<html lang="zh">
<head>
<title>Edges - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Control-Flow.html#Control-Flow" title="Control Flow">
<link rel="prev" href="Basic-Blocks.html#Basic-Blocks" title="Basic Blocks">
<link rel="next" href="Profile-information.html#Profile-information" title="Profile information">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Edges"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Profile-information.html#Profile-information">Profile information</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Basic-Blocks.html#Basic-Blocks">Basic Blocks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Control-Flow.html#Control-Flow">Control Flow</a>
<hr>
</div>

<h3 class="section">15.2 边</h3>

<p><a name="index-edge-in-the-flow-graph-3144"></a><a name="index-edge-3145"></a><!-- Edges represent possible control flow transfers from the end of some -->
<!-- basic block A to the head of another basic block B@.  We say that A is -->
<!-- a predecessor of B, and B is a successor of A@.  Edges are represented -->
<!-- in GCC with the @code{edge} data type.  Each @code{edge} acts as a -->
<!-- link between two basic blocks: the @code{src} member of an edge -->
<!-- points to the predecessor basic block of the @code{dest} basic block. -->
<!-- The members @code{preds} and @code{succs} of the @code{basic_block} data -->
<!-- type point to type-safe vectors of edges to the predecessors and -->
<!-- successors of the block. -->
边表示从某个基本块A的结束到另一个基本块B的开头的可能的控制流转换。我们称A是B的前驱，B是A的后继。在GCC中，边由<code>edge</code>数据类型表示。每个<code>edge</code>作为两个基本块之间的链接：<code>edge</code>的<code>src</code>成员指向<code>dest</code>的前驱基本块。数据类型<code>basic_block</code>的成员<code>preds</code>和<code>succs</code>，指向块的前驱边向量和后继边向量。

 <p><a name="index-edge-iterators-3146"></a><!-- When walking the edges in an edge vector, @dfn{edge iterators} should -->
<!-- be used.  Edge iterators are constructed using the -->
<!-- @code{edge_iterator} data structure and several methods are available -->
<!-- to operate on them: -->
当在一个边向量中访问边时，应该使用边迭代器。边迭代器由<code>edge_iterator</code>数据结构和一些可以使用的操作构成：

     <dl>
<dt><code>ei_start</code><a name="index-ei_005fstart-3147"></a><dd><!-- This function initializes an @code{edge_iterator} that points to the -->
<!-- first edge in a vector of edges. -->
该函数初始化一个指向边向量中第一个边的<code>edge_iterator</code>。

     <br><dt><code>ei_last</code><a name="index-ei_005flast-3148"></a><dd><!-- This function initializes an @code{edge_iterator} that points to the -->
<!-- last edge in a vector of edges. -->
该函数初始化一个指向边向量中最后一个边的<code>edge_iterator</code>。

     <br><dt><code>ei_end_p</code><a name="index-ei_005fend_005fp-3149"></a><dd><!-- This predicate is @code{true} if an @code{edge_iterator} represents -->
<!-- the last edge in an edge vector. -->
如果<code>edge_iterator</code>表示边向量中的最后一个边，则该断言为<code>true</code>。

     <br><dt><code>ei_one_before_end_p</code><a name="index-ei_005fone_005fbefore_005fend_005fp-3150"></a><dd><!-- This predicate is @code{true} if an @code{edge_iterator} represents -->
<!-- the second last edge in an edge vector. -->
如果<code>edge_iterator</code>表示边向量中的倒数第二个边，则该断言为<code>true</code>。

     <br><dt><code>ei_next</code><a name="index-ei_005fnext-3151"></a><dd><!-- This function takes a pointer to an @code{edge_iterator} and makes it -->
<!-- point to the next edge in the sequence. -->
该函数接受一个指向<code>edge_iterator</code>的指针，并使其指向序列中的下一个边。

     <br><dt><code>ei_prev</code><a name="index-ei_005fprev-3152"></a><dd><!-- This function takes a pointer to an @code{edge_iterator} and makes it -->
<!-- point to the previous edge in the sequence. -->
该函数接受一个指向<code>edge_iterator</code>的指针，并使其指向序列中的上一个边。

     <br><dt><code>ei_edge</code><a name="index-ei_005fedge-3153"></a><dd><!-- This function returns the @code{edge} currently pointed to by an -->
<!-- @code{edge_iterator}. -->
该函数返回由<code>edge_iterator</code>当前指向的<code>edge</code>。

     <br><dt><code>ei_safe_safe</code><a name="index-ei_005fsafe_005fsafe-3154"></a><dd><!-- This function returns the @code{edge} currently pointed to by an -->
<!-- @code{edge_iterator}, but returns @code{NULL} if the iterator is -->
<!-- pointing at the end of the sequence.  This function has been provided -->
<!-- for existing code makes the assumption that a @code{NULL} edge -->
<!-- indicates the end of the sequence. -->
该函数返回由<code>edge_iterator</code>当前指向的<code>edge</code>，但是如果迭代器指向序列的结尾时，则返回<code>NULL</code>。该函数是为现有的代码提供的，这些代码假设用<code>NULL</code>边来表示序列的结尾。
</dl>

<!-- The convenience macro @code{FOR_EACH_EDGE} can be used to visit all of -->
<!-- the edges in a sequence of predecessor or successor edges.  It must -->
<!-- not be used when an element might be removed during the traversal, -->
<!-- otherwise elements will be missed.  Here is an example of how to use -->
<!-- the macro: -->
 <p>宏<code>FOR_EACH_EDGE</code>可以方便的用来访问前驱边或后继边序列。当在遍历中会移除掉某个元素时，不要使用该宏，否则会错过这些元素。这里有一个如何使用该宏的例子：

<pre class="smallexample">     edge e;
     edge_iterator ei;
     
     FOR_EACH_EDGE (e, ei, bb-&gt;succs)
       {
          if (e-&gt;flags &amp; EDGE_FALLTHRU)
            break;
       }
</pre>
 <p><a name="index-fall_002dthru-3155"></a><!-- There are various reasons why control flow may transfer from one block -->
<!-- to another.  One possibility is that some instruction, for example a -->
<!-- @code{CODE_LABEL}, in a linearized instruction stream just always -->
<!-- starts a new basic block.  In this case a @dfn{fall-thru} edge links -->
<!-- the basic block to the first following basic block.  But there are -->
<!-- several other reasons why edges may be created.  The @code{flags} -->
<!-- field of the @code{edge} data type is used to store information -->
<!-- about the type of edge we are dealing with.  Each edge is of one of -->
<!-- the following types: -->
有许多原因会导致控制流从一个块传递到另一个。一种可能是某条指令，例如<code>CODE_LABEL</code>，在线形的指令流中，总是起始一个新基本块。在这种情况下，一个<dfn>fall-thru</dfn>边将基本块与随后的第一个基本块相连。不过还有许多其它原因会导致边被创建。<code>edge</code>数据类型的<code>flags</code>域用于存储我们正在处理的边的类型信息。每个边都具有下列类型之一：

     <dl>
<dt><em>jump</em><dd><!-- No type flags are set for edges corresponding to jump instructions. -->
<!-- These edges are used for unconditional or conditional jumps and in -->
<!-- RTL also for table jumps.  They are the easiest to manipulate as they -->
<!-- may be freely redirected when the flow graph is not in SSA form. -->
与跳转指令相关的边没有被设置类型标识。这些边用于无条件或有条件跳转，以及RTL中还有表跳转。它们是最容易操作的，因为当流图不为SSA形式的时候，可以自由重定向。

     <br><dt><em>fall-thru</em><dd><a name="index-EDGE_005fFALLTHRU_002c-force_005fnonfallthru-3156"></a><!-- Fall-thru edges are present in case where the basic block may continue -->
<!-- execution to the following one without branching.  These edges have -->
<!-- the @code{EDGE_FALLTHRU} flag set.  Unlike other types of edges, these -->
<!-- edges must come into the basic block immediately following in the -->
<!-- instruction stream.  The function @code{force_nonfallthru} is -->
<!-- available to insert an unconditional jump in the case that redirection -->
<!-- is needed.  Note that this may require creation of a new basic block. -->
<!-- Fall-thru边存在于当基本块不需要分支而是继续执行随后的块的时候。 -->
这些边的标志设为<code>EDGE_FALLTHRU</code>。不像其它类型的边，这些边必须直接进入基本块的指令流中。函数<code>force_nonfallthru</code>可以用于在需要重定向时插入一个无条件跳转。注意这可能需要创建一个新基本块。

     <br><dt><em>exception handling</em><dd><a name="index-exception-handling-3157"></a><a name="index-EDGE_005fABNORMAL_002c-EDGE_005fEH-3158"></a><!-- Exception handling edges represent possible control transfers from a -->
<!-- trapping instruction to an exception handler.  The definition of -->
<!-- ``trapping'' varies.  In C++, only function calls can throw, but for -->
<!-- Java, exceptions like division by zero or segmentation fault are -->
<!-- defined and thus each instruction possibly throwing this kind of -->
<!-- exception needs to be handled as control flow instruction.  Exception -->
<!-- edges have the @code{EDGE_ABNORMAL} and @code{EDGE_EH} flags set. -->
异常处理边表示可能的控制转移，从一个陷门指令到一个异常处理器。
关于“trapping”定义不尽相同。在C++中，只有函数调用能够抛出异常，
但是对于Java，像除0或者段错误都被定义为异常，
并且因此每条指令都可能抛出这种需要处理的异常。
异常边设置了<code>EDGE_ABNORMAL</code>和<code>EDGE_EH</code>标识。

     <p><a name="index-purge_005fdead_005fedges-3159"></a><!-- When updating the instruction stream it is easy to change possibly -->
<!-- trapping instruction to non-trapping, by simply removing the exception -->
<!-- edge.  The opposite conversion is difficult, but should not happen -->
<!-- anyway.  The edges can be eliminated via @code{purge_dead_edges} call. -->
当更新指令流时，能够容易的将可能trapping的指令转换成non-traaping，
通过简单的将异常边移除。相反的转换比较困难，但是是不会发生的。
可以通过调用<code>purge_dead_edges</code>来消除边。

     <p><a name="index-REG_005fEH_005fREGION_002c-EDGE_005fABNORMAL_005fCALL-3160"></a><!-- In the RTL representation, the destination of an exception edge is -->
<!-- specified by @code{REG_EH_REGION} note attached to the insn. -->
<!-- In case of a trapping call the @code{EDGE_ABNORMAL_CALL} flag is set -->
<!-- too.  In the @code{tree} representation, this extra flag is not set. -->
在RTL表示中，异常边的目的地由附加在insn上的注解<code>REG_EH_REGION</code>来指定。
在trapping调用的情况下，还设置了<code>EDGE_ABNORMAL_CALL</code>标识。
在<code>tree</code>表示中，该额外的标识没有被设置。

     <p><a name="index-may_005ftrap_005fp_002c-tree_005fcould_005ftrap_005fp-3161"></a><!-- In the RTL representation, the predicate @code{may_trap_p} may be used -->
<!-- to check whether instruction still may trap or not.  For the tree -->
<!-- representation, the @code{tree_could_trap_p} predicate is available, -->
<!-- but this predicate only checks for possible memory traps, as in -->
<!-- dereferencing an invalid pointer location. -->
在RTL表示中，断言<code>may_trap_p</code>可以用来检测指令是否还可能trap。
对于tree表示，可以用<code>tree_could_trap_p</code>，
不过该断言只检测可能的内存trap，像在废除一个无效的指针地址。

     <br><dt><em>sibling calls</em><dd><a name="index-sibling-call-3162"></a><a name="index-EDGE_005fABNORMAL_002c-EDGE_005fSIBCALL-3163"></a><!-- Sibling calls or tail calls terminate the function in a non-standard -->
<!-- way and thus an edge to the exit must be present. -->
<!-- @code{EDGE_SIBCALL} and @code{EDGE_ABNORMAL} are set in such case. -->
<!-- These edges only exist in the RTL representation. -->
兄弟调用或者尾调用以非标准的方式终止函数，
并且因此必须存在一个引向出口的边。
<code>EDGE_SIBCALL</code>和<code>EDGE_ABNORMAL</code>在这种情况下被设置。
这些边只存在于RTL表示中。

     <br><dt><em>computed jumps</em><dd><a name="index-computed-jump-3164"></a><a name="index-EDGE_005fABNORMAL-3165"></a><!-- Computed jumps contain edges to all labels in the function referenced -->
<!-- from the code.  All those edges have @code{EDGE_ABNORMAL} flag set. -->
<!-- The edges used to represent computed jumps often cause compile time -->
<!-- performance problems, since functions consisting of many taken labels -->
<!-- and many computed jumps may have @emph{very} dense flow graphs, so -->
<!-- these edges need to be handled with special care.  During the earlier -->
<!-- stages of the compilation process, GCC tries to avoid such dense flow -->
<!-- graphs by factoring computed jumps.  For example, given the following -->
<!-- series of jumps, -->
计算跳转包含了引向函数中代码引用的所有标号的边。
所有这些边都设置了<code>EDGE_ABNORMAL</code>标识。
用来表示计算跳转的边通常会造成编译时间性能问题，
因为函数有许多标号组成，许多计算跳转可能具有密集的流图，
所以这些边需要特别仔细的处理。在编译过程的早期阶段，
GCC尝试避免这样的密集流图，通过因子化计算跳转。
例如，给定下列跳转，

     <pre class="smallexample">            goto *x;
            [ ... ]
          
            goto *x;
            [ ... ]
          
            goto *x;
            [ ... ]
</pre>
     <p class="noindent"><!-- factoring the computed jumps results in the following code sequence -->
<!-- which has a much simpler flow graph: -->
将计算跳转提取公因子，会产生具有比较简单流图的代码序列：

     <pre class="smallexample">            goto y;
            [ ... ]
          
            goto y;
            [ ... ]
          
            goto y;
            [ ... ]
          
          y:
            goto *x;
</pre>
     <!-- However, the classic problem with this transformation is that it has a -->
     <!-- runtime cost in there resulting code: An extra jump.  Therefore, the -->
     <!-- computed jumps are un-factored in the later passes of the compiler. -->
     <!-- Be aware of that when you work on passes in that area.  There have -->
     <!-- been numerous examples already where the compile time for code with -->
     <!-- unfactored computed jumps caused some serious headaches. -->
     <p>但是，这种转换的典型问题是产生的结果代码具有运行时代价：
一个额外的跳转。因此计算跳转在编译器之后的过程里被un-factored。
当你工作于这些过程上时，需要注意。曾有许多已存的例子，
即对未公因子化的计算跳转编译时造成的头痛之事。

     <br><dt><em>nonlocal goto handlers</em><dd><a name="index-nonlocal-goto-handler-3166"></a><a name="index-EDGE_005fABNORMAL_002c-EDGE_005fABNORMAL_005fCALL-3167"></a><!-- GCC allows nested functions to return into caller using a @code{goto} -->
<!-- to a label passed to as an argument to the callee.  The labels passed -->
<!-- to nested functions contain special code to cleanup after function -->
<!-- call.  Such sections of code are referred to as ``nonlocal goto -->
<!-- receivers''.  If a function contains such nonlocal goto receivers, an -->
<!-- edge from the call to the label is created with the -->
<!-- @code{EDGE_ABNORMAL} and @code{EDGE_ABNORMAL_CALL} flags set. -->
GCC允许嵌套函数使用<code>goto</code>到一个通过参数传给被调用者的标号的方式来返回到调用者那里。
传给嵌套函数的标号包含了特定的代码用来在函数调用之后进行清理工作。
这段代码被称为“nonlocal goto receivers”。
如果一个函数包含这样的非局部goto接受者，一个从调用到标号的边被创建，
并设置了<code>EDGE_ABNORMAL</code>和<code>EDGE_ABNORMAL_CALL</code>标识。

     <br><dt><em>function entry points</em><dd><a name="index-function-entry-point_002c-alternate-function-entry-point-3168"></a><a name="index-LABEL_005fALTERNATE_005fNAME-3169"></a><!-- By definition, execution of function starts at basic block 0, so there -->
<!-- is always an edge from the @code{ENTRY_BLOCK_PTR} to basic block 0. -->
<!-- There is no @code{tree} representation for alternate entry points at -->
<!-- this moment.  In RTL, alternate entry points are specified by -->
<!-- @code{CODE_LABEL} with @code{LABEL_ALTERNATE_NAME} defined.  This -->
<!-- feature is currently used for multiple entry point prologues and is -->
<!-- limited to post-reload passes only.  This can be used by back-ends to -->
<!-- emit alternate prologues for functions called from different contexts. -->
<!-- In future full support for multiple entry functions defined by Fortran -->
<!-- 90 needs to be implemented. -->
根据定义，函数执行起始于基本块0，所以总有一个边从<code>ENTRY_BLOCK_PTR</code>到基本块0。目前，对备用入口点没有<code>tree</code>表示。在RTL里，备用入口点通过定义了<code>LABEL_ALTERNATE_NAME</code>的<code>CODE_LABEL</code>指定。这能够被后端用于为通过不同上下文调用函数而生成备用prologues。将来，Fortran90定义的多入口函数的完全支持需要被实现。

     <br><dt><em>function exits</em><dd><!-- In the pre-reload representation a function terminates after the last -->
<!-- instruction in the insn chain and no explicit return instructions are -->
<!-- used.  This corresponds to the fall-thru edge into exit block.  After -->
<!-- reload, optimal RTL epilogues are used that use explicit (conditional) -->
<!-- return instructions that are represented by edges with no flags set. -->
在pre-reload表示中，函数终止于insn链中的最后一条指令，并且没有显式的返回指令。标记对应于进入出口块的fall-thru边。reload之后，最佳的RTL结尾部分（epilogues）会被使用，其会使用显式的（有条件的）返回指令，并使用没有标记设置的边来表示。
</dl>

<!-- @node Profile information -->
<!-- @section Profile information -->
 </body></html>

