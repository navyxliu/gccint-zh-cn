<html lang="zh">
<head>
<title>Loop manipulation - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Loop-Analysis-and-Representation.html#Loop-Analysis-and-Representation" title="Loop Analysis and Representation">
<link rel="prev" href="Loop-querying.html#Loop-querying" title="Loop querying">
<link rel="next" href="LCSSA.html#LCSSA" title="LCSSA">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Loop-manipulation"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="LCSSA.html#LCSSA">LCSSA</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Loop-querying.html#Loop-querying">Loop querying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Loop-Analysis-and-Representation.html#Loop-Analysis-and-Representation">Loop Analysis and Representation</a>
<hr>
</div>

<h3 class="section">14.3 循环操作</h3>

<p><a name="index-Loop-manipulation-3123"></a>
<!-- The loops tree can be manipulated using the following functions: -->
可以使用下列函数来操作循环树：

<!-- @itemize -->
<!-- @item @code{flow_loop_tree_node_add}: Adds a node to the tree. -->
<!-- @item @code{flow_loop_tree_node_remove}: Removes a node from the tree. -->
<!-- @item @code{add_bb_to_loop}: Adds a basic block to a loop. -->
<!-- @item @code{remove_bb_from_loops}: Removes a basic block from loops. -->
<!-- @end itemize -->
     <ul>
<li><code>flow_loop_tree_node_add</code>: 向树中增加一个节点。
<li><code>flow_loop_tree_node_remove</code>: 从树中移除一个节点。
<li><code>add_bb_to_loop</code>: 向循环增加一个基本块。
<li><code>remove_bb_from_loops</code>: 从循环中移除一个基本块。
</ul>

<!-- Most low-level CFG functions update loops automatically.  The following -->
<!-- functions handle some more complicated cases of CFG manipulations: -->
 <p>大多数低级别的CFG函数会自动更新循环。下列函数用来处理一些比较复杂的CFG操作情况：

<!-- @itemize -->
<!-- @item @code{remove_path}: Removes an edge and all blocks it dominates. -->
<!-- @item @code{split_loop_exit_edge}: Splits exit edge of the loop, -->
<!-- ensuring that PHI node arguments remain in the loop (this ensures that -->
<!-- loop-closed SSA form is preserved).  Only useful on GIMPLE. -->
<!-- @end itemize -->
     <ul>
<li><code>remove_path</code>: 移除一个边，以及它支配的所有块。
<li><code>split_loop_exit_edge</code>:
拆分循环的出口边，以确保PHI节点参数保留在循环中（确保使用了循环封闭SSA形式）。只用于GIMPLE。
</ul>

<!-- Finally, there are some higher-level loop transformations implemented. -->
<!-- While some of them are written so that they should work on non-innermost -->
<!-- loops, they are mostly untested in that case, and at the moment, they -->
<!-- are only reliable for the innermost loops: -->
 <p>最后，有一些高层的循环转换被实现。虽然其中一些能够工作于非最内层循环，但是大多数并没有对这种情况进行过测试，目前，它们只对最内层循环可靠：

<!-- @itemize -->
<!-- @item @code{create_iv}: Creates a new induction variable.  Only works on -->
<!-- GIMPLE@.  @code{standard_iv_increment_position} can be used to find a -->
<!-- suitable place for the iv increment. -->
<!-- @item @code{duplicate_loop_to_header_edge}, -->
<!-- @code{tree_duplicate_loop_to_header_edge}: These functions (on RTL and -->
<!-- on GIMPLE) duplicate the body of the loop prescribed number of times on -->
<!-- one of the edges entering loop header, thus performing either loop -->
<!-- unrolling or loop peeling.  @code{can_duplicate_loop_p} -->
<!-- (@code{can_unroll_loop_p} on GIMPLE) must be true for the duplicated -->
<!-- loop. -->
<!-- @item @code{loop_version}, @code{tree_ssa_loop_version}: These function -->
<!-- create a copy of a loop, and a branch before them that selects one of -->
<!-- them depending on the prescribed condition.  This is useful for -->
<!-- optimizations that need to verify some assumptions in runtime (one of -->
<!-- the copies of the loop is usually left unchanged, while the other one is -->
<!-- transformed in some way). -->
<!-- @item @code{tree_unroll_loop}: Unrolls the loop, including peeling the -->
<!-- extra iterations to make the number of iterations divisible by unroll -->
<!-- factor, updating the exit condition, and removing the exits that now -->
<!-- cannot be taken.  Works only on GIMPLE. -->
<!-- @end itemize -->
     <ul>
<li><code>create_iv</code>:
创建一个新的归约变量。只工作在GIMPLE上。
<code>standard_iv_increment_position</code>能够被用来为iv增量找到合适的位置。
<li><code>duplicate_loop_to_header_edge</code>,
<code>tree_duplicate_loop_to_header_edge</code>:
这些函数（在RTL和GIMPLE之上）在进入循环头的边上对循环体复制规定的次数，
从而执行了循环展开或loop peeling。对于复制的循环，
<code>can_duplicate_loop_p</code>（GIMPLE之上为<code>can_unroll_loop_p</code>）必须为真。
<li><code>loop_version</code>, <code>tree_ssa_loop_version</code>:
这些函数创建一个循环的复本，以及在它们之前的一个分支跳转，
从而可以根据规定的条件来选择它们。这对需要在运行时检验一些假设的优化很有帮助
（循环的一个复本通常不做变换，而另一个通过某种方式进行转换）。
<li><code>tree_unroll_loop</code>:
展开循环，包括剥离额外的迭代，从而使得迭代次数可以由展开因子划分，
更新出口条件，以及移除不会经过的出口。只在GIMPLE上工作。
</ul>

<!-- @node LCSSA -->
<!-- @section Loop-closed SSA form -->
 </body></html>

