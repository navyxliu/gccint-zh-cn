<html lang="zh">
<head>
<title>Test Idioms - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Testsuites.html#Testsuites" title="Testsuites">
<link rel="next" href="Test-Directives.html#Test-Directives" title="Test Directives">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Test-Idioms"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Test-Directives.html#Test-Directives">Test Directives</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Testsuites.html#Testsuites">Testsuites</a>
<hr>
</div>

<h3 class="section">7.1 测试包代码中使用的习惯用法</h3>

<!-- In general, C testcases have a trailing @file{-@var{n}.c}, starting -->
<!-- with @file{-1.c}, in case other testcases with similar names are added -->
<!-- later.  If the test is a test of some well-defined feature, it should -->
<!-- have a name referring to that feature such as -->
<!-- @file{@var{feature}-1.c}.  If it does not test a well-defined feature -->
<!-- but just happens to exercise a bug somewhere in the compiler, and a -->
<!-- bug report has been filed for this bug in the GCC bug database, -->
<!-- @file{pr@var{bug-number}-1.c} is the appropriate form of name. -->
<!-- Otherwise (for miscellaneous bugs not filed in the GCC bug database), -->
<!-- and previously more generally, test cases are named after the date on -->
<!-- which they were added.  This allows people to tell at a glance whether -->
<!-- a test failure is because of a recently found bug that has not yet -->
<!-- been fixed, or whether it may be a regression, but does not give any -->
<!-- other information about the bug or where discussion of it may be -->
<!-- found.  Some other language testsuites follow similar conventions. -->
<p>通常，C 测试用例以<samp><span class="file">-</span><var>n</var><span class="file">.c</span></samp>结尾，并且从<samp><span class="file">-1.c</span></samp>开始，
以便于以后增加其它具有类似名字的测试用例。
如果是测试一些明确定义的特征，则测试的名字应该指出这个特征，
例如<samp><var>feature</var><span class="file">-1.c</span></samp>。如果不是测试一个明确定义的特征，
而只是检验在编译器中存在的，并且是在GCC bug库中归档的bug，
则可以使用<samp><span class="file">pr</span><var>bug-number</var><span class="file">-1.c</span></samp>这样的名字形式。
否则（对于在GCC bug库中没有归档的各种bug），
测试用例根据它们被添加的日期来命名，这种情况在以前更加常见。
这样使人们能够一眼看出一个测试失败是由于一个新发现并且还没有被修复的bug造成的，
还是由于一个回退错误造成的，但它并没有给出关于bug的其它信息，
以及从哪里可以找到相关的讨论。一些其它语言的测试包也遵守类似的惯例。

<!-- In the @file{gcc.dg} testsuite, it is often necessary to test that an -->
<!-- error is indeed a hard error and not just a warning-for example, -->
<!-- where it is a constraint violation in the C standard, which must -->
<!-- become an error with @option{-pedantic-errors}.  The following idiom, -->
<!-- where the first line shown is line @var{line} of the file and the line -->
<!-- that generates the error, is used for this: -->
 <p>在<samp><span class="file">gcc.dg</span></samp>测试包中，通常需要测试一个错误确实是硬件错误，
而不只是一个警告——例如，在C标准中的violatile限定，
在有<samp><span class="option">-pedantic-errors</span></samp>的时候必须为一个错误。为此，
可以使用下面的习惯用法，其中第一行为产生错误的文件的行<var>line</var>。

<pre class="smallexample">     /* { dg-bogus "warning" "warning in place of error" } */
     /* { dg-error "<var>regexp</var>" "<var>message</var>" { target *-*-* } <var>line</var> } */
</pre>
 <!-- It may be necessary to check that an expression is an integer constant -->
<!-- expression and has a certain value.  To check that @code{@var{E}} has -->
<!-- value @code{@var{V}}, an idiom similar to the following is used: -->
 <p>可能需要检查一个表达式为整数常量表达式，并且具有一个特定的值。
要检查<var>E</var>具有值<var>V</var>，可以使用类似下面的习惯用法：

<pre class="smallexample">     char x[((E) == (V) ? 1 : -1)];
</pre>
 <!-- In @file{gcc.dg} tests, @code{__typeof__} is sometimes used to make -->
<!-- assertions about the types of expressions.  See, for example, -->
<!-- @file{gcc.dg/c99-condexpr-1.c}.  The more subtle uses depend on the -->
<!-- exact rules for the types of conditional expressions in the C -->
<!-- standard; see, for example, @file{gcc.dg/c99-intconst-1.c}. -->
 <p>在<samp><span class="file">gcc.dg</span></samp>测试中，<code>__typeof__</code>有时被用于表达式类型的断言。
例如，可以参见<samp><span class="file">gcc.dg/c99-condexpr-1.c</span></samp>。
更加巧妙的用法依靠了C标准中条件表达式类型的确切规则；
例如，可以参见<samp><span class="file">gcc.dg/c99-intconst-1.c</span></samp>。

<!-- It is useful to be able to test that optimizations are being made -->
<!-- properly.  This cannot be done in all cases, but it can be done where -->
<!-- the optimization will lead to code being optimized away (for example, -->
<!-- where flow analysis or alias analysis should show that certain code -->
<!-- cannot be called) or to functions not being called because they have -->
<!-- been expanded as built-in functions.  Such tests go in -->
<!-- @file{gcc.c-torture/execute}.  Where code should be optimized away, a -->
<!-- call to a nonexistent function such as @code{link_failure ()} may be -->
<!-- inserted; a definition -->
 <p>如果能够测试优化被做的很适当会很有帮助。这并不能在所有情况下都能做到，
但对于可以使得代码被优化掉的情况
（例如，流分析或别名分析应该显示那样的代码不会被调用），
或者函数将不被调用，因为它们已经被扩展为内建的函数时，是可以做到的。
这样的测试在<samp><span class="file">gcc.c-torture/execute</span></samp>中。
在将要被优化掉的代码的地方，可以插入一个像<code>link_failure ()</code>
这样的对一个不存在的函数的调用；并且还需要如下定义，

<pre class="smallexample">     #ifndef __OPTIMIZE__
     void
     link_failure (void)
     {
       abort ();
     }
     #endif
</pre>
 <p class="noindent"><!-- will also be needed so that linking still succeeds when the test is -->
<!-- run without optimization.  When all calls to a built-in function -->
<!-- should have been optimized and no calls to the non-built-in version of -->
<!-- the function should remain, that function may be defined as -->
<!-- @code{static} to call @code{abort ()} (although redeclaring a function -->
<!-- as static may not work on all targets). -->
从而使得当测试在没有优化而运行时，连接依然成功。
当对一个内建函数的所有调用都已经被优化，并且不会剩下对函数的非内建版本的调用时，
那个函数可以定义为<code>static</code>，并且调用<code>abort ()</code>
（虽然将函数声明为静态的可能不会在所有的目标上工作）。

<!-- All testcases must be portable.  Target-specific testcases must have -->
<!-- appropriate code to avoid causing failures on unsupported systems; -->
<!-- unfortunately, the mechanisms for this differ by directory. -->
 <p>所有测试用例都必须是可移植的。
目标特定的测试用例必须具有适当的代码来避免在不支持的系统上引起失败；
不幸的是，这种机制随目录有所不同。

<!-- FIXME: discuss non-C testsuites here. -->
 <p>FIXME: 讨论一下非C的测试包。

<!-- @node Test Directives -->
<!-- @section Directives used within DejaGnu tests -->
 </body></html>

