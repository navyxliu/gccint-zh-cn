@c Copyright (C) 1988,1989,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,
@c 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@en @node Target Macros
@en @chapter Target Description Macros and Functions
@node Target Macros
@chapter 目标机描述宏和函数
@cindex machine description macros
@cindex target description macros
@cindex macros, target description
@cindex @file{tm.h} macros

@en In addition to the file @file{@var{machine}.md}, a machine description
@en includes a C header file conventionally given the name
@en @file{@var{machine}.h} and a C source file named @file{@var{machine}.c}.
@en The header file defines numerous macros that convey the information
@en about the target machine that does not fit into the scheme of the
@en @file{.md} file.  The file @file{tm.h} should be a link to
@en @file{@var{machine}.h}.  The header file @file{config.h} includes
@en @file{tm.h} and most compiler source files include @file{config.h}.  The
@en source file defines a variable @code{targetm}, which is a structure
@en containing pointers to functions and data relating to the target
@en machine.  @file{@var{machine}.c} should also contain their definitions,
@en if they are not defined elsewhere in GCC, and other functions called
@en through the macros defined in the @file{.h} file.
除了文件@file{@var{machine}.md}，
机器描述还包括一个通常名为@file{@var{machine}.h}的C头文件和一个名为
@file{@var{machine}.c}的C源文件。
头文件定义了许多用来传达不适合@file{.md}文件框架的目标机器信息的宏。
文件@file{tm.h}应该为@file{@var{machine}.h}的一个链接。
头文件@file{config.h}包含@file{tm.h}，
并且大多数编译器源文件包含@file{config.h}。
源文件定义了变量@code{targetm}，
其为一个包含了与目标机器相关的函数指针和数据的结构体。
如果它们没有在GCC中的其它地方定义，@file{@var{machine}.c}还应该包含它们的定义，
其它通过宏调用的函数在@file{.h}文件中定义。

@en @menu
@en * Target Structure::    The @code{targetm} variable.
@en * Driver::              Controlling how the driver runs the compilation passes.
@en * Run-time Target::     Defining @samp{-m} options like @option{-m68000} and @option{-m68020}.
@en * Per-Function Data::   Defining data structures for per-function information.
@en * Storage Layout::      Defining sizes and alignments of data.
@en * Type Layout::         Defining sizes and properties of basic user data types.
@en * Registers::           Naming and describing the hardware registers.
@en * Register Classes::    Defining the classes of hardware registers.
@en * Old Constraints::     The old way to define machine-specific constraints.
@en * Stack and Calling::   Defining which way the stack grows and by how much.
@en * Varargs::             Defining the varargs macros.
@en * Trampolines::         Code set up at run time to enter a nested function.
@en * Library Calls::       Controlling how library routines are implicitly called.
@en * Addressing Modes::    Defining addressing modes valid for memory operands.
@en * Anchored Addresses::  Defining how @option{-fsection-anchors} should work.
@en * Condition Code::      Defining how insns update the condition code.
@en * Costs::               Defining relative costs of different operations.
@en * Scheduling::          Adjusting the behavior of the instruction scheduler.
@en * Sections::            Dividing storage into text, data, and other sections.
@en * PIC::                 Macros for position independent code.
@en * Assembler Format::    Defining how to write insns and pseudo-ops to output.
@en * Debugging Info::      Defining the format of debugging output.
@en * Floating Point::      Handling floating point for cross-compilers.
@en * Mode Switching::      Insertion of mode-switching instructions.
@en * Target Attributes::   Defining target-specific uses of @code{__attribute__}.
@en * Emulated TLS::        Emulated TLS support.
@en * MIPS Coprocessors::   MIPS coprocessor support and how to customize it.
@en * PCH Target::          Validity checking for precompiled headers.
@en * C++ ABI::             Controlling C++ ABI changes.
@en * Named Address Spaces:: Adding support for named address spaces
@en * Misc::                Everything else.
@en @end menu
@menu
* Target Structure::	@code{targetm}变量
* Driver::		控制驱动程序如何运行编译过程
* Run-time Target::	定义像@option{-m68000}和@option{-m68020}这样的@samp{-m}选项
* Per-Function Data::	定义每个函数的信息的数据结构体
* Storage Layout::	定义数据的大小和对齐方式
* Type Layout::		定义基本用户数据类型的大小和属性
* Registers::		命名和描述硬件寄存器
* Register Classes::	定义硬件寄存器的类别
* Old Constraints::	定义机器特定约束的旧方式
* Stack and Calling::	定义栈增长的方式和数量
* Varargs::		定义varargs宏
* Trampolines::		运行时建立的进入嵌套函数的代码
* Library Calls::	控制库函数如何被隐式调用
* Addressing Modes::	定义对内存操作数有效的寻址方式
* Anchored Addresses::	定义@option{-fsection-anchors}如何工作
* Condition Code::	定义insns如何更新条件代码
* Costs::		定义不同操作的相对开销
* Scheduling::		调整指令调度器的行为
* Sections::		将存储拆分到代码，数据和其它的段
* PIC::			位置无关代码的宏
* Assembler Format::	定义如何输出insns和伪操作
* Debugging Info::	定义调试输出的格式
* Floating Point::	处理交叉编译器的浮点
* Mode Switching::	插入模式切换指令
* Target Attributes::	定义目标机特定的@code{__attribute__}用法
* Emulated TLS::	模拟对TLS的支持
* MIPS Coprocessors::	对MIPS协处理器的支持，以及如何自定义
* PCH Target::		对预编译头文件的有效性检查
* C++ ABI::		控制C++ ABI的变动
* Named Address Spaces:: Adding support for named address spaces
* Misc::		其它
@end menu

@en @node Target Structure
@en @section The Global @code{targetm} Variable
@node Target Structure
@section 全局变量@code{targetm}
@cindex target hooks
@cindex target functions

@deftypevar {struct gcc_target} targetm
@en The target @file{.c} file must define the global @code{targetm} variable
@en which contains pointers to functions and data relating to the target
@en machine.  The variable is declared in @file{target.h};
@en @file{target-def.h} defines the macro @code{TARGET_INITIALIZER} which is
@en used to initialize the variable, and macros for the default initializers
@en for elements of the structure.  The @file{.c} file should override those
@en macros for which the default definition is inappropriate.  For example:
目标机@file{.c}文件必须定义包含了目标机器相关的函数指针和数据的全局变量
@code{targetm}。该变量在@file{target.h}中声明；
@file{target-def.h}定义了用来初始化该变量的宏@code{TARGET_INITIALIZER}，
和结构体元素的缺省初始化宏。@file{.c}文件应该覆写这些缺省定义不合适的宏。例如：
@smallexample
#include "target.h"
#include "target-def.h"

/* @r{Initialize the GCC target structure.}  */

#undef TARGET_COMP_TYPE_ATTRIBUTES
#define TARGET_COMP_TYPE_ATTRIBUTES @var{machine}_comp_type_attributes

struct gcc_target targetm = TARGET_INITIALIZER;
@end smallexample
@end deftypevar

@en Where a macro should be defined in the @file{.c} file in this manner to
@en form part of the @code{targetm} structure, it is documented below as a
@en ``Target Hook'' with a prototype.  Many macros will change in future
@en from being defined in the @file{.h} file to being part of the
@en @code{targetm} structure.
其中，宏应该通过这种方式在@file{.c}文件中被定义，
从而成为@code{targetm}结构体的一部分。
该宏将在下面作为具有函数原型的“目标钩子”来介绍。
在@file{.h}.h文件中定义的许多宏将来都会改为@code{targetm}结构体的一部分。

@en @node Driver
@en @section Controlling the Compilation Driver, @file{gcc}
@node Driver
@section 控制编译驱动器，@file{gcc}
@cindex driver
@cindex controlling the compilation driver

@c prevent bad page break with this line
@en You can control the compilation driver.
你可以控制编译驱动器。 

@defmac SWITCH_TAKES_ARG (@var{char})
@en A C expression which determines whether the option @option{-@var{char}}
@en takes arguments.  The value should be the number of arguments that
@en option takes--zero, for many options.
一个C表达式，用来确定选项@option{-@var{char}}是否接受参数。
值应该为那个选项接受的参数个数，对于许多选项其为0。

@en By default, this macro is defined as
@en @code{DEFAULT_SWITCH_TAKES_ARG}, which handles the standard options
@en properly.  You need not define @code{SWITCH_TAKES_ARG} unless you
@en wish to add additional options which take arguments.  Any redefinition
@en should call @code{DEFAULT_SWITCH_TAKES_ARG} and then check for
@en additional options.
缺省情况下，该宏被定义为@code{DEFAULT_SWITCH_TAKES_ARG}，
其可以正常处理标准的选项。除非你希望增加额外的接受参数的选项，
否则不需要定义@code{SWITCH_TAKES_ARG}。
任何重定义都应该先调用@code{DEFAULT_SWITCH_TAKES_ARG}，然后再检查额外的选项。
@end defmac

@defmac WORD_SWITCH_TAKES_ARG (@var{name})
@en A C expression which determines whether the option @option{-@var{name}}
@en takes arguments.  The value should be the number of arguments that
@en option takes--zero, for many options.  This macro rather than
@en @code{SWITCH_TAKES_ARG} is used for multi-character option names.
一个C表达式，用来确定选项@option{-@var{name}}是否接受参数。
值应该为那个选项接受的参数个数，对于许多选项其为0。
该宏不同于@code{SWITCH_TAKES_ARG}，是用于选项名为多个字符的情况。

@en By default, this macro is defined as
@en @code{DEFAULT_WORD_SWITCH_TAKES_ARG}, which handles the standard options
@en properly.  You need not define @code{WORD_SWITCH_TAKES_ARG} unless you
@en wish to add additional options which take arguments.  Any redefinition
@en should call @code{DEFAULT_WORD_SWITCH_TAKES_ARG} and then check for
@en additional options.
缺省情况下，该宏被定义为@code{DEFAULT_WORD_SWITCH_TAKES_ARG}，
其可以正常处理标准的选项。除非你希望增加额外的接受参数的选项，
否则不需要定义@code{WORD_SWITCH_TAKES_ARG}。
任何重定义都应该先调用@code{DEFAULT_WORD_SWITCH_TAKES_ARG}，然后再检查额外的选项。
@end defmac

@defmac SWITCH_CURTAILS_COMPILATION (@var{char})
@en A C expression which determines whether the option @option{-@var{char}}
@en stops compilation before the generation of an executable.  The value is
@en boolean, nonzero if the option does stop an executable from being
@en generated, zero otherwise.
一个C表达式，用来确定选项@option{-@var{char}}是否在生成可执行程序之前停止编译。
值为布尔型，如果选项确实停止生成可执行程序则为非0，否则为0。

@en By default, this macro is defined as
@en @code{DEFAULT_SWITCH_CURTAILS_COMPILATION}, which handles the standard
@en options properly.  You need not define
@en @code{SWITCH_CURTAILS_COMPILATION} unless you wish to add additional
@en options which affect the generation of an executable.  Any redefinition
@en should call @code{DEFAULT_SWITCH_CURTAILS_COMPILATION} and then check
@en for additional options.
缺省情况下，该宏被定义为@code{DEFAULT_SWITCH_CURTAILS_COMPILATION}，
其可以正常处理标准的选项。除非你希望增加额外的影响可执行程序生成的选项，
否则不需要定义@code{SWITCH_CURTAILS_COMPILATION}。
任何重定义都应该先调用@code{DEFAULT_SWITCH_CURTAILS_COMPILATION}，
然后再检查额外的选项。
@end defmac

@defmac TARGET_OPTION_TRANSLATE_TABLE
@en If defined, a list of pairs of strings, the first of which is a
@en potential command line target to the @file{gcc} driver program, and the
@en second of which is a space-separated (tabs and other whitespace are not
@en supported) list of options with which to replace the first option.  The
@en target defining this list is responsible for assuring that the results
@en are valid.  Replacement options may not be the @code{--opt} style, they
@en must be the @code{-opt} style.  It is the intention of this macro to
@en provide a mechanism for substitution that affects the multilibs chosen,
@en such as one option that enables many options, some of which select
@en multilibs.  Example nonsensical definition, where @option{-malt-abi},
@en @option{-EB}, and @option{-mspoo} cause different multilibs to be chosen:
如果定义，则为字符串对（pairs of strings）列表，
其中第一个字符串为@file{gcc}驱动程序的一个可能的命令行目标，
第二个字符串为空格分隔的（不支持tab和其它whitespace）选项列表，
用来替换第一个选项。
定义该列表的目标机要负责确保结果是有效的。替换选项不可以为@code{--opt}风格的，
它们必须为@code{-opt}风格的。该宏的目的是为选择multilib提供一种替换机制，
例如通过一个选项可以打开许多选项，其中一些用来选择multilib。
例如，在下面这个无意义的定义中，
@option{-malt-abi}, @option{-EB}和@option{-mspoo}会导致不同的multilib被选择：

@smallexample
#define TARGET_OPTION_TRANSLATE_TABLE \
@{ "-fast",   "-march=fast-foo -malt-abi -I/usr/fast-foo" @}, \
@{ "-compat", "-EB -malign=4 -mspoo" @}
@end smallexample
@end defmac

@defmac DRIVER_SELF_SPECS
@en A list of specs for the driver itself.  It should be a suitable
@en initializer for an array of strings, with no surrounding braces.
驱动器本身的specs列表。其应该为一个字符串数组的适当的初始化值，
并且不使用大括号包裹。

@en The driver applies these specs to its own command line between loading
@en default @file{specs} files (but not command-line specified ones) and
@en choosing the multilib directory or running any subcommands.  It
@en applies them in the order given, so each spec can depend on the
@en options added by earlier ones.  It is also possible to remove options
@en using @samp{%<@var{option}} in the usual way.
驱动器将这些specs应用到它自己的命令行上，位于加载缺省@file{specs}文件
（而不是由命令行指定的）和选择multilib目录或者运行任何子命令之间。
驱动器按照给定的顺序来应用它们，所以每个spec可以依赖于先前增加的选项。
还可以使用通常的方式，用@samp{%<@var{option}}来移除选项。

@en This macro can be useful when a port has several interdependent target
@en options.  It provides a way of standardizing the command line so
@en that the other specs are easier to write.
当一个port具有多个相互依赖的目标机选项时，该宏会有帮助。
它提供了一种标准化命令行的方法，使得其它specs的书写变得容易些。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac OPTION_DEFAULT_SPECS
@en A list of specs used to support configure-time default options (i.e.@:
@en @option{--with} options) in the driver.  It should be a suitable initializer
@en for an array of structures, each containing two strings, without the
@en outermost pair of surrounding braces.
一个specs列表，用于支持驱动器中的配置时（configure-time）缺省选项
（即，@option{--with}选项）。
其应该为一个结构体数组的适当的初始化值，每个元素包含两个字符串，
并且不带有最外层的大括号对。

@en The first item in the pair is the name of the default.  This must match
@en the code in @file{config.gcc} for the target.  The second item is a spec
@en to apply if a default with this name was specified.  The string
@en @samp{%(VALUE)} in the spec will be replaced by the value of the default
@en everywhere it occurs.
字符串对的第一项为缺省名字。其必须匹配目标机的@file{config.gcc}中的代码。
第二项为一个spec，当那个缺省名字被指定的时候会被应用。
在spec中，字符串@samp{%(VALUE)}出现的所有地方都将被缺省值替换。

@en The driver will apply these specs to its own command line between loading
@en default @file{specs} files and processing @code{DRIVER_SELF_SPECS}, using
@en the same mechanism as @code{DRIVER_SELF_SPECS}.
驱动器将这些specs应用到它自己的命令行上，
位于加载缺省@file{specs}文件和处理@code{DRIVER_SELF_SPECS}之间，
使用与@code{DRIVER_SELF_SPECS}相同的机制。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac CPP_SPEC
@en A C string constant that tells the GCC driver program options to
@en pass to CPP@.  It can also specify how to translate options you
@en give to GCC into options for GCC to pass to the CPP@.
一个C字符串常量，告诉GCC驱动程序要传给CPP的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给CPP的选项。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac CPLUSPLUS_CPP_SPEC
@en This macro is just like @code{CPP_SPEC}, but is used for C++, rather
@en than C@.  If you do not define this macro, then the value of
@en @code{CPP_SPEC} (if any) will be used instead.
该宏类似于@code{CPP_SPEC}，只不过是用于C++而不是C。如果你不定义该宏，
则会使用@code{CPP_SPEC}的值（如果存在）来替代。
@end defmac

@defmac CC1_SPEC
@en A C string constant that tells the GCC driver program options to
@en pass to @code{cc1}, @code{cc1plus}, @code{f771}, and the other language
@en front ends.
@en It can also specify how to translate options you give to GCC into options
@en for GCC to pass to front ends.
一个C字符串常量，告诉GCC驱动程序要传给@code{cc1}, @code{cc1plus}, 
@code{f771}和其它语言前端的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给前端的选项。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac CC1PLUS_SPEC
@en A C string constant that tells the GCC driver program options to
@en pass to @code{cc1plus}.  It can also specify how to translate options you
@en give to GCC into options for GCC to pass to the @code{cc1plus}.
一个C字符串常量，告诉GCC驱动程序要传给@code{cc1plus}的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给@code{cc1plus}的选项。

@en Do not define this macro if it does not need to do anything.
@en Note that everything defined in CC1_SPEC is already passed to
@en @code{cc1plus} so there is no need to duplicate the contents of
@en CC1_SPEC in CC1PLUS_SPEC@.
如果不需要做任何事情的话，则不要定义该宏。
注意在CC1_SPEC中定义的所有选项已经被传给@code{cc1plus}，
所以不需要在CC1PLUS_SPEC中重复CC1_SPEC的内容。
@end defmac

@defmac ASM_SPEC
@en A C string constant that tells the GCC driver program options to
@en pass to the assembler.  It can also specify how to translate options
@en you give to GCC into options for GCC to pass to the assembler.
@en See the file @file{sun3.h} for an example of this.
一个C字符串常量，告诉GCC驱动程序要传给汇编器的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给汇编器的选项。
参见文件@file{sun3.h}中的例子。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac ASM_FINAL_SPEC
@en A C string constant that tells the GCC driver program how to
@en run any programs which cleanup after the normal assembler.
@en Normally, this is not needed.  See the file @file{mips.h} for
@en an example of this.
一个C字符串常量，告诉GCC驱动程序如何在运行正常的汇编器之后，来运行任何清除程序。
通常，不需要该宏。参见文件@file{mips.h}中的例子。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac AS_NEEDS_DASH_FOR_PIPED_INPUT
@en Define this macro, with no value, if the driver should give the assembler
@en an argument consisting of a single dash, @option{-}, to instruct it to
@en read from its standard input (which will be a pipe connected to the
@en output of the compiler proper).  This argument is given after any
@en @option{-o} option specifying the name of the output file.
如果驱动器应该传给汇编器一个由单横线@option{-}组成的参数，
来指示它从标准输入（其将为一个与编译器输出相连接的管道）读取时，
则定义该宏，并且不需要给出定义值。
该参数在任何指定输出文件名的@option{-o}选项后面被给出。

@en If you do not define this macro, the assembler is assumed to read its
@en standard input if given no non-option arguments.  If your assembler
@en cannot read standard input at all, use a @samp{%@{pipe:%e@}} construct;
@en see @file{mips.h} for instance.
如果不定义该宏，则汇编器被认为在没有传给任何非选项参数时，才从标准输入读取。
如果你的汇编器根本不能从标准输入读取，则使用@samp{%@{pipe:%e@}}；
参见@file{mips.h}中的例子。
@end defmac

@defmac LINK_SPEC
@en A C string constant that tells the GCC driver program options to
@en pass to the linker.  It can also specify how to translate options you
@en give to GCC into options for GCC to pass to the linker.
一个C字符串常量，告诉GCC驱动程序要传给连接器的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给连接器的选项。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac LIB_SPEC
@en Another C string constant used much like @code{LINK_SPEC}.  The difference
@en between the two is that @code{LIB_SPEC} is used at the end of the
@en command given to the linker.
另一个C字符串常量，与@code{LINK_SPEC}的用法很相似。
两者的区别是@code{LIB_SPEC}用于传给连接器的命令的结尾处。

@en If this macro is not defined, a default is provided that
@en loads the standard C library from the usual place.  See @file{gcc.c}.
如果该宏没有被定义，则提供缺省的方式，从通常的地方来加载标准C库。
参见@file{gcc.c}。
@end defmac

@defmac LIBGCC_SPEC
@en Another C string constant that tells the GCC driver program
@en how and when to place a reference to @file{libgcc.a} into the
@en linker command line.  This constant is placed both before and after
@en the value of @code{LIB_SPEC}.
另一个C字符串常量，
告诉GCC驱动程序如何以及什么时候将对@file{libgcc.a}的引用放到连接器的命令行中。
该常量同时被放在@code{LIB_SPEC}的值的前面和后面。

@en If this macro is not defined, the GCC driver provides a default that
@en passes the string @option{-lgcc} to the linker.
如果该宏没有被定义，则GCC驱动器提供了一个缺省的方式，
将字符串@option{-lgcc}传给连接器。
@end defmac

@defmac REAL_LIBGCC_SPEC
@en By default, if @code{ENABLE_SHARED_LIBGCC} is defined, the
@en @code{LIBGCC_SPEC} is not directly used by the driver program but is
@en instead modified to refer to different versions of @file{libgcc.a}
@en depending on the values of the command line flags @option{-static},
@en @option{-shared}, @option{-static-libgcc}, and @option{-shared-libgcc}.  On
@en targets where these modifications are inappropriate, define
@en @code{REAL_LIBGCC_SPEC} instead.  @code{REAL_LIBGCC_SPEC} tells the
@en driver how to place a reference to @file{libgcc} on the link command
@en line, but, unlike @code{LIBGCC_SPEC}, it is used unmodified.
缺省情况下，如果@code{ENABLE_SHARED_LIBGCC}被定义，
则@code{LIBGCC_SPEC}不直接被驱动程序使用，而是根据命令行标记@option{-static}, 
@option{-shared}, @option{-static-libgcc}和@option{-shared-libgcc}的值，
进行修改，从而引用@file{libgcc.a}的不同版本。在一些目标机上，这些修改并不合适，
这样就可以定义@code{REAL_LIBGCC_SPEC}。
@code{REAL_LIBGCC_SPEC}告诉驱动器如何将对@file{libgcc}的引用放到连接器命令行中，
不过不像@code{LIBGCC_SPEC}，它不经过修改，被直接使用。
@end defmac

@defmac USE_LD_AS_NEEDED
@en A macro that controls the modifications to @code{LIBGCC_SPEC}
@en mentioned in @code{REAL_LIBGCC_SPEC}.  If nonzero, a spec will be
@en generated that uses --as-needed and the shared libgcc in place of the
@en static exception handler library, when linking without any of
@en @code{-static}, @code{-static-libgcc}, or @code{-shared-libgcc}.
一个宏，用于控制在@code{REAL_LIBGCC_SPEC}中提到的对@code{LIBGCC_SPEC}的修改。
如果非0，则会生成一个spec，当不使用任何@code{-static}, 
@code{-static-libgcc}或@code{-shared-libgcc}来连接的时候，
将使用–as-needed和静态异常处理库所在位置的共享libgcc。
@end defmac

@defmac LINK_EH_SPEC
@en If defined, this C string constant is added to @code{LINK_SPEC}.
@en When @code{USE_LD_AS_NEEDED} is zero or undefined, it also affects
@en the modifications to @code{LIBGCC_SPEC} mentioned in
@en @code{REAL_LIBGCC_SPEC}.
如果定义，则该C字符串常量被增加到@code{LINK_SPEC}中。
当@code{USE_LD_AS_NEEDED}为0或者未定义时，
其还影响在@code{REAL_LIBGCC_SPEC}中提到的对@code{LIBGCC_SPEC}的修改。
@end defmac

@defmac STARTFILE_SPEC
@en Another C string constant used much like @code{LINK_SPEC}.  The
@en difference between the two is that @code{STARTFILE_SPEC} is used at
@en the very beginning of the command given to the linker.
另一个C字符串常量，与@code{LINK_SPEC}的用法很相似。
两者的不同之处是@code{STARTFILE_SPEC}用于传给连接器的命令的最开始处。

@en If this macro is not defined, a default is provided that loads the
@en standard C startup file from the usual place.  See @file{gcc.c}.
如果该宏没有被定义，则会提供一种缺省方式，
从通常的地方来加载标准C启动（startup）文件。参见@file{gcc.c}。
@end defmac

@defmac ENDFILE_SPEC
@en Another C string constant used much like @code{LINK_SPEC}.  The
@en difference between the two is that @code{ENDFILE_SPEC} is used at
@en the very end of the command given to the linker.
另一个C字符串常量，与@code{LINK_SPEC}的用法很相似。
两者的不同之处是@code{ENDFILE_SPEC}用于传给连接器的命令的最末尾处。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac THREAD_MODEL_SPEC
@en GCC @code{-v} will print the thread model GCC was configured to use.
@en However, this doesn't work on platforms that are multilibbed on thread
@en models, such as AIX 4.3.  On such platforms, define
@en @code{THREAD_MODEL_SPEC} such that it evaluates to a string without
@en blanks that names one of the recognized thread models.  @code{%*}, the
@en default value of this macro, will expand to the value of
@en @code{thread_file} set in @file{config.gcc}.
GCC @code{-v}将会打印GCC被配置使用的线程模式。然而，在有些平台上这是无法工作的，
像AIX 4.3。对于这样的平台，将@code{THREAD_MODEL_SPEC}定义为没有空格的字符串来
命名可识别的线程模式的名字。@code{%*}为该宏的缺省值，
将扩展为在@file{config.gcc}中设置的@code{thread_file}的值。
@end defmac

@defmac SYSROOT_SUFFIX_SPEC
@en Define this macro to add a suffix to the target sysroot when GCC is
@en configured with a sysroot.  This will cause GCC to search for usr/lib,
@en et al, within sysroot+suffix.
定义该宏，当GCC使用sysroot被配置时，来为目标机的sysroot增加一个suffix。
这将导致GCC在sysroot+suffix下查找usr/lib等。
@end defmac

@defmac SYSROOT_HEADERS_SUFFIX_SPEC
@en Define this macro to add a headers_suffix to the target sysroot when
@en GCC is configured with a sysroot.  This will cause GCC to pass the
@en updated sysroot+headers_suffix to CPP, causing it to search for
@en usr/include, et al, within sysroot+headers_suffix.
定义该宏，当GCC使用sysroot被配置时，来为目标机的sysroot增加一个headers_suffix。
这将导致GCC将更新的sysroot+headers_suffix传给CPP，
使其在sysroot+headers_suffix下查找usr/include等。
@end defmac

@defmac EXTRA_SPECS
@en Define this macro to provide additional specifications to put in the
@en @file{specs} file that can be used in various specifications like
@en @code{CC1_SPEC}.
定义该宏，来提供放在@file{specs}文件中，
可以被各种specification，像@code{CC1_SPEC}，使用的额外的specification。

@en The definition should be an initializer for an array of structures,
@en containing a string constant, that defines the specification name, and a
@en string constant that provides the specification.
定义应该为一个结构体数组的初始化值，其包含一个字符串常量，
定义了specification的名字，以及一个字符串常量，提供相应的specification。

@en Do not define this macro if it does not need to do anything.
如果不需要做任何事情的话，则不要定义该宏。

@en @code{EXTRA_SPECS} is useful when an architecture contains several
@en related targets, which have various @code{@dots{}_SPECS} which are similar
@en to each other, and the maintainer would like one central place to keep
@en these definitions.
当一种体系结构包含多个相关的目标机，所具有的各种@code{@dots{}_SPECS}彼此很相似
的时候，@code{EXTRA_SPECS}会很有用，维护者会希望有一个地方来集中保存这些定义。

@en For example, the PowerPC System V.4 targets use @code{EXTRA_SPECS} to
@en define either @code{_CALL_SYSV} when the System V calling sequence is
@en used or @code{_CALL_AIX} when the older AIX-based calling sequence is
@en used.
例如，PowerPC System V.4的目标机使用@code{EXTRA_SPECS}，
在System V调用序列被使用时，来定义@code{_CALL_SYSV}，
在较老的基于AIX的调用序列被使用时，来定义@code{_CALL_AIX}。

@en The @file{config/rs6000/rs6000.h} target file defines:
@file{config/rs6000/rs6000.h}目标机文件这样定义:

@smallexample
#define EXTRA_SPECS \
  @{ "cpp_sysv_default", CPP_SYSV_DEFAULT @},

#define CPP_SYS_DEFAULT ""
@end smallexample

@en The @file{config/rs6000/sysv.h} target file defines:
@file{config/rs6000/sysv.h}目标机文件这样定义:
@smallexample
#undef CPP_SPEC
#define CPP_SPEC \
"%@{posix: -D_POSIX_SOURCE @} \
%@{mcall-sysv: -D_CALL_SYSV @} \
%@{!mcall-sysv: %(cpp_sysv_default) @} \
%@{msoft-float: -D_SOFT_FLOAT@} %@{mcpu=403: -D_SOFT_FLOAT@}"

#undef CPP_SYSV_DEFAULT
#define CPP_SYSV_DEFAULT "-D_CALL_SYSV"
@end smallexample

@en while the @file{config/rs6000/eabiaix.h} target file defines
@en @code{CPP_SYSV_DEFAULT} as:
而@file{config/rs6000/eabiaix.h}目标机文件将@code{CPP_SYSV_DEFAULT}定义为:

@smallexample
#undef CPP_SYSV_DEFAULT
#define CPP_SYSV_DEFAULT "-D_CALL_AIX"
@end smallexample
@end defmac

@defmac LINK_LIBGCC_SPECIAL_1
@en Define this macro if the driver program should find the library
@en @file{libgcc.a}.  If you do not define this macro, the driver program will pass
@en the argument @option{-lgcc} to tell the linker to do the search.
定义该宏，如果驱动程序应该找到库@file{libgcc.a}。
如果没有定义该宏，则驱动程序将参数@option{-lgcc}传给连接器，告诉连接器来查找。
@end defmac

@defmac LINK_GCC_C_SEQUENCE_SPEC
@en The sequence in which libgcc and libc are specified to the linker.
@en By default this is @code{%G %L %G}.
指定给连接器的libgcc和libc的顺序。缺省为@code{%G %L %G}。
@end defmac

@defmac LINK_COMMAND_SPEC
@en A C string constant giving the complete command line need to execute the
@en linker.  When you do this, you will need to update your port each time a
@en change is made to the link command line within @file{gcc.c}.  Therefore,
@en define this macro only if you need to completely redefine the command
@en line for invoking the linker and there is no other way to accomplish
@en the effect you need.  Overriding this macro may be avoidable by overriding
@en @code{LINK_GCC_C_SEQUENCE_SPEC} instead.
一个C字符串常量，给出执行连接器所需的完整的命令行。当定义时，
每次在@file{gcc.c}中对连接器命令行的修改，你都需要更新你的port。
因此，只有当你需要完全重定义所调用的连接器的命令行，并且没有其他方式来完成时，
才定义该宏。可以通过@code{LINK_GCC_C_SEQUENCE_SPEC}来替代该宏。
@end defmac

@defmac LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
@en A nonzero value causes @command{collect2} to remove duplicate @option{-L@var{directory}} search
@en directories from linking commands.  Do not give it a nonzero value if
@en removing duplicate search directories changes the linker's semantics.
一个非零值，
使得@command{collect2}从连接命令中移除重复的@option{-L@var{directory}}搜索目录。
如果移除重复的搜索目录会改变连接器的语法，则不要定义为非零。
@end defmac

@defmac MULTILIB_DEFAULTS
@en Define this macro as a C expression for the initializer of an array of
@en string to tell the driver program which options are defaults for this
@en target and thus do not need to be handled specially when using
@en @code{MULTILIB_OPTIONS}.
定义该宏为字符串数组的初始化C表达式，用来告诉驱动器程序对于该目标机，
哪些选项是缺省的，因此当使用@code{MULTILIB_OPTIONS}时，不需要单独处理。

@en Do not define this macro if @code{MULTILIB_OPTIONS} is not defined in
@en the target makefile fragment or if none of the options listed in
@en @code{MULTILIB_OPTIONS} are set by default.
@en @xref{Target Fragment}.
如果在target makefile片段中没有定义@code{MULTILIB_OPTIONS}，
或者如果在@code{MULTILIB_OPTIONS}中列出的选项中没有被设为缺省的，
则不要定义该宏。@xref{Target Fragment}。
@end defmac

@defmac RELATIVE_PREFIX_NOT_LINKDIR
@en Define this macro to tell @command{gcc} that it should only translate
@en a @option{-B} prefix into a @option{-L} linker option if the prefix
@en indicates an absolute file name.
定义该宏来告诉@command{gcc}，
如果前缀指示了一个绝对的文件名，
则其应该只将@option{-B}的前缀转换成@option{-L}连接器选项，
@end defmac

@defmac MD_EXEC_PREFIX
@en If defined, this macro is an additional prefix to try after
@en @code{STANDARD_EXEC_PREFIX}.  @code{MD_EXEC_PREFIX} is not searched
@en when the compiler is built as a cross
@en compiler.  If you define @code{MD_EXEC_PREFIX}, then be sure to add it
@en to the list of directories used to find the assembler in @file{configure.in}.
如果定义，该宏为一个可选前缀，其在@code{STANDARD_EXEC_PREFIX}之后进行尝试。
当使用@option{-b}选项，或者编译器被构建为交叉编译器时，
将不搜索@code{MD_EXEC_PREFIX}。如果你定义了@code{MD_EXEC_PREFIX}，
则要确保将其增加到@file{configure.in}中用于查找汇编器的目录列表中。
@end defmac

@defmac STANDARD_STARTFILE_PREFIX
@en Define this macro as a C string constant if you wish to override the
@en standard choice of @code{libdir} as the default prefix to
@en try when searching for startup files such as @file{crt0.o}.
@en @code{STANDARD_STARTFILE_PREFIX} is not searched when the compiler
@en is built as a cross compiler.
定义该宏为C字符串常量，
如果你希望覆盖将@code{libdir}作为前缀来搜索起始文件@file{crt0.o}等的标准选择。
当构建为交叉编译器时，@code{STANDARD_STARTFILE_PREFIX}不被搜索。
@end defmac

@defmac STANDARD_STARTFILE_PREFIX_1
@en Define this macro as a C string constant if you wish to override the
@en standard choice of @code{/lib} as a prefix to try after the default prefix
@en when searching for startup files such as @file{crt0.o}.
@en @code{STANDARD_STARTFILE_PREFIX_1} is not searched when the compiler
@en is built as a cross compiler.
定义该宏为C字符串常量，如果你希望覆盖在缺省前缀之后，
将@code{/lib}作为前缀来搜索起始文件@file{crt0.o}等的标准选择。
当构建为交叉编译器时，@code{STANDARD_STARTFILE_PREFIX_1}不被搜索。
@end defmac

@defmac STANDARD_STARTFILE_PREFIX_2
@en Define this macro as a C string constant if you wish to override the
@en standard choice of @code{/lib} as yet another prefix to try after the
@en default prefix when searching for startup files such as @file{crt0.o}.
@en @code{STANDARD_STARTFILE_PREFIX_2} is not searched when the compiler
@en is built as a cross compiler.
定义该宏为C字符串常量，如果你希望覆盖在缺省前缀之后，
将@code{/lib}作为前缀来搜索起始文件@file{crt0.o}等的标准选择。
当构建为交叉编译器时，@code{STANDARD_STARTFILE_PREFIX_2}不被搜索。
@end defmac

@defmac MD_STARTFILE_PREFIX
@en If defined, this macro supplies an additional prefix to try after the
@en standard prefixes.  @code{MD_EXEC_PREFIX} is not searched when the
@en compiler is built as a cross compiler.
如果定义，该宏提供了额外的前缀，在标准前缀之后被尝试。
当使用@option{-b}选项，或者编译器被构建为交叉编译器时，
将不搜索@code{MD_EXEC_PREFIX}。
@end defmac

@defmac MD_STARTFILE_PREFIX_1
@en If defined, this macro supplies yet another prefix to try after the
@en standard prefixes.  It is not searched when the compiler is built as a
@en cross compiler.
如果定义，该宏提供了另一个额外的前缀，在标准前缀之后被尝试。
当使用@option{-b}选项，或者编译器被构建为交叉编译器时，其将不被搜索。
@end defmac

@defmac INIT_ENVIRONMENT
@en Define this macro as a C string constant if you wish to set environment
@en variables for programs called by the driver, such as the assembler and
@en loader.  The driver passes the value of this macro to @code{putenv} to
@en initialize the necessary environment variables.
定义该宏为C字符串常量，如果你希望为驱动器调用的程序，例如汇编器和连接器，
来设置的环境变量。驱动器将该宏的值传给@code{putenv}来初始化需要的环境变量。
@end defmac

@defmac LOCAL_INCLUDE_DIR
@en Define this macro as a C string constant if you wish to override the
@en standard choice of @file{/usr/local/include} as the default prefix to
@en try when searching for local header files.  @code{LOCAL_INCLUDE_DIR}
@en comes before @code{SYSTEM_INCLUDE_DIR} in the search order.
定义该宏为C字符串常量，如果你希望覆写当尝试搜索局部头文件时，
将@file{/usr/local/include}作为缺省前缀的标准选择。
在搜索顺序中，@code{LOCAL_INCLUDE_DIR}位于@code{SYSTEM_INCLUDE_DIR}之前。

@en Cross compilers do not search either @file{/usr/local/include} or its
@en replacement.
交叉编译器既不搜索@file{/usr/local/include}，也不搜索它的替换者。
@end defmac

@defmac SYSTEM_INCLUDE_DIR
@en Define this macro as a C string constant if you wish to specify a
@en system-specific directory to search for header files before the standard
@en directory.  @code{SYSTEM_INCLUDE_DIR} comes before
@en @code{STANDARD_INCLUDE_DIR} in the search order.
定义该宏作为C字符串常量，
如果你希望指定一个系统特定的目录在标准目录之前来搜索头文件。
在搜索顺序中，@code{SYSTEM_INCLUDE_DIR}位于@code{STANDARD_INCLUDE_DIR}之前。

@en Cross compilers do not use this macro and do not search the directory
@en specified.
交叉编译器不使用该宏，并且不搜索所指定的目录。
@end defmac

@defmac STANDARD_INCLUDE_DIR
@en Define this macro as a C string constant if you wish to override the
@en standard choice of @file{/usr/include} as the default prefix to
@en try when searching for header files.
定义该宏为C字符串常量，
如果你希望覆写将@file{/usr/include}作为缺省前缀来尝试搜索头文件的标准选择。

@en Cross compilers ignore this macro and do not search either
@en @file{/usr/include} or its replacement.
交叉编译器忽略该宏，并且不搜索@file{/usr/include}和它的替换者。
@end defmac

@defmac STANDARD_INCLUDE_COMPONENT
@en The ``component'' corresponding to @code{STANDARD_INCLUDE_DIR}.
@en See @code{INCLUDE_DEFAULTS}, below, for the description of components.
@en If you do not define this macro, no component is used.
“component”对应于@code{STANDARD_INCLUDE_DIR}。关于组件的描述，
参见下面的@code{INCLUDE_DEFAULTS}。如果你没有定义该宏，则不使用组件。
@end defmac

@defmac INCLUDE_DEFAULTS
@en Define this macro if you wish to override the entire default search path
@en for include files.  For a native compiler, the default search path
@en usually consists of @code{GCC_INCLUDE_DIR}, @code{LOCAL_INCLUDE_DIR},
@en @code{SYSTEM_INCLUDE_DIR}, @code{GPLUSPLUS_INCLUDE_DIR}, and
@en @code{STANDARD_INCLUDE_DIR}.  In addition, @code{GPLUSPLUS_INCLUDE_DIR}
@en and @code{GCC_INCLUDE_DIR} are defined automatically by @file{Makefile},
@en and specify private search areas for GCC@.  The directory
@en @code{GPLUSPLUS_INCLUDE_DIR} is used only for C++ programs.
定义该宏，如果你希望覆写include文件的全部缺省搜索路径。对于一个本地编译器，
缺省搜索路径通常由@code{GCC_INCLUDE_DIR}, @code{LOCAL_INCLUDE_DIR}, 
@code{SYSTEM_INCLUDE_DIR}, @code{GPLUSPLUS_INCLUDE_DIR}和
@code{STANDARD_INCLUDE_DIR}组成。另外，@code{GPLUSPLUS_INCLUDE_DIR}和
@code{GCC_INCLUDE_DIR}由@file{Makefile}自动定义，并指定为GCC的私有搜索区域。
目录@code{GPLUSPLUS_INCLUDE_DIR}只用于C++程序。

@en The definition should be an initializer for an array of structures.
@en Each array element should have four elements: the directory name (a
@en string constant), the component name (also a string constant), a flag
@en for C++-only directories,
@en and a flag showing that the includes in the directory don't need to be
@en wrapped in @code{extern @samp{C}} when compiling C++.  Mark the end of
@en the array with a null element.
该定义为一个结构体数组的初始化值。
每个数组元素具有四个元素：目录名（字符串常量），
组件名（也是字符串常量），一个标志用来指示只用于C++，
以及一个标志用来表示当编译C++时，对该目录下include进来的代码，
不需要使用@code{extern @samp{C}}进行包裹。
使用空元素来标记数组的结尾。

@en The component name denotes what GNU package the include file is part of,
@en if any, in all uppercase letters.  For example, it might be @samp{GCC}
@en or @samp{BINUTILS}.  If the package is part of a vendor-supplied
@en operating system, code the component name as @samp{0}.
组件名指出了include文件属于什么GNU包，如果存在，则全部使用大写字母。
例如，可能为@samp{GCC}或@samp{BINUTILS}。
如果程序包是商家提供的操作系统的一部分，则将名字写为@samp{0}。

@en For example, here is the definition used for VAX/VMS:
例如，这是用于VAX/VMS的定义:

@smallexample
#define INCLUDE_DEFAULTS \
@{                                       \
  @{ "GNU_GXX_INCLUDE:", "G++", 1, 1@},   \
  @{ "GNU_CC_INCLUDE:", "GCC", 0, 0@},    \
  @{ "SYS$SYSROOT:[SYSLIB.]", 0, 0, 0@},  \
  @{ ".", 0, 0, 0@},                      \
  @{ 0, 0, 0, 0@}                         \
@}
@end smallexample
@end defmac

@en Here is the order of prefixes tried for exec files:
这些是尝试查找exec文件的前缀顺序：

@en @enumerate
@en @item
@en Any prefixes specified by the user with @option{-B}.
@en 
@en @item
@en The environment variable @code{GCC_EXEC_PREFIX} or, if @code{GCC_EXEC_PREFIX}
@en is not set and the compiler has not been installed in the configure-time 
@en @var{prefix}, the location in which the compiler has actually been installed.
@en 
@en @item
@en The directories specified by the environment variable @code{COMPILER_PATH}.
@en 
@en @item
@en The macro @code{STANDARD_EXEC_PREFIX}, if the compiler has been installed
@en in the configured-time @var{prefix}. 
@en 
@en @item
@en The location @file{/usr/libexec/gcc/}, but only if this is a native compiler. 
@en 
@en @item
@en The location @file{/usr/lib/gcc/}, but only if this is a native compiler. 
@en 
@en @item
@en The macro @code{MD_EXEC_PREFIX}, if defined, but only if this is a native 
@en compiler.
@en @end enumerate
@enumerate
@item
用户使用@option{-B}指定的前缀。

@item
环境变量@code{GCC_EXEC_PREFIX}，
或者如果@code{GCC_EXEC_PREFIX}没有被设置并且编译器没有被安装到配置时的@var{prefix}处，
则搜索编译器实际被安装的位置。

@item
环境变量@code{COMPILER_PATH}指定的目录。

@item
宏@code{STANDARD_EXEC_PREFIX}，如果编译器安装在配置时的@var{prefix}处。

@item
位置@file{/usr/libexec/gcc/}，仅当是本地编译器。

@item
位置@file{/usr/lib/gcc/}，仅当是本地编译器。

@item
宏@code{MD_EXEC_PREFIX}，如果定义，仅当是本地编译器。
@end enumerate

@en Here is the order of prefixes tried for startfiles:
这些是尝试查找启动文件的前缀顺序：

@en @enumerate
@en @item
@en Any prefixes specified by the user with @option{-B}.
@en 
@en @item
@en The environment variable @code{GCC_EXEC_PREFIX} or its automatically determined
@en value based on the installed toolchain location.
@en 
@en @item
@en The directories specified by the environment variable @code{LIBRARY_PATH}
@en (or port-specific name; native only, cross compilers do not use this).
@en 
@en @item
@en The macro @code{STANDARD_EXEC_PREFIX}, but only if the toolchain is installed
@en in the configured @var{prefix} or this is a native compiler. 
@en 
@en @item
@en The location @file{/usr/lib/gcc/}, but only if this is a native compiler.
@en 
@en @item
@en The macro @code{MD_EXEC_PREFIX}, if defined, but only if this is a native 
@en compiler.
@en 
@en @item
@en The macro @code{MD_STARTFILE_PREFIX}, if defined, but only if this is a 
@en native compiler, or we have a target system root.
@en 
@en @item
@en The macro @code{MD_STARTFILE_PREFIX_1}, if defined, but only if this is a 
@en native compiler, or we have a target system root.
@en 
@en @item
@en The macro @code{STANDARD_STARTFILE_PREFIX}, with any sysroot modifications.
@en If this path is relative it will be prefixed by @code{GCC_EXEC_PREFIX} and
@en the machine suffix or @code{STANDARD_EXEC_PREFIX} and the machine suffix.
@en 
@en @item
@en The macro @code{STANDARD_STARTFILE_PREFIX_1}, but only if this is a native
@en compiler, or we have a target system root. The default for this macro is
@en @file{/lib/}.
@en 
@en @item
@en The macro @code{STANDARD_STARTFILE_PREFIX_2}, but only if this is a native
@en compiler, or we have a target system root. The default for this macro is
@en @file{/usr/lib/}.
@en @end enumerate
@enumerate
@item
用户使用@option{-B}指定的前缀。

@item
环境变量@code{GCC_EXEC_PREFIX}，或者基于工具链的安装位置被自动确定的值。

@item
由环境变量@code{LIBRARY_PATH}指定的目录（或者port特定的名字，只用于本地编译器，
交叉编译器不使用）。

@item
宏@code{STANDARD_EXEC_PREFIX}，但只当工具链被安装在配置的@var{prefix}处，
或者为本地编译器。

@item
位置@file{/usr/lib/gcc/}，仅当是本地编译器。

@item
宏@code{MD_EXEC_PREFIX}，如果定义，仅当是本地编译器。

@item
宏@code{MD_STARTFILE_PREFIX}，如果定义，
仅当为本地编译器，或者具有目标机系统根目录（system root）。

@item
宏@code{MD_STARTFILE_PREFIX_1}，如果定义，
仅当为本地编译器，或者具有目标机系统根目录。

@item
宏@code{STANDARD_STARTFILE_PREFIX}，带有任何sysroot的修改。
如果该路径相关，则会加上@code{GCC_EXEC_PREFIX}前缀和机器后缀，
或者@code{STANDARD_EXEC_PREFIX}和机器后缀。

@item
宏@code{STANDARD_STARTFILE_PREFIX_1}，仅当为本地编译器，
或者具有目标机系统根目录。该宏的缺省值为@file{/lib/}。

@item
宏@code{STANDARD_STARTFILE_PREFIX_2}，仅当为本地编译器，
或者具有目标机系统根目录。该宏的缺省值为@file{/usr/lib/}。
@end enumerate

@en @node Run-time Target
@en @section Run-time Target Specification
@node Run-time Target
@section 运行时的target指定
@cindex run-time target specification
@cindex predefined macros
@cindex target specifications

@c prevent bad page break with this line
@en Here are run-time target specifications.
这些是运行时的target指定。

@defmac TARGET_CPU_CPP_BUILTINS ()
@en This function-like macro expands to a block of code that defines
@en built-in preprocessor macros and assertions for the target CPU, using
@en the functions @code{builtin_define}, @code{builtin_define_std} and
@en @code{builtin_assert}.  When the front end
@en calls this macro it provides a trailing semicolon, and since it has
@en finished command line option processing your code can use those
@en results freely.
该类函数的宏扩展成一块代码，其定义了target CPU内建的预处理器宏和断言，
使用函数@code{builtin_define}, @code{builtin_define_std}和
@code{builtin_assert}。当前端调用该宏时，其提供一个尾部的分号，
由于其已经结束了命令行选项处理，所以你的代码可以自由的使用那些结果。

@en @code{builtin_assert} takes a string in the form you pass to the
@en command-line option @option{-A}, such as @code{cpu=mips}, and creates
@en the assertion.  @code{builtin_define} takes a string in the form
@en accepted by option @option{-D} and unconditionally defines the macro.
@code{builtin_assert}接受一个字符串，按照传给命令行选项@option{-A}的形式，
例如@code{cpu=mips}，并且创建一个断言。@code{builtin_define}接受一个字符串，
按照传给命令行选项@option{-D}的形式，并且无条件的定义一个宏。

@en @code{builtin_define_std} takes a string representing the name of an
@en object-like macro.  If it doesn't lie in the user's namespace,
@en @code{builtin_define_std} defines it unconditionally.  Otherwise, it
@en defines a version with two leading underscores, and another version
@en with two leading and trailing underscores, and defines the original
@en only if an ISO standard was not requested on the command line.  For
@en example, passing @code{unix} defines @code{__unix}, @code{__unix__}
@en and possibly @code{unix}; passing @code{_mips} defines @code{__mips},
@en @code{__mips__} and possibly @code{_mips}, and passing @code{_ABI64}
@en defines only @code{_ABI64}.
@code{builtin_define_std}接受一个字符串，来表示对象的名字。
如果其不在用户命名空间，则@code{builtin_define_std}无条件的定义它。否则，
定义一个具有两个前导下划线的版本，和另一个具有两个前导和后缀的下划线的版本。
例如传递@code{unix}，将定义@code{__unix}, @code{__unix__}以及可能的@code{unix}；
传递@code{_mips}，将定义@code{__mips}, @code{__mips__}和可能的@code{_mips}，
传递@code{_ABI64}，将指定义@code{_ABI64}。

@en You can also test for the C dialect being compiled.  The variable
@en @code{c_language} is set to one of @code{clk_c}, @code{clk_cplusplus}
@en or @code{clk_objective_c}.  Note that if we are preprocessing
@en assembler, this variable will be @code{clk_c} but the function-like
@en macro @code{preprocessing_asm_p()} will return true, so you might want
@en to check for that first.  If you need to check for strict ANSI, the
@en variable @code{flag_iso} can be used.  The function-like macro
@en @code{preprocessing_trad_p()} can be used to check for traditional
@en preprocessing.
你还可以测试被编译的C方言。变量@code{c_language}被设为@code{clk_c}, 
@code{clk_cplusplus}或者@code{clk_objective_c}。注意，如果我们在预处理汇编，
则该变量将为@code{clk_c}，不过类函数的宏@code{preprocessing_asm_p()}将返回真，
所以你可能要先检查它。如果你需要检查严格的ANSI，可以使用变量@code{flag_iso}。
类函数的宏@code{preprocessing_trad_p()}可以用来检查传统的预处理。
@end defmac

@defmac TARGET_OS_CPP_BUILTINS ()
@en Similarly to @code{TARGET_CPU_CPP_BUILTINS} but this macro is optional
@en and is used for the target operating system instead.
类似于@code{TARGET_CPU_CPP_BUILTINS}，不过该宏是可选的，用于target操作系统。
@end defmac

@defmac TARGET_OBJFMT_CPP_BUILTINS ()
@en Similarly to @code{TARGET_CPU_CPP_BUILTINS} but this macro is optional
@en and is used for the target object format.  @file{elfos.h} uses this
@en macro to define @code{__ELF__}, so you probably do not need to define
@en it yourself.
类似于@code{TARGET_CPU_CPP_BUILTINS}，不过该宏是可选的，用于target目标文件格式。
@file{elfos.h}使用该宏来定义@code{__ELF__}，所以你可能不需要自己定义。
@end defmac

@deftypevar {extern int} target_flags
@en This variable is declared in @file{options.h}, which is included before
@en any target-specific headers.
该变量在@file{options.h}中声明，其在任何target特定的头文件之前被包含进来。
@end deftypevar

@deftypevr {Target Hook} int TARGET_DEFAULT_TARGET_FLAGS
@en This variable specifies the initial value of @code{target_flags}.
@en Its default setting is 0.
该变量指定了@code{target_flags}的初始值。其缺省设置为0。
@end deftypevr

@cindex optional hardware or system features
@cindex features, optional, in system conventions

@deftypefn {Target Hook} bool TARGET_HANDLE_OPTION (size_t @var{code}, const char *@var{arg}, int @var{value})
@en This hook is called whenever the user specifies one of the
@en target-specific options described by the @file{.opt} definition files
@en (@pxref{Options}).  It has the opportunity to do some option-specific
@en processing and should return true if the option is valid.  The default
@en definition does nothing but return true.
该宏当用户指定了在@file{.opt}定义文件(@pxref{Options})中描述的target特定选项
时被调用。其可以做一些选项特定的处理，并且如果选项有效时应该返回真。
缺省的定义不做任何事情，只是返回真。

@en @var{code} specifies the @code{OPT_@var{name}} enumeration value
@en associated with the selected option; @var{name} is just a rendering of
@en the option name in which non-alphanumeric characters are replaced by
@en underscores.  @var{arg} specifies the string argument and is null if
@en no argument was given.  If the option is flagged as a @code{UInteger}
@en (@pxref{Option properties}), @var{value} is the numeric value of the
@en argument.  Otherwise @var{value} is 1 if the positive form of the
@en option was used and 0 if the ``no-'' form was.
@var{code}指定了与选项相关的@code{OPT_@var{name}}枚举值；
这里的@var{name}只是对选项名的重写，将非字母和数字的字符替换为下划线。
@var{arg}指定了字符串参数，如果没有参数则为空。
如果选项被标记为@code{UInteger}（@pxref{Option properties}），
则@var{value}为参数的数值。否则@var{value}为1，如果使用了正的选项，
为0如果使用了“no-”形式。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_HANDLE_C_OPTION (size_t @var{code}, const char *@var{arg}, int @var{value})
@en This target hook is called whenever the user specifies one of the
@en target-specific C language family options described by the @file{.opt}
@en definition files(@pxref{Options}).  It has the opportunity to do some
@en option-specific processing and should return true if the option is
@en valid.  The arguments are like for @code{TARGET_HANDLE_OPTION}.  The
@en default definition does nothing but return false.
宏当用户指定了在@file{.opt}定义文件（参见“选项”）中描述的target特定的C语言家族
的选项时被调用。其可以做一些选项特定的处理，并且如果选项有效时应该返回真。
缺省的定义不做任何事情，只是返回假。

@en In general, you should use @code{TARGET_HANDLE_OPTION} to handle
@en options.  However, if processing an option requires routines that are
@en only available in the C (and related language) front ends, then you
@en should use @code{TARGET_HANDLE_C_OPTION} instead.
通常，你应该使用@code{TARGET_HANDLE_OPTION}来处理选项。然而，
如果选项处理只需要在C（和相关语言）前端中有效时，
你再使用@code{TARGET_HANDLE_C_OPTION}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_OBJC_CONSTRUCT_STRING_OBJECT (tree @var{string})
Targets may provide a string object type that can be used within and between C, C++ and their respective Objective-C dialects. A string object might, for example, embed encoding and length information. These objects are considered opaque to the compiler and handled as references. An ideal implementation makes the composition of the string object match that of the Objective-C @code{NSString} (@code{NXString} for GNUStep), allowing efficient interworking between C-only and Objective-C code. If a target implements string objects then this hook should return a reference to such an object constructed from the normal `C' string representation provided in @var{string}. At present, the hook is used by Objective-C only, to obtain a common-format string object when the target provides one.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_STRING_OBJECT_REF_TYPE_P (const_tree @var{stringref})
If a target implements string objects then this hook should return @code{true} if @var{stringref} is a valid reference to such an object.
@end deftypefn

@deftypefn {Target Hook} void TARGET_CHECK_STRING_OBJECT_FORMAT_ARG (tree @var{format_arg}, tree @var{args_list})
If a target implements string objects then this hook should should  provide a facility to check the function arguments in @var{args_list}  against the format specifiers in @var{format_arg} where the type of  @var{format_arg} is one recognized as a valid string reference type.
@end deftypefn

@defmac TARGET_VERSION
@en This macro is a C statement to print on @code{stderr} a string
@en describing the particular machine description choice.  Every machine
@en description should define @code{TARGET_VERSION}.  For example:
该宏为C语句，用来在@code{stderr}上打印表示特定机器描述选择的字符串。
每个机器描述都应该定义@code{TARGET_VERSION}。例如：

@smallexample
#ifdef MOTOROLA
#define TARGET_VERSION \
  fprintf (stderr, " (68k, Motorola syntax)");
#else
#define TARGET_VERSION \
  fprintf (stderr, " (68k, MIT syntax)");
#endif
@end smallexample
@end defmac

@defmac OVERRIDE_OPTIONS
@en Sometimes certain combinations of command options do not make sense on
@en a particular target machine.  You can define a macro
@en @code{OVERRIDE_OPTIONS} to take account of this.  This macro, if
@en defined, is executed once just after all the command options have been
@en parsed.
有时特定的命令选项组合在特定的target机器上没有意义。
你可以定义该宏@code{OVERRIDE_OPTIONS}。
如果定义，则在所有的命令选项被解析后执行。

@en Don't use this macro to turn on various extra optimizations for
@en @option{-O}.  That is what @code{OPTIMIZATION_OPTIONS} is for.
不要使用该宏来打开@option{-O}额外的优化。
使用@code{OPTIMIZATION_OPTIONS}来做这件事情。

If you need to do something whenever the optimization level is
changed via the optimize attribute or pragma, see
@code{TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE}

This macros is obsolete, new ports should use the target hook
@code{TARGET_OPTION_OVERRIDE} instead.
@end defmac

@deftypefn {Target Hook} void TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE (void)
This target function is similar to the hook @code{TARGET_OPTION_OVERRIDE}
but is called when the optimize level is changed via an attribute or
pragma or when it is reset at the end of the code affected by the
attribute or pragma.  It is not called at the beginning of compilation
when @code{TARGET_OPTION_OVERRIDE} is called so if you want to perform these
actions then, you should have @code{TARGET_OPTION_OVERRIDE} call
@code{TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE}.
@end deftypefn

@defmac C_COMMON_OVERRIDE_OPTIONS
@en This is similar to the @code{TARGET_OPTION_OVERRIDE} hook
@en but is only used in the C
@en language frontends (C, Objective-C, C++, Objective-C++) and so can be
@en used to alter option flag variables which only exist in those
@en frontends.
类似于@code{TARGET_OPTION_OVERRIDE}钩子，但只用于C语言的前端（C, Objective-C, C++, 
Objective-C++），所以可以用于修改只存在于那些前端中的选项标志变量。
@end defmac

@deftypevr {Target Hook} {const struct default_options *} TARGET_OPTION_OPTIMIZATION_TABLE
Some machines may desire to change what optimizations are performed for
various optimization levels.   This variable, if defined, describes
options to enable at particular sets of optimization levels.  These
options are processed once
just after the optimization level is determined and before the remainder
of the command options have been parsed, so may be overridden by other
options passed explicily.

This processing is run once at program startup and when the optimization
options are changed via @code{#pragma GCC optimize} or by using the
@code{optimize} attribute.
@end deftypevr

@deftypefn {Target Hook} void TARGET_OPTION_INIT_STRUCT (struct gcc_options *@var{opts})
Set target-dependent initial values of fields in @var{opts}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_DEFAULT_PARAMS (void)
Set target-dependent default values for @option{--param} settings, using calls to @code{set_default_param_value}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_HELP (void)
@en This hook is called in response to the user invoking
@en @option{--target-help} on the command line.  It gives the target a
@en chance to display extra information on the target specific command
@en line options found in its @file{.opt} file.
该钩子当用户在命令行中执行@option{--target-help}时被调用。
使得target可以显示在其@file{.opt}文件中找到的机器特定的命令行选项信息。
@end deftypefn

@defmac CAN_DEBUG_WITHOUT_FP
@en Define this macro if debugging can be performed even without a frame
@en pointer.  If this macro is defined, GCC will turn on the
@en @option{-fomit-frame-pointer} option whenever @option{-O} is specified.
定义该宏，如果没有帧指针也可以进行调试。如果定义了该宏，
则只要指定@option{-O}，GCC便打开@option{-fomit-frame-pointer}选项。
@end defmac

@defmac SWITCHABLE_TARGET
Some targets need to switch between substantially different subtargets
during compilation.  For example, the MIPS target has one subtarget for
the traditional MIPS architecture and another for MIPS16.  Source code
can switch between these two subarchitectures using the @code{mips16}
and @code{nomips16} attributes.

Such subtargets can differ in things like the set of available
registers, the set of available instructions, the costs of various
operations, and so on.  GCC caches a lot of this type of information
in global variables, and recomputing them for each subtarget takes a
significant amount of time.  The compiler therefore provides a facility
for maintaining several versions of the global variables and quickly
switching between them; see @file{target-globals.h} for details.

Define this macro to 1 if your target needs this facility.  The default
is 0.
@end defmac

@en @node Per-Function Data
@en @section Defining data structures for per-function information.
@node Per-Function Data
@section 为基于每个函数的信息定义数据结构
@cindex per-function data
@cindex data structures

@en If the target needs to store information on a per-function basis, GCC
@en provides a macro and a couple of variables to allow this.  Note, just
@en using statics to store the information is a bad idea, since GCC supports
@en nested functions, so you can be halfway through encoding one function
@en when another one comes along.
如果target需要存储基于每个函数的信息，则GCC为此提供了一个宏和一些变量。
注意，只是使用静态变量来保存信息是一个糟糕的想法，因为GCC支持嵌套函数，
所以可能会在编码一个函数的中途遇到另一个。

@en GCC defines a data structure called @code{struct function} which
@en contains all of the data specific to an individual function.  This
@en structure contains a field called @code{machine} whose type is
@en @code{struct machine_function *}, which can be used by targets to point
@en to their own specific data.
GCC定义了称为@code{struct function}的数据结构体，
包含了特定于单个函数的所有数据。该结构体包含一个称为@code{machine}的域，
其类型为@code{struct machine_function *}，
可以被target用于指向它们自己的特定数据。

@en If a target needs per-function specific data it should define the type
@en @code{struct machine_function} and also the macro @code{INIT_EXPANDERS}.
@en This macro should be used to initialize the function pointer
@en @code{init_machine_status}.  This pointer is explained below.
如果一个target需要基于每个函数的特定数据，
则应该定义类型@code{struct machine_function}，
以及宏@code{INIT_EXPANDERS}。
该宏将被用于初始化函数指针@code{init_machine_status}。
该指针将在下面说明。

@en One typical use of per-function, target specific data is to create an
@en RTX to hold the register containing the function's return address.  This
@en RTX can then be used to implement the @code{__builtin_return_address}
@en function, for level 0.
一个典型的基于每个函数的target特定数据，
是用于创建一个RTX来存放含有函数返回地址的寄存器。
该RTX随后可以被用于实现@code{__builtin_return_address}函数。

@en Note---earlier implementations of GCC used a single data area to hold
@en all of the per-function information.  Thus when processing of a nested
@en function began the old per-function data had to be pushed onto a
@en stack, and when the processing was finished, it had to be popped off the
@en stack.  GCC used to provide function pointers called
@en @code{save_machine_status} and @code{restore_machine_status} to handle
@en the saving and restoring of the target specific information.  Since the
@en single data area approach is no longer used, these pointers are no
@en longer supported.
注意，早期的GCC实现使用了单个数据区域来存放所有的基于每个函数的信息。
因此当开始处理嵌套函数时，旧式的基于每个函数的数据不得不被压入栈中，
并且当处理完成，还要出栈。
GCC曾经提供名为@code{save_machine_status}和@code{restore_machine_status}
函数指针来处理target特定信息的保存和恢复。
由于单数据区域的方法不再被使用了，这些指针也不再被支持。

@defmac INIT_EXPANDERS
@en Macro called to initialize any target specific information.  This macro
@en is called once per function, before generation of any RTL has begun.
@en The intention of this macro is to allow the initialization of the
@en function pointer @code{init_machine_status}.
被调用的宏，用来初始化任何target特定信息。
该宏在任何RTL生成开始之前，基于每个函数被调用一次。
该宏的目的是允许函数指针@code{init_machine_status}的初始化。
@end defmac

@deftypevar {void (*)(struct function *)} init_machine_status
@en If this function pointer is non-@code{NULL} it will be called once per
@en function, before function compilation starts, in order to allow the
@en target to perform any target specific initialization of the
@en @code{struct function} structure.  It is intended that this would be
@en used to initialize the @code{machine} of that structure.
如果该函数指针非空，则会在函数编译开始之前，基于每个函数被调用一次，
用于允许target来执行对@code{struct function}结构体的任何target特定初始化。
它将被用于初始化那个结构体的@code{machine}域。

@en @code{struct machine_function} structures are expected to be freed by GC@.
@en Generally, any memory that they reference must be allocated by using
@en GC allocation, including the structure itself.
结构体@code{struct machine_function}将期望被GC来释放。通常，
它们所引用的任何内存都必须使用@code{ggc_alloc}来分配，包括结构体本身。
@end deftypevar

@en @node Storage Layout
@en @section Storage Layout
@node Storage Layout
@section 存储布局
@cindex storage layout

@en Note that the definitions of the macros in this table which are sizes or
@en alignments measured in bits do not need to be constant.  They can be C
@en expressions that refer to static variables, such as the @code{target_flags}.
@en @xref{Run-time Target}.
注意该表格中的宏定义中，对于以bit为单位的大小或对齐，不需要为常量。
它们可以为引用了静态变量的C表达式，例如@code{target_flags}。
@xref{Run-time Target}。

@defmac BITS_BIG_ENDIAN
@en Define this macro to have the value 1 if the most significant bit in a
@en byte has the lowest number; otherwise define it to have the value zero.
@en This means that bit-field instructions count from the most significant
@en bit.  If the machine has no bit-field instructions, then this must still
@en be defined, but it doesn't matter which value it is defined to.  This
@en macro need not be a constant.
定义该宏的值为1，如果字节中的最高有效位具有最低编号；否则定义其值为0。
这意味着bit-field指令从最高有效位计数。如果机器没有bit-field指令，
则该宏也需要被定义，但定义什么值都无所谓。该宏不需要为一个常量。

@en This macro does not affect the way structure fields are packed into
@en bytes or words; that is controlled by @code{BYTES_BIG_ENDIAN}.
该宏不影响结构体域被打包成字节或者字的方式；
那是由@code{BYTES_BIG_ENDIAN}来控制的。
@end defmac

@defmac BYTES_BIG_ENDIAN
@en Define this macro to have the value 1 if the most significant byte in a
@en word has the lowest number.  This macro need not be a constant.
定义该宏的值为1，如果字中的最高有效字节具有最低编号。该宏不需要为一个常量。
@end defmac

@defmac WORDS_BIG_ENDIAN
@en Define this macro to have the value 1 if, in a multiword object, the
@en most significant word has the lowest number.  This applies to both
@en memory locations and registers; GCC fundamentally assumes that the
@en order of words in memory is the same as the order in registers.  This
@en macro need not be a constant.
定义该宏的值为1，如果在多字（multiword）对象中，最高有效字具有最低编号。
这同时应用于内存位置和寄存器中；
GCC从根本上假设在内存中的字的顺序与在寄存器中的一样。该宏不需要为一个常量。
@end defmac

@defmac LIBGCC2_WORDS_BIG_ENDIAN
@en Define this macro if @code{WORDS_BIG_ENDIAN} is not constant.  This must be a
@en constant value with the same meaning as @code{WORDS_BIG_ENDIAN}, which will be
@en used only when compiling @file{libgcc2.c}.  Typically the value will be set
@en based on preprocessor defines.
定义该宏如果@code{WORDS_BIG_ENDIAN}不是常量。该宏必须为一个常量值，
其与@code{WORDS_BIG_ENDIAN}的具有相同的含义，
并只用于编译@file{libgcc2.c}的时候。通常该值会根据预处理器定义来设置。
@end defmac

@defmac FLOAT_WORDS_BIG_ENDIAN
@en Define this macro to have the value 1 if @code{DFmode}, @code{XFmode} or
@en @code{TFmode} floating point numbers are stored in memory with the word
@en containing the sign bit at the lowest address; otherwise define it to
@en have the value 0.  This macro need not be a constant.
定义该宏值为1，如果@code{DFmode}, @code{XFmode}或@code{TFmode}浮点数被存储在
内存中，并且包含符号位的字位于最低地址；否则值为0。该宏不需要为一个常量。

@en You need not define this macro if the ordering is the same as for
@en multi-word integers.
你不需要定义该宏，如果顺序与多字整数相同。
@end defmac

@defmac BITS_PER_UNIT
@en Define this macro to be the number of bits in an addressable storage
@en unit (byte).  If you do not define this macro the default is 8.
定义该宏为一个可寻址的存储单元（字节）中的位数。如果没有定义，缺省为8。
@end defmac

@defmac BITS_PER_WORD
@en Number of bits in a word.  If you do not define this macro, the default
@en is @code{BITS_PER_UNIT * UNITS_PER_WORD}.
字的位数。如果没有定义，缺省为@code{BITS_PER_UNIT * UNITS_PER_WORD}。
@end defmac

@defmac MAX_BITS_PER_WORD
@en Maximum number of bits in a word.  If this is undefined, the default is
@en @code{BITS_PER_WORD}.  Otherwise, it is the constant value that is the
@en largest value that @code{BITS_PER_WORD} can have at run-time.
字的最大位数。如果没有定义，缺省为@code{BITS_PER_WORD}。
否则其为一个常量，为@code{BITS_PER_WORD}在运行时可以具有的最大值。
@end defmac

@defmac UNITS_PER_WORD
@en Number of storage units in a word; normally the size of a general-purpose
@en register, a power of two from 1 or 8.
字中的存储单元数；通常为通用目的寄存器的大小，2的1到8次幂。
@end defmac

@defmac MIN_UNITS_PER_WORD
@en Minimum number of units in a word.  If this is undefined, the default is
@en @code{UNITS_PER_WORD}.  Otherwise, it is the constant value that is the
@en smallest value that @code{UNITS_PER_WORD} can have at run-time.
字中的最小存储单元数。如果没有定义，缺省为@code{UNITS_PER_WORD}。否则，
其为一个常量，为@code{UNITS_PER_WORD}在运行时可以具有的最小值。
@end defmac

@defmac UNITS_PER_SIMD_WORD (@var{mode})
@en Number of units in the vectors that the vectorizer can produce for
@en scalar mode @var{mode}.  The default is equal to @code{UNITS_PER_WORD},
@en because the vectorizer can do some transformations even in absence of
@en specialized @acronym{SIMD} hardware.
向量化可以产生的向量的单元数。缺省等于@code{UNITS_PER_WORD}，
因为向量化可以在即使没有专门的@acronym{SIMD}硬件的情况下做一些转换。
@end defmac

@defmac POINTER_SIZE
@en Width of a pointer, in bits.  You must specify a value no wider than the
@en width of @code{Pmode}.  If it is not equal to the width of @code{Pmode},
@en you must define @code{POINTERS_EXTEND_UNSIGNED}.  If you do not specify
@en a value the default is @code{BITS_PER_WORD}.
指针的宽度，位数。必须指定不比@code{Pmode}宽的值。
如果其不等于@code{Pmode}的宽度，则必须定义@code{POINTERS_EXTEND_UNSIGNED}。
如果没有指定一个值，则缺省为@code{BITS_PER_WORD}。
@end defmac

@defmac POINTERS_EXTEND_UNSIGNED
@en A C expression that determines how pointers should be extended from
@en @code{ptr_mode} to either @code{Pmode} or @code{word_mode}.  It is
@en greater than zero if pointers should be zero-extended, zero if they
@en should be sign-extended, and negative if some other sort of conversion
@en is needed.  In the last case, the extension is done by the target's
@en @code{ptr_extend} instruction.
一个C表达式，用来确定指针应该如何从@code{ptr_mode}扩展为@code{Pmode}或者
@code{word_mode}。如果指针应该被零扩展，则其比0大，如果应该被符号扩展则为0，
如果需要其它转换方式则为负。对于最后一种情况，
扩展通过target的@code{ptr_extend}指令来完成。

@en You need not define this macro if the @code{ptr_mode}, @code{Pmode}
@en and @code{word_mode} are all the same width.
你不需要定义该宏，如果@code{ptr_mode}, @code{Pmode}和@code{word_mode}都为相同的宽度。
@end defmac

@defmac PROMOTE_MODE (@var{m}, @var{unsignedp}, @var{type})
@en A macro to update @var{m} and @var{unsignedp} when an object whose type
@en is @var{type} and which has the specified mode and signedness is to be
@en stored in a register.  This macro is only called when @var{type} is a
@en scalar type.
用来更新@var{m}和@var{unsignedp}，当一个类型为@var{type}并且具有特定的机器模式
的对象要被存储到寄存器中时。该宏只在@var{type}为一个标量类型时才被调用。

@en On most RISC machines, which only have operations that operate on a full
@en register, define this macro to set @var{m} to @code{word_mode} if
@en @var{m} is an integer mode narrower than @code{BITS_PER_WORD}.  In most
@en cases, only integer modes should be widened because wider-precision
@en floating-point operations are usually more expensive than their narrower
@en counterparts.
在大多数RISC机器上，只有作用于在整个寄存器上的运算，
定义该宏将@var{m}设为为@code{word_mode}，
如果@var{m}为一个比@code{BITS_PER_WORD}窄的整数模式。在大多数情况下，
只有整数模式应该被加宽，因为宽精度的浮点运算通常比相应的窄精度的运算代价要更高。

@en For most machines, the macro definition does not change @var{unsignedp}.
@en However, some machines, have instructions that preferentially handle
@en either signed or unsigned quantities of certain modes.  For example, on
@en the DEC Alpha, 32-bit loads from memory and 32-bit add instructions
@en sign-extend the result to 64 bits.  On such machines, set
@en @var{unsignedp} according to which kind of extension is more efficient.
大多数机器，宏定义不改变@var{unsignedp}。然而，
一些机器具有优先处理特定模式的有符号或者无符号的指令。例如，在DEC Alpha上，
32位load和32位add指令会将结果有符号扩展为64位。在这样的机器上，
根据扩展的类型来设置@var{unsignedp}会更加有效。

@en Do not define this macro if it would never modify @var{m}.
如果从来不会修改@var{m}，则不要定义该宏。
@end defmac

@deftypefn {Target Hook} {enum machine_mode} TARGET_PROMOTE_FUNCTION_MODE (const_tree @var{type}, enum machine_mode @var{mode}, int *@var{punsignedp}, const_tree @var{funtype}, int @var{for_return})
Like @code{PROMOTE_MODE}, but it is applied to outgoing function arguments or
function return values.  The target hook should return the new mode
and possibly change @code{*@var{punsignedp}} if the promotion should
change signedness.  This function is called only for scalar @emph{or
pointer} types.

@var{for_return} allows to distinguish the promotion of arguments and
return values.  If it is @code{1}, a return value is being promoted and
@code{TARGET_FUNCTION_VALUE} must perform the same promotions done here.
If it is @code{2}, the returned mode should be that of the register in
which an incoming parameter is copied, or the outgoing result is computed;
then the hook should return the same mode as @code{promote_mode}, though
the signedness may be different.

The default is to not promote arguments and return values.  You can
also define the hook to @code{default_promote_function_mode_always_promote}
if you would like to apply the same rules given by @code{PROMOTE_MODE}.
@end deftypefn

@defmac PARM_BOUNDARY
@en Normal alignment required for function parameters on the stack, in
@en bits.  All stack parameters receive at least this much alignment
@en regardless of data type.  On most machines, this is the same as the
@en size of an integer.
函数参数在栈上的对齐方式，位数。所有栈参数都接受这样的对齐，
而不论数据类型是什么。在大多数机器上，这与整数的大小相同。
@end defmac

@defmac STACK_BOUNDARY
@en Define this macro to the minimum alignment enforced by hardware for the
@en stack pointer on this machine.  The definition is a C expression for the
@en desired alignment (measured in bits).  This value is used as a default
@en if @code{PREFERRED_STACK_BOUNDARY} is not defined.  On most machines,
@en this should be the same as @code{PARM_BOUNDARY}.
定义该宏为硬件要求的在该机器上的栈指针的最小对齐。定义为一个C表达式，
为所要的对齐（位数）。该值作为缺省值使用，
如果没有定义@code{PREFERRED_STACK_BOUNDARY}。在大多数机器上，
这应该与@code{PARM_BOUNDARY}相同。
@end defmac

@defmac PREFERRED_STACK_BOUNDARY
@en Define this macro if you wish to preserve a certain alignment for the
@en stack pointer, greater than what the hardware enforces.  The definition
@en is a C expression for the desired alignment (measured in bits).  This
@en macro must evaluate to a value equal to or larger than
@en @code{STACK_BOUNDARY}.
定义该宏，如果你希望对栈指针维持一个特定的对齐，大于硬件要求的对齐。
定义为一个C表达式，为所要的对齐（位数）。
该宏必须等于或大于@code{STACK_BOUNDARY}。
@end defmac

@defmac INCOMING_STACK_BOUNDARY
@en Define this macro if the incoming stack boundary may be different
@en from @code{PREFERRED_STACK_BOUNDARY}.  This macro must evaluate
@en to a value equal to or larger than @code{STACK_BOUNDARY}.
@end defmac

@defmac FUNCTION_BOUNDARY
@en Alignment required for a function entry point, in bits.
函数入口点所需的对齐位数。
@end defmac

@defmac BIGGEST_ALIGNMENT
@en Biggest alignment that any data type can require on this machine, in
@en bits.  Note that this is not the biggest alignment that is supported,
@en just the biggest alignment that, when violated, may cause a fault.
该机器上任何数据类型可以需要的最大对齐位数。注意这不是所支持的最大对齐，
而是如果违反该对齐则可能会造成错误。
@end defmac

@defmac MALLOC_ABI_ALIGNMENT
Alignment, in bits, a C conformant malloc implementation has to
provide.  If not defined, the default value is @code{BITS_PER_WORD}.
@end defmac

@defmac ATTRIBUTE_ALIGNED_VALUE
Alignment used by the @code{__attribute__ ((aligned))} construct.  If
not defined, the default value is @code{BIGGEST_ALIGNMENT}.
@end defmac

@defmac MINIMUM_ATOMIC_ALIGNMENT
@en If defined, the smallest alignment, in bits, that can be given to an
@en object that can be referenced in one operation, without disturbing any
@en nearby object.  Normally, this is @code{BITS_PER_UNIT}, but may be larger
@en on machines that don't have byte or half-word store operations.
如果被定义，则为最小对齐位数，可以分给一个对象并且在一个操作中被应用，
而不需要干扰任何附近的对象。通常为@code{BITS_PER_UNIT}，
但在没有字节或半字的存储运算的机器上可以更大些。
@end defmac

@defmac BIGGEST_FIELD_ALIGNMENT
@en Biggest alignment that any structure or union field can require on this
@en machine, in bits.  If defined, this overrides @code{BIGGEST_ALIGNMENT} for
@en structure and union fields only, unless the field alignment has been set
@en by the @code{__attribute__ ((aligned (@var{n})))} construct.
任何结构体或者联合体域在该机器上需要的最大对齐。如果被定义，
这将只覆盖结构体和联合体的域的@code{BIGGEST_ALIGNMENT}，
除非域对齐已经通过@code{__attribute__ ((aligned (@var{n})))}设置。
@end defmac

@defmac ADJUST_FIELD_ALIGN (@var{field}, @var{computed})
@en An expression for the alignment of a structure field @var{field} if the
@en alignment computed in the usual way (including applying of
@en @code{BIGGEST_ALIGNMENT} and @code{BIGGEST_FIELD_ALIGNMENT} to the
@en alignment) is @var{computed}.  It overrides alignment only if the
@en field alignment has not been set by the
@en @code{__attribute__ ((aligned (@var{n})))} construct.
一个表达式，为结构体域@var{field}的对齐方式，如果对齐方式是按照通常方式计算
（包括应用@code{BIGGEST_ALIGNMENT}和@code{BIGGEST_FIELD_ALIGNMENT}）。
其只覆盖没有通过@code{__attribute__ ((aligned (@var{n})))}设置的域。
@end defmac

@defmac MAX_STACK_ALIGNMENT
Biggest stack alignment guaranteed by the backend.  Use this macro
to specify the maximum alignment of a variable on stack.

If not defined, the default value is @code{STACK_BOUNDARY}.

@c FIXME: The default should be @code{PREFERRED_STACK_BOUNDARY}.
@c But the fix for PR 32893 indicates that we can only guarantee
@c maximum stack alignment on stack up to @code{STACK_BOUNDARY}, not
@c @code{PREFERRED_STACK_BOUNDARY}, if stack alignment isn't supported.
@end defmac

@defmac MAX_OFILE_ALIGNMENT
@en Biggest alignment supported by the object file format of this machine.
@en Use this macro to limit the alignment which can be specified using the
@en @code{__attribute__ ((aligned (@var{n})))} construct.  If not defined,
@en the default value is @code{BIGGEST_ALIGNMENT}.
由该机器的目标文件格式所支持的最大对齐。使用该宏来限制可以使用
@code{__attribute__ ((aligned (@var{n})))}结构来指定的对齐。
如果没有定义，则缺省值为@code{BIGGEST_ALIGNMENT}。

@en On systems that use ELF, the default (in @file{config/elfos.h}) is
@en the largest supported 32-bit ELF section alignment representable on
@en a 32-bit host e.g. @samp{(((unsigned HOST_WIDEST_INT) 1 << 28) * 8)}.
@en On 32-bit ELF the largest supported section alignment in bits is
@en @samp{(0x80000000 * 8)}, but this is not representable on 32-bit hosts.
在使用ELF的系统上，缺省（在@file{config/elfos.h}中）为在32位host上可以表示的
32位ELF section对齐，即@samp{(((unsigned HOST_WIDEST_INT) 1 << 28) * 8)}。
在32位ELF上，最大支持的section对齐位数是@samp{(0x80000000 * 8)}，
但这在32位host上无法表示。
@end defmac

@defmac DATA_ALIGNMENT (@var{type}, @var{basic-align})
@en If defined, a C expression to compute the alignment for a variable in
@en the static store.  @var{type} is the data type, and @var{basic-align} is
@en the alignment that the object would ordinarily have.  The value of this
@en macro is used instead of that alignment to align the object.
如果定义，则为一个C表达式，来计算在静态存储中的变量的对齐。
@var{type}为数据类型，@var{basic-align}为对象通常具有的对齐。
该宏的值被用于替代那个对齐，并应用的对象上。

@en If this macro is not defined, then @var{basic-align} is used.
如果该宏没有定义，则使用@var{basic-align}。

@findex strcpy
@en One use of this macro is to increase alignment of medium-size data to
@en make it all fit in fewer cache lines.  Another is to cause character
@en arrays to be word-aligned so that @code{strcpy} calls that copy
@en constants to character arrays can be done inline.
该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。
另一种用法是使得字符数组按照字对齐，这样@code{strcpy}调用可以通过内联方式完成。
@end defmac

@defmac CONSTANT_ALIGNMENT (@var{constant}, @var{basic-align})
@en If defined, a C expression to compute the alignment given to a constant
@en that is being placed in memory.  @var{constant} is the constant and
@en @var{basic-align} is the alignment that the object would ordinarily
@en have.  The value of this macro is used instead of that alignment to
@en align the object.
如果定义，为一个C表达式，来计算放在内存中的常量的对齐。@var{constant}为常量，
@var{basic-align}为该对象通常具有的对齐。该宏的值被用于替代那个对齐，
并应用的对象上。

@en If this macro is not defined, then @var{basic-align} is used.
如果该宏没有定义，则使用@var{basic-align}。

@en The typical use of this macro is to increase alignment for string
@en constants to be word aligned so that @code{strcpy} calls that copy
@en constants can be done inline.
该宏的典型用法为增加字符串常量的对齐，使其为字对齐，
这样@code{strcpy}调用可以通过内联方式完成。
@end defmac

@defmac LOCAL_ALIGNMENT (@var{type}, @var{basic-align})
@en If defined, a C expression to compute the alignment for a variable in
@en the local store.  @var{type} is the data type, and @var{basic-align} is
@en the alignment that the object would ordinarily have.  The value of this
@en macro is used instead of that alignment to align the object.
如果定义，为一个C表达式，来计算在局部存储中的对象的对齐。@var{type}为数据类型，
@var{basic-align}为对象通常的对齐。该宏的值被用于替代那个对齐，并应用的对象上。

@en If this macro is not defined, then @var{basic-align} is used.
如果该宏没有定义，则使用@var{basic-align}。

@en One use of this macro is to increase alignment of medium-size data to
@en make it all fit in fewer cache lines.
该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。

If the value of this macro has a type, it should be an unsigned type.
@end defmac

@defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})
If defined, a C expression to compute the alignment for stack slot.
@var{type} is the data type, @var{mode} is the widest mode available,
and @var{basic-align} is the alignment that the slot would ordinarily
have.  The value of this macro is used instead of that alignment to
align the slot.

If this macro is not defined, then @var{basic-align} is used when
@var{type} is @code{NULL}.  Otherwise, @code{LOCAL_ALIGNMENT} will
be used.

This macro is to set alignment of stack slot to the maximum alignment
of all possible modes which the slot may have.

If the value of this macro has a type, it should be an unsigned type.
@end defmac

@defmac LOCAL_DECL_ALIGNMENT (@var{decl})
If defined, a C expression to compute the alignment for a local
variable @var{decl}.

If this macro is not defined, then
@code{LOCAL_ALIGNMENT (TREE_TYPE (@var{decl}), DECL_ALIGN (@var{decl}))}
is used.

One use of this macro is to increase alignment of medium-size data to
make it all fit in fewer cache lines.

If the value of this macro has a type, it should be an unsigned type.
@end defmac

@defmac MINIMUM_ALIGNMENT (@var{exp}, @var{mode}, @var{align})
If defined, a C expression to compute the minimum required alignment
for dynamic stack realignment purposes for @var{exp} (a type or decl),
@var{mode}, assuming normal alignment @var{align}.

If this macro is not defined, then @var{align} will be used.
@end defmac

@defmac EMPTY_FIELD_BOUNDARY
@en Alignment in bits to be given to a structure bit-field that follows an
@en empty field such as @code{int : 0;}.
允许像@code{int : 0;}；这样的空域的结构体位域的对齐位数。

@en If @code{PCC_BITFIELD_TYPE_MATTERS} is true, it overrides this macro.
如果@code{PCC_BITFIELD_TYPE_MATTERS}为真，则其覆盖该宏。
@end defmac

@defmac STRUCTURE_SIZE_BOUNDARY
@en Number of bits which any structure or union's size must be a multiple of.
@en Each structure or union's size is rounded up to a multiple of this.
任何结构体或联合体的大小必须为该位数的倍数。
每个结构体或联合体的大小都将被舍入到该位数的一个倍数。

@en If you do not define this macro, the default is the same as
@en @code{BITS_PER_UNIT}.
如果没有定义该宏，则缺省与@code{BITS_PER_UNIT}相同。
@end defmac

@defmac STRICT_ALIGNMENT
@en Define this macro to be the value 1 if instructions will fail to work
@en if given data not on the nominal alignment.  If instructions will merely
@en go slower in that case, define this macro as 0.
定义该宏值为1，如果给定数据不在通常对齐方式上，则指令无法工作。
如果对于这种情况指令只不过是变慢，则定义该宏为0。
@end defmac

@defmac PCC_BITFIELD_TYPE_MATTERS
@en Define this if you wish to imitate the way many other C compilers handle
@en alignment of bit-fields and the structures that contain them.
定义该宏，如果你希望仿效许多其它C编译器处理位域和包含它们的结构体的对齐方式。

@en The behavior is that the type written for a named bit-field (@code{int},
@en @code{short}, or other integer type) imposes an alignment for the entire
@en structure, as if the structure really did contain an ordinary field of
@en that type.  In addition, the bit-field is placed within the structure so
@en that it would fit within such a field, not crossing a boundary for it.
该行为是书写为命名位域（@code{int},@code{short}或其它整数类型）的类型被实施
用于整个结构体的对齐，就好像结构体包含了一个该类型的普通的域。另外，
位域放在结构体中，使得其将适合这样的域，而不会跨越边界。

@en Thus, on most machines, a named bit-field whose type is written as
@en @code{int} would not cross a four-byte boundary, and would force
@en four-byte alignment for the whole structure.  (The alignment used may
@en not be four bytes; it is controlled by the other alignment parameters.)
这样，大多数机器上，书写为@code{int}的命名位域将不会跨越一个四字节的边界，
并将使得整个结构体为四字节对齐。（可能不使用四字节对齐；其由其它对齐参数控制。）

@en An unnamed bit-field will not affect the alignment of the containing
@en structure.
一个没有命名的位域将不会影响包含结构体的对齐。

@en If the macro is defined, its definition should be a C expression;
@en a nonzero value for the expression enables this behavior.
如果定义了该宏，则其定义为一个C表达式；该表达式的非0值会使用这样方式。

@en Note that if this macro is not defined, or its value is zero, some
@en bit-fields may cross more than one alignment boundary.  The compiler can
@en support such references if there are @samp{insv}, @samp{extv}, and
@en @samp{extzv} insns that can directly reference memory.
注意如果该宏没有定义，或者其值为0，则一些位域可能跨越多于一个的对齐边界。
编译器可以支持这种引用，如果有@samp{insv}, 
@samp{extv}和@samp{extzv} insns可以直接引用内存。

@en The other known way of making bit-fields work is to define
@en @code{STRUCTURE_SIZE_BOUNDARY} as large as @code{BIGGEST_ALIGNMENT}.
@en Then every structure can be accessed with fullwords.
其它已知的可以使位域工作的的方式为定义@code{STRUCTURE_SIZE_BOUNDARY}和@code{BIGGEST_ALIGNMENT}一样大。

@en Unless the machine has bit-field instructions or you define
@en @code{STRUCTURE_SIZE_BOUNDARY} that way, you must define
@en @code{PCC_BITFIELD_TYPE_MATTERS} to have a nonzero value.
除非机器具有位域指令或者你按照那种方式定义了@code{STRUCTURE_SIZE_BOUNDARY}，
否则你必须定义@code{PCC_BITFIELD_TYPE_MATTERS}具有非0值。

@en If your aim is to make GCC use the same conventions for laying out
@en bit-fields as are used by another compiler, here is how to investigate
@en what the other compiler does.  Compile and run this program:
如果你的目标是使得GCC使用与其它编译器相同的约定来布局位域，
则这里有一种方式可以调查其它编译器是如何做的。编译运行该程序：

@smallexample
struct foo1
@{
  char x;
  char :0;
  char y;
@};

struct foo2
@{
  char x;
  int :0;
  char y;
@};

main ()
@{
  printf ("Size of foo1 is %d\n",
          sizeof (struct foo1));
  printf ("Size of foo2 is %d\n",
          sizeof (struct foo2));
  exit (0);
@}
@end smallexample

@en If this prints 2 and 5, then the compiler's behavior is what you would
@en get from @code{PCC_BITFIELD_TYPE_MATTERS}.
如果其打印2和5，则编译器的行为就是你通过@code{PCC_BITFIELD_TYPE_MATTERS}获得的效果。
@end defmac

@defmac BITFIELD_NBYTES_LIMITED
@en Like @code{PCC_BITFIELD_TYPE_MATTERS} except that its effect is limited
@en to aligning a bit-field within the structure.
跟@code{PCC_BITFIELD_TYPE_MATTERS}相似，除了它只影响结构体中的位域的对齐。
@end defmac

@deftypefn {Target Hook} bool TARGET_ALIGN_ANON_BITFIELD (void)
@en When @code{PCC_BITFIELD_TYPE_MATTERS} is true this hook will determine
@en whether unnamed bitfields affect the alignment of the containing
@en structure.  The hook should return true if the structure should inherit
@en the alignment requirements of an unnamed bitfield's type.
当@code{PCC_BITFIELD_TYPE_MATTERS}为真，
该钩子将确定未命名位域是否要影响包含它的结构体的对齐。
钩子应该返回真，如果结构体应该继承未命名位域的类型所要求的对齐。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_NARROW_VOLATILE_BITFIELD (void)
@en This target hook should return @code{true} if accesses to volatile bitfields
@en should use the narrowest mode possible.  It should return @code{false} if
@en these accesses should use the bitfield container type.
该target钩子应该返回@code{true}，如果访问volatile位域应该尽可能使用最窄的机器模式。其应该返回@code{false}，如果这些访问应该使用位域的容器的类型。

@en The default is @code{!TARGET_STRICT_ALIGN}.
缺省为@code{!TARGET_STRICT_ALIGN}。
@end deftypefn

@defmac MEMBER_TYPE_FORCES_BLK (@var{field}, @var{mode})
@en Return 1 if a structure or array containing @var{field} should be accessed using
@en @code{BLKMODE}.
返回1，如果一个包含@var{field}的结构体或者数组应该使用@code{BLKMODE}模式来访问。

@en If @var{field} is the only field in the structure, @var{mode} is its
@en mode, otherwise @var{mode} is VOIDmode.  @var{mode} is provided in the
@en case where structures of one field would require the structure's mode to
@en retain the field's mode.
如果@var{field}为结构体中唯一的域，则@var{mode}为它的机器模式，
否则@var{mode}为VOIDmode。

@en Normally, this is not needed.
通常，不需要该宏。
@end defmac

@defmac ROUND_TYPE_ALIGN (@var{type}, @var{computed}, @var{specified})
@en Define this macro as an expression for the alignment of a type (given
@en by @var{type} as a tree node) if the alignment computed in the usual
@en way is @var{computed} and the alignment explicitly specified was
@en @var{specified}.
定义该宏为一个表达式，为一个类型（由作为树节点的@var{type}给定）的对齐，
如果按照通常方式计算的对齐方式为@var{computed}并且显示指定的对齐方式为@var{specified}。

@en The default is to use @var{specified} if it is larger; otherwise, use
@en the smaller of @var{computed} and @code{BIGGEST_ALIGNMENT}
缺省是使用@var{specified}，如果其更大；
否则使用@var{computed}和@code{BIGGEST_ALIGNMENT}中较小的。
@end defmac

@defmac MAX_FIXED_MODE_SIZE
@en An integer expression for the size in bits of the largest integer
@en machine mode that should actually be used.  All integer machine modes of
@en this size or smaller can be used for structures and unions with the
@en appropriate sizes.  If this macro is undefined, @code{GET_MODE_BITSIZE
@en (DImode)} is assumed.
一个整数表达式，为实际应该被使用的最大的整数机器模式的位数。
所有该大小或者更小一些的整数机器模式都可以用于结构体和联合体。
如果哦没有定义该宏，则假设为@code{GET_MODE_BITSIZE (DImode)}。
@end defmac

@defmac STACK_SAVEAREA_MODE (@var{save_level})
@en If defined, an expression of type @code{enum machine_mode} that
@en specifies the mode of the save area operand of a
@en @code{save_stack_@var{level}} named pattern (@pxref{Standard Names}).
@en @var{save_level} is one of @code{SAVE_BLOCK}, @code{SAVE_FUNCTION}, or
@en @code{SAVE_NONLOCAL} and selects which of the three named patterns is
@en having its mode specified.
如果定义，则为一个@code{enum machine_mode}类型的表达式，
指定名为@code{save_stack_@var{level}}的指令模式（@pxref{Standard Names}）的save区域操作数的机器模式。
@var{save_level}为@code{SAVE_BLOCK}, @code{SAVE_FUNCTION}或@code{SAVE_NONLOCAL}中之一。

@en You need not define this macro if it always returns @code{Pmode}.  You
@en would most commonly define this macro if the
@en @code{save_stack_@var{level}} patterns need to support both a 32- and a
@en 64-bit mode.
你不需要定义该宏，如果其总是返回@code{Pmode}。你通常将会定义该宏，
如果@code{save_stack_@var{level}}指令模式需要同时支持32和64位机器模式。
@end defmac

@defmac STACK_SIZE_MODE
@en If defined, an expression of type @code{enum machine_mode} that
@en specifies the mode of the size increment operand of an
@en @code{allocate_stack} named pattern (@pxref{Standard Names}).
如果定义，为一个@code{enum machine_mode}类型的表达式，
指定名为@code{allocate_stack}的指令模式（@pxref{Standard Names}）的size increment操作数的机器模式。

@en You need not define this macro if it always returns @code{word_mode}.
@en You would most commonly define this macro if the @code{allocate_stack}
@en pattern needs to support both a 32- and a 64-bit mode.
你不需要定义该宏，如果其总是返回@code{word_mode}。你通常将会定义该宏，
如果@code{allocate_stack}指令模式需要同时支持32和64位机器模式。
@end defmac

@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_CMP_RETURN_MODE (void)
@en This target hook should return the mode to be used for the return value
@en of compare instructions expanded to libgcc calls.  If not defined
@en @code{word_mode} is returned which is the right choice for a majority of
@en targets.
该target钩子应该返回扩展为libgcc调用的比较指令的返回值的机器模式。
如果没有定义，则返回@code{word_mode}，其对于大多数target是正确的。
@end deftypefn

@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_SHIFT_COUNT_MODE (void)
@en This target hook should return the mode to be used for the shift count operand
@en of shift instructions expanded to libgcc calls.  If not defined
@en @code{word_mode} is returned which is the right choice for a majority of
@en targets.
该target钩子应该返回扩展为libgcc调用的移位指令的shift count操作数的机器模式。
如果没有定义，则返回@code{word_mode}，其对于大多数target是正确的。
@end deftypefn

@deftypefn {Target Hook} {enum machine_mode} TARGET_UNWIND_WORD_MODE (void)
Return machine mode to be used for @code{_Unwind_Word} type.
The default is to use @code{word_mode}.
@end deftypefn

@defmac ROUND_TOWARDS_ZERO
@en If defined, this macro should be true if the prevailing rounding
@en mode is towards zero.
如果定义，该宏应该为真，如果舍入的模式是朝向0。

@en Defining this macro only affects the way @file{libgcc.a} emulates
@en floating-point arithmetic.
定义该宏只影响@file{libgcc.a}模拟浮点算术的方式。

@en Not defining this macro is equivalent to returning zero.
不定义该宏，等价于其返回0。
@end defmac

@defmac LARGEST_EXPONENT_IS_NORMAL (@var{size})
@en This macro should return true if floats with @var{size}
@en bits do not have a NaN or infinity representation, but use the largest
@en exponent for normal numbers instead.
该宏应该返回真，如果具有@var{size}位数的浮点不具有NaN或无穷的表示，
但是使用最大的普通数的指数来替代表示。

@en Defining this macro only affects the way @file{libgcc.a} emulates
@en floating-point arithmetic.
定义该宏只影响@file{libgcc.a}模拟浮点算术的方式。

@en The default definition of this macro returns false for all sizes.
该宏缺省定义对所有的size都返回假。
@end defmac

@deftypefn {Target Hook} bool TARGET_MS_BITFIELD_LAYOUT_P (const_tree @var{record_type})
This target hook returns @code{true} if bit-fields in the given
@var{record_type} are to be laid out following the rules of Microsoft
Visual C/C++, namely: (i) a bit-field won't share the same storage
unit with the previous bit-field if their underlying types have
different sizes, and the bit-field will be aligned to the highest
alignment of the underlying types of itself and of the previous
bit-field; (ii) a zero-sized bit-field will affect the alignment of
the whole enclosing structure, even if it is unnamed; except that
(iii) a zero-sized bit-field will be disregarded unless it follows
another bit-field of nonzero size.  If this hook returns @code{true},
other macros that control bit-field layout are ignored.

When a bit-field is inserted into a packed record, the whole size
of the underlying type is used by one or more same-size adjacent
bit-fields (that is, if its long:3, 32 bits is used in the record,
and any additional adjacent long bit-fields are packed into the same
chunk of 32 bits.  However, if the size changes, a new field of that
size is allocated).  In an unpacked record, this is the same as using
alignment, but not equivalent when packing.

If both MS bit-fields and @samp{__attribute__((packed))} are used,
the latter will take precedence.  If @samp{__attribute__((packed))} is
used on a single field when MS bit-fields are in use, it will take
precedence for that field, but the alignment of the rest of the structure
may affect its placement.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_DECIMAL_FLOAT_SUPPORTED_P (void)
@en Returns true if the target supports decimal floating point.
返回真，如果target支持十进制浮点。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_FIXED_POINT_SUPPORTED_P (void)
@en Returns true if the target supports fixed-point arithmetic.
返回真，如果target支持定点算术。
@end deftypefn

@deftypefn {Target Hook} void TARGET_EXPAND_TO_RTL_HOOK (void)
@en This hook is called just before expansion into rtl, allowing the target
@en to perform additional initializations or analysis before the expansion.
@en For example, the rs6000 port uses it to allocate a scratch stack slot
@en for use in copying SDmode values between memory and floating point
@en registers whenever the function being expanded has any SDmode
@en usage.
该钩子在扩展为rtl之前被调用，允许target在扩展前执行额外的实例化或者分析。
例如，rs6000port使用它来分配scratch栈槽，当被扩展的函数具有任何SDmode使用时，
用于在内存和浮点寄存器之间复制SDmode值。
@end deftypefn

@deftypefn {Target Hook} void TARGET_INSTANTIATE_DECLS (void)
@en This hook allows the backend to perform additional instantiations on rtl
@en that are not actually in any insns yet, but will be later.
该钩子允许后端执行额外的rtl实例化，这些实际上不存在于任何insn中，但在之后会有。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_MANGLE_TYPE (const_tree @var{type})
If your target defines any fundamental types, or any types your target
uses should be mangled differently from the default, define this hook
to return the appropriate encoding for these types as part of a C++
mangled name.  The @var{type} argument is the tree structure representing
the type to be mangled.  The hook may be applied to trees which are
not target-specific fundamental types; it should return @code{NULL}
for all such types, as well as arguments it does not recognize.  If the
return value is not @code{NULL}, it must point to a statically-allocated
string constant.

Target-specific fundamental types might be new fundamental types or
qualified versions of ordinary fundamental types.  Encode new
fundamental types as @samp{@w{u @var{n} @var{name}}}, where @var{name}
is the name used for the type in source code, and @var{n} is the
length of @var{name} in decimal.  Encode qualified versions of
ordinary types as @samp{@w{U @var{n} @var{name} @var{code}}}, where
@var{name} is the name used for the type qualifier in source code,
@var{n} is the length of @var{name} as above, and @var{code} is the
code used to represent the unqualified version of this type.  (See
@code{write_builtin_type} in @file{cp/mangle.c} for the list of
codes.)  In both cases the spaces are for clarity; do not include any
spaces in your string.

This hook is applied to types prior to typedef resolution.  If the mangled
name for a particular type depends only on that type's main variant, you
can perform typedef resolution yourself using @code{TYPE_MAIN_VARIANT}
before mangling.

The default version of this hook always returns @code{NULL}, which is
appropriate for a target that does not define any new fundamental
types.
@end deftypefn

@en @node Type Layout
@en @section Layout of Source Language Data Types
@node Type Layout
@section 源语言的数据类型布局

@en These macros define the sizes and other characteristics of the standard
@en basic data types used in programs being compiled.  Unlike the macros in
@en the previous section, these apply to specific features of C and related
@en languages, rather than to fundamental aspects of storage layout.
这些宏定义了在被编译的程序中使用的标准基础数据类型的大小和其它特征。
不像之前章节中的宏，这些是应用到C和相关语言的特定特征上，
而不是存储布局的基础方面。

@defmac INT_TYPE_SIZE
@en A C expression for the size in bits of the type @code{int} on the
@en target machine.  If you don't define this, the default is one word.
一个C表达式，为在target机器上类型@code{int}的位大小。
如果没有定义，缺省为一个字。
@end defmac

@defmac SHORT_TYPE_SIZE
@en A C expression for the size in bits of the type @code{short} on the
@en target machine.  If you don't define this, the default is half a word.
@en (If this would be less than one storage unit, it is rounded up to one
@en unit.)
一个C表达式，为在target机器上类型@code{short}的位大小。如果没有定义，
缺省为半个字。（如果比一个存储单元小，则会向上舍入为一个单元。）
@end defmac

@defmac LONG_TYPE_SIZE
@en A C expression for the size in bits of the type @code{long} on the
@en target machine.  If you don't define this, the default is one word.
一个C表达式，为在target机器上类型@code{long}的位大小。
如果没有定义，缺省为一个字。
@end defmac

@defmac ADA_LONG_TYPE_SIZE
@en On some machines, the size used for the Ada equivalent of the type
@en @code{long} by a native Ada compiler differs from that used by C@.  In
@en that situation, define this macro to be a C expression to be used for
@en the size of that type.  If you don't define this, the default is the
@en value of @code{LONG_TYPE_SIZE}.
在一些机器上，本地Ada编译器使用的类型@code{long}的大小与C使用的不相同。
这种情况下，定义该宏为一个C表达式用于那个类型的大小。如果没有定义，
则缺省为@code{LONG_TYPE_SIZE}的值。
@end defmac

@defmac LONG_LONG_TYPE_SIZE
@en A C expression for the size in bits of the type @code{long long} on the
@en target machine.  If you don't define this, the default is two
@en words.  If you want to support GNU Ada on your machine, the value of this
@en macro must be at least 64.
一个C表达式，为在target机器上类型@code{long long}的位大小。如果没有定义，
缺省为两个字。如果你想在你的机器上支持GNU Ada，则该宏的值最少必须为64。
@end defmac

@defmac CHAR_TYPE_SIZE
@en A C expression for the size in bits of the type @code{char} on the
@en target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT}.
一个C表达式，为在target机器上类型@code{char}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT}。
@end defmac

@defmac BOOL_TYPE_SIZE
@en A C expression for the size in bits of the C++ type @code{bool} and
@en C99 type @code{_Bool} on the target machine.  If you don't define
@en this, and you probably shouldn't, the default is @code{CHAR_TYPE_SIZE}.
一个C表达式，为在target机器上C++类型@code{bool}和C99类型@code{_Bool}的位大小。
如果没有定义，并且通常不会定义，缺省为@code{CHAR_TYPE_SIZE}。
@end defmac

@defmac FLOAT_TYPE_SIZE
@en A C expression for the size in bits of the type @code{float} on the
@en target machine.  If you don't define this, the default is one word.
一个C表达式，为在target机器上类型@code{float}的位大小。
如果没有定义，缺省为一个字。
@end defmac

@defmac DOUBLE_TYPE_SIZE
@en A C expression for the size in bits of the type @code{double} on the
@en target machine.  If you don't define this, the default is two
@en words.
一个C表达式，为在target机器上类型@code{double}的位大小。
如果没有定义，缺省为两个字。
@end defmac

@defmac LONG_DOUBLE_TYPE_SIZE
@en A C expression for the size in bits of the type @code{long double} on
@en the target machine.  If you don't define this, the default is two
@en words.
一个C表达式，为在target机器上类型@code{long double}的位大小。
如果没有定义，缺省为两个字。
@end defmac

@defmac SHORT_FRACT_TYPE_SIZE
@en A C expression for the size in bits of the type @code{short _Fract} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT}.
一个C表达式，为在target机器上类型@code{short _Fract}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT}。
@end defmac

@defmac FRACT_TYPE_SIZE
@en A C expression for the size in bits of the type @code{_Fract} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT * 2}.
一个C表达式，为在target机器上类型@code{_Fract}的位大小。如果没有定义，
缺省为@code{BITS_PER_UNIT * 2}。
@end defmac

@defmac LONG_FRACT_TYPE_SIZE
@en A C expression for the size in bits of the type @code{long _Fract} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT * 4}.
一个C表达式，为在target机器上类型@code{long _Fract}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 4}。
@end defmac

@defmac LONG_LONG_FRACT_TYPE_SIZE
@en A C expression for the size in bits of the type @code{long long _Fract} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT * 8}.
一个C表达式，为在target机器上类型@code{long long _Fract}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 8}。
@end defmac

@defmac SHORT_ACCUM_TYPE_SIZE
@en A C expression for the size in bits of the type @code{short _Accum} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT * 2}.
一个C表达式，为在target机器上类型@code{short _Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 2}。
@end defmac

@defmac ACCUM_TYPE_SIZE
@en A C expression for the size in bits of the type @code{_Accum} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT * 4}.
一个C表达式，为在target机器上类型@code{_Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 4}。
@end defmac

@defmac LONG_ACCUM_TYPE_SIZE
@en A C expression for the size in bits of the type @code{long _Accum} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT * 8}.
一个C表达式，为在target机器上类型@code{long _Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 8}。
@end defmac

@defmac LONG_LONG_ACCUM_TYPE_SIZE
@en A C expression for the size in bits of the type @code{long long _Accum} on
@en the target machine.  If you don't define this, the default is
@en @code{BITS_PER_UNIT * 16}.
一个C表达式，为在target机器上类型@code{long long _Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 16}。
@end defmac

@defmac LIBGCC2_LONG_DOUBLE_TYPE_SIZE
@en Define this macro if @code{LONG_DOUBLE_TYPE_SIZE} is not constant or
@en if you want routines in @file{libgcc2.a} for a size other than
@en @code{LONG_DOUBLE_TYPE_SIZE}.  If you don't define this, the
@en default is @code{LONG_DOUBLE_TYPE_SIZE}.
定义该宏，如果@code{LONG_DOUBLE_TYPE_SIZE}不是常量或者如果你想让@file{libgcc2.a}
中具有大小不是@code{LONG_DOUBLE_TYPE_SIZE}的程序。如果没有定义，
缺省为@code{LONG_DOUBLE_TYPE_SIZE}。
@end defmac

@defmac LIBGCC2_HAS_DF_MODE
@en Define this macro if neither @code{DOUBLE_TYPE_SIZE} nor
@en @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is
@en @code{DFmode} but you want @code{DFmode} routines in @file{libgcc2.a}
@en anyway.  If you don't define this and either @code{DOUBLE_TYPE_SIZE}
@en or @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is 64 then the default is 1,
@en otherwise it is 0.
定义该宏，如果@code{DOUBLE_TYPE_SIZE}和
@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}都不是@code{DFmode}，
但是你还想让@file{libgcc2.a}中具有@code{DFmode}的程序。如果没有定义，
并且@code{DOUBLE_TYPE_SIZE}或@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}为64，
则缺省为1，否则为0。
@end defmac

@defmac LIBGCC2_HAS_XF_MODE
@en Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not
@en @code{XFmode} but you want @code{XFmode} routines in @file{libgcc2.a}
@en anyway.  If you don't define this and @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}
@en is 80 then the default is 1, otherwise it is 0.
定义该宏，如果@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}不是@code{XFmode}，
但是你还想让@file{libgcc2.a}中具有@code{XFmode}的程序。如果没有定义，
并且@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}为80，则缺省为1，否则为0。
@end defmac

@defmac LIBGCC2_HAS_TF_MODE
@en Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not
@en @code{TFmode} but you want @code{TFmode} routines in @file{libgcc2.a}
@en anyway.  If you don't define this and @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}
@en is 128 then the default is 1, otherwise it is 0.
定义该宏，如果@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}不是@code{TFmode}，
但是你还想让@file{libgcc2.a}中具有@code{TFmode}的程序。如果没有定义，
并且@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}为128，则缺省为1，否则为0。
@end defmac

@defmac SF_SIZE
@defmacx DF_SIZE
@defmacx XF_SIZE
@defmacx TF_SIZE
@en Define these macros to be the size in bits of the mantissa of
@en @code{SFmode}, @code{DFmode}, @code{XFmode} and @code{TFmode} values,
@en if the defaults in @file{libgcc2.h} are inappropriate.  By default,
@en @code{FLT_MANT_DIG} is used for @code{SF_SIZE}, @code{LDBL_MANT_DIG}
@en for @code{XF_SIZE} and @code{TF_SIZE}, and @code{DBL_MANT_DIG} or
@en @code{LDBL_MANT_DIG} for @code{DF_SIZE} according to whether
@en @code{DOUBLE_TYPE_SIZE} or
@en @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is 64.
定义这些宏为@code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}值的尾数
位大小，如果在@file{libgcc2.h}中的缺省定义不合适。缺省的，
@code{FLT_MANT_DIG}用于@code{SF_SIZE}, @code{LDBL_MANT_DIG}用于@code{XF_SIZE}和
@code{TF_SIZE}，并且@code{DBL_MANT_DIG}或@code{LDBL_MANT_DIG}用于
@code{DF_SIZE}，根据@code{DOUBLE_TYPE_SIZE}或
@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}是否为64。
@end defmac

@defmac TARGET_FLT_EVAL_METHOD
@en A C expression for the value for @code{FLT_EVAL_METHOD} in @file{float.h},
@en assuming, if applicable, that the floating-point control word is in its
@en default state.  If you do not define this macro the value of
@en @code{FLT_EVAL_METHOD} will be zero.
一个C表达式，为@file{float.h}中的@code{FLT_EVAL_METHOD}的值。
如果没有定义，则@code{FLT_EVAL_METHOD}的值将为0。
@end defmac

@defmac WIDEST_HARDWARE_FP_SIZE
@en A C expression for the size in bits of the widest floating-point format
@en supported by the hardware.  If you define this macro, you must specify a
@en value less than or equal to the value of @code{LONG_DOUBLE_TYPE_SIZE}.
@en If you do not define this macro, the value of @code{LONG_DOUBLE_TYPE_SIZE}
@en is the default.
一个C表达式，为硬件支持的最宽浮点格式的位数。如果定义该宏，
则必须指定一个小于或等于@code{LONG_DOUBLE_TYPE_SIZE}的值。如果没有定义，
则缺省为@code{LONG_DOUBLE_TYPE_SIZE}的值。
@end defmac

@defmac DEFAULT_SIGNED_CHAR
@en An expression whose value is 1 or 0, according to whether the type
@en @code{char} should be signed or unsigned by default.  The user can
@en always override this default with the options @option{-fsigned-char}
@en and @option{-funsigned-char}.
一个表达式，其值为1或者0，根据类型@code{char}缺省应该为有符号的还是无符号的。
用户总是可以使用选项@option{-fsigned-char}和@option{-funsigned-char}来覆盖该缺省定义。
@end defmac

@deftypefn {Target Hook} bool TARGET_DEFAULT_SHORT_ENUMS (void)
@en This target hook should return true if the compiler should give an
@en @code{enum} type only as many bytes as it takes to represent the range
@en of possible values of that type.  It should return false if all
@en @code{enum} types should be allocated like @code{int}.
该target钩子应该返回真，如果编译器应该为@code{enum}类型设置为可以表示该类型值
范围的字节数。其应该返回假，如果所有的@code{enum}类型应该按照@code{int}类型的
方式来分配。

@en The default is to return false.
缺省为返回假。
@end deftypefn

@defmac SIZE_TYPE
@en A C expression for a string describing the name of the data type to use
@en for size values.  The typedef name @code{size_t} is defined using the
@en contents of the string.
一个C表达式，为一个字符串描述了用于size值的数据类型名。
typedef名@code{size_t}使用该字符串的内容来定义。

@en The string can contain more than one keyword.  If so, separate them with
@en spaces, and write first any length keyword, then @code{unsigned} if
@en appropriate, and finally @code{int}.  The string must exactly match one
@en of the data type names defined in the function
@en @code{init_decl_processing} in the file @file{c-decl.c}.  You may not
@en omit @code{int} or change the order---that would cause the compiler to
@en crash on startup.
字符串可以包含多一个的关键字。如果是这样，则将它们使用空格分开，
首先是任意长度的关键字，然后是合适@code{unsigned} 的，最后是@code{int}。
字符串必须显示的匹配文件@file{c-decl.c}中函数@code{init_decl_processing}中
定义的数据类型名。不可以省略掉@code{int}或者改变顺序，
这将会使编译器在启动时崩溃。

@en If you don't define this macro, the default is @code{"long unsigned
@en int"}.
如果没有定义，缺省为@code{"long unsigned int"}。
@end defmac

@defmac PTRDIFF_TYPE
@en A C expression for a string describing the name of the data type to use
@en for the result of subtracting two pointers.  The typedef name
@en @code{ptrdiff_t} is defined using the contents of the string.  See
@en @code{SIZE_TYPE} above for more information.
一个C表达式，为一个字符串，描述了用于两个指针相减的结果的数据类型名。
typedef名@code{ptrdiff_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

@en If you don't define this macro, the default is @code{"long int"}.
如果没有定义，则缺省为@code{"long int"}。
@end defmac

@defmac WCHAR_TYPE
@en A C expression for a string describing the name of the data type to use
@en for wide characters.  The typedef name @code{wchar_t} is defined using
@en the contents of the string.  See @code{SIZE_TYPE} above for more
@en information.
一个C表达式，为一个字符串，描述了用于宽字符的数据类型名。
typedef名@code{wchar_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

@en If you don't define this macro, the default is @code{"int"}.
如果没有定义，则缺省为@code{"int"}。
@end defmac

@defmac WCHAR_TYPE_SIZE
@en A C expression for the size in bits of the data type for wide
@en characters.  This is used in @code{cpp}, which cannot make use of
@en @code{WCHAR_TYPE}.
一个C表达式，为宽字符数据类型的位数。
这用于不能使用@code{WCHAR_TYPE}的@code{cpp}中。
@end defmac

@defmac WINT_TYPE
@en A C expression for a string describing the name of the data type to
@en use for wide characters passed to @code{printf} and returned from
@en @code{getwc}.  The typedef name @code{wint_t} is defined using the
@en contents of the string.  See @code{SIZE_TYPE} above for more
@en information.
一个C表达式，为一个字符串，
描述了传递给@code{printf}并且从@code{getwc}中返回的宽字符数据类型名。
typedef名@code{wint_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

@en If you don't define this macro, the default is @code{"unsigned int"}.
如果没有定义，则缺省为@code{"unsigned int"}。
@end defmac

@defmac INTMAX_TYPE
@en A C expression for a string describing the name of the data type that
@en can represent any value of any standard or extended signed integer type.
@en The typedef name @code{intmax_t} is defined using the contents of the
@en string.  See @code{SIZE_TYPE} above for more information.
一个C表达式，为一个字符串，
描述了可以表示任何标准或者扩展的有符号整数类型值的数据类型名。
typedef名@code{intmax_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

@en If you don't define this macro, the default is the first of
@en @code{"int"}, @code{"long int"}, or @code{"long long int"} that has as
@en much precision as @code{long long int}.
如果没有定义，则缺省为@code{"int"}, @code{"long int"}或
@code{"long long int"}中第一个与@code{long long int}具有相同精度的字符串。
@end defmac

@defmac UINTMAX_TYPE
@en A C expression for a string describing the name of the data type that
@en can represent any value of any standard or extended unsigned integer
@en type.  The typedef name @code{uintmax_t} is defined using the contents
@en of the string.  See @code{SIZE_TYPE} above for more information.
一个C表达式，为一个字符串，
描述了可以表示任何标准或者扩展的无符号整数类型值的数据类型名。
typedef名@code{uintmax_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

@en If you don't define this macro, the default is the first of
@en @code{"unsigned int"}, @code{"long unsigned int"}, or @code{"long long
@en unsigned int"} that has as much precision as @code{long long unsigned
@en int}.
如果没有定义，则缺省为@code{"unsigned int"}, @code{"long unsigned int"}或
@code{"long long unsigned int"}中第一个与@code{long long unsigned int}
具有相同精度的字符串。
@end defmac

@defmac SIG_ATOMIC_TYPE
@defmacx INT8_TYPE
@defmacx INT16_TYPE
@defmacx INT32_TYPE
@defmacx INT64_TYPE
@defmacx UINT8_TYPE
@defmacx UINT16_TYPE
@defmacx UINT32_TYPE
@defmacx UINT64_TYPE
@defmacx INT_LEAST8_TYPE
@defmacx INT_LEAST16_TYPE
@defmacx INT_LEAST32_TYPE
@defmacx INT_LEAST64_TYPE
@defmacx UINT_LEAST8_TYPE
@defmacx UINT_LEAST16_TYPE
@defmacx UINT_LEAST32_TYPE
@defmacx UINT_LEAST64_TYPE
@defmacx INT_FAST8_TYPE
@defmacx INT_FAST16_TYPE
@defmacx INT_FAST32_TYPE
@defmacx INT_FAST64_TYPE
@defmacx UINT_FAST8_TYPE
@defmacx UINT_FAST16_TYPE
@defmacx UINT_FAST32_TYPE
@defmacx UINT_FAST64_TYPE
@defmacx INTPTR_TYPE
@defmacx UINTPTR_TYPE
C expressions for the standard types @code{sig_atomic_t},
@code{int8_t}, @code{int16_t}, @code{int32_t}, @code{int64_t},
@code{uint8_t}, @code{uint16_t}, @code{uint32_t}, @code{uint64_t},
@code{int_least8_t}, @code{int_least16_t}, @code{int_least32_t},
@code{int_least64_t}, @code{uint_least8_t}, @code{uint_least16_t},
@code{uint_least32_t}, @code{uint_least64_t}, @code{int_fast8_t},
@code{int_fast16_t}, @code{int_fast32_t}, @code{int_fast64_t},
@code{uint_fast8_t}, @code{uint_fast16_t}, @code{uint_fast32_t},
@code{uint_fast64_t}, @code{intptr_t}, and @code{uintptr_t}.  See
@code{SIZE_TYPE} above for more information.

If any of these macros evaluates to a null pointer, the corresponding
type is not supported; if GCC is configured to provide
@code{<stdint.h>} in such a case, the header provided may not conform
to C99, depending on the type in question.  The defaults for all of
these macros are null pointers.
@end defmac

@defmac TARGET_PTRMEMFUNC_VBIT_LOCATION
The C++ compiler represents a pointer-to-member-function with a struct
that looks like:

@smallexample
  struct @{
    union @{
      void (*fn)();
      ptrdiff_t vtable_index;
    @};
    ptrdiff_t delta;
  @};
@end smallexample

@noindent
The C++ compiler must use one bit to indicate whether the function that
will be called through a pointer-to-member-function is virtual.
Normally, we assume that the low-order bit of a function pointer must
always be zero.  Then, by ensuring that the vtable_index is odd, we can
distinguish which variant of the union is in use.  But, on some
platforms function pointers can be odd, and so this doesn't work.  In
that case, we use the low-order bit of the @code{delta} field, and shift
the remainder of the @code{delta} field to the left.

GCC will automatically make the right selection about where to store
this bit using the @code{FUNCTION_BOUNDARY} setting for your platform.
However, some platforms such as ARM/Thumb have @code{FUNCTION_BOUNDARY}
set such that functions always start at even addresses, but the lowest
bit of pointers to functions indicate whether the function at that
address is in ARM or Thumb mode.  If this is the case of your
architecture, you should define this macro to
@code{ptrmemfunc_vbit_in_delta}.

In general, you should not have to define this macro.  On architectures
in which function addresses are always even, according to
@code{FUNCTION_BOUNDARY}, GCC will automatically define this macro to
@code{ptrmemfunc_vbit_in_pfn}.
@end defmac

@defmac TARGET_VTABLE_USES_DESCRIPTORS
Normally, the C++ compiler uses function pointers in vtables.  This
macro allows the target to change to use ``function descriptors''
instead.  Function descriptors are found on targets for whom a
function pointer is actually a small data structure.  Normally the
data structure consists of the actual code address plus a data
pointer to which the function's data is relative.

If vtables are used, the value of this macro should be the number
of words that the function descriptor occupies.
@end defmac

@defmac TARGET_VTABLE_ENTRY_ALIGN
By default, the vtable entries are void pointers, the so the alignment
is the same as pointer alignment.  The value of this macro specifies
the alignment of the vtable entry in bits.  It should be defined only
when special alignment is necessary. */
@end defmac

@defmac TARGET_VTABLE_DATA_ENTRY_DISTANCE
There are a few non-descriptor entries in the vtable at offsets below
zero.  If these entries must be padded (say, to preserve the alignment
specified by @code{TARGET_VTABLE_ENTRY_ALIGN}), set this to the number
of words in each data entry.
@end defmac

@en @node Registers
@en @section Register Usage
@node Registers
@section 寄存器的用法
@cindex register usage

@en This section explains how to describe what registers the target machine
@en has, and how (in general) they can be used.
这一节说明了如何描述目标机器具有什么寄存器，
以及它们（通常）可以被如何使用。

@en The description of which registers a specific instruction can use is
@en done with register classes; see @ref{Register Classes}.  For information
@en on using registers to access a stack frame, see @ref{Frame Registers}.
@en For passing values in registers, see @ref{Register Arguments}.
@en For returning values in registers, see @ref{Scalar Return}.
寄存器类别用来描述一个特定指令可以使用哪些寄存器；
参见@ref{Register Classes}。
关于使用寄存器来访问栈帧的信息，参见@ref{Frame Registers}。
关于使用寄存器来传值，参见@ref{Register Arguments}。
关于使用寄存器来返回值，参见@ref{Scalar Return}。

@en @menu
@en * Register Basics::             Number and kinds of registers.
@en * Allocation Order::            Order in which registers are allocated.
@en * Values in Registers::         What kinds of values each reg can hold.
@en * Leaf Functions::              Renumbering registers for leaf functions.
@en * Stack Registers::             Handling a register stack such as 80387.
@en @end menu
@menu
* Register Basics::	寄存器编号和种类
* Allocation Order::	寄存器按照什么顺序分配
* Values in Registers::	每个寄存器可以存放什么类型的值
* Leaf Functions::	为叶子函数重编号寄存器
* Stack Registers::	处理像80387这样的寄存器栈
@end menu

@en @node Register Basics
@en @subsection Basic Characteristics of Registers
@node Register Basics
@subsection 寄存器的基本特征

@c prevent bad page break with this line
@en Registers have various characteristics.
寄存器具有不同的特征。

@defmac FIRST_PSEUDO_REGISTER
@en Number of hardware registers known to the compiler.  They receive
@en numbers 0 through @code{FIRST_PSEUDO_REGISTER-1}; thus, the first
@en pseudo register's number really is assigned the number
@en @code{FIRST_PSEUDO_REGISTER}.
编译器知道的硬件寄存器个数。它们包括编号0到@code{FIRST_PSEUDO_REGISTER-1}；
因此，第一个伪寄存器的编号实际被赋值为@code{FIRST_PSEUDO_REGISTER}。
@end defmac

@defmac FIXED_REGISTERS
@cindex fixed register
@en An initializer that says which registers are used for fixed purposes
@en all throughout the compiled code and are therefore not available for
@en general allocation.  These would include the stack pointer, the frame
@en pointer (except on machines where that can be used as a general
@en register when no frame pointer is needed), the program counter on
@en machines where that is considered one of the addressable registers,
@en and any other numbered register with a standard use.
一个初始化，说明哪些寄存器在整个编译代码中都用于固定用途，
因此不能用于通用分配。这些将包括栈指针，帧指针（在当不需要帧指针时，
可以用于通用寄存器的机器上除外），
在一些机器上被认为是可寻址的寄存器的程序计数器，
以及其它具有标准用法的编号寄存器。

@en This information is expressed as a sequence of numbers, separated by
@en commas and surrounded by braces.  The @var{n}th number is 1 if
@en register @var{n} is fixed, 0 otherwise.
这些信息作为一个序列编号来表示，由逗号分隔并由大括号包括。
第@var{n}个编号为1，如果寄存器@var{n}为固定的，否则为0。

@en The table initialized from this macro, and the table initialized by
@en the following one, may be overridden at run time either automatically,
@en by the actions of the macro @code{CONDITIONAL_REGISTER_USAGE}, or by
@en the user with the command options @option{-ffixed-@var{reg}},
@en @option{-fcall-used-@var{reg}} and @option{-fcall-saved-@var{reg}}.
从该宏初始化的表，以及由下面的初始化的表，都可以在运行时被覆盖，
或者通过执行宏@code{CONDITIONAL_REGISTER_USAGE}自动完成，
或者通过用户使用命令选项@option{-ffixed-@var{reg}}, 
@option{-fcall-used-@var{reg}}和@option{-fcall-saved-@var{reg}}。
@end defmac

@defmac CALL_USED_REGISTERS
@cindex call-used register
@cindex call-clobbered register
@cindex call-saved register
@en Like @code{FIXED_REGISTERS} but has 1 for each register that is
@en clobbered (in general) by function calls as well as for fixed
@en registers.  This macro therefore identifies the registers that are not
@en available for general allocation of values that must live across
@en function calls.
类似@code{FIXED_REGISTERS}，但是对于被函数调用破坏的每个寄存器，
以及固定寄存器，值为1。因此，
该宏标识了哪些寄存器不适合用于必须活跃于整个函数调用的值的通用分配。

@en If a register has 0 in @code{CALL_USED_REGISTERS}, the compiler
@en automatically saves it on function entry and restores it on function
@en exit, if the register is used within the function.
如果寄存器在@code{CALL_USED_REGISTERS}中具有值0，
如果寄存器在函数中被使用，则编译器会自动的在函数入口保存它，
并在函数出口恢复它。
@end defmac

@defmac CALL_REALLY_USED_REGISTERS
@cindex call-used register
@cindex call-clobbered register
@cindex call-saved register
@en Like @code{CALL_USED_REGISTERS} except this macro doesn't require
@en that the entire set of @code{FIXED_REGISTERS} be included.
@en (@code{CALL_USED_REGISTERS} must be a superset of @code{FIXED_REGISTERS}).
@en This macro is optional.  If not specified, it defaults to the value
@en of @code{CALL_USED_REGISTERS}.
类似@code{CALL_USED_REGISTERS}，除了该宏不需要包含整个@code{FIXED_REGISTERS}集。
（@code{CALL_USED_REGISTERS}必须为@code{FIXED_REGISTERS}的超集）。
该宏为可选的。如果没有被指定，其缺省为@code{CALL_USED_REGISTERS}的值。
@end defmac

@defmac HARD_REGNO_CALL_PART_CLOBBERED (@var{regno}, @var{mode})
@cindex call-used register
@cindex call-clobbered register
@cindex call-saved register
@en A C expression that is nonzero if it is not permissible to store a
@en value of mode @var{mode} in hard register number @var{regno} across a
@en call without some part of it being clobbered.  For most machines this
@en macro need not be defined.  It is only required for machines that do not
@en preserve the entire contents of a register across a call.
一个C表达式，值为非0，
如果不允许将机器模式为@var{mode}的值存储在编号为@var{regno}的硬件寄存器中，
并且整个调用中没有破坏其某个部分。对于大多数机器，该宏不需要被定义。
其只用于一些在调用中不保护寄存器的整个内容的机器上。
@end defmac

@findex fixed_regs
@findex call_used_regs
@findex global_regs
@findex reg_names
@findex reg_class_contents
@deftypefn {Target Hook} void TARGET_CONDITIONAL_REGISTER_USAGE (void)
@en This hook may conditionally modify five variables
@en @code{fixed_regs}, @code{call_used_regs}, @code{global_regs},
@en @code{reg_names}, and @code{reg_class_contents}, to take into account
@en any dependence of these register sets on target flags.  The first three
@en of these are of type @code{char []} (interpreted as Boolean vectors).
@en @code{global_regs} is a @code{const char *[]}, and
@en @code{reg_class_contents} is a @code{HARD_REG_SET}.  Before the macro is
@en called, @code{fixed_regs}, @code{call_used_regs},
@en @code{reg_class_contents}, and @code{reg_names} have been initialized
@en from @code{FIXED_REGISTERS}, @code{CALL_USED_REGISTERS},
@en @code{REG_CLASS_CONTENTS}, and @code{REGISTER_NAMES}, respectively.
@en @code{global_regs} has been cleared, and any @option{-ffixed-@var{reg}},
@en @option{-fcall-used-@var{reg}} and @option{-fcall-saved-@var{reg}}
@en command options have been applied.
该钩子可以条件修改5个变量@code{fixed_regs}, 
@code{call_used_rehs}, @code{global_regs}, @code{reg_names} 和
@code{reg_class_contents}，来考虑这些寄存器集对target标号的任何依赖。
前3个为@code{char []}类型（作为布尔向量来解析）。
@code{global_regs}为一个@code{const char *[]}，
@code{reg_class_contents}为一个@code{HARD_REG_SET}。
在宏被调用之前，@code{fixed_regs}, @code{call_used_regs}, 
@code{reg_class_contents}和@code{reg_names}已经分别通过@code{FIXED_REGISTERS},
@code{CALL_USED_REGISTERS}, @code{REG_CLASS_CONTENTS}和@code{REGISTER_NAMES}被初始化。
@code{global_regs}已经被清除，并且任何@option{-ffixed-@var{reg}}, 
@option{-fcall-used-@var{reg}}和@option{-fcall-saved-@var{reg}}选项已经被应用。

@en You need not define this macro if it has no work to do.
如果不需要做什么工作，则不必定义该宏。

@cindex disabling certain registers
@cindex controlling register usage
@en If the usage of an entire class of registers depends on the target
@en flags, you may indicate this to GCC by using this macro to modify
@en @code{fixed_regs} and @code{call_used_regs} to 1 for each of the
@en registers in the classes which should not be used by GCC@.  Also define
@en the macro @code{REG_CLASS_FROM_LETTER} / @code{REG_CLASS_FROM_CONSTRAINT}
@en to return @code{NO_REGS} if it
@en is called with a letter for a class that shouldn't be used.
如果整个寄存器的类别的使用，取决于target标记，
则你可以通过使用该宏来指示GCC修改@code{fixed_regs}和@code{call_used_regs}为1，
对于类别中的每个不应由GCC使用的寄存器。还有就是，
定义宏@code{REG_CLASS_FROM_LETTER} / @code{REG_CLASS_FROM_CONSTRAINT}来返回@code{NO_REGS}，
如果其被调用，并带有一个不应该被使用的类别字母。

@en (However, if this class is not included in @code{GENERAL_REGS} and all
@en of the insn patterns whose constraints permit this class are
@en controlled by target switches, then GCC will automatically avoid using
@en these registers when the target switches are opposed to them.)
（然而，如果该类没有包含在@code{GENERAL_REGS}中，
并且所有的insn指令模式的约束允许该类通过target开关来控制，
则GCC将自动避免使用这些寄存器，当target开关与它们相反时。）
@end deftypefn

@defmac INCOMING_REGNO (@var{out})
@en Define this macro if the target machine has register windows.  This C
@en expression returns the register number as seen by the called function
@en corresponding to the register number @var{out} as seen by the calling
@en function.  Return @var{out} if register number @var{out} is not an
@en outbound register.
定义该宏，如果target机器具有寄存器窗口。
该C表达式根据调用函数能看到的寄存器编号@var{out}，
返回被调用函数所能看到的寄存器编号。
返回@var{out}，如果寄存器编号@var{out}不是发送寄存器（outbound register）。
@end defmac

@defmac OUTGOING_REGNO (@var{in})
@en Define this macro if the target machine has register windows.  This C
@en expression returns the register number as seen by the calling function
@en corresponding to the register number @var{in} as seen by the called
@en function.  Return @var{in} if register number @var{in} is not an inbound
@en register.
定义该宏，如果target机器具有寄存器窗口。
该C表达式根据被调用函数能看到的寄存器编号@var{in}，
返回调用函数所能看到的寄存器编号。
返回@var{in}，如果寄存器编号@var{in}不是运入寄存器（inbound register）。
@end defmac

@defmac LOCAL_REGNO (@var{regno})
@en Define this macro if the target machine has register windows.  This C
@en expression returns true if the register is call-saved but is in the
@en register window.  Unlike most call-saved registers, such registers
@en need not be explicitly restored on function exit or during non-local
@en gotos.
定义该宏，如果target机器具有寄存器窗口。该C表达式返回真，
如果寄存器为调用保存的，但是在寄存器窗口中。不像大多调用保存的寄存器，
这样的寄存器不需要在函数出口或者非局部调转中被显示的恢复。
@end defmac

@defmac PC_REGNUM
@en If the program counter has a register number, define this as that
@en register number.  Otherwise, do not define it.
如果程序计数器具有一个寄存器编号，则定义其为那个寄存器编号。否则不要定义它。
@end defmac

@en @node Allocation Order
@en @subsection Order of Allocation of Registers
@node Allocation Order
@subsection 寄存器的分配顺序
@cindex order of register allocation
@cindex register allocation order

@c prevent bad page break with this line
@en Registers are allocated in order.
寄存器按照顺序进行分配。

@defmac REG_ALLOC_ORDER
@en If defined, an initializer for a vector of integers, containing the
@en numbers of hard registers in the order in which GCC should prefer
@en to use them (from most preferred to least).
如果定义，则为一个整数向量的初始化值，包含了硬件寄存器号，
GCC将按该照顺序来使用它们（前面的优先）。

@en If this macro is not defined, registers are used lowest numbered first
@en (all else being equal).
如果没有定义该宏，则寄存器按照低编号优先的方式使用。

@en One use of this macro is on machines where the highest numbered
@en registers must always be saved and the save-multiple-registers
@en instruction supports only sequences of consecutive registers.  On such
@en machines, define @code{REG_ALLOC_ORDER} to be an initializer that lists
@en the highest numbered allocable register first.
该宏的一个用处是在一些机器上，
高编号的寄存器必须总是被保存并且save-multiple-registers指令
只支持连续序列的寄存器。在这些机器上，
可以定义@code{REG_ALLOC_ORDER}来初始化列表，
使得高编号寄存器优先分配。
@end defmac

@defmac ADJUST_REG_ALLOC_ORDER
A C statement (sans semicolon) to choose the order in which to allocate
hard registers for pseudo-registers local to a basic block.

Store the desired register order in the array @code{reg_alloc_order}.
Element 0 should be the register to allocate first; element 1, the next
register; and so on.

The macro body should not assume anything about the contents of
@code{reg_alloc_order} before execution of the macro.

On most machines, it is not necessary to define this macro.
@end defmac

@defmac HONOR_REG_ALLOC_ORDER
Normally, IRA tries to estimate the costs for saving a register in the
prologue and restoring it in the epilogue.  This discourages it from
using call-saved registers.  If a machine wants to ensure that IRA
allocates registers in the order given by REG_ALLOC_ORDER even if some
call-saved registers appear earlier than call-used ones, this macro
should be defined.
@end defmac

@defmac IRA_HARD_REGNO_ADD_COST_MULTIPLIER (@var{regno})
In some case register allocation order is not enough for the
Integrated Register Allocator (@acronym{IRA}) to generate a good code.
If this macro is defined, it should return a floating point value
based on @var{regno}.  The cost of using @var{regno} for a pseudo will
be increased by approximately the pseudo's usage frequency times the
value returned by this macro.  Not defining this macro is equivalent
to having it always return @code{0.0}.

@en On most machines, it is not necessary to define this macro.
在大多数机器上，不需要定义该宏。
@end defmac

@en @node Values in Registers
@en @subsection How Values Fit in Registers
@node Values in Registers
@subsection 如何使值适合寄存器

@en This section discusses the macros that describe which kinds of values
@en (specifically, which machine modes) each register can hold, and how many
@en consecutive registers are needed for a given mode.
这节讨论的宏，描述了每个寄存器可以存放哪类的值（明确的说，
是哪些机器模式的），以及对于给定的机器模式需要多少个连续的寄存器。

@defmac HARD_REGNO_NREGS (@var{regno}, @var{mode})
@en A C expression for the number of consecutive hard registers, starting
@en at register number @var{regno}, required to hold a value of mode
@en @var{mode}.  This macro must never return zero, even if a register
@en cannot hold the requested mode - indicate that with HARD_REGNO_MODE_OK
@en and/or CANNOT_CHANGE_MODE_CLASS instead.
一个C表达式，为存放模式@var{mode}的值所需要的连续的硬件寄存器，
起始于寄存器编号@var{regno}。该宏不要返回0，
即使寄存器不能存放指定的mode —— 替代的，
使用HARD_REGNO_MODE_OK 和/或 CANNOT_CHANGE_MODE_CLASS。

@en On a machine where all registers are exactly one word, a suitable
@en definition of this macro is
在所有寄存器都是一个字大小的机器上，该宏的一个合适的定义为

@smallexample
#define HARD_REGNO_NREGS(REGNO, MODE)            \
   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
    / UNITS_PER_WORD)
@end smallexample
@end defmac

@defmac HARD_REGNO_NREGS_HAS_PADDING (@var{regno}, @var{mode})
@en A C expression that is nonzero if a value of mode @var{mode}, stored
@en in memory, ends with padding that causes it to take up more space than
@en in registers starting at register number @var{regno} (as determined by
@en multiplying GCC's notion of the size of the register when containing
@en this mode by the number of registers returned by
@en @code{HARD_REGNO_NREGS}).  By default this is zero.
一个C表达式，为非0，如果模式为@var{mode}的值，存储在内存中，
并由padding结尾，这使得其占有更多的空间，
比在起始于寄存器编号@var{regno}的寄存器中。缺省的为0。

@en For example, if a floating-point value is stored in three 32-bit
@en registers but takes up 128 bits in memory, then this would be
@en nonzero.
例如，如果浮点值存储在三个32位寄存器中，但是在内存中占有128位，则该宏应该为非0。

@en This macros only needs to be defined if there are cases where
@en @code{subreg_get_info}
@en would otherwise wrongly determine that a @code{subreg} can be
@en represented by an offset to the register number, when in fact such a
@en @code{subreg} would contain some of the padding not stored in
@en registers and so not be representable.
该宏只有当@code{subreg_get_info}会错误的确定一个@code{subreg}可以通过寄存器编号的偏移量来表示，
而实际上这样的@code{subreg}将会保存一些不应该被表示的padding时，
才需要被定义。
@end defmac

@defmac HARD_REGNO_NREGS_WITH_PADDING (@var{regno}, @var{mode})
@en For values of @var{regno} and @var{mode} for which
@en @code{HARD_REGNO_NREGS_HAS_PADDING} returns nonzero, a C expression
@en returning the greater number of registers required to hold the value
@en including any padding.  In the example above, the value would be four.
对于@code{HARD_REGNO_NREGS_HAS_PADDING}会返回非0的@var{regno}和@var{mode}的值，
其为一个C表达式，返回保存包括任何padding的值所需要的寄存器的最大数。
在上面的例子中，值将为4。
@end defmac

@defmac REGMODE_NATURAL_SIZE (@var{mode})
@en Define this macro if the natural size of registers that hold values
@en of mode @var{mode} is not the word size.  It is a C expression that
@en should give the natural size in bytes for the specified mode.  It is
@en used by the register allocator to try to optimize its results.  This
@en happens for example on SPARC 64-bit where the natural size of
@en floating-point registers is still 32-bit.
定义该宏，如果存放模式@var{mode}的值的寄存器的自然大小，不是word大小。
其为一个C表达式，对于指定的mode给出以字节为单位的自然的大小。
其被寄存器分配用于尝试优化它的结果。
例如这出现在SPARC 64位机器上，其浮点寄存器的自然大小仍然是32位。
@end defmac

@defmac HARD_REGNO_MODE_OK (@var{regno}, @var{mode})
@en A C expression that is nonzero if it is permissible to store a value
@en of mode @var{mode} in hard register number @var{regno} (or in several
@en registers starting with that one).  For a machine where all registers
@en are equivalent, a suitable definition is
一个C表达式，其为非0，
如果允许将一个@var{mode}模式的值存储在硬件寄存器编号@var{regno}
（或者起始于它的多个寄存器）中。对于所有寄存器都是等价的机器上，
一个合适的定义为

@smallexample
#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
@end smallexample

@en You need not include code to check for the numbers of fixed registers,
@en because the allocation mechanism considers them to be always occupied.
你不需要包含检查固定寄存器编号的代码，
因为分配机制总是认为它们已经被占用了。

@cindex register pairs
@en On some machines, double-precision values must be kept in even/odd
@en register pairs.  You can implement that by defining this macro to reject
@en odd register numbers for such modes.
在一些机器上，双精度值必须放在偶/奇寄存器对。
你可以通过定义该宏来拒绝这样模式的奇数寄存器编号。

@en The minimum requirement for a mode to be OK in a register is that the
@en @samp{mov@var{mode}} instruction pattern support moves between the
@en register and other hard register in the same class and that moving a
@en value into the register and back out not alter it.
对于一个模式可以放在寄存器中的最小需求为，
@samp{mov@var{mode}}指令模式支持在寄存器和同一类别的其它硬件寄存器之间的移动，
并且将一个值移动到寄存器中并移动回来，而不会改变。

@en Since the same instruction used to move @code{word_mode} will work for
@en all narrower integer modes, it is not necessary on any machine for
@en @code{HARD_REGNO_MODE_OK} to distinguish between these modes, provided
@en you define patterns @samp{movhi}, etc., to take advantage of this.  This
@en is useful because of the interaction between @code{HARD_REGNO_MODE_OK}
@en and @code{MODES_TIEABLE_P}; it is very desirable for all integer modes
@en to be tieable.
由于用于move @code{word_mode}的同一指令，也可以用于所有更窄的整数模式，
所以@code{HARD_REGNO_MODE_OK}不必要在任何机器上对于这些模式都不同，
假定你定义了指令模式@samp{movhi}等。

@en Many machines have special registers for floating point arithmetic.
@en Often people assume that floating point machine modes are allowed only
@en in floating point registers.  This is not true.  Any registers that
@en can hold integers can safely @emph{hold} a floating point machine
@en mode, whether or not floating arithmetic can be done on it in those
@en registers.  Integer move instructions can be used to move the values.
许多机器对于浮点算术具有特定的寄存器。
通常人们假设浮点机器模式只在浮点寄存器中被允许。这并不真实。
任何可以存放整数的寄存器都可以安全的存放一个浮点机器模式，
而不管是否可以在这些寄存器上进行浮点算术。
整数move指令可以用于移动这些值。

@en On some machines, though, the converse is true: fixed-point machine
@en modes may not go in floating registers.  This is true if the floating
@en registers normalize any value stored in them, because storing a
@en non-floating value there would garble it.  In this case,
@en @code{HARD_REGNO_MODE_OK} should reject fixed-point machine modes in
@en floating registers.  But if the floating registers do not automatically
@en normalize, if you can store any bit pattern in one and retrieve it
@en unchanged without a trap, then any machine mode may go in a floating
@en register, so you can define this macro to say so.
然而在一些机器上，定点机器模式不可以放在浮点寄存器中。
比如如果浮点寄存器对任何存储的值进行标准化，
因为存储一个非浮点值将会使值变得混淆。这种情况下，
@code{HARD_REGNO_MODE_OK}应该拒绝定点机器模式放在浮点寄存器中。
但是，如果浮点寄存器不自动标准化，
如果你可以存储任何位的指令模式并无需改动的获得它，
则任何机器模式都可以放在浮点寄存器中，这样你可以定义该宏来表明可以这么做。

@en The primary significance of special floating registers is rather that
@en they are the registers acceptable in floating point arithmetic
@en instructions.  However, this is of no concern to
@en @code{HARD_REGNO_MODE_OK}.  You handle it by writing the proper
@en constraints for those instructions.
当然，特定的浮点寄存器的主要意义是它们在浮点算术指令中可以使用。
但是，这根@code{HARD_REGNO_MODE_OK}没有关系。
你可以通过对那些执行写合适的约束来处理。

@en On some machines, the floating registers are especially slow to access,
@en so that it is better to store a value in a stack frame than in such a
@en register if floating point arithmetic is not being done.  As long as the
@en floating registers are not in class @code{GENERAL_REGS}, they will not
@en be used unless some pattern's constraint asks for one.
在一些机器上，浮点寄存器访问起来特别慢，所以如果浮点算术没有完成前，
最好将值存在栈帧中，而不是在这样的寄存器中。
只要浮点寄存器不在@code{GENERAL_REGS}类别中，它们将不会被使用，
除非某个指令模式的约束要求这样。
@end defmac

@defmac HARD_REGNO_RENAME_OK (@var{from}, @var{to})
@en A C expression that is nonzero if it is OK to rename a hard register
@en @var{from} to another hard register @var{to}.
一个C表达式，为非0，
如果可以将一个硬件寄存器@var{from}重命名为另一个寄存器@var{to}。

@en One common use of this macro is to prevent renaming of a register to
@en another register that is not saved by a prologue in an interrupt
@en handler.
该宏的一个通用的用法是防止将一个寄存器重命名为另一个寄存器，
而其在中断处理函数的序言中没有被保存。

@en The default is always nonzero.
缺省总是为非0。
@end defmac

@defmac MODES_TIEABLE_P (@var{mode1}, @var{mode2})
@en A C expression that is nonzero if a value of mode
@en @var{mode1} is accessible in mode @var{mode2} without copying.
一个C表达式，其为非0，如果一个模式@var{mode1}的值，
不需要复制便可以按照模式@var{mode2}来访问。

@en If @code{HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and
@en @code{HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same for
@en any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}
@en should be nonzero.  If they differ for any @var{r}, you should define
@en this macro to return zero unless some other mechanism ensures the
@en accessibility of the value in a narrower mode.
如果@code{HARD_REGNO_MODE_OK (@var{r}, @var{mode1})}和
@code{HARD_REGNO_MODE_OK (@var{r}, @var{mode2})}对于任何@var{r}总是相同，
则@code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}应该为非0。
如果它们对于任何@var{r}都不同，则你应该定义该宏来返回0，
除非某个其它机制能够确保值可以按照更窄的模式来访问。

@en You should define this macro to return nonzero in as many cases as
@en possible since doing so will allow GCC to perform better register
@en allocation.
你应该定义该宏来尽可能情况的返回非0，
因为这样会使得GCC执行更好的寄存器分配。
@end defmac

@deftypefn {Target Hook} bool TARGET_HARD_REGNO_SCRATCH_OK (unsigned int @var{regno})
This target hook should return @code{true} if it is OK to use a hard register
@var{regno} as scratch reg in peephole2.
This target hook should return @code{true} if it is OK to use a hard register
@var{regno} as scratch reg in peephole2.

One common use of this macro is to prevent using of a register that
is not saved by a prologue in an interrupt handler.

The default version of this hook always returns @code{true}.
@end deftypefn

@defmac AVOID_CCMODE_COPIES
@en Define this macro if the compiler should avoid copies to/from @code{CCmode}
@en registers.  You should only define this macro if support for copying to/from
@en @code{CCmode} is incomplete.
定义该宏，如果编译器应该避免复制从/到@code{CCmode}寄存器。
你应该只当对复制从/到@code{CCmode}寄存器的支持不完善的时候定义该宏。
@end defmac

@en @node Leaf Functions
@en @subsection Handling Leaf Functions
@node Leaf Functions
@subsection 处理叶子函数

@cindex leaf functions
@cindex functions, leaf
@en On some machines, a leaf function (i.e., one which makes no calls) can run
@en more efficiently if it does not make its own register window.  Often this
@en means it is required to receive its arguments in the registers where they
@en are passed by the caller, instead of the registers where they would
@en normally arrive.
在一些机器上，一个叶子函数（即，不做任何调用的函数），如果其不创建自己的寄存器窗口，则可以运行的更加有效。通常这意味着，其需要通过调用者传递参数的寄存器来接收它的参数，而不是它们通常到达的寄存器。

@en The special treatment for leaf functions generally applies only when
@en other conditions are met; for example, often they may use only those
@en registers for its own variables and temporaries.  We use the term ``leaf
@en function'' to mean a function that is suitable for this special
@en handling, so that functions with no calls are not necessarily ``leaf
@en functions''.
通常只有当叶子函数还满足其它条件时，才会对其进行特殊的对待；例如，通常它们可能只使用，用于它自己的变量和临时对象的那些寄存器。我们使用术语“叶子函数”来指一个适合这样特殊处理的函数，所以没有函数调用的函数并不一定是“叶子函数”。

@en GCC assigns register numbers before it knows whether the function is
@en suitable for leaf function treatment.  So it needs to renumber the
@en registers in order to output a leaf function.  The following macros
@en accomplish this.
GCC是在它知道函数是否适合作为叶子函数来对待之前，分配寄存器编号的。所以它需要重编号寄存器，以便输出一个叶子函数。下面的宏用来完成此事。

@defmac LEAF_REGISTERS
@en Name of a char vector, indexed by hard register number, which
@en contains 1 for a register that is allowable in a candidate for leaf
@en function treatment.
一个char向量的名字，按照硬件寄存器编号进行索引，对于允许作为叶子函数处理的候选寄存器，其值为1。

@en If leaf function treatment involves renumbering the registers, then the
@en registers marked here should be the ones before renumbering---those that
@en GCC would ordinarily allocate.  The registers which will actually be
@en used in the assembler code, after renumbering, should not be marked with 1
@en in this vector.
如果叶子函数处理涉及到重编号寄存器，则这里标记的寄存器应该是重编号之前的——那些GCC通常分配的。重编号后，在汇编代码中实际被使用的寄存器，不要在该向量中被标记为1。

@en Define this macro only if the target machine offers a way to optimize
@en the treatment of leaf functions.
只有当目标机器提供了优化叶子函数处理的方法时，才定义该宏。
@end defmac

@defmac LEAF_REG_REMAP (@var{regno})
@en A C expression whose value is the register number to which @var{regno}
@en should be renumbered, when a function is treated as a leaf function.
一个C表达式，当函数作为叶子函数来处理时，其值为应该对@var{regno}进行重编的寄存器编号。

@en If @var{regno} is a register number which should not appear in a leaf
@en function before renumbering, then the expression should yield @minus{}1, which
@en will cause the compiler to abort.
如果@var{regno}为一个在重编号前不应该出现在叶子函数中的寄存器编号，则表达式的值应该为-1，这将造成编译器中断退出。

@en Define this macro only if the target machine offers a way to optimize the
@en treatment of leaf functions, and registers need to be renumbered to do
@en this.
只有当目标机器提供了优化叶子函数处理的方法，并且寄存器需要被重编号的时候，才定义该宏。
@end defmac

@findex current_function_is_leaf
@findex current_function_uses_only_leaf_regs
@en @code{TARGET_ASM_FUNCTION_PROLOGUE} and
@en @code{TARGET_ASM_FUNCTION_EPILOGUE} must usually treat leaf functions
@en specially.  They can test the C variable @code{current_function_is_leaf}
@en which is nonzero for leaf functions.  @code{current_function_is_leaf} is
@en set prior to local register allocation and is valid for the remaining
@en compiler passes.  They can also test the C variable
@en @code{current_function_uses_only_leaf_regs} which is nonzero for leaf
@en functions which only use leaf registers.
@en @code{current_function_uses_only_leaf_regs} is valid after all passes
@en that modify the instructions have been run and is only useful if
@en @code{LEAF_REGISTERS} is defined.
@code{TARGET_ASM_FUNCTION_PROLOGUE}和@code{TARGET_ASM_FUNCTION_EPILOGUE}通常必须专门处理叶子函数。它们可以测试C变量@code{current_function_is_leaf}，其对于叶子函数为非0。@code{current_function_is_leaf}在局部寄存器分配之前被设置，并且可以用于剩余的编译器过程。它们还可以测试C变量@code{current_function_uses_only_leaf_regs}，其对于只用叶子寄存器的叶子函数为非0。@code{current_function_uses_only_leaf_regs}在所有修改指令的过程被运行完之后可用，并且只有当@code{LEAF_REGISTERS}被定义时才有用。

@c changed this to fix overfull.  ALSO:  why the "it" at the beginning
@c of the next paragraph?!  --mew 2feb93

@en @node Stack Registers
@en @subsection Registers That Form a Stack
@node Stack Registers
@subsection 形成栈的寄存器

@en There are special features to handle computers where some of the
@en ``registers'' form a stack.  Stack registers are normally written by
@en pushing onto the stack, and are numbered relative to the top of the
@en stack.
有一些特性用来处理计算机中形成栈的寄存器。
栈寄存器通常写成被压入一个栈中，并相对于栈顶进行编号。

@en Currently, GCC can only handle one group of stack-like registers, and
@en they must be consecutively numbered.  Furthermore, the existing
@en support for stack-like registers is specific to the 80387 floating
@en point coprocessor.  If you have a new architecture that uses
@en stack-like registers, you will need to do substantial work on
@en @file{reg-stack.c} and write your machine description to cooperate
@en with it, as well as defining these macros.
目前，GCC只能处理一组类栈的寄存器，并且它们的编号必须是连续的。
而且，现存的对类栈寄存器的支持是特定于80387浮点协处理器。
如果你有一个新的体系结构使用了类栈寄存器，
你将需要在@file{reg-stack.c}上做大量的工作，并书写你自己的机器描述，
同时还要定义这些宏。

@defmac STACK_REGS
@en Define this if the machine has any stack-like registers.
如果机器具有任何类栈寄存器，则定义该宏。
@end defmac

@defmac STACK_REG_COVER_CLASS
This is a cover class containing the stack registers.  Define this if
the machine has any stack-like registers.
@end defmac

@defmac FIRST_STACK_REG
@en The number of the first stack-like register.  This one is the top
@en of the stack.
第一个类栈寄存器的编号。这是栈顶。
@end defmac

@defmac LAST_STACK_REG
@en The number of the last stack-like register.  This one is the bottom of
@en the stack.
最后一个类栈寄存器的编号，这是栈底。
@end defmac

@en @node Register Classes
@en @section Register Classes
@node Register Classes
@section 寄存器类别
@cindex register class definitions
@cindex class definitions, register

@en On many machines, the numbered registers are not all equivalent.
@en For example, certain registers may not be allowed for indexed addressing;
@en certain registers may not be allowed in some instructions.  These machine
@en restrictions are described to the compiler using @dfn{register classes}.
在许多机器上，编号寄存器并不都是等价的。例如，一些寄存器不可以用作索引寻址；
一些寄存器不可以用于某些指令。
这些机器限制使用寄存器类别(@dfn{register classes})来描述给编译器。

@en You define a number of register classes, giving each one a name and saying
@en which of the registers belong to it.  Then you can specify register classes
@en that are allowed as operands to particular instruction patterns.
你定义一些寄存器类别，给出每个类别的名字并指名哪些寄存器属于它。然后，
你可以指定哪些寄存器类别对于特定的指令模式可以用作操作数。

@findex ALL_REGS
@findex NO_REGS
@en In general, each register will belong to several classes.  In fact, one
@en class must be named @code{ALL_REGS} and contain all the registers.  Another
@en class must be named @code{NO_REGS} and contain no registers.  Often the
@en union of two classes will be another class; however, this is not required.
总的来说，每个寄存器将属于多个类别。实际上，
必须有一个名为@code{ALL_REGS}的类别，包含所有的寄存器。
另外必须有一个名为@code{NO_REGS}的类别，不包含寄存器。
通常两个类别的并集将成为另一个类别；但并不这么要求。

@findex GENERAL_REGS
@en One of the classes must be named @code{GENERAL_REGS}.  There is nothing
@en terribly special about the name, but the operand constraint letters
@en @samp{r} and @samp{g} specify this class.  If @code{GENERAL_REGS} is
@en the same as @code{ALL_REGS}, just define it as a macro which expands
@en to @code{ALL_REGS}.
其中一个类别必须名为@code{GENERAL_REGS}。该名字没有什么特殊的，
但是操作数约束字母@samp{r}和@samp{g}专门指定该类。
如果@code{GENERAL_REGS}与@code{ALL_REGS}相同，
则可以将其定义为扩展成@code{ALL_REGS}的宏。

@en Order the classes so that if class @var{x} is contained in class @var{y}
@en then @var{x} has a lower class number than @var{y}.
对类别进行排序，使得如果类@var{x}包含在类@var{y}中，
则@var{x}具有比@var{y}更低的类别编号。

@en The way classes other than @code{GENERAL_REGS} are specified in operand
@en constraints is through machine-dependent operand constraint letters.
@en You can define such letters to correspond to various classes, then use
@en them in operand constraints.
在操作数约束中指定@code{GENERAL_REGS}之外的类别的方法，
是通过机器相关的约束字母。你可以定义该字母来对应于不同的类别，
然后在操作数约束中使用它们。

@en You should define a class for the union of two classes whenever some
@en instruction allows both classes.  For example, if an instruction allows
@en either a floating point (coprocessor) register or a general register for a
@en certain operand, you should define a class @code{FLOAT_OR_GENERAL_REGS}
@en which includes both of them.  Otherwise you will get suboptimal code.
只要有指令同时允许两个类别，就应该定义一个它们的并集的类别。
例如，如果对于一个特定的操作数，
有一条指令允许一个浮点（协处理器）寄存器或者一个通用寄存器，
则应该定义一个类别@code{FLOAT_OR_GENERAL_REGS}，其包含它们两。
否则你不会得到最优的代码。

@en You must also specify certain redundant information about the register
@en classes: for each class, which classes contain it and which ones are
@en contained in it; for each pair of classes, the largest class contained
@en in their union.
你还必须指定关于寄存器类别的冗余信息：对于每个类别，
有哪些类别包含它以及哪些被它包含；
对于每个类别对，最大的类包含在它们的并集中。

@en When a value occupying several consecutive registers is expected in a
@en certain class, all the registers used must belong to that class.
@en Therefore, register classes cannot be used to enforce a requirement for
@en a register pair to start with an even-numbered register.  The way to
@en specify this requirement is with @code{HARD_REGNO_MODE_OK}.
当一个值占用多个连续的位于特定类别的寄存器时，
所有被使用的寄存器必须属于那个类别。因此，
寄存器类别不能用于要求寄存器对起始于偶数编号的寄存器。
用来指定该要求的方法是使用@code{HARD_REGNO_MODE_OK}。

@en Register classes used for input-operands of bitwise-and or shift
@en instructions have a special requirement: each such class must have, for
@en each fixed-point machine mode, a subclass whose registers can transfer that
@en mode to or from memory.  For example, on some machines, the operations for
@en single-byte values (@code{QImode}) are limited to certain registers.  When
@en this is so, each register class that is used in a bitwise-and or shift
@en instruction must have a subclass consisting of registers from which
@en single-byte values can be loaded or stored.  This is so that
@en @code{PREFERRED_RELOAD_CLASS} can always have a possible value to return.
用于按位与或者移位指令的操作数的寄存器类别具有特殊的要求：
对于每个定点机器模式，每个这样的类必须具有一个子类，
它的寄存器可以按照该机器模式与内存进行传送值。例如，在一些机器上，
对于单字节值的操作（@code{QImode}）被限制为特定的寄存器。这样的话，
每个用于按位与或者移位指令的寄存器类别必须具有一个子类，
组成它的寄存器可以用来加载或存储单字节值。
这使得@code{PREFERRED_RELOAD_CLASS}总是具有一个可以返回的值。

@deftp {Data type} {enum reg_class}
@en An enumerated type that must be defined with all the register class names
@en as enumerated values.  @code{NO_REGS} must be first.  @code{ALL_REGS}
@en must be the last register class, followed by one more enumerated value,
@en @code{LIM_REG_CLASSES}, which is not a register class but rather
@en tells how many classes there are.
一个枚举类型，必须使用所有的寄存器类别名作为枚举值来定义。
@code{NO_REGS}必须位于最前面。@code{ALL_REGS}必须为最后一个寄存器类别，
后面再跟随一个枚举值，@code{LIM_REG_CLASSES}，其不是一个寄存器类别，
但是用来告诉有多少个类别。

@en Each register class has a number, which is the value of casting
@en the class name to type @code{int}.  The number serves as an index
@en in many of the tables described below.
每个寄存器类别具有一个编号，其为将类别名映射到@code{int}类型的值。
编号在下面描述的许多表中用作索引。
@end deftp

@defmac N_REG_CLASSES
@en The number of distinct register classes, defined as follows:
不同寄存器类别的数目，定义为:

@smallexample
#define N_REG_CLASSES (int) LIM_REG_CLASSES
@end smallexample
@end defmac

@defmac REG_CLASS_NAMES
@en An initializer containing the names of the register classes as C string
@en constants.  These names are used in writing some of the debugging dumps.
一个初始化值，包含了作为C字符串常量的寄存器类别的名字。
这些名字用于书写一些调试转储。
@end defmac

@defmac REG_CLASS_CONTENTS
@en An initializer containing the contents of the register classes, as integers
@en which are bit masks.  The @var{n}th integer specifies the contents of class
@en @var{n}.  The way the integer @var{mask} is interpreted is that
@en register @var{r} is in the class if @code{@var{mask} & (1 << @var{r})} is 1.
一个初始化值，包含了寄存器类别的内容，作为位掩码的整数。
第@var{n}个整数指定了类别@var{n}的内容。整数掩码的解析方式为，
寄存器@var{r}在类别中，如果@code{@var{mask} & (1 << @var{r})}为1。

@en When the machine has more than 32 registers, an integer does not suffice.
@en Then the integers are replaced by sub-initializers, braced groupings containing
@en several integers.  Each sub-initializer must be suitable as an initializer
@en for the type @code{HARD_REG_SET} which is defined in @file{hard-reg-set.h}.
@en In this situation, the first integer in each sub-initializer corresponds to
@en registers 0 through 31, the second integer to registers 32 through 63, and
@en so on.
当机器具有多于32个寄存器的时候，一个整数还不能满足。这时整数被替换为子初始化值，
为括号包裹的多个整数。每个子初始化值必须适合类型@code{HARD_REG_SET}的初始化值，
其在@file{hard-reg-set.h}中定义。这种情况下，
每个子初始化值的第一个整数对应于寄存器0到31，第二个对应于32到63，等等。
@end defmac

@defmac REGNO_REG_CLASS (@var{regno})
@en A C expression whose value is a register class containing hard register
@en @var{regno}.  In general there is more than one such class; choose a class
@en which is @dfn{minimal}, meaning that no smaller class also contains the
@en register.
一个C表达式，其值为包含了硬件寄存器@var{regno}的寄存器类别。总的来说，
会有不止一个这样的类别；选择最小的那个，这意味着没有更小的类别包含该寄存器。
@end defmac

@defmac BASE_REG_CLASS
@en A macro whose definition is the name of the class to which a valid
@en base register must belong.  A base register is one used in an address
@en which is the register value plus a displacement.
一个宏，它的定义为有效的基址寄存器必须属于的类别名字。
基址寄存器用于由寄存器的值加上一个偏移量来表示的地址中。
@end defmac

@defmac MODE_BASE_REG_CLASS (@var{mode})
@en This is a variation of the @code{BASE_REG_CLASS} macro which allows
@en the selection of a base register in a mode dependent manner.  If
@en @var{mode} is VOIDmode then it should return the same value as
@en @code{BASE_REG_CLASS}.
这是宏@code{BASE_REG_CLASS}的变体，其允许在机器模式相关的方式下选择基址寄存器。
如果@var{mode}为VOIDmode，则其应该返回根@code{BASE_REG_CLASS}同样的值。
@end defmac

@defmac MODE_BASE_REG_REG_CLASS (@var{mode})
@en A C expression whose value is the register class to which a valid
@en base register must belong in order to be used in a base plus index
@en register address.  You should define this macro if base plus index
@en addresses have different requirements than other base register uses.
一个C表达式，其值为有效的基址寄存器必须属于的类别名字，
且用于一个基址寄存器加上索引寄存器的地址中。你应该定义该宏，
如果表示为基址寄存器加上索引寄存器的地址具有不同于其它基址寄存器的用法要求时。
@end defmac

@defmac MODE_CODE_BASE_REG_CLASS (@var{mode}, @var{outer_code}, @var{index_code})
@en A C expression whose value is the register class to which a valid
@en base register must belong.  @var{outer_code} and @var{index_code} define the
@en context in which the base register occurs.  @var{outer_code} is the code of
@en the immediately enclosing expression (@code{MEM} for the top level of an
@en address, @code{ADDRESS} for something that occurs in an
@en @code{address_operand}).  @var{index_code} is the code of the corresponding
@en index expression if @var{outer_code} is @code{PLUS}; @code{SCRATCH} otherwise.
一个C表达式，其值为有效的基址寄存器必须属于的类别名字。
@var{outer_code}和@var{index_code}定义了基址寄存器出现的上下文。
@var{outer_code}为。@var{index_code}为相应的索引表达式的代码，
如果@var{outer_code}为@code{PLUS}；否则为@code{SCRATCH}。
@end defmac

@defmac INDEX_REG_CLASS
@en A macro whose definition is the name of the class to which a valid
@en index register must belong.  An index register is one used in an
@en address where its value is either multiplied by a scale factor or
@en added to another register (as well as added to a displacement).
一个C表达式，其值为有效的索引寄存器必须属于的类别名字。
索引寄存器为一个用于地址中的寄存器，
它的值用于乘于一个标量因子或者加上另一个寄存器（也可以加上一个偏移量）。
@end defmac

@defmac REGNO_OK_FOR_BASE_P (@var{num})
@en A C expression which is nonzero if register number @var{num} is
@en suitable for use as a base register in operand addresses.
@en Like @code{TARGET_LEGITIMATE_ADDRESS_P}, this macro should also
@en define a strict and a non-strict variant.  Both variants behave
@en the same for hard register; for pseudos, the strict variant will
@en pass only those that have been allocated to a valid hard registers,
@en while the non-strict variant will pass all pseudos.
一个C表达式，其为非0，
如果寄存器编号@var{num}适合在操作数地址中作为基址寄存器使用。
其可以为一个合适的硬件寄存器，或者一个已经被分配了这样的硬件寄存器的伪寄存器。
@end defmac

@defmac REGNO_MODE_OK_FOR_BASE_P (@var{num}, @var{mode})
@en A C expression that is just like @code{REGNO_OK_FOR_BASE_P}, except that
@en that expression may examine the mode of the memory reference in
@en @var{mode}.  You should define this macro if the mode of the memory
@en reference affects whether a register may be used as a base register.  If
@en you define this macro, the compiler will use it instead of
@en @code{REGNO_OK_FOR_BASE_P}.  The mode may be @code{VOIDmode} for
@en addresses that appear outside a @code{MEM}, i.e., as an
@en @code{address_operand}.
一个C表达式，类似于@code{REGNO_OK_FOR_BASE_P}，
除了表达式可以检查内存引用的机器模式@var{mode}。你应该定义该宏，
如果内存引用的机器模式影响了一个寄存器是否可以作为基址寄存器使用。
如果你定义了该宏，则编译器将使用它来替代@code{REGNO_OK_FOR_BASE_P}。
对于出现在@code{MEM}之外的地址，即作为一个@code{address_operand}，
mode可以为@code{VOIDmode}。

This macro also has strict and non-strict variants.
@end defmac

@defmac REGNO_MODE_OK_FOR_REG_BASE_P (@var{num}, @var{mode})
@en A C expression which is nonzero if register number @var{num} is suitable for
@en use as a base register in base plus index operand addresses, accessing
@en memory in mode @var{mode}.  It may be either a suitable hard register or a
@en pseudo register that has been allocated such a hard register.  You should
@en define this macro if base plus index addresses have different requirements
@en than other base register uses.
一个C表达式，其为非0，
如果寄存器编号@var{num}适合在表示为基址加索引的地址中作为一个基址寄存器使用，
并通过模式@var{mode}来访问。其可以为一个合适的硬件寄存器，
或者一个已经被分配了这样的硬件寄存器的伪寄存器。你应该定义该宏，
如果表示为基址寄存器加上索引寄存器的地址具有不同于其它基址寄存器的用法要求时。

@en Use of this macro is deprecated; please use the more general
@en @code{REGNO_MODE_CODE_OK_FOR_BASE_P}.
不赞成使用该宏；请使用更加通用的@code{REGNO_MODE_CODE_OK_FOR_BASE_P}。

This macro also has strict and non-strict variants.
@end defmac

@defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{outer_code}, @var{index_code})
@en A C expression that is just like @code{REGNO_MODE_OK_FOR_BASE_P}, except
@en that that expression may examine the context in which the register
@en appears in the memory reference.  @var{outer_code} is the code of the
@en immediately enclosing expression (@code{MEM} if at the top level of the
@en address, @code{ADDRESS} for something that occurs in an
@en @code{address_operand}).  @var{index_code} is the code of the
@en corresponding index expression if @var{outer_code} is @code{PLUS};
@en @code{SCRATCH} otherwise.  The mode may be @code{VOIDmode} for addresses
@en that appear outside a @code{MEM}, i.e., as an @code{address_operand}.
一个C表达式，类似于@code{REGNO_MODE_OK_FOR_BASE_P}，
除了表达式可以检查寄存器出现内存引用中的上下文。@var{outer_code}为。
@var{index_code}为相应的索引表达式的代码，如果@var{outer_code}为@code{PLUS}；
否则为@code{SCRATCH}。对于出现在@code{MEM}之外的地址，
即作为一个@code{address_operand}，mode可以为@code{VOIDmode}。

This macro also has strict and non-strict variants.
@end defmac

@defmac REGNO_OK_FOR_INDEX_P (@var{num})
@en A C expression which is nonzero if register number @var{num} is
@en suitable for use as an index register in operand addresses.  It may be
@en either a suitable hard register or a pseudo register that has been
@en allocated such a hard register.
一个C表达式，其为非0，
如果寄存器编号@var{num}适合作为索引寄存器用于操作数地址中。
其可以为一个合适的硬件寄存器或者一个已经被分配了这样的硬件寄存器的伪寄存器。

@en The difference between an index register and a base register is that
@en the index register may be scaled.  If an address involves the sum of
@en two registers, neither one of them scaled, then either one may be
@en labeled the ``base'' and the other the ``index''; but whichever
@en labeling is used must fit the machine's constraints of which registers
@en may serve in each capacity.  The compiler will try both labelings,
@en looking for one that is valid, and will reload one or both registers
@en only if neither labeling works.
索引寄存器和基址寄存器的区别是，索引寄存器可以被标量化。
如果一个地址包含了两个寄存器的和，并且都不被标量化，
则一个可以被标签为“base” 另一个为“index”；但是使用哪个标签，
必须要适合机器的约束。编译器将尝试两种标签方式，来查找有效的一种，
并且当两种方式都无法工作时，重载一个或两个寄存器。
@end defmac

@deftypefn {Target Hook} reg_class_t TARGET_PREFERRED_RELOAD_CLASS (rtx @var{x}, reg_class_t @var{rclass})
A target hook that places additional restrictions on the register class
to use when it is necessary to copy value @var{x} into a register in class
@var{rclass}.  The value is a register class; perhaps @var{rclass}, or perhaps
another, smaller class.

The default version of this hook always returns value of @code{rclass} argument.

Sometimes returning a more restrictive class makes better code.  For
example, on the 68000, when @var{x} is an integer constant that is in range
for a @samp{moveq} instruction, the value of this macro is always
@code{DATA_REGS} as long as @var{rclass} includes the data registers.
Requiring a data register guarantees that a @samp{moveq} will be used.

One case where @code{TARGET_PREFERRED_RELOAD_CLASS} must not return
@var{rclass} is if @var{x} is a legitimate constant which cannot be
loaded into some register class.  By returning @code{NO_REGS} you can
force @var{x} into a memory location.  For example, rs6000 can load
immediate values into general-purpose registers, but does not have an
instruction for loading an immediate value into a floating-point
register, so @code{TARGET_PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when
@var{x} is a floating-point constant.  If the constant can't be loaded
into any kind of register, code generation will be better if
@code{LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead
of using @code{TARGET_PREFERRED_RELOAD_CLASS}.

If an insn has pseudos in it after register allocation, reload will go
through the alternatives and call repeatedly @code{TARGET_PREFERRED_RELOAD_CLASS}
to find the best one.  Returning @code{NO_REGS}, in this case, makes
reload add a @code{!} in front of the constraint: the x86 back-end uses
this feature to discourage usage of 387 registers when math is done in
the SSE registers (and vice versa).
@end deftypefn

@defmac PREFERRED_RELOAD_CLASS (@var{x}, @var{class})
@en A C expression that places additional restrictions on the register class
@en to use when it is necessary to copy value @var{x} into a register in class
@en @var{class}.  The value is a register class; perhaps @var{class}, or perhaps
@en another, smaller class.  On many machines, the following definition is
@en safe:
一个C表达式，对寄存器类别进行额外的限制，
用于当需要复制值@var{x}到类别为@var{class}的寄存器中。
值为一个寄存器类别；可能为@var{class}或者其它比@var{class}小的类别。
在许多机器上，下列定义是安全的：

@smallexample
#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS
@end smallexample

@en Sometimes returning a more restrictive class makes better code.  For
@en example, on the 68000, when @var{x} is an integer constant that is in range
@en for a @samp{moveq} instruction, the value of this macro is always
@en @code{DATA_REGS} as long as @var{class} includes the data registers.
@en Requiring a data register guarantees that a @samp{moveq} will be used.
有时返回一个更加限制的类别将会产生更好的代码。例如，在68000上，
当@var{x}为一个整数常量，并且在@samp{moveq}指令的范围内，
则该宏的值总是为@code{DATA_REGS}，只要@var{class}包含数据寄存器。
需要一个数据寄存器保证了@samp{moveq}将使用。

@en One case where @code{PREFERRED_RELOAD_CLASS} must not return
@en @var{class} is if @var{x} is a legitimate constant which cannot be
@en loaded into some register class.  By returning @code{NO_REGS} you can
@en force @var{x} into a memory location.  For example, rs6000 can load
@en immediate values into general-purpose registers, but does not have an
@en instruction for loading an immediate value into a floating-point
@en register, so @code{PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when
@en @var{x} is a floating-point constant.  If the constant can't be loaded
@en into any kind of register, code generation will be better if
@en @code{LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead
@en of using @code{PREFERRED_RELOAD_CLASS}.
一种@code{PREFERRED_RELOAD_CLASS}必须不返回@var{class}的情况为，
如果@var{x}为一个合法常量其不能被加载到某个寄存器类别中。
通过返回@code{NO_REGS}，你可以强迫@var{x}放入内存位置中。例如，
rs6000可以加载立即数值到通用寄存器中，
但没有指令可以加载立即数值到浮点寄存器中，
所以@code{PREFERRED_RELOAD_CLASS}返回@code{NO_REGS}，
当@var{x}为一个浮点常量时。如果常量不能被加载到任何种类的寄存器中，
如果@code{LEGITIMATE_CONSTANT_P}使常量为非法的，
而不是使用@code{PREFERRED_RELOAD_CLASS}，则代码生成将会更好。

@en If an insn has pseudos in it after register allocation, reload will go
@en through the alternatives and call repeatedly @code{PREFERRED_RELOAD_CLASS}
@en to find the best one.  Returning @code{NO_REGS}, in this case, makes
@en reload add a @code{!} in front of the constraint: the x86 back-end uses
@en this feature to discourage usage of 387 registers when math is done in
@en the SSE registers (and vice versa).
如果一个insn在寄存器分配之后具有伪寄存器，
则重载将遍历选择项并且反复调用@code{PREFERRED_RELOAD_CLASS}来找到最好的一个。
返回@code{NO_REGS}，在这种情况下，使得重载在约束前增加一个@code{!}：
x86后端使用该特征来劝阻使用387寄存器，当算术在SSE寄存器中进行时（反之亦然）。
@end defmac

@defmac PREFERRED_OUTPUT_RELOAD_CLASS (@var{x}, @var{class})
@en Like @code{PREFERRED_RELOAD_CLASS}, but for output reloads instead of
@en input reloads.  If you don't define this macro, the default is to use
@en @var{class}, unchanged.
类似于@code{PREFERRED_RELOAD_CLASS}，但是用于输出重载而不是输入重载。
如果没有定义该宏，则缺省为使用不变的@var{class}。

@en You can also use @code{PREFERRED_OUTPUT_RELOAD_CLASS} to discourage
@en reload from using some alternatives, like @code{PREFERRED_RELOAD_CLASS}.
你还可以使用@code{PREFERRED_OUTPUT_RELOAD_CLASS}来劝阻使用一些可选项的重载，
类似于@code{PREFERRED_RELOAD_CLASS}。
@end defmac

@deftypefn {Target Hook} reg_class_t TARGET_PREFERRED_OUTPUT_RELOAD_CLASS (rtx @var{x}, reg_class_t @var{rclass})
Like @code{TARGET_PREFERRED_RELOAD_CLASS}, but for output reloads instead of
input reloads.

The default version of this hook always returns value of @code{rclass}
argument.

You can also use @code{TARGET_PREFERRED_OUTPUT_RELOAD_CLASS} to discourage
reload from using some alternatives, like @code{TARGET_PREFERRED_RELOAD_CLASS}.
@end deftypefn

@defmac LIMIT_RELOAD_CLASS (@var{mode}, @var{class})
@en A C expression that places additional restrictions on the register class
@en to use when it is necessary to be able to hold a value of mode
@en @var{mode} in a reload register for which class @var{class} would
@en ordinarily be used.
一个C表达式，对寄存器类别实施额外的限制，
用于当需要在一个类别为@var{class}的重载寄存器中保存机器模式为@var{mode}的值的时候。

@en Unlike @code{PREFERRED_RELOAD_CLASS}, this macro should be used when
@en there are certain modes that simply can't go in certain reload classes.
不像@code{PREFERRED_RELOAD_CLASS}，
该宏应该用于当有特定的机器模式不能简单的放入特定的重载类别中的时候。

@en The value is a register class; perhaps @var{class}, or perhaps another,
@en smaller class.
值为一个寄存器类别；可能为@var{class}，或者其它更小的类别。

@en Don't define this macro unless the target machine has limitations which
@en require the macro to do something nontrivial.
不要定义该宏，除非target机器具有一些限制，使得宏需要做一些事情。
@end defmac

@deftypefn {Target Hook} reg_class_t TARGET_SECONDARY_RELOAD (bool @var{in_p}, rtx @var{x}, reg_class_t @var{reload_class}, enum machine_mode @var{reload_mode}, secondary_reload_info *@var{sri})
@en Many machines have some registers that cannot be copied directly to or
@en from memory or even from other types of registers.  An example is the
@en @samp{MQ} register, which on most machines, can only be copied to or
@en from general registers, but not memory.  Below, we shall be using the
@en term 'intermediate register' when a move operation cannot be performed
@en directly, but has to be done by copying the source into the intermediate
@en register first, and then copying the intermediate register to the
@en destination.  An intermediate register always has the same mode as
@en source and destination.  Since it holds the actual value being copied,
@en reload might apply optimizations to re-use an intermediate register
@en and eliding the copy from the source when it can determine that the
@en intermediate register still holds the required value.
许多机器具有一些寄存器，其不能直接和内存之间进行复制，
甚至不能和其它类型的寄存器。一个例子是@samp{MQ}寄存器，
在大多数机器上，只能与通用寄存器直接进行复制，而不能和内存之间。
下面，我们将使用术语‘中途寄存器’，当一个move操作不能直接执行，
而必须首先通过将源复制到中途寄存器中，然后再从中途寄存器复制到目的。
一个中途寄存器总是具有与源和目的相同的机器模式。由于其存放了被复制的实际的值，
所以重载可能进行优化来重用一个中途寄存器，并且省略掉从源进行复制的操作，
当它可以确定中途寄存器还保留着所需要的值的时候。

@en Another kind of secondary reload is required on some machines which
@en allow copying all registers to and from memory, but require a scratch
@en register for stores to some memory locations (e.g., those with symbolic
@en address on the RT, and those with certain symbolic address on the SPARC
@en when compiling PIC)@.  Scratch registers need not have the same mode
@en as the value being copied, and usually hold a different value than
@en that being copied.  Special patterns in the md file are needed to
@en describe how the copy is performed with the help of the scratch register;
@en these patterns also describe the number, register class(es) and mode(s)
@en of the scratch register(s).
另一种需要执行二次重载的情况是，在一些机器上，
其允许所有的寄存器和内存之间进行复制，
但要求一个scratch寄存器来存储一些内存的位置（例如，在RT上那些具有符号地址的，
以及在SPARC上当编译PIC时那些具有特定符号地址的）。
草稿寄存器不需要与被复制的值具有相同的机器模式，并且通常保留一个不同的值。
在md文件中需要特殊的指令模式来描述复制在草稿寄存器的帮助下如何执行；
这些指令模式还描述了草稿寄存器的编号，寄存器类别和机器模式。

@en In some cases, both an intermediate and a scratch register are required.
在一些情况下，同时需要中途寄存器和草稿寄存器。

@en For input reloads, this target hook is called with nonzero @var{in_p},
@en and @var{x} is an rtx that needs to be copied to a register of class
@en @var{reload_class} in @var{reload_mode}.  For output reloads, this target
@en hook is called with zero @var{in_p}, and a register of class @var{reload_class}
@en needs to be copied to rtx @var{x} in @var{reload_mode}.
对于输入重载，该target钩子使用非零的@var{in_p}来调用，并且@var{x}为一个rtx，
其需要被复制到一个类别为@var{reload_class}，机器模式为@var{reload_mode}的寄存器中。
对于输出重载，该target钩子使用为0的@var{in_p}调用，并且一个类别为@var{reload_class}，
需要复制到机器模式为reload_mode的rtx @var{x}中。

@en If copying a register of @var{reload_class} from/to @var{x} requires
@en an intermediate register, the hook @code{secondary_reload} should
@en return the register class required for this intermediate register.
@en If no intermediate register is required, it should return NO_REGS.
@en If more than one intermediate register is required, describe the one
@en that is closest in the copy chain to the reload register.
如果在类别为@var{reload_class}的寄存器和@var{x}直接进行复制需要一个中途寄存器，
则钩子@code{secondary_reload}应该返回一个该中途寄存器需要的寄存器类别。
如果不需要中途寄存器，则其应该返回NO_REGS。如果需要多个中途寄存器，
则描述在复制链中最近的那个。

@en If scratch registers are needed, you also have to describe how to
@en perform the copy from/to the reload register to/from this
@en closest intermediate register.  Or if no intermediate register is
@en required, but still a scratch register is needed, describe the
@en copy  from/to the reload register to/from the reload operand @var{x}.
如果需要草稿寄存器，
则还要描述如何如何在重载寄存器和这个最近的中途寄存器直接进行复制。
或者如果不需要中途寄存器，但仍然需要一个草稿寄存器，
则描述重载寄存器和重载操作数@var{x}之间的复制。

@en You do this by setting @code{sri->icode} to the instruction code of a pattern
@en in the md file which performs the move.  Operands 0 and 1 are the output
@en and input of this copy, respectively.  Operands from operand 2 onward are
@en for scratch operands.  These scratch operands must have a mode, and a
@en single-register-class
@en @c [later: or memory]
@en output constraint.
为此，你需要设置@code{sri->icode}为在md文件中执行move的指令模式的代码。
操作数0和1分别为该复制的输出和输入。从2以后的操作数为草稿操作数。
这些草稿操作数必须具有机器模式并且一个single-register-class的输出约束。

@en When an intermediate register is used, the @code{secondary_reload}
@en hook will be called again to determine how to copy the intermediate
@en register to/from the reload operand @var{x}, so your hook must also
@en have code to handle the register class of the intermediate operand.
当使用中途寄存器的时候，@code{secondary_reload}钩子将会被再次调用，
来确定如何在中途寄存器和重载操作数之间进行复制，
所以你的钩子必须还要具有处理中途操作数的寄存器类别的代码。

@c [For later: maybe we'll allow multi-alternative reload patterns -
@c   the port maintainer could name a mov<mode> pattern that has clobbers -
@c   and match the constraints of input and output to determine the required
@c   alternative.  A restriction would be that constraints used to match
@c   against reloads registers would have to be written as register class
@c   constraints, or we need a new target macro / hook that tells us if an
@c   arbitrary constraint can match an unknown register of a given class.
@c   Such a macro / hook would also be useful in other places.]


@en @var{x} might be a pseudo-register or a @code{subreg} of a
@en pseudo-register, which could either be in a hard register or in memory.
@en Use @code{true_regnum} to find out; it will return @minus{}1 if the pseudo is
@en in memory and the hard register number if it is in a register.
@var{x}可以为伪寄存器或者一个伪寄存器的@code{subreg}，
其可以为一个硬件寄存器或者在内存中。使用@code{true_regnum}来查看；
其将返回-1如果伪寄存器在内存中，以及硬件寄存器编号，如果其在一个寄存器中。

@en Scratch operands in memory (constraint @code{"=m"} / @code{"=&m"}) are
@en currently not supported.  For the time being, you will have to continue
@en to use @code{SECONDARY_MEMORY_NEEDED} for that purpose.
在内存中的草稿操作数（约束@code{"=m"} / @code{"=&m"}）目前不被支持。
为此，目前你必须继续使用@code{SECONDARY_MEMORY_NEEDED}。

@en @code{copy_cost} also uses this target hook to find out how values are
@en copied.  If you want it to include some extra cost for the need to allocate
@en (a) scratch register(s), set @code{sri->extra_cost} to the additional cost.
@en Or if two dependent moves are supposed to have a lower cost than the sum
@en of the individual moves due to expected fortuitous scheduling and/or special
@en forwarding logic, you can set @code{sri->extra_cost} to a negative amount.
@code{copy_cost}还是要该target钩子来查找值如何被复制。
如果你想让其包含像分配草稿寄存器所需要的额外代价，
则可以设置@code{sri->extra_cost}为额外代价。
或者如果两个相关move会具有比两个单个move之和的代价要低，
则可以设置@code{sri->extra_cost}为一个负数。
@end deftypefn

@defmac SECONDARY_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})
@defmacx SECONDARY_INPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})
@defmacx SECONDARY_OUTPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})
These macros are obsolete, new ports should use the target hook
@code{TARGET_SECONDARY_RELOAD} instead.

These are obsolete macros, replaced by the @code{TARGET_SECONDARY_RELOAD}
target hook.  Older ports still define these macros to indicate to the
reload phase that it may
need to allocate at least one register for a reload in addition to the
register to contain the data.  Specifically, if copying @var{x} to a
register @var{class} in @var{mode} requires an intermediate register,
you were supposed to define @code{SECONDARY_INPUT_RELOAD_CLASS} to return the
largest register class all of whose registers can be used as
intermediate registers or scratch registers.

If copying a register @var{class} in @var{mode} to @var{x} requires an
intermediate or scratch register, @code{SECONDARY_OUTPUT_RELOAD_CLASS}
was supposed to be defined be defined to return the largest register
class required.  If the
requirements for input and output reloads were the same, the macro
@code{SECONDARY_RELOAD_CLASS} should have been used instead of defining both
macros identically.

The values returned by these macros are often @code{GENERAL_REGS}.
Return @code{NO_REGS} if no spare register is needed; i.e., if @var{x}
can be directly copied to or from a register of @var{class} in
@var{mode} without requiring a scratch register.  Do not define this
macro if it would always return @code{NO_REGS}.

If a scratch register is required (either with or without an
intermediate register), you were supposed to define patterns for
@samp{reload_in@var{m}} or @samp{reload_out@var{m}}, as required
(@pxref{Standard Names}.  These patterns, which were normally
implemented with a @code{define_expand}, should be similar to the
@samp{mov@var{m}} patterns, except that operand 2 is the scratch
register.

These patterns need constraints for the reload register and scratch
register that
contain a single register class.  If the original reload register (whose
class is @var{class}) can meet the constraint given in the pattern, the
value returned by these macros is used for the class of the scratch
register.  Otherwise, two additional reload registers are required.
Their classes are obtained from the constraints in the insn pattern.

@var{x} might be a pseudo-register or a @code{subreg} of a
pseudo-register, which could either be in a hard register or in memory.
Use @code{true_regnum} to find out; it will return @minus{}1 if the pseudo is
in memory and the hard register number if it is in a register.

These macros should not be used in the case where a particular class of
registers can only be copied to memory and not to another class of
registers.  In that case, secondary reload registers are not needed and
would not be helpful.  Instead, a stack location must be used to perform
the copy and the @code{mov@var{m}} pattern should use memory as an
intermediate storage.  This case often occurs between floating-point and
general registers.
@end defmac

@defmac SECONDARY_MEMORY_NEEDED (@var{class1}, @var{class2}, @var{m})
@en Certain machines have the property that some registers cannot be copied
@en to some other registers without using memory.  Define this macro on
@en those machines to be a C expression that is nonzero if objects of mode
@en @var{m} in registers of @var{class1} can only be copied to registers of
@en class @var{class2} by storing a register of @var{class1} into memory
@en and loading that memory location into a register of @var{class2}.
一些机器要求某些寄存器必须使用内存才能与其它寄存器进行复制。
定义该宏在那些机器上，其为一个C表达式，
为非0如果机器模式为@var{m}的对象在类别为@var{class1}的寄存器中，
只能通过将@var{class1}的寄存器存储到内存中并且将内存位置加载到@var{class2}的寄存中。

@en Do not define this macro if its value would always be zero.
如果其值总是为0，则不要定义该宏。
@end defmac

@defmac SECONDARY_MEMORY_NEEDED_RTX (@var{mode})
@en Normally when @code{SECONDARY_MEMORY_NEEDED} is defined, the compiler
@en allocates a stack slot for a memory location needed for register copies.
@en If this macro is defined, the compiler instead uses the memory location
@en defined by this macro.
通常当@code{SECONDARY_MEMORY_NEEDED}被定义时，
编译器会分配一个栈槽为需要寄存器复制的内存位置。
如果该宏被定义，则编译器会替代的使用该宏定义的内存位置。

@en Do not define this macro if you do not define
@en @code{SECONDARY_MEMORY_NEEDED}.
如果没有定义@code{SECONDARY_MEMORY_NEEDED}，则不要定义该宏。
@end defmac

@defmac SECONDARY_MEMORY_NEEDED_MODE (@var{mode})
@en When the compiler needs a secondary memory location to copy between two
@en registers of mode @var{mode}, it normally allocates sufficient memory to
@en hold a quantity of @code{BITS_PER_WORD} bits and performs the store and
@en load operations in a mode that many bits wide and whose class is the
@en same as that of @var{mode}.
当编译器需要一个二级内存位置在机器模式为@var{mode}的寄存器之间进行复制的时候，
其通常分配足够的内存来存放@code{BITS_PER_WORD}个位，
并且执行该位数宽度的@var{mode}的存储和加载操作。

@en This is right thing to do on most machines because it ensures that all
@en bits of the register are copied and prevents accesses to the registers
@en in a narrower mode, which some machines prohibit for floating-point
@en registers.
这在大多数机器上是正确的，
因为其确保寄存器的所有位被复制并且阻止对寄存器按照较窄的机器模式来访问，
这对于浮点寄存器通常是禁止的。

@en However, this default behavior is not correct on some machines, such as
@en the DEC Alpha, that store short integers in floating-point registers
@en differently than in integer registers.  On those machines, the default
@en widening will not work correctly and you must define this macro to
@en suppress that widening in some cases.  See the file @file{alpha.h} for
@en details.
然而，该缺省行为在一些机器上是不正确的，例如DEC Alpha，
其在浮点寄存器中存储short整数与在整数寄存器中是不同的。
在那些机器上，缺省的宽度将不正确，你必须定义该宏来抑制这种宽度。
详情参见@file{alpha.h}文件。

@en Do not define this macro if you do not define
@en @code{SECONDARY_MEMORY_NEEDED} or if widening @var{mode} to a mode that
@en is @code{BITS_PER_WORD} bits wide is correct for your machine.
如果没有定义，或者如果@code{BITS_PER_WORD}个位数的宽度是正确的，则不要定义该宏。
@end defmac

@deftypefn {Target Hook} bool TARGET_CLASS_LIKELY_SPILLED_P (reg_class_t @var{rclass})
A target hook which returns @code{true} if pseudos that have been assigned
to registers of class @var{rclass} would likely be spilled because
registers of @var{rclass} are needed for spill registers.

The default version of this target hook returns @code{true} if @var{rclass}
has exactly one register and @code{false} otherwise.  On most machines, this
default should be used.  Only use this target hook to some other expression
if pseudos allocated by @file{local-alloc.c} end up in memory because their
hard registers were needed for spill registers.  If this target hook returns
@code{false} for those classes, those pseudos will only be allocated by
@file{global.c}, which knows how to reallocate the pseudo to another
register.  If there would not be another register available for reallocation,
you should not change the implementation of this target hook since
the only effect of such implementation would be to slow down register
allocation.
@end deftypefn

@defmac CLASS_LIKELY_SPILLED_P (@var{class})
A C expression whose value is nonzero if pseudos that have been assigned
to registers of class @var{class} would likely be spilled because
registers of @var{class} are needed for spill registers.

The default value of this macro returns 1 if @var{class} has exactly one
register and zero otherwise.  On most machines, this default should be
used.  Only define this macro to some other expression if pseudos
allocated by @file{local-alloc.c} end up in memory because their hard
registers were needed for spill registers.  If this macro returns nonzero
for those classes, those pseudos will only be allocated by
@file{global.c}, which knows how to reallocate the pseudo to another
register.  If there would not be another register available for
reallocation, you should not change the definition of this macro since
the only effect of such a definition would be to slow down register
allocation.
@end defmac

@defmac CLASS_MAX_NREGS (@var{class}, @var{mode})
@en A C expression for the maximum number of consecutive registers
@en of class @var{class} needed to hold a value of mode @var{mode}.
一个C表达式，为需要存放机器模式为@var{mode}的值所需要的连续的类别为@var{class}的寄存器的最大数。

@en This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact,
@en the value of the macro @code{CLASS_MAX_NREGS (@var{class}, @var{mode})}
@en should be the maximum value of @code{HARD_REGNO_NREGS (@var{regno},
@en @var{mode})} for all @var{regno} values in the class @var{class}.
这与宏@code{HARD_REGNO_NREGS}很相近。实际上，
宏@code{CLASS_MAX_NREGS (@var{class}, @var{mode})}的值应该为@code{HARD_REGNO_NREGS (@var{regno},@var{mode})}的最大值。

@en This macro helps control the handling of multiple-word values
@en in the reload pass.
该宏有助于处理多字的值，在重载过程中。
@end defmac

@defmac CANNOT_CHANGE_MODE_CLASS (@var{from}, @var{to}, @var{class})
@en If defined, a C expression that returns nonzero for a @var{class} for which
@en a change from mode @var{from} to mode @var{to} is invalid.
如果被定义，为一个C表达式，其返回非0，对于一个@var{class}，
其由机器模式@var{from}到@var{to}的改变是无效的。

@en For the example, loading 32-bit integer or floating-point objects into
@en floating-point registers on the Alpha extends them to 64 bits.
@en Therefore loading a 64-bit object and then storing it as a 32-bit object
@en does not store the low-order 32 bits, as would be the case for a normal
@en register.  Therefore, @file{alpha.h} defines @code{CANNOT_CHANGE_MODE_CLASS}
@en as below:
例如，加载32位整数或者浮点对象到浮点寄存器中，在Alpha上将被扩展为64位。
因此加载64位对象并存储为32位对象时将不保存第32位。
因此，@file{alpha.h}定义@code{CANNOT_CHANGE_MODE_CLASS}如下：

@smallexample
#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \
  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \
   ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)
@end smallexample
@end defmac

@deftypefn {Target Hook} {const reg_class_t *} TARGET_IRA_COVER_CLASSES (void)
Return an array of cover classes for the Integrated Register Allocator
(@acronym{IRA}).  Cover classes are a set of non-intersecting register
classes covering all hard registers used for register allocation
purposes.  If a move between two registers in the same cover class is
possible, it should be cheaper than a load or store of the registers.
The array is terminated by a @code{LIM_REG_CLASSES} element.

The order of cover classes in the array is important.  If two classes
have the same cost of usage for a pseudo, the class occurred first in
the array is chosen for the pseudo.

This hook is called once at compiler startup, after the command-line
options have been processed. It is then re-examined by every call to
@code{target_reinit}.

The default implementation returns @code{IRA_COVER_CLASSES}, if defined,
otherwise there is no default implementation.  You must define either this
macro or @code{IRA_COVER_CLASSES} in order to use the integrated register
allocator with Chaitin-Briggs coloring. If the macro is not defined,
the only available coloring algorithm is Chow's priority coloring.

This hook must not be modified from @code{NULL} to non-@code{NULL} or
vice versa by command-line option processing.
@end deftypefn

@defmac IRA_COVER_CLASSES
See the documentation for @code{TARGET_IRA_COVER_CLASSES}.
@end defmac

@en @node Old Constraints
@en @section Obsolete Macros for Defining Constraints
@node Old Constraints
@section 废弃的定义约束的宏
@cindex defining constraints, obsolete method
@cindex constraints, defining, obsolete method

@en Machine-specific constraints can be defined with these macros instead
@en of the machine description constructs described in @ref{Define
@en Constraints}.  This mechanism is obsolete.  New ports should not use
@en it; old ports should convert to the new mechanism.
机器特定的约束可以使用这些宏来定义，来替代在@ref{Define Constraints}中描述的机器描述结构。
这种机制已经被废弃；旧的port应该转换为新的机制。

@defmac CONSTRAINT_LEN (@var{char}, @var{str})
@en For the constraint at the start of @var{str}, which starts with the letter
@en @var{c}, return the length.  This allows you to have register class /
@en constant / extra constraints that are longer than a single letter;
@en you don't need to define this macro if you can do with single-letter
@en constraints only.  The definition of this macro should use
@en DEFAULT_CONSTRAINT_LEN for all the characters that you don't want
@en to handle specially.
@en There are some sanity checks in genoutput.c that check the constraint lengths
@en for the md file, so you can also use this macro to help you while you are
@en transitioning from a byzantine single-letter-constraint scheme: when you
@en return a negative length for a constraint you want to re-use, genoutput
@en will complain about every instance where it is used in the md file.
对于起始于@var{str}，其起始字母为@var{c}的约束，返回其长度。
这允许你具有比单个字母更长的寄存器类别/常量/额外约束；
你不需要定义该宏，如果你只用单个字母的约束。
该宏的定义应该使用DEFAULT_CONSTRAINT_LEN，对于你不想特别处理的所有字符。
在genoutput.c中有一些合理性检查，用来为md文件检查约束的长度。
@end defmac

@defmac REG_CLASS_FROM_LETTER (@var{char})
@en A C expression which defines the machine-dependent operand constraint
@en letters for register classes.  If @var{char} is such a letter, the
@en value should be the register class corresponding to it.  Otherwise,
@en the value should be @code{NO_REGS}.  The register letter @samp{r},
@en corresponding to class @code{GENERAL_REGS}, will not be passed
@en to this macro; you do not need to handle it.
一个C表达式，其为寄存器类别定义了机器相关的操作数约束字母。
如果@var{char}为这样的字母，则值应该为对应的寄存器类别。否则，
值应该为@code{NO_REGS}。寄存器字母@samp{r}，对应于类别@code{GENERAL_REGS}，
将不被传给该宏；你不需要处理它。
@end defmac

@defmac REG_CLASS_FROM_CONSTRAINT (@var{char}, @var{str})
@en Like @code{REG_CLASS_FROM_LETTER}, but you also get the constraint string
@en passed in @var{str}, so that you can use suffixes to distinguish between
@en different variants.
类似于@code{REG_CLASS_FROM_LETTER}，不过你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac CONST_OK_FOR_LETTER_P (@var{value}, @var{c})
@en A C expression that defines the machine-dependent operand constraint
@en letters (@samp{I}, @samp{J}, @samp{K}, @dots{} @samp{P}) that specify
@en particular ranges of integer values.  If @var{c} is one of those
@en letters, the expression should check that @var{value}, an integer, is in
@en the appropriate range and return 1 if so, 0 otherwise.  If @var{c} is
@en not one of those letters, the value should be 0 regardless of
@en @var{value}.
一个C表达式，其定义了机器相关操作数约束字母（@samp{I}, @samp{J}, @samp{K}, 
@dots{} @samp{P}），指定了整数值的特定范围。如果@var{c}为那些字母中的，
则表达式应该检查@var{value}，一个整数，如果在合适的范围中则返回1，否则返回0。
如果@var{c}不是那些字母中的，则值应该为0，而不管@var{value}是多少。
@end defmac

@defmac CONST_OK_FOR_CONSTRAINT_P (@var{value}, @var{c}, @var{str})
@en Like @code{CONST_OK_FOR_LETTER_P}, but you also get the constraint
@en string passed in @var{str}, so that you can use suffixes to distinguish
@en between different variants.
类似@code{CONST_OK_FOR_LETTER_P}，但是你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac CONST_DOUBLE_OK_FOR_LETTER_P (@var{value}, @var{c})
@en A C expression that defines the machine-dependent operand constraint
@en letters that specify particular ranges of @code{const_double} values
@en (@samp{G} or @samp{H}).
一个C表达式，定义了机器相关操作数约束字母，
指定了@code{const_double}值的特定范围（@samp{G}或@samp{H}）。

@en If @var{c} is one of those letters, the expression should check that
@en @var{value}, an RTX of code @code{const_double}, is in the appropriate
@en range and return 1 if so, 0 otherwise.  If @var{c} is not one of those
@en letters, the value should be 0 regardless of @var{value}.
如果@var{c}为那些字母中的，则表达式应该检查@var{value}，
一个代码为@code{const_double}的RTX，如果在合适的范围中则返回1，否则返回0。
如果@var{c}不是那些字母中的，则值应该为0，而不管@var{value}是多少。

@en @code{const_double} is used for all floating-point constants and for
@en @code{DImode} fixed-point constants.  A given letter can accept either
@en or both kinds of values.  It can use @code{GET_MODE} to distinguish
@en between these kinds.
@code{const_double}用于所有的浮点常量和@code{DImode}定点常量。
一个给定的字母可以接受一种或者这两种类型的值。
其可以使用@code{GET_MODE}来区别这些类型。
@end defmac

@defmac CONST_DOUBLE_OK_FOR_CONSTRAINT_P (@var{value}, @var{c}, @var{str})
@en Like @code{CONST_DOUBLE_OK_FOR_LETTER_P}, but you also get the constraint
@en string passed in @var{str}, so that you can use suffixes to distinguish
@en between different variants.
类似@code{CONST_DOUBLE_OK_FOR_LETTER_P}，但是你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac EXTRA_CONSTRAINT (@var{value}, @var{c})
@en A C expression that defines the optional machine-dependent constraint
@en letters that can be used to segregate specific types of operands, usually
@en memory references, for the target machine.  Any letter that is not
@en elsewhere defined and not matched by @code{REG_CLASS_FROM_LETTER} /
@en @code{REG_CLASS_FROM_CONSTRAINT}
@en may be used.  Normally this macro will not be defined.
一个C表达式，定义了可选的机器相关约束字母，
其可以用于为target机器隔离特定类型的操作数，通常为内存引用。
任何没有在其它地方定义并且不被
@code{REG_CLASS_FROM_LETTER} / REG_CLASS_FROM_CONSTRAINT匹配的字母都可以使用。
通常该宏将不被定义。

@en If it is required for a particular target machine, it should return 1
@en if @var{value} corresponds to the operand type represented by the
@en constraint letter @var{c}.  If @var{c} is not defined as an extra
@en constraint, the value returned should be 0 regardless of @var{value}.
如果对于特定的target机器需要该宏，则应该返回1，
如果@var{value}对应于由约束字母@var{c}表示的操作数类型。
如果@var{c}没有作为extra约束定义，则值应该为0，而不管@var{value}是多少。

@en For example, on the ROMP, load instructions cannot have their output
@en in r0 if the memory reference contains a symbolic address.  Constraint
@en letter @samp{Q} is defined as representing a memory address that does
@en @emph{not} contain a symbolic address.  An alternative is specified with
@en a @samp{Q} constraint on the input and @samp{r} on the output.  The next
@en alternative specifies @samp{m} on the input and a register class that
@en does not include r0 on the output.
例如，则ROMP上，加载指令不能将它们的输出放在r0中，
如果内存引用包含了一个符号地址。
约束字母@samp{Q}被定义来表示不包含符号地址的内存地址。
一个可选项使用@samp{Q}约束在输入上并且@samp{r}在输出上来指定。
下一个可选项指定了@samp{m}在输入上并且不包含r0的寄存器类别在输出上。
@end defmac

@defmac EXTRA_CONSTRAINT_STR (@var{value}, @var{c}, @var{str})
@en Like @code{EXTRA_CONSTRAINT}, but you also get the constraint string passed
@en in @var{str}, so that you can use suffixes to distinguish between different
@en variants.
类似@code{EXTRA_CONSTRAINT}，但是你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac EXTRA_MEMORY_CONSTRAINT (@var{c}, @var{str})
@en A C expression that defines the optional machine-dependent constraint
@en letters, amongst those accepted by @code{EXTRA_CONSTRAINT}, that should
@en be treated like memory constraints by the reload pass.
一个C表达式，定义了可选的机器相关约束字母，
在那些由@code{EXTRA_CONSTRAINT}接受的字母中，
其应该被重载过程作为内存约束来对待。

@en It should return 1 if the operand type represented by the constraint
@en at the start of @var{str}, the first letter of which is the letter @var{c},
@en comprises a subset of all memory references including
@en all those whose address is simply a base register.  This allows the reload
@en pass to reload an operand, if it does not directly correspond to the operand
@en type of @var{c}, by copying its address into a base register.
其应该返回1，如果由@var{str}起始，并且第一个字母为@var{c}的约束所表示的操作数
类型所包含的所有内存引用为简单的基址寄存器。这允许重载过程来重载操作数，
如果其不直接对应于操作数类型@var{c}，通过将其地址复制到基址寄存器中。

@en For example, on the S/390, some instructions do not accept arbitrary
@en memory references, but only those that do not make use of an index
@en register.  The constraint letter @samp{Q} is defined via
@en @code{EXTRA_CONSTRAINT} as representing a memory address of this type.
@en If the letter @samp{Q} is marked as @code{EXTRA_MEMORY_CONSTRAINT},
@en a @samp{Q} constraint can handle any memory operand, because the
@en reload pass knows it can be reloaded by copying the memory address
@en into a base register if required.  This is analogous to the way
@en an @samp{o} constraint can handle any memory operand.
例如，在S/390上，一些指令不接受任意的内存引用，只接受那些不使用索引寄存器的。
约束字母@samp{Q}被通过@code{EXTRA_CONSTRAINT}定义，来表示这种类型的内存地址。
如果字母@samp{Q}被标记为@code{EXTRA_MEMORY_CONSTRAINT}，
则一个@samp{Q}常量可以处理任何内存操作数，
因为重载过程知道其可以通过将内存地址复制到基址寄存器中如果需要的话。
这类似于可以处理任何内存操作数的@samp{o}约束的方式。
@end defmac

@defmac EXTRA_ADDRESS_CONSTRAINT (@var{c}, @var{str})
@en A C expression that defines the optional machine-dependent constraint
@en letters, amongst those accepted by @code{EXTRA_CONSTRAINT} /
@en @code{EXTRA_CONSTRAINT_STR}, that should
@en be treated like address constraints by the reload pass.
一个C表达式，定义了可选的机器相关约束字母，在那些由
@code{EXTRA_CONSTRAINT} / @code{EXTRA_CONSTRAINT_STR}接受的字母中，
其应该被重载过程作为地址约束来对待。

@en It should return 1 if the operand type represented by the constraint
@en at the start of @var{str}, which starts with the letter @var{c}, comprises
@en a subset of all memory addresses including
@en all those that consist of just a base register.  This allows the reload
@en pass to reload an operand, if it does not directly correspond to the operand
@en type of @var{str}, by copying it into a base register.
其应该返回1，如果由@var{str}起始，并且第一个字母为@var{c}的约束所表示的操作数
类型所包含的所有内存引用为简单的基址寄存器。这允许重载过程来重载操作数，
如果其不直接对应于操作数类型@var{str}，通过将其地址复制到基址寄存器中。

@en Any constraint marked as @code{EXTRA_ADDRESS_CONSTRAINT} can only
@en be used with the @code{address_operand} predicate.  It is treated
@en analogously to the @samp{p} constraint.
标记为@code{EXTRA_ADDRESS_CONSTRAINT}的约束只能与@code{address_operand}断言
一起使用。其类似于@samp{p}约束。
@end defmac

@en @node Stack and Calling
@en @section Stack Layout and Calling Conventions
@node Stack and Calling
@section 栈布局和调用约定
@cindex calling conventions

@c prevent bad page break with this line
@en This describes the stack layout and calling conventions.
这一节描述了栈的布局和调用约定。

@menu
* Frame Layout::
* Exception Handling::
* Stack Checking::
* Frame Registers::
* Elimination::
* Stack Arguments::
* Register Arguments::
* Scalar Return::
* Aggregate Return::
* Caller Saves::
* Function Entry::
* Profiling::
* Tail Calls::
* Stack Smashing Protection::
@end menu

@en @node Frame Layout
@en @subsection Basic Stack Layout
@node Frame Layout
@subsection 基本的帧布局
@cindex stack frame layout
@cindex frame layout

@c prevent bad page break with this line
@en Here is the basic stack layout.
这里是基本的栈布局。

@defmac STACK_GROWS_DOWNWARD
@en Define this macro if pushing a word onto the stack moves the stack
@en pointer to a smaller address.
定义该宏，如果将一个字压入栈中使得栈指针移向更小的地址。

@en When we say, ``define this macro if @dots{}'', it means that the
@en compiler checks this macro only with @code{#ifdef} so the precise
@en definition used does not matter.
当我们说“定义该宏，如果@dots{}”，这意味着编译器只是使用@code{#ifdef}来检查该宏，
所以具体定义的值并没有关系。
@end defmac

@defmac STACK_PUSH_CODE
@en This macro defines the operation used when something is pushed
@en on the stack.  In RTL, a push operation will be
@en @code{(set (mem (STACK_PUSH_CODE (reg sp))) @dots{})}
该宏定义了当压栈所使用的操作。对于RTL形式，
压栈操作将为@code{(set (mem (STACK_PUSH_CODE (reg sp))) @dots{})}。

@en The choices are @code{PRE_DEC}, @code{POST_DEC}, @code{PRE_INC},
@en and @code{POST_INC}.  Which of these is correct depends on
@en the stack direction and on whether the stack pointer points
@en to the last item on the stack or whether it points to the
@en space for the next item on the stack.
可选择的方式为@code{PRE_DEC}, @code{POST_DEC}, @code{PRE_INC}和@code{POST_INC}。
使用哪一个是正确的，取决于栈的方向和栈指针是否指向栈中的最后一项，
还是指向之后的空间。

@en The default is @code{PRE_DEC} when @code{STACK_GROWS_DOWNWARD} is
@en defined, which is almost always right, and @code{PRE_INC} otherwise,
@en which is often wrong.
缺省为@code{PRE_DEC}，当@code{STACK_GROWS_DOWNWARD}被定义时，
这大多情况下都是正确，否则为@code{PRE_INC}，这经常是错误的。
@end defmac

@defmac FRAME_GROWS_DOWNWARD
@en Define this macro to nonzero value if the addresses of local variable slots
@en are at negative offsets from the frame pointer.
定义该宏为非零值，如果局部变量槽的地址位于帧指针的负偏移处。
@end defmac

@defmac ARGS_GROW_DOWNWARD
@en Define this macro if successive arguments to a function occupy decreasing
@en addresses on the stack.
定义该宏，如果函数的连续的参数在栈上的地址是递减的。
@end defmac

@defmac STARTING_FRAME_OFFSET
@en Offset from the frame pointer to the first local variable slot to be allocated.
帧指针到第一个被分配的局部变量槽的偏移量。

@en If @code{FRAME_GROWS_DOWNWARD}, find the next slot's offset by
@en subtracting the first slot's length from @code{STARTING_FRAME_OFFSET}.
@en Otherwise, it is found by adding the length of the first slot to the
@en value @code{STARTING_FRAME_OFFSET}.
如果@code{FRAME_GROWS_DOWNWARD}，则通过从@code{STARTING_FRAME_OFFSET}减去第一个
栈槽的长度来查找下一个栈槽的偏移量。否则，通过从@code{STARTING_FRAME_OFFSET}
加上第一个栈槽的长度来查找。
@c i'm not sure if the above is still correct.. had to change it to get
@c rid of an overfull.  --mew 2feb93
@end defmac

@defmac STACK_ALIGNMENT_NEEDED
@en Define to zero to disable final alignment of the stack during reload.
@en The nonzero default for this macro is suitable for most ports.
定义为0，来禁止在重载过程中对栈进行最后的对齐操作。缺省的非0值适合于大多port。

@en On ports where @code{STARTING_FRAME_OFFSET} is nonzero or where there
@en is a register save block following the local block that doesn't require
@en alignment to @code{STACK_BOUNDARY}, it may be beneficial to disable
@en stack alignment and do it in the backend.
在一些port上，@code{STARTING_FRAME_OFFSET}为非0，
或者在局部块之后有一块寄存器保存区域，其不需要对齐到@code{STACK_BOUNDARY}，
这样禁止栈对齐并且在后端实现可能会更好。
@end defmac

@defmac STACK_POINTER_OFFSET
@en Offset from the stack pointer register to the first location at which
@en outgoing arguments are placed.  If not specified, the default value of
@en zero is used.  This is the proper value for most machines.
从栈指针寄存器到第一个输出的参数所放在的位置的偏移量。
如果没有指定，则缺省值0被使用。这对于大多数机器都合适。

@en If @code{ARGS_GROW_DOWNWARD}, this is the offset to the location above
@en the first location at which outgoing arguments are placed.
如果@code{ARGS_GROW_DOWNWARD}，
则这是输出参数位于的第一个位置的上面的位置的偏移量。
@end defmac

@defmac FIRST_PARM_OFFSET (@var{fundecl})
@en Offset from the argument pointer register to the first argument's
@en address.  On some machines it may depend on the data type of the
@en function.
参数指针寄存器到第一个参数的地址的偏移量。在一些机器上，
其可能依赖于函数的数据类型。

@en If @code{ARGS_GROW_DOWNWARD}, this is the offset to the location above
@en the first argument's address.
如果@code{ARGS_GROW_DOWNWARD}，则这是第一个参数的地址的上面的位置的偏移量。
@end defmac

@defmac STACK_DYNAMIC_OFFSET (@var{fundecl})
@en Offset from the stack pointer register to an item dynamically allocated
@en on the stack, e.g., by @code{alloca}.
栈指针寄存器到在栈上动态分配的对象的偏移量，例如，通过@code{alloca}。

@en The default value for this macro is @code{STACK_POINTER_OFFSET} plus the
@en length of the outgoing arguments.  The default is correct for most
@en machines.  See @file{function.c} for details.
该宏的缺省值为@code{STACK_POINTER_OFFSET}加上输出参数的长度。
缺省值对于大多数机器是正确的。详情参见@file{function.c}。
@end defmac

@defmac INITIAL_FRAME_ADDRESS_RTX
@en A C expression whose value is RTL representing the address of the initial
@en stack frame. This address is passed to @code{RETURN_ADDR_RTX} and
@en @code{DYNAMIC_CHAIN_ADDRESS}.  If you don't define this macro, a reasonable
@en default value will be used.  Define this macro in order to make frame pointer
@en elimination work in the presence of @code{__builtin_frame_address (count)} and
@en @code{__builtin_return_address (count)} for @code{count} not equal to zero.
一个C表达式，其值为RTL，表示初始栈帧的地址。
该地址被传给@code{RETURN_ADDR_RTX}和@code{DYNAMIC_CHAIN_ADDRESS}。
如果你没有定义该宏，则一个合理的缺省值将被使用。定义该宏，
可以使帧指针消除在@code{__builtin_frame_address (count)}和
@code{__builtin_return_address (count)}不等于0的情况下工作。
@end defmac

@defmac DYNAMIC_CHAIN_ADDRESS (@var{frameaddr})
@en A C expression whose value is RTL representing the address in a stack
@en frame where the pointer to the caller's frame is stored.  Assume that
@en @var{frameaddr} is an RTL expression for the address of the stack frame
@en itself.
一个C表达式，其值为RTL，表示栈帧中的地址，指向被存储的调用者的帧。
假设@var{frameaddr}为一个栈帧本身的地址的RTL表达式。

@en If you don't define this macro, the default is to return the value
@en of @var{frameaddr}---that is, the stack frame address is also the
@en address of the stack word that points to the previous frame.
如果你没有定义该宏，则缺省为返回@var{frameaddr}的值——也就是说，
栈帧地址也是指向之前帧的地址。
@end defmac

@defmac SETUP_FRAME_ADDRESSES
@en If defined, a C expression that produces the machine-specific code to
@en setup the stack so that arbitrary frames can be accessed.  For example,
@en on the SPARC, we must flush all of the register windows to the stack
@en before we can access arbitrary stack frames.  You will seldom need to
@en define this macro.
如果定义，为一个C表达式，其产生机器特定的代码来建立栈，使得可以访问任意的帧。
例如，在SPARC上，我们必须刷新栈的所有寄存器窗口，在我们可以访问任意栈帧之前。
你很少会需要定义该宏。
@end defmac

@deftypefn {Target Hook} rtx TARGET_BUILTIN_SETJMP_FRAME_VALUE (void)
@en This target hook should return an rtx that is used to store
@en the address of the current frame into the built in @code{setjmp} buffer.
@en The default value, @code{virtual_stack_vars_rtx}, is correct for most
@en machines.  One reason you may need to define this target hook is if
@en @code{hard_frame_pointer_rtx} is the appropriate value on your machine.
该target钩子应该返回一个rtx，用于将当前帧的地址存储到内建的@code{setjmp}缓存中。
缺省值，@code{virtual_stack_vars_rtx}，对于大多数机器是正确的。
一种你可能需要定义该target钩子的原因是，
如果@code{hard_frame_pointer_rtx}在你的机器上是合适的值。
@end deftypefn

@defmac FRAME_ADDR_RTX (@var{frameaddr})
@en A C expression whose value is RTL representing the value of the frame
@en address for the current frame.  @var{frameaddr} is the frame pointer
@en of the current frame.  This is used for __builtin_frame_address.
@en You need only define this macro if the frame address is not the same
@en as the frame pointer.  Most machines do not need to define it.
一个C表达式，其值为RTL，表示当前帧的帧地址。@var{frameaddr}为当前帧的帧指针。
这用于__builtin_frame_address。你只有当帧地址与帧指针不同的时候才需要定义该宏。
大多数机器不需要定义该宏。
@end defmac

@defmac RETURN_ADDR_RTX (@var{count}, @var{frameaddr})
A C expression whose value is RTL representing the value of the return
address for the frame @var{count} steps up from the current frame, after
the prologue.  @var{frameaddr} is the frame pointer of the @var{count}
frame, or the frame pointer of the @var{count} @minus{} 1 frame if
@code{RETURN_ADDR_IN_PREVIOUS_FRAME} is defined.

The value of the expression must always be the correct address when
@var{count} is zero, but may be @code{NULL_RTX} if there is no way to
determine the return address of other frames.
@end defmac

@defmac RETURN_ADDR_IN_PREVIOUS_FRAME
@en Define this if the return address of a particular stack frame is accessed
@en from the frame pointer of the previous stack frame.
定义该宏，如果一个特定的栈帧的返回地址是从之前栈帧的帧指针中访问的。
@end defmac

@defmac INCOMING_RETURN_ADDR_RTX
@en A C expression whose value is RTL representing the location of the
@en incoming return address at the beginning of any function, before the
@en prologue.  This RTL is either a @code{REG}, indicating that the return
@en value is saved in @samp{REG}, or a @code{MEM} representing a location in
@en the stack.
一个C表达式，其值为RTL，表示在任何函数的起始处，在序言之前，
流入的返回地址的位置。该RTL或者为一个@code{REG}，
指示返回地址保存在@samp{REG}中，或者一个@code{MEM}表示位于栈中。

@en You only need to define this macro if you want to support call frame
@en debugging information like that provided by DWARF 2.
你只在你想支持调用帧调试信息，像DWARF2提供的那样，的时候才需要定义该宏。

@en If this RTL is a @code{REG}, you should also define
@en @code{DWARF_FRAME_RETURN_COLUMN} to @code{DWARF_FRAME_REGNUM (REGNO)}.
如果该RTL为一个@code{REG}，
你还要定义@code{DWARF_FRAME_RETURN_COLUMN}为@code{DWARF_FRAME_REGNUM (REGNO)}。
@end defmac

@defmac DWARF_ALT_FRAME_RETURN_COLUMN
@en A C expression whose value is an integer giving a DWARF 2 column
@en number that may be used as an alternative return column.  The column
@en must not correspond to any gcc hard register (that is, it must not
@en be in the range of @code{DWARF_FRAME_REGNUM}).
一个C表达式，其值为一个整数，给出了DWARF2的列号，可以用作替代的返回列。
column必须不对应于任何gcc硬件寄存器（也就是说，
其必须不在@code{DWARF_FRAME_REGNUM}的范围中）。

@en This macro can be useful if @code{DWARF_FRAME_RETURN_COLUMN} is set to a
@en general register, but an alternative column needs to be used for signal
@en frames.  Some targets have also used different frame return columns
@en over time.
该宏当被设为一个通用寄存器，但是候选的column需要用于signal帧的时候会很有用。
一些target还使用了不同的帧返回列。
@end defmac

@defmac DWARF_ZERO_REG
@en A C expression whose value is an integer giving a DWARF 2 register
@en number that is considered to always have the value zero.  This should
@en only be defined if the target has an architected zero register, and
@en someone decided it was a good idea to use that register number to
@en terminate the stack backtrace.  New ports should avoid this.
一个C表达式，其值为一个整数，给出了DWARF2寄存器编号，其被认为总是具有值0。
这应该只当target的体系结构中具有一个0寄存器并且认为使用寄存器编号来确定栈的
回溯是一个好主意的时候才被定义。新的part应该避免该宏。
@end defmac

@deftypefn {Target Hook} void TARGET_DWARF_HANDLE_FRAME_UNSPEC (const char *@var{label}, rtx @var{pattern}, int @var{index})
@en This target hook allows the backend to emit frame-related insns that
@en contain UNSPECs or UNSPEC_VOLATILEs.  The DWARF 2 call frame debugging
@en info engine will invoke it on insns of the form
该target钩子允许后端生成帧相关的insn，其包含了UNSPECs或UNSPEC_VOLATILEs。
DWARF2调用帧调试信息引擎将会按照如下的形式来调用它
@smallexample
(set (reg) (unspec [@dots{}] UNSPEC_INDEX))
@end smallexample
@en and
和 
@smallexample
(set (reg) (unspec_volatile [@dots{}] UNSPECV_INDEX)).
@end smallexample
@en to let the backend emit the call frame instructions.  @var{label} is
@en the CFI label attached to the insn, @var{pattern} is the pattern of
@en the insn and @var{index} is @code{UNSPEC_INDEX} or @code{UNSPECV_INDEX}.
来使后端生成调用帧指令。@var{label}为insn附带的CFI标号，
@var{pattern}为insn的指令模式，
@var{index}为@code{UNSPEC_INDEX}或@code{UNSPECV_INDEX}。
@end deftypefn

@defmac INCOMING_FRAME_SP_OFFSET
@en A C expression whose value is an integer giving the offset, in bytes,
@en from the value of the stack pointer register to the top of the stack
@en frame at the beginning of any function, before the prologue.  The top of
@en the frame is defined to be the value of the stack pointer in the
@en previous frame, just before the call instruction.
一个C表达式，其值为一个整数，给出了偏移字节数，
从栈指针寄存器到任何函数的起始处，序言之前的栈帧的顶部。
帧的顶部被定义为之前帧的栈指针的值，就在call指令之前。

@en You only need to define this macro if you want to support call frame
@en debugging information like that provided by DWARF 2.
你只有当你想支持像DWARF2提供的那样的帧调试信息时才需要定义该宏。
@end defmac

@defmac ARG_POINTER_CFA_OFFSET (@var{fundecl})
@en A C expression whose value is an integer giving the offset, in bytes,
@en from the argument pointer to the canonical frame address (cfa).  The
@en final value should coincide with that calculated by
@en @code{INCOMING_FRAME_SP_OFFSET}.  Which is unfortunately not usable
@en during virtual register instantiation.
一个C表达式，其值为一个整数，给出了偏移字节数，从参数指针到规范化帧地址（cfa）。
最终的值应该与通过@code{INCOMING_FRAME_SP_OFFSET}所计算的一致。
不幸的是这在虚寄存器实例化的时候不可用。

@en The default value for this macro is
@en @code{FIRST_PARM_OFFSET (fundecl) + crtl->args.pretend_args_size},
@en which is correct for most machines; in general, the arguments are found
@en immediately before the stack frame.  Note that this is not the case on
@en some targets that save registers into the caller's frame, such as SPARC
@en and rs6000, and so such targets need to define this macro.
该宏的缺省值为@code{FIRST_PARM_OFFSET (fundecl)}，其对于大多数机器是正确的；
总的来说，参数在栈帧之前被找到。注意有些情况不是这样的，一些target将寄存器保存在调用者的帧中，像SPARC和rs6000，这样的target就不需要定义该宏。

@en You only need to define this macro if the default is incorrect, and you
@en want to support call frame debugging information like that provided by
@en DWARF 2.
你只有当缺省是不正确的时候，
以及你想支持像DWARF2提供的那样的帧调试信息时才需要定义该宏。
@end defmac

@defmac FRAME_POINTER_CFA_OFFSET (@var{fundecl})
@en If defined, a C expression whose value is an integer giving the offset
@en in bytes from the frame pointer to the canonical frame address (cfa).
@en The final value should coincide with that calculated by
@en @code{INCOMING_FRAME_SP_OFFSET}.
如果被定义，则为一个C表达式，其值为一个整数，给出了偏移字节数，
从帧指针到规范化帧地址（cfa）。
最终的值应该与通过@code{INCOMING_FRAME_SP_OFFSET}所计算的一致。

@en Normally the CFA is calculated as an offset from the argument pointer,
@en via @code{ARG_POINTER_CFA_OFFSET}, but if the argument pointer is
@en variable due to the ABI, this may not be possible.  If this macro is
@en defined, it implies that the virtual register instantiation should be
@en based on the frame pointer instead of the argument pointer.  Only one
@en of @code{FRAME_POINTER_CFA_OFFSET} and @code{ARG_POINTER_CFA_OFFSET}
@en should be defined.
通常CFA被作为参数指针的偏移量来计算，通过@code{ARG_POINTER_CFA_OFFSET}，
但是如果参数指针是一个变量，这就不太可能了。如果该宏被定义，
它暗示了虚寄存器实例化应该基于帧指针而不是参数指针。
@code{FRAME_POINTER_CFA_OFFSET}和@code{ARG_POINTER_CFA_OFFSET}只有一个应该被定义。
@end defmac

@defmac CFA_FRAME_BASE_OFFSET (@var{fundecl})
@en If defined, a C expression whose value is an integer giving the offset
@en in bytes from the canonical frame address (cfa) to the frame base used
@en in DWARF 2 debug information.  The default is zero.  A different value
@en may reduce the size of debug information on some ports.
如果定义，则为一个C表达式，其值为一个整数，给出了偏移字节数，
从规范化帧地址（cfa）到DWARF2调试信息使用的frame base。缺省为0。
不同的值可以在一些port上减少调试信息的大小。
@end defmac

@en @node Exception Handling
@en @subsection Exception Handling Support
@node Exception Handling
@subsection 对异常处理的支持
@cindex exception handling

@defmac EH_RETURN_DATA_REGNO (@var{N})
@en A C expression whose value is the @var{N}th register number used for
@en data by exception handlers, or @code{INVALID_REGNUM} if fewer than
@en @var{N} registers are usable.
一个C表达式，其值为第@var{N}个寄存器的编号，用于异常处理的数据，
或者为@code{INVALID_REGNUM}，如果小于@var{N}个寄存器可用。

@en The exception handling library routines communicate with the exception
@en handlers via a set of agreed upon registers.  Ideally these registers
@en should be call-clobbered; it is possible to use call-saved registers,
@en but may negatively impact code size.  The target must support at least
@en 2 data registers, but should define 4 if there are enough free registers.
异常处理库程序与异常处理者通过一套协定好的寄存器来通讯。理想的，
这些寄存器应该为调用破坏的；可以使用调用保存的寄存器，
但可能会对代码大小产生负影响。target必须支持至少两个数据寄存器，
但如果有足够的可用的寄存器，则应该定义为4。

@en You must define this macro if you want to support call frame exception
@en handling like that provided by DWARF 2.
你必须定义该宏，如果你想支持像DWARF 2提供的调用帧异常处理。
@end defmac

@defmac EH_RETURN_STACKADJ_RTX
@en A C expression whose value is RTL representing a location in which
@en to store a stack adjustment to be applied before function return.
@en This is used to unwind the stack to an exception handler's call frame.
@en It will be assigned zero on code paths that return normally.
一个C表达式，其值为RTL，表示一个位置，用来存储栈调整，在函数返回前应用。
这用于unwind栈到一个异常处理的调用帧中。其将被赋予0在通常的返回代码路径上。

@en Typically this is a call-clobbered hard register that is otherwise
@en untouched by the epilogue, but could also be a stack slot.
通常这是一个调用破坏的硬件寄存器，但也可以为一个栈槽。

@en Do not define this macro if the stack pointer is saved and restored
@en by the regular prolog and epilog code in the call frame itself; in
@en this case, the exception handling library routines will update the
@en stack location to be restored in place.  Otherwise, you must define
@en this macro if you want to support call frame exception handling like
@en that provided by DWARF 2.
不要定义该宏，如果栈指针在调用帧本身通过序言和尾声来保存和恢复时；
这种情况下，异常处理库函数将更新栈位置并保存。否则，你必须定义该宏，
如果你想支持调用帧异常处理，就像DWARF2提供的那样。
@end defmac

@defmac EH_RETURN_HANDLER_RTX
@en A C expression whose value is RTL representing a location in which
@en to store the address of an exception handler to which we should
@en return.  It will not be assigned on code paths that return normally.
一个C表达式，其值为一个RTL，表示一个位置，用来存储我们应该返回的异常处理的地址。
其在通常的返回的代码路径上将不被赋值。

@en Typically this is the location in the call frame at which the normal
@en return address is stored.  For targets that return by popping an
@en address off the stack, this might be a memory address just below
@en the @emph{target} call frame rather than inside the current call
@en frame.  If defined, @code{EH_RETURN_STACKADJ_RTX} will have already
@en been assigned, so it may be used to calculate the location of the
@en target call frame.
通常这是在调用帧中通常返回地址存储的位置。对于通过在栈中弹出地址的target，
这可以为一个内存地址，就在target调用帧的下面，而不是在当前调用帧中。
如果被定义，@code{EH_RETURN_STACKADJ_RTX}将已经被赋值，
所以其可以用于计算target调用帧的位置。

@en Some targets have more complex requirements than storing to an
@en address calculable during initial code generation.  In that case
@en the @code{eh_return} instruction pattern should be used instead.
一些target具有更加复杂的要求，比在初始化代码生成阶段存储到地址中。
这种情况下，要替代的使用@code{eh_return}指令模式。

@en If you want to support call frame exception handling, you must
@en define either this macro or the @code{eh_return} instruction pattern.
如果你想支持调用帧异常处理，你必须定义该宏或者@code{eh_return}指令模式。
@end defmac

@defmac RETURN_ADDR_OFFSET
@en If defined, an integer-valued C expression for which rtl will be generated
@en to add it to the exception handler address before it is searched in the
@en exception handling tables, and to subtract it again from the address before
@en using it to return to the exception handler.
如果定义，则为一个整数值的C表达式，并会为此生成rtl来加上异常处理地址，
在其在异常处理表中搜索之前，并且再减去它，在用它来返回到异常处理之前。
@end defmac

@defmac ASM_PREFERRED_EH_DATA_FORMAT (@var{code}, @var{global})
@en This macro chooses the encoding of pointers embedded in the exception
@en handling sections.  If at all possible, this should be defined such
@en that the exception handling section will not require dynamic relocations,
@en and so may be read-only.
该宏选择在异常处理section中嵌入的指针的解码。如果尽可能，该宏应该被定义，
这样异常处理section将不会要求进行动态重定位，并可以为只读的。

@en @var{code} is 0 for data, 1 for code labels, 2 for function pointers.
@en @var{global} is true if the symbol may be affected by dynamic relocations.
@en The macro should return a combination of the @code{DW_EH_PE_*} defines
@en as found in @file{dwarf2.h}.
@var{code}为0，对于数据，1对于代码标号，2对于函数指针。
@var{global}为真，如果符号可以由动态重定位影响。
宏应该返回在@file{dwarf2.h}中可以找到的@code{DW_EH_PE_*}的组合。

@en If this macro is not defined, pointers will not be encoded but
@en represented directly.
如果该宏没有定义，则指针将不被解码，而是直接表示。
@end defmac

@defmac ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX (@var{file}, @var{encoding}, @var{size}, @var{addr}, @var{done})
@en This macro allows the target to emit whatever special magic is required
@en to represent the encoding chosen by @code{ASM_PREFERRED_EH_DATA_FORMAT}.
@en Generic code takes care of pc-relative and indirect encodings; this must
@en be defined if the target uses text-relative or data-relative encodings.
该宏允许target生成特定的magic，
用于表示@code{ASM_PREFERRED_EH_DATA_FORMAT}选择的encoding。
通常代码考虑pc-relative和indirect解码；
如果target使用text-relative或者data-relative解码，则必须定义该宏。

@en This is a C statement that branches to @var{done} if the format was
@en handled.  @var{encoding} is the format chosen, @var{size} is the number
@en of bytes that the format occupies, @var{addr} is the @code{SYMBOL_REF}
@en to be emitted.
这是一个C语句，如果格式被处理，则执行分支跳转。@var{encoding}为选择的格式，
@var{size}为格式占用的字节数，@var{addr}为生成的@code{SYMBOL_REF}。
@end defmac

@defmac MD_UNWIND_SUPPORT
@en A string specifying a file to be #include'd in unwind-dw2.c.  The file
@en so included typically defines @code{MD_FALLBACK_FRAME_STATE_FOR}.
一个字符串，指定了文件在unwind-dw2.c中被#include包含进来。
被包含进来的文件通常定义了@code{MD_FALLBACK_FRAME_STATE_FOR}。
@end defmac

@defmac MD_FALLBACK_FRAME_STATE_FOR (@var{context}, @var{fs})
@en This macro allows the target to add CPU and operating system specific
@en code to the call-frame unwinder for use when there is no unwind data
@en available.  The most common reason to implement this macro is to unwind
@en through signal frames.
该宏允许target增加CPU和操作系统特定代码到call-frame unwinder，
用于当没有unwind数据可用时。最常见的原因是实现该宏来通过signal帧来unwind。

@en This macro is called from @code{uw_frame_state_for} in
@en @file{unwind-dw2.c}, @file{unwind-dw2-xtensa.c} and
@en @file{unwind-ia64.c}.  @var{context} is an @code{_Unwind_Context};
@en @var{fs} is an @code{_Unwind_FrameState}.  Examine @code{context->ra}
@en for the address of the code being executed and @code{context->cfa} for
@en the stack pointer value.  If the frame can be decoded, the register
@en save addresses should be updated in @var{fs} and the macro should
@en evaluate to @code{_URC_NO_REASON}.  If the frame cannot be decoded,
@en the macro should evaluate to @code{_URC_END_OF_STACK}.
该宏由@file{unwind-dw2.c}, @file{unwind-dw2-xtensa.c}和@file{unwind-ia64.c}中的
@code{uw_frame_state_for}调用。@var{context}为一个@code{_Unwind_Context}；
@var{fs}为一个@code{_Unwind_FrameState}。检查@code{context->ra}来得到被执行的
代码的地址，检查@code{context->cfa}来得到栈指针的值。如果帧可以被解码，
则寄存器保存地址应该在@var{fs}中更新，并且宏应该求值为@code{_URC_NO_REASON}。
如果帧不能被解码，则宏应该求解为@code{_URC_END_OF_STACK}。

@en For proper signal handling in Java this macro is accompanied by
@en @code{MAKE_THROW_FRAME}, defined in @file{libjava/include/*-signal.h} headers.
对于java中合适的信号处理，该宏通过@code{MAKE_THROW_FRAME}来应用，
在@file{libjava/include/*-signal.h}中定义。
@end defmac

@defmac MD_HANDLE_UNWABI (@var{context}, @var{fs})
@en This macro allows the target to add operating system specific code to the
@en call-frame unwinder to handle the IA-64 @code{.unwabi} unwinding directive,
@en usually used for signal or interrupt frames.
该宏允许target增加操作系统特定的代码到调用帧unwinder，
来处理IA-64 @code{.unwabi} unwinding伪指令，通常用于signal或者interrrupt帧。

@en This macro is called from @code{uw_update_context} in @file{unwind-ia64.c}.
@en @var{context} is an @code{_Unwind_Context};
@en @var{fs} is an @code{_Unwind_FrameState}.  Examine @code{fs->unwabi}
@en for the abi and context in the @code{.unwabi} directive.  If the
@en @code{.unwabi} directive can be handled, the register save addresses should
@en be updated in @var{fs}.
该宏由@file{unwind-ia64.c}中的@code{uw_update_context}调用。
@var{context}为一个@code{_Unwind_Context}；
@var{fs}为一个@code{_Unwind_FrameState}。检查@code{fs->unwabi}来得到abi。
如果@code{.unwabi}伪指令可以被处理，则寄存器保存地址应该在@var{fs}中更新。
@end defmac

@defmac TARGET_USES_WEAK_UNWIND_INFO
@en A C expression that evaluates to true if the target requires unwind
@en info to be given comdat linkage.  Define it to be @code{1} if comdat
@en linkage is necessary.  The default is @code{0}.
一个C表达式，计算为真，如果target需要unwind info给定comdat linkage。
定义其为@code{1}，如果comdat linkage有必要。缺省为@code{0}。
@end defmac

@en @node Stack Checking
@en @subsection Specifying How Stack Checking is Done
@node Stack Checking
@subsection 指定如何进行栈检查

@en GCC will check that stack references are within the boundaries of the
@en stack, if the option @option{-fstack-check} is specified, in one of
@en three ways:
GCC将检查栈引用是否位于栈的边界里，如果指定了@option{-fstack-check}，
使用三种方式的之一：

@enumerate
@item
@en If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC
@en will assume that you have arranged for full stack checking to be done
@en at appropriate places in the configuration files.  GCC will not do
@en other special processing.
如果@code{STACK_CHECK_BUILTIN}宏的值为非0，
则GCC将假设你已经安排了在配置文件的合适的地方进行栈检查，例如，
在TARGET_ASM_FUNCTION_PROLOGUE中。GCC将不再做其它特殊的处理。

@item
If @code{STACK_CHECK_BUILTIN} is zero and the value of the
@code{STACK_CHECK_STATIC_BUILTIN} macro is nonzero, GCC will assume
that you have arranged for static stack checking (checking of the
static stack frame of functions) to be done at appropriate places
in the configuration files.  GCC will only emit code to do dynamic
stack checking (checking on dynamic stack allocations) using the third
approach below.

@item
@en If neither of the above are true, GCC will generate code to periodically
@en ``probe'' the stack pointer using the values of the macros defined below.
如果上面两种方式都不是，则GCC将生成代码来周期的“探测”栈指针，
使用下面定义的宏的值。
@end enumerate

If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is defined,
GCC will change its allocation strategy for large objects if the option
@option{-fstack-check} is specified: they will always be allocated
dynamically if their size exceeds @code{STACK_CHECK_MAX_VAR_SIZE} bytes.

@defmac STACK_CHECK_BUILTIN
A nonzero value if stack checking is done by the configuration files in a
machine-dependent manner.  You should define this macro if stack checking
is required by the ABI of your machine or if you would like to do stack
checking in some more efficient way than the generic approach.  The default
value of this macro is zero.
一个非0值，如果栈检查按照机器相关的方式通过配置文件来完成。
你应该定义该宏，如果栈检查被你的机器的ABI要求，
或者你想让栈检查使用比GCC可移植方式更有效的方法。该宏的缺省值为0。
@end defmac

@defmac STACK_CHECK_STATIC_BUILTIN
A nonzero value if static stack checking is done by the configuration files
in a machine-dependent manner.  You should define this macro if you would
like to do static stack checking in some more efficient way than the generic
approach.  The default value of this macro is zero.
@end defmac

@defmac STACK_CHECK_PROBE_INTERVAL_EXP
An integer specifying the interval at which GCC must generate stack probe
instructions, defined as 2 raised to this integer.  You will normally
define this macro so that the interval be no larger than the size of
the ``guard pages'' at the end of a stack area.  The default value
of 12 (4096-byte interval) is suitable for most systems.
@end defmac

@defmac STACK_CHECK_MOVING_SP
An integer which is nonzero if GCC should move the stack pointer page by page
when doing probes.  This can be necessary on systems where the stack pointer
contains the bottom address of the memory area accessible to the executing
thread at any point in time.  In this situation an alternate signal stack
is required in order to be able to recover from a stack overflow.  The
default value of this macro is zero.
@end defmac

@defmac STACK_CHECK_PROTECT
The number of bytes of stack needed to recover from a stack overflow, for
languages where such a recovery is supported.  The default value of 75 words
with the @code{setjmp}/@code{longjmp}-based exception handling mechanism and
8192 bytes with other exception handling mechanisms should be adequate for
most machines.
@end defmac

The following macros are relevant only if neither STACK_CHECK_BUILTIN
nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether
in the opposite case.

@defmac STACK_CHECK_MAX_FRAME_SIZE
@en The maximum size of a stack frame, in bytes.  GCC will generate probe
@en instructions in non-leaf functions to ensure at least this many bytes of
@en stack are available.  If a stack frame is larger than this size, stack
@en checking will not be reliable and GCC will issue a warning.  The
@en default is chosen so that GCC only generates one instruction on most
@en systems.  You should normally not change the default value of this macro.
一个栈帧的最大大小，以字节为单位。
GCC将生成探测指令在非叶子函数来确保栈中至少这么多大小的字节是可用的。
如果一个栈帧大于该大小，则栈检查将不可靠并且GCC将产生一个警告。缺省值被选择，
使得GCC只生成一条指令，在大多数系统上。你通常不应该修改该宏的缺省值。
@end defmac

@defmac STACK_CHECK_FIXED_FRAME_SIZE
@en GCC uses this value to generate the above warning message.  It
@en represents the amount of fixed frame used by a function, not including
@en space for any callee-saved registers, temporaries and user variables.
@en You need only specify an upper bound for this amount and will normally
@en use the default of four words.
GCC使用该值来生成上面的警告消息。其表示函数使用的固定的帧数量，
不包括用于任何被调用者保存的寄存器，临时变量和用户变量的空间。
你只需要指定该数量的上界并且通常使用缺省值，4个字。
@end defmac

@defmac STACK_CHECK_MAX_VAR_SIZE
@en The maximum size, in bytes, of an object that GCC will place in the
@en fixed area of the stack frame when the user specifies
@en @option{-fstack-check}.
@en GCC computed the default from the values of the above macros and you will
@en normally not need to override that default.
为当用户指定@option{-fstack-check}时，GCC将在栈帧的固定域放入的对象的最大大小，
以字节为单位。GCC根据上面的宏来计算缺省值并且你通常不需要覆盖缺省值。
@end defmac

@need 2000
@en @node Frame Registers
@en @subsection Registers That Address the Stack Frame
@node Frame Registers
@subsection 用于栈帧寻址的寄存器

@c prevent bad page break with this line
@en This discusses registers that address the stack frame.
这里讨论了用于栈帧寻址的寄存器。

@defmac STACK_POINTER_REGNUM
@en The register number of the stack pointer register, which must also be a
@en fixed register according to @code{FIXED_REGISTERS}.  On most machines,
@en the hardware determines which register this is.
栈指针寄存器的寄存器编号，其还必须为一个@code{FIXED_REGISTERS}中的固定寄存器。
在大多数机器上，硬件决定了这是哪个寄存器。
@end defmac

@defmac FRAME_POINTER_REGNUM
@en The register number of the frame pointer register, which is used to
@en access automatic variables in the stack frame.  On some machines, the
@en hardware determines which register this is.  On other machines, you can
@en choose any register you wish for this purpose.
帧指针寄存器的寄存器编号，其用于访问在栈帧中的自动变量。
在一些机器上，硬件决定了这是哪个寄存器。
在其它机器上，你可以选择任意寄存器来达到该目的。
@end defmac

@defmac HARD_FRAME_POINTER_REGNUM
@en On some machines the offset between the frame pointer and starting
@en offset of the automatic variables is not known until after register
@en allocation has been done (for example, because the saved registers are
@en between these two locations).  On those machines, define
@en @code{FRAME_POINTER_REGNUM} the number of a special, fixed register to
@en be used internally until the offset is known, and define
@en @code{HARD_FRAME_POINTER_REGNUM} to be the actual hard register number
@en used for the frame pointer.
在一些机器上，帧指针和自动变量的起始处之间的偏移量直到寄存器分配进行完之后才知道
（例如，因为保存寄存器位于这两个位置之间）。这些机器上，
定义@code{FRAME_POINTER_REGNUM}为一个特定的固定寄存器的编号，在内部使用，
直到位移已知，并且定义@code{HARD_FRAME_POINTER_REGNUM}为实际的硬件寄存器，
用于帧指针。

@en You should define this macro only in the very rare circumstances when it
@en is not possible to calculate the offset between the frame pointer and
@en the automatic variables until after register allocation has been
@en completed.  When this macro is defined, you must also indicate in your
@en definition of @code{ELIMINABLE_REGS} how to eliminate
@en @code{FRAME_POINTER_REGNUM} into either @code{HARD_FRAME_POINTER_REGNUM}
@en or @code{STACK_POINTER_REGNUM}.
你只需要在非常少见的情况下定义该宏，当不可能计算帧指针和自动变量的偏移时，
并且直到寄存器分配完成。当该宏被定义，
你必须还要在你的@code{ELIMINABLE_REGS}的定义中指示如果消除
@code{FRAME_POINTER_REGNUM}为@code{HARD_FRAME_POINTER_REGNUM}或者
@code{STACK_POINTER_REGNUM}。

@en Do not define this macro if it would be the same as
@en @code{FRAME_POINTER_REGNUM}.
如果其与@code{FRAME_POINTER_REGNUM}相同，则不要定义该宏。
@end defmac

@defmac ARG_POINTER_REGNUM
@en The register number of the arg pointer register, which is used to access
@en the function's argument list.  On some machines, this is the same as the
@en frame pointer register.  On some machines, the hardware determines which
@en register this is.  On other machines, you can choose any register you
@en wish for this purpose.  If this is not the same register as the frame
@en pointer register, then you must mark it as a fixed register according to
@en @code{FIXED_REGISTERS}, or arrange to be able to eliminate it
@en (@pxref{Elimination}).
arg指针寄存器的寄存器编号，其用于访问函数的参数列表。在大多数机器上，
这与帧指针寄存器相同。在一些机器上，硬件决定了其为那个寄存器。在其它机器上，
你可以选择任意的寄存器。如果这与帧指针寄存器不同，
则你必须标记其为一个固定寄存器，
根据@code{FIXED_REGISTERS}或者设法能够消除它(@pxref{Elimination})。
@end defmac

@defmac HARD_FRAME_POINTER_IS_FRAME_POINTER
Define this to a preprocessor constant that is nonzero if
@code{hard_frame_pointer_rtx} and @code{frame_pointer_rtx} should be
the same.  The default definition is @samp{(HARD_FRAME_POINTER_REGNUM
== FRAME_POINTER_REGNUM)}; you only need to define this macro if that
definition is not suitable for use in preprocessor conditionals.
@end defmac

@defmac HARD_FRAME_POINTER_IS_ARG_POINTER
Define this to a preprocessor constant that is nonzero if
@code{hard_frame_pointer_rtx} and @code{arg_pointer_rtx} should be the
same.  The default definition is @samp{(HARD_FRAME_POINTER_REGNUM ==
ARG_POINTER_REGNUM)}; you only need to define this macro if that
definition is not suitable for use in preprocessor conditionals.
@end defmac

@defmac RETURN_ADDRESS_POINTER_REGNUM
@en The register number of the return address pointer register, which is used to
@en access the current function's return address from the stack.  On some
@en machines, the return address is not at a fixed offset from the frame
@en pointer or stack pointer or argument pointer.  This register can be defined
@en to point to the return address on the stack, and then be converted by
@en @code{ELIMINABLE_REGS} into either the frame pointer or stack pointer.
返回地址指针寄存器的寄存器编号，其用于访问栈中当前函数的返回地址。
在一些机器上，返回地址不在帧指针或栈指针或参数指针的固定偏移处。
该寄存器被定义指向栈中的返回地址，
并且然后通过@code{ELIMINABLE_REGS}转换为帧指针或者栈指针。

@en Do not define this macro unless there is no other way to get the return
@en address from the stack.
不要定义该宏，除非没有其他的方式从栈中获得返回地址。
@end defmac

@defmac STATIC_CHAIN_REGNUM
@defmacx STATIC_CHAIN_INCOMING_REGNUM
@en Register numbers used for passing a function's static chain pointer.  If
@en register windows are used, the register number as seen by the called
@en function is @code{STATIC_CHAIN_INCOMING_REGNUM}, while the register
@en number as seen by the calling function is @code{STATIC_CHAIN_REGNUM}.  If
@en these registers are the same, @code{STATIC_CHAIN_INCOMING_REGNUM} need
@en not be defined.
用于传递函数static链指针的寄存器编号。如果寄存器窗口被使用，
则寄存器编号由被调用函数所看到是@code{STATIC_CHAIN_INCOMING_REGNUM}，
而由调用者函数看到的是@code{STATIC_CHAIN_REGNUM}。如果这些寄存器是相同的，
则不需要定义@code{STATIC_CHAIN_INCOMING_REGNUM}。

@en The static chain register need not be a fixed register.
静态链寄存器不需要为一个固定寄存器。

@en If the static chain is passed in memory, these macros should not be
@en defined; instead, the @code{TARGET_STATIC_CHAIN} hook should be used.
如果静态链在内存中传递，则这些宏不需要定义；替代的，应该定义下面的两个宏。
@end defmac

@deftypefn {Target Hook} rtx TARGET_STATIC_CHAIN (const_tree @var{fndecl}, bool @var{incoming_p})
This hook replaces the use of @code{STATIC_CHAIN_REGNUM} et al for
targets that may use different static chain locations for different
nested functions.  This may be required if the target has function
attributes that affect the calling conventions of the function and
those calling conventions use different static chain locations.

The default version of this hook uses @code{STATIC_CHAIN_REGNUM} et al.

If the static chain is passed in memory, this hook should be used to
provide rtx giving @code{mem} expressions that denote where they are stored.
Often the @code{mem} expression as seen by the caller will be at an offset
from the stack pointer and the @code{mem} expression as seen by the callee
will be at an offset from the frame pointer.
@findex stack_pointer_rtx
@findex frame_pointer_rtx
@findex arg_pointer_rtx
@en The variables @code{stack_pointer_rtx}, @code{frame_pointer_rtx}, and
@en @code{arg_pointer_rtx} will have been initialized and should be used
@en to refer to those items.
变量@code{stack_pointer_rtx}, @code{frame_pointer_rtx}和@code{arg_pointer_rtx}将在使用这些宏之前被初始化，并可以引用。
@end deftypefn

@defmac DWARF_FRAME_REGISTERS
@en This macro specifies the maximum number of hard registers that can be
@en saved in a call frame.  This is used to size data structures used in
@en DWARF2 exception handling.
该宏指定了可以在一个调用帧中被保存的硬件寄存器的最大数。
这用于DWARF2异常处理中的size数据结构体。

@en Prior to GCC 3.0, this macro was needed in order to establish a stable
@en exception handling ABI in the face of adding new hard registers for ISA
@en extensions.  In GCC 3.0 and later, the EH ABI is insulated from changes
@en in the number of hard registers.  Nevertheless, this macro can still be
@en used to reduce the runtime memory requirements of the exception handling
@en routines, which can be substantial if the ISA contains a lot of
@en registers that are not call-saved.
在GCC3.0之前，该宏需要用来建立一个稳定的异常处理ABI。

@en If this macro is not defined, it defaults to
@en @code{FIRST_PSEUDO_REGISTER}.
如果该宏没有被定义，其缺省为@code{FIRST_PSEUDO_REGISTER}。
@end defmac

@defmac PRE_GCC3_DWARF_FRAME_REGISTERS
@en This macro is similar to @code{DWARF_FRAME_REGISTERS}, but is provided
@en for backward compatibility in pre GCC 3.0 compiled code.
该宏类似于@code{DWARF_FRAME_REGISTERS}，是为了向后兼容在GCC3.0之前编译的代码而提供。

@en If this macro is not defined, it defaults to
@en @code{DWARF_FRAME_REGISTERS}.
如果没有定义该宏，其缺省为@code{DWARF_FRAME_REGISTERS}。
@end defmac

@defmac DWARF_REG_TO_UNWIND_COLUMN (@var{regno})
@en Define this macro if the target's representation for dwarf registers
@en is different than the internal representation for unwind column.
@en Given a dwarf register, this macro should return the internal unwind
@en column number to use instead.
定义该宏，如果target对于dwarf寄存器的表示与对于unwind column的内部表示不相同。
给定一个dwarf寄存器，该宏应该返回替代使用的内部unwind column编号。

@en See the PowerPC's SPE target for an example.
例子参见PowerPC's SPE target。
@end defmac

@defmac DWARF_FRAME_REGNUM (@var{regno})
@en Define this macro if the target's representation for dwarf registers
@en used in .eh_frame or .debug_frame is different from that used in other
@en debug info sections.  Given a GCC hard register number, this macro
@en should return the .eh_frame register number.  The default is
@en @code{DBX_REGISTER_NUMBER (@var{regno})}.
定义该宏，如果target对于用在.eh_frame或者.debug_frame的dwarf寄存器的表示与用在
其它调试信息section中的不同。给定一个GCC硬件寄存器编号，该宏应该返回.eh_frame
寄存器编号。缺省为@code{DBX_REGISTER_NUMBER (@var{regno})}。
@end defmac

@defmac DWARF2_FRAME_REG_OUT (@var{regno}, @var{for_eh})
@en Define this macro to map register numbers held in the call frame info
@en that GCC has collected using @code{DWARF_FRAME_REGNUM} to those that
@en should be output in .debug_frame (@code{@var{for_eh}} is zero) and
@en .eh_frame (@code{@var{for_eh}} is nonzero).  The default is to
@en return @code{@var{regno}}.
定义该宏来影射在调用帧信息中存放的寄存器编号，
其为GCC使用@code{DWARF_FRAME_REGNUM}来搜集的应该放在.debug_frame
（@code{@var{for_eh}}为0）和.eh_frame（@code{@var{for_eh}}为非0）中的寄存器。
缺省为返回@code{@var{regno}}。
@end defmac

@en @node Elimination
@en @subsection Eliminating Frame Pointer and Arg Pointer
@node Elimination
@subsection 消除帧指针和参数指针

@c prevent bad page break with this line
@en This is about eliminating the frame pointer and arg pointer.
这些是关于消除帧指针和参数指针的。

@deftypefn {Target Hook} bool TARGET_FRAME_POINTER_REQUIRED (void)
This target hook should return @code{true} if a function must have and use
a frame pointer.  This target hook is called in the reload pass.  If its return
value is @code{true} the function will have a frame pointer.

This target hook can in principle examine the current function and decide
according to the facts, but on most machines the constant @code{false} or the
constant @code{true} suffices.  Use @code{false} when the machine allows code
to be generated with no frame pointer, and doing so saves some time or space.
Use @code{true} when there is no possible advantage to avoiding a frame
pointer.

In certain cases, the compiler does not know how to produce valid code
without a frame pointer.  The compiler recognizes those cases and
automatically gives the function a frame pointer regardless of what
@code{TARGET_FRAME_POINTER_REQUIRED} returns.  You don't need to worry about
them.

In a function that does not require a frame pointer, the frame pointer
register can be allocated for ordinary usage, unless you mark it as a
fixed register.  See @code{FIXED_REGISTERS} for more information.

Default return value is @code{false}.
@end deftypefn

@findex get_frame_size
@defmac INITIAL_FRAME_POINTER_OFFSET (@var{depth-var})
@en A C statement to store in the variable @var{depth-var} the difference
@en between the frame pointer and the stack pointer values immediately after
@en the function prologue.  The value would be computed from information
@en such as the result of @code{get_frame_size ()} and the tables of
@en registers @code{regs_ever_live} and @code{call_used_regs}.
一条C语句，用来紧接着函数序言之后，
将帧指针和栈指针值的差存储在@var{depth-var}中。
该值应该通过像@code{get_frame_size ()}这样的结果信息以及寄存器表
@code{regs_ever_live}和@code{call_used_regs}中被计算。

@en If @code{ELIMINABLE_REGS} is defined, this macro will be not be used and
@en need not be defined.  Otherwise, it must be defined even if
@en @code{TARGET_FRAME_POINTER_REQUIRED} always returns true; in that
@en case, you may set @var{depth-var} to anything.
如果@code{ELIMINABLE_REGS}被定义，则该宏将不被使用并不需要被定义。
否则，其必须被定义，即使@code{FRAME_POINTER_REQUIRED}被定义为总是为真；
这这种情况下，你可以设置@var{depth-var}为任何值。
@end defmac

@defmac ELIMINABLE_REGS
@en If defined, this macro specifies a table of register pairs used to
@en eliminate unneeded registers that point into the stack frame.  If it is not
@en defined, the only elimination attempted by the compiler is to replace
@en references to the frame pointer with references to the stack pointer.
如果被定义，则该宏指定了一个寄存器双对的表，用于消除不需要的指向栈帧的寄存器。
如果没有被定义，则编译器唯一尝试去做的消除是将对帧指针的引用替换为对栈指针的引用。

@en The definition of this macro is a list of structure initializations, each
@en of which specifies an original and replacement register.
该宏的定义为一个结构体初始化列表，每个指定了最初的和替换后的寄存器。

@en On some machines, the position of the argument pointer is not known until
@en the compilation is completed.  In such a case, a separate hard register
@en must be used for the argument pointer.  This register can be eliminated by
@en replacing it with either the frame pointer or the argument pointer,
@en depending on whether or not the frame pointer has been eliminated.
在一些机器上，参数指针的位置直到编译结束时才知道。这种情况下，
一个单独的硬件寄存器必须用于参数指针。
该寄存器可以通过替换为帧指针或者参数指针来消除，这取决于帧指针是否已经被消除。

@en In this case, you might specify:
这种情况下，你可能会指定：

@smallexample
#define ELIMINABLE_REGS  \
@{@{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM@}, \
 @{ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM@}, \
 @{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM@}@}
@end smallexample

@en Note that the elimination of the argument pointer with the stack pointer is
@en specified first since that is the preferred elimination.
注意首先指定的是使用栈指针来消除参数指针，因为这是首选的消除方式。
@end defmac

@deftypefn {Target Hook} bool TARGET_CAN_ELIMINATE (const int @var{from_reg}, const int @var{to_reg})
This target hook should returns @code{true} if the compiler is allowed to
try to replace register number @var{from_reg} with register number
@var{to_reg}.  This target hook need only be defined if @code{ELIMINABLE_REGS}
is defined, and will usually be @code{true}, since most of the cases
preventing register elimination are things that the compiler already
knows about.

Default return value is @code{true}.
@end deftypefn

@defmac INITIAL_ELIMINATION_OFFSET (@var{from-reg}, @var{to-reg}, @var{offset-var})
@en This macro is similar to @code{INITIAL_FRAME_POINTER_OFFSET}.  It
@en specifies the initial difference between the specified pair of
@en registers.  This macro must be defined if @code{ELIMINABLE_REGS} is
@en defined.
该宏类似于@code{INITIAL_FRAME_POINTER_OFFSET}。
其指定了被指定的寄存器双对的初始差。该宏必须被定义，
如果@code{ELIMINABLE_REGS}被定义。
@end defmac

@en @node Stack Arguments
@en @subsection Passing Function Arguments on the Stack
@node Stack Arguments
@subsection 在栈上传递函数参数
@cindex arguments on stack
@cindex stack arguments

@en The macros in this section control how arguments are passed
@en on the stack.  See the following section for other macros that
@en control passing certain arguments in registers.
该节的宏控制如何在栈上传递参数。关于控制在寄存器中传递特定参数的其它宏，
参见后续的章节。

@deftypefn {Target Hook} bool TARGET_PROMOTE_PROTOTYPES (const_tree @var{fntype})
@en This target hook returns @code{true} if an argument declared in a
@en prototype as an integral type smaller than @code{int} should actually be
@en passed as an @code{int}.  In addition to avoiding errors in certain
@en cases of mismatch, it also makes for better code on certain machines.
@en The default is to not promote prototypes.
该target钩子返回@code{true}，如果在函数原型中声明的一个参数，
为整型的并且比@code{int}小，应该作为@code{int}来传递。
除了能够避免一些不匹配的错误以外，其还能在特定机器上生成更好的代码。
缺省为不提升原型。
@end deftypefn

@defmac PUSH_ARGS
@en A C expression.  If nonzero, push insns will be used to pass
@en outgoing arguments.
@en If the target machine does not have a push instruction, set it to zero.
@en That directs GCC to use an alternate strategy: to
@en allocate the entire argument block and then store the arguments into
@en it.  When @code{PUSH_ARGS} is nonzero, @code{PUSH_ROUNDING} must be defined too.
一个C表达式。如果非0，则将使用push insn来传递输出参数。
如果target机器不具有push指令，则设置其为0。这将指示GCC使用替代的策略：
分配整个参数块然后将参数存进去。当@code{PUSH_ARGS}为非0时，
@code{PUSH_ROUNDING}也必须被定义。
@end defmac

@defmac PUSH_ARGS_REVERSED
@en A C expression.  If nonzero, function arguments will be evaluated from
@en last to first, rather than from first to last.  If this macro is not
@en defined, it defaults to @code{PUSH_ARGS} on targets where the stack
@en and args grow in opposite directions, and 0 otherwise.
一个C表达式。如果非0，则函数参数将按照从最后一个到第一个的顺序来求值，
而不是从第一个到最后一个。如果该宏没被定义，其缺省为@code{PUSH_ARGS}，
在栈和args按照相反的顺序进行增长的target上，否则为0。
@end defmac

@defmac PUSH_ROUNDING (@var{npushed})
@en A C expression that is the number of bytes actually pushed onto the
@en stack when an instruction attempts to push @var{npushed} bytes.
一个C表达式，其为当一个指令试图压入@var{npushed}个字节时，实际压入栈中的字节数。

@en On some machines, the definition
在一些机器上，定义

@smallexample
#define PUSH_ROUNDING(BYTES) (BYTES)
@end smallexample

@noindent
@en will suffice.  But on other machines, instructions that appear
@en to push one byte actually push two bytes in an attempt to maintain
@en alignment.  Then the definition should be
便可以满足。但是在其它机器上，指令压入一个字节时，
而为了保持对齐实际压入了两个字节。则定义应该为

@smallexample
#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)
@end smallexample

If the value of this macro has a type, it should be an unsigned type.
@end defmac

@findex current_function_outgoing_args_size
@defmac ACCUMULATE_OUTGOING_ARGS
@en A C expression.  If nonzero, the maximum amount of space required for outgoing arguments
@en will be computed and placed into the variable
@en @code{current_function_outgoing_args_size}.  No space will be pushed
@en onto the stack for each call; instead, the function prologue should
@en increase the stack frame size by this amount.
一个C表达式。如果非0，则为输出参数中将被计算并放进变量
@code{current_function_outgoing_args_size}所需要的空间最大数目。
对于每个调用，将不会有空间被压入栈中；替代的，函数序言应该增加栈帧的大小。

@en Setting both @code{PUSH_ARGS} and @code{ACCUMULATE_OUTGOING_ARGS}
@en is not proper.
同时设置@code{PUSH_ARGS}和@code{ACCUMULATE_OUTGOING_ARGS}是不合适的。
@end defmac

@defmac REG_PARM_STACK_SPACE (@var{fndecl})
@en Define this macro if functions should assume that stack space has been
@en allocated for arguments even when their values are passed in
@en registers.
定义该宏，如果函数应该假设参数的栈空间已经被分配，
即使它们的值是在寄存器中被传递的。

@en The value of this macro is the size, in bytes, of the area reserved for
@en arguments passed in registers for the function represented by @var{fndecl},
@en which can be zero if GCC is calling a library function.
@en The argument @var{fndecl} can be the FUNCTION_DECL, or the type itself
@en of the function.
该宏的值是一个@var{fndecl}表示的函数在寄存器中传递的参数的保留空间的大小，
字节为单位，其可以为0如果GCC在调用一个库函数。

@en This space can be allocated by the caller, or be a part of the
@en machine-dependent stack frame: @code{OUTGOING_REG_PARM_STACK_SPACE} says
@en which.
该空间可以被调用者分配，或者为机器相关的栈帧的一部分：
这由@code{OUTGOING_REG_PARM_STACK_SPACE}决定。
@end defmac
@c above is overfull.  not sure what to do.  --mew 5feb93  did
@c something, not sure if it looks good.  --mew 10feb93

@defmac OUTGOING_REG_PARM_STACK_SPACE (@var{fntype})
@en Define this to a nonzero value if it is the responsibility of the
@en caller to allocate the area reserved for arguments passed in registers
@en when calling a function of @var{fntype}.  @var{fntype} may be NULL
@en if the function called is a library function.
定义该宏为一个非0值，如果分配在寄存器中传递的参数的保留空间，是由调用者负责。

@en If @code{ACCUMULATE_OUTGOING_ARGS} is defined, this macro controls
@en whether the space for these arguments counts in the value of
@en @code{current_function_outgoing_args_size}.
如果@code{ACCUMULATE_OUTGOING_ARGS}被定义，
则该宏控制这些参数的空间是否算在@code{current_function_outgoing_args_size}中。
@end defmac

@defmac STACK_PARMS_IN_REG_PARM_AREA
@en Define this macro if @code{REG_PARM_STACK_SPACE} is defined, but the
@en stack parameters don't skip the area specified by it.
@c i changed this, makes more sens and it should have taken care of the
@c overfull.. not as specific, tho.  --mew 5feb93
定义该宏，如果@code{REG_PARM_STACK_SPACE}被定义，
但是栈参数不跳过其所指定的区域。

@en Normally, when a parameter is not passed in registers, it is placed on the
@en stack beyond the @code{REG_PARM_STACK_SPACE} area.  Defining this macro
@en suppresses this behavior and causes the parameter to be passed on the
@en stack in its natural location.
通常，当一个参数没有在寄存器中传递时，
其被放在@code{REG_PARM_STACK_SPACE}区域之外的栈上。
定义该宏来抑制这种行为并使得在栈上传递的参数按照它的自然位置。
@end defmac

@deftypefn {Target Hook} int TARGET_RETURN_POPS_ARGS (tree @var{fundecl}, tree @var{funtype}, int @var{size})
This target hook returns the number of bytes of its own arguments that
a function pops on returning, or 0 if the function pops no arguments
and the caller must therefore pop them all after the function returns.

@var{fundecl} is a C variable whose value is a tree node that describes
the function in question.  Normally it is a node of type
@code{FUNCTION_DECL} that describes the declaration of the function.
From this you can obtain the @code{DECL_ATTRIBUTES} of the function.

@var{funtype} is a C variable whose value is a tree node that
describes the function in question.  Normally it is a node of type
@code{FUNCTION_TYPE} that describes the data type of the function.
From this it is possible to obtain the data types of the value and
arguments (if known).

When a call to a library function is being considered, @var{fundecl}
will contain an identifier node for the library function.  Thus, if
you need to distinguish among various library functions, you can do so
by their names.  Note that ``library function'' in this context means
a function used to perform arithmetic, whose name is known specially
in the compiler and was not mentioned in the C code being compiled.

@var{size} is the number of bytes of arguments passed on the
stack.  If a variable number of bytes is passed, it is zero, and
argument popping will always be the responsibility of the calling function.

On the VAX, all functions always pop their arguments, so the definition
of this macro is @var{size}.  On the 68000, using the standard
calling convention, no functions pop their arguments, so the value of
the macro is always 0 in this case.  But an alternative calling
convention is available in which functions that take a fixed number of
arguments pop them but other functions (such as @code{printf}) pop
nothing (the caller pops all).  When this convention is in use,
@var{funtype} is examined to determine whether a function takes a fixed
number of arguments.
@end deftypefn

@defmac CALL_POPS_ARGS (@var{cum})
@en A C expression that should indicate the number of bytes a call sequence
@en pops off the stack.  It is added to the value of @code{RETURN_POPS_ARGS}
@en when compiling a function call.
一个C表达式，指示一个调用序列从栈中弹出的字节数目。
其被加到@code{RETURN_POPS_ARGS}的值中，当编译一个函数调用时。

@en @var{cum} is the variable in which all arguments to the called function
@en have been accumulated.
@var{cum}为一个变量，为被调用函数的所有参数的累积。

@en On certain architectures, such as the SH5, a call trampoline is used
@en that pops certain registers off the stack, depending on the arguments
@en that have been passed to the function.  Since this is a property of the
@en call site, not of the called function, @code{RETURN_POPS_ARGS} is not
@en appropriate.
在特定的体系结构上，例如SH5，一个调用蹦床被用于弹出栈上特定的寄存器，
根据被传递给函数的参数。因为这是调用方的属性，而不是被调用函数的，
所以@code{RETURN_POPS_ARGS}不太适合。
@end defmac

@en @node Register Arguments
@en @subsection Passing Arguments in Registers
@node Register Arguments
@subsection 在寄存器中传递参数
@cindex arguments in registers
@cindex registers arguments

@en This section describes the macros which let you control how various
@en types of arguments are passed in registers or how they are arranged in
@en the stack.
这节描述了让你控制不同类型的参数如何在寄存器中传递，
或者它们如何被安排在栈中的宏。

@defmac FUNCTION_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})
— Macro: FUNCTION_ARG (cum, mode, type, named)
@en A C expression that controls whether a function argument is passed
@en in a register, and which register.
一个C表达式，控制函数的参数是否在寄存器中传递，以及在那个寄存器中传递。

@en The arguments are @var{cum}, which summarizes all the previous
@en arguments; @var{mode}, the machine mode of the argument; @var{type},
@en the data type of the argument as a tree node or 0 if that is not known
@en (which happens for C support library functions); and @var{named},
@en which is 1 for an ordinary argument and 0 for nameless arguments that
@en correspond to @samp{@dots{}} in the called function's prototype.
@en @var{type} can be an incomplete type if a syntax error has previously
@en occurred.
参数为@var{cum}，其总结了所有之前的参数；@var{mode}，参数的机器模式；
@var{type}，参数的数据类型，作为一个树节点或者0如果不知道（这发生于C支持库的
函数）；@var{named}，其为1对于普通参数，0对于无名参数，
对应于在被调用函数原型中的@samp{@dots{}}。@var{type}可以为一个不完全类型，
如果之前产生了语法错误。

@en The value of the expression is usually either a @code{reg} RTX for the
@en hard register in which to pass the argument, or zero to pass the
@en argument on the stack.
表达式的值通常为一个在其中传递参数的硬件寄存器的@code{reg} RTX，或者0，
在栈上传递参数。

@en For machines like the VAX and 68000, where normally all arguments are
@en pushed, zero suffices as a definition.
对于像VAX和68000的机器，其通常所有参数被压栈，则定义为0就行。

@en The value of the expression can also be a @code{parallel} RTX@.  This is
@en used when an argument is passed in multiple locations.  The mode of the
@en @code{parallel} should be the mode of the entire argument.  The
@en @code{parallel} holds any number of @code{expr_list} pairs; each one
@en describes where part of the argument is passed.  In each
@en @code{expr_list} the first operand must be a @code{reg} RTX for the hard
@en register in which to pass this part of the argument, and the mode of the
@en register RTX indicates how large this part of the argument is.  The
@en second operand of the @code{expr_list} is a @code{const_int} which gives
@en the offset in bytes into the entire argument of where this part starts.
@en As a special exception the first @code{expr_list} in the @code{parallel}
@en RTX may have a first operand of zero.  This indicates that the entire
@en argument is also stored on the stack.
表达式的值也可以为一个@code{parallel} RTX。这用于当参数在多个位置传递的时候。
@code{parallel}的机器模式应该为整个参数的机器模式。
@code{parallel}保存了任意数目的@code{expr_list}对；
每一个描述了该部分参数在哪里传递，
@code{reg} RTX的机器模式指示了该部分的参数有多大。
@code{expr_list}的第二个操作数为一个const_int，
其给出了该部分起始处与整个参数的偏移字节数。作为一个特例，
@code{parallel} RTX中的第一个@code{expr_list}的第一个操作数可以为0。
这意味着整个参数也在栈中存储。

@en The last time this macro is called, it is called with @code{MODE ==
@en VOIDmode}, and its result is passed to the @code{call} or @code{call_value}
@en pattern as operands 2 and 3 respectively.
该宏最后一次被调用的时候，@code{MODE == VOIDmode}，
并且结果被传递给@code{call}或者@code{call_value}指令模式，分别作为其操作数2和3。

@cindex @file{stdarg.h} and register arguments
@en The usual way to make the ISO library @file{stdarg.h} work on a machine
@en where some arguments are usually passed in registers, is to cause
@en nameless arguments to be passed on the stack instead.  This is done
@en by making @code{FUNCTION_ARG} return 0 whenever @var{named} is 0.
通常使ISO库@file{stdarg.h}在一些参数在寄存器中传递的机器上工作的方法，
是使无名参数在栈上传递。这通过使@code{FUNCTION_ARG}当@var{named}为0时返回0来实现。

@en @cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{FUNCTION_ARG}
@en @cindex @code{REG_PARM_STACK_SPACE}, and @code{FUNCTION_ARG}
@en You may use the hook @code{targetm.calls.must_pass_in_stack}
@en in the definition of this macro to determine if this argument is of a
@en type that must be passed in the stack.  If @code{REG_PARM_STACK_SPACE}
@en is not defined and @code{FUNCTION_ARG} returns nonzero for such an
@en argument, the compiler will abort.  If @code{REG_PARM_STACK_SPACE} is
@en defined, the argument will be computed in the stack and then loaded into
@en a register.
你可以在该宏的定义中，使用钩子@code{targetm.calls.must_pass_in_stack}来确定该
参数是否为一个必须在栈中传递的类型。如果@code{REG_PARM_STACK_SPACE}没有定义并且
@code{FUNCTION_ARG}对于这样的参数返回非0，则编译器会abort。
如果@code{REG_PARM_STACK_SPACE}被定义，则参数会在栈中计算并且然后加载到寄存器中。
@end defmac

@deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (enum machine_mode @var{mode}, const_tree @var{type})
@en This target hook should return @code{true} if we should not pass @var{type}
@en solely in registers.  The file @file{expr.h} defines a
@en definition that is usually appropriate, refer to @file{expr.h} for additional
@en documentation.
该target钩子应该返回@code{true}，如果我们不应该只在寄存器中传递@var{type}。
文件@file{expr.h}中有一个定义，其通常是合适的，更多的文档请参考@file{expr.h}。
@end deftypefn

@defmac FUNCTION_INCOMING_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})
@en Define this macro if the target machine has ``register windows'', so
@en that the register in which a function sees an arguments is not
@en necessarily the same as the one in which the caller passed the
@en argument.
定义该宏，如果target机器具有“寄存器窗口”，
这样函数看到的参数寄存器没有必要与调用者传递参数的寄存器相同。

@en For such machines, @code{FUNCTION_ARG} computes the register in which
@en the caller passes the value, and @code{FUNCTION_INCOMING_ARG} should
@en be defined in a similar fashion to tell the function being called
@en where the arguments will arrive.
对于这样的机器，@code{FUNCTION_ARG}计算调用者传递值的寄存器，
@code{FUNCTION_INCOMING_ARG}应该按照类似的方式定义，
来告诉被调用的函数参数在哪里到来。

@en If @code{FUNCTION_INCOMING_ARG} is not defined, @code{FUNCTION_ARG}
@en serves both purposes.
如果@code{FUNCTION_INCOMING_ARG}没有定义，则@code{FUNCTION_ARG}具有这两种用途。
@end defmac

@deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})
@en This target hook returns the number of bytes at the beginning of an
@en argument that must be put in registers.  The value must be zero for
@en arguments that are passed entirely in registers or that are entirely
@en pushed on the stack.
该target钩子返回在参数的起始处必须被放入寄存器的字节数。
值必须为0对于参数全部放在寄存器中或者全部压入栈中。

@en On some machines, certain arguments must be passed partially in
@en registers and partially in memory.  On these machines, typically the
@en first few words of arguments are passed in registers, and the rest
@en on the stack.  If a multi-word argument (a @code{double} or a
@en structure) crosses that boundary, its first few words must be passed
@en in registers and the rest must be pushed.  This macro tells the
@en compiler when this occurs, and how many bytes should go in registers.
一些机器上，特定的参数必须部分在寄存器中传递并且部分在内存中传递。
在这些机器上，通常参数的起始一些字在寄存器中传递，其余的在栈上。
如果一个多字的参数（@code{double}或者结构体）跨越了边界，
则其起始的一些字必须在寄存器中传递并且剩余的被压栈。
该宏告诉编译器这种情况什么时候发生，以及多少字节应该在寄存器中。

@en @code{FUNCTION_ARG} for these arguments should return the first
@en register to be used by the caller for this argument; likewise
@en @code{FUNCTION_INCOMING_ARG}, for the called function.
@code{FUNCTION_ARG}对于这些参数应该返回第一个寄存器，被调用者用于该参数；
通常@code{FUNCTION_INCOMING_ARG}用于被调用的函数。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})
@en This target hook should return @code{true} if an argument at the
@en position indicated by @var{cum} should be passed by reference.  This
@en predicate is queried after target independent reasons for being
@en passed by reference, such as @code{TREE_ADDRESSABLE (type)}.
该target钩子应该返回@code{true}，
如果@var{cum}所指示的位置的参数应该按照引用的方式来传递。

@en If the hook returns true, a copy of that argument is made in memory and a
@en pointer to the argument is passed instead of the argument itself.
@en The pointer is passed in whatever way is appropriate for passing a pointer
@en to that type.
如果钩子返回真，则参数的副本在内存中产生并且指向参数的指针被替代参数本身来传递。
指针按照传递该类型的指针的方式来传递。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CALLEE_COPIES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})
@en The function argument described by the parameters to this hook is
@en known to be passed by reference.  The hook should return true if the
@en function argument should be copied by the callee instead of copied
@en by the caller.
由该钩子的参数所描述的函数的参数已知为通过引用来传递的。钩子应该返回真，
如果函数参数应该由被调用者复制，而不是调用者。

@en For any argument for which the hook returns true, if it can be
@en determined that the argument is not modified, then a copy need
@en not be generated.
对于任何该钩子返回真的参数，如果其可以被确定参数没有被修改，则不需要产生副本。

@en The default version of this hook always returns false.
该钩子的缺省版本总是返回假。
@end deftypefn

@defmac CUMULATIVE_ARGS
@en A C type for declaring a variable that is used as the first argument of
@en @code{FUNCTION_ARG} and other related values.  For some target machines,
@en the type @code{int} suffices and can hold the number of bytes of
@en argument so far.
一个C类型，用来声明一个变量，
被用作@code{FUNCTION_ARG}的第一个参数以及其它相关的值。对于一些target机器，
类型@code{int}可以满足并且目前可以保持参数的字节数。

@en There is no need to record in @code{CUMULATIVE_ARGS} anything about the
@en arguments that have been passed on the stack.  The compiler has other
@en variables to keep track of that.  For target machines on which all
@en arguments are passed on the stack, there is no need to store anything in
@en @code{CUMULATIVE_ARGS}; however, the data structure must exist and
@en should not be empty, so use @code{int}.
不需要在@code{CUMULATIVE_ARGS}中记录任何已经在栈中传递的参数的信息。
编译器有其它变量来记录。对于所有参数在栈上传递的target机器，
不需要在@code{CUMULATIVE_ARGS}中保存任何事物；然而，
数据结构体必须存在并且不能为空，因此可以使用@code{int}。
@end defmac

@defmac OVERRIDE_ABI_FORMAT (@var{fndecl})
If defined, this macro is called before generating any code for a
function, but after the @var{cfun} descriptor for the function has been
created.  The back end may use this macro to update @var{cfun} to
reflect an ABI other than that which would normally be used by default.
If the compiler is generating code for a compiler-generated function,
@var{fndecl} may be @code{NULL}.
@end defmac

@defmac INIT_CUMULATIVE_ARGS (@var{cum}, @var{fntype}, @var{libname}, @var{fndecl}, @var{n_named_args})
@en A C statement (sans semicolon) for initializing the variable
@en @var{cum} for the state at the beginning of the argument list.  The
@en variable has type @code{CUMULATIVE_ARGS}.  The value of @var{fntype}
@en is the tree node for the data type of the function which will receive
@en the args, or 0 if the args are to a compiler support library function.
@en For direct calls that are not libcalls, @var{fndecl} contain the
@en declaration node of the function.  @var{fndecl} is also set when
@en @code{INIT_CUMULATIVE_ARGS} is used to find arguments for the function
@en being compiled.  @var{n_named_args} is set to the number of named
@en arguments, including a structure return address if it is passed as a
@en parameter, when making a call.  When processing incoming arguments,
@en @var{n_named_args} is set to @minus{}1.
一条C语句（没有分号），用于初始化变量@var{cum}，在参数列表的起始处。
变量具有类型@code{CUMULATIVE_ARGS}。@var{fntype}的值为树节点，
为将要接受参数的函数的数据类型，或者为0如果参数是传给编译器支持库的函数。
对于直接调用，没有libcall，@var{fndecl}包含了被编译的函数。
@var{fndecl}在当@code{INIT_CUMULATIVE_ARGS}被用于查找被编译的函数的参数时，
也被设置。@var{n_named_args}被设为命名参数的个数，包括一个结构体返回地址，
如果其作为参数被传递。当处理流入参数时，@var{n_named_args}被设为-1。

@en When processing a call to a compiler support library function,
@en @var{libname} identifies which one.  It is a @code{symbol_ref} rtx which
@en contains the name of the function, as a string.  @var{libname} is 0 when
@en an ordinary C function call is being processed.  Thus, each time this
@en macro is called, either @var{libname} or @var{fntype} is nonzero, but
@en never both of them at once.
当处理对编译器支持库的函数的调用时，@var{libname}指示了为哪一个函数。
其为一个@code{symbol_ref} rtx，包含了函数的名字，作为字符串。@var{libname}为0，
当一个普通C函数被处理。因此，每次该宏被调用时，
或者@var{libname}或者@var{fntype}为非 0，但不会同时非0。
@end defmac

@defmac INIT_CUMULATIVE_LIBCALL_ARGS (@var{cum}, @var{mode}, @var{libname})
@en Like @code{INIT_CUMULATIVE_ARGS} but only used for outgoing libcalls,
@en it gets a @code{MODE} argument instead of @var{fntype}, that would be
@en @code{NULL}.  @var{indirect} would always be zero, too.  If this macro
@en is not defined, @code{INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname,
@en 0)} is used instead.
类似于@code{INIT_CUMULATIVE_ARGS}，但只用于流出的libcall，
其接受一个@code{MODE}参数而不是@var{fntype}。如果该宏没有定义，
则使用@code{INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname,0)}来替代。
@end defmac

@defmac INIT_CUMULATIVE_INCOMING_ARGS (@var{cum}, @var{fntype}, @var{libname})
@en Like @code{INIT_CUMULATIVE_ARGS} but overrides it for the purposes of
@en finding the arguments for the function being compiled.  If this macro is
@en undefined, @code{INIT_CUMULATIVE_ARGS} is used instead.
类似于@code{INIT_CUMULATIVE_ARGS}，但会覆盖其，用于查找被编译的函数的参数。
如果该宏没有被定义，则使用@code{INIT_CUMULATIVE_ARGS}来替代。

@en The value passed for @var{libname} is always 0, since library routines
@en with special calling conventions are never compiled with GCC@.  The
@en argument @var{libname} exists for symmetry with
@en @code{INIT_CUMULATIVE_ARGS}.
@c could use "this macro" in place of @code{INIT_CUMULATIVE_ARGS}, maybe.
@c --mew 5feb93   i switched the order of the sentences.  --mew 10feb93
传递给@var{libname}的值总是为0，因为库函数具有特定的调用约定，从来不被GCC编译。
参数@var{libname}的存在是为了与@code{INIT_CUMULATIVE_ARGS}对称。
@end defmac

@defmac FUNCTION_ARG_ADVANCE (@var{cum}, @var{mode}, @var{type}, @var{named})
@en A C statement (sans semicolon) to update the summarizer variable
@en @var{cum} to advance past an argument in the argument list.  The
@en values @var{mode}, @var{type} and @var{named} describe that argument.
@en Once this is done, the variable @var{cum} is suitable for analyzing
@en the @emph{following} argument with @code{FUNCTION_ARG}, etc.
一条C语句（没有分号），来更新总结变量@var{cum}来在参数列表中前进一个参数。
值@var{mode}, @var{type}和@var{named}描述了那个参数。一旦执行后，
变量@var{cum}便适合分析随后的参数。

@en This macro need not do anything if the argument in question was passed
@en on the stack.  The compiler knows how to track the amount of stack space
@en used for arguments without any special help.
该宏不需要做任何事情，如果要询问的参数是在栈中传递的。
编译器知道如何追踪用于参数的栈空间，不需要任何特殊帮助。
@end defmac


@defmac FUNCTION_ARG_OFFSET (@var{mode}, @var{type})
If defined, a C expression that is the number of bytes to add to the
offset of the argument passed in memory.  This is needed for the SPU,
which passes @code{char} and @code{short} arguments in the preferred
slot that is in the middle of the quad word instead of starting at the
top.
@end defmac

@defmac FUNCTION_ARG_PADDING (@var{mode}, @var{type})
@en If defined, a C expression which determines whether, and in which direction,
@en to pad out an argument with extra space.  The value should be of type
@en @code{enum direction}: either @code{upward} to pad above the argument,
@en @code{downward} to pad below, or @code{none} to inhibit padding.
如果被定义，则为一个C表达式，其确定是否使用额外的空间来填补参数，
以及按照什么方向。值应该为类型@code{enum direction}：或者@code{upward}，
向上填补参数，@code{downward}向下，或者@code{none}不进行填补。

@en The @emph{amount} of padding is always just enough to reach the next
@en multiple of @code{TARGET_FUNCTION_ARG_BOUNDARY}; this macro does not
@en control it.
填补的数目总是刚足够达到下一个@code{TARGET_FUNCTION_ARG_BOUNDARY}的倍数；
该宏不进行控制。

@en This macro has a default definition which is right for most systems.
@en For little-endian machines, the default is to pad upward.  For
@en big-endian machines, the default is to pad downward for an argument of
@en constant size shorter than an @code{int}, and upward otherwise.
该宏具有一个缺省定义，其对大多数系统是对的。对于小端机器，缺省为向上填补。
对于大端机器，缺省为如果参数的大小比@code{int}短则向下填补，否则向上。
@end defmac

@defmac PAD_VARARGS_DOWN
@en If defined, a C expression which determines whether the default
@en implementation of va_arg will attempt to pad down before reading the
@en next argument, if that argument is smaller than its aligned space as
@en controlled by @code{PARM_BOUNDARY}.  If this macro is not defined, all such
@en arguments are padded down if @code{BYTES_BIG_ENDIAN} is true.
如果定义，则为一个C表达式，其确定va_arg的缺省实现是否会尝试向下填补，
在读取下一个参数之前，如果那个参数比@code{PARM_BOUNDARY}所控制的对齐空间要小。
如果该宏没有定义，则所有这样的参数都被向下填补，
如果@code{BYTES_BIG_ENDIAN}为真。
@end defmac

@defmac BLOCK_REG_PADDING (@var{mode}, @var{type}, @var{first})
@en Specify padding for the last element of a block move between registers and
@en memory.  @var{first} is nonzero if this is the only element.  Defining this
@en macro allows better control of register function parameters on big-endian
@en machines, without using @code{PARALLEL} rtl.  In particular,
@en @code{MUST_PASS_IN_STACK} need not test padding and mode of types in
@en registers, as there is no longer a "wrong" part of a register;  For example,
@en a three byte aggregate may be passed in the high part of a register if so
@en required.
指定了寄存器和内存间移动的块的最后一个元素的填补。@var{first}为非0，
如果这是唯一的元素。定义该宏，允许更好的处理在大端机器上寄存器函数参数，
不使用@code{PARALLEL} rtl。特别的，
@code{MUST_PASS_IN_STACK}不需要测试填充和寄存器中的类型的机器模式，
因为在寄存器中不在有“错误的”部分；例如，
一个三字节的聚合类型可能在寄存器的高部传递，如果需要的话。
@end defmac

@defmac FUNCTION_ARG_BOUNDARY (@var{mode}, @var{type})
@en If defined, a C expression that gives the alignment boundary, in bits,
@en of an argument with the specified mode and type.  If it is not defined,
@en @code{PARM_BOUNDARY} is used for all arguments.
如果定义，为一个C表达式，其给出了指定的mode和type的参数的对齐边界位数。
如果没有定义，则@code{PARM_BOUNDARY}用于所有参数。
@end defmac

@deftypefn {Target Hook} {unsigned int} TARGET_FUNCTION_ARG_BOUNDARY (enum machine_mode @var{mode}, const_tree @var{type})
This hook returns the the alignment boundary, in bits, of an argument
with the specified mode and type.  The default hook returns
@code{PARM_BOUNDARY} for all arguments.
@end deftypefn

@defmac FUNCTION_ARG_REGNO_P (@var{regno})
@en A C expression that is nonzero if @var{regno} is the number of a hard
@en register in which function arguments are sometimes passed.  This does
@en @emph{not} include implicit arguments such as the static chain and
@en the structure-value address.  On many machines, no registers can be
@en used for this purpose since all function arguments are pushed on the
@en stack.
一个C表达式，其为非0，如果@var{regno}为硬件寄存器的编号，
函数参数有时在其中传递。这不包括隐式参数，像静态链和结构体值的地址。
在许多机器上，没有寄存器可以用于此目的，因为所有函数参数都被压到栈上。
@end defmac

@deftypefn {Target Hook} bool TARGET_SPLIT_COMPLEX_ARG (const_tree @var{type})
@en This hook should return true if parameter of type @var{type} are passed
@en as two scalar parameters.  By default, GCC will attempt to pack complex
@en arguments into the target's word size.  Some ABIs require complex arguments
@en to be split and treated as their individual components.  For example, on
@en AIX64, complex floats should be passed in a pair of floating point
@en registers, even though a complex float would fit in one 64-bit floating
@en point register.
该钩子应该返回真，如果参数@var{type}作为两个标量参数传递。缺省的，
GCC将尝试将复数参数打包成target的字大小。
一些ABI要求复数参数要被拆分开并且作为单独的部分对待。例如，在AIX64上，
复数浮点应该在一对浮点寄存器中传递，即使复数浮点可以适合一个64位的浮点寄存器。

@en The default value of this hook is @code{NULL}, which is treated as always
@en false.
该钩子的缺省值为@code{NULL}，其被最为假来对待。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_BUILD_BUILTIN_VA_LIST (void)
@en This hook returns a type node for @code{va_list} for the target.
@en The default version of the hook returns @code{void*}.
该钩子返回一个target的@code{va_list}的类型节点。缺省版本返回@code{void*}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_ENUM_VA_LIST_P (int @var{idx}, const char **@var{pname}, tree *@var{ptree})
This target hook is used in function @code{c_common_nodes_and_builtins}
to iterate through the target specific builtin types for va_list. The
variable @var{idx} is used as iterator. @var{pname} has to be a pointer
to a @code{const char *} and @var{ptree} a pointer to a @code{tree} typed
variable.
The arguments @var{pname} and @var{ptree} are used to store the result of
this macro and are set to the name of the va_list builtin type and its
internal type.
If the return value of this macro is zero, then there is no more element.
Otherwise the @var{IDX} should be increased for the next call of this
macro to iterate through all types.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_FN_ABI_VA_LIST (tree @var{fndecl})
This hook returns the va_list type of the calling convention specified by
@var{fndecl}.
The default version of this hook returns @code{va_list_type_node}.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_CANONICAL_VA_LIST_TYPE (tree @var{type})
This hook returns the va_list type of the calling convention specified by the
type of @var{type}. If @var{type} is not a valid va_list type, it returns
@code{NULL_TREE}.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_FN_ABI_VA_LIST (tree @var{fndecl})
This hook returns the va_list type of the calling convention specified by
@var{fndecl}.
The default version of this hook returns @code{va_list_type_node}.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_CANONICAL_VA_LIST_TYPE (tree @var{type})
This hook returns the va_list type of the calling convention specified by the
type of @var{type}. If @var{type} is not a valid va_list type, it returns
@code{NULL_TREE}.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree @var{valist}, tree @var{type}, gimple_seq *@var{pre_p}, gimple_seq *@var{post_p})
@en This hook performs target-specific gimplification of
@en @code{VA_ARG_EXPR}.  The first two parameters correspond to the
@en arguments to @code{va_arg}; the latter two are as in
@en @code{gimplify.c:gimplify_expr}.
该钩子执行target特定的@code{VA_ARG_EXPR}的gimplification。
前两个参数对应于@code{va_arg}的参数；后两个作为@code{gimplify.c:gimplify_expr}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VALID_POINTER_MODE (enum machine_mode @var{mode})
@en Define this to return nonzero if the port can handle pointers
@en with machine mode @var{mode}.  The default version of this
@en hook returns true for both @code{ptr_mode} and @code{Pmode}.
定义该钩子返回非0，如果port可以处理具有机器模式@var{mode}的指针。
缺省版本对于@code{ptr_mode}和@code{Pmode}都返回真。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SCALAR_MODE_SUPPORTED_P (enum machine_mode @var{mode})
@en Define this to return nonzero if the port is prepared to handle
@en insns involving scalar mode @var{mode}.  For a scalar mode to be
@en considered supported, all the basic arithmetic and comparisons
@en must work.
定义该钩子来返回非0，如果port准备好了处理涉及标量机器模式@var{mode}的insn。
对于被考虑支持的一个标量机器模式，所有的基本算术和比较都必须能工作。

@en The default version of this hook returns true for any mode
@en required to handle the basic C types (as defined by the port).
@en Included here are the double-word arithmetic supported by the
@en code in @file{optabs.c}.
缺省版本返回真，对于任何要求处理基本C类型（被port定义）的机器模式。
包括在@file{optabs.c}中的代码支持的双字算术。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VECTOR_MODE_SUPPORTED_P (enum machine_mode @var{mode})
@en Define this to return nonzero if the port is prepared to handle
@en insns involving vector mode @var{mode}.  At the very least, it
@en must have move patterns for this mode.
定义该钩子来返回非0，如果port准备好了处理涉及向量模式@var{mode}的insn。
最起码，其必须有该机器模式的move指令模式。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P (enum machine_mode @var{mode})
Define this to return nonzero for machine modes for which the port has
small register classes.  If this target hook returns nonzero for a given
@var{mode}, the compiler will try to minimize the lifetime of registers
in @var{mode}.  The hook may be called with @code{VOIDmode} as argument.
In this case, the hook is expected to return nonzero if it returns nonzero
for any mode.

On some machines, it is risky to let hard registers live across arbitrary
insns.  Typically, these machines have instructions that require values
to be in specific registers (like an accumulator), and reload will fail
if the required hard register is used for another purpose across such an
insn.

Passes before reload do not know which hard registers will be used
in an instruction, but the machine modes of the registers set or used in
the instruction are already known.  And for some machines, register
classes are small for, say, integer registers but not for floating point
registers.  For example, the AMD x86-64 architecture requires specific
registers for the legacy x86 integer instructions, but there are many
SSE registers for floating point operations.  On such targets, a good
strategy may be to return nonzero from this hook for @code{INTEGRAL_MODE_P}
machine modes but zero for the SSE register classes.

The default version of this hook retuns false for any mode.  It is always
safe to redefine this hook to return with a nonzero value.  But if you
unnecessarily define it, you will reduce the amount of optimizations
that can be performed in some cases.  If you do not define this hook
to return a nonzero value when it is required, the compiler will run out
of spill registers and print a fatal error message.
@end deftypefn

@en @node Scalar Return
@en @subsection How Scalar Function Values Are Returned
@node Scalar Return
@subsection 标量函数值如何被返回
@cindex return values in registers
@cindex values, returned by functions
@cindex scalars, returned as values

@en This section discusses the macros that control returning scalars as
@en values---values that can fit in registers.
这节讨论了控制返回标量值的宏，值可以放在寄存器中。

@deftypefn {Target Hook} rtx TARGET_FUNCTION_VALUE (const_tree @var{ret_type}, const_tree @var{fn_decl_or_type}, bool @var{outgoing})
@en Define this to return an RTX representing the place where a function
@en returns or receives a value of data type @var{ret_type}, a tree node
@en representing a data type.  @var{fn_decl_or_type} is a tree node
@en representing @code{FUNCTION_DECL} or @code{FUNCTION_TYPE} of a
@en function being called.  If @var{outgoing} is false, the hook should
@en compute the register in which the caller will see the return value.
@en Otherwise, the hook should return an RTX representing the place where
@en a function returns a value.
定义该宏返回一个RTX，用来表示函数返回或者接受数据类型为@var{ret_type}的值的
地方。@var{ret_type}为一个树节点，表示一个数据类型。 
@var{fn_decl_or_type}为一个树节点，表示被调用的函数的@code{FUNCTION_DECL}或者
@code{FUNCTION_TYPE}。如果@var{outgoing}为假，
则钩子应该计算调用者将要看到返回值的寄存器。否则，钩子应该返回一个RTX，
其表示函数在哪儿返回一个值。

@en On many machines, only @code{TYPE_MODE (@var{ret_type})} is relevant.
@en (Actually, on most machines, scalar values are returned in the same
@en place regardless of mode.)  The value of the expression is usually a
@en @code{reg} RTX for the hard register where the return value is stored.
@en The value can also be a @code{parallel} RTX, if the return value is in
@en multiple places.  See @code{FUNCTION_ARG} for an explanation of the
@en @code{parallel} form.   Note that the callee will populate every
@en location specified in the @code{parallel}, but if the first element of
@en the @code{parallel} contains the whole return value, callers will use
@en that element as the canonical location and ignore the others.  The m68k
@en port uses this type of @code{parallel} to return pointers in both
@en @samp{%a0} (the canonical location) and @samp{%d0}.
在许多机器上，只有@code{TYPE_MODE (@var{ret_type})}是相关的。
（实际上，在大多数机器上，标量值不管机器模式如何，都在同一地方返回。）
表达式的值通常为一个硬件寄存器的@code{reg} RTX，为存放返回值的地方。
该值还可以为一个@code{parallel} RTX，如果返回值在多个地方。
对于@code{parallel}形式的解释，参见@code{FUNCTION_ARG}。
m68k port使用了这种@code{parallel}类型来返回指针，
在@samp{%a0}(规范化位置) 和@samp{%d0}中。

@en If @code{TARGET_PROMOTE_FUNCTION_RETURN} returns true, you must apply
@en the same promotion rules specified in @code{PROMOTE_MODE} if
@en @var{valtype} is a scalar type.
如果@code{TARGET_PROMOTE_FUNCTION_RETURN}返回真，如果valtype为一个标量类型，
则你必须应用在@code{PROMOTE_MODE}中指定的相同的提升规则。

@en If the precise function being called is known, @var{func} is a tree
@en node (@code{FUNCTION_DECL}) for it; otherwise, @var{func} is a null
@en pointer.  This makes it possible to use a different value-returning
@en convention for specific functions when all their calls are
@en known.
如果确切的知道被调用的函数，则@var{func}为它的树节点（@code{FUNCTION_DECL}）；
否则，@var{func}为一个空指针。这是的可以使用不同的值返回约定，
对于所有调用都知道的特定的函数。

@en Some target machines have ``register windows'' so that the register in
@en which a function returns its value is not the same as the one in which
@en the caller sees the value.  For such machines, you should return
@en different RTX depending on @var{outgoing}.
一些target机器具有“寄存器窗口”，
这使得函数返回它的值所用的寄存器与调用者看到值所在的寄存器不同。
对于这样的机器，你应该返回不同的RTX，根据@var{outgoing}。

@en @code{TARGET_FUNCTION_VALUE} is not used for return values with
@en aggregate data types, because these are returned in another way.  See
@en @code{TARGET_STRUCT_VALUE_RTX} and related macros, below.
@code{TARGET_FUNCTION_VALUE}不用于返回聚合数据类型的值，
因为这些通过其它方式返回。参见下面的@code{TARGET_STRUCT_VALUE_RTX}以及相关的宏。
@end deftypefn

@defmac FUNCTION_VALUE (@var{valtype}, @var{func})
@en This macro has been deprecated.  Use @code{TARGET_FUNCTION_VALUE} for
@en a new target instead.
该宏已经不赞成被使用。对于新的target，使用@code{TARGET_FUNCTION_VALUE}来替代。
@end defmac

@defmac LIBCALL_VALUE (@var{mode})
@en A C expression to create an RTX representing the place where a library
@en function returns a value of mode @var{mode}.
一个C表达式，用来创建一个RTX，表示库函数返回模式@var{mode}的值的地方。
如果确切的知道被调用的函数，则func为它的树节点（FUNCTION_DECL）；
否则func为一个空指针。这使得可以使用不同的值返回约定，
对于所有调用都知道的特定的函数。

@en Note that ``library function'' in this context means a compiler
@en support routine, used to perform arithmetic, whose name is known
@en specially by the compiler and was not mentioned in the C code being
@en compiled.
注意“库函数”在该上下文中意味着是编译器支持的程序，用于执行算术运算，
其名字由编译器知道并且没有在被编译的C代码中提到。
@end defmac

@deftypefn {Target Hook} rtx TARGET_LIBCALL_VALUE (enum machine_mode @var{mode}, const_rtx @var{fun})
Define this hook if the back-end needs to know the name of the libcall
function in order to determine where the result should be returned.  

The mode of the result is given by @var{mode} and the name of the called
library function is given by @var{fun}.  The hook should return an RTX 
representing the place where the library function result will be returned.

If this hook is not defined, then LIBCALL_VALUE will be used.
@end deftypefn

@defmac FUNCTION_VALUE_REGNO_P (@var{regno})
A C expression that is nonzero if @var{regno} is the number of a hard
register in which the values of called function may come back.

A register whose use for returning values is limited to serving as the
second of a pair (for a value of type @code{double}, say) need not be
recognized by this macro.  So for most machines, this definition
suffices:

@smallexample
#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)
@end smallexample

If the machine has register windows, so that the caller and the called
function use different registers for the return value, this macro
should recognize only the caller's register numbers.

This macro has been deprecated.  Use @code{TARGET_FUNCTION_VALUE_REGNO_P}
for a new target instead.
@end defmac

@deftypefn {Target Hook} bool TARGET_FUNCTION_VALUE_REGNO_P (const unsigned int @var{regno})
A target hook that return @code{true} if @var{regno} is the number of a hard
register in which the values of called function may come back.

A register whose use for returning values is limited to serving as the
second of a pair (for a value of type @code{double}, say) need not be
recognized by this target hook.

If the machine has register windows, so that the caller and the called
function use different registers for the return value, this target hook
should recognize only the caller's register numbers.

If this hook is not defined, then FUNCTION_VALUE_REGNO_P will be used.
@end deftypefn

@defmac APPLY_RESULT_SIZE
Define this macro if @samp{untyped_call} and @samp{untyped_return}
need more space than is implied by @code{FUNCTION_VALUE_REGNO_P} for
saving and restoring an arbitrary return value.
@en 定义该宏，如果@samp{untyped_call}和@samp{untyped_return}需要比
@en @code{FUNCTION_VALUE_REGNO_P}用于保存和恢复一个任意返回地址所用的更多的空间。
@end defmac

@deftypefn {Target Hook} bool TARGET_RETURN_IN_MSB (const_tree @var{type})
@en This hook should return true if values of type @var{type} are returned
@en at the most significant end of a register (in other words, if they are
@en padded at the least significant end).  You can assume that @var{type}
@en is returned in a register; the caller is required to check this.
该钩子应该返回真，如果类型@var{type}的值按照在寄存器中的最高有效位返回
（换句话说，如果他们在最低有效位进行被padded）。
你可以假设该@var{type}在寄存器中被返回；调用者被要求进行该检查。

@en Note that the register provided by @code{TARGET_FUNCTION_VALUE} must
@en be able to hold the complete return value.  For example, if a 1-, 2-
@en or 3-byte structure is returned at the most significant end of a
@en 4-byte register, @code{TARGET_FUNCTION_VALUE} should provide an
@en @code{SImode} rtx.
注意@code{TARGET_FUNCTION_VALUE}提供的寄存器必须能够保存完整的返回值。
例如，如果一个1，2或者3字节的结构体被返回，按照4字节寄存器中的最高有效位的方式，
则@code{TARGET_FUNCTION_VALUE}应该提供一个@code{SImode} rtx。
@end deftypefn

@en @node Aggregate Return
@en @subsection How Large Values Are Returned
@node Aggregate Return
@subsection 如何返回大的值
@cindex aggregates as return values
@cindex large return values
@cindex returning aggregate values
@cindex structure value address

@en When a function value's mode is @code{BLKmode} (and in some other
@en cases), the value is not returned according to
@en @code{TARGET_FUNCTION_VALUE} (@pxref{Scalar Return}).  Instead, the
@en caller passes the address of a block of memory in which the value
@en should be stored.  This address is called the @dfn{structure value
@en address}.
当函数值的机器模式为@code{BLKmode}（并且在一些其它情况下），
值不根据@code{TARGET_FUNCTION_VALUE}来返回(@pxref{Scalar Return})。
替代的，调用者传递内存块的地址。
该地址被称为结构体地址（@dfn{structure value address}）。

@en This section describes how to control returning structure values in
@en memory.
这一节描述了如何控制在内存中返回结构体值。

@deftypefn {Target Hook} bool TARGET_RETURN_IN_MEMORY (const_tree @var{type}, const_tree @var{fntype})
@en This target hook should return a nonzero value to say to return the
@en function value in memory, just as large structures are always returned.
@en Here @var{type} will be the data type of the value, and @var{fntype}
@en will be the type of the function doing the returning, or @code{NULL} for
@en libcalls.
该target钩子应该返回一个非零值，来指明在内存中返回函数值，
正如返回大的结构体的方式。这里@var{type}为值的数据类型，
@var{fntype}为函数的类型，或者@code{NULL}，如果是libcall。

@en Note that values of mode @code{BLKmode} must be explicitly handled
@en by this function.  Also, the option @option{-fpcc-struct-return}
@en takes effect regardless of this macro.  On most systems, it is
@en possible to leave the hook undefined; this causes a default
@en definition to be used, whose value is the constant 1 for @code{BLKmode}
@en values, and 0 otherwise.
注意模式@code{BLKmode}的值必须被该函数显示的处理。
而且，选项@option{-fpcc-struct-return}将会其作用，
而不管该宏如何定义。在大多数系统上，可能会没有定义该钩子；
这将使用一个缺省定义，其值为常数1对于@code{BLKmode}值，其它的为0。

@en Do not use this hook to indicate that structures and unions should always
@en be returned in memory.  You should instead use @code{DEFAULT_PCC_STRUCT_RETURN}
@en to indicate this.
不要使用该宏来指示结构体和联合体应该总是在内存中返回。
你应该使用@code{DEFAULT_PCC_STRUCT_RETURN}来做这件事情。
@end deftypefn

@defmac DEFAULT_PCC_STRUCT_RETURN
@en Define this macro to be 1 if all structure and union return values must be
@en in memory.  Since this results in slower code, this should be defined
@en only if needed for compatibility with other compilers or with an ABI@.
@en If you define this macro to be 0, then the conventions used for structure
@en and union return values are decided by the @code{TARGET_RETURN_IN_MEMORY}
@en target hook.
定义该宏为1，如果所有的结构体和联合体返回值必须在内存中。
由于这将使得代码变慢，所以应该只有需要与其它编译器或者ABI兼容时才定义。
如果你定义了该宏为0，
则对于结构体和联合体返回值的约定则由@code{TARGET_RETURN_IN_MEMORY} target钩子来决定。

@en If not defined, this defaults to the value 1.
如果没有定义，将缺省为1。
@end defmac

@deftypefn {Target Hook} rtx TARGET_STRUCT_VALUE_RTX (tree @var{fndecl}, int @var{incoming})
@en This target hook should return the location of the structure value
@en address (normally a @code{mem} or @code{reg}), or 0 if the address is
@en passed as an ``invisible'' first argument.  Note that @var{fndecl} may
@en be @code{NULL}, for libcalls.  You do not need to define this target
@en hook if the address is always passed as an ``invisible'' first
@en argument.
该target钩子应该返回结构体值的地址位置（通常为@code{mem}或者@code{reg}），
或者0，如果地址作为“不可视”的第一个参数传递。
注意@var{fndecl}可以为@code{NULL}，对于libcall。
你不需要定义该target钩子，如果地址总是作为“不可视”的第一个参数传递。

@en On some architectures the place where the structure value address
@en is found by the called function is not the same place that the
@en caller put it.  This can be due to register windows, or it could
@en be because the function prologue moves it to a different place.
@en @var{incoming} is @code{1} or @code{2} when the location is needed in
@en the context of the called function, and @code{0} in the context of
@en the caller.
在一些体系结构上，
被调用函数寻找结构体值地址的地方与调用者放入的地方不相同。
这可能是由于寄存器窗口，或者函数序言将其移动到一个不同的地方。
@var{incoming}为@code{1}或者@code{2}，
当地址在被调用函数的上下文中需要，
为@code{0}如果在调用者的上下文中需要。

@en If @var{incoming} is nonzero and the address is to be found on the
@en stack, return a @code{mem} which refers to the frame pointer. If
@en @var{incoming} is @code{2}, the result is being used to fetch the
@en structure value address at the beginning of a function.  If you need
@en to emit adjusting code, you should do it at this point.
如果@var{incoming}为非0并且地址是在栈中找到，
则返回一个@code{mem}，其引用帧指针。
如果@var{incoming}为@code{2}，
则结果用于在函数的起始处获取结构体值的地址。
如果你需要输出调整代码，你应该在这里进行。
@end deftypefn

@defmac PCC_STATIC_STRUCT_RETURN
@en Define this macro if the usual system convention on the target machine
@en for returning structures and unions is for the called function to return
@en the address of a static variable containing the value.
定义该宏，如果在target机器上的通常的系统约定，
对于返回结构体和联合体，为被调用函数返回包含该值的静态变量的地址。

@en Do not define this if the usual system convention is for the caller to
@en pass an address to the subroutine.
不要定义该宏，如果通常的系统约定为调用者将地址传给子程序。

@en This macro has effect in @option{-fpcc-struct-return} mode, but it does
@en nothing when you use @option{-freg-struct-return} mode.
该宏具有@option{-fpcc-struct-return}模式下的效果，
但是当你使用@option{-freg-struct-return}模式时，其将不做任何事。
@end defmac

@deftypefn {Target Hook} {enum machine_mode} TARGET_GET_RAW_RESULT_MODE (int @var{regno})
This target hook returns the mode to be used when accessing raw return registers in @code{__builtin_return}.  Define this macro if the value in @var{reg_raw_mode} is not correct.
@end deftypefn

@deftypefn {Target Hook} {enum machine_mode} TARGET_GET_RAW_ARG_MODE (int @var{regno})
This target hook returns the mode to be used when accessing raw argument registers in @code{__builtin_apply_args}.  Define this macro if the value in @var{reg_raw_mode} is not correct.
@end deftypefn

@en @node Caller Saves
@en @subsection Caller-Saves Register Allocation
@node Caller Saves
@subsection 调用者保存的寄存器分配

@en If you enable it, GCC can save registers around function calls.  This
@en makes it possible to use call-clobbered registers to hold variables that
@en must live across calls.
如果你使用这种功能，GCC可以将寄存器保存在函数调用附近。
这使得可以使用调用破坏的（call-clobbered）寄存器来存放必须活跃于调用之间的变量。

@defmac CALLER_SAVE_PROFITABLE (@var{refs}, @var{calls})
@en A C expression to determine whether it is worthwhile to consider placing
@en a pseudo-register in a call-clobbered hard register and saving and
@en restoring it around each function call.  The expression should be 1 when
@en this is worth doing, and 0 otherwise.
一个C表达式来确定是否值得考虑将一个伪寄存器放在一个调用破坏的硬件寄存器中，
并在每个函数调用的附近进行保存和恢复。表达式应该为1，当值得去做，否则为0。

@en If you don't define this macro, a default is used which is good on most
@en machines: @code{4 * @var{calls} < @var{refs}}.
如果没有定义该宏，缺省值将被使用，
其在大多数机器上都是好的：@code{4 * @var{calls} < @var{refs}}。
@end defmac

@defmac HARD_REGNO_CALLER_SAVE_MODE (@var{regno}, @var{nregs})
@en A C expression specifying which mode is required for saving @var{nregs}
@en of a pseudo-register in call-clobbered hard register @var{regno}.  If
@en @var{regno} is unsuitable for caller save, @code{VOIDmode} should be
@en returned.  For most machines this macro need not be defined since GCC
@en will select the smallest suitable mode.
一个C表达式指定了将伪寄存器@var{nregs}保存在调用破坏的硬件寄存器@var{regno}中，
需要哪种机器模式。如果@var{regno}不适合调用者保存，则应该返回@code{VOIDmode}。
对于大多数机器，该宏不需要被定义，因为GCC将选择最小的合适的机器模式。
@end defmac

@en @node Function Entry
@en @subsection Function Entry and Exit
@node Function Entry
@subsection 函数入口和出口
@cindex function entry and exit
@cindex prologue
@cindex epilogue

@en This section describes the macros that output function entry
@en (@dfn{prologue}) and exit (@dfn{epilogue}) code.
这一章描述了输出函数入口（@dfn{prologue}）和出口（@dfn{epilogue}）代码的宏。

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_PROLOGUE (FILE *@var{file}, HOST_WIDE_INT @var{size})
@en If defined, a function that outputs the assembler code for entry to a
@en function.  The prologue is responsible for setting up the stack frame,
@en initializing the frame pointer register, saving registers that must be
@en saved, and allocating @var{size} additional bytes of storage for the
@en local variables.  @var{size} is an integer.  @var{file} is a stdio
@en stream to which the assembler code should be output.
如果被定义，则为一个函数，其为函数的入口输出汇编代码。序言负责设置栈帧，
初始化帧指针寄存器，保存必须被保存的机器，并分配保存局部变量所需要的额外字节数
@var{size}。@var{size}为一个整数。
@var{file}为汇编代码应该被输出到的一个stdio流。

@en The label for the beginning of the function need not be output by this
@en macro.  That has already been done when the macro is run.
函数起始处的标号不需要被该宏输出。其已经在该宏运行时被输出了。

@findex regs_ever_live
@en To determine which registers to save, the macro can refer to the array
@en @code{regs_ever_live}: element @var{r} is nonzero if hard register
@en @var{r} is used anywhere within the function.  This implies the function
@en prologue should save register @var{r}, provided it is not one of the
@en call-used registers.  (@code{TARGET_ASM_FUNCTION_EPILOGUE} must likewise use
@en @code{regs_ever_live}.)
要确定哪些寄存器要保存，该宏可以引用数组@code{regs_ever_live}：
元素@var{r}为非零，如果硬件寄存器@var{r}在函数某处被使用。
这意味着倘若其不是调用使用的（call-used）寄存器，
则函数序言应该保存寄存器@var{r}。
(同样@code{TARGET_ASM_FUNCTION_EPILOGUE}也必须使用@code{regs_ever_live}。)

@en On machines that have ``register windows'', the function entry code does
@en not save on the stack the registers that are in the windows, even if
@en they are supposed to be preserved by function calls; instead it takes
@en appropriate steps to ``push'' the register stack, if any non-call-used
@en registers are used in the function.
在具有“寄存器窗口”的机器上，函数入口代码不在栈中保存位于窗口中的寄存器，
即使它们认为被函数调用保留；替代的，如果在函数中使用了任何非调用使用的寄存器，
其使用适当的步骤来“压入”寄存器栈中。

@findex frame_pointer_needed
@en On machines where functions may or may not have frame-pointers, the
@en function entry code must vary accordingly; it must set up the frame
@en pointer if one is wanted, and not otherwise.  To determine whether a
@en frame pointer is in wanted, the macro can refer to the variable
@en @code{frame_pointer_needed}.  The variable's value will be 1 at run
@en time in a function that needs a frame pointer.  @xref{Elimination}.
在一些机器上，函数可以有帧指针，也可以没有，则函数入口代码必须相应的有所不同；
如果需要则其必须建立帧指针，否则不建立。要确定是否想要帧指针，
宏可以引用变量@code{frame_pointer_needed}。在运行时，如果函数需要帧指针，
则变量的值将被设为1。@xref{Elimination}。

@en The function entry code is responsible for allocating any stack space
@en required for the function.  This stack space consists of the regions
@en listed below.  In most cases, these regions are allocated in the
@en order listed, with the last listed region closest to the top of the
@en stack (the lowest address if @code{STACK_GROWS_DOWNWARD} is defined, and
@en the highest address if it is not defined).  You can use a different order
@en for a machine if doing so is more convenient or required for
@en compatibility reasons.  Except in cases where required by standard
@en or by a debugger, there is no reason why the stack layout used by GCC
@en need agree with that used by other compilers for a machine.
函数入口代码负责分配函数需要的任何栈空间。该栈空间包括下面列出的域。
大多数情况下，这些域按照列出的顺序被分配，最后列出的域最靠近栈顶
（如果@code{STACK_GROWS_DOWNWARD}被定义，则为最低地址，如果没有定义，
则为最高地址）。你可以为一个机器使用不同的顺序，
如果这样做更加方便或者出于兼容的原因。除了由于标准或者调试器的要求之外，
没有理由GCC使用的栈布局需要适合机器上的其它编译器所使用的。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_END_PROLOGUE (FILE *@var{file})
@en If defined, a function that outputs assembler code at the end of a
@en prologue.  This should be used when the function prologue is being
@en emitted as RTL, and you have some extra assembler that needs to be
@en emitted.  @xref{prologue instruction pattern}.
如果被定义，则为一个函数，在序言的结尾处输出汇编代码。
这应该被用于当函数序言作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“序言指令模式”
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_BEGIN_EPILOGUE (FILE *@var{file})
@en If defined, a function that outputs assembler code at the start of an
@en epilogue.  This should be used when the function epilogue is being
@en emitted as RTL, and you have some extra assembler that needs to be
@en emitted.  @xref{epilogue instruction pattern}.
如果被定义，则为一个函数，在尾声的起始处输出汇编代码。
这应该被用于当函数尾声作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“尾声指令模式”
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_EPILOGUE (FILE *@var{file}, HOST_WIDE_INT @var{size})
@en If defined, a function that outputs the assembler code for exit from a
@en function.  The epilogue is responsible for restoring the saved
@en registers and stack pointer to their values when the function was
@en called, and returning control to the caller.  This macro takes the
@en same arguments as the macro @code{TARGET_ASM_FUNCTION_PROLOGUE}, and the
@en registers to restore are determined from @code{regs_ever_live} and
@en @code{CALL_USED_REGISTERS} in the same way.
如果被定义，则为一个函数，其为函数的退出输出汇编代码。
尾声负责恢复保存的寄存器和栈指针为函数被调用时的值，并将控制返回给调用者。
该宏接受跟@code{TARGET_ASM_FUNCTION_PROLOGUE}相同的参数，
并且要恢复的寄存器按照相同的方式通过@code{regs_ever_live}和
@code{CALL_USED_REGISTERS}来确定。

@en On some machines, there is a single instruction that does all the work
@en of returning from the function.  On these machines, give that
@en instruction the name @samp{return} and do not define the macro
@en @code{TARGET_ASM_FUNCTION_EPILOGUE} at all.
在一些机器上，有一个单独的指令，可以做从函数中返回的所有工作。
在这些机器上，给出那个名为@samp{return}的指令，
并且不要定义宏@code{TARGET_ASM_FUNCTION_EPILOGUE}。

@en Do not define a pattern named @samp{return} if you want the
@en @code{TARGET_ASM_FUNCTION_EPILOGUE} to be used.  If you want the target
@en switches to control whether return instructions or epilogues are used,
@en define a @samp{return} pattern with a validity condition that tests the
@en target switches appropriately.  If the @samp{return} pattern's validity
@en condition is false, epilogues will be used.
如果你想使用@code{TARGET_ASM_FUNCTION_EPILOGUE}，
则不要定义名为@samp{return}的指令模式。
如果你想target切换使用return指令或者尾声，则定义一个@samp{return}指令模式，
带有一个有效性条件用来测试target的适当的切换。
如果@samp{return}指令模式的有效性条件为假，则使用尾声。

@en On machines where functions may or may not have frame-pointers, the
@en function exit code must vary accordingly.  Sometimes the code for these
@en two cases is completely different.  To determine whether a frame pointer
@en is wanted, the macro can refer to the variable
@en @code{frame_pointer_needed}.  The variable's value will be 1 when compiling
@en a function that needs a frame pointer.
在一些机器上，函数可以有帧指针，也可以没有，则函数的退出代码必须相应有所不同。
有时这两种情况的代码会完全不同。要确定是否需要帧指针，
该宏可以引用变量@code{frame_pointer_needed}。当编译一个需要帧指针的函数时，
变量的值将为1。

@en Normally, @code{TARGET_ASM_FUNCTION_PROLOGUE} and
@en @code{TARGET_ASM_FUNCTION_EPILOGUE} must treat leaf functions specially.
@en The C variable @code{current_function_is_leaf} is nonzero for such a
@en function.  @xref{Leaf Functions}.
通常，@code{TARGET_ASM_FUNCTION_PROLOGUE}和@code{TARGET_ASM_FUNCTION_EPILOGUE}
必须单独处理叶子函数。对于这样的函数，C变量@code{current_function_is_leaf}为
非零。@xref{Leaf Functions}。

@en On some machines, some functions pop their arguments on exit while
@en others leave that for the caller to do.  For example, the 68020 when
@en given @option{-mrtd} pops arguments in functions that take a fixed
@en number of arguments.
在一些机器上，一些函数在退出时弹出它们的参数，而其它的则将它们留给调用者来完成。
例如，68020当给定@option{-mrtd}时会弹出具有固定参数个数的函数的参数。

@findex current_function_pops_args
@en Your definition of the macro @code{RETURN_POPS_ARGS} decides which
@en functions pop their own arguments.  @code{TARGET_ASM_FUNCTION_EPILOGUE}
@en needs to know what was decided.  The number of bytes of the current
@en function's arguments that this function should pop is available in
@en @code{crtl->args.pops_args}.  @xref{Scalar Return}.
你对宏的定义决定了哪些函数弹出它们的自己的参数。
@code{TARGET_ASM_FUNCTION_EPILOGUE}需要知道这些。
称作@code{current_function_pops_args}的变量为函数应该弹出的参数的字节个数。
@xref{Scalar Return}。
@end deftypefn

@itemize @bullet
@item
@findex current_function_pretend_args_size
@en A region of @code{current_function_pretend_args_size} bytes of
@en uninitialized space just underneath the first argument arriving on the
@en stack.  (This may not be at the very start of the allocated stack region
@en if the calling sequence has pushed anything else since pushing the stack
@en arguments.  But usually, on such machines, nothing else has been pushed
@en yet, because the function prologue itself does all the pushing.)  This
@en region is used on machines where an argument may be passed partly in
@en registers and partly in memory, and, in some cases to support the
@en features in @code{<stdarg.h>}.
@code{current_function_pretend_args_size}个字节大小的未初始化空间位于栈中第一个
参数的下面。（这可能不是被分配的栈域的最起始处，如果调用序列在压入栈参数时还压入
了其它东西。通常，在这样的机器上，并没有压入其它东西，因为函数序言本身来做所有的
压栈操作）该域用于参数可以部分在寄存器中传递，部分在内存中传递的机器上，
以及支持@code{<stdarg.h>}的特性的情况。

@item
@en An area of memory used to save certain registers used by the function.
@en The size of this area, which may also include space for such things as
@en the return address and pointers to previous stack frames, is
@en machine-specific and usually depends on which registers have been used
@en in the function.  Machines with register windows often do not require
@en a save area.
有一块内存用于保存函数使用的特定的寄存器。该区域的大小，
可能还包括作为返回地址和指向之前栈帧的指针的一些空间，
其为机器特定的并且通常取决于函数中已经使用了哪些寄存器。
具有寄存器窗口的机器通常不需要这样的存储区域。

@item
@en A region of at least @var{size} bytes, possibly rounded up to an allocation
@en boundary, to contain the local variables of the function.  On some machines,
@en this region and the save area may occur in the opposite order, with the
@en save area closer to the top of the stack.
一块至少@var{size}个字节的区域，可能舍人到一个分配边界的大小，
来保存函数的局部变量。在一些机器上，该域和保存域可以按照相反的顺序出现，
使得保存域接近于栈顶。

@item
@cindex @code{ACCUMULATE_OUTGOING_ARGS} and stack frames
@en Optionally, when @code{ACCUMULATE_OUTGOING_ARGS} is defined, a region of
@en @code{current_function_outgoing_args_size} bytes to be used for outgoing
@en argument lists of the function.  @xref{Stack Arguments}.
可选的，当@code{ACCUMULATE_OUTGOING_ARGS}被定义时，
还有一块@code{current_function_outgoing_args_size}字节大小的区域用于函数的传出
的参数列表。@xref{Stack Arguments}。
@end itemize

@defmac EXIT_IGNORE_STACK
@en Define this macro as a C expression that is nonzero if the return
@en instruction or the function epilogue ignores the value of the stack
@en pointer; in other words, if it is safe to delete an instruction to
@en adjust the stack pointer before a return from the function.  The
@en default is 0.
定义该宏为一个C表达式，其为非0，如果返回指令或者函数尾声忽略栈指针的值；
换句话说，如果在从函数中返回前，删除调整栈指针的指令是安全的。缺省为0。

@en Note that this macro's value is relevant only for functions for which
@en frame pointers are maintained.  It is never safe to delete a final
@en stack adjustment in a function that has no frame pointer, and the
@en compiler knows this regardless of @code{EXIT_IGNORE_STACK}.
注意该宏的值只于维护帧指针的函数相关。
在没有帧指针的函数中删除最后的栈调整是绝对不安全的，并且编译器知道这种情况，
而不管@code{EXIT_IGNORE_STACK}定义如何。
@end defmac

@defmac EPILOGUE_USES (@var{regno})
@en Define this macro as a C expression that is nonzero for registers that are
@en used by the epilogue or the @samp{return} pattern.  The stack and frame
@en pointer registers are already assumed to be used as needed.
定义该宏为一个C表达式，其为非0，对于用于尾声或者@samp{return}指令模式的寄存器。
栈和帧指针寄存器已经被假设需要使用。
@end defmac

@defmac EH_USES (@var{regno})
@en Define this macro as a C expression that is nonzero for registers that are
@en used by the exception handling mechanism, and so should be considered live
@en on entry to an exception edge.
定义该宏为一个C表达式，其为非0，对于用于异常处理机制的寄存器，
所以其应该被考虑为在一个异常边的入口上是活跃的。
@end defmac

@defmac DELAY_SLOTS_FOR_EPILOGUE
@en Define this macro if the function epilogue contains delay slots to which
@en instructions from the rest of the function can be ``moved''.  The
@en definition should be a C expression whose value is an integer
@en representing the number of delay slots there.
定义该宏，如果函数尾声包含延迟槽，并且函数其余的指令可以被移动过去。
该定义应该为一个C表达式，其值为一个整数表示有多少个延迟槽。
@end defmac

@defmac ELIGIBLE_FOR_EPILOGUE_DELAY (@var{insn}, @var{n})
@en A C expression that returns 1 if @var{insn} can be placed in delay
@en slot number @var{n} of the epilogue.
一个C表达式，返回1，如果@var{insn}可以放在尾声中的延迟槽编号@var{n}中。

@en The argument @var{n} is an integer which identifies the delay slot now
@en being considered (since different slots may have different rules of
@en eligibility).  It is never negative and is always less than the number
@en of epilogue delay slots (what @code{DELAY_SLOTS_FOR_EPILOGUE} returns).
@en If you reject a particular insn for a given delay slot, in principle, it
@en may be reconsidered for a subsequent delay slot.  Also, other insns may
@en (at least in principle) be considered for the so far unfilled delay
@en slot.
参数@var{n}为一个整数，其标识了目前被考虑的延迟槽（由于不同的延迟槽可以具有不同
的适任规则）。其从不为负，并且总是小于尾声延迟槽的总数
（@code{DELAY_SLOTS_FOR_EPILOGUE}的返回值）。
如果你为给定的延迟槽拒绝了一个特定的insn，原则上，其可以被后续的延迟槽重新考虑。
而且，其它insn还可以（至少原则上）被目前为止还没有被填充的延迟槽考虑。

@findex current_function_epilogue_delay_list
@findex final_scan_insn
@en The insns accepted to fill the epilogue delay slots are put in an RTL
@en list made with @code{insn_list} objects, stored in the variable
@en @code{current_function_epilogue_delay_list}.  The insn for the first
@en delay slot comes first in the list.  Your definition of the macro
@en @code{TARGET_ASM_FUNCTION_EPILOGUE} should fill the delay slots by
@en outputting the insns in this list, usually by calling
@en @code{final_scan_insn}.
被接受填充尾声延迟槽的insn被放在一个RTL链表中，使用@code{insn_list}对象，
并存储在变量@code{current_function_epilogue_delay_list}中。
第一个延迟槽的insn位于链表中的第一个。你对宏@code{TARGET_ASM_FUNCTION_EPILOGUE}
的定义应该通过输出该链表的insn来填充延迟槽，通常是调用@code{final_scan_insn}。

@en You need not define this macro if you did not define
@en @code{DELAY_SLOTS_FOR_EPILOGUE}.
你不需要定义该宏，如果你没有定义@code{DELAY_SLOTS_FOR_EPILOGUE}。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_MI_THUNK (FILE *@var{file}, tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, tree @var{function})
@en A function that outputs the assembler code for a thunk
@en function, used to implement C++ virtual function calls with multiple
@en inheritance.  The thunk acts as a wrapper around a virtual function,
@en adjusting the implicit object parameter before handing control off to
@en the real function.
一个函数，输出一个thunk函数的汇编代码，用于实现具有多继承的C++虚函数调用。
thunk作为一个虚函数的封装，用来调整隐式对象参数，在将控制移交给实函数之前。

@en First, emit code to add the integer @var{delta} to the location that
@en contains the incoming first argument.  Assume that this argument
@en contains a pointer, and is the one used to pass the @code{this} pointer
@en in C++.  This is the incoming argument @emph{before} the function prologue,
@en e.g.@: @samp{%o0} on a sparc.  The addition must preserve the values of
@en all other incoming arguments.
首选，输出代码来增加整数@var{delta}为包含传递进来的第一个参数的为。
假设该参数包含一个指针，并用于在C++中传递@code{this}指针。
这是在函数序言之前的参数，例如在sparc上为@samp{%o0}。

@en Then, if @var{vcall_offset} is nonzero, an additional adjustment should be
@en made after adding @code{delta}.  In particular, if @var{p} is the
@en adjusted pointer, the following adjustment should be made:
然后，如果@var{vcall_offset}非0，则在增加@var{delta}之后应该进行额外的调整。
特别是，如果@var{p}为被调整的指针，则应该进行如下的调整：

@smallexample
p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]
@end smallexample

@en After the additions, emit code to jump to @var{function}, which is a
@en @code{FUNCTION_DECL}.  This is a direct pure jump, not a call, and does
@en not touch the return address.  Hence returning from @var{FUNCTION} will
@en return to whoever called the current @samp{thunk}.
加法之后，输出代码跳转到@var{function}，其为@code{FUNCTION_DECL}。
这是一个直接跳转，而不是调用，并且不触及返回地址。因此从@var{FUNCTION}中返回时，
将返回到调用当前@samp{thunk}的地方。

@en The effect must be as if @var{function} had been called directly with
@en the adjusted first argument.  This macro is responsible for emitting all
@en of the code for a thunk function; @code{TARGET_ASM_FUNCTION_PROLOGUE}
@en and @code{TARGET_ASM_FUNCTION_EPILOGUE} are not invoked.
其效果就好像是函数被直接调用，并使用调整后的第一个参数。
该宏负责输出thunk函数的所有代码；@code{TARGET_ASM_FUNCTION_PROLOGUE}和@code{TARGET_ASM_FUNCTION_EPILOGUE}不被调用。

@en The @var{thunk_fndecl} is redundant.  (@var{delta} and @var{function}
@en have already been extracted from it.)  It might possibly be useful on
@en some targets, but probably not.
@var{thunk_fndecl}是冗余的。（@var{delta}和@var{function}已经从中被抽取出来。）
其可能在一些target上有用，也很可能没用。

@en If you do not define this macro, the target-independent code in the C++
@en front end will generate a less efficient heavyweight thunk that calls
@en @var{function} instead of jumping to it.  The generic approach does
@en not support varargs.
如果你没有定义该宏，则C++前端的target无关代码将会生成一个不太有效的重量级的
thunk，其调用@var{function}而不是直接跳转过去。普通的方法不支持varargs。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (const_tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, const_tree @var{function})
@en A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would be able
@en to output the assembler code for the thunk function specified by the
@en arguments it is passed, and false otherwise.  In the latter case, the
@en generic approach will be used by the C++ front end, with the limitations
@en previously exposed.
一个函数，返回真，如果TARGET_ASM_OUTPUT_MI_THUNK应该能够为其传递的参数所指定的
thunk函数输出汇编代码，否则为假。在后一种情况下，C++前端将会使用普通的方式，
并具有之前提到的限制。
@end deftypefn

@en @node Profiling
@en @subsection Generating Code for Profiling
@node Profiling
@subsection 为profiling生成代码
@cindex profiling, code generation

@en These macros will help you generate code for profiling.
这些宏将帮助你为profiling生成代码。

@defmac FUNCTION_PROFILER (@var{file}, @var{labelno})
@en A C statement or compound statement to output to @var{file} some
@en assembler code to call the profiling subroutine @code{mcount}.
一条C语句或者复合语句，来输出到@var{file}中一些汇编代码，
来调用profiling子程序@code{mcount}。

@findex mcount
@en The details of how @code{mcount} expects to be called are determined by
@en your operating system environment, not by GCC@.  To figure them out,
@en compile a small program for profiling using the system's installed C
@en compiler and look at the assembler code that results.
关于@code{mcount}期望如何被调用的细节，由你的操作系统环境来决定，
而不是GCC。要弄清楚它们，可以编译一个小程序，
使用系统安装的C编译进行profiling，并查看生成的汇编代码。

@en Older implementations of @code{mcount} expect the address of a counter
@en variable to be loaded into some register.  The name of this variable is
@en @samp{LP} followed by the number @var{labelno}, so you would generate
@en the name using @samp{LP%d} in a @code{fprintf}.
@code{mcount}的旧的实现，期望一个计数变量的地址被加载到某个寄存器中。
该变量的名字为@samp{LP}，后面跟随数字@var{labelno}，
所以你应该生成该名字，在@code{fprintf}中使用@samp{LP%d}。
@end defmac

@defmac PROFILE_HOOK
@en A C statement or compound statement to output to @var{file} some assembly
@en code to call the profiling subroutine @code{mcount} even the target does
@en not support profiling.
一条C语句或者复合语句，来输出到@var{file}中一些汇编代码，
来调用profiling子程序@code{mcount}，即使target不支持profiling。
@end defmac

@defmac NO_PROFILE_COUNTERS
@en Define this macro to be an expression with a nonzero value if the
@en @code{mcount} subroutine on your system does not need a counter variable
@en allocated for each function.  This is true for almost all modern
@en implementations.  If you define this macro, you must not use the
@en @var{labelno} argument to @code{FUNCTION_PROFILER}.
定义该宏为一个表达式，具有一个非0的值，
如果你系统上的@code{mcount}子程序不需要为每个函数分配一个计数变量。
这对于大多数现代实现都是正确的。如果你定义了该宏，
你一定不要使用@code{FUNCTION_PROFILER}的@var{labelno}参数。
@end defmac

@defmac PROFILE_BEFORE_PROLOGUE
@en Define this macro if the code for function profiling should come before
@en the function prologue.  Normally, the profiling code comes after.
定义该宏，如果函数profiling的代码应该位于函数序言之前。
通常profiling代码位于之后。
@end defmac

@en @node Tail Calls
@en @subsection Permitting tail calls
@node Tail Calls
@subsection 允许尾调用
@cindex tail calls

@deftypefn {Target Hook} bool TARGET_FUNCTION_OK_FOR_SIBCALL (tree @var{decl}, tree @var{exp})
@en True if it is ok to do sibling call optimization for the specified
@en call expression @var{exp}.  @var{decl} will be the called function,
@en or @code{NULL} if this is an indirect call.
如果可以为指定的调用表达式@var{exp}做sibling call优化，则为真。
@var{decl}为被调用的函数，或者为@var{NULL}，如果这是一个间接调用。

@en It is not uncommon for limitations of calling conventions to prevent
@en tail calls to functions outside the current unit of translation, or
@en during PIC compilation.  The hook is used to enforce these restrictions,
@en as the @code{sibcall} md pattern can not fail, or fall over to a
@en ``normal'' call.  The criteria for successful sibling call optimization
@en may vary greatly between different architectures.
通常调用约定的限制不会阻止当前转换单元之外的或者PIC编译过程中的函数尾调用。
钩子用来加强这些限制，由于@code{sibcall} md模式不能fail。
成功的sibling call优化的标准可能在不同的体系结构上有很大的差别。
@end deftypefn

@deftypefn {Target Hook} void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap @var{regs})
@en Add any hard registers to @var{regs} that are live on entry to the
@en function.  This hook only needs to be defined to provide registers that
@en cannot be found by examination of FUNCTION_ARG_REGNO_P, the callee saved
@en registers, STATIC_CHAIN_INCOMING_REGNUM, STATIC_CHAIN_REGNUM,
@en TARGET_STRUCT_VALUE_RTX, FRAME_POINTER_REGNUM, EH_USES,
@en FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM, and the PIC_OFFSET_TABLE_REGNUM.
增加任何在函数入口为活跃的硬件寄存器到@var{regs}。
该钩子只需要被定义来提供不能通过检查FUNCTION_ARG_REGNO_P，
callee保存的寄存器，STATIC_CHAIN_INCOMING_REGNUM，
STATIC_CHAIN_REGNUM， TARGET_STRUCT_VALUE_RTX，FRAME_POINTER_REGNUM，
EH_USES， FRAME_POINTER_REGNUM，
ARG_POINTER_REGNUM和PIC_OFFSET_TABLE_REGNUM来发现的寄存器。
@end deftypefn

@en @node Stack Smashing Protection
@en @subsection Stack smashing protection
@node Stack Smashing Protection
@subsection 栈冲突保护
@cindex stack smashing protection

@deftypefn {Target Hook} tree TARGET_STACK_PROTECT_GUARD (void)
@en This hook returns a @code{DECL} node for the external variable to use
@en for the stack protection guard.  This variable is initialized by the
@en runtime to some random value and is used to initialize the guard value
@en that is placed at the top of the local stack frame.  The type of this
@en variable must be @code{ptr_type_node}.
该钩子返回一个外部变量的@code{DECL}节点，用作栈保护者。
该变量在运行时被初始化为某个随即值，
并用于初始化放在局部栈帧顶端的警卫值。
该变量的类型必须为@code{ptr_type_node}。

@en The default version of this hook creates a variable called
@en @samp{__stack_chk_guard}, which is normally defined in @file{libgcc2.c}.
该钩子的缺省版本创建一个叫做@samp{__stack_chk_guard}的变量，
其通常在@file{libgcc2.c}中被定义。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_STACK_PROTECT_FAIL (void)
@en This hook returns a tree expression that alerts the runtime that the
@en stack protect guard variable has been modified.  This expression should
@en involve a call to a @code{noreturn} function.
该钩子返回一个tree表达式，用以警告运行时，栈保护者变量被修改了。
该表达式应该包括一个对无返回的（@code{noreturn}）函数的调用。

@en The default version of this hook invokes a function called
@en @samp{__stack_chk_fail}, taking no arguments.  This function is
@en normally defined in @file{libgcc2.c}.
该钩子的缺省版本调用一个叫做@samp{__stack_chk_fail}的函数，
不接受任何参数。该函数通常在@file{libgcc2.c}中被定义。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SUPPORTS_SPLIT_STACK (bool @var{report}, struct gcc_options *@var{opts})
Whether this target supports splitting the stack when the options described in @var{opts} have been passed.  This is called after options have been parsed, so the target may reject splitting the stack in some configurations.  The default version of this hook returns false.  If @var{report} is true, this function may issue a warning or error; if @var{report} is false, it must simply return a value
@end deftypefn

@en @node Varargs
@en @section Implementing the Varargs Macros
@node Varargs
@section 实现Varargs宏
@cindex varargs implementation

@en GCC comes with an implementation of @code{<varargs.h>} and
@en @code{<stdarg.h>} that work without change on machines that pass arguments
@en on the stack.  Other machines require their own implementations of
@en varargs, and the two machine independent header files must have
@en conditionals to include it.
GCC自带了@code{<varargs.h>}和@code{<stdarg.h>}的实现，
可直接用于在栈上传递参数的机器上。其它机器需要它们自己的varargs实现，
并且两个机器独立的头文件必须条件包含它。

@en ISO @code{<stdarg.h>} differs from traditional @code{<varargs.h>} mainly in
@en the calling convention for @code{va_start}.  The traditional
@en implementation takes just one argument, which is the variable in which
@en to store the argument pointer.  The ISO implementation of
@en @code{va_start} takes an additional second argument.  The user is
@en supposed to write the last named argument of the function here.
ISO @code{<stdarg.h>}与传统@code{<varargs.h>}的区别主要在@code{va_start}的调用
约定上。传统的实现只接受一个参数，其为存储参数指针的变量。
ISO的实现接受额外的第二个参数。用户应该将函数的最后一个命名参数写在这里。

@en However, @code{va_start} should not use this argument.  The way to find
@en the end of the named arguments is with the built-in functions described
@en below.
然而，@code{va_start}不应该使用这个参数。
发现命名参数结尾的方法为使用下面描述的内建函数。

@defmac __builtin_saveregs ()
@en Use this built-in function to save the argument registers in memory so
@en that the varargs mechanism can access them.  Both ISO and traditional
@en versions of @code{va_start} must use @code{__builtin_saveregs}, unless
@en you use @code{TARGET_SETUP_INCOMING_VARARGS} (see below) instead.
使用该内建函数来将参数寄存器保存在内存中，使得varargs机制可以访问它们。
@code{va_start}的ISO版本和传统版本都必须使用@code{__builtin_saveregs}，
除非你使用@code{TARGET_SETUP_INCOMING_VARARGS}来替代（参见下面）。

@en On some machines, @code{__builtin_saveregs} is open-coded under the
@en control of the target hook @code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  On
@en other machines, it calls a routine written in assembler language,
@en found in @file{libgcc2.c}.
在一些机器上，@code{__builtin_saveregs}为开放编码的，
在target钩子@code{TARGET_EXPAND_BUILTIN_SAVEREGS}的控制下。
在其它机器上，其调用了汇编语言写的例程，可以在@file{libgcc2.c}中找到。

@en Code generated for the call to @code{__builtin_saveregs} appears at the
@en beginning of the function, as opposed to where the call to
@en @code{__builtin_saveregs} is written, regardless of what the code is.
@en This is because the registers must be saved before the function starts
@en to use them for its own purposes.
不管怎样，调用@code{__builtin_saveregs}的生成代码都出现在函数的起始处。
这是因为寄存器必须在函数开始使用它们前被保存。
@c i rewrote the first sentence above to fix an overfull hbox. --mew
@c 10feb93
@end defmac

@defmac __builtin_next_arg (@var{lastarg})
@en This builtin returns the address of the first anonymous stack
@en argument, as type @code{void *}.  If @code{ARGS_GROW_DOWNWARD}, it
@en returns the address of the location above the first anonymous stack
@en argument.  Use it in @code{va_start} to initialize the pointer for
@en fetching arguments from the stack.  Also use it in @code{va_start} to
@en verify that the second parameter @var{lastarg} is the last named argument
@en of the current function.
这与@code{__builtin_args_info}等价，用于栈参数。其返回第一个匿名栈参数的地址，
类型为@code{void *}。如果@code{ARGS_GROW_DOWNWARD}，
其返回第一个匿名栈参数的上面的位置地址。在@code{va_start}中使用它来初始化指针，
来从栈中获得参数。同样，在@code{va_start}中使用它来验证第二个参数@var{lastarg}
为当前函数的最后一个命名参数。
@end defmac

@defmac __builtin_classify_type (@var{object})
@en Since each machine has its own conventions for which data types are
@en passed in which kind of register, your implementation of @code{va_arg}
@en has to embody these conventions.  The easiest way to categorize the
@en specified data type is to use @code{__builtin_classify_type} together
@en with @code{sizeof} and @code{__alignof__}.
由于每个机器具有它自己的约定，对于哪些数据类型在哪种寄存器中传递，
因此你的@code{va_arg}实现必须包含这些约定。
将指定数据类型归类的最简单方法是使用@code{__builtin_classify_type}，
加上@code{sizeof}和@code{__alignof__}。

@en @code{__builtin_classify_type} ignores the value of @var{object},
@en considering only its data type.  It returns an integer describing what
@en kind of type that is---integer, floating, pointer, structure, and so on.
@code{__builtin_classify_type}忽略@var{object}的值，只考虑它的数据类型。
其返回一个整数来描述什么类型为，整型，浮点，指针，结构体等。

@en The file @file{typeclass.h} defines an enumeration that you can use to
@en interpret the values of @code{__builtin_classify_type}.
文件@file{typeclass.h}定义了一个枚举，
你可以用来解析@code{__builtin_classify_type}的值。
@end defmac

@en These machine description macros help implement varargs:
这些机器描述宏用来帮助实现varargs：

@deftypefn {Target Hook} rtx TARGET_EXPAND_BUILTIN_SAVEREGS (void)
@en If defined, this hook produces the machine-specific code for a call to
@en @code{__builtin_saveregs}.  This code will be moved to the very
@en beginning of the function, before any parameter access are made.  The
@en return value of this function should be an RTX that contains the value
@en to use as the return of @code{__builtin_saveregs}.
如果定义，该钩子产生机器特定代码，用于调用@code{__builtin_saveregs}。
该代码将被移动到函数的最开始处，在访问任何参数之前。
该函数的返回值应该为一个RTX，其包含了@code{__builtin_saveregs}的返回值。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARGS (CUMULATIVE_ARGS *@var{args_so_far}, enum machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})
@en This target hook offers an alternative to using
@en @code{__builtin_saveregs} and defining the hook
@en @code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  Use it to store the anonymous
@en register arguments into the stack so that all the arguments appear to
@en have been passed consecutively on the stack.  Once this is done, you can
@en use the standard implementation of varargs that works for machines that
@en pass all their arguments on the stack.
该target钩子提供了使用@code{__builtin_saveregs}和定义
@code{TARGET_EXPAND_BUILTIN_SAVEREGS}钩子的替代。
使用它来将匿名寄存器参数存储到栈中，使得所有参数都像是通过栈连续的传递。
当这样做时，你可以使用varargs的标准实现，其用于将所有参数在栈上传递的机器上。

@en The argument @var{args_so_far} points to the @code{CUMULATIVE_ARGS} data
@en structure, containing the values that are obtained after processing the
@en named arguments.  The arguments @var{mode} and @var{type} describe the
@en last named argument---its machine mode and its data type as a tree node.
参数@var{args_so_far}指向@code{CUMULATIVE_ARGS}数据结构体，
包含了处理完命名参数之后所获得的值。
参数@var{mode}和@var{type}描述了最后一个命名参数的机器模式和作为树结点的数据类型。

@en The target hook should do two things: first, push onto the stack all the
@en argument registers @emph{not} used for the named arguments, and second,
@en store the size of the data thus pushed into the @code{int}-valued
@en variable pointed to by @var{pretend_args_size}.  The value that you
@en store here will serve as additional offset for setting up the stack
@en frame.
该target钩子应该做两件事：第一，将所有不用于命名参数的参数寄存器压入栈中，
第二，存储数据的大小，把@var{pretend_args_size}指向的@code{int}值得变量压入。
这里你存储的值将作为额外的偏移量，用来建立栈帧。

@en Because you must generate code to push the anonymous arguments at
@en compile time without knowing their data types,
@en @code{TARGET_SETUP_INCOMING_VARARGS} is only useful on machines that
@en have just a single category of argument register and use it uniformly
@en for all data types.
因为你必须生成代码来将匿名参数在编译时压入，而不需要知道它们的数据类型，
所以@code{TARGET_SETUP_INCOMING_VARARGS}只在只有一种参数寄存器类别并用于所有
数据类型的机器上有用。

@en If the argument @var{second_time} is nonzero, it means that the
@en arguments of the function are being analyzed for the second time.  This
@en happens for an inline function, which is not actually compiled until the
@en end of the source file.  The hook @code{TARGET_SETUP_INCOMING_VARARGS} should
@en not generate any instructions in this case.
如果参数@var{second_time}非0，其以为着函数的参数被第二次分析。
这发生于内联函数，其直到源文件结尾才被实际编译。对于这种情况，
钩子@code{TARGET_SETUP_INCOMING_VARARGS}不应该产生任何指令。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_STRICT_ARGUMENT_NAMING (CUMULATIVE_ARGS *@var{ca})
@en Define this hook to return @code{true} if the location where a function
@en argument is passed depends on whether or not it is a named argument.
定义该钩子来返回@code{true}，如果函数参数传递的位置依赖于其是否为一个命名参数。

@en This hook controls how the @var{named} argument to @code{FUNCTION_ARG}
@en is set for varargs and stdarg functions.  If this hook returns
@en @code{true}, the @var{named} argument is always true for named
@en arguments, and false for unnamed arguments.  If it returns @code{false},
@en but @code{TARGET_PRETEND_OUTGOING_VARARGS_NAMED} returns @code{true},
@en then all arguments are treated as named.  Otherwise, all named arguments
@en except the last are treated as named.
该钩子控制对于varargs和stdarg函数，如何设置FUNCTION_ARG的@var{named}参数。
如果该钩子返回@code{true}，则@var{named}参数总是为命名参数，未命名参数总是未假。
如果返回@code{false}，但是@code{TARGET_PRETEND_OUTGOING_VARARGS_NAMED}返回
@code{true}，则所有参数都被作为命名的对待。否则所有命名参数，除了最后一个，
被作为命名的对待。

@en You need not define this hook if it always returns @code{false}.
如果其总是返回0，则不需要定义该钩子。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED (CUMULATIVE_ARGS *@var{ca})
@en If you need to conditionally change ABIs so that one works with
@en @code{TARGET_SETUP_INCOMING_VARARGS}, but the other works like neither
@en @code{TARGET_SETUP_INCOMING_VARARGS} nor @code{TARGET_STRICT_ARGUMENT_NAMING} was
@en defined, then define this hook to return @code{true} if
@en @code{TARGET_SETUP_INCOMING_VARARGS} is used, @code{false} otherwise.
@en Otherwise, you should not define this hook.
如果你需要条件的改变ABI，使得一种工作于@code{TARGET_SETUP_INCOMING_VARARGS}，
另一种工作于@code{TARGET_SETUP_INCOMING_VARARGS}和
@code{TARGET_STRICT_ARGUMENT_NAMING}都没有被定义，则定义该钩子返回@code{true}，
如果使用@code{TARGET_SETUP_INCOMING_VARARGS}，否则返回@code{false}。
否则，你不需要定义该钩子。
@end deftypefn

@en @node Trampolines
@en @section Trampolines for Nested Functions
@node Trampolines
@section 嵌套函数的蹦床
@cindex trampolines for nested functions
@cindex nested functions, trampolines for

@en A @dfn{trampoline} is a small piece of code that is created at run time
@en when the address of a nested function is taken.  It normally resides on
@en the stack, in the stack frame of the containing function.  These macros
@en tell GCC how to generate code to allocate and initialize a
@en trampoline.
一个蹦床@dfn{trampoline}为在运行时，当使用嵌套函数的地址时，创建的一小块代码。其通常驻于栈上，在包含函数的栈帧中。这些宏告诉GCC如何生成代码来分配和初始化一个蹦床。

@en The instructions in the trampoline must do two things: load a constant
@en address into the static chain register, and jump to the real address of
@en the nested function.  On CISC machines such as the m68k, this requires
@en two instructions, a move immediate and a jump.  Then the two addresses
@en exist in the trampoline as word-long immediate operands.  On RISC
@en machines, it is often necessary to load each address into a register in
@en two parts.  Then pieces of each address form separate immediate
@en operands.
在蹦床中的指令必须做两件事情：将一个常量地址加载到静态链寄存器中，并跳转到嵌套函数的实际地址。在CISC机器，像m68k上，这要求两条指令，一个move立即数和一个jump。然后两个地址存放在蹦床中作为字长的立即操作数。在RISC机器上，其通常需要分成两部分加载每个地址到寄存器中。然后地址的各部分形成独立的立即操作数。

@en The code generated to initialize the trampoline must store the variable
@en parts---the static chain value and the function address---into the
@en immediate operands of the instructions.  On a CISC machine, this is
@en simply a matter of copying each address to a memory reference at the
@en proper offset from the start of the trampoline.  On a RISC machine, it
@en may be necessary to take out pieces of the address and store them
@en separately.
用来初始化蹦床的代码必须将变量的组成部分——静态链值和函数地址——存储到指令的立即操作数中。在CISC机器上，这是简单的复制每个地址到一个内存引用，在蹦床起始处的合适偏移量上。在RISC机器上，其可能需要拿出部分地址并单独存储它们。

@deftypefn {Target Hook} void TARGET_ASM_TRAMPOLINE_TEMPLATE (FILE *@var{f})
This hook is called by @code{assemble_trampoline_template} to output,
on the stream @var{f}, assembler code for a block of data that contains
the constant parts of a trampoline.  This code should not include a
label---the label is taken care of automatically.

If you do not define this hook, it means no template is needed
for the target.  Do not define this hook on systems where the block move
code to copy the trampoline into place would be larger than the code
to generate it on the spot.
@end deftypefn

@defmac TRAMPOLINE_SECTION
@en Return the section into which the trampoline template is to be placed
@en (@pxref{Sections}).  The default value is @code{readonly_data_section}.
返回蹦床模版被放入的section(@pxref{Sections})。
缺省值为@code{readonly_data_section}。
@end defmac

@defmac TRAMPOLINE_SIZE
@en A C expression for the size in bytes of the trampoline, as an integer.
一个C表达式，蹦床的字节单位的大小，为整数。
@end defmac

@defmac TRAMPOLINE_ALIGNMENT
@en Alignment required for trampolines, in bits.
蹦床需要的对齐，以位为单位。

@en If you don't define this macro, the value of @code{FUNCTION_ALIGNMENT}
@en is used for aligning trampolines.
如果没有定义该宏，则使用@code{BIGGEST_ALIGNMENT}的值来对齐蹦床。
@end defmac

@deftypefn {Target Hook} void TARGET_TRAMPOLINE_INIT (rtx @var{m_tramp}, tree @var{fndecl}, rtx @var{static_chain})
This hook is called to initialize a trampoline.
@var{m_tramp} is an RTX for the memory block for the trampoline; @var{fndecl}
is the @code{FUNCTION_DECL} for the nested function; @var{static_chain} is an
RTX for the static chain value that should be passed to the function
when it is called.

If the target defines @code{TARGET_ASM_TRAMPOLINE_TEMPLATE}, then the
first thing this hook should do is emit a block move into @var{m_tramp}
from the memory block returned by @code{assemble_trampoline_template}.
Note that the block move need only cover the constant parts of the 
trampoline.  If the target isolates the variable parts of the trampoline
to the end, not all @code{TRAMPOLINE_SIZE} bytes need be copied.

If the target requires any other actions, such as flushing caches or
enabling stack execution, these actions should be performed after 
initializing the trampoline proper.
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_TRAMPOLINE_ADJUST_ADDRESS (rtx @var{addr})
This hook should perform any machine-specific adjustment in
the address of the trampoline.  Its argument contains the address of the
memory block that was passed to @code{TARGET_TRAMPOLINE_INIT}.  In case
the address to be used for a function call should be different from the
address at which the template was stored, the different address should
be returned; otherwise @var{addr} should be returned unchanged.
If this hook is not defined, @var{addr} will be used for function calls.
@end deftypefn

@en Implementing trampolines is difficult on many machines because they have
@en separate instruction and data caches.  Writing into a stack location
@en fails to clear the memory in the instruction cache, so when the program
@en jumps to that location, it executes the old contents.
在许多机器上实现蹦床是困难的，因为它们具有独立的指令和数据缓存。
写到栈位置中使得无法清除指令缓存中的内存，所以当程序跳转到那个位置时，
其执行了旧的内容。

@en Here are two possible solutions.  One is to clear the relevant parts of
@en the instruction cache whenever a trampoline is set up.  The other is to
@en make all trampolines identical, by having them jump to a standard
@en subroutine.  The former technique makes trampoline execution faster; the
@en latter makes initialization faster.
有两种可能的解决方法。一种是清除指令缓存的相关部分，当蹦床被建立的时候。
另一种是使所有蹦床为等同的，通过使它们跳转到一个标准的子程序中。
前者使得蹦床执行更快；后者使得初始化更快。

@en To clear the instruction cache when a trampoline is initialized, define
@en the following macro.
要在初始化蹦床时清除指令缓存，定义下列宏。

@defmac CLEAR_INSN_CACHE (@var{beg}, @var{end})
@en If defined, expands to a C expression clearing the @emph{instruction
@en cache} in the specified interval.  The definition of this macro would
@en typically be a series of @code{asm} statements.  Both @var{beg} and
@en @var{end} are both pointer expressions.
如果被定义，将扩展为一个C表达式，在指定的间隔处来清除指令缓存。
该宏的定义通常为一系列@code{asm}语句。@var{beg}和@var{end}都为指针表达式。
@end defmac

@en The operating system may also require the stack to be made executable
@en before calling the trampoline.  To implement this requirement, define
@en the following macro.
操作系统可能还需要栈被设为可执行的，在调用蹦床之前。要实现这种需求，定义下列宏。

@defmac ENABLE_EXECUTE_STACK
@en Define this macro if certain operations must be performed before executing
@en code located on the stack.  The macro should expand to a series of C
@en file-scope constructs (e.g.@: functions) and provide a unique entry point
@en named @code{__enable_execute_stack}.  The target is responsible for
@en emitting calls to the entry point in the code, for example from the
@en @code{TARGET_TRAMPOLINE_INIT} hook.
定义该宏，如果在执行位于栈上的代码之前必须执行特定的操作。
宏应该扩展为一系列的C文件作用域的结构（例如函数）并提供一个唯一的如何口点名
为@code{__enable_execute_stack}。target负责生成对入口点的调用，
例如从@code{INITIALIZE_TRAMPOLINE}宏中。
@end defmac

@en To use a standard subroutine, define the following macro.  In addition,
@en you must make sure that the instructions in a trampoline fill an entire
@en cache line with identical instructions, or else ensure that the
@en beginning of the trampoline code is always aligned at the same point in
@en its cache line.  Look in @file{m68k.h} as a guide.
要使用标准的子程序，定义下列宏。另外，
你必须确信在蹦床中的指令使用相同的指令来填充整个缓存行，
或者蹦床代码的起始处总是在缓存行的某点被对齐。查看@file{m68k.h}作为参考。

@defmac TRANSFER_FROM_TRAMPOLINE
@en Define this macro if trampolines need a special subroutine to do their
@en work.  The macro should expand to a series of @code{asm} statements
@en which will be compiled with GCC@.  They go in a library function named
@en @code{__transfer_from_trampoline}.
定义该宏，如果蹦床需要一个特定的子程序来做它们的工作。
该宏应该扩展为一系列的@code{asm}语句，其将由GCC来编译。
它们放在名为@code{__transfer_from_trampoline}的库函数中。

@en If you need to avoid executing the ordinary prologue code of a compiled
@en C function when you jump to the subroutine, you can do so by placing a
@en special label of your own in the assembler code.  Use one @code{asm}
@en statement to generate an assembler label, and another to make the label
@en global.  Then trampolines can use that label to jump directly to your
@en special assembler code.
如果当你跳转到子程序时，你需要避免普通的被编译的C函数的序言代码，
你可以通过在汇编代码中放一个你自己的特定标号。
使用一条@code{asm}语句来生成汇编标号，另一条语句使得标号为global的。
然后蹦床可以使用该标号直接跳到你特定的汇编代码上。
@end defmac

@en @node Library Calls
@en @section Implicit Calls to Library Routines
@node Library Calls
@section 库例程的隐式调用
@cindex library subroutine names
@cindex @file{libgcc.a}

@c prevent bad page break with this line
@en Here is an explanation of implicit calls to library routines.
这是库函数的隐式调用的说明。

@defmac DECLARE_LIBRARY_RENAMES
@en This macro, if defined, should expand to a piece of C code that will get
@en expanded when compiling functions for libgcc.a.  It can be used to
@en provide alternate names for GCC's internal library functions if there
@en are ABI-mandated names that the compiler should provide.
该宏，如果被定义，应该扩展为一块C代码，当编译libgcc.a的函数时被扩展。
其可以被用于提供GCC内部库函数的替代名字，如果有编译应该提供的ABI名字。
@end defmac

@findex set_optab_libfunc
@findex init_one_libfunc
@deftypefn {Target Hook} void TARGET_INIT_LIBFUNCS (void)
@en This hook should declare additional library routines or rename
@en existing ones, using the functions @code{set_optab_libfunc} and
@en @code{init_one_libfunc} defined in @file{optabs.c}.
@en @code{init_optabs} calls this macro after initializing all the normal
@en library routines.
该钩子应该声明额外的库函数或者重命名存在的，
使用@file{optabs.c}中定义的函数@code{set_optab_libfunc}和
@code{init_one_libfunc}。
@code{init_optabs}调用该宏，在初始化所有正常的库函数之后。

@en The default is to do nothing.  Most ports don't need to define this hook.
缺省为不作任何事情。大多数port不需要定义该钩子。
@end deftypefn

@defmac FLOAT_LIB_COMPARE_RETURNS_BOOL (@var{mode}, @var{comparison})
@en This macro should return @code{true} if the library routine that
@en implements the floating point comparison operator @var{comparison} in
@en mode @var{mode} will return a boolean, and @var{false} if it will
@en return a tristate.
该宏应该返回@code{true}，如果实现在模式@var{mode}下的浮点比较操作符
@var{comparison}的库函数应该返回一个布尔值，
如果应该返回一个三态值则返回@var{false}。

@en GCC's own floating point libraries return tristates from the
@en comparison operators, so the default returns false always.  Most ports
@en don't need to define this macro.
GCC本身的浮点库从比较运算符中返回三态值，所以缺省总是返回假。
大多数port不需要定义该宏。
@end defmac

@defmac TARGET_LIB_INT_CMP_BIASED
@en This macro should evaluate to @code{true} if the integer comparison
@en functions (like @code{__cmpdi2}) return 0 to indicate that the first
@en operand is smaller than the second, 1 to indicate that they are equal,
@en and 2 to indicate that the first operand is greater than the second.
@en If this macro evaluates to @code{false} the comparison functions return
@en @minus{}1, 0, and 1 instead of 0, 1, and 2.  If the target uses the routines
@en in @file{libgcc.a}, you do not need to define this macro.
该宏应该求解为@code{true}，如果整型比较函数（像@code{__cmpdi2}）
应该返回0来指示第一个操作数比第二个小，1来指示相等，
2来指示第一个操作数大于第二个。如果该宏求解为@code{false}，
则比较函数返回-1，0和1，来替代0，1和2。如果target使用@file{libgcc.a}中的函数，
则不需要定义该宏。
@end defmac

@cindex US Software GOFAST, floating point emulation library
@cindex floating point emulation library, US Software GOFAST
@cindex GOFAST, floating point emulation library
@findex gofast_maybe_init_libfuncs
@defmac US_SOFTWARE_GOFAST
@en Define this macro if your system C library uses the US Software GOFAST
@en library to provide floating point emulation.
定义该宏，如果你的系统C库使用US Software GOFAST库来提供浮点模拟。

@en In addition to defining this macro, your architecture must set
@en @code{TARGET_INIT_LIBFUNCS} to @code{gofast_maybe_init_libfuncs}, or
@en else call that function from its version of that hook.  It is defined
@en in @file{config/gofast.h}, which must be included by your
@en architecture's @file{@var{cpu}.c} file.  See @file{sparc/sparc.c} for
@en an example.
除了定义该宏以外，你的体系结构必须将@code{TARGET_INIT_LIBFUNCS}设为
@code{gofast_maybe_init_libfuncs}，或者从那个钩子版本中调用该函数。
其在@file{config/gofast.h}中定义，
且必须被你的体系结构的@file{@var{cpu}.c}文件包含进来。
例如参见@file{sparc/sparc.c}。

@en If this macro is defined, the
@en @code{TARGET_FLOAT_LIB_COMPARE_RETURNS_BOOL} target hook must return
@en false for @code{SFmode} and @code{DFmode} comparisons.
如果该宏被定义，
则@code{TARGET_FLOAT_LIB_COMPARE_RETURNS_BOOL} target钩子必须返回假，
对于@code{SFmode}和@code{DFmode}比较。
@end defmac

@cindex @code{EDOM}, implicit usage
@findex matherr
@defmac TARGET_EDOM
@en The value of @code{EDOM} on the target machine, as a C integer constant
@en expression.  If you don't define this macro, GCC does not attempt to
@en deposit the value of @code{EDOM} into @code{errno} directly.  Look in
@en @file{/usr/include/errno.h} to find the value of @code{EDOM} on your
@en system.
target机器上的@code{EDOM}的值，作为一个C整型常量表达式。如果没有定义该宏，
则GCC不尝试将@code{EDOM}的值直接存放到@code{errno}中。
查看@file{/usr/include/errno.h}来查找你的系统上的@code{EDOM}的值。

@en If you do not define @code{TARGET_EDOM}, then compiled code reports
@en domain errors by calling the library function and letting it report the
@en error.  If mathematical functions on your system use @code{matherr} when
@en there is an error, then you should leave @code{TARGET_EDOM} undefined so
@en that @code{matherr} is used normally.
如果没有定义@code{TARGET_EDOM}则被编译的代码通过调用库函数并使其报告错误，
来报告domain错误。如果对于这样的错误，你系统上的数学函数使用@code{matherr}，
则应该不定义@code{TARGET_EDOM}，以便@code{matherr}被正常使用。
@end defmac

@cindex @code{errno}, implicit usage
@defmac GEN_ERRNO_RTX
@en Define this macro as a C expression to create an rtl expression that
@en refers to the global ``variable'' @code{errno}.  (On certain systems,
@en @code{errno} may not actually be a variable.)  If you don't define this
@en macro, a reasonable default is used.
定义该宏为C表达式来创建一个rtl表达式，来引用全局“变量”@code{errno}。
（在一些系统上，@code{errno}可能实际不是一个变量。）如果没有定义该宏，
则会使用一个合理的缺省。
@end defmac

@cindex C99 math functions, implicit usage
@defmac TARGET_C99_FUNCTIONS
@en When this macro is nonzero, GCC will implicitly optimize @code{sin} calls into
@en @code{sinf} and similarly for other functions defined by C99 standard.  The
@en default is zero because a number of existing systems lack support for these
@en functions in their runtime so this macro needs to be redefined to one on
@en systems that do support the C99 runtime.
当该宏非0时，GCC将隐式的优化@code{sin}调用为@code{sinf}，
类似的还有C99标准中定义的其它函数。缺省为非0，这对于大多现代系统是合适的，
然而有一些系统缺少对这些函数的运行时支持，所以它们需要该宏被重定义为0。
@end defmac

@cindex sincos math function, implicit usage
@defmac TARGET_HAS_SINCOS
@en When this macro is nonzero, GCC will implicitly optimize calls to @code{sin}
@en and @code{cos} with the same argument to a call to @code{sincos}.  The
@en default is zero.  The target has to provide the following functions:
当该宏非0时，
GCC将隐式的优化@code{sin}和@code{cos}调用为使用相同参数的@code{sincos}调用。
缺省为0。target必须提供下列函数：
@smallexample
void sincos(double x, double *sin, double *cos);
void sincosf(float x, float *sin, float *cos);
void sincosl(long double x, long double *sin, long double *cos);
@end smallexample
@end defmac

@defmac NEXT_OBJC_RUNTIME
@en Define this macro to generate code for Objective-C message sending using
@en the calling convention of the NeXT system.  This calling convention
@en involves passing the object, the selector and the method arguments all
@en at once to the method-lookup library function.
定义该宏来使用NeXT系统约定为Objective-C消息发送生成代码。
该调用约定包括将对象，选择者和方法一起传递给方法查询库函数。

@en The default calling convention passes just the object and the selector
@en to the lookup function, which returns a pointer to the method.
缺省调用约定只将对象和选择者传递给查询函数，其返回一个指向方法的指针。
@end defmac

@en @node Addressing Modes
@en @section Addressing Modes
@node Addressing Modes
@section 寻址模式
@cindex addressing modes

@c prevent bad page break with this line
@en This is about addressing modes.
这是关于寻址模式的宏。

@defmac HAVE_PRE_INCREMENT
@defmacx HAVE_PRE_DECREMENT
@defmacx HAVE_POST_INCREMENT
@defmacx HAVE_POST_DECREMENT
@en A C expression that is nonzero if the machine supports pre-increment,
@en pre-decrement, post-increment, or post-decrement addressing respectively.
一个C表达式，为非0，如果机器分别支持前增，前减，后增，或者后减寻址。
@end defmac

@defmac HAVE_PRE_MODIFY_DISP
@defmacx HAVE_POST_MODIFY_DISP
@en A C expression that is nonzero if the machine supports pre- or
@en post-address side-effect generation involving constants other than
@en the size of the memory operand.
一个C表达式，非零，如果机器支持pre-或者post-address，
除了生成内存操作数的大小以外，还有常量副作用生成。
@end defmac

@defmac HAVE_PRE_MODIFY_REG
@defmacx HAVE_POST_MODIFY_REG
@en A C expression that is nonzero if the machine supports pre- or
@en post-address side-effect generation involving a register displacement.
一个C表达式，非零，如果机器支持pre-或者post-address，
除了生成内存操作数的大小以外，还有寄存器置换的副作用生成。
@end defmac

@defmac CONSTANT_ADDRESS_P (@var{x})
@en A C expression that is 1 if the RTX @var{x} is a constant which
@en is a valid address.  On most machines the default definition of
@en @code{(CONSTANT_P (@var{x}) && GET_CODE (@var{x}) != CONST_DOUBLE)}
@en is acceptable, but a few machines are more restrictive as to which
@en constant addresses are supported. 
一个C表达式，为1，如果RTX @var{x}为一个常量，其为一个有效地址。
在大多数机器上，这可以被定义为@code{CONSTANT_P (@var{x})}，
但一些机器在支持哪些常量地址方面更加严格。
@end defmac

@defmac CONSTANT_P (@var{x})
@en @code{CONSTANT_P}, which is defined by target-independent code,
@en accepts integer-values expressions whose values are not explicitly
@en known, such as @code{symbol_ref}, @code{label_ref}, and @code{high}
@en expressions and @code{const} arithmetic expressions, in addition to
@en @code{const_int} and @code{const_double} expressions.
@code{CONSTANT_P}，其由target无关代码定义，接受整数值表达式，
其值不被显示的知道，例如@code{symbol_ref}, @code{label_ref}，@code{high}表达式，
以及@code{const}算术表达式，@code{const_int}和@code{const_double}表达式。
@end defmac

@defmac MAX_REGS_PER_ADDRESS
@en A number, the maximum number of registers that can appear in a valid
@en memory address.  Note that it is up to you to specify a value equal to
@en the maximum number that @code{TARGET_LEGITIMATE_ADDRESS_P} would ever
@en accept.
一个数，为可以出现在一个有效的内存地址中的最大寄存器编号。
注意需要你来指定@code{GO_IF_LEGITIMATE_ADDRESS}应该能够接受的等于该最大值的值。
@end defmac

@deftypefn {Target Hook} bool TARGET_LEGITIMATE_ADDRESS_P (enum machine_mode @var{mode}, rtx @var{x}, bool @var{strict})
A function that returns whether @var{x} (an RTX) is a legitimate memory
address on the target machine for a memory operand of mode @var{mode}.

Legitimate addresses are defined in two variants: a strict variant and a
non-strict one.  The @var{strict} parameter chooses which variant is
desired by the caller.

The strict variant is used in the reload pass.  It must be defined so
that any pseudo-register that has not been allocated a hard register is
considered a memory reference.  This is because in contexts where some
kind of register is required, a pseudo-register with no hard register
must be rejected.  For non-hard registers, the strict variant should look
up the @code{reg_renumber} array; it should then proceed using the hard
register number in the array, or treat the pseudo as a memory reference
if the array holds @code{-1}.

The non-strict variant is used in other passes.  It must be defined to
accept all pseudo-registers in every context where some kind of
register is required.

Normally, constant addresses which are the sum of a @code{symbol_ref}
and an integer are stored inside a @code{const} RTX to mark them as
constant.  Therefore, there is no need to recognize such sums
specifically as legitimate addresses.  Normally you would simply
recognize any @code{const} as legitimate.

Usually @code{PRINT_OPERAND_ADDRESS} is not prepared to handle constant
sums that are not marked with  @code{const}.  It assumes that a naked
@code{plus} indicates indexing.  If so, then you @emph{must} reject such
naked constant sums as illegitimate addresses, so that none of them will
be given to @code{PRINT_OPERAND_ADDRESS}.

@cindex @code{TARGET_ENCODE_SECTION_INFO} and address validation
On some machines, whether a symbolic address is legitimate depends on
the section that the address refers to.  On these machines, define the
target hook @code{TARGET_ENCODE_SECTION_INFO} to store the information
into the @code{symbol_ref}, and then check for it here.  When you see a
@code{const}, you will have to look inside it to find the
@code{symbol_ref} in order to determine the section.  @xref{Assembler
Format}.

@cindex @code{GO_IF_LEGITIMATE_ADDRESS}
Some ports are still using a deprecated legacy substitute for
this hook, the @code{GO_IF_LEGITIMATE_ADDRESS} macro.  This macro
has this syntax:

@example
#define GO_IF_LEGITIMATE_ADDRESS (@var{mode}, @var{x}, @var{label})
@end example

@noindent
and should @code{goto @var{label}} if the address @var{x} is a valid
address on the target machine for a memory operand of mode @var{mode}.

@findex REG_OK_STRICT
Compiler source files that want to use the strict variant of this
macro define the macro @code{REG_OK_STRICT}.  You should use an
@code{#ifdef REG_OK_STRICT} conditional to define the strict variant in
that case and the non-strict variant otherwise.

Using the hook is usually simpler because it limits the number of
files that are recompiled when changes are made.
@end deftypefn

@defmac TARGET_MEM_CONSTRAINT
A single character to be used instead of the default @code{'m'}
character for general memory addresses.  This defines the constraint
letter which matches the memory addresses accepted by
@code{TARGET_LEGITIMATE_ADDRESS_P}.  Define this macro if you want to
support new address formats in your back end without changing the
semantics of the @code{'m'} constraint.  This is necessary in order to
preserve functionality of inline assembly constructs using the
@code{'m'} constraint.
@end defmac

@defmac FIND_BASE_TERM (@var{x})
@en A C expression to determine the base term of address @var{x},
@en or to provide a simplified version of @var{x} from which @file{alias.c}
@en can easily find the base term.  This macro is used in only two places:
@en @code{find_base_value} and @code{find_base_term} in @file{alias.c}.
一个C表达式，用来确定地址@var{x}的base term。该宏只在两个地方使用：
@file{alias.c}的@code{find_base_value}和 @code{find_base_term}。

@en It is always safe for this macro to not be defined.  It exists so
@en that alias analysis can understand machine-dependent addresses.
不定义该宏也总是安全的。它的存在是为了别名分析可以理解机器相关的地址。

@en The typical use of this macro is to handle addresses containing
@en a label_ref or symbol_ref within an UNSPEC@.
该宏的典型用法是处理在UNSPEC中包含label_ref或symbol_ref的地址。
@end defmac

@deftypefn {Target Hook} rtx TARGET_LEGITIMIZE_ADDRESS (rtx @var{x}, rtx @var{oldx}, enum machine_mode @var{mode})
This hook is given an invalid memory address @var{x} for an
operand of mode @var{mode} and should try to return a valid memory
address.

@findex break_out_memory_refs
@var{x} will always be the result of a call to @code{break_out_memory_refs},
and @var{oldx} will be the operand that was given to that function to produce
@var{x}.

The code of the hook should not alter the substructure of
@var{x}.  If it transforms @var{x} into a more legitimate form, it
should return the new @var{x}.

It is not necessary for this hook to come up with a legitimate address.
The compiler has standard ways of doing so in all cases.  In fact, it
is safe to omit this hook or make it return @var{x} if it cannot find
a valid way to legitimize the address.  But often a machine-dependent
strategy can generate better code.
@end deftypefn

@defmac LEGITIMIZE_RELOAD_ADDRESS (@var{x}, @var{mode}, @var{opnum}, @var{type}, @var{ind_levels}, @var{win})
@en A C compound statement that attempts to replace @var{x}, which is an address
@en that needs reloading, with a valid memory address for an operand of mode
@en @var{mode}.  @var{win} will be a C statement label elsewhere in the code.
@en It is not necessary to define this macro, but it might be useful for
@en performance reasons.
一条C复合语句，其尝试使用一个机器模式为@var{mode}的操作数的有效内存地址，
来替换地址需要重载的@var{x}。@var{win}为代码中的一个C语句标号。
不必要定义该宏，但其可能会对性能有帮助。

@en For example, on the i386, it is sometimes possible to use a single
@en reload register instead of two by reloading a sum of two pseudo
@en registers into a register.  On the other hand, for number of RISC
@en processors offsets are limited so that often an intermediate address
@en needs to be generated in order to address a stack slot.  By defining
@en @code{LEGITIMIZE_RELOAD_ADDRESS} appropriately, the intermediate addresses
@en generated for adjacent some stack slots can be made identical, and thus
@en be shared.
例如，在i386上，有时可能通过将两个伪寄存器的和重载到一个寄存器中，
从而只使用一个重载寄存器，而不是两个。另一方面，
许多RISC处理器的偏移量是有限制的，使得经常要生成一个中间地址来寻址一个栈槽。
通过适当的定义@code{LEGITIMIZE_RELOAD_ADDRESS}，
为邻近的一些栈槽生成的中间地址可以为同一个，实现共享。

@en @emph{Note}: This macro should be used with caution.  It is necessary
@en to know something of how reload works in order to effectively use this,
@en and it is quite easy to produce macros that build in too much knowledge
@en of reload internals.
注意：该宏应该慎重使用。有必要了解重载是如何工作的，以便有效的使用该宏。

@en @emph{Note}: This macro must be able to reload an address created by a
@en previous invocation of this macro.  If it fails to handle such addresses
@en then the compiler may generate incorrect code or abort.
注意：该宏必须能够重载由该宏的之前调用所创建的地址。
如果不能处理这样的地址，则编译器可能会产生不正确的代码或者中断退出。

@findex push_reload
@en The macro definition should use @code{push_reload} to indicate parts that
@en need reloading; @var{opnum}, @var{type} and @var{ind_levels} are usually
@en suitable to be passed unaltered to @code{push_reload}.
宏定义应该使用@code{push_reload}来指示需要重载的部分；
@var{opnum}，@var{type}和@var{ind_levels}通常无需更改而直接传给@code{push_reload}。

@en The code generated by this macro must not alter the substructure of
@en @var{x}.  If it transforms @var{x} into a more legitimate form, it
@en should assign @var{x} (which will always be a C variable) a new value.
@en This also applies to parts that you change indirectly by calling
@en @code{push_reload}.
该宏生成的代码必须不要修改@var{x}的子结构体。如果其将@var{x}转换成更合法的形式，
则其必须为@var{x}（其总为一个c变量）赋予一个新的值。
这也通常应用于你通过调用@code{push_reload}而间接改变的部分。

@findex strict_memory_address_p
@en The macro definition may use @code{strict_memory_address_p} to test if
@en the address has become legitimate.
宏定义可以使用@code{strict_memory_address_p}来测试地址是否已经为合法的。

@findex copy_rtx
@en If you want to change only a part of @var{x}, one standard way of doing
@en this is to use @code{copy_rtx}.  Note, however, that it unshares only a
@en single level of rtl.  Thus, if the part to be changed is not at the
@en top level, you'll need to replace first the top level.
@en It is not necessary for this macro to come up with a legitimate
@en address;  but often a machine-dependent strategy can generate better code.
如果你只想改变@var{x}的一部分，一种标准的方法是使用@code{copy_rtx}。
但是注意，其只与rtl同一级不共享。因此，如果改变的部分不在顶层，
则你要首先替换顶层。该宏不必要产生一个合法的地址；但是通常机器相关的策略可以产生更好的代码。
@end defmac

@deftypefn {Target Hook} bool TARGET_MODE_DEPENDENT_ADDRESS_P (const_rtx @var{addr})
This hook returns @code{true} if memory address @var{addr} can have
different meanings depending on the machine mode of the memory
reference it is used for or if the address is valid for some modes
but not others.

Autoincrement and autodecrement addresses typically have mode-dependent
effects because the amount of the increment or decrement is the size
of the operand being addressed.  Some machines have other mode-dependent
addresses.  Many RISC machines have no mode-dependent addresses.

You may assume that @var{addr} is a valid address for the machine.

The default version of this hook returns @code{false}.
@end deftypefn

@defmac GO_IF_MODE_DEPENDENT_ADDRESS (@var{addr}, @var{label})
@en A C statement or compound statement with a conditional @code{goto
@en @var{label};} executed if memory address @var{x} (an RTX) can have
@en different meanings depending on the machine mode of the memory
@en reference it is used for or if the address is valid for some modes
@en but not others.
一条C语句或者复合语句，具有一个条件@code{goto @var{label};}；
当内存地址@var{x}（一个RTX）可以具有不同的含义，
该含义取决于内存引用的机器模式时，被执行。

@en Autoincrement and autodecrement addresses typically have mode-dependent
@en effects because the amount of the increment or decrement is the size
@en of the operand being addressed.  Some machines have other mode-dependent
@en addresses.  Many RISC machines have no mode-dependent addresses.
自动递增和自动递减地址通常具有机器模式相关的效果，
因为递增或递减的数量为被寻址的操作数的大小。
一些机器具有其它机器模式相关的地址。许多RISC机器没有机器模式相关的地址。

@en You may assume that @var{addr} is a valid address for the machine.
你可以假设@var{addr}对于机器是一个有效的地址。

These are obsolete macros, replaced by the
@code{TARGET_MODE_DEPENDENT_ADDRESS_P} target hook.
@end defmac

@defmac LEGITIMATE_CONSTANT_P (@var{x})
@en A C expression that is nonzero if @var{x} is a legitimate constant for
@en an immediate operand on the target machine.  You can assume that
@en @var{x} satisfies @code{CONSTANT_P}, so you need not check this.  In fact,
@en @samp{1} is a suitable definition for this macro on machines where
@en anything @code{CONSTANT_P} is valid.
一个C表达式，如果@var{x}对于target机器上的一个立即操作数为合法的常量，
则为非0。你可以假设@var{x}满足@code{CONSTANT_P}，所以不需要进行检查。
实际上，在任何@code{CONSTANT_P}都是有效的机器上，为该宏定义为@samp{1}是合适的。
@end defmac

@deftypefn {Target Hook} rtx TARGET_DELEGITIMIZE_ADDRESS (rtx @var{x})
@en This hook is used to undo the possibly obfuscating effects of the
@en @code{LEGITIMIZE_ADDRESS} and @code{LEGITIMIZE_RELOAD_ADDRESS} target
@en macros.  Some backend implementations of these macros wrap symbol
@en references inside an @code{UNSPEC} rtx to represent PIC or similar
@en addressing modes.  This target hook allows GCC's optimizers to understand
@en the semantics of these opaque @code{UNSPEC}s by converting them back
@en into their original form.
该钩子用于撤销@code{LEGITIMIZE_ADDRESS}和@code{LEGITIMIZE_RELOAD_ADDRESS} target
宏可能造成的模糊效果。这些宏的一些后端实现，
将符号引用包含在一个@code{UNSPEC} rtx中来表示PIC或者类似的寻址模式。
该target钩子允许GCC的优化器来理解这些透明的@code{UNSPEC}的语义，
通过将它们转换回到它们最初的形式。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CANNOT_FORCE_CONST_MEM (rtx @var{x})
@en This hook should return true if @var{x} is of a form that cannot (or
@en should not) be spilled to the constant pool.  The default version of
@en this hook returns false.
该钩子应该返回真，如果@var{x}不能够（或不应该）被溢出到常量池中。
该钩子的缺省版本返回假。

@en The primary reason to define this hook is to prevent reload from
@en deciding that a non-legitimate constant would be better reloaded
@en from the constant pool instead of spilling and reloading a register
@en holding the constant.  This restriction is often true of addresses
@en of TLS symbols for various targets.
定义该钩子的主要原因是阻止重载决定将一个不合法的常量从常量池中重载，
而不是溢出并重载一个寄存器来保存常量。对于不同的target，
该限制对于TLS符号的地址常常是真。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_USE_BLOCKS_FOR_CONSTANT_P (enum machine_mode @var{mode}, const_rtx @var{x})
@en This hook should return true if pool entries for constant @var{x} can
@en be placed in an @code{object_block} structure.  @var{mode} is the mode
@en of @var{x}.
该钩子应该返回真，
如果常量@var{x}的池实体（pool entries）可以放在一个@code{object_block}结构体中。
@var{mode}为@var{x}的机器模式。

@en The default version returns false for all constants.
缺省版本为所有的常量返回假。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_BUILTIN_RECIPROCAL (unsigned @var{fn}, bool @var{md_fn}, bool @var{sqrt})
@en This hook should return the DECL of a function that implements reciprocal of
@en the builtin function with builtin function code @var{fn}, or
@en @code{NULL_TREE} if such a function is not available.  @var{md_fn} is true
@en when @var{fn} is a code of a machine-dependent builtin function.  When
@en @var{sqrt} is true, additional optimizations that apply only to the reciprocal
@en of a square root function are performed, and only reciprocals of @code{sqrt}
@en function are valid.
该钩子应该返回一个函数的decl，该函数实现了代码为@var{fn}的内建函数的倒数，
或者如果没有这样的函数，则返回@code{NULL_TREE}。
当@var{fn}为一个机器相关的内建函数的代码时，@var{tm_fn}为真。
当@var{sqrt}为真时，只对平方根函数进行额外的优化，
并且只有@var{sqrt}函数的倒数可用。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)
@en This hook should return the DECL of a function @var{f} that given an
@en address @var{addr} as an argument returns a mask @var{m} that can be
@en used to extract from two vectors the relevant data that resides in
@en @var{addr} in case @var{addr} is not properly aligned.
该钩子应该返回一个函数@var{f}的decl，给定一个地址@var{addr}作为参数，
该函数返回一个掩码@var{m}，在@var{addr}没有被适当的对齐时，
其可以用于从两个向量中抽取位于@var{addr}中的相关数据。

@en The autovectorizer, when vectorizing a load operation from an address
@en @var{addr} that may be unaligned, will generate two vector loads from
@en the two aligned addresses around @var{addr}. It then generates a
@en @code{REALIGN_LOAD} operation to extract the relevant data from the
@en two loaded vectors. The first two arguments to @code{REALIGN_LOAD},
@en @var{v1} and @var{v2}, are the two vectors, each of size @var{VS}, and
@en the third argument, @var{OFF}, defines how the data will be extracted
@en from these two vectors: if @var{OFF} is 0, then the returned vector is
@en @var{v2}; otherwise, the returned vector is composed from the last
@en @var{VS}-@var{OFF} elements of @var{v1} concatenated to the first
@en @var{OFF} elements of @var{v2}.
自动向量化，当向量化一个加载操作，且地址@var{addr}可以没有对齐，
则会生成两个向量加载，从@var{addr}附件的两个对齐的地址。
其然后生成一个@code{REALIGN_LOAD}操作，来从两个加载的向量中抽取相关数据。
@code{REALIGN_LOAD}的前两个参数，@var{v1}和@var{v2}，为两个向量，
每个的大小为@var{VS}，第三个参数，@var{OFF}，定义了数据如何从这两个向量中抽取：
如果@var{OFF}为0，则返回的向量为@var{V2}；
否则返回的向量由@var{v1}的后@var{VS}-@var{OFF}个元素连接到@var{v2}的前@var{OFF}个元素而组成。

@en If this hook is defined, the autovectorizer will generate a call
@en to @var{f} (using the DECL tree that this hook returns) and will
@en use the return value of @var{f} as the argument @var{OFF} to
@en @code{REALIGN_LOAD}. Therefore, the mask @var{m} returned by @var{f}
@en should comply with the semantics expected by @code{REALIGN_LOAD}
@en described above.
@en If this hook is not defined, then @var{addr} will be used as
@en the argument @var{OFF} to @code{REALIGN_LOAD}, in which case the low
@en log2(@var{VS}) @minus{} 1 bits of @var{addr} will be considered.
如果定义了该钩子，则自动向量化会生成一个对@var{f}的调用（使用该钩子返回的DECL）
并使用@var{f}的返回值作为@code{REALIGN_LOAD}的参数@var{OFF}。因此，
@var{f}返回的掩码@var{m}应该遵守@code{REALIGN_LOAD}所期望的上面描述的语义。
如果该钩子没有被定义，
则@var{addr}将作为@code{REALIGN_LOAD}的参数@var{OFF}来使用，
这种情况下将会考虑@var{addr}的低log2(@var{VS})-1位。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN (tree @var{x})
@en This hook should return the DECL of a function @var{f} that implements
@en widening multiplication of the even elements of two input vectors of type @var{x}.
该钩子应该返回一个函数@var{f}的decl，
该函数实现了两个类型为@var{x}的输入向量作为偶数元素的加宽乘法。

@en If this hook is defined, the autovectorizer will use it along with the
@en @code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD} target hook when vectorizing
@en widening multiplication in cases that the order of the results does not have to be
@en preserved (e.g.@: used only by a reduction computation). Otherwise, the
@en @code{widen_mult_hi/lo} idioms will be used.
如果定义了该钩子，则自动化向量当进行向量化加宽乘法时，
将会使用它和@code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD} target钩子，
以防结果顺序不需要被保存（例如，只用于减法计算）。
否则将使用@code{widen_mult_hi/lo}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD (tree @var{x})
@en This hook should return the DECL of a function @var{f} that implements
@en widening multiplication of the odd elements of two input vectors of type @var{x}.
该钩子应该返回一个函数@var{f}的decl，
该函数实现了两个类型为@var{x}的输入向量作为奇数元素的加宽乘法。

@en If this hook is defined, the autovectorizer will use it along with the
@en @code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN} target hook when vectorizing
@en widening multiplication in cases that the order of the results does not have to be
@en preserved (e.g.@: used only by a reduction computation). Otherwise, the
@en @code{widen_mult_hi/lo} idioms will be used.
如果定义了该钩子，则自动化向量当进行向量化加宽乘法时，
将会使用它和@code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN} target钩子，
以防结果顺序不需要被保存（例如，只用于减法计算）。
否则将使用@code{widen_mult_hi/lo}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST (enum vect_cost_for_stmt @var{type_of_cost}, tree @var{vectype}, int @var{misalign})
Returns cost of different scalar or vector statements for vectorization cost model.
For vector memory operations the cost may depend on type (@var{vectype}) and 
misalignment value (@var{misalign}).
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE (const_tree @var{type}, bool @var{is_packed})
Return true if vector alignment is reachable (by peeling N iterations) for the given type.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VEC_PERM (tree @var{type}, tree *@var{mask_element_type})
Target builtin that implements vector permute.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK (tree @var{vec_type}, tree @var{mask})
Return true if a vector created for @code{builtin_vec_perm} is valid.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_CONVERSION (unsigned @var{code}, tree @var{dest_type}, tree @var{src_type})
@en This hook should return the DECL of a function that implements conversion of the
@en input vector of type @var{src_type} to type @var{dest_type}.
@en The value of @var{code} is one of the enumerators in @code{enum tree_code} and
@en specifies how the conversion is to be applied
@en (truncation, rounding, etc.).
该钩子应该返回一个函数的decl，该函数实现了类型为@var{type}的输入向量的转换。
如果@var{type}为一个整数类型，则转换结果为一个同样大小的浮点类型的向量。
如果@var{type}为浮点类型，则转换结果为一个同样大小的整数类型的向量。
@var{code}指定了如何应用转换（截断，舍入，等）。

@en If this hook is defined, the autovectorizer will use the
@en @code{TARGET_VECTORIZE_BUILTIN_CONVERSION} target hook when vectorizing
@en conversion. Otherwise, it will return @code{NULL_TREE}.
如果定义了该钩子，则自动向量化当进行向量化转换时，
会使用@code{TARGET_VECTORIZE_BUILTIN_CONVERSION} target钩子。
否则，其应该返回@code{NULL_TREE}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (tree @var{fndecl}, tree @var{vec_type_out}, tree @var{vec_type_in})
@en This hook should return the decl of a function that implements the
@en vectorized variant of the builtin function with builtin function code
@en @var{code} or @code{NULL_TREE} if such a function is not available.
@en The value of @var{fndecl} is the builtin function declaration.  The
@en return type of the vectorized function shall be of vector type
@en @var{vec_type_out} and the argument types should be @var{vec_type_in}.
该钩子应该返回一个函数的decl，
该函数实现了代码为@var{code}的内建函数的向量化变体，
或者如果没有这样的函数则返回@code{NULL_TREE}。
向量化的函数的返回类型应该为向量类型@var{vec_type_out}，
并且参数类型应该为@var{vec_type_in}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT (enum machine_mode @var{mode}, const_tree @var{type}, int @var{misalignment}, bool @var{is_packed})
This hook should return true if the target supports misaligned vector
store/load of a specific factor denoted in the @var{misalignment}
parameter.  The vector store/load should be of machine mode @var{mode} and
the elements in the vectors should be of type @var{type}.  @var{is_packed}
parameter is true if the memory access is defined in a packed struct.
@end deftypefn

@deftypefn {Target Hook} {enum machine_mode} TARGET_VECTORIZE_PREFERRED_SIMD_MODE (enum machine_mode @var{mode})
This hook should return the preferred mode for vectorizing scalar
mode @var{mode}.  The default is
equal to @code{word_mode}, because the vectorizer can do some
transformations even in absence of specialized @acronym{SIMD} hardware.
@end deftypefn

@deftypefn {Target Hook} {unsigned int} TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES (void)
This hook should return a mask of sizes that should be iterated over
after trying to autovectorize using the vector size derived from the
mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.
The default is zero which means to not iterate over other vector sizes.
@end deftypefn

@en @node Anchored Addresses
@en @section Anchored Addresses
@node Anchored Addresses
@section 锚定的地址
@cindex anchored addresses
@cindex @option{-fsection-anchors}

@en GCC usually addresses every static object as a separate entity.
@en For example, if we have:
GCC通常将每一个静态对象作为一个单独的实体来寻址。例如，如果我们有：

@smallexample
static int a, b, c;
int foo (void) @{ return a + b + c; @}
@end smallexample

@en the code for @code{foo} will usually calculate three separate symbolic
@en addresses: those of @code{a}, @code{b} and @code{c}.  On some targets,
@en it would be better to calculate just one symbolic address and access
@en the three variables relative to it.  The equivalent pseudocode would
@en be something like:
@code{foo}的代码通常会计算三个独立的符号地址：@code{a}，@code{b}和@code{c}的。
在一些target上，只计算一个符号地址并且通过相对地址来访问这三个变量会更好些。
等价的伪代码可能为：

@smallexample
int foo (void)
@{
  register int *xr = &x;
  return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
@}
@end smallexample

@en (which isn't valid C).  We refer to shared addresses like @code{x} as
@en ``section anchors''.  Their use is controlled by @option{-fsection-anchors}.
（这不是有效的C）。我们称像@code{x}这样的共享地址为“section anchors”。
它们的用法由@option{-fsection-anchors}控制。

@en The hooks below describe the target properties that GCC needs to know
@en in order to make effective use of section anchors.  It won't use
@en section anchors at all unless either @code{TARGET_MIN_ANCHOR_OFFSET}
@en or @code{TARGET_MAX_ANCHOR_OFFSET} is set to a nonzero value.
下面的钩子描述了GCC需要知道的target属性，以便有效利用section anchors。
除非@code{TARGET_MIN_ANCHOR_OFFSET}或@code{TARGET_MAX_ANCHOR_OFFSET}
被设为一个非0的值，否则section anchors根本不会被使用。

@deftypevr {Target Hook} HOST_WIDE_INT TARGET_MIN_ANCHOR_OFFSET
@en The minimum offset that should be applied to a section anchor.
@en On most targets, it should be the smallest offset that can be
@en applied to a base register while still giving a legitimate address
@en for every mode.  The default value is 0.
应该应用到section anchor的最小偏移量。在大多数target上，
其应该为可以应用到基址寄存器并且对每种机器模式都可以给出合法地址的最小偏移量。
缺省值为0。
@end deftypevr

@deftypevr {Target Hook} HOST_WIDE_INT TARGET_MAX_ANCHOR_OFFSET
@en Like @code{TARGET_MIN_ANCHOR_OFFSET}, but the maximum (inclusive)
@en offset that should be applied to section anchors.  The default
@en value is 0.
类似@code{TARGET_MIN_ANCHOR_OFFSET}，
但是为可以应用到section anchors的最大(包括)偏移量。缺省为0。
@end deftypevr

@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_ANCHOR (rtx @var{x})
@en Write the assembly code to define section anchor @var{x}, which is a
@en @code{SYMBOL_REF} for which @samp{SYMBOL_REF_ANCHOR_P (@var{x})} is true.
@en The hook is called with the assembly output position set to the beginning
@en of @code{SYMBOL_REF_BLOCK (@var{x})}.
写汇编代码来定义section anchor @var{x}，其为一个@code{SYMBOL_REF}，
并且@samp{SYMBOL_REF_ANCHOR_P (@var{x})}为真。该钩子被调用时，
汇编输出位置被设为@code{SYMBOL_REF_BLOCK (@var{x})}的起始处。

@en If @code{ASM_OUTPUT_DEF} is available, the hook's default definition uses
@en it to define the symbol as @samp{. + SYMBOL_REF_BLOCK_OFFSET (@var{x})}.
@en If @code{ASM_OUTPUT_DEF} is not available, the hook's default definition
@en is @code{NULL}, which disables the use of section anchors altogether.
如果@code{ASM_OUTPUT_DEF}可用，
则钩子的缺省定义使用它来定义符号为@samp{. + SYMBOL_REF_BLOCK_OFFSET (@var{x})}。
如果@code{ASM_OUTPUT_DEF}不可用，则钩子的缺省定义为@code{NULL}，
其禁止了section anchors的使用。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_USE_ANCHORS_FOR_SYMBOL_P (const_rtx @var{x})
@en Return true if GCC should attempt to use anchors to access @code{SYMBOL_REF}
@en @var{x}.  You can assume @samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})} and
@en @samp{!SYMBOL_REF_ANCHOR_P (@var{x})}.
返回真，如果GCC应该尝试使用anchors来访问@code{SYMBOL_REF} @var{x}。
你可以假设@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}和
@samp{!SYMBOL_REF_ANCHOR_P (@var{x})}。

@en The default version is correct for most targets, but you might need to
@en intercept this hook to handle things like target-specific attributes
@en or target-specific sections.
缺省版本对于大多数target都正确，
但是你可能需要截取该钩子来处理target特定的属性或者target特定的section。
@end deftypefn

@en @node Condition Code
@en @section Condition Code Status
@node Condition Code
@section 条件代码状态
@cindex condition code status

The macros in this section can be split in two families, according to the
two ways of representing condition codes in GCC.

The first representation is the so called @code{(cc0)} representation
(@pxref{Jump Patterns}), where all instructions can have an implicit
clobber of the condition codes.  The second is the condition code
register representation, which provides better schedulability for
architectures that do have a condition code register, but on which
most instructions do not affect it.  The latter category includes
most RISC machines.

The implicit clobbering poses a strong restriction on the placement of
the definition and use of the condition code, which need to be in adjacent
insns for machines using @code{(cc0)}.  This can prevent important
optimizations on some machines.  For example, on the IBM RS/6000, there
is a delay for taken branches unless the condition code register is set
three instructions earlier than the conditional branch.  The instruction
scheduler cannot perform this optimization if it is not permitted to
separate the definition and use of the condition code register.

For this reason, it is possible and suggested to use a register to
represent the condition code for new ports.  If there is a specific
condition code register in the machine, use a hard register.  If the
condition code or comparison result can be placed in any general register,
or if there are multiple condition registers, use a pseudo register.
Registers used to store the condition code value will usually have a mode
that is in class @code{MODE_CC}.

Alternatively, you can use @code{BImode} if the comparison operator is
specified already in the compare instruction.  In this case, you are not
interested in most macros in this section.

@menu
* CC0 Condition Codes::      Old style representation of condition codes.
* MODE_CC Condition Codes::  Modern representation of condition codes.
* Cond Exec Macros::         Macros to control conditional execution.
@end menu

@node CC0 Condition Codes
@subsection Representation of condition codes using @code{(cc0)}
@findex cc0

@findex cc_status
@en The file @file{conditions.h} defines a variable @code{cc_status} to
@en describe how the condition code was computed (in case the interpretation of
@en the condition code depends on the instruction that it was set by).  This
@en variable contains the RTL expressions on which the condition code is
@en currently based, and several standard flags.
文件@file{conditions.h}定义了变量@code{cc_status}，
用来描述条件代码如何被计算（对于条件代码的解释取决于设置它的指令的情况）。
该变量包含了条件码目前基于的RTL表达式，以及一些标准的标记。

@en Sometimes additional machine-specific flags must be defined in the machine
@en description header file.  It can also add additional machine-specific
@en information by defining @code{CC_STATUS_MDEP}.
有时额外的机器特定的标记必须被定义，在机器描述头文件中。
其还可以增加额外的机器特定信息，通过定义@code{CC_STATUS_MDEP}。

@defmac CC_STATUS_MDEP
@en C code for a data type which is used for declaring the @code{mdep}
@en component of @code{cc_status}.  It defaults to @code{int}.
一个数据类型的C代码，其用于声明@code{cc_status}的@code{mdep}部件。
缺省为@code{int}。

@en This macro is not used on machines that do not use @code{cc0}.
该宏在不使用@code{cc0}的机器上不被使用。
@end defmac

@defmac CC_STATUS_MDEP_INIT
@en A C expression to initialize the @code{mdep} field to ``empty''.
@en The default definition does nothing, since most machines don't use
@en the field anyway.  If you want to use the field, you should probably
@en define this macro to initialize it.
一个C表达式，用来初始化@code{mdep}域为“空”。缺省定义不做任何事，
因为大多数机器不使用该域。如果你想使用该域，则可能应该定义该宏来初始化它。

@en This macro is not used on machines that do not use @code{cc0}.
该宏在不使用@code{cc0}的机器上不被使用。
@end defmac

@defmac NOTICE_UPDATE_CC (@var{exp}, @var{insn})
@en A C compound statement to set the components of @code{cc_status}
@en appropriately for an insn @var{insn} whose body is @var{exp}.  It is
@en this macro's responsibility to recognize insns that set the condition
@en code as a byproduct of other activity as well as those that explicitly
@en set @code{(cc0)}.
一个C复合语句，用来适当的为主体为@var{exp}的@var{insn}，
设置@code{cc_status}的部件。
该宏负责识别insn将条件码设置作为副产品以及显示的set @code{(cc0)}。

@en This macro is not used on machines that do not use @code{cc0}.
该宏在不使用@code{cc0}的机器上不被使用。

@en If there are insns that do not set the condition code but do alter
@en other machine registers, this macro must check to see whether they
@en invalidate the expressions that the condition code is recorded as
@en reflecting.  For example, on the 68000, insns that store in address
@en registers do not set the condition code, which means that usually
@en @code{NOTICE_UPDATE_CC} can leave @code{cc_status} unaltered for such
@en insns.  But suppose that the previous insn set the condition code
@en based on location @samp{a4@@(102)} and the current insn stores a new
@en value in @samp{a4}.  Although the condition code is not changed by
@en this, it will no longer be true that it reflects the contents of
@en @samp{a4@@(102)}.  Therefore, @code{NOTICE_UPDATE_CC} must alter
@en @code{cc_status} in this case to say that nothing is known about the
@en condition code value.
如果insn不设置条件码，但修改其它机器寄存器，
则该宏必须检查它们是否使得记录条件码的表达式变为无效。例如，在68000上，
在地址寄存器上存储insn不设置条件码，
其意味着通常@code{NOTICE_UPDATE_CC}对于这样的insn可以不修改@code{cc_status}。
但是假设之前的insn将条件码设成基于位置@samp{a4@@(102)}，
并且当前insn在@samp{a4}上存储了一个新值。虽然条件码没有被改变，
但其不再为真，因为其反映了@samp{a4@@(102)}的内容。因此对于这种情况，
@code{NOTICE_UPDATE_CC}必须修改@code{cc_status}，来表示条件码值不可知。

@en The definition of @code{NOTICE_UPDATE_CC} must be prepared to deal
@en with the results of peephole optimization: insns whose patterns are
@en @code{parallel} RTXs containing various @code{reg}, @code{mem} or
@en constants which are just the operands.  The RTL structure of these
@en insns is not sufficient to indicate what the insns actually do.  What
@en @code{NOTICE_UPDATE_CC} should do when it sees one is just to run
@en @code{CC_STATUS_INIT}.
@code{NOTICE_UPDATE_CC}的定义必须要准备处理窥孔优化的结果：
insn的指令模式为@code{parallel} RTXs，其包含了不同的@code{reg}，
@code{mem}或者常量操作数。这些insn的RTL结构体不足以表明insn实际要做的事情。
@code{NOTICE_UPDATE_CC}应该做的是当遇到这样的，就直接运行@code{CC_STATUS_INIT}。

@en A possible definition of @code{NOTICE_UPDATE_CC} is to call a function
@en that looks at an attribute (@pxref{Insn Attributes}) named, for example,
@en @samp{cc}.  This avoids having detailed information about patterns in
@en two places, the @file{md} file and in @code{NOTICE_UPDATE_CC}.
@code{NOTICE_UPDATE_CC}可能的定义为调用一个函数，
来查看一个属性（@pxref{Insn Attributes}），例如名为@samp{cc}。这避免了在两个地方，
@file{md}文件和@code{NOTICE_UPDATE_CC}中具有指令模式的详细信息。
@end defmac

@node MODE_CC Condition Codes
@subsection Representation of condition codes using registers
@findex CCmode
@findex MODE_CC

@defmac SELECT_CC_MODE (@var{op}, @var{x}, @var{y})
On many machines, the condition code may be produced by other instructions
than compares, for example the branch can use directly the condition
code set by a subtract instruction.  However, on some machines
when the condition code is set this way some bits (such as the overflow
bit) are not set in the same way as a test instruction, so that a different
branch instruction must be used for some conditional branches.  When
this happens, use the machine mode of the condition code register to
record different formats of the condition code register.  Modes can
also be used to record which compare instruction (e.g. a signed or an
unsigned comparison) produced the condition codes.

If other modes than @code{CCmode} are required, add them to
@file{@var{machine}-modes.def} and define @code{SELECT_CC_MODE} to choose
a mode given an operand of a compare.  This is needed because the modes
have to be chosen not only during RTL generation but also, for example,
by instruction combination.  The result of @code{SELECT_CC_MODE} should
be consistent with the mode used in the patterns; for example to support
the case of the add on the SPARC discussed above, we have the pattern

@smallexample
(define_insn ""
  [(set (reg:CC_NOOV 0)
        (compare:CC_NOOV
          (plus:SI (match_operand:SI 0 "register_operand" "%r")
                   (match_operand:SI 1 "arith_operand" "rI"))
          (const_int 0)))]
  ""
  "@dots{}")
@end smallexample

@noindent
together with a @code{SELECT_CC_MODE} that returns @code{CC_NOOVmode}
for comparisons whose argument is a @code{plus}:

@smallexample
#define SELECT_CC_MODE(OP,X,Y) \
  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT          \
   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)    \
   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS    \
       || GET_CODE (X) == NEG) \
      ? CC_NOOVmode : CCmode))
@end smallexample

Another reason to use modes is to retain information on which operands
were used by the comparison; see @code{REVERSIBLE_CC_MODE} later in
this section.

@en You should define this macro if and only if you define extra CC modes
@en in @file{@var{machine}-modes.def}.
你应该定义该宏，当且仅当你在@file{@var{machine}-modes.def}中定义了额外的CC机器模式。
@end defmac

@defmac CANONICALIZE_COMPARISON (@var{code}, @var{op0}, @var{op1})
@en On some machines not all possible comparisons are defined, but you can
@en convert an invalid comparison into a valid one.  For example, the Alpha
@en does not have a @code{GT} comparison, but you can use an @code{LT}
@en comparison instead and swap the order of the operands.
在一些机器上，并不是所有可能的比较都被定义，
但你可以将一个无效的比较转换为一个有效的。例如，Alpha没有@code{GT}比较，
但你可以使用@code{LT}比较来替代，并且交换操作数的顺序。

@en On such machines, define this macro to be a C statement to do any
@en required conversions.  @var{code} is the initial comparison code
@en and @var{op0} and @var{op1} are the left and right operands of the
@en comparison, respectively.  You should modify @var{code}, @var{op0}, and
@en @var{op1} as required.
在一些机器上，定义该宏为一条C语句来做任何需要的转换。
@var{code}为初始化比较代码，@var{op0}和@var{op1}为比较的左，右操作数。
你应该根据需要来修改@var{code}，@var{op0}和@var{op1}。

@en GCC will not assume that the comparison resulting from this macro is
@en valid but will see if the resulting insn matches a pattern in the
@en @file{md} file.
GCC将不假设该宏的比较结果为有效的，
但会查看结果insn是否匹配@file{md}文件中的指令模式。

@en You need not define this macro if it would never change the comparison
@en code or operands.
你不需要定义该宏，如果其不会改变比较代码或者操作数。
@end defmac

@defmac REVERSIBLE_CC_MODE (@var{mode})
@en A C expression whose value is one if it is always safe to reverse a
@en comparison whose mode is @var{mode}.  If @code{SELECT_CC_MODE}
@en can ever return @var{mode} for a floating-point inequality comparison,
@en then @code{REVERSIBLE_CC_MODE (@var{mode})} must be zero.
一个C表达式，其值为1，如果总是可以安全的将模式为@var{mode}的比较运算逆转。
如果@code{SELECT_CC_MODE}可以为浮点不等于比较返回@var{mode}，
则@code{REVERSIBLE_CC_MODE (@var{mode})}必须为0。

@en You need not define this macro if it would always returns zero or if the
@en floating-point format is anything other than @code{IEEE_FLOAT_FORMAT}.
@en For example, here is the definition used on the SPARC, where floating-point
@en inequality comparisons are always given @code{CCFPEmode}:
你不需要定义该宏，如果其总是返回0，
或者如果浮点格式不是@code{IEEE_FLOAT_FORMAT}。
例如，这是在SPARC上的定义，其中浮点不等于比较总是为@code{CCFPEmode}：

@smallexample
#define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)
@end smallexample
@end defmac

@defmac REVERSE_CONDITION (@var{code}, @var{mode})
@en A C expression whose value is reversed condition code of the @var{code} for
@en comparison done in CC_MODE @var{mode}.  The macro is used only in case
@en @code{REVERSIBLE_CC_MODE (@var{mode})} is nonzero.  Define this macro in case
@en machine has some non-standard way how to reverse certain conditionals.  For
@en instance in case all floating point conditions are non-trapping, compiler may
@en freely convert unordered compares to ordered one.  Then definition may look
@en like:
一个C表达式，其值为按照CC_MODE模式进行比较的条件码的逆转。
宏只用于@code{REVERSIBLE_CC_MODE (@var{mode})}为非0的情况。
当机器具有某种非标准的方式来反转特定条件时，定义该宏。
例如，当所有浮点条件为非陷阱的，编译器可以自由的转换未排序的比较为排序的。
则定义可以为：

@smallexample
#define REVERSE_CONDITION(CODE, MODE) \
   ((MODE) != CCFPmode ? reverse_condition (CODE) \
    : reverse_condition_maybe_unordered (CODE))
@end smallexample
@end defmac

@deftypefn {Target Hook} bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *@var{p1}, unsigned int *@var{p2})

On targets which do not use @code{(cc0)}, and which use a hard
register rather than a pseudo-register to hold condition codes, the
regular CSE passes are often not able to identify cases in which the
hard register is set to a common value.  Use this hook to enable a
small pass which optimizes such cases.  This hook should return true
to enable this pass, and it should set the integers to which its
arguments point to the hard register numbers used for condition codes.
When there is only one such register, as is true on most systems, the
integer pointed to by @var{p2} should be set to
@code{INVALID_REGNUM}.

The default version of this hook returns false.
@end deftypefn

@deftypefn {Target Hook} {enum machine_mode} TARGET_CC_MODES_COMPATIBLE (enum machine_mode @var{m1}, enum machine_mode @var{m2})
On targets which use multiple condition code modes in class
@code{MODE_CC}, it is sometimes the case that a comparison can be
validly done in more than one mode.  On such a system, define this
target hook to take two mode arguments and to return a mode in which
both comparisons may be validly done.  If there is no such mode,
return @code{VOIDmode}.

The default version of this hook checks whether the modes are the
same.  If they are, it returns that mode.  If they are different, it
returns @code{VOIDmode}.
@end deftypefn

@node Cond Exec Macros
@subsection Macros to control conditional execution
@findex conditional execution
@findex predication

There is one macro that may need to be defined for targets
supporting conditional execution, independent of how they
represent conditional branches.

@defmac REVERSE_CONDEXEC_PREDICATES_P (@var{op1}, @var{op2})
@en A C expression that returns true if the conditional execution predicate
@en @var{op1}, a comparison operation, is the inverse of @var{op2} and vice
@en versa.  Define this to return 0 if the target has conditional execution
@en predicates that cannot be reversed safely.  There is no need to validate
@en that the arguments of op1 and op2 are the same, this is done separately.
@en If no expansion is specified, this macro is defined as follows:
C表达式，返回真，如果条件执行断言@var{op1}，一个比较操作，为@var{op2}的反转，
反之亦然。定义该宏返回0，如果target具有条件执行断言，且不能被安全的反转。
不需要验证参数op1和op2相等，这已经被单独执行过。如果没有指定，该宏被定义为：

@smallexample
#define REVERSE_CONDEXEC_PREDICATES_P (x, y) \
   (GET_CODE ((x)) == reversed_comparison_code ((y), NULL))
@end smallexample
@end defmac

@en @node Costs
@en @section Describing Relative Costs of Operations
@node Costs
@section 描述操作的相对代价
@cindex costs of instructions
@cindex relative costs
@cindex speed of instructions

@en These macros let you describe the relative speed of various operations
@en on the target machine.
这些宏让你描述target机器上各种操作的相对速度。

@defmac REGISTER_MOVE_COST (@var{mode}, @var{from}, @var{to})
@en A C expression for the cost of moving data of mode @var{mode} from a
@en register in class @var{from} to one in class @var{to}.  The classes are
@en expressed using the enumeration values such as @code{GENERAL_REGS}.  A
@en value of 2 is the default; other values are interpreted relative to
@en that.
一个C表达式，
为从寄存器类别@var{from}到类别@var{to}移动模式为@var{mode}的数据的代价。
类别使用枚举值表示，例如@code{GENERAL_REGS}。缺省值为2；其它值相对于它来解析。

@en It is not required that the cost always equal 2 when @var{from} is the
@en same as @var{to}; on some machines it is expensive to move between
@en registers if they are not general registers.
当@var{from}与@var{to}相同时，并不要求代价总是为2；在一些机器上，
如果不是通用寄存器，则寄存器之间的移动代价是昂贵的。

@en If reload sees an insn consisting of a single @code{set} between two
@en hard registers, and if @code{REGISTER_MOVE_COST} applied to their
@en classes returns a value of 2, reload does not check to ensure that the
@en constraints of the insn are met.  Setting a cost of other than 2 will
@en allow reload to verify that the constraints are met.  You should do this
@en if the @samp{mov@var{m}} pattern's constraints do not allow such copying.
如果重载遇到一个insn，由两个硬件寄存器之间的单个@code{set}组成，
并且如果@code{REGISTER_MOVE_COST}应用到它们的类别上返回2，
则重载不检查insn的约束是否满足。将代价设为2以外的值将允许重载验证约束是否满足。
如果@samp{mov@var{m}}模式的约束不允许这样的复制，则你应该这样做。

These macros are obsolete, new ports should use the target hook
@code{TARGET_REGISTER_MOVE_COST} instead.
@end defmac

@deftypefn {Target Hook} int TARGET_REGISTER_MOVE_COST (enum machine_mode @var{mode}, reg_class_t @var{from}, reg_class_t @var{to})
This target hook should return the cost of moving data of mode @var{mode}
from a register in class @var{from} to one in class @var{to}.  The classes
are expressed using the enumeration values such as @code{GENERAL_REGS}.
A value of 2 is the default; other values are interpreted relative to
that.

It is not required that the cost always equal 2 when @var{from} is the
same as @var{to}; on some machines it is expensive to move between
registers if they are not general registers.

If reload sees an insn consisting of a single @code{set} between two
hard registers, and if @code{TARGET_REGISTER_MOVE_COST} applied to their
classes returns a value of 2, reload does not check to ensure that the
constraints of the insn are met.  Setting a cost of other than 2 will
allow reload to verify that the constraints are met.  You should do this
if the @samp{mov@var{m}} pattern's constraints do not allow such copying.

The default version of this function returns 2.
@end deftypefn

@defmac MEMORY_MOVE_COST (@var{mode}, @var{class}, @var{in})
@en A C expression for the cost of moving data of mode @var{mode} between a
@en register of class @var{class} and memory; @var{in} is zero if the value
@en is to be written to memory, nonzero if it is to be read in.  This cost
@en is relative to those in @code{REGISTER_MOVE_COST}.  If moving between
@en registers and memory is more expensive than between two registers, you
@en should define this macro to express the relative cost.
一个C表达式，
为在寄存器类别@var{class}和内存之间移动模式为@var{mode}的数据的代价；
@var{in}为0，如果值要被写到内存中，非0，如果要从内存中读进。
该代价为@code{REGISTER_MOVE_COST}的相对值。
如果在寄存器和内存间移动比两个寄存器之间更昂贵，则应该定义该宏来表示相对代价。

@en If you do not define this macro, GCC uses a default cost of 4 plus
@en the cost of copying via a secondary reload register, if one is
@en needed.  If your machine requires a secondary reload register to copy
@en between memory and a register of @var{class} but the reload mechanism is
@en more complex than copying via an intermediate, define this macro to
@en reflect the actual cost of the move.
如果你没有定义该宏，如果需要的话，
则GCC使用缺省值4加上通过第二个重载寄存器复制的代价。
如果你的机器需要第二个重载寄存器在内存和寄存器类别@var{class}直接复制，
但是重载机制比通过中间物质复制更复杂，则定义该宏来反映move的实际代价。

@en GCC defines the function @code{memory_move_secondary_cost} if
@en secondary reloads are needed.  It computes the costs due to copying via
@en a secondary register.  If your machine copies from memory using a
@en secondary register in the conventional way but the default base value of
@en 4 is not correct for your machine, define this macro to add some other
@en value to the result of that function.  The arguments to that function
@en are the same as to this macro.
GCC定义函数@code{memory_move_secondary_cost}，如果需要第二次重载。
其根据通过第二个寄存器复制来计算代价。
如果你的机器使用第二个寄存器按照约定的方式从内存中复制，
但是缺省值4对你的机器不正确，则定义该宏来增加某个其它值作为那个函数的结果。
函数的参数与该宏相同。

These macros are obsolete, new ports should use the target hook
@code{TARGET_MEMORY_MOVE_COST} instead.
@end defmac

@deftypefn {Target Hook} int TARGET_MEMORY_MOVE_COST (enum machine_mode @var{mode}, reg_class_t @var{rclass}, bool @var{in})
This target hook should return the cost of moving data of mode @var{mode}
between a register of class @var{rclass} and memory; @var{in} is @code{false}
if the value is to be written to memory, @code{true} if it is to be read in.
This cost is relative to those in @code{TARGET_REGISTER_MOVE_COST}.
If moving between registers and memory is more expensive than between two
registers, you should add this target hook to express the relative cost.

If you do not add this target hook, GCC uses a default cost of 4 plus
the cost of copying via a secondary reload register, if one is
needed.  If your machine requires a secondary reload register to copy
between memory and a register of @var{rclass} but the reload mechanism is
more complex than copying via an intermediate, use this target hook to
reflect the actual cost of the move.

GCC defines the function @code{memory_move_secondary_cost} if
secondary reloads are needed.  It computes the costs due to copying via
a secondary register.  If your machine copies from memory using a
secondary register in the conventional way but the default base value of
4 is not correct for your machine, use this target hook to add some other
value to the result of that function.  The arguments to that function
are the same as to this target hook.
@end deftypefn

@defmac BRANCH_COST (@var{speed_p}, @var{predictable_p})
A C expression for the cost of a branch instruction.  A value of 1 is the
default; other values are interpreted relative to that. Parameter @var{speed_p}
is true when the branch in question should be optimized for speed.  When
it is false, @code{BRANCH_COST} should be returning value optimal for code size
rather then performance considerations.  @var{predictable_p} is true for well
predictable branches. On many architectures the @code{BRANCH_COST} can be
reduced then.
一个C表达式，为分支指令的代价。缺省值为1；其它值相对于它来解析。
@end defmac

@en Here are additional macros which do not specify precise relative costs,
@en but only that certain actions are more expensive than GCC would
@en ordinarily expect.
这些是额外的宏，其不指定确切的相对代价，而只是指定特定的动作比GCC通常期望的要昂贵。

@defmac SLOW_BYTE_ACCESS
@en Define this macro as a C expression which is nonzero if accessing less
@en than a word of memory (i.e.@: a @code{char} or a @code{short}) is no
@en faster than accessing a word of memory, i.e., if such access
@en require more than one instruction or if there is no difference in cost
@en between byte and (aligned) word loads.
定义该宏为一个C表达式，如果访问小于一个字的内存
（即@code{char}或者@code{short}）不如访问一个字的内存快，即，
如果这样的访问需要多于一条的指令，并且如果字节和（对齐的）字加载的代价没有区别，
则值为非零。

@en When this macro is not defined, the compiler will access a field by
@en finding the smallest containing object; when it is defined, a fullword
@en load will be used if alignment permits.  Unless bytes accesses are
@en faster than word accesses, using word accesses is preferable since it
@en may eliminate subsequent memory access if subsequent accesses occur to
@en other fields in the same word of the structure, but to different bytes.
当该宏没有被定义，则编译器将通过找到最小的包含对象来访问一个域；当其被定义，
如果允许对齐，则会使用全字的加载。除非字节访问比字访问快，则使用字访问比较好，
因为其可以消除后续的内存访问，如果后续的访问发生在结构体的相同字的其它域。
@end defmac

@defmac SLOW_UNALIGNED_ACCESS (@var{mode}, @var{alignment})
@en Define this macro to be the value 1 if memory accesses described by the
@en @var{mode} and @var{alignment} parameters have a cost many times greater
@en than aligned accesses, for example if they are emulated in a trap
@en handler.
定义该宏的值为1，
如果由@var{mode}和@var{alignment}参数描述的内存访问比对齐的访问具有多倍的代价，
例如如果它们在陷阱处理中被模拟。

@en When this macro is nonzero, the compiler will act as if
@en @code{STRICT_ALIGNMENT} were nonzero when generating code for block
@en moves.  This can cause significantly more instructions to be produced.
@en Therefore, do not set this macro nonzero if unaligned accesses only add a
@en cycle or two to the time for a memory access.
当该宏为非0时，编译器在为块移动生成代码时，
将按照@code{STRICT_ALIGNMENT}为非0的方式执行。这可以引起相当多的指令被产生。
因此如果非对齐访问只是增加一个周期或者两个，则不要设置该宏为非零。

@en If the value of this macro is always zero, it need not be defined.  If
@en this macro is defined, it should produce a nonzero value when
@en @code{STRICT_ALIGNMENT} is nonzero.
如果该宏的值总是0，则不需要被定义。如果该宏被定义，其应该产生一个非0值，
当@code{STRICT_ALIGNMENT}非0时。
@end defmac

@defmac MOVE_RATIO (@var{speed})
@en The threshold of number of scalar memory-to-memory move insns, @emph{below}
@en which a sequence of insns should be generated instead of a
@en string move insn or a library call.  Increasing the value will always
@en make code faster, but eventually incurs high cost in increased code size.
标量的内存到内存的move insn的临界数，@emph{低于}其值的时候，
应该生成一个insn序列，而不是字符串move insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

@en Note that on machines where the corresponding move insn is a
@en @code{define_expand} that emits a sequence of insns, this macro counts
@en the number of such sequences.
注意在一些机器上，对应的move insn为一个@code{define_expand}，
其产生一个insn序列，则该宏为该序列的个数。

The parameter @var{speed} is true if the code is currently being
optimized for speed rather than size.

@en If you don't define this, a reasonable default is used.
如果没有定义，则会使用一个合理的缺省值。
@end defmac

@defmac MOVE_BY_PIECES_P (@var{size}, @var{alignment})
@en A C expression used to determine whether @code{move_by_pieces} will be used to
@en copy a chunk of memory, or whether some other block move mechanism
@en will be used.  Defaults to 1 if @code{move_by_pieces_ninsns} returns less
@en than @code{MOVE_RATIO}.
一个C表达式，用于确定是否使用@code{move_by_pieces}来复制一块内存，
或者使用其它某种块移动机制。缺省为1，
如果@code{move_by_pieces_ninsns}返回值小于@code{MOVE_RATIO}。
@end defmac

@defmac MOVE_MAX_PIECES
@en A C expression used by @code{move_by_pieces} to determine the largest unit
@en a load or store used to copy memory is.  Defaults to @code{MOVE_MAX}.
一个C表达式，
由@code{move_by_pieces}使用用于确定load或者store用于复制内存的最大单元。
缺省为@code{MOVE_MAX}。
@end defmac

@defmac CLEAR_RATIO (@var{speed})
@en The threshold of number of scalar move insns, @emph{below} which a sequence
@en of insns should be generated to clear memory instead of a string clear insn
@en or a library call.  Increasing the value will always make code faster, but
@en eventually incurs high cost in increased code size.
标量move insn的临界数，@emph{低于}其值时，应该生成一个insn序列来清除内存，
而不是字符串clear insn或者库调用。增加值将总是使得代码更快，
但是会最终由于代码大小的增加而产生高的代价。

The parameter @var{speed} is true if the code is currently being
optimized for speed rather than size.

@en If you don't define this, a reasonable default is used.
如果没有定义，则会使用一个合理的缺省值。
@end defmac

@defmac CLEAR_BY_PIECES_P (@var{size}, @var{alignment})
@en A C expression used to determine whether @code{clear_by_pieces} will be used
@en to clear a chunk of memory, or whether some other block clear mechanism
@en will be used.  Defaults to 1 if @code{move_by_pieces_ninsns} returns less
@en than @code{CLEAR_RATIO}.
一个C表达式，用于确定是否使用@code{clear_by_pieces}来清除一块内存，
或者使用其它块清楚机制。缺省为1，
如果@code{move_by_pieces_ninsns}返回值小于@code{CLEAR_RATIO}。
@end defmac

@defmac SET_RATIO (@var{speed})
@en The threshold of number of scalar move insns, @emph{below} which a sequence
@en of insns should be generated to set memory to a constant value, instead of
@en a block set insn or a library call.  
@en Increasing the value will always make code faster, but
@en eventually incurs high cost in increased code size.
标量move insn的临界数，@emph{低于}其值时，
应该生成一个insn序列来将内存设为一个常量值，而不是一个块设置insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

The parameter @var{speed} is true if the code is currently being
optimized for speed rather than size.

@en If you don't define this, it defaults to the value of @code{MOVE_RATIO}.
如果没有定义，缺省值为@code{MOVE_RATIO}。
@end defmac

@defmac SET_BY_PIECES_P (@var{size}, @var{alignment})
@en A C expression used to determine whether @code{store_by_pieces} will be
@en used to set a chunk of memory to a constant value, or whether some 
@en other mechanism will be used.  Used by @code{__builtin_memset} when 
@en storing values other than constant zero.
@en Defaults to 1 if @code{move_by_pieces_ninsns} returns less
@en than @code{SET_RATIO}.
一个C表达式用来确定是否使用@code{store_by_pieces}来设置内存块为常量值，
或者使用其它机制。当存储非常数0的值时，由@code{__builtin_memset}使用。
缺省为1，如果@code{move_by_pieces_ninsns}返回值小于@code{SET_RATIO}。
@end defmac

@defmac STORE_BY_PIECES_P (@var{size}, @var{alignment})
@en A C expression used to determine whether @code{store_by_pieces} will be
@en used to set a chunk of memory to a constant string value, or whether some
@en other mechanism will be used.  Used by @code{__builtin_strcpy} when
@en called with a constant source string.
@en Defaults to 1 if @code{move_by_pieces_ninsns} returns less
@en than @code{MOVE_RATIO}.
一个C表达式用来确定是否使用@code{store_by_pieces}来设置内存块为常量字符串，
或者使用其它的机制。当使用常量源字符串调用时，被@code{__builtin_strcpy}使用。
缺省为1，如果@code{move_by_pieces_ninsns}返回值小于@code{MOVE_RATIO}。
@end defmac

@defmac USE_LOAD_POST_INCREMENT (@var{mode})
@en A C expression used to determine whether a load postincrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_POST_INCREMENT}.
一个C表达式用于确定对于给定的mode，后增加载是否好。
缺省值为@code{HAVE_POST_INCREMENT}。
@end defmac

@defmac USE_LOAD_POST_DECREMENT (@var{mode})
@en A C expression used to determine whether a load postdecrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_POST_DECREMENT}.
一个C表达式用于确定对于给定的mode，后减加载是否好。
缺省值为@code{HAVE_POST_DECREMENT}。
@end defmac

@defmac USE_LOAD_PRE_INCREMENT (@var{mode})
@en A C expression used to determine whether a load preincrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_PRE_INCREMENT}.
一个C表达式用于确定对于给定的mode，前增加载是否好。
缺省值为@code{HAVE_PRE_INCREMENT}。
@end defmac

@defmac USE_LOAD_PRE_DECREMENT (@var{mode})
@en A C expression used to determine whether a load predecrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_PRE_DECREMENT}.
一个C表达式用于确定对于给定的mode，前减加载是否好。
缺省值为@code{HAVE_PRE_DECREMENT}。
@end defmac

@defmac USE_STORE_POST_INCREMENT (@var{mode})
@en A C expression used to determine whether a store postincrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_POST_INCREMENT}.
一个C表达式用于确定对于给定的mode，后增存储是否好。
缺省值为@code{HAVE_POST_INCREMENT}。
@end defmac

@defmac USE_STORE_POST_DECREMENT (@var{mode})
@en A C expression used to determine whether a store postdecrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_POST_DECREMENT}.
一个C表达式用于确定对于给定的mode，后减存储是否好。
缺省值为@code{HAVE_POST_DECREMENT}。
@end defmac

@defmac USE_STORE_PRE_INCREMENT (@var{mode})
@en This macro is used to determine whether a store preincrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_PRE_INCREMENT}.
一个C表达式用于确定对于给定的mode，前增存储是否好。
缺省值为@code{HAVE_PRE_INCREMENT}。
@end defmac

@defmac USE_STORE_PRE_DECREMENT (@var{mode})
@en This macro is used to determine whether a store predecrement is a good
@en thing to use for a given mode.  Defaults to the value of
@en @code{HAVE_PRE_DECREMENT}.
一个C表达式用于确定对于给定的mode，前减存储是否好。
缺省值为@code{HAVE_PRE_DECREMENT}。
@end defmac

@defmac NO_FUNCTION_CSE
@en Define this macro if it is as good or better to call a constant
@en function address than to call an address kept in a register.
定义该宏，如果调用常量函数地址要比调用保存在寄存器中的地址好些。
@end defmac

@defmac RANGE_TEST_NON_SHORT_CIRCUIT
@en Define this macro if a non-short-circuit operation produced by
@en @samp{fold_range_test ()} is optimal.  This macro defaults to true if
@en @code{BRANCH_COST} is greater than or equal to the value 2.
定义该宏，如果由@samp{fold_range_test ()}产生的non-short-circuit操作为可选的。
该宏缺省为真，如果@code{BRANCH_COST}大于或等于2。
@end defmac

@deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, int @var{code}, int @var{outer_code}, int *@var{total}, bool @var{speed})
@en This target hook describes the relative costs of RTL expressions.
该target钩子描述了RTL表达式的相对代价。

@en The cost may depend on the precise form of the expression, which is
@en available for examination in @var{x}, and the rtx code of the expression
@en in which it is contained, found in @var{outer_code}.  @var{code} is the
@en expression code---redundant, since it can be obtained with
@en @code{GET_CODE (@var{x})}.
代价可以依赖于表达式的确切形式，可以通过检查@var{x}来获得表达式的形式，
表达式包含的rtx的代码为@var{outer_code}。@var{code}为表达式代码，冗余的，
因为其可以使用@code{GET_CODE (@var{x})}获得。

@en In implementing this hook, you can use the construct
@en @code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast
@en instructions.
实现该钩子时，
你可以使用结构@code{COSTS_N_INSNS (@var{n})}来指定代价等价于@var{n}个指令。

@en On entry to the hook, @code{*@var{total}} contains a default estimate
@en for the cost of the expression.  The hook should modify this value as
@en necessary.  Traditionally, the default costs are @code{COSTS_N_INSNS (5)}
@en for multiplications, @code{COSTS_N_INSNS (7)} for division and modulus
@en operations, and @code{COSTS_N_INSNS (1)} for all other operations.
在钩子的入口处，@code{*@var{total}}包含了缺省的表达式代价的估值。需要的话，
钩子应该修改该值。传统的，缺省代价对于乘法为@code{COSTS_N_INSNS (5)}，
对于除法和求模为@code{COSTS_N_INSNS (7)}，
对于其它操作为@code{COSTS_N_INSNS (1)}。

@en When optimizing for code size, i.e.@: when @code{speed} is
@en false, this target hook should be used to estimate the relative
@en size cost of an expression, again relative to @code{COSTS_N_INSNS}.
当优化代码大小时，即，当@code{optimize_size}非0时，
该target钩子应该用于估计一个表达式的相对大小代价，
同样也是相对于@code{COSTS_N_INSNS}。

@en The hook returns true when all subexpressions of @var{x} have been
@en processed, and false when @code{rtx_cost} should recurse.
钩子返回真，当所有@var{x}的子表达式都被处理，当@code{rtx_cost}应该递归时返回假。
@end deftypefn

@deftypefn {Target Hook} int TARGET_ADDRESS_COST (rtx @var{address}, bool @var{speed})
@en This hook computes the cost of an addressing mode that contains
@en @var{address}.  If not defined, the cost is computed from
@en the @var{address} expression and the @code{TARGET_RTX_COST} hook.
该钩子计算包含@var{address}的寻址模式的代价。如果没有定义，
代价通过@var{address}表达式和@code{TARGET_RTX_COST}钩子来计算。

@en For most CISC machines, the default cost is a good approximation of the
@en true cost of the addressing mode.  However, on RISC machines, all
@en instructions normally have the same length and execution time.  Hence
@en all addresses will have equal costs.
对于大多数CISC机器，缺省代价为寻址模式的真实代价的合理近似值。
然而，在RISC机器上，所有指令通常具有相同的长度和执行时间。
因此所有寻址将具有相等的代价。

@en In cases where more than one form of an address is known, the form with
@en the lowest cost will be used.  If multiple forms have the same, lowest,
@en cost, the one that is the most complex will be used.
对于多于一个的形式的寻址，将会使用最低代价的形式。
如果多个形式具有相同的，最低的代价，则使用最复杂的。

@en For example, suppose an address that is equal to the sum of a register
@en and a constant is used twice in the same basic block.  When this macro
@en is not defined, the address will be computed in a register and memory
@en references will be indirect through that register.  On machines where
@en the cost of the addressing mode containing the sum is no higher than
@en that of a simple indirect reference, this will produce an additional
@en instruction and possibly require an additional register.  Proper
@en specification of this macro eliminates this overhead for such machines.
例如，假设地址等于寄存器和常量的和，并在同一基本块中使用两次。
当该宏没有被定义，地址将在寄存器中计算，并且内存引用将通过寄存器间接实现。
在一些机器上，包含该和的寻址模式的代价不比简单的间接引用高，
这样则会产生一条额外的指令，并且可能需要一个额外的寄存器。
对该宏进行合适的指定，会消除这样的情况。

@en This hook is never called with an invalid address.
该钩子从不会被无效地址调用。

@en On machines where an address involving more than one register is as
@en cheap as an address computation involving only one register, defining
@en @code{TARGET_ADDRESS_COST} to reflect this can cause two registers to
@en be live over a region of code where only one would have been if
@en @code{TARGET_ADDRESS_COST} were not defined in that manner.  This effect
@en should be considered in the definition of this macro.  Equivalent costs
@en should probably only be given to addresses with different numbers of
@en registers on machines with lots of registers.
在一些机器上，地址包括多于一个寄存器的代价，
跟只包含一个寄存器的地址计算代价一样低，
则定义@code{TARGET_ADDRESS_COST}来反映这种情况，
可以使得两个寄存器在代码域中为活跃的，如果没有定义则可能只有一个为活跃的。
这种效果在定义该宏时应该被考虑。
可能只有对于有大量寄存器的机器才可能会有相等的代价。
@end deftypefn

@en @node Scheduling
@en @section Adjusting the Instruction Scheduler
@node Scheduling
@section 调整指令调度器

@en The instruction scheduler may need a fair amount of machine-specific
@en adjustment in order to produce good code.  GCC provides several target
@en hooks for this purpose.  It is usually enough to define just a few of
@en them: try the first ones in this list first.
指令调度器可能需要一些机器特定的调整，来产生好的代码。GCC为此提供了几个target钩子。通常定义它们的一部分就足够了：先尝试该列表中最前面的。

@deftypefn {Target Hook} int TARGET_SCHED_ISSUE_RATE (void)
@en This hook returns the maximum number of instructions that can ever
@en issue at the same time on the target machine.  The default is one.
@en Although the insn scheduler can define itself the possibility of issue
@en an insn on the same cycle, the value can serve as an additional
@en constraint to issue insns on the same simulated processor cycle (see
@en hooks @samp{TARGET_SCHED_REORDER} and @samp{TARGET_SCHED_REORDER2}).
@en This value must be constant over the entire compilation.  If you need
@en it to vary depending on what the instructions are, you must use
@en @samp{TARGET_SCHED_VARIABLE_ISSUE}.
该钩子返回在target机器上同一时间可以发射的最大指令数目。缺省为1。
虽然insn调度器本身可以定义同一周期发射一个insn的可能能性，
但该值可以作为额外的约束，用于相同模拟处理器周期的insn发射
（参见钩子@samp{TARGET_SCHED_REORDER}和@samp{TARGET_SCHED_REORDER2}）。
该值在整个编译过程中必须为常量。如果你需要其依赖指令是什么而变化，
则必须使用@samp{TARGET_SCHED_VARIABLE_ISSUE}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_VARIABLE_ISSUE (FILE *@var{file}, int @var{verbose}, rtx @var{insn}, int @var{more})
@en This hook is executed by the scheduler after it has scheduled an insn
@en from the ready list.  It should return the number of insns which can
@en still be issued in the current cycle.  The default is
@en @samp{@w{@var{more} - 1}} for insns other than @code{CLOBBER} and
@en @code{USE}, which normally are not counted against the issue rate.
@en You should define this hook if some insns take more machine resources
@en than others, so that fewer insns can follow them in the same cycle.
@en @var{file} is either a null pointer, or a stdio stream to write any
@en debug output to.  @var{verbose} is the verbose level provided by
@en @option{-fsched-verbose-@var{n}}.  @var{insn} is the instruction that
@en was scheduled.
该钩子在调度器从就绪列表中调度了一个insn之后被执行。
其应该返回在当前周期仍然可以被发射的insn数目。
对于@code{CLOBBER}和@code{USE}之外的insn，缺省为@samp{@w{@var{more} - 1}}，
其通常不根据发射频率来计数。你应该定义该钩子，
如果一些insn比其它的需要更多的机器资源，
使得在同一周期它们后面可以跟随较少的insn。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{insn}为被调度的指针。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_ADJUST_COST (rtx @var{insn}, rtx @var{link}, rtx @var{dep_insn}, int @var{cost})
@en This function corrects the value of @var{cost} based on the
@en relationship between @var{insn} and @var{dep_insn} through the
@en dependence @var{link}.  It should return the new value.  The default
@en is to make no adjustment to @var{cost}.  This can be used for example
@en to specify to the scheduler using the traditional pipeline description
@en that an output- or anti-dependence does not incur the same cost as a
@en data-dependence.  If the scheduler using the automaton based pipeline
@en description, the cost of anti-dependence is zero and the cost of
@en output-dependence is maximum of one and the difference of latency
@en times of the first and the second insns.  If these values are not
@en acceptable, you could use the hook to modify them too.  See also
@en @pxref{Processor pipeline description}.
该函数根据@var{insn}和@var{dep_insn}通过依赖链接的关系来更正@var{cost}值。
其应该返回新的值。缺省为不对@var{cost}进行调整。
例如这可以用于指定调度器使用传统的流水线描述，
即输出或反向依赖不产生与数据依赖相同的代价。
如果调度器使用基于流水线描述的自动机，则反向依赖的代码为0，
输出依赖的代价为1和第一个insn与第二个insn之间的延迟时间的最大值。
如果这些值无法接受，你应该使用该钩子来修改它们。@pxref{Processor pipeline description}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_ADJUST_PRIORITY (rtx @var{insn}, int @var{priority})
@en This hook adjusts the integer scheduling priority @var{priority} of
@en @var{insn}.  It should return the new priority.  Increase the priority to
@en execute @var{insn} earlier, reduce the priority to execute @var{insn}
@en later.  Do not define this hook if you do not need to adjust the
@en scheduling priorities of insns.
该钩子调整@var{insn}的整数调度有限级@var{priority}。其应该返回新的priority。
增加优先级来提前执行@var{insn}，减少优先级来推迟执行@var{insn}。
如果不需要调整insn的调度优先级，则不需要定义该钩子。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_REORDER (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_readyp}, int @var{clock})
@en This hook is executed by the scheduler after it has scheduled the ready
@en list, to allow the machine description to reorder it (for example to
@en combine two small instructions together on @samp{VLIW} machines).
@en @var{file} is either a null pointer, or a stdio stream to write any
@en debug output to.  @var{verbose} is the verbose level provided by
@en @option{-fsched-verbose-@var{n}}.  @var{ready} is a pointer to the ready
@en list of instructions that are ready to be scheduled.  @var{n_readyp} is
@en a pointer to the number of elements in the ready list.  The scheduler
@en reads the ready list in reverse order, starting with
@en @var{ready}[@var{*n_readyp} @minus{} 1] and going to @var{ready}[0].  @var{clock}
@en is the timer tick of the scheduler.  You may modify the ready list and
@en the number of ready insns.  The return value is the number of insns that
@en can issue this cycle; normally this is just @code{issue_rate}.  See also
@en @samp{TARGET_SCHED_REORDER2}.
该钩子在调度器调度完就绪列表后被执行，
以允许机器描述来重新排序（例如在@samp{VLIW}机器上，将两个小指令合并一起）。
@var{file}或者为一个null指针，或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{ready}为指向已经被调度的指令就绪列表的指针。
@var{n_readyp}为指向在就绪列表中的元素个数的指针。
调度器按照相反的顺序读取就绪列表，从@var{ready}[@var{*n_readyp}-1]开始，
到@var{ready}[0]。@var{clock}为调度器的时钟tick。你可以修改就绪列表和insn。
返回值为这个周期可以发射的insn数；这通常只是为@code{issue_rate}。
参见@samp{TARGET_SCHED_REORDER2}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_REORDER2 (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_readyp}, int @var{clock})
@en Like @samp{TARGET_SCHED_REORDER}, but called at a different time.  That
@en function is called whenever the scheduler starts a new cycle.  This one
@en is called once per iteration over a cycle, immediately after
@en @samp{TARGET_SCHED_VARIABLE_ISSUE}; it can reorder the ready list and
@en return the number of insns to be scheduled in the same cycle.  Defining
@en this hook can be useful if there are frequent situations where
@en scheduling one insn causes other insns to become ready in the same
@en cycle.  These other insns can then be taken into account properly.
类似于@samp{TARGET_SCHED_REORDER}，只不过在不同的时间被调用。
该函数每当调度器开始一个新的周期时被调用。其在每个周期都被调用一次，
紧跟在@samp{TARGET_SCHED_VARIABLE_ISSUE}之后；
其可以重排就绪列表并返回在同一周期被调度的insn数目。
如果常常调度一个insn会引起其他insn可以在同一周期就绪，则定义该钩子会很有用。
这样其它insn便可以被适当的考虑进来。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx @var{head}, rtx @var{tail})
@en This hook is called after evaluation forward dependencies of insns in
@en chain given by two parameter values (@var{head} and @var{tail}
@en correspondingly) but before insns scheduling of the insn chain.  For
@en example, it can be used for better insn classification if it requires
@en analysis of dependencies.  This hook can use backward and forward
@en dependencies of the insn scheduler because they are already
@en calculated.
该钩子在由两个参数值给出的链中向前评估完insn的依赖关系之后，
但在insn链的调度之前被调用。例如，其可以被用于更好的insn分类，
如果其需要依赖分析。该钩子可以使用insn调度器的向后和向前依赖，
因为它们已经被计算好了。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT (FILE *@var{file}, int @var{verbose}, int @var{max_ready})
@en This hook is executed by the scheduler at the beginning of each block of
@en instructions that are to be scheduled.  @var{file} is either a null
@en pointer, or a stdio stream to write any debug output to.  @var{verbose}
@en is the verbose level provided by @option{-fsched-verbose-@var{n}}.
@en @var{max_ready} is the maximum number of insns in the current scheduling
@en region that can be live at the same time.  This can be used to allocate
@en scratch space if it is needed, e.g.@: by @samp{TARGET_SCHED_REORDER}.
该钩子在每个要被调度的指令块的起始处被调用。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{max_ready}为在当前调度域中可以同时活跃的insn最大数。
这可以用来分配需要的草稿空间，例如，@samp{TARGET_SCHED_REORDER}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FINISH (FILE *@var{file}, int @var{verbose})
@en This hook is executed by the scheduler at the end of each block of
@en instructions that are to be scheduled.  It can be used to perform
@en cleanup of any actions done by the other scheduling hooks.  @var{file}
@en is either a null pointer, or a stdio stream to write any debug output
@en to.  @var{verbose} is the verbose level provided by
@en @option{-fsched-verbose-@var{n}}.
该钩子在每个要被调度的指令块的起始处被调用。
其可以用于执行清除由其它调度钩子完成的任何动作。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_GLOBAL (FILE *@var{file}, int @var{verbose}, int @var{old_max_uid})
@en This hook is executed by the scheduler after function level initializations.
@en @var{file} is either a null pointer, or a stdio stream to write any debug output to.
@en @var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}.
@en @var{old_max_uid} is the maximum insn uid when scheduling begins.
该钩子在函数级初始化的时候被调度器执行。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{old_max_uid}为调度开始时，最大的insn uid。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FINISH_GLOBAL (FILE *@var{file}, int @var{verbose})
@en This is the cleanup hook corresponding to @code{TARGET_SCHED_INIT_GLOBAL}.
@en @var{file} is either a null pointer, or a stdio stream to write any debug output to.
@en @var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}.
这是一个清除钩子，对应于@code{TARGET_SCHED_INIT_GLOBAL}。
@var{file}或者为一个null指针，或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)
@en The hook returns an RTL insn.  The automaton state used in the
@en pipeline hazard recognizer is changed as if the insn were scheduled
@en when the new simulated processor cycle starts.  Usage of the hook may
@en simplify the automaton pipeline description for some @acronym{VLIW}
@en processors.  If the hook is defined, it is used only for the automaton
@en based pipeline description.  The default is not to change the state
@en when the new simulated processor cycle starts.
该钩子返回一个RTL insn。流水线冒险识别器中的自动机状态，
按照当新的模拟处理器周期开始，insn被调度的样子被改变。
该钩子的用法可以简化一些@acronym{VLIW}处理器的自动机流水线描述。
如果钩子被定义，其只用于基于自动机的流水线描述。缺省为不改变状态，
当新的模拟处理器周期开始时。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN (void)
@en The hook can be used to initialize data used by the previous hook.
该钩子可以用于初始化先前的钩子所使用的数据。
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_SCHED_DFA_POST_CYCLE_INSN (void)
@en The hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used
@en to changed the state as if the insn were scheduled when the new
@en simulated processor cycle finishes.
该钩子与@samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN}类似，但用于改变状态，
按照当新的模拟处理器周期结束时insn被调度的方式。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN (void)
@en The hook is analogous to @samp{TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN} but
@en used to initialize data used by the previous hook.
该钩子与@samp{TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN}类似，
但用于初始化先前的钩子所使用的数据。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE (void)
@en The hook to notify target that the current simulated cycle is about to finish.
@en The hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used
@en to change the state in more complicated situations - e.g., when advancing
@en state on a single insn is not enough.
该钩子用来通报target，当前模拟周期将要完成。
该钩子类似于@samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN}，
但用于在更复杂的情况下改变状态，例如当在一个单独的insn上前移一个状态并不足够时。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_DFA_POST_ADVANCE_CYCLE (void)
@en The hook to notify target that new simulated cycle has just started.
@en The hook is analogous to @samp{TARGET_SCHED_DFA_POST_CYCLE_INSN} but used
@en to change the state in more complicated situations - e.g., when advancing
@en state on a single insn is not enough.
该钩子用来通报target，新的模拟周期刚刚开始。
该钩子类似于@samp{TARGET_SCHED_DFA_POST_CYCLE_INSN}，
但用于在更复杂的情况下改变状态，例如当在一个单独的insn上前移一个状态并不足够时。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD (void)
@en This hook controls better choosing an insn from the ready insn queue
@en for the @acronym{DFA}-based insn scheduler.  Usually the scheduler
@en chooses the first insn from the queue.  If the hook returns a positive
@en value, an additional scheduler code tries all permutations of
@en @samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()}
@en subsequent ready insns to choose an insn whose issue will result in
@en maximal number of issued insns on the same cycle.  For the
@en @acronym{VLIW} processor, the code could actually solve the problem of
@en packing simple insns into the @acronym{VLIW} insn.  Of course, if the
@en rules of @acronym{VLIW} packing are described in the automaton.
该钩子控制基于@acronym{DFA}的insn调度器来更好的选择一个insn，
从就绪insn队列中。通常调度器从队列中选择第一个insn。如果钩子返回一个正值，
则会有额外的调度器代码来尝试所有的@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()}的排列组合，
来选择一个insn，使得发射该insn将在同一周期产生最大的insn发射数。
对于@acronym{VLIW}处理器，
代码实际上解决了将简单insn打包成@acronym{VLIW} insn的问题。
当然，如果@acronym{VLIW}打包规则在自动机中有描述。

@en This code also could be used for superscalar @acronym{RISC}
@en processors.  Let us consider a superscalar @acronym{RISC} processor
@en with 3 pipelines.  Some insns can be executed in pipelines @var{A} or
@en @var{B}, some insns can be executed only in pipelines @var{B} or
@en @var{C}, and one insn can be executed in pipeline @var{B}.  The
@en processor may issue the 1st insn into @var{A} and the 2nd one into
@en @var{B}.  In this case, the 3rd insn will wait for freeing @var{B}
@en until the next cycle.  If the scheduler issues the 3rd insn the first,
@en the processor could issue all 3 insns per cycle.
该代码还能用于超标量@acronym{RISC}处理器。
让我们考虑一个具有3级流水的超标量@acronym{RISC}处理器。
一些insn可以在流水线@var{A}或@var{B}中被执行，
一些insn只能在流水线@var{B}或@var{C}中执行，
并且有一个insn可以在流水线@var{B}中被执行。处理器可以发射第一个insn到@var{A}，
第二个到@var{B}。这种情况下，第三个insn将会等待释放@var{B}，直到下一个周期。
如果调度器先发射第三个insn，则处理器可以一个周期发射所有的3个insn。

@en Actually this code demonstrates advantages of the automaton based
@en pipeline hazard recognizer.  We try quickly and easy many insn
@en schedules to choose the best one.
实际上该代码证明了基于自动机的流水线冒险识别器的优点。
我们最快且最容易的尝试许多insn调度，并选择最好的一种。

@en The default is no multipass scheduling.
缺省为不进行多遍的调度。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD (rtx @var{insn})
@en This hook controls what insns from the ready insn queue will be
@en considered for the multipass insn scheduling.  If the hook returns
@en zero for @var{insn}, the insn will be not chosen to
@en be issued.
该钩子控制了对于多遍insn调度，就绪insn队列中的什么样的insn将被考虑。
如果钩子返回0，对于最为参数传递的insn，则insn将不被选择发射。

@en The default is that any ready insns can be chosen to be issued.
缺省为所有的就绪insn都可以被选择发射。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN (void *@var{data}, char *@var{ready_try}, int @var{n_ready}, bool @var{first_cycle_insn_p})
This hook prepares the target backend for a new round of multipass
scheduling.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE (void *@var{data}, char *@var{ready_try}, int @var{n_ready}, rtx @var{insn}, const void *@var{prev_data})
This hook is called when multipass scheduling evaluates instruction INSN.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK (const void *@var{data}, char *@var{ready_try}, int @var{n_ready})
This is called when multipass scheduling backtracks from evaluation of
an instruction.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END (const void *@var{data})
This hook notifies the target about the result of the concluded current
round of multipass scheduling.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT (void *@var{data})
This hook initilizes target-specific data used in multipass scheduling.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI (void *@var{data})
This hook finilizes target-specific data used in multipass scheduling.
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_DFA_NEW_CYCLE (FILE *@var{dump}, int @var{verbose}, rtx @var{insn}, int @var{last_clock}, int @var{clock}, int *@var{sort_p})
@en This hook is called by the insn scheduler before issuing @var{insn}
@en on cycle @var{clock}.  If the hook returns nonzero,
@en @var{insn} is not issued on this processor cycle.  Instead,
@en the processor cycle is advanced.  If *@var{sort_p}
@en is zero, the insn ready queue is not sorted on the new cycle
@en start as usually.  @var{dump} and @var{verbose} specify the file and
@en verbosity level to use for debugging output.
@en @var{last_clock} and @var{clock} are, respectively, the
@en processor cycle on which the previous insn has been issued,
@en and the current processor cycle.
该钩子在给定的周期，在发射作为第三个参数传递的insn之前被insn调度器调用。
如果钩子返回非零，则insn在给定的处理器周期将不被发射。替代的，
处理器周期将前移。如果最后一个参数的值为0，
则insn就绪队列没有在新的周期开始时按照通常的方式被排序。
第一个参数传递了调试输出的文件。第二个参数传递了调试输出的详细级别。
第四个和第五个参数值分别对应于之前insn被发射的处理器周期，以及当前处理器周期。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct _dep *@var{_dep}, int @var{cost}, int @var{distance})
@en This hook is used to define which dependences are considered costly by
@en the target, so costly that it is not advisable to schedule the insns that
@en are involved in the dependence too close to one another.  The parameters
@en to this hook are as follows:  The first parameter @var{_dep} is the dependence
@en being evaluated.  The second parameter @var{cost} is the cost of the
@en dependence as estimated by the scheduler, and the third
@en parameter @var{distance} is the distance in cycles between the two insns.
@en The hook returns @code{true} if considering the distance between the two
@en insns the dependence between them is considered costly by the target,
@en and @code{false} otherwise.
该钩子用于定义哪种依赖被target认为是具有昂贵代价的，
以至于将insn调度成依赖太近是不明智的。参数为：
第一个参数@var{_dep}为被评估的依赖。第二个参数@var{cost}为依赖的代价，
第三个参数@var{distance}为两个insn的周期距离。钩子返回@code{true}，
如果考虑两个insn间的距离，它们间的依赖被 target认为是昂贵的，
否则为@code{false}。

@en Defining this hook can be useful in multiple-issue out-of-order machines,
@en where (a) it's practically hopeless to predict the actual data/resource
@en delays, however: (b) there's a better chance to predict the actual grouping
@en that will be formed, and (c) correctly emulating the grouping can be very
@en important.  In such targets one may want to allow issuing dependent insns
@en closer to one another---i.e., closer than the dependence distance;  however,
@en not in cases of ``costly dependences'', which this hooks allows to define.
在多发射，乱序机器上，定义该钩子可以有用，
（a）实际中是无法预测真实的数据/资源延迟，
但是（b）有一个更好的机会来预测实际要被执行的组，
并且（c）正确模拟分组会非常重要。在这样的target上，
可能想要允许发射距离较近的依赖insn，即，比依赖距离近；
但是对于“昂贵的依赖”不这样做，这样就可以定义该钩子。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_H_I_D_EXTENDED (void)
@en This hook is called by the insn scheduler after emitting a new instruction to
@en the instruction stream.  The hook notifies a target backend to extend its
@en per instruction data structures.
该钩子在输出一个新的指令到指令流之后被insn调度器调用。
钩子通知target后端来延伸它的每个指令的数据结构。
@end deftypefn

@deftypefn {Target Hook} {void *} TARGET_SCHED_ALLOC_SCHED_CONTEXT (void)
Return a pointer to a store large enough to hold target scheduling context.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_SCHED_CONTEXT (void *@var{tc}, bool @var{clean_p})
Initialize store pointed to by @var{tc} to hold target scheduling context.
It @var{clean_p} is true then initialize @var{tc} as if scheduler is at the
beginning of the block.  Otherwise, copy the current context into @var{tc}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_CONTEXT (void *@var{tc})
Copy target scheduling context pointed to by @var{tc} to the current context.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_CLEAR_SCHED_CONTEXT (void *@var{tc})
Deallocate internal data in target scheduling context pointed to by @var{tc}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FREE_SCHED_CONTEXT (void *@var{tc})
Deallocate a store for target scheduling context pointed to by @var{tc}.
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_SPECULATE_INSN (rtx @var{insn}, int @var{request}, rtx *@var{new_pat})
@en This hook is called by the insn scheduler when @var{insn} has only
@en speculative dependencies and therefore can be scheduled speculatively.
@en The hook is used to check if the pattern of @var{insn} has a speculative
@en version and, in case of successful check, to generate that speculative
@en pattern.  The hook should return 1, if the instruction has a speculative form,
@en or @minus{}1, if it doesn't.  @var{request} describes the type of requested
@en speculation.  If the return value equals 1 then @var{new_pat} is assigned
@en the generated speculative pattern.
该钩子当@var{insn}只有投机依赖，并因此可以被投机的调度时，被调用。
钩子用于检查@var{insn}的指令模式是否具有一个投机版本，并且如果检查成功，
则生成那个投机模式。钩子应该返回1，如果具有投机形式，或者-1，如果不具有。
@var{request}描述了请求投机的类型。如果返回值等于1，
则@var{new_pat}被赋值为生成的投机指令模式。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SCHED_NEEDS_BLOCK_P (int @var{dep_status})
@en This hook is called by the insn scheduler during generation of recovery code
@en for @var{insn}.  It should return @code{true}, if the corresponding check
@en instruction should branch to recovery code, or @code{false} otherwise.
该钩子在为@var{insn}生成恢复代码时，被insn调度器调用。其应该返回@code{true}，
如果相应的检查指令应该分支跳转到回复代码，否则为@code{false}.
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_SCHED_GEN_SPEC_CHECK (rtx @var{insn}, rtx @var{label}, int @var{mutate_p})
@en This hook is called by the insn scheduler to generate a pattern for recovery
@en check instruction.  If @var{mutate_p} is zero, then @var{insn} is a
@en speculative instruction for which the check should be generated.
@en @var{label} is either a label of a basic block, where recovery code should
@en be emitted, or a null pointer, when requested check doesn't branch to
@en recovery code (a simple check).  If @var{mutate_p} is nonzero, then
@en a pattern for a branchy check corresponding to a simple check denoted by
@en @var{insn} should be generated.  In this case @var{label} can't be null.
该钩子被insn调度器调用，来为恢复检查指令产生一个指令模式。
如果@var{mutate_p}为0，则@var{insn}为一个投机指令，对此应该生成检查。
@var{label}或者为一个基本快的标号，恢复代码应该被生成的地方，
或者为一个null指针，当请求的检查没有分支到恢复代码（简单的检查）。
如果@var{mutate_p}为非 0，
则由@var{insn}注解的对应于一个简单检查的指令模式应该被生成。
这种情况下，@var{label}不能为null。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC (const_rtx @var{insn})
@en This hook is used as a workaround for
@en @samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD} not being
@en called on the first instruction of the ready list.  The hook is used to
@en discard speculative instructions that stand first in the ready list from
@en being scheduled on the current cycle.  If the hook returns @code{false},
@en @var{insn} will not be chosen to be issued.
@en For non-speculative instructions,
@en the hook should always return @code{true}.  For example, in the ia64 backend
@en the hook is used to cancel data speculative insns when the ALAT table
@en is nearly full.
该钩子用于在就绪列表中第一个指令上没有调用@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD}的情况。
钩子用于丢弃从当前周期调度的起始于就绪列表的投机指令。对于非投机指令，
钩子应该总是返回非零。例如，在ia64后端，钩子用于取消数据投机insn，
当ALAT表将满时。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_FLAGS (struct spec_info_def *@var{spec_info})
@en This hook is used by the insn scheduler to find out what features should be
@en enabled/used.
@en The structure *@var{spec_info} should be filled in by the target.
@en The structure describes speculation types that can be used in the scheduler.
该钩子被insn调度器用于查找什么特点应该被启用。结构体@var{spec_info}应该由target来填充。该结构体描述了调度器中可以使用的投机类型。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_SMS_RES_MII (struct ddg *@var{g})
@en This hook is called by the swing modulo scheduler to calculate a
@en resource-based lower bound which is based on the resources available in
@en the machine and the resources required by each instruction.  The target
@en backend can use @var{g} to calculate such bound.  A very simple lower
@en bound will be used in case this hook is not implemented: the total number
@en of instructions divided by the issue rate.
该钩子被swing modulo调度器调用，来计算基于资源的下界，
其基于在机器上可用的资源以及每个指令要求的资源。
target后端可以使用@var{g}来计算这个边界。如果没有实现该钩子，
则会使用一个非常简单的下界：指令总数除以发射率。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SCHED_DISPATCH (rtx @var{insn}, int @var{x})
This hook is called by Haifa Scheduler.  It returns true if dispatch scheduling
is supported in hardware and the condition specified in the parameter is true.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_DISPATCH_DO (rtx @var{insn}, int @var{x})
This hook is called by Haifa Scheduler.  It performs the operation specified
in its second parameter.
@end deftypefn

@en @node Sections
@en @section Dividing the Output into Sections (Texts, Data, @dots{})
@node Sections
@section 将输出划分到section中（Texts, Data, @dots{}）
@c the above section title is WAY too long.  maybe cut the part between
@c the (...)?  --mew 10feb93

@en An object file is divided into sections containing different types of
@en data.  In the most common case, there are three sections: the @dfn{text
@en section}, which holds instructions and read-only data; the @dfn{data
@en section}, which holds initialized writable data; and the @dfn{bss
@en section}, which holds uninitialized data.  Some systems have other kinds
@en of sections.
目标文件被划分到包含不同类型数据的section中。大多数情况下，
有三个section：@dfn{text section}，存放指令和只读数据；@dfn{data section}，
存放初始化的可写数据；@dfn{bss section}，存放未初始化的数据。
一些系统还具有其它类型的section。

@en @file{varasm.c} provides several well-known sections, such as
@en @code{text_section}, @code{data_section} and @code{bss_section}.
@en The normal way of controlling a @code{@var{foo}_section} variable
@en is to define the associated @code{@var{FOO}_SECTION_ASM_OP} macro,
@en as described below.  The macros are only read once, when @file{varasm.c}
@en initializes itself, so their values must be run-time constants.
@en They may however depend on command-line flags.
@file{varasm.c}提供了一些已知的section，例如@code{text_section}, 
@code{data_section}和@code{bss_section}。
通常控制一个@code{@var{foo}_section}变量的方式是定义一个相关联的
宏@code{@var{FOO}_SECTION_ASM_OP}，正如下面将要描述的。
宏只在@file{varasm.c}初始化时被读一次，
所以它们的值必须为运行时常量。不过它们可以依赖于命令行标记。

@en @emph{Note:} Some run-time files, such @file{crtstuff.c}, also make
@en use of the @code{@var{FOO}_SECTION_ASM_OP} macros, and expect them
@en to be string literals.
注意：一些运行时文件，例如@file{crtstuff.c}，
也使用@code{@var{FOO}_SECTION_ASM_OP}宏，并且将它们作为字符串文字。

@en Some assemblers require a different string to be written every time a
@en section is selected.  If your assembler falls into this category, you
@en should define the @code{TARGET_ASM_INIT_SECTIONS} hook and use
@en @code{get_unnamed_section} to set up the sections.
一些汇编器要求每次选择section时，都要写入一个不同的字符串。
如果你的汇编器属于这类，
你应该定义@code{TARGET_ASM_INIT_SECTIONS}钩子并使用
@code{get_unnamed_section}来建立section。

@en You must always create a @code{text_section}, either by defining
@en @code{TEXT_SECTION_ASM_OP} or by initializing @code{text_section}
@en in @code{TARGET_ASM_INIT_SECTIONS}.  The same is true of
@en @code{data_section} and @code{DATA_SECTION_ASM_OP}.  If you do not
@en create a distinct @code{readonly_data_section}, the default is to
@en reuse @code{text_section}.
你必须总是创建一个@code{text_section}，
或者通过定义@code{TEXT_SECTION_ASM_OP}，
或者通过在@code{TARGET_ASM_INIT_SECTIONS}中初始化@code{text_section}。
同样对于@code{data_section}和@code{DATA_SECTION_ASM_OP}。
如果你没有创建一个独立的@code{readonly_data_section}，
则缺省使用@code{text_section}。

@en All the other @file{varasm.c} sections are optional, and are null
@en if the target does not provide them.
所有其他@file{varasm.c} section都是可选的，如果target不提供则为null。

@defmac TEXT_SECTION_ASM_OP
@en A C expression whose value is a string, including spacing, containing the
@en assembler operation that should precede instructions and read-only data.
@en Normally @code{"\t.text"} is right.
一个C表达式，值为一个字符串，包括空格，
其包含了在指令和只读数据之前的汇编操作。通常为@code{"\t.text"}。
@end defmac

@defmac HOT_TEXT_SECTION_NAME
@en If defined, a C string constant for the name of the section containing most
@en frequently executed functions of the program.  If not defined, GCC will provide
@en a default definition if the target supports named sections.
如果定义，则为一个C字符串常量，为包含最频繁被执行的程序的函数的section名字。
如果没有定义，GCC将会提供一个缺省定义，如果target支持命名section。
@end defmac

@defmac UNLIKELY_EXECUTED_TEXT_SECTION_NAME
@en If defined, a C string constant for the name of the section containing unlikely
@en executed functions in the program.
如果定义，则为一个C字符串常量，为包含程序中不太可能被执行的函数的section名字。
@end defmac

@defmac DATA_SECTION_ASM_OP
@en A C expression whose value is a string, including spacing, containing the
@en assembler operation to identify the following data as writable initialized
@en data.  Normally @code{"\t.data"} is right.
一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为可写的初始化数据的汇编操作。通常为@code{"\t.data"}。
@end defmac

@defmac SDATA_SECTION_ASM_OP
@en If defined, a C expression whose value is a string, including spacing,
@en containing the assembler operation to identify the following data as
@en initialized, writable small data.
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为初始化的，可写的小数据的汇编操作。
@end defmac

@defmac READONLY_DATA_SECTION_ASM_OP
@en A C expression whose value is a string, including spacing, containing the
@en assembler operation to identify the following data as read-only initialized
@en data.
一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为只读的初始化数据的汇编操作。
@end defmac

@defmac BSS_SECTION_ASM_OP
@en If defined, a C expression whose value is a string, including spacing,
@en containing the assembler operation to identify the following data as
@en uninitialized global data.  If not defined, and neither
@en @code{ASM_OUTPUT_BSS} nor @code{ASM_OUTPUT_ALIGNED_BSS} are defined,
@en uninitialized global data will be output in the data section if
@en @option{-fno-common} is passed, otherwise @code{ASM_OUTPUT_COMMON} will be
@en used.
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为未初始化的，global数据的汇编操作。如果没有定义，
并且@code{ASM_OUTPUT_BSS}和@code{ASM_OUTPUT_ALIGNED_BSS}也都没有定义，
则为初始化的global数据将被输出在data section，如果使用了@option{-fno-common}，
否则将使用@code{ASM_OUTPUT_COMMON}。
@end defmac

@defmac SBSS_SECTION_ASM_OP
@en If defined, a C expression whose value is a string, including spacing,
@en containing the assembler operation to identify the following data as
@en uninitialized, writable small data.
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为未初始化的，可写的小数据的汇编操作。
@end defmac

@defmac TLS_COMMON_ASM_OP
If defined, a C expression whose value is a string containing the
assembler operation to identify the following data as thread-local
common data.  The default is @code{".tls_common"}.
@end defmac

@defmac TLS_SECTION_ASM_FLAG
If defined, a C expression whose value is a character constant
containing the flag used to mark a section as a TLS section.  The
default is @code{'T'}.
@end defmac

@defmac INIT_SECTION_ASM_OP
@en If defined, a C expression whose value is a string, including spacing,
@en containing the assembler operation to identify the following data as
@en initialization code.  If not defined, GCC will assume such a section does
@en not exist.  This section has no corresponding @code{init_section}
@en variable; it is used entirely in runtime code.
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为初始化代码的汇编操作。如果没有定义，
GCC将假设这样的section不存在。该section没有相应的@code{init_section}变量；
其完全在运行时代码中使用。
@end defmac

@defmac FINI_SECTION_ASM_OP
@en If defined, a C expression whose value is a string, including spacing,
@en containing the assembler operation to identify the following data as
@en finalization code.  If not defined, GCC will assume such a section does
@en not exist.  This section has no corresponding @code{fini_section}
@en variable; it is used entirely in runtime code.
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为结束代码的汇编操作。如果没有定义，
GCC将假设这样的section不存在。该section没有相应的@code{fini_section}变量；
其完全在运行时代码中使用。
@end defmac

@defmac INIT_ARRAY_SECTION_ASM_OP
@en If defined, a C expression whose value is a string, including spacing,
@en containing the assembler operation to identify the following data as
@en part of the @code{.init_array} (or equivalent) section.  If not
@en defined, GCC will assume such a section does not exist.  Do not define
@en both this macro and @code{INIT_SECTION_ASM_OP}.
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为@code{.init_array}（或相当的） section的一部分的
汇编操作。如果没有定义，GCC将假设这样的section不存在。
不要同时定义该宏和@code{INIT_SECTION_ASM_OP}。
@end defmac

@defmac FINI_ARRAY_SECTION_ASM_OP
@en If defined, a C expression whose value is a string, including spacing,
@en containing the assembler operation to identify the following data as
@en part of the @code{.fini_array} (or equivalent) section.  If not
@en defined, GCC will assume such a section does not exist.  Do not define
@en both this macro and @code{FINI_SECTION_ASM_OP}.
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为@code{.fini_array}（或相当的） section的一部分的
汇编操作。如果没有定义，GCC将假设这样的section不存在。
不要同时定义该宏和@code{FINI_SECTION_ASM_OP}。
@end defmac

@defmac CRT_CALL_STATIC_FUNCTION (@var{section_op}, @var{function})
@en If defined, an ASM statement that switches to a different section
@en via @var{section_op}, calls @var{function}, and switches back to
@en the text section.  This is used in @file{crtstuff.c} if
@en @code{INIT_SECTION_ASM_OP} or @code{FINI_SECTION_ASM_OP} to calls
@en to initialization and finalization functions from the init and fini
@en sections.  By default, this macro uses a simple function call.  Some
@en ports need hand-crafted assembly code to avoid dependencies on
@en registers initialized in the function prologue or to ensure that
@en constant pools don't end up too far way in the text section.
如果定义，为一个ASM语句，其通过@var{section_op}来切换到不同的section，
调用@var{function}，然后切换回到text section。这在@file{crtstuff.c}中使用，
如果@code{INIT_SECTION_ASM_OP}或@code{FINI_SECTION_ASM_OP}从init和
fini section中调用初始化和结束函数。缺省下，该宏使用简单的函数调用。
一些port需要手工的代码来避免在函数前奏中对寄存器初始化的依赖，
或者确保常量池在text section中不要结束的太远。
@end defmac

@defmac TARGET_LIBGCC_SDATA_SECTION
@en If defined, a string which names the section into which small
@en variables defined in crtstuff and libgcc should go.  This is useful
@en when the target has options for optimizing access to small data, and
@en you want the crtstuff and libgcc routines to be conservative in what
@en they expect of your application yet liberal in what your application
@en expects.  For example, for targets with a @code{.sdata} section (like
@en MIPS), you could compile crtstuff with @code{-G 0} so that it doesn't
@en require small data support from your application, but use this macro
@en to put small data into @code{.sdata} so that your application can
@en access these variables whether it uses small data or not.
如果定义，则为一个字符串，
其命名了在crtstuff和libgcc中定义的小变量应该存放的section。
这在target具有选项来优化访问小数据的时候很有用。例如，
对于具有@code{.sdata} section（像MIPS）的target，
你可以使用@code{-G 0}来编译crtstuff，使得其不需要小数据的支持，
但是使用该宏将小数据放到@code{.sdata}中，
这样你的应用程序不管是否使用小数据，都可以访问到这些变量。
@end defmac

@defmac FORCE_CODE_SECTION_ALIGN
@en If defined, an ASM statement that aligns a code section to some
@en arbitrary boundary.  This is used to force all fragments of the
@en @code{.init} and @code{.fini} sections to have to same alignment
@en and thus prevent the linker from having to add any padding.
如果定义，则为一个ASM语句，其将code section对齐到某个任意的边界。
这用于使得所有@code{.init}和@code{.fini} section的fragment都具有同样的对齐，
这样就可以阻止连接器增加任何padding。
@end defmac

@defmac JUMP_TABLES_IN_TEXT_SECTION
@en Define this macro to be an expression with a nonzero value if jump
@en tables (for @code{tablejump} insns) should be output in the text
@en section, along with the assembler instructions.  Otherwise, the
@en readonly data section is used.
定义该宏为一个表达式，具有非零值，如果跳转表（对于@code{tablejump} insn）
应该被输出到text secton中，以及汇编指令。否则，使用只读data section。

@en This macro is irrelevant if there is no separate readonly data section.
如果没有独立的只读data section，则该宏不相关。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_INIT_SECTIONS (void)
@en Define this hook if you need to do something special to set up the
@en @file{varasm.c} sections, or if your target has some special sections
@en of its own that you need to create.
定义该钩子，如果你需要在建立@file{varasm.c} section时做一些特殊的处理，
或者你的target具有一些特殊的section需要创建。

@en GCC calls this hook after processing the command line, but before writing
@en any assembly code, and before calling any of the section-returning hooks
@en described below.
GCC在处理完命令行之后，在写任何汇编代码之前，
并在调用任何下面描述的返回section的钩子之前调用该钩子。
@end deftypefn

@deftypefn {Target Hook} int TARGET_ASM_RELOC_RW_MASK (void)
@en Return a mask describing how relocations should be treated when
@en selecting sections.  Bit 1 should be set if global relocations
@en should be placed in a read-write section; bit 0 should be set if
@en local relocations should be placed in a read-write section.
返回一个掩码，用来描述当选择section时，应该如何对待重定位。
如果全局重定位应该放在读写section中，则应该设置位1；
如果局部重定位应该被放在读写section中，则应该设置位0。

@en The default version of this function returns 3 when @option{-fpic}
@en is in effect, and 0 otherwise.  The hook is typically redefined
@en when the target cannot support (some kinds of) dynamic relocations
@en in read-only sections even in executables.
该函数的缺省版本返回3，当@option{-fpic}有效时，否则返回0。
当target不支持（某种）在只读section中，甚至在可执行程序中的动态重定位时，
通常会重定义该钩子。
@end deftypefn

@deftypefn {Target Hook} {section *} TARGET_ASM_SELECT_SECTION (tree @var{exp}, int @var{reloc}, unsigned HOST_WIDE_INT @var{align})
@en Return the section into which @var{exp} should be placed.  You can
@en assume that @var{exp} is either a @code{VAR_DECL} node or a constant of
@en some sort.  @var{reloc} indicates whether the initial value of @var{exp}
@en requires link-time relocations.  Bit 0 is set when variable contains
@en local relocations only, while bit 1 is set for global relocations.
@en @var{align} is the constant alignment in bits.
返回@var{exp}应该被放入的section。
你可以假设@var{exp}为@code{VAR_DECL}节点或者一个常量。
@var{reloc}指示@var{exp}的初始化值是否需要连接时重定位。
当变量只包含局部重定位时位0被设置，对于全局重定位位1被设置。
@var{align}为常量对齐位数。

@en The default version of this function takes care of putting read-only
@en variables in @code{readonly_data_section}.
该函数的缺省版本只关心将只读变量放到@code{readonly_data_section}中。

@en See also @var{USE_SELECT_SECTION_FOR_FUNCTIONS}.
参见@var{USE_SELECT_SECTION_FOR_FUNCTIONS}.
@end deftypefn

@defmac USE_SELECT_SECTION_FOR_FUNCTIONS
@en Define this macro if you wish TARGET_ASM_SELECT_SECTION to be called
@en for @code{FUNCTION_DECL}s as well as for variables and constants.
如果你希望对于@code{FUNCTION_DECL}，
将会调用TARGET_ASM_SELECT_SECTION，则定义该宏。同样对于变量和常量。

@en In the case of a @code{FUNCTION_DECL}, @var{reloc} will be zero if the
@en function has been determined to be likely to be called, and nonzero if
@en it is unlikely to be called.
对于@code{FUNCTION_DECL}，@var{reloc}将为0，如果函数被确定有可能被调用，
非零如果其不能被调用。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_UNIQUE_SECTION (tree @var{decl}, int @var{reloc})
@en Build up a unique section name, expressed as a @code{STRING_CST} node,
@en and assign it to @samp{DECL_SECTION_NAME (@var{decl})}.
@en As with @code{TARGET_ASM_SELECT_SECTION}, @var{reloc} indicates whether
@en the initial value of @var{exp} requires link-time relocations.
构建一个唯一的section名，使用@code{STRING_CST}节点表示，
并赋值为@samp{DECL_SECTION_NAME (@var{decl})}。
跟@code{TARGET_ASM_SELECT_SECTION}一样，
@var{reloc}指示@var{exp}的初始化值是否需要连接时重定位。

@en The default version of this function appends the symbol name to the
@en ELF section name that would normally be used for the symbol.  For
@en example, the function @code{foo} would be placed in @code{.text.foo}.
@en Whatever the actual target object format, this is often good enough.
该函数的缺省版本向ELF section名中追加一个符号名。例如，
函数@code{foo}将被放在@code{.text.foo}中。
这对于实际的target目标格式通常是可以的。
@end deftypefn

@deftypefn {Target Hook} {section *} TARGET_ASM_FUNCTION_RODATA_SECTION (tree @var{decl})
@en Return the readonly data section associated with
@en @samp{DECL_SECTION_NAME (@var{decl})}.
@en The default version of this function selects @code{.gnu.linkonce.r.name} if
@en the function's section is @code{.gnu.linkonce.t.name}, @code{.rodata.name}
@en if function is in @code{.text.name}, and the normal readonly-data section
@en otherwise.
返回与@samp{DECL_SECTION_NAME (@var{decl})}关联的只读data section。
该函数的缺省版本选择@code{.gnu.linkonce.r.name}，
如果函数的section为@code{.gnu.linkonce.t.name}，
@code{.rodata.name}如果函数在@code{.text.name}中，
否则为通常的只读data section。
@end deftypefn

@deftypefn {Target Hook} {section *} TARGET_ASM_SELECT_RTX_SECTION (enum machine_mode @var{mode}, rtx @var{x}, unsigned HOST_WIDE_INT @var{align})
@en Return the section into which a constant @var{x}, of mode @var{mode},
@en should be placed.  You can assume that @var{x} is some kind of
@en constant in RTL@.  The argument @var{mode} is redundant except in the
@en case of a @code{const_int} rtx.  @var{align} is the constant alignment
@en in bits.
返回具有机器模式mode的常量x应该放入的section。
你可以假设@var{x}为RTL形式的某种常量。参数@var{mode}除了@code{const_int}之外，
是冗余的。@var{align}为常量对齐位数。

@en The default version of this function takes care of putting symbolic
@en constants in @code{flag_pic} mode in @code{data_section} and everything
@en else in @code{readonly_data_section}.
该函数的缺省版本考虑将符号常量@code{flag_pic}模式的，放在@code{data_section}中，
其它放在@code{readonly_data_section}中。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_MANGLE_DECL_ASSEMBLER_NAME (tree @var{decl}, tree @var{id})
@en Define this hook if you need to postprocess the assembler name generated
@en by target-independent code.  The @var{id} provided to this hook will be
@en the computed name (e.g., the macro @code{DECL_NAME} of the @var{decl} in C,
@en or the mangled name of the @var{decl} in C++).  The return value of the
@en hook is an @code{IDENTIFIER_NODE} for the appropriate mangled name on
@en your target system.  The default implementation of this hook just
@en returns the @var{id} provided.
定义该钩子，如果你需要处理由target无关的代码生成的汇编名。
提供给该钩子的@var{id}将为被计算的名字（例如C中的@code{DECL_NAME}宏，
或者C++中的mangled name）。该钩子的返回值为一个@code{IDENTIFIER_NODE}。
该钩子的缺省实现只是返回提供的@var{id}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ENCODE_SECTION_INFO (tree @var{decl}, rtx @var{rtl}, int @var{new_decl_p})
@en Define this hook if references to a symbol or a constant must be
@en treated differently depending on something about the variable or
@en function named by the symbol (such as what section it is in).
定义该钩子，如果对符号或者常量的引用必须根据符号所命名的变量或者函数来不同处理
（例如其在哪个section中）。

@en The hook is executed immediately after rtl has been created for
@en @var{decl}, which may be a variable or function declaration or
@en an entry in the constant pool.  In either case, @var{rtl} is the
@en rtl in question.  Do @emph{not} use @code{DECL_RTL (@var{decl})}
@en in this hook; that field may not have been initialized yet.
钩子在为@var{decl}创建@var{rtl}之后立即被执行，
@var{decl}可能为一个变量或者函数声明，或者常量池的入口。@emph{不要}在该钩子中
使用@code{DECL_RTL (@var{decl})}；那个域可能还没有被初始化。

@en In the case of a constant, it is safe to assume that the rtl is
@en a @code{mem} whose address is a @code{symbol_ref}.  Most decls
@en will also have this form, but that is not guaranteed.  Global
@en register variables, for instance, will have a @code{reg} for their
@en rtl.  (Normally the right thing to do with such unusual rtl is
@en leave it alone.)
对于常量，可以假设rtl为一个@code{mem}，其地址为一个 @code{symbol_ref}。
大多数decl将具有这种形式，但不被保证。全局寄存器变量，例如，
它们的rtl将具有一个@code{reg}。（对于这样不寻常的rtl通常是将其放在一边）。

@en The @var{new_decl_p} argument will be true if this is the first time
@en that @code{TARGET_ENCODE_SECTION_INFO} has been invoked on this decl.  It will
@en be false for subsequent invocations, which will happen for duplicate
@en declarations.  Whether or not anything must be done for the duplicate
@en declaration depends on whether the hook examines @code{DECL_ATTRIBUTES}.
@en @var{new_decl_p} is always true when the hook is called for a constant.
参数@var{new_decl_p}将为真，
如果这是第一次对于该decl调用@code{TARGET_ENCODE_SECTION_INFO}。
对于后续的调用其将为假，这放生在复制的声明中。对于复制声明，是否需要做什么，
取决于钩子是否检查@code{DECL_ATTRIBUTES}。当钩子对于常量被调用，
则@var{new_decl_p}总为真。

@en @cindex @code{SYMBOL_REF_FLAG}, in @code{TARGET_ENCODE_SECTION_INFO}
@en The usual thing for this hook to do is to record flags in the
@en @code{symbol_ref}, using @code{SYMBOL_REF_FLAG} or @code{SYMBOL_REF_FLAGS}.
@en Historically, the name string was modified if it was necessary to
@en encode more than one bit of information, but this practice is now
@en discouraged; use @code{SYMBOL_REF_FLAGS}.
该钩子通常做的事情是记录@code{symbol_ref}中的标记，
使用@code{SYMBOL_REF_FLAG}或@code{SYMBOL_REF_FLAGS}。

@en The default definition of this hook, @code{default_encode_section_info}
@en in @file{varasm.c}, sets a number of commonly-useful bits in
@en @code{SYMBOL_REF_FLAGS}.  Check whether the default does what you need
@en before overriding it.
该钩子的缺省定义，@file{varasm.c}中的@code{default_encode_section_info}，
设置了@code{SYMBOL_REF_FLAGS}中通常有用的位。
在覆盖它之前检查缺省代码是否做了你所需要的。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_STRIP_NAME_ENCODING (const char *@var{name})
@en Decode @var{name} and return the real name part, sans
@en the characters that @code{TARGET_ENCODE_SECTION_INFO}
@en may have added.
解析@var{name}并返回真实的名字部分，
没有@code{TARGET_ENCODE_SECTION_INFO}可能加进去的字符。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_IN_SMALL_DATA_P (const_tree @var{exp})
@en Returns true if @var{exp} should be placed into a ``small data'' section.
@en The default version of this hook always returns false.
返回真，如果@var{exp}应该被放到“小数据”section中。该钩子的缺省版本总是返回假。
@end deftypefn

@deftypevr {Target Hook} bool TARGET_HAVE_SRODATA_SECTION
@en Contains the value true if the target places read-only
@en ``small data'' into a separate section.  The default value is false.
如果target将只读“小数据”放到单独的section中，则包含值为真。缺省值为假。
@end deftypevr

@deftypefn {Target Hook} bool TARGET_PROFILE_BEFORE_PROLOGUE (void)
It returns true if target wants profile code emitted before prologue.

The default version of this hook use the target macro
@code{PROFILE_BEFORE_PROLOGUE}.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_BINDS_LOCAL_P (const_tree @var{exp})
@en Returns true if @var{exp} names an object for which name resolution
@en rules must resolve to the current ``module'' (dynamic shared library
@en or executable image).
返回真，如果@var{exp}命名了一个对象，其名字解析规则必须

@en The default version of this hook implements the name resolution rules
@en for ELF, which has a looser model of global name binding than other
@en currently supported object file formats.
该钩子的缺省版本实现了ELF的名字解析规则，
其具有一个比目前支持的其它目标文件格式较松散的全局名字绑定模型。
@end deftypefn

@deftypevr {Target Hook} bool TARGET_HAVE_TLS
@en Contains the value true if the target supports thread-local storage.
@en The default value is false.
如果target支持thread-local storage，则包含值为真。缺省值为假。
@end deftypevr

@en @node PIC
@en @section Position Independent Code
@node PIC
@section 位置独立代码
@cindex position independent code
@cindex PIC

@en This section describes macros that help implement generation of position
@en independent code.  Simply defining these macros is not enough to
@en generate valid PIC; you must also add support to the hook
@en @code{TARGET_LEGITIMATE_ADDRESS_P} and to the macro
@en @code{PRINT_OPERAND_ADDRESS}, as well as @code{LEGITIMIZE_ADDRESS}.  You
@en must modify the definition of @samp{movsi} to do something appropriate
@en when the source operand contains a symbolic address.  You may also
@en need to alter the handling of switch statements so that they use
@en relative addresses.
这一节描述了帮助实现位置独立代码生成的宏。
简单的定义这些宏并不足以生成有效的PIC；
你必须还要增加对宏@code{GO_IF_LEGITIMATE_ADDRESS}和
@code{PRINT_OPERAND_ADDRESS}的支持，还有@code{LEGITIMIZE_ADDRESS}。
你必须修改@samp{movsi}的定义，
当源操作数包含一个符号地址时来做一些适当的处理。
还可能需要修改switch语句的处理，使得它们使用相对地址。

@c i rearranged the order of the macros above to try to force one of 
@c them to the next line, to eliminate an overfull hbox. --mew 10feb93

@defmac PIC_OFFSET_TABLE_REGNUM
@en The register number of the register used to address a table of static
@en data addresses in memory.  In some cases this register is defined by a
@en processor's ``application binary interface'' (ABI)@.  When this macro
@en is defined, RTL is generated for this register once, as with the stack
@en pointer and frame pointer registers.  If this macro is not defined, it
@en is up to the machine-dependent files to allocate such a register (if
@en necessary).  Note that this register must be fixed when in use (e.g.@:
@en when @code{flag_pic} is true).
用于寻址内存中静态数据地址表的寄存器的编号。一些情况下，
该寄存器由处理器的“应用二进制接口”（ABI）定义。当该宏被定义时，
会为该寄存器生成一次 RTL，使用栈指针和帧指针寄存器。如果该宏没有被定义，
则需要机器相关文件来分配这样的寄存器（如果需要的话）。
注意该寄存器在使用时（即当@code{flag_pic}为真时）必须为固定的。
@end defmac

@defmac PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
@en A C expression that is nonzero if the register defined by
@en @code{PIC_OFFSET_TABLE_REGNUM} is clobbered by calls.  If not defined,
@en the default is zero.  Do not define
@en this macro if @code{PIC_OFFSET_TABLE_REGNUM} is not defined.
定义该宏，如果由@code{PIC_OFFSET_TABLE_REGNUM}定义的寄存器被调用破坏。
如果@code{PIC_OFFSET_TABLE_REGNUM}没有被定义，则不要定义该宏。
@end defmac

@defmac LEGITIMATE_PIC_OPERAND_P (@var{x})
@en A C expression that is nonzero if @var{x} is a legitimate immediate
@en operand on the target machine when generating position independent code.
@en You can assume that @var{x} satisfies @code{CONSTANT_P}, so you need not
@en check this.  You can also assume @var{flag_pic} is true, so you need not
@en check it either.  You need not define this macro if all constants
@en (including @code{SYMBOL_REF}) can be immediate operands when generating
@en position independent code.
一个C表达式，如果当生成位置独立代码时，
@var{x}为target机器上的合法的立即数操作数，则为非零。
你可以假设@var{x}满足@code{CONSTANT_P}，所以不需要进行检查。
你还可以假设@var{flag_pic}为真，所以也不需要进行检查。
如果当生成位置独立代码时，
所有的常量（包括@code{SYMBOL_REF}）都可以为立即操作数，则不需要定义该宏。
@end defmac

@en @node Assembler Format
@en @section Defining the Output Assembler Language
@node Assembler Format
@section 定义汇编语言输出

@en This section describes macros whose principal purpose is to describe how
@en to write instructions in assembler language---rather than what the
@en instructions do.
这一节描述的宏，主要用于描述如何使用汇编语言书写指令，而不是指令本身。

@en @menu
@en * File Framework::       Structural information for the assembler file.
@en * Data Output::          Output of constants (numbers, strings, addresses).
@en * Uninitialized Data::   Output of uninitialized variables.
@en * Label Output::         Output and generation of labels.
@en * Initialization::       General principles of initialization
@en                          and termination routines.
@en * Macros for Initialization::
@en                          Specific macros that control the handling of
@en                          initialization and termination routines.
@en * Instruction Output::   Output of actual instructions.
@en * Dispatch Tables::      Output of jump tables.
@en * Exception Region Output:: Output of exception region code.
@en * Alignment Output::     Pseudo ops for alignment and skipping data.
@en @end menu
@menu
* File Framework::		汇编文件的结构化信息  
* Data Output::			常量（数目，字符串，地址）的输出
* Uninitialized Data::		未初始化变量的输出
* Label Output::		标号的输出和生成
* Initialization::		初始化程序和终止程序的通用原则
* Macros for Initialization::	控制处理初始化程序和终止程序的特定宏
* Instruction Output::		实际指令的输出
* Dispatch Tables::		跳转表的输出
* Exception Region Output::	异常区域代码的输出
* Alignment Output::		用于对齐和跳过数据的伪操作
@end menu

@en @node File Framework
@en @subsection The Overall Framework of an Assembler File
@node File Framework
@subsection 汇编文件的总体框架
@cindex assembler format
@cindex output of assembler code

@c prevent bad page break with this line
@en This describes the overall framework of an assembly file.
这章描述了汇编文件的总体框架。

@findex default_file_start
@deftypefn {Target Hook} void TARGET_ASM_FILE_START (void)
@en Output to @code{asm_out_file} any text which the assembler expects to
@en find at the beginning of a file.  The default behavior is controlled
@en by two flags, documented below.  Unless your target's assembler is
@en quite unusual, if you override the default, you should call
@en @code{default_file_start} at some point in your target hook.  This
@en lets other target files rely on these variables.
将汇编器期望在文件起始处发现的任何文本输出到@code{asm_out_file}。
缺省行为由两个标志控制，将在下面介绍。除非你target的汇编器十分不常见，
如果你覆盖了缺省，则应该在你的target钩子上的某处调用@code{default_file_start}。
这将让其它target文件依赖于这些变量。
@end deftypefn

@deftypevr {Target Hook} bool TARGET_ASM_FILE_START_APP_OFF
@en If this flag is true, the text of the macro @code{ASM_APP_OFF} will be
@en printed as the very first line in the assembly file, unless
@en @option{-fverbose-asm} is in effect.  (If that macro has been defined
@en to the empty string, this variable has no effect.)  With the normal
@en definition of @code{ASM_APP_OFF}, the effect is to notify the GNU
@en assembler that it need not bother stripping comments or extra
@en whitespace from its input.  This allows it to work a bit faster.
如果该标记为真，则宏@code{ASM_APP_OFF}的文本将作为汇编文本的第一行被打印，
除非正在使用@option{-fverbose-asm}。（如果那个宏被定义为空字符串，
则该变量将不起作用。）对于@code{ASM_APP_OFF}的通常定义，
其效果是告知GNU汇编器不需要费功夫从输入中去除掉注释或额外的空格。
这将使得运行更快些。

@en The default is false.  You should not set it to true unless you have
@en verified that your port does not generate any extra whitespace or
@en comments that will cause GAS to issue errors in NO_APP mode.
缺省为假。不要将其设为真，除非你已经核实你的port不会产生任何额外的空格或者注释，
这将使得GAS在NO_APP模式下产生错误。
@end deftypevr

@deftypevr {Target Hook} bool TARGET_ASM_FILE_START_FILE_DIRECTIVE
@en If this flag is true, @code{output_file_directive} will be called
@en for the primary source file, immediately after printing
@en @code{ASM_APP_OFF} (if that is enabled).  Most ELF assemblers expect
@en this to be done.  The default is false.
如果该标记为真，对于主源文件，@code{output_file_directive}将被调用，
就在打印了@code{ASM_APP_OFF}之后（如果启用了该功能）。
大多数ELF汇编器期望做这件事。缺省为假。
@end deftypevr

@deftypefn {Target Hook} void TARGET_ASM_FILE_END (void)
@en Output to @code{asm_out_file} any text which the assembler expects
@en to find at the end of a file.  The default is to output nothing.
将汇编器期望在文件结尾发现的任何文本输出到中。缺省为什么也不输出。
@end deftypefn

@deftypefun void file_end_indicate_exec_stack ()
@en Some systems use a common convention, the @samp{.note.GNU-stack}
@en special section, to indicate whether or not an object file relies on
@en the stack being executable.  If your system uses this convention, you
@en should define @code{TARGET_ASM_FILE_END} to this function.  If you
@en need to do other things in that hook, have your hook function call
@en this function.
一些系统使用通用的约定，用特定的@samp{.note.GNU-stack} section，
来指示一个依赖栈的目标文件是否被执行。如果你的系统使用了该约定，
你应该将@code{TARGET_ASM_FILE_END}定义为该函数。
如果你需要在钩子中做其它事情，则要在你的钩子函数中调用该函数。
@end deftypefun

@deftypefn {Target Hook} void TARGET_ASM_LTO_START (void)
@en Output to @code{asm_out_file} any text which the assembler expects
@en to find at the start of an LTO section.  The default is to output
@en nothing.
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_LTO_END (void)
@en Output to @code{asm_out_file} any text which the assembler expects
@en to find at the end of an LTO section.  The default is to output
@en nothing.
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_CODE_END (void)
@en Output to @code{asm_out_file} any text which is needed before emitting
@en unwind info and debug info at the end of a file.  Some targets emit
@en here PIC setup thunks that cannot be emitted at the end of file,
@en because they couldn't have unwind info then.  The default is to output
@en nothing.
@end deftypefn

@defmac ASM_COMMENT_START
@en A C string constant describing how to begin a comment in the target
@en assembler language.  The compiler assumes that the comment will end at
@en the end of the line.
一个C字符串常量，描述了如何在target汇编语言中起始一条注释。
编译器假设注释将结束于行尾。
@end defmac

@defmac ASM_APP_ON
@en A C string constant for text to be output before each @code{asm}
@en statement or group of consecutive ones.  Normally this is
@en @code{"#APP"}, which is a comment that has no effect on most
@en assemblers but tells the GNU assembler that it must check the lines
@en that follow for all valid assembler constructs.
一个C字符串常量，将在每个@code{asm}语句或者一组连续的@code{asm}语句之前被输出。
通常为@code{"#APP"}，其为一条注释，对于多数汇编器不起作用，
但可以告诉GNU汇编器必须对随后的行检查所有的有效汇编结构。
@end defmac

@defmac ASM_APP_OFF
@en A C string constant for text to be output after each @code{asm}
@en statement or group of consecutive ones.  Normally this is
@en @code{"#NO_APP"}, which tells the GNU assembler to resume making the
@en time-saving assumptions that are valid for ordinary compiler output.
一个C字符串常量，将在每个@code{asm}语句或者一组连续的@code{asm}语句之前被输出。
通常为@code{"#NO_APP"}，告诉GNU汇编器继续进行省时的假设，
认为通常的编译器输出是有效的。
@end defmac

@defmac ASM_OUTPUT_SOURCE_FILENAME (@var{stream}, @var{name})
@en A C statement to output COFF information or DWARF debugging information
@en which indicates that filename @var{name} is the current source file to
@en the stdio stream @var{stream}.
一条C语句，输出COFF信息或者DWARF调试信息，
用来指示文件名@var{name}为当前的对于标准输入输出流@var{stream}的源文件。

@en This macro need not be defined if the standard form of output
@en for the file format in use is appropriate.
该宏不需要被定义，如果输出的标准形式适用于正在使用的文件格式。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_SOURCE_FILENAME (FILE *@var{file}, const char *@var{name})
Output COFF information or DWARF debugging information which indicates that filename @var{name} is the current source file to the stdio stream @var{file}.
 
 This target hook need not be defined if the standard form of output for the file format in use is appropriate.
@end deftypefn

@defmac OUTPUT_QUOTED_STRING (@var{stream}, @var{string})
@en A C statement to output the string @var{string} to the stdio stream
@en @var{stream}.  If you do not call the function @code{output_quoted_string}
@en in your config files, GCC will only call it to output filenames to
@en the assembler source.  So you can use it to canonicalize the format
@en of the filename using this macro.
一条C语句，将字符串@var{string}输出到stdio流@var{stream}中。
如果你不在你的配置文件中调用函数@code{output_quoted_string}，
则GCC将只调用它来输出文件名到汇编源文件中。
所以你可以使用它来规范使用该宏的文件名的格式。
@end defmac

@defmac ASM_OUTPUT_IDENT (@var{stream}, @var{string})
@en A C statement to output something to the assembler file to handle a
@en @samp{#ident} directive containing the text @var{string}.  If this
@en macro is not defined, nothing is output for a @samp{#ident} directive.
一条C语句，用来输出一些东西到汇编文件中，
以处理包含文本@var{string}的@samp{#ident}伪指令。如果没有定义该宏，
对于@samp{#ident}伪指令，将不输出任何东西。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_NAMED_SECTION (const char *@var{name}, unsigned int @var{flags}, tree @var{decl})
@en Output assembly directives to switch to section @var{name}.  The section
@en should have attributes as specified by @var{flags}, which is a bit mask
@en of the @code{SECTION_*} flags defined in @file{output.h}.  If @var{decl}
@en is non-NULL, it is the @code{VAR_DECL} or @code{FUNCTION_DECL} with which
@en this section is associated.
输出汇编伪指令来切换section名字。section应该具有@var{flags}指定的属性，
其为@file{output.h}中定义的@code{SECTION_*}标记的位掩码。如果@var{align}非零，
则其包含了用于section的对齐字节数，否则将使用target缺省的。
只有那些必须在section伪指令里指定对齐的target才需要关注@var{align}
 — 我们仍然使用@code{ASM_OUTPUT_ALIGN}。
@end deftypefn

@deftypefn {Target Hook} {section *} TARGET_ASM_FUNCTION_SECTION (tree @var{decl}, enum node_frequency @var{freq}, bool @var{startup}, bool @var{exit})
Return preferred text (sub)section for function @var{decl}.
Main purpose of this function is to separate cold, normal and hot
functions. @var{startup} is true when function is known to be used only 
at startup (from static constructors or it is @code{main()}).
@var{exit} is true when function is known to be used only at exit
(from static destructors).
Return NULL if function should go to default text section.
@end deftypefn

@deftypevr {Target Hook} bool TARGET_HAVE_NAMED_SECTIONS
@en This flag is true if the target supports @code{TARGET_ASM_NAMED_SECTION}.
@en It must not be modified by command-line option processing.
该标记为真，如果target支持@code{TARGET_ASM_NAMED_SECTION}。不要在命令行选项处理的时候来修改它。
@end deftypevr

@anchor{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}
@deftypevr {Target Hook} bool TARGET_HAVE_SWITCHABLE_BSS_SECTIONS
@en This flag is true if we can create zeroed data by switching to a BSS
@en section and then using @code{ASM_OUTPUT_SKIP} to allocate the space.
@en This is true on most ELF targets.
该标记为真，如果我们能够通过切换到BSS section来创建初始化为0的数据，
并且使用@code{ASM_OUTPUT_SKIP}来分配空间。这在大多数ELF target上为真。
@end deftypevr

@deftypefn {Target Hook} {unsigned int} TARGET_SECTION_TYPE_FLAGS (tree @var{decl}, const char *@var{name}, int @var{reloc})
@en Choose a set of section attributes for use by @code{TARGET_ASM_NAMED_SECTION}
@en based on a variable or function decl, a section name, and whether or not the
@en declaration's initializer may contain runtime relocations.  @var{decl} may be
@en null, in which case read-write data should be assumed.
根据变量或函数decl，section名name，和声明的初始化是否可以包含运行时重定位，
来选择供@code{TARGET_ASM_NAMED_SECTION}使用的section属性集。
@var{decl}可以为null，这种情况下，将假设为可读写数据。

@en The default version of this function handles choosing code vs data,
@en read-only vs read-write data, and @code{flag_pic}.  You should only
@en need to override this if your target has special flags that might be
@en set via @code{__attribute__}.
该函数的缺省版本用来处理选择代码和数据，只读数据和可读写数据，
以及@code{flag_pic}。
你应该只有在你的target具有通过@code{__attribute__}设置的特定标记时，
才需要覆盖该函数。
@end deftypefn

@deftypefn {Target Hook} int TARGET_ASM_RECORD_GCC_SWITCHES (print_switch_type @var{type}, const char *@var{text})
@en Provides the target with the ability to record the gcc command line
@en switches that have been passed to the compiler, and options that are
@en enabled.  The @var{type} argument specifies what is being recorded.
@en It can take the following values:
使得target能够记录传给编译器的gcc命令行开关，和打开的选项。
参数@var{type}指定了要记录的内容。其可以为下面的值：

@en @table @gcctabopt
@en @item SWITCH_TYPE_PASSED
@en @var{text} is a command line switch that has been set by the user.
@en 
@en @item SWITCH_TYPE_ENABLED
@en @var{text} is an option which has been enabled.  This might be as a
@en direct result of a command line switch, or because it is enabled by
@en default or because it has been enabled as a side effect of a different
@en command line switch.  For example, the @option{-O2} switch enables
@en various different individual optimization passes.
@en 
@en @item SWITCH_TYPE_DESCRIPTIVE
@en @var{text} is either NULL or some descriptive text which should be
@en ignored.  If @var{text} is NULL then it is being used to warn the
@en target hook that either recording is starting or ending.  The first
@en time @var{type} is SWITCH_TYPE_DESCRIPTIVE and @var{text} is NULL, the
@en warning is for start up and the second time the warning is for
@en wind down.  This feature is to allow the target hook to make any
@en necessary preparations before it starts to record switches and to
@en perform any necessary tidying up after it has finished recording
@en switches.
@en 
@en @item SWITCH_TYPE_LINE_START
@en This option can be ignored by this target hook.
@en 
@en @item  SWITCH_TYPE_LINE_END
@en This option can be ignored by this target hook.
@en @end table
@table @gcctabopt
@item SWITCH_TYPE_PASSED
@var{text}为用户设置的命令行开关。 

@item SWITCH_TYPE_ENABLED
@var{text}为开启的选项。这可能为命令行开关的直接结果，或者是因为其被缺省打开，
或者因为其被不同的命令行开关的副作用打开。例如，
@option{-O2}开关打开了各种不同的独立的优化过程。 

@item SWITCH_TYPE_DESCRIPTIVE
@var{text}或者为NULL，或者为一些应该被忽略的描述文本。如果@var{text}text为NULL，
则其被用来警告target钩子记录开始或者结束。第一次，
@var{type}为SWITCH_TYPE_DESCRIPTIVE并且@var{text}为NULL，这是警告记录开始了，
第二次，是警告结束了。该特征可以允许target钩子来做任何需要的准备，
在其开始记录开关的时候，并执行一些比较的整理，在其完成记录开关之后。

@item SWITCH_TYPE_LINE_START
该选项可以被该target钩子忽略掉。 

@item  SWITCH_TYPE_LINE_END
该选项可以被该target钩子忽略掉。 
@end table

@en The hook's return value must be zero.  Other return values may be
@en supported in the future.
钩子的返回值必须为0。其它返回值可能在将来被支持。

@en By default this hook is set to NULL, but an example implementation is
@en provided for ELF based targets.  Called @var{elf_record_gcc_switches},
@en it records the switches as ASCII text inside a new, string mergeable
@en section in the assembler output file.  The name of the new section is
@en provided by the @code{TARGET_ASM_RECORD_GCC_SWITCHES_SECTION} target
@en hook.
缺省下，该钩子被设为NULL，但是对于基于ELF的target，有一个实现例子。
叫做@var{elf_record_gcc_switches}，其记录了开关，
并作为ASCII文本放在汇编输出文件中一个新的，可以字符串合并的section。
新section的名字由target钩子@code{TARGET_ASM_RECORD_GCC_SWITCHES_SECTION}提供。
@end deftypefn

@deftypevr {Target Hook} {const char *} TARGET_ASM_RECORD_GCC_SWITCHES_SECTION
@en This is the name of the section that will be created by the example
@en ELF implementation of the @code{TARGET_ASM_RECORD_GCC_SWITCHES} target
@en hook.
这是@code{TARGET_ASM_RECORD_GCC_SWITCHES} target钩子的ELF实现的例子所创建的section名字。
@end deftypevr

@need 2000
@en @node Data Output
@en @subsection Output of Data
@node Data Output
@subsection 数据的输出


@deftypevr {Target Hook} {const char *} TARGET_ASM_BYTE_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_HI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_SI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_DI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_TI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_HI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_SI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_DI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_TI_OP
@en These hooks specify assembly directives for creating certain kinds
@en of integer object.  The @code{TARGET_ASM_BYTE_OP} directive creates a
@en byte-sized object, the @code{TARGET_ASM_ALIGNED_HI_OP} one creates an
@en aligned two-byte object, and so on.  Any of the hooks may be
@en @code{NULL}, indicating that no suitable directive is available.
这些钩子指定了用于创建特定类型的整数对象的汇编伪指令。
@code{TARGET_ASM_BYTE_OP}伪指令创建一个字节大小的对象，
@code{TARGET_ASM_ALIGNED_HI_OP}创建一个两个字节对齐的对象，等等。
这些钩子都可以为@code{NULL}，这表示没有合适的伪指令。

@en The compiler will print these strings at the start of a new line,
@en followed immediately by the object's initial value.  In most cases,
@en the string should contain a tab, a pseudo-op, and then another tab.
编译器将在一个新行中的起始处打印这些字符串，随后紧跟对象的初始化值。
大多数情况下，字符串应该包含一个tab，一个伪操作符，然后是另一个tab。
@end deftypevr

@deftypefn {Target Hook} bool TARGET_ASM_INTEGER (rtx @var{x}, unsigned int @var{size}, int @var{aligned_p})
@en The @code{assemble_integer} function uses this hook to output an
@en integer object.  @var{x} is the object's value, @var{size} is its size
@en in bytes and @var{aligned_p} indicates whether it is aligned.  The
@en function should return @code{true} if it was able to output the
@en object.  If it returns false, @code{assemble_integer} will try to
@en split the object into smaller parts.
函数@code{assemble_integer}使用该钩子来输出一个整数对象。@var{x}为对象的值，
@var{size}为它的以字节为单位的大小，@var{aligned_p}指示其是否为对齐的。
函数应该返回真，如果它能够输出对象。如果返回假，
则@code{assemble_integer}将尝试把对象分割为更小的部分。

@en The default implementation of this hook will use the
@en @code{TARGET_ASM_BYTE_OP} family of strings, returning @code{false}
@en when the relevant string is @code{NULL}.
该钩子的缺省实现将使用@code{TARGET_ASM_BYTE_OP}字符串家族，
当相应字符串为@code{NULL}时返回假。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA (FILE *@var{file}, rtx @var{x})
A target hook to recognize @var{rtx} patterns that @code{output_addr_const}
can't deal with, and output assembly code to @var{file} corresponding to
the pattern @var{x}.  This may be used to allow machine-dependent
@code{UNSPEC}s to appear within constants.

If target hook fails to recognize a pattern, it must return @code{false},
so that a standard error message is printed.  If it prints an error message
itself, by calling, for example, @code{output_operand_lossage}, it may just
return @code{true}.
@end deftypefn

@defmac OUTPUT_ADDR_CONST_EXTRA (@var{stream}, @var{x}, @var{fail})
@en A C statement to recognize @var{rtx} patterns that
@en @code{output_addr_const} can't deal with, and output assembly code to
@en @var{stream} corresponding to the pattern @var{x}.  This may be used to
@en allow machine-dependent @code{UNSPEC}s to appear within constants.
一条C语句用来识别@code{output_addr_const}不能处理的@var{rtx}模式，
并输出汇编代码到模式@var{x}对应的@var{stream}中。
这可以用来允许在常量中出现机器相关的@code{UNSPEC}。

@en If @code{OUTPUT_ADDR_CONST_EXTRA} fails to recognize a pattern, it must
@en @code{goto fail}, so that a standard error message is printed.  If it
@en prints an error message itself, by calling, for example,
@en @code{output_operand_lossage}, it may just complete normally.
如果@code{OUTPUT_ADDR_CONST_EXTRA}没有能够识别出指令模式，
其必须@code{goto fail}， 这样就会打印出一个标准错误消息。
如果其本身打印了一个错误消息，
例如通过调用@code{output_operand_lossage}，其可以正常的结束。
@end defmac

@defmac ASM_OUTPUT_ASCII (@var{stream}, @var{ptr}, @var{len})
@en A C statement to output to the stdio stream @var{stream} an assembler
@en instruction to assemble a string constant containing the @var{len}
@en bytes at @var{ptr}.  @var{ptr} will be a C expression of type
@en @code{char *} and @var{len} a C expression of type @code{int}.
一条C语句，用来输出到stdio流@var{stream}中一条汇编指令，
以组合一个在@var{ptr}处包含@var{len}个字节的字符串常量。
@var{ptr}将为一个@code{char *}类型的C表达式，
@var{len}为一个@code{int}型的C表达式。

@en If the assembler has a @code{.ascii} pseudo-op as found in the
@en Berkeley Unix assembler, do not define the macro
@en @code{ASM_OUTPUT_ASCII}.
如果汇编器具有一个@code{.ascii}伪指令，正如在Berkeley Unix汇编器上的，
则不要定义宏@code{ASM_OUTPUT_ASCII}。
@end defmac

@defmac ASM_OUTPUT_FDESC (@var{stream}, @var{decl}, @var{n})
@en A C statement to output word @var{n} of a function descriptor for
@en @var{decl}.  This must be defined if @code{TARGET_VTABLE_USES_DESCRIPTORS}
@en is defined, and is otherwise unused.
一条C语句，用来输出@var{decl}的函数描述符的字@var{n}。
这必须在定义@code{TARGET_VTABLE_USES_DESCRIPTORS}时被定义，否则将不起作用。
@end defmac

@defmac CONSTANT_POOL_BEFORE_FUNCTION
@en You may define this macro as a C expression.  You should define the
@en expression to have a nonzero value if GCC should output the constant
@en pool for a function before the code for the function, or a zero value if
@en GCC should output the constant pool after the function.  If you do
@en not define this macro, the usual case, GCC will output the constant
@en pool before the function.
你可以定义该宏为一个C表达式。你应该定义表达式具有非零值，
如果GCC应该在输出函数的代码前，输出常量池，或者定义为0，
如果GCC应该在函数后输出常量池。如果你不定义该宏，则通常情况下，
GCC将在函数前输出常量池。
@end defmac

@defmac ASM_OUTPUT_POOL_PROLOGUE (@var{file}, @var{funname}, @var{fundecl}, @var{size})
@en A C statement to output assembler commands to define the start of the
@en constant pool for a function.  @var{funname} is a string giving
@en the name of the function.  Should the return type of the function
@en be required, it can be obtained via @var{fundecl}.  @var{size}
@en is the size, in bytes, of the constant pool that will be written
@en immediately after this call.
一条C语句，用来输出汇编命令，以定义函数的常量池的起始。
@var{funname}为一个字符串，给定了函数的名字。如果需要函数的返回类型，
则可以通过@var{fundecl}来获得。
@var{size}为在该调用之后要立即写入的常量池的大小，以字节为单位。

@en If no constant-pool prefix is required, the usual case, this macro need
@en not be defined.
通常情况下，如果不需要常量池前缀，该宏不需要被定义。
@end defmac

@defmac ASM_OUTPUT_SPECIAL_POOL_ENTRY (@var{file}, @var{x}, @var{mode}, @var{align}, @var{labelno}, @var{jumpto})
@en A C statement (with or without semicolon) to output a constant in the
@en constant pool, if it needs special treatment.  (This macro need not do
@en anything for RTL expressions that can be output normally.)
一条C语句（带有或者不带有分号），用来输出一个常量在常量池中，
如果其需要特殊的处理。（该宏对于可以正常输出的RTL表达式不需要做任何事情。）

@en The argument @var{file} is the standard I/O stream to output the
@en assembler code on.  @var{x} is the RTL expression for the constant to
@en output, and @var{mode} is the machine mode (in case @var{x} is a
@en @samp{const_int}).  @var{align} is the required alignment for the value
@en @var{x}; you should output an assembler directive to force this much
@en alignment.
参数@var{file}为将汇编代码输出到的标准I/O流。@var{x}为要输出的常量的RTL表达式，
@var{mode}为机器模式（用于@var{x}为@samp{const_int}时）。
@var{align}为值@var{x}所需要的对齐；你应该输出一个汇编伪指令来执行该对齐。

@en The argument @var{labelno} is a number to use in an internal label for
@en the address of this pool entry.  The definition of this macro is
@en responsible for outputting the label definition at the proper place.
@en Here is how to do this:
参数@var{labelno}为该池中实体的地址的内部标号的编号。
该宏的定义负责在合适的地方输出标号的定义。这里有一个实现的例子：

@smallexample
@code{(*targetm.asm_out.internal_label)} (@var{file}, "LC", @var{labelno});
@end smallexample

@en When you output a pool entry specially, you should end with a
@en @code{goto} to the label @var{jumpto}.  This will prevent the same pool
@en entry from being output a second time in the usual manner.
当你专门输出一个池中实体时，你应该结束于一个@code{goto}，
以跳转到标号@var{jumpto}。这将阻止相同的池中实体通过通常的方式被再一次输出。

@en You need not define this macro if it would do nothing.
如果不做任何事情，则不要定义该宏。
@end defmac

@defmac ASM_OUTPUT_POOL_EPILOGUE (@var{file} @var{funname} @var{fundecl} @var{size})
@en A C statement to output assembler commands to at the end of the constant
@en pool for a function.  @var{funname} is a string giving the name of the
@en function.  Should the return type of the function be required, you can
@en obtain it via @var{fundecl}.  @var{size} is the size, in bytes, of the
@en constant pool that GCC wrote immediately before this call.
一条C语句，用来输出汇编命令到函数常量池的结尾。@var{funname}为一个字符串，
给出了函数的名字。如果需要函数的返回类型，可以通过@var{fundecl}来获得。
@var{size}为GCC在该调用之前立即写入的常量池的大小，以字节为单位。

@en If no constant-pool epilogue is required, the usual case, you need not
@en define this macro.
通常情况下，如果不需要常量池结束语，则不需要定义该宏。
@end defmac

@defmac IS_ASM_LOGICAL_LINE_SEPARATOR (@var{C}, @var{STR})
@en Define this macro as a C expression which is nonzero if @var{C} is
@en used as a logical line separator by the assembler.  @var{STR} points
@en to the position in the string where @var{C} was found; this can be used if
@en a line separator uses multiple characters.
定义该宏为一个C表达式，其为非零，如果@var{C}被汇编器用作逻辑行分隔符。
@var{STR}指向在字符串中@var{C}被发现的位置；
这可以用于行分隔符使用多个字符的时候。

@en If you do not define this macro, the default is that only
@en the character @samp{;} is treated as a logical line separator.
如果你不定义该宏，则缺省的为只将字符@samp{;}作为逻辑行的分隔符。
@end defmac

@deftypevr {Target Hook} {const char *} TARGET_ASM_OPEN_PAREN
@deftypevrx {Target Hook} {const char *} TARGET_ASM_CLOSE_PAREN
@en These target hooks are C string constants, describing the syntax in the
@en assembler for grouping arithmetic expressions.  If not overridden, they
@en default to normal parentheses, which is correct for most assemblers.
这些target钩子为C字符串常量，描述了算术表达式组合的汇编语法。
如果没有被覆盖，它们缺省为通常的括号，这对大多数汇编器都是正确的。
@end deftypevr

@en These macros are provided by @file{real.h} for writing the definitions
@en of @code{ASM_OUTPUT_DOUBLE} and the like:
这些宏由@file{real.h}提供，用于写@code{ASM_OUTPUT_DOUBLE}等的定义：

@defmac REAL_VALUE_TO_TARGET_SINGLE (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DOUBLE (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_LONG_DOUBLE (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DECIMAL32 (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DECIMAL64 (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DECIMAL128 (@var{x}, @var{l})
@en These translate @var{x}, of type @code{REAL_VALUE_TYPE}, to the
@en target's floating point representation, and store its bit pattern in
@en the variable @var{l}.  For @code{REAL_VALUE_TO_TARGET_SINGLE} and
@en @code{REAL_VALUE_TO_TARGET_DECIMAL32}, this variable should be a
@en simple @code{long int}.  For the others, it should be an array of
@en @code{long int}.  The number of elements in this array is determined
@en by the size of the desired target floating point data type: 32 bits of
@en it go in each @code{long int} array element.  Each array element holds
@en 32 bits of the result, even if @code{long int} is wider than 32 bits
@en on the host machine.
这些将类型为@code{REAL_VALUE_TYPE}的@var{x}，转换为target的浮点表示，
并将其存储在变量@var{l}中。
对于@code{REAL_VALUE_TO_TARGET_SINGLE}和@code{REAL_VALUE_TO_TARGET_DECIMAL32}，
该变量应该为一个简单的@code{long int}。对于其它的，
其应该为一个@code{long int}的数组。
该数组的元素个数由所需要的target浮点数据类型的大小决定：
每个@code{long int}数组元素有32位。每个数组元素存放32位的结果，
即使@code{long int}在host机器上比32位宽。

@en The array element values are designed so that you can print them out
@en using @code{fprintf} in the order they should appear in the target
@en machine's memory.
数组元素值被设计成，
可以使用@code{fprintf}按照在target机器内存中的顺序来打印它们。
@end defmac

@en @node Uninitialized Data
@en @subsection Output of Uninitialized Variables
@node Uninitialized Data
@subsection 未初始化变量的输出

@en Each of the macros in this section is used to do the whole job of
@en outputting a single uninitialized variable.
这一节的每个宏都是用于输出单个未初始化变量的整个工作中。

@defmac ASM_OUTPUT_COMMON (@var{stream}, @var{name}, @var{size}, @var{rounded})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} the assembler definition of a common-label named
@en @var{name} whose size is @var{size} bytes.  The variable @var{rounded}
@en is the size rounded up to whatever alignment the caller wants.  It is
@en possible that @var{size} may be zero, for instance if a struct with no
@en other member than a zero-length array is defined.  In this case, the
@en backend must output a symbol definition that allocates at least one
@en byte, both so that the address of the resulting object does not compare
@en equal to any other, and because some object formats cannot even express
@en the concept of a zero-sized common symbol, as that is how they represent
@en an ordinary undefined external.
一条C语句（没有分号），用来将大小为@var{size}，
名字为@var{name}的通用标号的汇编定义，输出到stdio流@var{stream}中。
变量@var{rounded}为调用者想要对齐而舍入的大小。

@en Use the expression @code{assemble_name (@var{stream}, @var{name})} to
@en output the name itself; before and after that, output the additional
@en assembler syntax for defining the name, and a newline.
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在这之前和之后，输出额外的定义name的汇编语法，以及换行。

@en This macro controls how the assembler definitions of uninitialized
@en common global variables are output.
该宏控制如何输出未初始化的通用全局变量的汇编定义。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_COMMON (@var{stream}, @var{name}, @var{size}, @var{alignment})
@en Like @code{ASM_OUTPUT_COMMON} except takes the required alignment as a
@en separate, explicit argument.  If you define this macro, it is used in
@en place of @code{ASM_OUTPUT_COMMON}, and gives you more flexibility in
@en handling the required alignment of the variable.  The alignment is specified
@en as the number of bits.
类似@code{ASM_OUTPUT_COMMON}，除了其接受一个alignment，作为独立，显式的参数。
如果你定义了该宏，其被用于替换@code{ASM_OUTPUT_COMMON}，
使得你在处理变量对齐方面变得更加灵活。aligment被指定为位的数目。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_DECL_COMMON (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
@en Like @code{ASM_OUTPUT_ALIGNED_COMMON} except that @var{decl} of the
@en variable to be output, if there is one, or @code{NULL_TREE} if there
@en is no corresponding variable.  If you define this macro, GCC will use it
@en in place of both @code{ASM_OUTPUT_COMMON} and
@en @code{ASM_OUTPUT_ALIGNED_COMMON}.  Define this macro when you need to see
@en the variable's decl in order to chose what to output.
类似@code{ASM_OUTPUT_ALIGNED_COMMON}，除了要被输出的变量的@var{decl}，
如果存在的话，或者为@code{NULL_TREE}如果没有相应的变量。如果你定义了该宏，
GCC将替换@code{ASM_OUTPUT_COMMON}和@code{ASM_OUTPUT_ALIGNED_COMMON}。
当你需要看到变量的decl，以便选择如何输出时，可以定义该宏。
@end defmac

@defmac ASM_OUTPUT_BSS (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{rounded})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} the assembler definition of uninitialized global @var{decl} named
@en @var{name} whose size is @var{size} bytes.  The variable @var{rounded}
@en is the size rounded up to whatever alignment the caller wants.
一条C语句（没有分号），用来将名字为@var{name}，
大小为@var{size}个字节的未初始化的全局@var{decl}的汇编定义输出到stdio流
@var{stream}中。变量@var{rounded}为调用者想要对齐而舍入的大小。

@en Try to use function @code{asm_output_bss} defined in @file{varasm.c} when
@en defining this macro.  If unable, use the expression
@en @code{assemble_name (@var{stream}, @var{name})} to output the name itself;
@en before and after that, output the additional assembler syntax for defining
@en the name, and a newline.
当定义该宏时，可以尝试使用@file{varasm.c}中定义的@code{asm_output_bss}。
如果不行，
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出额外的定义name的汇编语法，以及换行。

@en There are two ways of handling global BSS@.  One is to define either
@en this macro or its aligned counterpart, @code{ASM_OUTPUT_ALIGNED_BSS}.
@en The other is to have @code{TARGET_ASM_SELECT_SECTION} return a
@en switchable BSS section (@pxref{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}).
@en You do not need to do both.
有两种方式来处理全局BSS。一种是定义该宏或者它的对齐副本，
@code{ASM_OUTPUT_ALIGNED_BSS}。
另一种是让@code{TARGET_ASM_SELECT_SECTION}返回一个可切换的BSS section
（参见 @ref{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}）。你不需要两者都做。

@en Some languages do not have @code{common} data, and require a
@en non-common form of global BSS in order to handle uninitialized globals
@en efficiently.  C++ is one example of this.  However, if the target does
@en not support global BSS, the front end may choose to make globals
@en common in order to save space in the object file.
一些语言不具有@code{common}数据，并且要求全局BSS为non-common的，
以便高效的处理未初始化全局变量。C++就是这样的例子。然而，
如果target不支持全局BSS，则前端可以选择生成全局common，
以便在目标文件中节省空间。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_BSS (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
@en Like @code{ASM_OUTPUT_BSS} except takes the required alignment as a
@en separate, explicit argument.  If you define this macro, it is used in
@en place of @code{ASM_OUTPUT_BSS}, and gives you more flexibility in
@en handling the required alignment of the variable.  The alignment is specified
@en as the number of bits.
类似@code{ASM_OUTPUT_BSS}，除了其接受需要的aligment作为单独，显式的参数。
如果你定义了该宏，其被用于替换@code{ASM_OUTPUT_BSS}，
这使得你在处理变量所需的对齐方面更加灵活。aligment被指定为位数。

@en Try to use function @code{asm_output_aligned_bss} defined in file
@en @file{varasm.c} when defining this macro.
当定义该宏时，
尝试使用在文件@file{varasm.c}中定义的函数@code{asm_output_aligned_bss}。
@file{varasm.c} when defining this macro.
@end defmac

@defmac ASM_OUTPUT_LOCAL (@var{stream}, @var{name}, @var{size}, @var{rounded})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} the assembler definition of a local-common-label named
@en @var{name} whose size is @var{size} bytes.  The variable @var{rounded}
@en is the size rounded up to whatever alignment the caller wants.
一条C语句（没有分号），用来将名字为@var{name}，
大小为@var{size}个字节的local-common标号的汇编定义输出到stdio流@var{stream}中。
变量@var{rounded}为调用者想要对齐而舍入的大小。

@en Use the expression @code{assemble_name (@var{stream}, @var{name})} to
@en output the name itself; before and after that, output the additional
@en assembler syntax for defining the name, and a newline.
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出额外的定义name的汇编语法，以及换行。

@en This macro controls how the assembler definitions of uninitialized
@en static variables are output.
该宏控制如何输出未初始化的静态变量的汇编定义。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_LOCAL (@var{stream}, @var{name}, @var{size}, @var{alignment})
@en Like @code{ASM_OUTPUT_LOCAL} except takes the required alignment as a
@en separate, explicit argument.  If you define this macro, it is used in
@en place of @code{ASM_OUTPUT_LOCAL}, and gives you more flexibility in
@en handling the required alignment of the variable.  The alignment is specified
@en as the number of bits.
类似@code{ASM_OUTPUT_LOCAL}，除了其接受需要的aligment作为单独，显式的参数。
如果你定义了该宏，其被用于替换@code{ASM_OUTPUT_LOCAL}，
这使得你在处理变量所需的对齐方面更加灵活。aligment被指定为位数。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_DECL_LOCAL (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
@en Like @code{ASM_OUTPUT_ALIGNED_DECL} except that @var{decl} of the
@en variable to be output, if there is one, or @code{NULL_TREE} if there
@en is no corresponding variable.  If you define this macro, GCC will use it
@en in place of both @code{ASM_OUTPUT_DECL} and
@en @code{ASM_OUTPUT_ALIGNED_DECL}.  Define this macro when you need to see
@en the variable's decl in order to chose what to output.
类似@code{ASM_OUTPUT_ALIGNED_DECL}，除了要被输出的变量的@var{decl}，
如果存在的话，或者为@code{NULL_TREE}如果没有相应的变量。如果你定义了该宏，
GCC将替换@code{ASM_OUTPUT_DECL}和@code{ASM_OUTPUT_ALIGNED_DECL}。
当你需要看到变量的decl，以便选择如何输出时，可以定义该宏。
@end defmac

@en @node Label Output
@en @subsection Output and Generation of Labels
@node Label Output
@subsection 标号的生成和输出

@c prevent bad page break with this line
@en This is about outputting labels.
这节是关于标号输出的。

@findex assemble_name
@defmac ASM_OUTPUT_LABEL (@var{stream}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} the assembler definition of a label named @var{name}.
@en Use the expression @code{assemble_name (@var{stream}, @var{name})} to
@en output the name itself; before and after that, output the additional
@en assembler syntax for defining the name, and a newline.  A default
@en definition of this macro is provided which is correct for most systems.
一条C语句（没有分号），
用来将名字为@var{name}的标号的汇编定义输出到stdio流@var{stream}中。
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出定义name的额外的汇编语法，以及换行。
该宏的缺省定义被提供，其对于多数系统都是正确的。
@end defmac

@defmac ASM_OUTPUT_FUNCTION_LABEL (@var{stream}, @var{name}, @var{decl})
A C statement (sans semicolon) to output to the stdio stream
@var{stream} the assembler definition of a label named @var{name} of
a function.
Use the expression @code{assemble_name (@var{stream}, @var{name})} to
output the name itself; before and after that, output the additional
assembler syntax for defining the name, and a newline.  A default
definition of this macro is provided which is correct for most systems.

If this macro is not defined, then the function name is defined in the
usual manner as a label (by means of @code{ASM_OUTPUT_LABEL}).
@end defmac

@findex assemble_name_raw
@defmac ASM_OUTPUT_INTERNAL_LABEL (@var{stream}, @var{name})
@en Identical to @code{ASM_OUTPUT_LABEL}, except that @var{name} is known
@en to refer to a compiler-generated label.  The default definition uses
@en @code{assemble_name_raw}, which is like @code{assemble_name} except
@en that it is more efficient.
等同于@code{ASM_OUTPUT_LABEL}，除了@var{name}为已知的，引用了编译器生成的标号。
缺省定义使用@code{assemble_name_raw}，其类似于@code{assemble_name}，
只不过更加高效。
@end defmac

@defmac SIZE_ASM_OP
@en A C string containing the appropriate assembler directive to specify the
@en size of a symbol, without any arguments.  On systems that use ELF, the
@en default (in @file{config/elfos.h}) is @samp{"\t.size\t"}; on other
@en systems, the default is not to define this macro.
一个C字符串，包含了适当的汇编伪指令，用于指定符号的大小，不需要任何参数。
在使用ELF的系统上，缺省为（在@file{config/elfos.h}中）@samp{"\t.size\t"}；
在其它系统上，缺省为不定义该宏。

@en Define this macro only if it is correct to use the default definitions
@en of @code{ASM_OUTPUT_SIZE_DIRECTIVE} and @code{ASM_OUTPUT_MEASURED_SIZE}
@en for your system.  If you need your own custom definitions of those
@en macros, or if you do not need explicit symbol sizes at all, do not
@en define this macro.
只有在你的系统上可以正确的使用@code{ASM_OUTPUT_SIZE_DIRECTIVE}和
@code{ASM_OUTPUT_MEASURED_SIZE}的缺省定义时，才定义该宏。
如果对于那些宏，你需要自己特定的定义，或者如果你根本不需要显式的符号大小，
则不要定义该宏。
@end defmac

@defmac ASM_OUTPUT_SIZE_DIRECTIVE (@var{stream}, @var{name}, @var{size})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} a directive telling the assembler that the size of the
@en symbol @var{name} is @var{size}.  @var{size} is a @code{HOST_WIDE_INT}.
@en If you define @code{SIZE_ASM_OP}, a default definition of this macro is
@en provided.
一条C语句（没有分号），用来将一条伪指令输出到stdio流@var{stream}中，
以告诉汇编器符号@var{name}的大小为@var{size}。@var{size}为@code{HOST_WIDE_INT}。
如果你定义了@code{SIZE_ASM_OP}，则该宏的缺省定义会被提供。
@end defmac

@defmac ASM_OUTPUT_MEASURED_SIZE (@var{stream}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} a directive telling the assembler to calculate the size of
@en the symbol @var{name} by subtracting its address from the current
@en address.
一条C语句（没有分号），用来将一条伪指令输出到stdio流@var{stream}中，
以告诉汇编器通过从当前地址减去符号@var{name}的地址，来计算符号的大小。

@en If you define @code{SIZE_ASM_OP}, a default definition of this macro is
@en provided.  The default assumes that the assembler recognizes a special
@en @samp{.} symbol as referring to the current address, and can calculate
@en the difference between this and another symbol.  If your assembler does
@en not recognize @samp{.} or cannot do calculations with it, you will need
@en to redefine @code{ASM_OUTPUT_MEASURED_SIZE} to use some other technique.
如果你定义了@code{SIZE_ASM_OP}，则该宏的缺省定义会被提供。
缺省定义假设汇编器可以识别特殊的@samp{.}符号，作为引用当前地址，
并能够计算该处和其它符号的差。如果你的汇编器不识别@samp{.}，或者不能计算差，
你需要重定义@code{ASM_OUTPUT_MEASURED_SIZE}来使用其它技术。
@end defmac

@defmac TYPE_ASM_OP
@en A C string containing the appropriate assembler directive to specify the
@en type of a symbol, without any arguments.  On systems that use ELF, the
@en default (in @file{config/elfos.h}) is @samp{"\t.type\t"}; on other
@en systems, the default is not to define this macro.
一个C字符串，包含了适当的汇编伪指令，用于指定符号的类型，不需要任何参数。
在使用ELF的系统上，缺省为（在@file{config/elfos.h}中）@samp{"\t.type\t"}；
在其它系统上，缺省为不定义该宏。

@en Define this macro only if it is correct to use the default definition of
@en @code{ASM_OUTPUT_TYPE_DIRECTIVE} for your system.  If you need your own
@en custom definition of this macro, or if you do not need explicit symbol
@en types at all, do not define this macro.
只有在你的系统上可以正确的使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}的缺省定义时，
才定义该宏。如果对于该宏，你需要自己特定的定义，
或者如果你根本不需要显式的符号类型，则不要定义该宏。
@end defmac

@defmac TYPE_OPERAND_FMT
@en A C string which specifies (using @code{printf} syntax) the format of
@en the second operand to @code{TYPE_ASM_OP}.  On systems that use ELF, the
@en default (in @file{config/elfos.h}) is @samp{"@@%s"}; on other systems,
@en the default is not to define this macro.
一个C字符串，
指定了@code{TYPE_ASM_OP}的第二个操作数的格式（使用@code{printf}语法）。
在使用ELF的系统上，缺省为（在@file{config/elfos.h}中）@samp{"@@%s"}；
在其它系统上，缺省为不定义该宏。

@en Define this macro only if it is correct to use the default definition of
@en @code{ASM_OUTPUT_TYPE_DIRECTIVE} for your system.  If you need your own
@en custom definition of this macro, or if you do not need explicit symbol
@en types at all, do not define this macro.
只有在你的系统上可以正确的使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}的缺省定义时，
才定义该宏。如果对于该宏，你需要自己特定的定义，
或者如果你根本不需要显式的符号类型，则不要定义该宏。
@end defmac

@defmac ASM_OUTPUT_TYPE_DIRECTIVE (@var{stream}, @var{type})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} a directive telling the assembler that the type of the
@en symbol @var{name} is @var{type}.  @var{type} is a C string; currently,
@en that string is always either @samp{"function"} or @samp{"object"}, but
@en you should not count on this.
一条C语句（没有分号），用以将一条伪指令输出到stdio流@var{stream}中，
以告诉汇编器符号@var{name}的类型为@var{type}。@var{type}是一个C字符串；
目前该字符串总是@samp{"function"}或者@samp{"object"}，但你不要依赖于此。

@en If you define @code{TYPE_ASM_OP} and @code{TYPE_OPERAND_FMT}, a default
@en definition of this macro is provided.
如果你定义了@code{TYPE_ASM_OP}和@code{TYPE_OPERAND_FMT}，
则该宏的缺省定义会被提供。
@end defmac

@defmac ASM_DECLARE_FUNCTION_NAME (@var{stream}, @var{name}, @var{decl})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} any text necessary for declaring the name @var{name} of a
@en function which is being defined.  This macro is responsible for
@en outputting the label definition (perhaps using
@en @code{ASM_OUTPUT_FUNCTION_LABEL}).  The argument @var{decl} is the
@en @code{FUNCTION_DECL} tree node representing the function.
一条C语句（没有分号），用以将任何声明被定义的函数名字@var{name}所需要的文本，
输出到stdio流@var{stream}中。
该宏负责输出标号定义（或者使用@code{ASM_OUTPUT_LABEL}）。
参数@var{decl}为表示函数的@code{FUNCTION_DECL}树结点。

@en If this macro is not defined, then the function name is defined in the
@en usual manner as a label (by means of @code{ASM_OUTPUT_FUNCTION_LABEL}).
如果该宏没有被定义，
则函数名被作为标号按照通常的方式来定义（使用@code{ASM_OUTPUT_LABEL}）。

@en You may wish to use @code{ASM_OUTPUT_TYPE_DIRECTIVE} in the definition
@en of this macro.
你可能希望在定义该宏时使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}。
@end defmac

@defmac ASM_DECLARE_FUNCTION_SIZE (@var{stream}, @var{name}, @var{decl})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} any text necessary for declaring the size of a function
@en which is being defined.  The argument @var{name} is the name of the
@en function.  The argument @var{decl} is the @code{FUNCTION_DECL} tree node
@en representing the function.
一条C语句（没有分号），用以将任何声明被定义的函数的大小所需要的文本，
输出到stdio流@var{stream}中。参数@var{name}为函数的名字。
参数@var{decl}为表示函数的@code{FUNCTION_DECL}树结点。

@en If this macro is not defined, then the function size is not defined.
如果该宏没有被定义，则函数大小没有被定义。

@en You may wish to use @code{ASM_OUTPUT_MEASURED_SIZE} in the definition
@en of this macro.
你可能希望在定义该宏时使用@code{ASM_OUTPUT_MEASURED_SIZE}。
@end defmac

@defmac ASM_DECLARE_OBJECT_NAME (@var{stream}, @var{name}, @var{decl})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} any text necessary for declaring the name @var{name} of an
@en initialized variable which is being defined.  This macro must output the
@en label definition (perhaps using @code{ASM_OUTPUT_LABEL}).  The argument
@en @var{decl} is the @code{VAR_DECL} tree node representing the variable.
一条C语句（没有分号），
用以将任何声明被定义的初始化变量名字@var{name}所需要的文本，
输出到stdio流@var{stream}中。
该宏必须输出标号定义（可能使用@code{ASM_OUTPUT_LABEL}）。
参数@var{decl}为表示变量的@code{VAR_DECL}树结点。

@en If this macro is not defined, then the variable name is defined in the
@en usual manner as a label (by means of @code{ASM_OUTPUT_LABEL}).
如果该宏没有被定义，
则变量名被作为标号按照通常的方式来定义（使用@code{ASM_OUTPUT_LABEL}）。

@en You may wish to use @code{ASM_OUTPUT_TYPE_DIRECTIVE} and/or
@en @code{ASM_OUTPUT_SIZE_DIRECTIVE} in the definition of this macro.
你可能希望在定义该宏时使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}和/或@code{ASM_OUTPUT_SIZE_DIRECTIVE}。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_DECLARE_CONSTANT_NAME (FILE *@var{file}, const char *@var{name}, const_tree @var{expr}, HOST_WIDE_INT @var{size})
A target hook to output to the stdio stream @var{file} any text necessary
for declaring the name @var{name} of a constant which is being defined.  This
target hook is responsible for outputting the label definition (perhaps using
@code{assemble_label}).  The argument @var{exp} is the value of the constant,
and @var{size} is the size of the constant in bytes.  The @var{name}
will be an internal label.

The default version of this target hook, define the @var{name} in the
usual manner as a label (by means of @code{assemble_label}).

You may wish to use @code{ASM_OUTPUT_TYPE_DIRECTIVE} in this target hook.
@end deftypefn

@defmac ASM_DECLARE_REGISTER_GLOBAL (@var{stream}, @var{decl}, @var{regno}, @var{name})
A C statement (sans semicolon) to output to the stdio stream
@var{stream} any text necessary for claiming a register @var{regno}
for a global variable @var{decl} with name @var{name}.

If you don't define this macro, that is equivalent to defining it to do
nothing.
@end defmac

@defmac ASM_DECLARE_REGISTER_GLOBAL (@var{stream}, @var{decl}, @var{regno}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} any text necessary for claiming a register @var{regno}
@en for a global variable @var{decl} with name @var{name}.
一条C语句（没有分号），用以将任何为具有名字@var{name}的全局变量声明一个寄存器@var{regno}所需要的文本，输出到stdio流@var{stream}中。

@en If you don't define this macro, that is equivalent to defining it to do
@en nothing.
如果没有定义该宏，则相当于定义其什么都不做。
@end defmac

@defmac ASM_FINISH_DECLARE_OBJECT (@var{stream}, @var{decl}, @var{toplevel}, @var{atend})
@en A C statement (sans semicolon) to finish up declaring a variable name
@en once the compiler has processed its initializer fully and thus has had a
@en chance to determine the size of an array when controlled by an
@en initializer.  This is used on systems where it's necessary to declare
@en something about the size of the object.
一条C语句（没有分号），用于在编译器完全处理了初始化者之后，
来完成声明一个变量名，这样当数组的大小由初始化者控制的时候，
就有机会来确定数组的大小。这用于需要声明对象的大小的系统上。

@en If you don't define this macro, that is equivalent to defining it to do
@en nothing.
如果没有定义该宏，则相当于定义其什么都不做。

@en You may wish to use @code{ASM_OUTPUT_SIZE_DIRECTIVE} and/or
@en @code{ASM_OUTPUT_MEASURED_SIZE} in the definition of this macro.
你可能希望在定义该宏时使用@code{ASM_OUTPUT_SIZE_DIRECTIVE}和/或@code{ASM_OUTPUT_MEASURED_SIZE}。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_GLOBALIZE_LABEL (FILE *@var{stream}, const char *@var{name})
@en This target hook is a function to output to the stdio stream
@en @var{stream} some commands that will make the label @var{name} global;
@en that is, available for reference from other files.
该target钩子为一个函数，用于将一些命令输出到stdio流@var{stream}中，
从而使得标号@var{name}为全局的；也就是，可以从其它文件中引用。

@en The default implementation relies on a proper definition of
@en @code{GLOBAL_ASM_OP}.
缺省实现依赖于@code{GLOBAL_ASM_OP}的适当定义。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_GLOBALIZE_DECL_NAME (FILE *@var{stream}, tree @var{decl})
@en This target hook is a function to output to the stdio stream
@en @var{stream} some commands that will make the name associated with @var{decl}
@en global; that is, available for reference from other files.
该target钩子为一个函数，用于将一些命令输出到stdio流@var{stream}中，
从而使得@var{decl}相关联的名字为全局的；也就是，可以从其它文件中引用。

@en The default implementation uses the TARGET_ASM_GLOBALIZE_LABEL target hook.
缺省实现使用TARGET_ASM_GLOBALIZE_LABEL target钩子。
@end deftypefn

@defmac ASM_WEAKEN_LABEL (@var{stream}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} some commands that will make the label @var{name} weak;
@en that is, available for reference from other files but only used if
@en no other definition is available.  Use the expression
@en @code{assemble_name (@var{stream}, @var{name})} to output the name
@en itself; before and after that, output the additional assembler syntax
@en for making that name weak, and a newline.
一条C语句（没有分号），用于将一些命令输出到stdio流@var{stream}中，
从而使得标号@var{name}为弱的；也就是，可以从其它文件中引用，
但只有在没有其它定义的时候。
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出使得name为弱的额外的汇编语法，以及换行。

@en If you don't define this macro or @code{ASM_WEAKEN_DECL}, GCC will not
@en support weak symbols and you should not define the @code{SUPPORTS_WEAK}
@en macro.
如果没有定义该宏或者@code{ASM_WEAKEN_DECL}，
GCC将不支持弱符号并且你不要定义宏@code{SUPPORTS_WEAK}。
@end defmac

@defmac ASM_WEAKEN_DECL (@var{stream}, @var{decl}, @var{name}, @var{value})
@en Combines (and replaces) the function of @code{ASM_WEAKEN_LABEL} and
@en @code{ASM_OUTPUT_WEAK_ALIAS}, allowing access to the associated function
@en or variable decl.  If @var{value} is not @code{NULL}, this C statement
@en should output to the stdio stream @var{stream} assembler code which
@en defines (equates) the weak symbol @var{name} to have the value
@en @var{value}.  If @var{value} is @code{NULL}, it should output commands
@en to make @var{name} weak.
组合（并替换）了函数@code{ASM_WEAKEN_LABEL}和@code{ASM_OUTPUT_WEAK_ALIAS}，
允许访问相关的函数或变量decl。如果@var{value}不为@code{NULL}，
该C语句应该将定义弱符号@var{name}具有值@var{value}的汇编代码，
输出到stdio流@var{stream}中。如果@var{value}为@code{NULL}，
其应该输出命令来使得@var{name}为弱的。
@end defmac

@defmac ASM_OUTPUT_WEAKREF (@var{stream}, @var{decl}, @var{name}, @var{value})
@en Outputs a directive that enables @var{name} to be used to refer to
@en symbol @var{value} with weak-symbol semantics.  @code{decl} is the
@en declaration of @code{name}.
输出一条伪指令，使得@var{name}被用来使用弱符号语义引用符号@var{value}。
@code{decl}为@code{name}的声明。
@end defmac

@defmac SUPPORTS_WEAK
@en A preprocessor constant expression which evaluates to true if the target
@en supports weak symbols.
一个预处理常量表达式，如果target支持弱符号，则求值为真。

@en If you don't define this macro, @file{defaults.h} provides a default
@en definition.  If either @code{ASM_WEAKEN_LABEL} or @code{ASM_WEAKEN_DECL}
@en is defined, the default definition is @samp{1}; otherwise, it is @samp{0}.
如果你没有定义该宏，@file{defaults.h}会提供一个缺省的定义。
如果@code{ASM_WEAKEN_LABEL}或者@code{ASM_WEAKEN_DECL}被定义，
则缺省定义为@samp{1}；否则为@samp{0}。
@end defmac

@defmac TARGET_SUPPORTS_WEAK
A C expression which evaluates to true if the target supports weak symbols.

If you don't define this macro, @file{defaults.h} provides a default
definition.  The default definition is @samp{(SUPPORTS_WEAK)}.  Define
this macro if you want to control weak symbol support with a compiler
flag such as @option{-melf}.
@end defmac

@defmac MAKE_DECL_ONE_ONLY (@var{decl})
@en A C statement (sans semicolon) to mark @var{decl} to be emitted as a
@en public symbol such that extra copies in multiple translation units will
@en be discarded by the linker.  Define this macro if your object file
@en format provides support for this concept, such as the @samp{COMDAT}
@en section flags in the Microsoft Windows PE/COFF format, and this support
@en requires changes to @var{decl}, such as putting it in a separate section.
一条C语句（没有分号），用来标记@var{decl}作为public符号生成，
这样在多个转换单元中额外的副本将被连接器丢弃。
如果你的目标文件格式提供了这样的支持，
例如在Microsoft Windows PE/COFF格式中的@samp{COMDAT} section标记，
并且这种支持需要对@var{decl}进行改动，例如将其放到独立的section中，则定义该宏。
@end defmac

@defmac SUPPORTS_ONE_ONLY
@en A C expression which evaluates to true if the target supports one-only
@en semantics.
一个C表达式，如果target支持one-only语义，则其求值为真。

@en If you don't define this macro, @file{varasm.c} provides a default
@en definition.  If @code{MAKE_DECL_ONE_ONLY} is defined, the default
@en definition is @samp{1}; otherwise, it is @samp{0}.  Define this macro if
@en you want to control one-only symbol support with a compiler flag, or if
@en setting the @code{DECL_ONE_ONLY} flag is enough to mark a declaration to
@en be emitted as one-only.
如果你没有定义该宏，@file{varasm.c}会提供一个缺省的定义。
如果@code{MAKE_DECL_ONE_ONLY}被定义，则缺省定义为@samp{1}；否则为@samp{0}。
如果你想使用编译器标记来控制one-only符号的支持，
或者如果设置@code{DECL_ONE_ONLY}标记就足以标记声明被作为one-only生成时，
定义该宏。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_ASSEMBLE_VISIBILITY (tree @var{decl}, int @var{visibility})
@en This target hook is a function to output to @var{asm_out_file} some
@en commands that will make the symbol(s) associated with @var{decl} have
@en hidden, protected or internal visibility as specified by @var{visibility}.
该target钩子为一个函数，用来将一些命令输出到@var{asm_out_file}，
其将使得与@var{decl}相关的符号具有通过@var{visibility}指定的隐藏，
保护或者内部可见的属性。
@end deftypefn

@defmac TARGET_WEAK_NOT_IN_ARCHIVE_TOC
@en A C expression that evaluates to true if the target's linker expects
@en that weak symbols do not appear in a static archive's table of contents.
@en The default is @code{0}.
一个C表达式，如果target的连接器期望弱符号不出现在静态归档的目录表中，
则其求值为真。缺省为@code{0}。

@en Leaving weak symbols out of an archive's table of contents means that,
@en if a symbol will only have a definition in one translation unit and
@en will have undefined references from other translation units, that
@en symbol should not be weak.  Defining this macro to be nonzero will
@en thus have the effect that certain symbols that would normally be weak
@en (explicit template instantiations, and vtables for polymorphic classes
@en with noninline key methods) will instead be nonweak.
将弱符号置于归档的目录表之外，意味着如果符号将只在一个转换单元中有一个定义，
并且有从其它转换单元中进行未定义的引用，则该符号将不为弱的。定义该宏为非零，
将使得这样通常为弱的符号成为非弱的。

@en The C++ ABI requires this macro to be zero.  Define this macro for
@en targets where full C++ ABI compliance is impossible and where linker
@en restrictions require weak symbols to be left out of a static archive's
@en table of contents.
C++ ABI要求该宏为0。当target不能完全遵守C++ ABI，
并且连接器要求弱符号在静态归档的目录表外面时，定义该宏。
@end defmac

@defmac ASM_OUTPUT_EXTERNAL (@var{stream}, @var{decl}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} any text necessary for declaring the name of an external
@en symbol named @var{name} which is referenced in this compilation but
@en not defined.  The value of @var{decl} is the tree node for the
@en declaration.
一条C语句（没有分号），
用于将声明在该编译中被引用但没有被定义的外部符号名字@var{name}，
所需要的任何文本输出到stdio流@var{stream}中。@var{decl}的值为声明的树结点。

@en This macro need not be defined if it does not need to output anything.
@en The GNU assembler and most Unix assemblers don't require anything.
如果不需要输出任何东西，则不需要定义该宏。
GNU汇编器和大多数Unix汇编器不需要做任何事情。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_EXTERNAL_LIBCALL (rtx @var{symref})
@en This target hook is a function to output to @var{asm_out_file} an assembler
@en pseudo-op to declare a library function name external.  The name of the
@en library function is given by @var{symref}, which is a @code{symbol_ref}.
该target钩子是一个函数，用于将一条汇编伪指令输出到@var{asm_out_file}中，
用以声明一个库函数名字为外部的。库函数的名字由@var{symref}给出，
@var{symref}为一个@code{symbol_ref}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_MARK_DECL_PRESERVED (const char *@var{symbol})
@en This target hook is a function to output to @var{asm_out_file} an assembler
@en directive to annotate @var{symbol} as used.  The Darwin target uses the
@en .no_dead_code_strip directive.
该target钩子为一个函数，用于将一条汇编伪指令输出到@var{asm_out_file}中，
用以注释使用的符号。Darwin target使用.no_dead_code_strip伪指令。
@end deftypefn

@defmac ASM_OUTPUT_LABELREF (@var{stream}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} a reference in assembler syntax to a label named
@en @var{name}.  This should add @samp{_} to the front of the name, if that
@en is customary on your operating system, as it is in most Berkeley Unix
@en systems.  This macro is used in @code{assemble_name}.
一条C语句（没有分号），
用于将名为@var{name}的标号的引用的汇编语法输出到stdio流@var{stream}中。
这应该在name前加上@samp{_}。该宏用于@code{assemble_name}。
@end defmac

@defmac ASM_OUTPUT_SYMBOL_REF (@var{stream}, @var{sym})
@en A C statement (sans semicolon) to output a reference to
@en @code{SYMBOL_REF} @var{sym}.  If not defined, @code{assemble_name}
@en will be used to output the name of the symbol.  This macro may be used
@en to modify the way a symbol is referenced depending on information
@en encoded by @code{TARGET_ENCODE_SECTION_INFO}.
一条C语句（没有分号），用于输出对@code{SYMBOL_REF} @var{sym}的引用。
如果没有定义，@code{assemble_name}将被用来输出符号的名字。
该宏可以用于修改符号被引用的方式，根据@code{TARGET_ENCODE_SECTION_INFO}的信息。
@end defmac

@defmac ASM_OUTPUT_LABEL_REF (@var{stream}, @var{buf})
@en A C statement (sans semicolon) to output a reference to @var{buf}, the
@en result of @code{ASM_GENERATE_INTERNAL_LABEL}.  If not defined,
@en @code{assemble_name} will be used to output the name of the symbol.
@en This macro is not used by @code{output_asm_label}, or the @code{%l}
@en specifier that calls it; the intention is that this macro should be set
@en when it is necessary to output a label differently when its address is
@en being taken.
一条C语句（没有分号），用于输出对@code{ASM_GENERATE_INTERNAL_LABEL}的结果，
@var{buf}的引用。如果没有定义，@code{assemble_name}将被用来输出符号的名字。
该宏不被调用它的@code{output_asm_label}或者@code{%l}指示符使用；
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_INTERNAL_LABEL (FILE *@var{stream}, const char *@var{prefix}, unsigned long @var{labelno})
@en A function to output to the stdio stream @var{stream} a label whose
@en name is made from the string @var{prefix} and the number @var{labelno}.
一个函数，将标号输出到stdio流@var{stream}中，
标号的名字由字符串@var{prefix}和编号@var{labelno}组成。

@en It is absolutely essential that these labels be distinct from the labels
@en used for user-level functions and variables.  Otherwise, certain programs
@en will have name conflicts with internal labels.
当然这些标号应该与用户级别函数和变量使用的标号不同。
否则，程序将具有与内部标号的命名冲突。

@en It is desirable to exclude internal labels from the symbol table of the
@en object file.  Most assemblers have a naming convention for labels that
@en should be excluded; on many systems, the letter @samp{L} at the
@en beginning of a label has this effect.  You should find out what
@en convention your system uses, and follow it.
通常要求内部标号不包含在目标文件的符号表中。大多数汇编器具有命名约定，
来处理这些标号。在许多系统上，位于标号的起始处的字母@samp{L}，具有这样的效果。
你应该找到你的系统使用的约定，并遵守。

@en The default version of this function utilizes @code{ASM_GENERATE_INTERNAL_LABEL}.
该函数的缺省版本利用@code{ASM_GENERATE_INTERNAL_LABEL}了。
@end deftypefn

@defmac ASM_OUTPUT_DEBUG_LABEL (@var{stream}, @var{prefix}, @var{num})
@en A C statement to output to the stdio stream @var{stream} a debug info
@en label whose name is made from the string @var{prefix} and the number
@en @var{num}.  This is useful for VLIW targets, where debug info labels
@en may need to be treated differently than branch target labels.  On some
@en systems, branch target labels must be at the beginning of instruction
@en bundles, but debug info labels can occur in the middle of instruction
@en bundles.
一条C语句，用来将调试信息标号输出到stdio流@var{stream}中，
标号的名字由字符串@var{prefix}和编号@var{num}组成。这对VLIW target很有用，
因为调试信息标号可能需要与分支目标标号进行不同的处理。在一些系统上，
分支目标标号必须在指令束的起始处，但是调试信息标号可以出现在指令束的中间。

@en If this macro is not defined, then @code{(*targetm.asm_out.internal_label)} will be
@en used.
如果该宏没有被定义，则会使用@code{(*targetm.asm_out.internal_label)}。
@end defmac

@defmac ASM_GENERATE_INTERNAL_LABEL (@var{string}, @var{prefix}, @var{num})
@en A C statement to store into the string @var{string} a label whose name
@en is made from the string @var{prefix} and the number @var{num}.
一条C语句，用于将标号存储到字符串@var{string}中，
标号的名字由字符串@var{prefix}和编号@var{num}组成。

This string, when output subsequently by @code{assemble_name}, should
produce the output that @code{(*targetm.asm_out.internal_label)} would produce
with the same @var{prefix} and @var{num}.

@en If the string begins with @samp{*}, then @code{assemble_name} will
@en output the rest of the string unchanged.  It is often convenient for
@en @code{ASM_GENERATE_INTERNAL_LABEL} to use @samp{*} in this way.  If the
@en string doesn't start with @samp{*}, then @code{ASM_OUTPUT_LABELREF} gets
@en to output the string, and may change it.  (Of course,
@en @code{ASM_OUTPUT_LABELREF} is also part of your machine description, so
@en you should know what it does on your machine.)
如果字符串起始于@samp{*}，
则@code{assemble_name}将按照不改变剩余字符串的方式被输出。
这对于@code{ASM_GENERATE_INTERNAL_LABEL}非常方便。
如果字符串不起始于@samp{*}，则会使用@code{ASM_OUTPUT_LABELREF}来输出字符串，
并且可能会做改变。（当然，@code{ASM_OUTPUT_LABELREF}也是你的机器描述的一部分，
所以你知道它在你的机器上做了什么。）
@end defmac

@defmac ASM_FORMAT_PRIVATE_NAME (@var{outvar}, @var{name}, @var{number})
@en A C expression to assign to @var{outvar} (which is a variable of type
@en @code{char *}) a newly allocated string made from the string
@en @var{name} and the number @var{number}, with some suitable punctuation
@en added.  Use @code{alloca} to get space for the string.
一个C表达式，给@var{outvar}（类型为@code{char *}*的变量）
赋值一个新分配的字符串，该字符串由字符串@var{name}和编号@var{number}组成，
并增加适当的标点符号。使用@code{alloca}为字符串获得空间。

@en The string will be used as an argument to @code{ASM_OUTPUT_LABELREF} to
@en produce an assembler label for an internal static variable whose name is
@en @var{name}.  Therefore, the string must be such as to result in valid
@en assembler code.  The argument @var{number} is different each time this
@en macro is executed; it prevents conflicts between similarly-named
@en internal static variables in different scopes.
字符串将被@code{ASM_OUTPUT_LABELREF}作为参数使用，
来产生一个名字为@var{name}的内部静态变量的汇编标号。
因此，字符串必须为有效的汇编代码。参数@var{number}在每次执行该宏时都不相同；
其使得在不同作用域下的内部静态变量的名字不会有冲突。

@en Ideally this string should not be a valid C identifier, to prevent any
@en conflict with the user's own symbols.  Most assemblers allow periods
@en or percent signs in assembler symbols; putting at least one of these
@en between the name and the number will suffice.
理想情况下，该字符串应该不是一个有效的C标识符，
以阻止任何与用户自己的符号的冲突。大多数汇编器运行点或者百分号在汇编符号中；
在名字和编号之间加入至少一个这样的字符便可以。

@en If this macro is not defined, a default definition will be provided
@en which is correct for most systems.
如果该宏没有被定义，一个缺省的定义将被提供，其在大多数系统上都是正确的。
@end defmac

@defmac ASM_OUTPUT_DEF (@var{stream}, @var{name}, @var{value})
@en A C statement to output to the stdio stream @var{stream} assembler code
@en which defines (equates) the symbol @var{name} to have the value @var{value}.
一条C语句，用于将定义符号@var{name}具有值@var{value}的汇编代码输出到stdio流@var{stream}中。

@findex SET_ASM_OP
@en If @code{SET_ASM_OP} is defined, a default definition is provided which is
@en correct for most systems.
如果定义了@code{SET_ASM_OP}，一个缺省的定义将被提供，
其在大多数系统上都是正确的。
@end defmac

@defmac ASM_OUTPUT_DEF_FROM_DECLS (@var{stream}, @var{decl_of_name}, @var{decl_of_value})
@en A C statement to output to the stdio stream @var{stream} assembler code
@en which defines (equates) the symbol whose tree node is @var{decl_of_name}
@en to have the value of the tree node @var{decl_of_value}.  This macro will
@en be used in preference to @samp{ASM_OUTPUT_DEF} if it is defined and if
@en the tree nodes are available.
一条C语句，用于将定义树结点为@var{decl_of_name}的符号，
具有树结点@var{decl_of_value}的值的汇编代码输出到stdio流@var{stream}中。
该宏将优先于`ASM_OUTPUT_DEF'被使用，如果其被定义，并且如果树结点有效。

@findex SET_ASM_OP
@en If @code{SET_ASM_OP} is defined, a default definition is provided which is
@en correct for most systems.
如果定义了@code{SET_ASM_OP}，一个缺省的定义将被提供，
其在大多数系统上都是正确的。
@end defmac

@defmac TARGET_DEFERRED_OUTPUT_DEFS (@var{decl_of_name}, @var{decl_of_value})
@en A C statement that evaluates to true if the assembler code which defines
@en (equates) the symbol whose tree node is @var{decl_of_name} to have the value
@en of the tree node @var{decl_of_value} should be emitted near the end of the
@en current compilation unit.  The default is to not defer output of defines.
@en This macro affects defines output by @samp{ASM_OUTPUT_DEF} and
@en @samp{ASM_OUTPUT_DEF_FROM_DECLS}.
一条C语句，如果定义树结点为@var{decl_of_name}的符号具有树结点为
@var{decl_of_value}的值的汇编代码，应该在当前编译单元结尾处被生成，
则求值为真。缺省为不推迟定义的输出。
该宏影响`ASM_OUTPUT_DEF' 和 `ASM_OUTPUT_DEF_FROM_DECLS'的定义输出。
@end defmac

@defmac ASM_OUTPUT_WEAK_ALIAS (@var{stream}, @var{name}, @var{value})
@en A C statement to output to the stdio stream @var{stream} assembler code
@en which defines (equates) the weak symbol @var{name} to have the value
@en @var{value}.  If @var{value} is @code{NULL}, it defines @var{name} as
@en an undefined weak symbol.
一条C语句，用来将定义弱符号@var{name}具有值@var{value}的汇编代码输出
到stdio流@var{stream}中。如果@var{value}为@code{NULL}，
其定义@var{name}为未定义的符号。

@en Define this macro if the target only supports weak aliases; define
@en @code{ASM_OUTPUT_DEF} instead if possible.
如果target只支持弱别名时，定义该宏；否则尽量定义@code{ASM_OUTPUT_DEF}。
@end defmac

@defmac OBJC_GEN_METHOD_LABEL (@var{buf}, @var{is_inst}, @var{class_name}, @var{cat_name}, @var{sel_name})
@en Define this macro to override the default assembler names used for
@en Objective-C methods.
定义该宏来覆盖缺省的用于Objective-C方法的汇编名。

@en The default name is a unique method number followed by the name of the
@en class (e.g.@: @samp{_1_Foo}).  For methods in categories, the name of
@en the category is also included in the assembler name (e.g.@:
@en @samp{_1_Foo_Bar}).
缺省名为一个唯一的方法编号，跟随class的名字（例如@samp{_1_Foo}）。
对于在category中的方法，category也包含在汇编名中（例如@samp{_1_Foo_Bar}）。

@en These names are safe on most systems, but make debugging difficult since
@en the method's selector is not present in the name.  Therefore, particular
@en systems define other ways of computing names.
这些名字在大多数系统上是安全的，但是使得调试变得困难，
因为方法selector不在名字中。因此一些特定的系统定义了其它计算名字的方式。

@en @var{buf} is an expression of type @code{char *} which gives you a
@en buffer in which to store the name; its length is as long as
@en @var{class_name}, @var{cat_name} and @var{sel_name} put together, plus
@en 50 characters extra.
@var{buf}为@code{char *}类型的表达式，给出一个缓存来存储名字；
其长度等于@var{class_name}，@var{cat_name}和@var{sel_name}的和，
再加上额外的50个字符。

@en The argument @var{is_inst} specifies whether the method is an instance
@en method or a class method; @var{class_name} is the name of the class;
@en @var{cat_name} is the name of the category (or @code{NULL} if the method is not
@en in a category); and @var{sel_name} is the name of the selector.
参数@var{is_inst}指定了方法是一个实例方法，还是一个类方法；
@var{class_name}为类的名字；@var{cat_name}为category的名字（或者为空，
如果方法不在category中）；@var{sel_name}为selector的名字。

@en On systems where the assembler can handle quoted names, you can use this
@en macro to provide more human-readable names.
在汇编器可以处理带引号的名字的系统上，你可以使用该宏来提供更加可读的名字。
@end defmac

@defmac ASM_DECLARE_CLASS_REFERENCE (@var{stream}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} commands to declare that the label @var{name} is an
@en Objective-C class reference.  This is only needed for targets whose
@en linkers have special support for NeXT-style runtimes.
一条C语句（没有分号），用于将命令输出到stdio流@var{stream}中，
来声明标号@var{name}为Objective-C class引用。
这只在连接器具有对NeXT-style运行时的特殊支持的target上需要。
@end defmac

@defmac ASM_DECLARE_UNRESOLVED_REFERENCE (@var{stream}, @var{name})
@en A C statement (sans semicolon) to output to the stdio stream
@en @var{stream} commands to declare that the label @var{name} is an
@en unresolved Objective-C class reference.  This is only needed for targets
@en whose linkers have special support for NeXT-style runtimes.
一条C语句（没有分号），用于将命令输出到stdio流@var{stream}中，
来声明标号@var{name}为未解决的Objective-C class引用。
这只在连接器具有对NeXT-style运行时的特殊支持的target上需要。
@end defmac

@en @node Initialization
@en @subsection How Initialization Functions Are Handled
@node Initialization
@subsection 如何处理初始化函数
@cindex initialization routines
@cindex termination routines
@cindex constructors, output of
@cindex destructors, output of

@en The compiled code for certain languages includes @dfn{constructors}
@en (also called @dfn{initialization routines})---functions to initialize
@en data in the program when the program is started.  These functions need
@en to be called before the program is ``started''---that is to say, before
@en @code{main} is called.
一些语言被编译后的代码中会包含构造者（也称为初始化例程）---当程序启动时，
用来初始化程序中的数据的函数。这些函数需要在程序开始前被调用---也就是说，
在调用@code{main}之前。

@en Compiling some languages generates @dfn{destructors} (also called
@en @dfn{termination routines}) that should be called when the program
@en terminates.
编译一些语言还会生成析构者（也成为终止例程），将在程序终止时被调用。

@en To make the initialization and termination functions work, the compiler
@en must output something in the assembler code to cause those functions to
@en be called at the appropriate time.  When you port the compiler to a new
@en system, you need to specify how to do this.
为了让初始化和终止函数工作，编译器必须在汇编代码中输出一些东西，
使得那些函数在适当的时候被调用。当你将编译器移植到一个新的系统时，
你需要指定如何做。

@en There are two major ways that GCC currently supports the execution of
@en initialization and termination functions.  Each way has two variants.
@en Much of the structure is common to all four variations.
GCC目前支持两种主要的方式，来执行初始化和终止函数。
每种方式都有两个变体。大多数结构体对于这四个变体都是通用的。

@findex __CTOR_LIST__
@findex __DTOR_LIST__
@en The linker must build two lists of these functions---a list of
@en initialization functions, called @code{__CTOR_LIST__}, and a list of
@en termination functions, called @code{__DTOR_LIST__}.
连接器必须构建两个这些函数的链表---一个是初始化函数链表，
叫做@code{__CTOR_LIST__}，一个是终止函数，叫做@code{__DTOR_LIST__}。

@en Each list always begins with an ignored function pointer (which may hold
@en 0, @minus{}1, or a count of the function pointers after it, depending on
@en the environment).  This is followed by a series of zero or more function
@en pointers to constructors (or destructors), followed by a function
@en pointer containing zero.
每个列表总是起始于一个被忽略的函数指针（其可能为0，-1，
或者之后的函数指针的个数，这取决于具体环境）。
随后是一系列指向构造者（或析构者）的零个或多个函数指针，
然后是一个包含0的函数指针。

@en Depending on the operating system and its executable file format, either
@en @file{crtstuff.c} or @file{libgcc2.c} traverses these lists at startup
@en time and exit time.  Constructors are called in reverse order of the
@en list; destructors in forward order.
取决于操作系统和它的可执行文件格式，或者@file{crtstuff.c}，
或者@file{libgcc2.c}会在起始时间和退出时间遍历这些列表。
构造者按照列表相反的顺序被调用；析构者按照向前的顺序。

@en The best way to handle static constructors works only for object file
@en formats which provide arbitrarily-named sections.  A section is set
@en aside for a list of constructors, and another for a list of destructors.
@en Traditionally these are called @samp{.ctors} and @samp{.dtors}.  Each
@en object file that defines an initialization function also puts a word in
@en the constructor section to point to that function.  The linker
@en accumulates all these words into one contiguous @samp{.ctors} section.
@en Termination functions are handled similarly.
处理静态构造者的最好的方式，
只有在目标文件格式提供任意命名section的时候才可以工作。
这会在构造者列表旁边设置一个section，析构者列表旁边设置另一个，
通常称作@samp{.ctors}和@samp{.dtors}。
每个定义了初始化函数的目标文件，还在构造section中放入一个字，
以指向那个函数。
连接器将所有这些字累积放入到一个邻近的@samp{.ctors} section中。
终止函数按照类似的方式处理。

@en This method will be chosen as the default by @file{target-def.h} if
@en @code{TARGET_ASM_NAMED_SECTION} is defined.  A target that does not
@en support arbitrary sections, but does support special designated
@en constructor and destructor sections may define @code{CTORS_SECTION_ASM_OP}
@en and @code{DTORS_SECTION_ASM_OP} to achieve the same effect.
如果定义了TARGET_ASM_NAMED_SECTION，
则该方法将被@file{target-def.h}作为缺省方式选择。
不支持任意section，但是支持特定的构造者和析构者section的target，
可以定义@code{CTORS_SECTION_ASM_OP}和@code{DTORS_SECTION_ASM_OP}
来达到相同的效果。

@en When arbitrary sections are available, there are two variants, depending
@en upon how the code in @file{crtstuff.c} is called.  On systems that
@en support a @dfn{.init} section which is executed at program startup,
@en parts of @file{crtstuff.c} are compiled into that section.  The
@en program is linked by the @command{gcc} driver like this:
当支持任意section时，有两个变体，
取决于如何调用@file{crtstuff.c}中的代码。
在支持@dfn{.init} section（其在程序起始时被执行）的系统上，
@file{crtstuff.c}的部分代码被编译到那个section中。
程序按照类似于下面的方式被@command{gcc}驱动连接：

@smallexample
ld -o @var{output_file} crti.o crtbegin.o @dots{} -lgcc crtend.o crtn.o
@end smallexample

@en The prologue of a function (@code{__init}) appears in the @code{.init}
@en section of @file{crti.o}; the epilogue appears in @file{crtn.o}.  Likewise
@en for the function @code{__fini} in the @dfn{.fini} section.  Normally these
@en files are provided by the operating system or by the GNU C library, but
@en are provided by GCC for a few targets.
函数（@code{__init}）的序言出现在@file{crti.o}的@code{.init} section中；
尾声出现在@file{crtn.o}中。同样的，函数@code{__fini}在@dfn{.fini} section中。
通常这些文件由操作系统或者GNU C库提供，但GCC也为一些target提供。

@en The objects @file{crtbegin.o} and @file{crtend.o} are (for most targets)
@en compiled from @file{crtstuff.c}.  They contain, among other things, code
@en fragments within the @code{.init} and @code{.fini} sections that branch
@en to routines in the @code{.text} section.  The linker will pull all parts
@en of a section together, which results in a complete @code{__init} function
@en that invokes the routines we need at startup.
目标文件@file{crtbegin.o}和@file{crtend.o}是从@file{crtstuff.c}
中编译出来的（对于大多target）。它们包含了，在@code{.init}和@code{.fini} 
section中的代码片断，用于跳转到@code{.text} section中的例程中。
连接器会把section的所有部分放在一起，形成完整的@code{__init}函数，
其可以在起始处调用我们需要的例程。

@en To use this variant, you must define the @code{INIT_SECTION_ASM_OP}
macro properly.
要使用这个变体，你必须适当的定义@code{INIT_SECTION_ASM_OP}宏。

@en If no init section is available, when GCC compiles any function called
@en @code{main} (or more accurately, any function designated as a program
@en entry point by the language front end calling @code{expand_main_function}),
@en it inserts a procedure call to @code{__main} as the first executable code
@en after the function prologue.  The @code{__main} function is defined
@en in @file{libgcc2.c} and runs the global constructors.
如果init section不可用，GCC在编译任何叫做@code{main}（或者更加确切的说，
任何被语言前端@code{expand_main_function}指定为程序入口点的函数）的函数时，
其会插入一个调用@code{__main}的程序，以作为在函数序言之后首先执行的代码。
@code{__main}函数在@file{libgcc2.c}中定义，并运行全局的构造者。

@en In file formats that don't support arbitrary sections, there are again
@en two variants.  In the simplest variant, the GNU linker (GNU @code{ld})
@en and an `a.out' format must be used.  In this case,
@en @code{TARGET_ASM_CONSTRUCTOR} is defined to produce a @code{.stabs}
@en entry of type @samp{N_SETT}, referencing the name @code{__CTOR_LIST__},
@en and with the address of the void function containing the initialization
@en code as its value.  The GNU linker recognizes this as a request to add
@en the value to a @dfn{set}; the values are accumulated, and are eventually
@en placed in the executable as a vector in the format described above, with
@en a leading (ignored) count and a trailing zero element.
@en @code{TARGET_ASM_DESTRUCTOR} is handled similarly.  Since no init
@en section is available, the absence of @code{INIT_SECTION_ASM_OP} causes
@en the compilation of @code{main} to call @code{__main} as above, starting
@en the initialization process.
对于文件格式不支持任意section的，也有两个变体。对于最简单的变体，
必须使用GNU连接器（GNU @code{ld}）和'a.out'格式。在这种情况下，
@code{TARGET_ASM_CONSTRUCTOR}被定义，
用来生成一个@samp{N_SETT}类型的@code{.stabs}条目，
来引用名字@code{__CTOR_LIST__}，
并且其值为一个包含了初始化代码的void函数地址。
GNU连接器将其识别为一个要设定的值；该值会被累积，
并最终作为一个向量放在可执行程序中，
一个前导（被忽略的）数目和一个尾部的0元素。
@code{TARGET_ASM_DESTRUCTOR}按照类似的情况被处理。
由于init section不可用，所以使得编译@code{main}来调用@code{__main}，
以开始初始化。

@en The last variant uses neither arbitrary sections nor the GNU linker.
@en This is preferable when you want to do dynamic linking and when using
@en file formats which the GNU linker does not support, such as `ECOFF'@.  In
@en this case, @code{TARGET_HAVE_CTORS_DTORS} is false, initialization and
@en termination functions are recognized simply by their names.  This requires
@en an extra program in the linkage step, called @command{collect2}.  This program
@en pretends to be the linker, for use with GCC; it does its job by running
@en the ordinary linker, but also arranges to include the vectors of
@en initialization and termination functions.  These functions are called
@en via @code{__main} as described above.  In order to use this method,
@en @code{use_collect2} must be defined in the target in @file{config.gcc}.
最后一个变体既不使用任意section，也不使用GNU连接器。这适合于，
你想进行动态连接并使用GNU连接器不支持的文件格式的时候，例如 'ECOFF'。
在这种情况下，@code{TARGET_HAVE_CTORS_DTORS}为假，
初始化和终止函数简单的通过它们的名字来识别。这要求在连接过程中的额外程序，
叫做@command{collect2}。该程序作为GCC使用的连接器；
它通过运行普通的连接器来完成工作，但是还负责包含初始化和终止函数的向量。
这些函数通过@code{__main}调用。要使用这种方式，
必须在@file{config.gcc}中定义@code{use_collect2}。

@ifinfo
The following section describes the specific macros that control and
customize the handling of initialization and termination functions.
@end ifinfo

@en @node Macros for Initialization
@en @subsection Macros Controlling Initialization Routines
@node Macros for Initialization
@subsection 控制初始化例程的宏

@en Here are the macros that control how the compiler handles initialization
@en and termination functions:
这里是控制编译器如何处理初始化和终止函数的宏：

@defmac INIT_SECTION_ASM_OP
@en If defined, a C string constant, including spacing, for the assembler
@en operation to identify the following data as initialization code.  If not
@en defined, GCC will assume such a section does not exist.  When you are
@en using special sections for initialization and termination functions, this
@en macro also controls how @file{crtstuff.c} and @file{libgcc2.c} arrange to
@en run the initialization functions.
如果定义，为一个C字符串常量，包括空格，
用于将随后的数据作为初始化代码的汇编操作。如果没有定义，
GCC将假设这样的section不存在。当你使用用于初始化和终止函数的特定的section时，
该宏还控制@file{crtstuff.c}和@file{libgcc2.c}如何运行初始化函数。
@end defmac

@defmac HAS_INIT_SECTION
@en If defined, @code{main} will not call @code{__main} as described above.
@en This macro should be defined for systems that control start-up code
@en on a symbol-by-symbol basis, such as OSF/1, and should not
@en be defined explicitly for systems that support @code{INIT_SECTION_ASM_OP}.
如果定义，@code{main}将不会调用@code{__main}。对于控制起始代码，
像OSF/1这样的系统，应该定义该宏，
对于支持@code{INIT_SECTION_ASM_OP}的系统不应该显式的定义。
@end defmac

@defmac LD_INIT_SWITCH
@en If defined, a C string constant for a switch that tells the linker that
@en the following symbol is an initialization routine.
如果定义，为一个C字符串，作为一个开关，告诉连接器后面的符号为一个初始化例程。
@end defmac

@defmac LD_FINI_SWITCH
@en If defined, a C string constant for a switch that tells the linker that
@en the following symbol is a finalization routine.
如果定义，为一个C字符串常量，作为一个开关，告诉连接器后面的符号为一个结束例程。
@end defmac

@defmac COLLECT_SHARED_INIT_FUNC (@var{stream}, @var{func})
@en If defined, a C statement that will write a function that can be
@en automatically called when a shared library is loaded.  The function
@en should call @var{func}, which takes no arguments.  If not defined, and
@en the object format requires an explicit initialization function, then a
@en function called @code{_GLOBAL__DI} will be generated.
如果定义，为一条C语句，其将写一个在加载共享库时可以被自动调用的函数。
函数应该调用@var{func}，其不接受任何参数。如果没有定义，
并且目标格式要求显示的初始化函数，则将会生成一个叫做@code{_GLOBAL__DI}的函数。

@en This function and the following one are used by collect2 when linking a
@en shared library that needs constructors or destructors, or has DWARF2
@en exception tables embedded in the code.
该函数和下面的一个，被collect2使用，用于连接一个需要构造者或者析构者，
或者代码中具有DWARF2异常表嵌入的共享库的时候。
@end defmac

@defmac COLLECT_SHARED_FINI_FUNC (@var{stream}, @var{func})
@en If defined, a C statement that will write a function that can be
@en automatically called when a shared library is unloaded.  The function
@en should call @var{func}, which takes no arguments.  If not defined, and
@en the object format requires an explicit finalization function, then a
@en function called @code{_GLOBAL__DD} will be generated.
如果定义，为一条C语句，其将写一个在卸载共享库时可以被自动调用的函数。
函数应该调用@var{func}，其不接受任何参数。如果没有定义，
并且目标格式要求显示的初始化函数，则将会生成一个叫做@code{_GLOBAL__DD}的函数。
@end defmac

@defmac INVOKE__main
@en If defined, @code{main} will call @code{__main} despite the presence of
@en @code{INIT_SECTION_ASM_OP}.  This macro should be defined for systems
@en where the init section is not actually run automatically, but is still
@en useful for collecting the lists of constructors and destructors.
如果定义，@code{main}将调用@code{__main}，
而不管@code{INIT_SECTION_ASM_OP}的存在。对于init section不被自动运行，
但是仍可以用于搜集构建者和析构者列表的系统，该宏应该被定义。
@end defmac

@defmac SUPPORTS_INIT_PRIORITY
@en If nonzero, the C++ @code{init_priority} attribute is supported and the
@en compiler should emit instructions to control the order of initialization
@en of objects.  If zero, the compiler will issue an error message upon
@en encountering an @code{init_priority} attribute.
如果非零，则支持C++ @code{init_priority}属性，
并且编译器应该生成指令来控制对象初始化的顺序。
如果为0，编译器遇到@code{init_priority}属性时，将产生一条错误信息。
@end defmac

@deftypevr {Target Hook} bool TARGET_HAVE_CTORS_DTORS
@en This value is true if the target supports some ``native'' method of
@en collecting constructors and destructors to be run at startup and exit.
@en It is false if we must use @command{collect2}.
该值为真，如果target支持一些搜集构造者和析构者在起始和退出时运行的本地方法。
如果我们必须使用@command{collect2}，则为假。
@end deftypevr

@deftypefn {Target Hook} void TARGET_ASM_CONSTRUCTOR (rtx @var{symbol}, int @var{priority})
@en If defined, a function that outputs assembler code to arrange to call
@en the function referenced by @var{symbol} at initialization time.
如果定义，为一个函数，输出汇编代码来调用在初始化时@var{symbol}引用的函数。

@en Assume that @var{symbol} is a @code{SYMBOL_REF} for a function taking
@en no arguments and with no return value.  If the target supports initialization
@en priorities, @var{priority} is a value between 0 and @code{MAX_INIT_PRIORITY};
@en otherwise it must be @code{DEFAULT_INIT_PRIORITY}.
假定@var{symbol}为一个没有参数并没有返回值的函数的@code{SYMBOL_REF}。
如果target支持初始化优先级，
@var{priority}为一个0到@code{MAX_INIT_PRIORITY}之间的值；
否则，其必须为@code{DEFAULT_INIT_PRIORITY}。

@en If this macro is not defined by the target, a suitable default will
@en be chosen if (1) the target supports arbitrary section names, (2) the
@en target defines @code{CTORS_SECTION_ASM_OP}, or (3) @code{USE_COLLECT2}
@en is not defined.
如果该宏没有被taret定义，则一个适当的缺省将被选择，
如果（1）target支持任意section名，
（2）target定义了@code{CTORS_SECTION_ASM_OP}，
或者（3）没有定义@code{USE_COLLECT2}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_DESTRUCTOR (rtx @var{symbol}, int @var{priority})
@en This is like @code{TARGET_ASM_CONSTRUCTOR} but used for termination
@en functions rather than initialization functions.
类似于@code{TARGET_ASM_CONSTRUCTOR}，不过用于终止函数，而不是初始化函数。
@end deftypefn

@en If @code{TARGET_HAVE_CTORS_DTORS} is true, the initialization routine
@en generated for the generated object file will have static linkage.
如果@code{TARGET_HAVE_CTORS_DTORS}为真，
对于生成的目标文件的初始化例程将具有静态连接。

@en If your system uses @command{collect2} as the means of processing
@en constructors, then that program normally uses @command{nm} to scan
@en an object file for constructor functions to be called.
如果你的系统使用@command{collec2}作为处理构造者的方法，
则那个程序通常使用@command{nm}来扫描目标文件，寻找被调用的构造者。

@en On certain kinds of systems, you can define this macro to make
@en @command{collect2} work faster (and, in some cases, make it work at all):
在一些特定的系统上，你可以定义该宏，使得@command{collect2}工作的更快。

@defmac OBJECT_FORMAT_COFF
@en Define this macro if the system uses COFF (Common Object File Format)
@en object files, so that @command{collect2} can assume this format and scan
@en object files directly for dynamic constructor/destructor functions.
定义该宏，如果系统使用COFF（Common Object File Format）目标文件，
这样@command{collect2}能够假设为该格式，并扫描直接目标文件的构造/析构函数。

@en This macro is effective only in a native compiler; @command{collect2} as
@en part of a cross compiler always uses @command{nm} for the target machine.
该宏只有在本地编译器上才有效率；
对于交叉编译器，@command{collect2}总是使用@command{nm}。
@end defmac

@defmac REAL_NM_FILE_NAME
@en Define this macro as a C string constant containing the file name to use
@en to execute @command{nm}.  The default is to search the path normally for
@en @command{nm}.
定义该宏为一个C字符串常量，包含用来执行@command{nm}的文件名。
缺省为搜索通常的路径。
@end defmac

@defmac NM_FLAGS
@command{collect2} calls @command{nm} to scan object files for static
constructors and destructors and LTO info.  By default, @option{-n} is
passed.  Define @code{NM_FLAGS} to a C string constant if other options
are needed to get the same output formut as GNU @command{nm -n}
produces.
@end defmac

@en If your system supports shared libraries and has a program to list the
@en dynamic dependencies of a given library or executable, you can define
@en these macros to enable support for running initialization and
@en termination functions in shared libraries:
如果你的系统支持共享库，并具有一个程序能够列出给定库或可执行程序的动态依赖，
你可以定义这些宏使得能够运行共享库中的初始化和终止函数：

@defmac LDD_SUFFIX
@en Define this macro to a C string constant containing the name of the program
@en which lists dynamic dependencies, like @command{ldd} under SunOS 4.
定义该宏为一个C字符串常量，包含程序的名字，其可以列出动态依赖，
像SunOS 4中的@command{ldd}。
@end defmac

@defmac PARSE_LDD_OUTPUT (@var{ptr})
@en Define this macro to be C code that extracts filenames from the output
@en of the program denoted by @code{LDD_SUFFIX}.  @var{ptr} is a variable
@en of type @code{char *} that points to the beginning of a line of output
@en from @code{LDD_SUFFIX}.  If the line lists a dynamic dependency, the
@en code must advance @var{ptr} to the beginning of the filename on that
@en line.  Otherwise, it must set @var{ptr} to @code{NULL}.
定义该宏为C代码，从@code{LDD_SUFFIX}指定的程序的输出中抽取文件名。
@var{ptr}为@code{char *}类型的变量，指向@code{LDD_SUFFIX}的输出中的一行。
如果行中列出的是动态依赖，则代码必须将@var{ptr}前进到那一行的文件名起始处。
否则，其必须设置@var{ptr}为@code{NULL}。
@end defmac

@defmac SHLIB_SUFFIX
@en Define this macro to a C string constant containing the default shared
@en library extension of the target (e.g., @samp{".so"}).  @command{collect2}
@en strips version information after this suffix when generating global
@en constructor and destructor names.  This define is only needed on targets
@en that use @command{collect2} to process constructors and destructors.
定义该宏为一个C字符串常量，包含了target缺省的共享库扩展名（例如@samp{".so"}）。
当生成全局构造者和析构者名字时，@command{collect2}从该后缀的后面剥去版本信息。
该定义只在使用@command{collect2}来处理构造者和析构者的target上需要。
@end defmac

@en @node Instruction Output
@en @subsection Output of Assembler Instructions
@node Instruction Output
@subsection 汇编指令的输出

@c prevent bad page break with this line
@en This describes assembler instruction output.
这章描述了汇编指令的输出。

@defmac REGISTER_NAMES
@en A C initializer containing the assembler's names for the machine
@en registers, each one as a C string constant.  This is what translates
@en register numbers in the compiler into assembler language.
一段C初始化程序，包含了机器寄存器的汇编名字，每个名字使用C字符串常量表示。
这用来将编译器中的寄存器编号转换成汇编语言。
@end defmac

@defmac ADDITIONAL_REGISTER_NAMES
@en If defined, a C initializer for an array of structures containing a name
@en and a register number.  This macro defines additional names for hard
@en registers, thus allowing the @code{asm} option in declarations to refer
@en to registers using alternate names.
如果定义，则为结构体数组的初始化程序，结构体包含了名字和寄存器编号。
该宏定义了硬件寄存器的附加名字，这样就可以允许在声明中的@code{asm}选项，
来使用附加名引用寄存器。
@end defmac

@defmac OVERLAPPING_REGISTER_NAMES
If defined, a C initializer for an array of structures containing a
name, a register number and a count of the number of consecutive
machine registers the name overlaps.  This macro defines additional
names for hard registers, thus allowing the @code{asm} option in
declarations to refer to registers using alternate names.  Unlike
@code{ADDITIONAL_REGISTER_NAMES}, this macro should be used when the
register name implies multiple underlying registers.

This macro should be used when it is important that a clobber in an
@code{asm} statement clobbers all the underlying values implied by the
register name.  For example, on ARM, clobbering the double-precision
VFP register ``d0'' implies clobbering both single-precision registers
``s0'' and ``s1''.
@end defmac

@defmac ASM_OUTPUT_OPCODE (@var{stream}, @var{ptr})
@en Define this macro if you are using an unusual assembler that
@en requires different names for the machine instructions.
定义该宏，如果你在使用一个不常见的汇编器，其需要不一样的机器指令名字。

@en The definition is a C statement or statements which output an
@en assembler instruction opcode to the stdio stream @var{stream}.  The
@en macro-operand @var{ptr} is a variable of type @code{char *} which
@en points to the opcode name in its ``internal'' form---the form that is
@en written in the machine description.  The definition should output the
@en opcode name to @var{stream}, performing any translation you desire, and
@en increment the variable @var{ptr} to point at the end of the opcode
@en so that it will not be output twice.
定义为C语句，输出一个汇编指令代码到标准输入输出流@var{stream}中。
宏操作数@var{ptr}为类型是@code{char *}的变量，其指向内部形式中的指令码名字，
内部形式使用机器描述来表示。该定义应该输出操作码名字到@var{stream}中，
执行你想要的任何转换，并且将变量@var{ptr}增加到指向opcode的尾部，
这样其才不会被输出两次。

@en In fact, your macro definition may process less than the entire opcode
@en name, or more than the opcode name; but if you want to process text
@en that includes @samp{%}-sequences to substitute operands, you must take
@en care of the substitution yourself.  Just be sure to increment
@en @var{ptr} over whatever text should not be output normally.
实际上，相对于整个指令码的名字，你的宏定义可以处理或多或少的部分；
但是如果你想处理包含@samp{%}序列的文本，则必须小心你所做的替换。
要保证增加@var{ptr}，使得不会输出不应该被输出的文本。

@findex recog_data.operand
@en If you need to look at the operand values, they can be found as the
@en elements of @code{recog_data.operand}.
如果需要查看操作数的值，它们可以作为@code{recog_data.operand}的元素被找到。

@en If the macro definition does nothing, the instruction is output
@en in the usual way.
如果宏定义不做任何事情，则指令使用通常的方式来输出。
@end defmac

@defmac FINAL_PRESCAN_INSN (@var{insn}, @var{opvec}, @var{noperands})
@en If defined, a C statement to be executed just prior to the output of
@en assembler code for @var{insn}, to modify the extracted operands so
@en they will be output differently.
如果定义，则为一条C语句，其就在为@var{insn}输出汇编代码之前将被执行，
用来修改被抽取的操作数，从而可以被不同方式的输出。

@en Here the argument @var{opvec} is the vector containing the operands
@en extracted from @var{insn}, and @var{noperands} is the number of
@en elements of the vector which contain meaningful data for this insn.
@en The contents of this vector are what will be used to convert the insn
@en template into assembler code, so you can change the assembler output
@en by changing the contents of the vector.
这里的参数@var{opvec}为一个向量，包含了从@var{insn}中抽取的操作数，
@var{noperands}为向量的元素个数。该向量的内容用于将insn模板转换成汇编代码，
所以你可以通过修改向量的内容来改变汇编输出。

@en This macro is useful when various assembler syntaxes share a single
@en file of instruction patterns; by defining this macro differently, you
@en can cause a large class of instructions to be output differently (such
@en as with rearranged operands).  Naturally, variations in assembler
@en syntax affecting individual insn patterns ought to be handled by
@en writing conditional output routines in those patterns.
该宏当有多个汇编语法共用一个指令模式文件时很有用；通过定义该宏，
你可以使大量类别的指令按照不同的方式输出（例如重组操作）。
自然的，影响单个insn模式的汇编语法，
应该通过在那些指令模式中写条件输出程序来处理。

@en If this macro is not defined, it is equivalent to a null statement.
如果没有定义该宏，则其相当于一条空语句。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_FINAL_POSTSCAN_INSN (FILE *@var{file}, rtx @var{insn}, rtx *@var{opvec}, int @var{noperands})
If defined, this target hook is a function which is executed just after the
output of assembler code for @var{insn}, to change the mode of the assembler
if necessary.

Here the argument @var{opvec} is the vector containing the operands
extracted from @var{insn}, and @var{noperands} is the number of
elements of the vector which contain meaningful data for this insn.
The contents of this vector are what was used to convert the insn
template into assembler code, so you can change the assembler mode
by checking the contents of the vector.
@end deftypefn

@defmac PRINT_OPERAND (@var{stream}, @var{x}, @var{code})
@en A C compound statement to output to stdio stream @var{stream} the
@en assembler syntax for an instruction operand @var{x}.  @var{x} is an
@en RTL expression.
C复合语句，用来将指令操作数@var{x}的汇编语法输出到标准输入输出流@var{stream}中。
@var{x}为RTL表达式。

@var{code} is a value that can be used to specify one of several ways
@en of printing the operand.  It is used when identical operands must be
@en printed differently depending on the context.  @var{code} comes from
@en the @samp{%} specification that was used to request printing of the
@en operand.  If the specification was just @samp{%@var{digit}} then
@en @var{code} is 0; if the specification was @samp{%@var{ltr}
@en @var{digit}} then @var{code} is the ASCII code for @var{ltr}.
@var{code}值可以用来指定打印操作数的方式。
用于当操作数必须根据上下文进行不同的打印的时候。
@var{code}来自用于打印操作数的@samp{%}指定语句。
如果指定语句只是@samp{%@var{digit}}，则@var{code}为0；
如果指定语句为@samp{%@var{ltr}@var{digit}}，则@var{code}为@var{ltr}的ASCII码。

@findex reg_names
@en If @var{x} is a register, this macro should print the register's name.
@en The names can be found in an array @code{reg_names} whose type is
@en @code{char *[]}.  @code{reg_names} is initialized from
@en @code{REGISTER_NAMES}.
如果@var{x}为寄存器，则该宏应该打印寄存器的名字。
名字可以在数组@code{reg_names}中找到，数组的类型为@code{char *[]}。
@code{reg_names}通过@code{REGISTER_NAMES}来初始化。

@en When the machine description has a specification @samp{%@var{punct}}
@en (a @samp{%} followed by a punctuation character), this macro is called
@en with a null pointer for @var{x} and the punctuation character for
@en @var{code}.
当机器描述具有一个@samp{%@var{punct}}指定语句时
（@samp{%}后面跟随一个标点符号字符），则该宏被调用时，@var{x}为空指针，
@var{code}为标点符号字符。
@end defmac

@defmac PRINT_OPERAND_PUNCT_VALID_P (@var{code})
@en A C expression which evaluates to true if @var{code} is a valid
@en punctuation character for use in the @code{PRINT_OPERAND} macro.  If
@en @code{PRINT_OPERAND_PUNCT_VALID_P} is not defined, it means that no
@en punctuation characters (except for the standard one, @samp{%}) are used
@en in this way.
一个C表达式，
当@var{code}为在@code{PRINT_OPERAND}宏中使用的有效的标点符号字符时，
其计算为真。如果没有定义@code{PRINT_OPERAND_PUNCT_VALID_P}，
则意味着不以这种方式使用标点符号字符（除了标准的@samp{%}以外）。
@end defmac

@defmac PRINT_OPERAND_ADDRESS (@var{stream}, @var{x})
@en A C compound statement to output to stdio stream @var{stream} the
@en assembler syntax for an instruction operand that is a memory reference
@en whose address is @var{x}.  @var{x} is an RTL expression.
C复合语句，用来将指令操作数为内存引用，其地址为@var{x}的汇编语法，
输出到标准输入输出流@var{stream}中。@var{x}为一个RTL表达式。

@cindex @code{TARGET_ENCODE_SECTION_INFO} usage
@en On some machines, the syntax for a symbolic address depends on the
@en section that the address refers to.  On these machines, define the hook
@en @code{TARGET_ENCODE_SECTION_INFO} to store the information into the
@en @code{symbol_ref}, and then check for it here.  @xref{Assembler
@en Format}.
在一些机器上，符号地址的语法取决于地址所引用的section。在这些机器上，
定义钩子@code{TARGET_ENCODE_SECTION_INFO}来将信息存储到@code{symbol_ref}，
并在这里进行检查。@xref{Assembler Format}。
@end defmac

@findex dbr_sequence_length
@defmac DBR_OUTPUT_SEQEND (@var{file})
@en A C statement, to be executed after all slot-filler instructions have
@en been output.  If necessary, call @code{dbr_sequence_length} to
@en determine the number of slots filled in a sequence (zero if not
@en currently outputting a sequence), to decide how many no-ops to output,
@en or whatever.
C语句，在所有的栈槽填充指令被输出之后执行。如果需要的话，
调用@code{dbr_sequence_length}来判定在序列中被填充的栈槽数目
（如果当前不是输出一个序列，则为0），用来决定输出多少个no-ops，或其它。

@en Don't define this macro if it has nothing to do, but it is helpful in
@en reading assembly output if the extent of the delay sequence is made
@en explicit (e.g.@: with white space).
如果不做任何事情，就不要定义该宏，但是如果将延迟序列显示化，
则会有助于阅读汇编输出（例如，使用空格）。
@end defmac

@findex final_sequence
@en Note that output routines for instructions with delay slots must be
@en prepared to deal with not being output as part of a sequence
@en (i.e.@: when the scheduling pass is not run, or when no slot fillers could be
@en found.)  The variable @code{final_sequence} is null when not
@en processing a sequence, otherwise it contains the @code{sequence} rtx
@en being output.
注意，用于带有延迟槽的指令的输出程序，
必须准备好处理没有被作为序列输出的情况（即，当没有运行调度过程，
或者没有找到栈槽填充者）。当没有处理序列时，变量@code{final_sequence}为空，
否则其包含了被输出的rtx @code{sequence}。

@findex asm_fprintf
@defmac REGISTER_PREFIX
@defmacx LOCAL_LABEL_PREFIX
@defmacx USER_LABEL_PREFIX
@defmacx IMMEDIATE_PREFIX
@en If defined, C string expressions to be used for the @samp{%R}, @samp{%L},
@en @samp{%U}, and @samp{%I} options of @code{asm_fprintf} (see
@en @file{final.c}).  These are useful when a single @file{md} file must
@en support multiple assembler formats.  In that case, the various @file{tm.h}
@en files can define these macros differently.
如果定义，则为C字符串表达式，用于@code{asm_fprintf}（参见 @file{final.c}）
的选项@samp{%R}, @samp{%L}, @samp{%U}和 @samp{%I}。
这在单个@file{md}文件必须支持多个汇编格式时很有用。这种情况下，
不同的@file{tm.h}文件可以定义不同的这些宏。
@end defmac

@defmac ASM_FPRINTF_EXTENSIONS (@var{file}, @var{argptr}, @var{format})
@en If defined this macro should expand to a series of @code{case}
@en statements which will be parsed inside the @code{switch} statement of
@en the @code{asm_fprintf} function.  This allows targets to define extra
@en printf formats which may useful when generating their assembler
@en statements.  Note that uppercase letters are reserved for future
@en generic extensions to asm_fprintf, and so are not available to target
@en specific code.  The output file is given by the parameter @var{file}.
@en The varargs input pointer is @var{argptr} and the rest of the format
@en string, starting the character after the one that is being switched
@en upon, is pointed to by @var{format}.
如果定义，该宏应该被扩展为一系列@code{case}语句，
其将在@code{asm_fprintf}函数中的@code{switch}语句里被解析。
这将应允许target来定义额外的printf格式，其在生成它们的汇编语句时很有帮助。
注意，大写字母被保留用于@code{asm_fprintf}将来的通用扩展，
所以不要用于target特定代码中。输出文件由参数@var{file}给定。
varargs输出指针为@var{argptr}，格式字符串的其余部分，由@var{format}指向。
@end defmac

@defmac ASSEMBLER_DIALECT
@en If your target supports multiple dialects of assembler language (such as
@en different opcodes), define this macro as a C expression that gives the
@en numeric index of the assembler language dialect to use, with zero as the
@en first variant.
如果你的target支持多个汇编语言方言（例如不同的操作码），
可以定义该宏作为C表达式，给出汇编语言方言的索引，0作为第一个。

@en If this macro is defined, you may use constructs of the form
如果该宏被定义，你可以在指令模式的输出模版中（参见输出模版）或者asm_fprintf的第一个参数中使用如下的结构形式

@smallexample
@samp{@{option0|option1|option2@dots{}@}}
@end smallexample
@noindent
@en in the output templates of patterns (@pxref{Output Template}) or in the
@en first argument of @code{asm_fprintf}.  This construct outputs
@en @samp{option0}, @samp{option1}, @samp{option2}, etc., if the value of
@en @code{ASSEMBLER_DIALECT} is zero, one, two, etc.  Any special characters
@en within these strings retain their usual meaning.  If there are fewer
@en alternatives within the braces than the value of
@en @code{ASSEMBLER_DIALECT}, the construct outputs nothing.
该结构输出@samp{option0}, @samp{option1}, @samp{option2}等等，
如果@code{ASSEMBLER_DIALECT}的值为0，1，2，等等。
这些字符串中的任何特殊字符将保留它们通常的含义。
如果括号中的可选项多于@code{ASSEMBLER_DIALECT}的值，则什么也不输出。

@en If you do not define this macro, the characters @samp{@{}, @samp{|} and
@en @samp{@}} do not have any special meaning when used in templates or
@en operands to @code{asm_fprintf}.
如果没有定义该宏，字符@samp{@{}, @samp{|}和@samp{@}}在模版中或
@code{asm_fprintf}的操作数中不具有任何特殊含义。

@en Define the macros @code{REGISTER_PREFIX}, @code{LOCAL_LABEL_PREFIX},
@en @code{USER_LABEL_PREFIX} and @code{IMMEDIATE_PREFIX} if you can express
@en the variations in assembler language syntax with that mechanism.  Define
@en @code{ASSEMBLER_DIALECT} and use the @samp{@{option0|option1@}} syntax
@en if the syntax variant are larger and involve such things as different
@en opcodes or operand order.
如果你能够通过定义宏@code{REGISTER_PREFIX}, @code{LOCAL_LABEL_PREFIX}, 
@code{USER_LABEL_PREFIX}和@code{IMMEDIATE_PREFIX}来表达出汇编语言语法的
不同之处，则定义这些宏。如果语法差异比较大，涉及到操作码不同或操作数顺序，
则定义@code{ASSEMBLER_DIALECT}，使用@samp{@{option0|option1@}}语法。
@end defmac

@defmac ASM_OUTPUT_REG_PUSH (@var{stream}, @var{regno})
@en A C expression to output to @var{stream} some assembler code
@en which will push hard register number @var{regno} onto the stack.
@en The code need not be optimal, since this macro is used only when
@en profiling.
C表达式，向@var{stream}中输出汇编代码，用于将硬件寄存器编号@var{regno}压入栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
@end defmac

@defmac ASM_OUTPUT_REG_POP (@var{stream}, @var{regno})
@en A C expression to output to @var{stream} some assembler code
@en which will pop hard register number @var{regno} off of the stack.
@en The code need not be optimal, since this macro is used only when
@en profiling.
C表达式，向@var{stream}中输出汇编代码，用于将硬件寄存器编号@var{regno}弹出栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
@end defmac

@en @node Dispatch Tables
@en @subsection Output of Dispatch Tables
@node Dispatch Tables
@subsection 派遣表的输出

@c prevent bad page break with this line
@en This concerns dispatch tables.
这些是关于派遣表的。

@cindex dispatch table
@defmac ASM_OUTPUT_ADDR_DIFF_ELT (@var{stream}, @var{body}, @var{value}, @var{rel})
@en A C statement to output to the stdio stream @var{stream} an assembler
@en pseudo-instruction to generate a difference between two labels.
@en @var{value} and @var{rel} are the numbers of two internal labels.  The
@en definitions of these labels are output using
@en @code{(*targetm.asm_out.internal_label)}, and they must be printed in the same
@en way here.  For example,
一条C语句，用来将汇编伪指令输出到stdio流@var{stream}中，
以生成两个标号间的距离。@var{value}和@var{rel}为两个内部标号的编号。
这些标号的定义通过使用@code{(*targetm.asm_out.internal_label)}来输出，
并且它们必须使用相同的方式打印。例如，

@smallexample
fprintf (@var{stream}, "\t.word L%d-L%d\n",
         @var{value}, @var{rel})
@end smallexample

@en You must provide this macro on machines where the addresses in a
@en dispatch table are relative to the table's own address.  If defined, GCC
@en will also use this macro on all machines when producing PIC@.
@en @var{body} is the body of the @code{ADDR_DIFF_VEC}; it is provided so that the
@en mode and flags can be read.
在一些机器上，派遣表中的地址是相对于表自己的地址，对此你必须提供该宏。
如果定义，GCC还将在生成PIC的所有机器上使用该宏。
@var{body}为@code{ADDR_DIFF_VEC}的主体；提供它使得可以读取模式和标记。
@end defmac

@defmac ASM_OUTPUT_ADDR_VEC_ELT (@var{stream}, @var{value})
@en This macro should be provided on machines where the addresses
@en in a dispatch table are absolute.
在一些机器上，派遣表中的地址为绝对地址，对此应该提供该宏。

@en The definition should be a C statement to output to the stdio stream
@en @var{stream} an assembler pseudo-instruction to generate a reference to
@en a label.  @var{value} is the number of an internal label whose
@en definition is output using @code{(*targetm.asm_out.internal_label)}.
@en For example,
定义应该为一条C语句，用来将汇编伪指令输出到stdio流@var{stream}中，
以生成对一个标号的引用。@var{value}为内部标号的编号，
其定义应该使用@code{(*targetm.asm_out.internal_label)}输出。例如，

@smallexample
fprintf (@var{stream}, "\t.word L%d\n", @var{value})
@end smallexample
@end defmac

@defmac ASM_OUTPUT_CASE_LABEL (@var{stream}, @var{prefix}, @var{num}, @var{table})
@en Define this if the label before a jump-table needs to be output
@en specially.  The first three arguments are the same as for
@en @code{(*targetm.asm_out.internal_label)}; the fourth argument is the
@en jump-table which follows (a @code{jump_insn} containing an
@en @code{addr_vec} or @code{addr_diff_vec}).
定义该宏，如果在跳转表之前的标号需要被特殊输出。
前三个参数跟@code{(*targetm.asm_out.internal_label)}相同；
第四个参数为随后的跳转表（一个包含@code{addr_vec}或@code{addr_diff_vec}
的@code{jump_insn}）。

@en This feature is used on system V to output a @code{swbeg} statement
@en for the table.
该特点用于system V，来为table输出一条@code{swbeg}语句。

@en If this macro is not defined, these labels are output with
@en @code{(*targetm.asm_out.internal_label)}.
如果没有定义该宏，这些标号使用@code{(*targetm.asm_out.internal_label)}输出。
@end defmac

@defmac ASM_OUTPUT_CASE_END (@var{stream}, @var{num}, @var{table})
@en Define this if something special must be output at the end of a
@en jump-table.  The definition should be a C statement to be executed
@en after the assembler code for the table is written.  It should write
@en the appropriate code to stdio stream @var{stream}.  The argument
@en @var{table} is the jump-table insn, and @var{num} is the label-number
@en of the preceding label.
定义该宏，如果在跳转表的结尾必须输出一些特殊的东西。定义应该为一条C语句，
在写完table的汇编代码后被执行。其应该将适当的代码写入到stdio流@var{stream}中。
参数@var{table}为jump-table insn，@var{num}为前面的标号的编号。

@en If this macro is not defined, nothing special is output at the end of
@en the jump-table.
如果没有定义该宏，在跳转表的结尾不输出任何特殊的东西。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_EMIT_UNWIND_LABEL (FILE *@var{stream}, tree @var{decl}, int @var{for_eh}, int @var{empty})
@en This target hook emits a label at the beginning of each FDE@.  It
@en should be defined on targets where FDEs need special labels, and it
@en should write the appropriate label, for the FDE associated with the
@en function declaration @var{decl}, to the stdio stream @var{stream}.
@en The third argument, @var{for_eh}, is a boolean: true if this is for an
@en exception table.  The fourth argument, @var{empty}, is a boolean:
@en true if this is a placeholder label for an omitted FDE@.
该target钩子在每个FDE的起始处生成一个标号。在一些target上，FDE需要特殊的标号，
对此应该定义该宏。其应该为函数声明@var{decl}相关联的FDE写入适当的标号到stdio流
@var{stream}中。第三个参数，@var{for_eh}，为一个布尔值；当是异常表时为真。
第四个参数@var{empty}，为一个布尔值；当是一个省略掉的FDE的占位符标号时为真。

@en The default is that FDEs are not given nonlocal labels.
缺省为FDE不给出非局部标号。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL (FILE *@var{stream})
@en This target hook emits a label at the beginning of the exception table.
@en It should be defined on targets where it is desirable for the table
@en to be broken up according to function.
该target钩子在异常表的起始处生成一个标号。在一些target上，
异常表需要根据函数被分割开，对此应该定义该宏。

The default is that no label is emitted.
缺省为不生成标号。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_EMIT_EXCEPT_PERSONALITY (rtx @var{personality})
If the target implements @code{TARGET_ASM_UNWIND_EMIT}, this hook may be used to emit a directive to install a personality hook into the unwind info.  This hook should not be used if dwarf2 unwind info is used.
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_UNWIND_EMIT (FILE *@var{stream}, rtx @var{insn})
@en This target hook emits assembly directives required to unwind the
@en given instruction.  This is only used when @code{TARGET_EXCEPT_UNWIND_INFO}
@en returns @code{UI_TARGET}.
该target钩子生成需要展开给定指定的汇编伪指令。这只在当@code{TARGET_EXCEPT_UNWIND_INFO}返回@code{UI_TARGET}的时候才被使用。
@end deftypefn

@deftypevr {Target Hook} bool TARGET_ASM_UNWIND_EMIT_BEFORE_INSN
True if the @code{TARGET_ASM_UNWIND_EMIT} hook should be called before the assembly for @var{insn} has been emitted, false if the hook should be called afterward.
@end deftypevr

@en @node Exception Region Output
@en @subsection Assembler Commands for Exception Regions
@node Exception Region Output
@subsection 用于异常区域的汇编命令

@c prevent bad page break with this line
@en This describes commands marking the start and the end of an exception
@en region.
这一节描述了标记异常区域的起始和结束的命令。

@defmac EH_FRAME_SECTION_NAME
@en If defined, a C string constant for the name of the section containing
@en exception handling frame unwind information.  If not defined, GCC will
@en provide a default definition if the target supports named sections.
@en @file{crtstuff.c} uses this macro to switch to the appropriate section.
如果定义，为一个C字符串常量，包含异常处理帧展开信息的section名字。
如果没有定义，GCC将提供一个缺省定义，如果target支持命名section。
@file{crtstuff.c}使用该宏来切换到适当的section。

@en You should define this symbol if your target supports DWARF 2 frame
@en unwind information and the default definition does not work.
你应该定义该符号，如果你的target支持DWARF2帧展开信息并且缺省定义不工作。
@end defmac

@defmac EH_FRAME_IN_DATA_SECTION
@en If defined, DWARF 2 frame unwind information will be placed in the
@en data section even though the target supports named sections.  This
@en might be necessary, for instance, if the system linker does garbage
@en collection and sections cannot be marked as not to be collected.
如果定义，DWARF2帧展开信息将被放到data section，即使target支持命名section。
例如当系统连接器进行垃圾搜集并且section不能被标记为不被搜集的时候，
可能需要这样。

@en Do not define this macro unless @code{TARGET_ASM_NAMED_SECTION} is
@en also defined.
不要定义该宏，除非@code{TARGET_ASM_NAMED_SECTION}也被定义。
@end defmac

@defmac EH_TABLES_CAN_BE_READ_ONLY
@en Define this macro to 1 if your target is such that no frame unwind
@en information encoding used with non-PIC code will ever require a
@en runtime relocation, but the linker may not support merging read-only
@en and read-write sections into a single read-write section.
定义该宏为1，如果你的target对于没有使用non-PIC代码编码的帧展开信息，
将总是要求运行时重定位，
但是连接器可能不支持将只读和读写section合并到单独的读写section中。
@end defmac

@defmac MASK_RETURN_ADDR
@en An rtx used to mask the return address found via @code{RETURN_ADDR_RTX}, so
@en that it does not contain any extraneous set bits in it.
一个rtx，用于对通过@code{RETURN_ADDR_RTX}发现的返回地址进行掩码操作，
使得其不包含任何无关的位。
@end defmac

@defmac DWARF2_UNWIND_INFO
@en Define this macro to 0 if your target supports DWARF 2 frame unwind
@en information, but it does not yet work with exception handling.
@en Otherwise, if your target supports this information (if it defines
@en @code{INCOMING_RETURN_ADDR_RTX} and either @code{UNALIGNED_INT_ASM_OP}
@en or @code{OBJECT_FORMAT_ELF}), GCC will provide a default definition of 1.
定义该宏为0，如果你的target支持DWARF2帧展开信息，
但是其还不能与异常处理一起工作。否则，
如果你的target支持这样的信息（如果定义了@code{INCOMING_RETURN_ADDR_RTX}，
并且@code{UNALIGNED_INT_ASM_OP}和@code{OBJECT_FORMAT_ELF}之一），
GCC将提供缺省的定义，1。

@en If @code{TARGET_UNWIND_INFO} is defined, the target specific unwinder
@en will be used in all cases.  Defining this macro will enable the generation
@en of DWARF 2 frame debugging information.
如果定义了@code{TARGET_UNWIND_INFO}，target特定的展开者将用于所有情况。
定义该宏将使得可以生成DWARF2帧调试信息。

@en If @code{TARGET_UNWIND_INFO} is not defined, and this macro is defined to 1,
@en the DWARF 2 unwinder will be the default exception handling mechanism;
@en otherwise, the @code{setjmp}/@code{longjmp}-based scheme will be used by
@en default.
如果没有定义@code{TARGET_UNWIND_INFO}，并且该宏被定义为1，
则DWARF2 unwider将为缺省的异常处理机制；
否则基于@code{setjmp}/@code{longjmp}的框架将被缺省使用。
@end defmac

@deftypefn {Target Hook} {enum unwind_info_type} TARGET_EXCEPT_UNWIND_INFO (struct gcc_options *@var{opts})
This hook defines the mechanism that will be used for exception handling
by the target.  If the target has ABI specified unwind tables, the hook
should return @code{UI_TARGET}.  If the target is to use the
@code{setjmp}/@code{longjmp}-based exception handling scheme, the hook
should return @code{UI_SJLJ}.  If the target supports DWARF 2 frame unwind
information, the hook should return @code{UI_DWARF2}.

A target may, if exceptions are disabled, choose to return @code{UI_NONE}.
This may end up simplifying other parts of target-specific code.  The
default implementation of this hook never returns @code{UI_NONE}.

Note that the value returned by this hook should be constant.  It should
not depend on anything except the command-line switches described by
@var{opts}.  In particular, the
setting @code{UI_SJLJ} must be fixed at compiler start-up as C pre-processor
macros and builtin functions related to exception handling are set up
depending on this setting.

The default implementation of the hook first honors the
@option{--enable-sjlj-exceptions} configure option, then
@code{DWARF2_UNWIND_INFO}, and finally defaults to @code{UI_SJLJ}.  If
@code{DWARF2_UNWIND_INFO} depends on command-line options, the target
must define this hook so that @var{opts} is used correctly.
@end deftypefn

@deftypevar {Target Hook} bool TARGET_UNWIND_TABLES_DEFAULT
@en This variable should be set to @code{true} if the target ABI requires unwinding
@en tables even when exceptions are not used.
该变量应该被设为@code{true}，如果target ABI即使不使用异常的时候也要求展开表。
@end deftypevar

@deftypevr {Target Hook} bool TARGET_UNWIND_TABLES_DEFAULT
This variable should be set to @code{true} if the target ABI requires unwinding
tables even when exceptions are not used.  It must not be modified by
command-line option processing.
@end deftypevr

@defmac DONT_USE_BUILTIN_SETJMP
@en Define this macro to 1 if the @code{setjmp}/@code{longjmp}-based scheme
@en should use the @code{setjmp}/@code{longjmp} functions from the C library
@en instead of the @code{__builtin_setjmp}/@code{__builtin_longjmp} machinery.
定义该宏为1，如果基于@code{setjmp}/@code{longjmp}的框架应该使用C库中的
@code{setjmp}/@code{longjmp}，
而不是@code{__builtin_setjmp}/@code{__builtin_longjmp}。
@end defmac

@defmac DWARF_CIE_DATA_ALIGNMENT
@en This macro need only be defined if the target might save registers in the
@en function prologue at an offset to the stack pointer that is not aligned to
@en @code{UNITS_PER_WORD}.  The definition should be the negative minimum
@en alignment if @code{STACK_GROWS_DOWNWARD} is defined, and the positive
@en minimum alignment otherwise.  @xref{SDB and DWARF}.  Only applicable if
@en the target supports DWARF 2 frame unwind information.
该宏只有当target可能会在函数序言中存储寄存器，
并且相对栈指针的偏移量没有对齐于@code{UNITS_PER_WORD}的时候，才需要被定义。
定义应该为负的最小对齐数，如果@code{STACK_GROWS_DOWNWARD}被定义，
否则为正的最小对齐数。@xref{SDB and DWARF}。
只有当target支持DWARF2帧展开信息的时候才有用。
@end defmac

@deftypevr {Target Hook} bool TARGET_TERMINATE_DW2_EH_FRAME_INFO
@en Contains the value true if the target should add a zero word onto the
@en end of a Dwarf-2 frame info section when used for exception handling.
@en Default value is false if @code{EH_FRAME_SECTION_NAME} is defined, and
@en true otherwise.
值为真，如果target应该增加一个0字到Dwarf-2帧信息section的结尾，
当用于异常处理时。缺省值为假，如果@code{EH_FRAME_SECTION_NAME}被定义，否则为真。
@end deftypevr

@deftypefn {Target Hook} rtx TARGET_DWARF_REGISTER_SPAN (rtx @var{reg})
@en Given a register, this hook should return a parallel of registers to
@en represent where to find the register pieces.  Define this hook if the
@en register and its mode are represented in Dwarf in non-contiguous
@en locations, or if the register should be represented in more than one
@en register in Dwarf.  Otherwise, this hook should return @code{NULL_RTX}.
@en If not defined, the default is to return @code{NULL_RTX}.
给定一个寄存器，该钩子应该返回一个并行的寄存器，来表示到哪里发现寄存器块。
定义该钩子，如果寄存器和它的机器模式在Dwarf中被表示为非连接的位置，
或者如果在Dwarf中寄存器应该被表示为多于一个寄存器。
否则该钩子应该返回@code{NULL_RTX}。如果没有定义，缺省为返回@code{NULL_RTX}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_INIT_DWARF_REG_SIZES_EXTRA (tree @var{address})
@en If some registers are represented in Dwarf-2 unwind information in
@en multiple pieces, define this hook to fill in information about the
@en sizes of those pieces in the table used by the unwinder at runtime.
@en It will be called by @code{expand_builtin_init_dwarf_reg_sizes} after
@en filling in a single size corresponding to each hard register;
@en @var{address} is the address of the table.
如果一些寄存器在Dwarf-2展开信息中按照多个块来表示，
定义该钩子在运行时来填充信息。
其将被@code{expand_builtin_init_dwarf_reg_sizes}调用。@var{address}为表的地址。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ASM_TTYPE (rtx @var{sym})
@en This hook is used to output a reference from a frame unwinding table to
@en the type_info object identified by @var{sym}.  It should return @code{true}
@en if the reference was output.  Returning @code{false} will cause the
@en reference to be output using the normal Dwarf2 routines.
该钩子被用于从帧展开表中输出一个引用到由@var{sym}标识的type_info对象中。
其应该返回@code{true}，如果引用被输出。
返回@code{false}将会造成引用使用通常的Dwarf2例程被输出。
@end deftypefn

@deftypevr {Target Hook} bool TARGET_ARM_EABI_UNWINDER
@en This flag should be set to @code{true} on targets that use an ARM EABI
@en based unwinding library, and @code{false} on other targets.  This effects
@en the format of unwinding tables, and how the unwinder in entered after
@en running a cleanup.  The default is @code{false}.
该钩子应该被设为@code{true}，在使用基于ARM EABI的展开库的target上，
并且在其它target上为@code{false}。这将影响展开表的格式。缺省为@code{false}。
@end deftypevr

@en @node Alignment Output
@en @subsection Assembler Commands for Alignment
@node Alignment Output
@subsection 用于对齐的汇编命令

@c prevent bad page break with this line
@en This describes commands for alignment.
这一节描述了用于对齐的命令。

@defmac JUMP_ALIGN (@var{label})
@en The alignment (log base 2) to put in front of @var{label}, which is
@en a common destination of jumps and has no fallthru incoming edge.
在@var{label}前放入的对齐数（基于2的log），
label为跳转的普通目的地并且不具有fallthru入边。

@en This macro need not be defined if you don't want any special alignment
@en to be done at such a time.  Most machine descriptions do not currently
@en define the macro.
如果你目前不想做任何特殊的对齐，则不需要定义该宏。
大多数机器描述目前都没有定义该宏。

@en Unless it's necessary to inspect the @var{label} parameter, it is better
@en to set the variable @var{align_jumps} in the target's
@en @code{TARGET_OPTION_OVERRIDE}.  Otherwise, you should try to honor the user's
@en selection in @var{align_jumps} in a @code{JUMP_ALIGN} implementation.
除非需要检查@var{label}参数，
最好在target的@code{OVERRIDE_OPTIONS}中设置变量@var{align_jumps}。
否则应该尽量在@code{JUMP_ALIGN}实现中尊重用户在@var{align_jumps}中的选择。
@end defmac

@deftypefn {Target Hook} int TARGET_ASM_JUMP_ALIGN_MAX_SKIP (rtx @var{label})
The maximum number of bytes to skip before @var{label} when applying
@code{JUMP_ALIGN}.  This works only if
@code{ASM_OUTPUT_MAX_SKIP_ALIGN} is defined.
@end deftypefn

@defmac LABEL_ALIGN_AFTER_BARRIER (@var{label})
@en The alignment (log base 2) to put in front of @var{label}, which follows
@en a @code{BARRIER}.
在@var{label}前放入的对齐数（基于2的log），@var{label}后跟随一个@code{BARRIER}。

@en This macro need not be defined if you don't want any special alignment
@en to be done at such a time.  Most machine descriptions do not currently
@en define the macro.
如果你目前不想做任何特殊的对齐，则不需要定义该宏。
大多数机器描述目前都没有定义该宏。
@end defmac

@deftypefn {Target Hook} int TARGET_ASM_LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP (rtx @var{label})
@en The maximum number of bytes to skip before @var{label} when applying
@en @code{LABEL_ALIGN_AFTER_BARRIER}.  This works only if
@en @code{ASM_OUTPUT_MAX_SKIP_ALIGN} is defined.
当应用@code{LABEL_ALIGN_AFTER_BARRIER}时，在@var{label}之前要跳过的最大字节个数。
这只在定义了@code{ASM_OUTPUT_MAX_SKIP_ALIGN}时才起作用。
@end deftypefn

@defmac LOOP_ALIGN (@var{label})
@en The alignment (log base 2) to put in front of @var{label}, which follows
@en a @code{NOTE_INSN_LOOP_BEG} note.
在@var{label}前放入的对齐数（基于2的log），
@var{label}后跟随一个@code{NOTE_INSN_LOOP_BEG}注解。

@en This macro need not be defined if you don't want any special alignment
@en to be done at such a time.  Most machine descriptions do not currently
@en define the macro.
如果你目前不想做任何特殊的对齐，则不需要定义该宏。
大多数机器描述目前都没有定义该宏。

@en Unless it's necessary to inspect the @var{label} parameter, it is better
@en to set the variable @code{align_loops} in the target's
@en @code{TARGET_OPTION_OVERRIDE}.  Otherwise, you should try to honor the user's
@en selection in @code{align_loops} in a @code{LOOP_ALIGN} implementation.
除非需要检查@var{label}参数，
最好在target的@code{OVERRIDE_OPTIONS}中设置变量@code{align_loops}。
否则应该尽量在@code{LOOP_ALIGN}实现中尊重用户在@code{align_loops}中的选择。
@end defmac

@deftypefn {Target Hook} int TARGET_ASM_LOOP_ALIGN_MAX_SKIP (rtx @var{label})
@en The maximum number of bytes to skip when applying @code{LOOP_ALIGN} to
@en @var{label}.  This works only if @code{ASM_OUTPUT_MAX_SKIP_ALIGN} is
@en defined.
当对@var{label}应用@code{LOOP_ALIGN}时，要跳过的最大字节个数。
这只在定义了@code{ASM_OUTPUT_MAX_SKIP_ALIGN}时才起作用。
@end deftypefn

@defmac LABEL_ALIGN (@var{label})
@en The alignment (log base 2) to put in front of @var{label}.
@en If @code{LABEL_ALIGN_AFTER_BARRIER} / @code{LOOP_ALIGN} specify a different alignment,
@en the maximum of the specified values is used.
在@var{label}前放入的对齐数（基于2的log），
如果@code{LABEL_ALIGN_AFTER_BARRIER} / @code{LOOP_ALIGN}指定了不相同的对齐，
则使用最大的值。

@en Unless it's necessary to inspect the @var{label} parameter, it is better
@en to set the variable @code{align_labels} in the target's
@en @code{TARGET_OPTION_OVERRIDE}.  Otherwise, you should try to honor the user's
@en selection in @code{align_labels} in a @code{LABEL_ALIGN} implementation.
除非需要检查@var{label}参数，
最好在target的@code{OVERRIDE_OPTIONS}中设置变量@code{align_labels}。
否则应该尽量在@code{LABEL_ALIGN}实现中尊重用户在@code{align_labels}中的选择。
@end defmac

@deftypefn {Target Hook} int TARGET_ASM_LABEL_ALIGN_MAX_SKIP (rtx @var{label})
@en The maximum number of bytes to skip when applying @code{LABEL_ALIGN}
@en to @var{label}.  This works only if @code{ASM_OUTPUT_MAX_SKIP_ALIGN}
@en is defined.
当对@var{label}应用@code{LABEL_ALIGN}时，要跳过的最大字节个数。
这只在定义了@code{ASM_OUTPUT_MAX_SKIP_ALIGN}时才起作用。
@end deftypefn

@defmac ASM_OUTPUT_SKIP (@var{stream}, @var{nbytes})
@en A C statement to output to the stdio stream @var{stream} an assembler
@en instruction to advance the location counter by @var{nbytes} bytes.
@en Those bytes should be zero when loaded.  @var{nbytes} will be a C
@en expression of type @code{unsigned HOST_WIDE_INT}.
一条C语句，将一条汇编指令输出到stdio流@var{stream}中，
使得将位置计数器前移@var{nbytes}个字节。那些字节在加载时应该为0。
@var{nbytes}将为@code{unsigned HOST_WIDE_INT}类型的C表达式。
@end defmac

@defmac ASM_NO_SKIP_IN_TEXT
@en Define this macro if @code{ASM_OUTPUT_SKIP} should not be used in the
@en text section because it fails to put zeros in the bytes that are skipped.
@en This is true on many Unix systems, where the pseudo--op to skip bytes
@en produces no-op instructions rather than zeros when used in the text
@en section.
定义该宏，如果@code{ASM_OUTPUT_SKIP}不应该在text section中使用，
因为无法在跳过的字节中放入0。这在许多Unix系统上都为，
当在text section中使用时，跳过字节的伪指令会产生no-op指令，而不是0。
@end defmac

@defmac ASM_OUTPUT_ALIGN (@var{stream}, @var{power})
@en A C statement to output to the stdio stream @var{stream} an assembler
@en command to advance the location counter to a multiple of 2 to the
@en @var{power} bytes.  @var{power} will be a C expression of type @code{int}.
一条C语句，将一条汇编指令输出到stdio流@var{stream}中，
使得将位置计数器前移2的@var{power}次幂个字节。
@var{power}为@code{int}类型的表达式。
@end defmac

@defmac ASM_OUTPUT_ALIGN_WITH_NOP (@var{stream}, @var{power})
@en Like @code{ASM_OUTPUT_ALIGN}, except that the ``nop'' instruction is used
@en for padding, if necessary.
类似@code{ASM_OUTPUT_ALIGN}，除了使用“nop”指令来填充，如果需要的话。
@end defmac

@defmac ASM_OUTPUT_MAX_SKIP_ALIGN (@var{stream}, @var{power}, @var{max_skip})
@en A C statement to output to the stdio stream @var{stream} an assembler
@en command to advance the location counter to a multiple of 2 to the
@en @var{power} bytes, but only if @var{max_skip} or fewer bytes are needed to
@en satisfy the alignment request.  @var{power} and @var{max_skip} will be
@en a C expression of type @code{int}.
一条C语句，将一条汇编指令输出到stdio流@var{stream}中，
使得将位置计数器前移2的@var{power}次幂个字节，
但只有当需要@var{max_skip}个或者更少的字节来满足对齐要求的时候才行。
@var{power}和@var{max_skip}为@code{int}类型的表达式。
@end defmac

@need 3000
@en @node Debugging Info
@en @section Controlling Debugging Information Format
@node Debugging Info
@section 控制调试信息格式

@c prevent bad page break with this line
@en This describes how to specify debugging information.
描述了如何指定调试信息。

@en @menu
@en * All Debuggers::      Macros that affect all debugging formats uniformly.
@en * DBX Options::        Macros enabling specific options in DBX format.
@en * DBX Hooks::          Hook macros for varying DBX format.
@en * File Names and DBX:: Macros controlling output of file names in DBX format.
@en * SDB and DWARF::      Macros for SDB (COFF) and DWARF formats.
@en * VMS Debug::          Macros for VMS debug format.
@en @end menu
@menu
* All Debuggers::	影响所有调试信息的宏   
* DBX Options::		启用DBX格式的特定选项的宏  
* DBX Hooks::		变更DBX格式的钩子宏 
* File Names and DBX::	控制DBX格式中文件名的输出
* SDB and DWARF::	用于SDB（COFF）和DWARF格式的宏
* VMS Debug::		用于VMS调试格式的宏
@end menu

@en @node All Debuggers
@en @subsection Macros Affecting All Debugging Formats
@node All Debuggers
@subsection 影响所有调试格式的宏

@c prevent bad page break with this line
@en These macros affect all debugging formats.
这些宏影响所有的调试格式。

@defmac DBX_REGISTER_NUMBER (@var{regno})
@en A C expression that returns the DBX register number for the compiler
@en register number @var{regno}.  In the default macro provided, the value
@en of this expression will be @var{regno} itself.  But sometimes there are
@en some registers that the compiler knows about and DBX does not, or vice
@en versa.  In such cases, some register may need to have one number in the
@en compiler and another for DBX@.
一个C表达式，返回编译器寄存器号@var{regno}的DBX寄存器号。
在提供的缺省宏中，该表达式的值将为@var{regno}本身。
但是有时候，有些寄存器编译器知道但是DBX不知道，或者相反。
对于这种情况，寄存器可能需要在编译器中具有一个编号，
而在DBX中具有另一个。

@en If two registers have consecutive numbers inside GCC, and they can be
@en used as a pair to hold a multiword value, then they @emph{must} have
@en consecutive numbers after renumbering with @code{DBX_REGISTER_NUMBER}.
@en Otherwise, debuggers will be unable to access such a pair, because they
@en expect register pairs to be consecutive in their own numbering scheme.
如果两个寄存器在GCC中具有连续的编号，
并且可以作为一对用来保存多字的值，
则它们在使用@code{DBX_REGISTER_NUMBER}重新编号之后
@emph{必须}还具有连续的编号。
否则，调试器将无法访问这样的寄存器对，
因为调试器期望寄存器对在自己的编号方案下也是连续的。

@en If you find yourself defining @code{DBX_REGISTER_NUMBER} in way that
@en does not preserve register pairs, then what you must do instead is
@en redefine the actual register numbering scheme.
如果你发现自己定义的@code{DBX_REGISTER_NUMBER}不能保持寄存器对，
则必须重定义实际的寄存器编号方案。
@end defmac

@defmac DEBUGGER_AUTO_OFFSET (@var{x})
@en A C expression that returns the integer offset value for an automatic
@en variable having address @var{x} (an RTL expression).  The default
@en computation assumes that @var{x} is based on the frame-pointer and
@en gives the offset from the frame-pointer.  This is required for targets
@en that produce debugging output for DBX or COFF-style debugging output
@en for SDB and allow the frame-pointer to be eliminated when the
@en @option{-g} options is used.
一个C表达式，返回具有地址@var{x}（RTL表达式）的自动变量的整数偏移量。
缺省计算是假设@var{x}基于帧指针的，并会给出相对帧指针的偏移量。
这对于产生DBX调试输出或COFF风格的SDB调试输出，
并且在使用@option{-g}选项时也允许消除帧指针的目标，会有需要。
@end defmac

@defmac DEBUGGER_ARG_OFFSET (@var{offset}, @var{x})
@en A C expression that returns the integer offset value for an argument
@en having address @var{x} (an RTL expression).  The nominal offset is
@en @var{offset}.
一个C表达式，返回具有地址@var{x}（RTL表达式）的参数的整数偏移量。
名义上的偏移量为@var{offset}。
@end defmac

@defmac PREFERRED_DEBUGGING_TYPE
@en A C expression that returns the type of debugging output GCC should
@en produce when the user specifies just @option{-g}.  Define
@en this if you have arranged for GCC to support more than one format of
@en debugging output.  Currently, the allowable values are @code{DBX_DEBUG},
@en @code{SDB_DEBUG}, @code{DWARF_DEBUG}, @code{DWARF2_DEBUG},
@en @code{XCOFF_DEBUG}, @code{VMS_DEBUG}, and @code{VMS_AND_DWARF2_DEBUG}.
一个C表达式，返回当用户只指定@option{-g}时，
GCC应该产生的调试输出类型。
如果你已经使得GCC支持多种调试输出格式的时候，则定义该宏。
目前，允许的值为@code{DBX_DEBUG}, @code{SDB_DEBUG}, @code{DWARF_DEBUG}, 
@code{DWARF2_DEBUG}, @code{XCOFF_DEBUG}, 
@code{VMS_DEBUG}和@code{VMS_AND_DWARF2_DEBUG}。

@en When the user specifies @option{-ggdb}, GCC normally also uses the
@en value of this macro to select the debugging output format, but with two
@en exceptions.  If @code{DWARF2_DEBUGGING_INFO} is defined, GCC uses the
@en value @code{DWARF2_DEBUG}.  Otherwise, if @code{DBX_DEBUGGING_INFO} is
@en defined, GCC uses @code{DBX_DEBUG}.
当用户指定@option{-ggdb}时，GCC通常还使用该宏的值来选择调试输出格式，
但是有两个例外。如果定义了@code{DWARF2_DEBUGGING_INFO}，
则GCC使用值@code{DWARF2_DEBUG}，如果定义了@code{DBX_DEBUGGING_INFO}，
则GCC使用@code{DBX_DEBUG}。

@en The value of this macro only affects the default debugging output; the
@en user can always get a specific type of output by using @option{-gstabs},
@en @option{-gcoff}, @option{-gdwarf-2}, @option{-gxcoff}, or @option{-gvms}.
该宏的值只影响缺省调试输出；用户总是可以通过使用@option{-gstabs},
@option{-gcoff}, @option{-gdwarf-2}, 
@option{-gxcoff}或@option{-gvms}来获得指定类型的输出。
@end defmac

@en @node DBX Options
@en @subsection Specific Options for DBX Output
@node DBX Options
@subsection 用于DBX输出的特定选项

@c prevent bad page break with this line
@en These are specific options for DBX output.
这些是用于DBX输出的特定选项。

@defmac DBX_DEBUGGING_INFO
@en Define this macro if GCC should produce debugging output for DBX
@en in response to the @option{-g} option.
定义该宏，如果对于@option{-g}选项，GCC应该产生DBX的调试输出。
@end defmac

@defmac XCOFF_DEBUGGING_INFO
@en Define this macro if GCC should produce XCOFF format debugging output
@en in response to the @option{-g} option.  This is a variant of DBX format.
定义该宏，如果对于@option{-g}选项，GCC应该产生XCOFF格式的调试输出。
这是DBX格式的变体。
@end defmac

@defmac DEFAULT_GDB_EXTENSIONS
@en Define this macro to control whether GCC should by default generate
@en GDB's extended version of DBX debugging information (assuming DBX-format
@en debugging information is enabled at all).  If you don't define the
@en macro, the default is 1: always generate the extended information
@en if there is any occasion to.
定义该宏来控制GCC是否缺省的生成GDB的扩展版本DBX调试信息
（假设是使用DBX格式的调试信息）。如果没有定义该宏，则缺省为1：
如果可能的话，总是生成扩展信息。
@end defmac

@defmac DEBUG_SYMS_TEXT
@en Define this macro if all @code{.stabs} commands should be output while
@en in the text section.
定义该宏，如果所有@code{.stabs}命令应该输出在text section中。
@end defmac

@defmac ASM_STABS_OP
@en A C string constant, including spacing, naming the assembler pseudo op to
@en use instead of @code{"\t.stabs\t"} to define an ordinary debugging symbol.
@en If you don't define this macro, @code{"\t.stabs\t"} is used.  This macro
@en applies only to DBX debugging information format.
一个C字符串常量，包括空格，
命名了用来替代@code{"\t.stabs\t"}的汇编伪指令，
来定义一个普通调试符号。
如果没有定义该宏，则使用@code{"\t.stabs\t"}。
该宏只用于DBX调试信息格式。
@end defmac

@defmac ASM_STABD_OP
@en A C string constant, including spacing, naming the assembler pseudo op to
@en use instead of @code{"\t.stabd\t"} to define a debugging symbol whose
@en value is the current location.  If you don't define this macro,
@en @code{"\t.stabd\t"} is used.  This macro applies only to DBX debugging
@en information format.
一个C字符串常量，包括空格，
命名了用来替代@code{"\t.stabd\t"}的汇编伪指令，
来定义一个普通调试符号。
如果没有定义该宏，则使用@code{"\t.stabd\t"}。
该宏只用于DBX调试信息格式。
@end defmac

@defmac ASM_STABN_OP
@en A C string constant, including spacing, naming the assembler pseudo op to
@en use instead of @code{"\t.stabn\t"} to define a debugging symbol with no
@en name.  If you don't define this macro, @code{"\t.stabn\t"} is used.  This
@en macro applies only to DBX debugging information format.
一个C字符串常量，包括空格，
命名了用来替代@code{"\t.stabn\t"}的汇编伪指令，来定义一个普通调试符号。
如果没有定义该宏，则使用@code{"\t.stabn\t"}。该宏只用于DBX调试信息格式。
@end defmac

@defmac DBX_NO_XREFS
@en Define this macro if DBX on your system does not support the construct
@en @samp{xs@var{tagname}}.  On some systems, this construct is used to
@en describe a forward reference to a structure named @var{tagname}.
@en On other systems, this construct is not supported at all.
定义该宏，如果DBX在你的系统上不支持@samp{xs@var{tagname}}结构。
在一些系统上，该结构被用于描述对名字叫@var{tagname}的结构体的向前引用。
在其它系统上，该结构根本不被支持。
@end defmac

@defmac DBX_CONTIN_LENGTH
@en A symbol name in DBX-format debugging information is normally
@en continued (split into two separate @code{.stabs} directives) when it
@en exceeds a certain length (by default, 80 characters).  On some
@en operating systems, DBX requires this splitting; on others, splitting
@en must not be done.  You can inhibit splitting by defining this macro
@en with the value zero.  You can override the default splitting-length by
@en defining this macro as an expression for the length you desire.
DBX格式的调试信息中的符号名被连续的处理
（分成两个独立的@code{.stabs}指令）
当其达到一个特定长度时（缺省为80个字符）。
在一些操作系统上，DBX 要求做这样的分割；在其它上面，则不能进行分割。
你可以通过定义该宏为0来约束分割。
你可以覆盖缺省的分割长度，通过定义该宏为一个长度的表达式。
@end defmac

@defmac DBX_CONTIN_CHAR
@en Normally continuation is indicated by adding a @samp{\} character to
@en the end of a @code{.stabs} string when a continuation follows.  To use
@en a different character instead, define this macro as a character
@en constant for the character you want to use.  Do not define this macro
@en if backslash is correct for your system.
通常通过在@code{.stabs}字符串的结尾增加一个@samp{\}字符来表示连续的处理。
要是用不用的字符，定义该宏为一个你想使用的字符常量。
不要定义该宏，如果反斜杠在你的系统上是正确的。
@end defmac

@defmac DBX_STATIC_STAB_DATA_SECTION
@en Define this macro if it is necessary to go to the data section before
@en outputting the @samp{.stabs} pseudo-op for a non-global static
@en variable.
定义该宏，如果需要在为非全局的静态变量输出@samp{.stabs}伪操作符之前进入data section。
@end defmac

@defmac DBX_TYPE_DECL_STABS_CODE
@en The value to use in the ``code'' field of the @code{.stabs} directive
@en for a typedef.  The default is @code{N_LSYM}.
对于typedef，@code{.stabs}指令的“code”域所使用的值。
缺省为@code{N_LSYM}。
@end defmac

@defmac DBX_STATIC_CONST_VAR_CODE
@en The value to use in the ``code'' field of the @code{.stabs} directive
@en for a static variable located in the text section.  DBX format does not
@en provide any ``right'' way to do this.  The default is @code{N_FUN}.
对于位于text section的静态变量，@code{.stabs}指令的“code”域所使用的值。
DBX格式不提供任何正确是方式。缺省为@code{N_FUN}。
@end defmac

@defmac DBX_REGPARM_STABS_CODE
@en The value to use in the ``code'' field of the @code{.stabs} directive
@en for a parameter passed in registers.  DBX format does not provide any
@en ``right'' way to do this.  The default is @code{N_RSYM}.
对于寄存器中传递的参数，@code{.stabs}指令的“code”域所使用的值。
DBX格式不提供任何正确是方式。缺省为@code{N_RSYM}。
@end defmac

@defmac DBX_REGPARM_STABS_LETTER
@en The letter to use in DBX symbol data to identify a symbol as a parameter
@en passed in registers.  DBX format does not customarily provide any way to
@en do this.  The default is @code{'P'}.
在DBX符号数据中使用的字母，用来标识一个符号为在寄存器中传递的参数。
DBX格式目前没有提供任何这样做的方式。缺省为@code{'P'}。
@end defmac

@defmac DBX_FUNCTION_FIRST
@en Define this macro if the DBX information for a function and its
@en arguments should precede the assembler code for the function.  Normally,
@en in DBX format, the debugging information entirely follows the assembler
@en code.
定义该宏，如果对于函数和它的参数的DBX信息应该位于函数的汇编代码之前。
通常，在DBX格式中，调试信息完全位于汇编代码之后。
@end defmac

@defmac DBX_BLOCKS_FUNCTION_RELATIVE
@en Define this macro, with value 1, if the value of a symbol describing
@en the scope of a block (@code{N_LBRAC} or @code{N_RBRAC}) should be
@en relative to the start of the enclosing function.  Normally, GCC uses
@en an absolute address.
定义该宏为1，
如果描述块（@code{N_LBRAC}或@code{N_RBRAC}）的作用域的符号的值，
应该相对于函数括号的起始处。通常GCC使用绝对值。
@end defmac

@defmac DBX_LINES_FUNCTION_RELATIVE
@en Define this macro, with value 1, if the value of a symbol indicating
@en the current line number (@code{N_SLINE}) should be relative to the
@en start of the enclosing function.  Normally, GCC uses an absolute address.
定义该宏为1，如果指示当前行（@code{N_SLINE}）的符号的值，
应该相对于函数括号的起始处。通常GCC使用绝对值。
@end defmac

@defmac DBX_USE_BINCL
@en Define this macro if GCC should generate @code{N_BINCL} and
@en @code{N_EINCL} stabs for included header files, as on Sun systems.  This
@en macro also directs GCC to output a type number as a pair of a file
@en number and a type number within the file.  Normally, GCC does not
@en generate @code{N_BINCL} or @code{N_EINCL} stabs, and it outputs a single
@en number for a type number.
定义该宏，
如果GCC应该为被包含的头文件生成@code{N_BINCL}和@code{N_EINCL} stabs，
如Sun系统。通常，GCC不生成@code{N_BINCL}或@code{N_EINCL} stabs。
@end defmac

@en @node DBX Hooks
@en @subsection Open-Ended Hooks for DBX Format
@node DBX Hooks
@subsection 针对DBX格式的钩子

@c prevent bad page break with this line
@en These are hooks for DBX format.
@en 这些是针对DBX格式的钩子。

@defmac DBX_OUTPUT_LBRAC (@var{stream}, @var{name})
@en Define this macro to say how to output to @var{stream} the debugging
@en information for the start of a scope level for variable names.  The
@en argument @var{name} is the name of an assembler symbol (for use with
@en @code{assemble_name}) whose value is the address where the scope begins.
定义该宏，
以告知如何将变量名的作用域级别的起始调试信息输出到@var{stream}中。
参数@var{name}为一个汇编符号的名字（使用@code{assemble_name}），
其值为作用域起始的地址。
@end defmac

@defmac DBX_OUTPUT_RBRAC (@var{stream}, @var{name})
@en Like @code{DBX_OUTPUT_LBRAC}, but for the end of a scope level.
类似@code{DBX_OUTPUT_LBRAC}，不过是作用域级别的结尾。
@end defmac

@defmac DBX_OUTPUT_NFUN (@var{stream}, @var{lscope_label}, @var{decl})
@en Define this macro if the target machine requires special handling to
@en output an @code{N_FUN} entry for the function @var{decl}.
定义该宏，
如果target机器要求对函数@var{decl}输出一个@code{N_FUN}条目进行特殊处理。
@end defmac

@defmac DBX_OUTPUT_SOURCE_LINE (@var{stream}, @var{line}, @var{counter})
@en A C statement to output DBX debugging information before code for line
@en number @var{line} of the current source file to the stdio stream
@en @var{stream}.  @var{counter} is the number of time the macro was
@en invoked, including the current invocation; it is intended to generate
@en unique labels in the assembly output.
一条C语句，将DBX调试信息在当前源文件行号@var{line}的代码前，
输出到stdio流@var{stream}中。@var{counter}为宏被调用的次数，
包括当前调用；其用于在汇编输出中生成为一个标号。

@en This macro should not be defined if the default output is correct, or
@en if it can be made correct by defining @code{DBX_LINES_FUNCTION_RELATIVE}.
如果缺省输出是正确的，
或者其能够通过定义@code{DBX_LINES_FUNCTION_RELATIVE}而变的正确，
则不要定义该宏。
@end defmac

@defmac NO_DBX_FUNCTION_END
@en Some stabs encapsulation formats (in particular ECOFF), cannot handle the
@en @code{.stabs "",N_FUN,,0,0,Lscope-function-1} gdb dbx extension construct.
@en On those machines, define this macro to turn this feature off without
@en disturbing the rest of the gdb extensions.
一些stab封装格式（特别是ECOFF），
不能处理@code{.stabs "",N_FUN,,0,0,Lscope-function-1} gdb dbx扩展结构。
在那些机器上，定义该宏来关掉这个特点，并且不影响其它gdb扩展。
@end defmac

@defmac NO_DBX_BNSYM_ENSYM
@en Some assemblers cannot handle the @code{.stabd BNSYM/ENSYM,0,0} gdb dbx
@en extension construct.  On those machines, define this macro to turn this
@en feature off without disturbing the rest of the gdb extensions.
一些汇编器不能处理@code{.stabd BNSYM/ENSYM,0,0} gdb dbx扩展结构。
在那些机器上，定义该宏来关掉这个特点，并且不影响其它gdb扩展。
@end defmac

@en @node File Names and DBX
@en @subsection File Names in DBX Format
@node File Names and DBX
@subsection DBX格式的文件名

@c prevent bad page break with this line
@en This describes file names in DBX format.
这一节描述了DBX格式的文件名。

@defmac DBX_OUTPUT_MAIN_SOURCE_FILENAME (@var{stream}, @var{name})
@en A C statement to output DBX debugging information to the stdio stream
@en @var{stream}, which indicates that file @var{name} is the main source
@en file---the file specified as the input file for compilation.
@en This macro is called only once, at the beginning of compilation.
一条C语句，
将DBX调试信息输出到标准输入输出（stdio）流@var{stream}上，
其中文件@var{name}为主源文件——被指定为被编译的输入文件。
该宏只被调用一次，在编译的开始处。

@en This macro need not be defined if the standard form of output
@en for DBX debugging information is appropriate.
如果DBX调试信息输出的标准形式合适，则该宏不需要被定义。

@en It may be necessary to refer to a label equal to the beginning of the
@en text section.  You can use @samp{assemble_name (stream, ltext_label_name)}
@en to do so.  If you do this, you must also set the variable
@en @var{used_ltext_label_name} to @code{true}.
有时可能需要引用相当与text段起始处的标号。
这时可以使用@samp{assemble_name (stream, ltext_label_name)}来完成。
如果这样做，则必须还要将变量@var{used_ltext_label_name}设为@code{true}。
@end defmac

@defmac NO_DBX_MAIN_SOURCE_DIRECTORY
@en Define this macro, with value 1, if GCC should not emit an indication
@en of the current directory for compilation and current source language at
@en the beginning of the file.
定义该宏的值为1，
如果不让GCC在文件起始处产生对当前的编译目录和当前的源语言的指示。
@end defmac

@defmac NO_DBX_GCC_MARKER
@en Define this macro, with value 1, if GCC should not emit an indication
@en that this object file was compiled by GCC@.  The default is to emit
@en an @code{N_OPT} stab at the beginning of every source file, with
@en @samp{gcc2_compiled.} for the string and value 0.
定义该宏的值为1，如果不让GCC产生该目标文件是由GCC编译的指示。
缺省情况是在每个源文件的起始处产生一个@code{N_OPT} stab，
其中字符串为@samp{gcc2_compiled.}，值为0。
@end defmac

@defmac DBX_OUTPUT_MAIN_SOURCE_FILE_END (@var{stream}, @var{name})
@en A C statement to output DBX debugging information at the end of
@en compilation of the main source file @var{name}.  Output should be
@en written to the stdio stream @var{stream}.
一条C语句，用来在主源文件@var{name}的编译结尾输出DBX调试信息。
输出将被写入标准输入输出流@var{stream}中。

@en If you don't define this macro, nothing special is output at the end
@en of compilation, which is correct for most machines.
如果没有定义该宏，则在编译的结尾将不做任何特定的输出，
这对于大多数机器都是正确的。
@end defmac

@defmac DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END
@en Define this macro @emph{instead of} defining
@en @code{DBX_OUTPUT_MAIN_SOURCE_FILE_END}, if what needs to be output at
@en the end of compilation is an @code{N_SO} stab with an empty string,
@en whose value is the highest absolute text address in the file.
定义该宏而不是定义@code{DBX_OUTPUT_MAIN_SOURCE_FILE_END}，
如果要在编译结尾输出的是一个@code{N_SO} stab，
其具有空字符串，值为文件中最高的绝对text地址。
@end defmac

@need 2000
@en @node SDB and DWARF
@en @subsection Macros for SDB and DWARF Output
@node SDB and DWARF
@subsection 用于SDB和DWARF输出的宏

@c prevent bad page break with this line
@en Here are macros for SDB and DWARF output.
这些是用于SDB和DWARF输出的宏。

@defmac SDB_DEBUGGING_INFO
@en Define this macro if GCC should produce COFF-style debugging output
@en for SDB in response to the @option{-g} option.
定义该宏，如果对于@option{-g}选项，GCC应该为SDB产生COFF风格的调试输出。
@end defmac

@defmac DWARF2_DEBUGGING_INFO
@en Define this macro if GCC should produce dwarf version 2 format
@en debugging output in response to the @option{-g} option.
定义该宏，如果对于@option{-g}选项，GCC应该产生dwarf本版2格式的调试输出。

@deftypefn {Target Hook} int TARGET_DWARF_CALLING_CONVENTION (const_tree @var{function})
@en Define this to enable the dwarf attribute @code{DW_AT_calling_convention} to
@en be emitted for each function.  Instead of an integer return the enum
@en value for the @code{DW_CC_} tag.
定义该钩子，使得为个函数输出dwarf属性@code{DW_AT_calling_convention}。
返回@code{DW_CC_}标记的enum值。
@end deftypefn

@en To support optional call frame debugging information, you must also
@en define @code{INCOMING_RETURN_ADDR_RTX} and either set
@en @code{RTX_FRAME_RELATED_P} on the prologue insns if you use RTL for the
@en prologue, or call @code{dwarf2out_def_cfa} and @code{dwarf2out_reg_save}
@en as appropriate from @code{TARGET_ASM_FUNCTION_PROLOGUE} if you don't.
要支持可选的调用帧调试信息，
你必须还要定义@code{INCOMING_RETURN_ADDR_RTX}，并如果在序言中使用RTL，
则设置@code{RTX_FRAME_RELATED_P}，或者如果没有使用RTL，
则从@code{TARGET_ASM_FUNCTION_PROLOGUE}中调用@code{dwarf2out_def_cfa}
和@code{dwarf2out_reg_save}。
@end defmac

@defmac DWARF2_FRAME_INFO
Define this macro to a nonzero value if GCC should always output
Dwarf 2 frame information.  If @code{TARGET_EXCEPT_UNWIND_INFO}
(@pxref{Exception Region Output}) returns @code{UI_DWARF2}, and
exceptions are enabled, GCC will output this information not matter
how you define @code{DWARF2_FRAME_INFO}.
@end defmac

@deftypefn {Target Hook} {enum unwind_info_type} TARGET_DEBUG_UNWIND_INFO (void)
This hook defines the mechanism that will be used for describing frame
unwind information to the debugger.  Normally the hook will return
@code{UI_DWARF2} if DWARF 2 debug information is enabled, and
return @code{UI_NONE} otherwise.

A target may return @code{UI_DWARF2} even when DWARF 2 debug information
is disabled in order to always output DWARF 2 frame information.

A target may return @code{UI_TARGET} if it has ABI specified unwind tables.
This will suppress generation of the normal debug frame unwind information.
@end deftypefn

@defmac DWARF2_ASM_LINE_DEBUG_INFO
@en Define this macro to be a nonzero value if the assembler can generate Dwarf 2
@en line debug info sections.  This will result in much more compact line number
@en tables, and hence is desirable if it works.
定义该宏为非0值，如果汇编器能够生成Dwarf2行调试信息section。
@end defmac

@deftypevr {Target Hook} bool TARGET_WANT_DEBUG_PUB_SECTIONS
True if the @code{.debug_pubtypes} and @code{.debug_pubnames} sections should be emitted.  These sections are not used on most platforms, and in particular GDB does not use them.
@end deftypevr

@defmac ASM_OUTPUT_DWARF_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})
@en A C statement to issue assembly directives that create a difference
@en @var{lab1} minus @var{lab2}, using an integer of the given @var{size}.
一条C语句，来输出汇编伪指令，
以创建一个@var{lab1}减去@var{lab2}的差，使用给定的@var{size}。
@end defmac

@defmac ASM_OUTPUT_DWARF_VMS_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})
A C statement to issue assembly directives that create a difference
between the two given labels in system defined units, e.g. instruction
slots on IA64 VMS, using an integer of the given size.
@end defmac

@defmac ASM_OUTPUT_DWARF_OFFSET (@var{stream}, @var{size}, @var{label}, @var{section})
@en A C statement to issue assembly directives that create a
@en section-relative reference to the given @var{label}, using an integer of the
@en given @var{size}.  The label is known to be defined in the given @var{section}.
一条C语句，来输出汇编伪指令，
以创建一个相对的@var{section}的给定@var{label}的引用，
使用给定的@var{size}。@var{label}为在给定@var{section}中定义的@var{label}。
@end defmac

@defmac ASM_OUTPUT_DWARF_PCREL (@var{stream}, @var{size}, @var{label})
@en A C statement to issue assembly directives that create a self-relative
@en reference to the given @var{label}, using an integer of the given @var{size}.
一条C语句，来输出汇编伪指令，
以创建一个给定@var{label}的引用，使用给定的@var{size}。
@end defmac

@defmac ASM_OUTPUT_DWARF_TABLE_REF (@var{label})
A C statement to issue assembly directives that create a reference to
the DWARF table identifier @var{label} from the current section.  This
is used on some systems to avoid garbage collecting a DWARF table which
is referenced by a function.
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_DWARF_DTPREL (FILE *@var{file}, int @var{size}, rtx @var{x})
@en If defined, this target hook is a function which outputs a DTP-relative
@en reference to the given TLS symbol of the specified size.
如果定义，该target钩子为一个函数，其输出一个相对DTP的引用，对给定的TLS符号。
@end deftypefn

@defmac PUT_SDB_@dots{}
@en Define these macros to override the assembler syntax for the special
@en SDB assembler directives.  See @file{sdbout.c} for a list of these
@en macros and their arguments.  If the standard syntax is used, you need
@en not define them yourself.
定义这些宏来覆盖汇编语法，为特定的SDB汇编伪指令。
参见@file{sdbout.c}，关于这些宏和它们的参数的列表。
如果使用标准语法，你不需要定义它们。
@end defmac

@defmac SDB_DELIM
@en Some assemblers do not support a semicolon as a delimiter, even between
@en SDB assembler directives.  In that case, define this macro to be the
@en delimiter to use (usually @samp{\n}).  It is not necessary to define
@en a new set of @code{PUT_SDB_@var{op}} macros if this is the only change
@en required.
一些汇编器不支持分号作为分隔符，即使在SDB汇编伪指令之间。
这种情况下，定义该宏为要使用的分隔符（通常为@samp{\n}）。
如果只需要改变该宏，则不需要定义新的@code{PUT_SDB_@var{op}}宏集合。
@end defmac

@defmac SDB_ALLOW_UNKNOWN_REFERENCES
@en Define this macro to allow references to unknown structure,
@en union, or enumeration tags to be emitted.  Standard COFF does not
@en allow handling of unknown references, MIPS ECOFF has support for
@en it.
定义该宏以允许对未知结构体，联合体和枚举标记的引用，被输出。
标准的COFF不允许处理未知的引用，MIPS ECOFF支持该特定。
@end defmac

@defmac SDB_ALLOW_FORWARD_REFERENCES
@en Define this macro to allow references to structure, union, or
@en enumeration tags that have not yet been seen to be handled.  Some
@en assemblers choke if forward tags are used, while some require it.
定义该宏以允许对未遇到的结构体，联合体和枚举标记的引用，被输出。
一些汇编器对此会出错。
@end defmac

@defmac SDB_OUTPUT_SOURCE_LINE (@var{stream}, @var{line})
@en A C statement to output SDB debugging information before code for line
@en number @var{line} of the current source file to the stdio stream
@en @var{stream}.  The default is to emit an @code{.ln} directive.
一条C语句，输出当前源文件的行号的SDB调试信息在代码前。
缺省为输出一个@code{.ln}伪指令。
@end defmac

@need 2000
@en @node VMS Debug
@en @subsection Macros for VMS Debug Format
@node VMS Debug
@subsection 用于VMS调试格式的宏

@c prevent bad page break with this line
@en Here are macros for VMS debug format.
这是用于VMS调试格式的宏。

@defmac VMS_DEBUGGING_INFO
@en Define this macro if GCC should produce debugging output for VMS
@en in response to the @option{-g} option.  The default behavior for VMS
@en is to generate minimal debug info for a traceback in the absence of
@en @option{-g} unless explicitly overridden with @option{-g0}.  This
@en behavior is controlled by @code{TARGET_OPTION_OPTIMIZATION} and
@en @code{TARGET_OPTION_OVERRIDE}.
定义该宏，如果GCC应该为@option{-g}选项产生VMS调试输出。
VMS的缺省行为是在没有@option{-g}时，生成可以回溯的最少调试信息，
除非使用@option{-g0}显示的覆盖。
该行为由@code{TARGET_OPTION_OPTIMIZATION}和@code{TARGET_OPTION_OVERRIDE}控制。
@end defmac

@en @node Floating Point
@en @section Cross Compilation and Floating Point
@node Floating Point
@section 交叉编译和浮点
@cindex cross compilation and floating point
@cindex floating point and cross compilation

@en While all modern machines use twos-complement representation for integers,
@en there are a variety of representations for floating point numbers.  This
@en means that in a cross-compiler the representation of floating point numbers
@en in the compiled program may be different from that used in the machine
@en doing the compilation.
虽然所有现代机器都使用二进制补码来表示整数，但对于浮点数却有不同的表示。
这意味着在交叉编译器中，
被编译的程序中的浮点数的表示可能与执行编译的机器上的表示不相同。

@en Because different representation systems may offer different amounts of
@en range and precision, all floating point constants must be represented in
@en the target machine's format.  Therefore, the cross compiler cannot
@en safely use the host machine's floating point arithmetic; it must emulate
@en the target's arithmetic.  To ensure consistency, GCC always uses
@en emulation to work with floating point values, even when the host and
@en target floating point formats are identical.
因为不同的表示方式可能会提供不同的取值范围和精度，
所以所有的浮点常量必须被表示成target机器的格式。
因此，交叉编译器不能使用host机器的浮点算术；其必须模拟target的算术运算。
为了确保一致性，GCC总是使用模拟方式来处理浮点值，
即使host和target的浮点格式相同。

@en The following macros are provided by @file{real.h} for the compiler to
@en use.  All parts of the compiler which generate or optimize
@en floating-point calculations must use these macros.  They may evaluate
@en their operands more than once, so operands must not have side effects.
下列宏由@file{real.h}提供给编译器使用。
编译器的生成或者优化浮点计算的所有部分必须使用这些宏。
它们可能会计算操作数多次，所以操作数一定不要有副作用。

@defmac REAL_VALUE_TYPE
@en The C data type to be used to hold a floating point value in the target
@en machine's format.  Typically this is a @code{struct} containing an
@en array of @code{HOST_WIDE_INT}, but all code should treat it as an opaque
@en quantity.
C数据类型，用于存放target机器格式的浮点值。
通常为一个包含@code{HOST_WIDE_INT}型数组的结构体，
但是所有的代码应该将其作为不透明的量。
@end defmac

@deftypefn Macro int REAL_VALUES_EQUAL (REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})
@en Compares for equality the two values, @var{x} and @var{y}.  If the target
@en floating point format supports negative zeroes and/or NaNs,
@en @samp{REAL_VALUES_EQUAL (-0.0, 0.0)} is true, and
@en @samp{REAL_VALUES_EQUAL (NaN, NaN)} is false.
比较两个值是否相等，@var{x}和@var{y}。如果target浮点格式支持负0和/或NaN，
则@samp{REAL_VALUES_EQUAL (-0.0, 0.0)} 为真, 
@samp{REAL_VALUES_EQUAL (NaN, NaN)}为假。
@end deftypefn

@deftypefn Macro int REAL_VALUES_LESS (REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})
@en Tests whether @var{x} is less than @var{y}.
测试@var{x}是否小于@var{y}。
@end deftypefn

@deftypefn Macro HOST_WIDE_INT REAL_VALUE_FIX (REAL_VALUE_TYPE @var{x})
@en Truncates @var{x} to a signed integer, rounding toward zero.
将@var{x}截取为有符号整数，向0舍入。
@end deftypefn

@deftypefn Macro {unsigned HOST_WIDE_INT} REAL_VALUE_UNSIGNED_FIX (REAL_VALUE_TYPE @var{x})
@en Truncates @var{x} to an unsigned integer, rounding toward zero.  If
@en @var{x} is negative, returns zero.
将@var{x}截取为无符号整数，向0舍入。如果@var{x}为负，则返回0。
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_ATOF (const char *@var{string}, enum machine_mode @var{mode})
@en Converts @var{string} into a floating point number in the target machine's
@en representation for mode @var{mode}.  This routine can handle both
@en decimal and hexadecimal floating point constants, using the syntax
@en defined by the C language for both.
将@var{string}转换为target机器模式@var{mode}所表示的浮点数。
该程序可以处理十进制和十六进制的浮点常量，使用C语言定义的语法。
@end deftypefn

@deftypefn Macro int REAL_VALUE_NEGATIVE (REAL_VALUE_TYPE @var{x})
@en Returns 1 if @var{x} is negative (including negative zero), 0 otherwise.
如果@var{x}为负数（包括负零），返回1，否则0。
@end deftypefn

@deftypefn Macro int REAL_VALUE_ISINF (REAL_VALUE_TYPE @var{x})
@en Determines whether @var{x} represents infinity (positive or negative).
确定@var{x}是否表示无穷（正的或负的）。
@end deftypefn

@deftypefn Macro int REAL_VALUE_ISNAN (REAL_VALUE_TYPE @var{x})
@en Determines whether @var{x} represents a ``NaN'' (not-a-number).
确定@var{x}是否表示“NaN” (not-a-number)。
@end deftypefn

@deftypefn Macro void REAL_ARITHMETIC (REAL_VALUE_TYPE @var{output}, enum tree_code @var{code}, REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})
@en Calculates an arithmetic operation on the two floating point values
@en @var{x} and @var{y}, storing the result in @var{output} (which must be a
@en variable).
计算一个算术运算对浮点值@var{x}和@var{y}，将结果存到@var{output}（其必须为一个变量）中。

@en The operation to be performed is specified by @var{code}.  Only the
@en following codes are supported: @code{PLUS_EXPR}, @code{MINUS_EXPR},
@en @code{MULT_EXPR}, @code{RDIV_EXPR}, @code{MAX_EXPR}, @code{MIN_EXPR}.
要执行的运算由@var{code}指定。只有下列代码被支持：@code{PLUS_EXPR}, @code{MINUS_EXPR}, @code{MULT_EXPR}, @code{RDIV_EXPR}, @code{MAX_EXPR}, @code{MIN_EXPR}。

@en If @code{REAL_ARITHMETIC} is asked to evaluate division by zero and the
@en target's floating point format cannot represent infinity, it will call
@en @code{abort}.  Callers should check for this situation first, using
@en @code{MODE_HAS_INFINITIES}.  @xref{Storage Layout}.
如果@code{REAL_ARITHMETIC}被要求计算除0，并且target的浮点格式不能表示无穷，则会调用@code{abort}。调用者应该首先检查这种情况，使用@code{MODE_HAS_INFINITIES}。@xref{Storage Layout}。
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_NEGATE (REAL_VALUE_TYPE @var{x})
@en Returns the negative of the floating point value @var{x}.
返回浮点值@var{x}的负数。
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_ABS (REAL_VALUE_TYPE @var{x})
@en Returns the absolute value of @var{x}.
返回@var{x}的绝对值。
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_TRUNCATE (REAL_VALUE_TYPE @var{mode}, enum machine_mode @var{x})
@en Truncates the floating point value @var{x} to fit in @var{mode}.  The
@en return value is still a full-size @code{REAL_VALUE_TYPE}, but it has an
@en appropriate bit pattern to be output as a floating constant whose
@en precision accords with mode @var{mode}.
将浮点值@var{x}截取为适合@var{mode}。返回值仍然是@code{REAL_VALUE_TYPE}，但是具有一个合适的位模式，其精度根据模式@var{mode}来输出浮点常量。
@end deftypefn

@deftypefn Macro void REAL_VALUE_TO_INT (HOST_WIDE_INT @var{low}, HOST_WIDE_INT @var{high}, REAL_VALUE_TYPE @var{x})
@en Converts a floating point value @var{x} into a double-precision integer
@en which is then stored into @var{low} and @var{high}.  If the value is not
@en integral, it is truncated.
转换浮点值@var{x}为双精度整数，存储到@var{low}和@var{high}中。如果值不是整形的，则进行截取。
@end deftypefn

@deftypefn Macro void REAL_VALUE_FROM_INT (REAL_VALUE_TYPE @var{x}, HOST_WIDE_INT @var{low}, HOST_WIDE_INT @var{high}, enum machine_mode @var{mode})
@en Converts a double-precision integer found in @var{low} and @var{high},
@en into a floating point value which is then stored into @var{x}.  The
@en value is truncated to fit in mode @var{mode}.
转换在@var{low}和@var{high}中的一个双精度整数为浮点值，其被存储在@var{x}中。值被截取以适合机器模式@var{mode}。
@end deftypefn

@en @node Mode Switching
@en @section Mode Switching Instructions
@node Mode Switching
@section 机器模式切换指令
@cindex mode switching
@en The following macros control mode switching optimizations:
下列的宏用来控制模式切换优化：

@defmac OPTIMIZE_MODE_SWITCHING (@var{entity})
@en Define this macro if the port needs extra instructions inserted for mode
@en switching in an optimizing compilation.
定义该宏，如果在优化编译中，port需要为机器模式切换插入额外的指令。

@en For an example, the SH4 can perform both single and double precision
@en floating point operations, but to perform a single precision operation,
@en the FPSCR PR bit has to be cleared, while for a double precision
@en operation, this bit has to be set.  Changing the PR bit requires a general
@en purpose register as a scratch register, hence these FPSCR sets have to
@en be inserted before reload, i.e.@: you can't put this into instruction emitting
@en or @code{TARGET_MACHINE_DEPENDENT_REORG}.
例如，SH4可以执行单精度和双精度的浮点运算，但是执行单精度运算时，
必须清除FPSCR PR位，而执行双精度运算时，必须设置该位。
改变PR位需要一个通用寄存器来作为草稿寄存器，
因此这些FPSCR设置必须在重载之前被插入，
即你不能将它放在指令输出或者@code{TARGET_MACHINE_DEPENDENT_REORG}阶段。

@en You can have multiple entities that are mode-switched, and select at run time
@en which entities actually need it.  @code{OPTIMIZE_MODE_SWITCHING} should
@en return nonzero for any @var{entity} that needs mode-switching.
@en If you define this macro, you also have to define
@en @code{NUM_MODES_FOR_MODE_SWITCHING}, @code{MODE_NEEDED},
@en @code{MODE_PRIORITY_TO_MODE} and @code{EMIT_MODE_SET}.
@en @code{MODE_AFTER}, @code{MODE_ENTRY}, and @code{MODE_EXIT}
@en are optional.
你可以具有多个具有模式切换的实体，并且在运行时选择哪些实体实际需要。
对于任何需要模式切换的@var{entity}，@code{OPTIMIZE_MODE_SWITCHING}应该返回非零。
如果你定义了该宏，你还必须定义@code{NUM_MODES_FOR_MODE_SWITCHING}, 
@code{MODE_NEEDED}, @code{MODE_PRIORITY_TO_MODE}和@code{EMIT_MODE_SET}。
@code{MODE_AFTER}, @code{MODE_ENTRY}和@code{MODE_EXIT}是可选的。
@end defmac

@defmac NUM_MODES_FOR_MODE_SWITCHING
@en If you define @code{OPTIMIZE_MODE_SWITCHING}, you have to define this as
@en initializer for an array of integers.  Each initializer element
@en N refers to an entity that needs mode switching, and specifies the number
@en of different modes that might need to be set for this entity.
@en The position of the initializer in the initializer---starting counting at
@en zero---determines the integer that is used to refer to the mode-switched
@en entity in question.
@en In macros that take mode arguments / yield a mode result, modes are
@en represented as numbers 0 @dots{} N @minus{} 1.  N is used to specify that no mode
@en switch is needed / supplied.
如果你定义了@code{OPTIMIZE_MODE_SWITCHING}，你必须定义该宏，
作为整数数组的初始化。每个初始化元素N引用一个需要模式切换的实体，
并且指定了该实体可能需要被设置的不同模式的数目。
初始化的位置——起始于0——确定了被用于引用有问题的模式切换实体的整数。
@end defmac

@defmac MODE_NEEDED (@var{entity}, @var{insn})
@en @var{entity} is an integer specifying a mode-switched entity.  If
@en @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to
@en return an integer value not larger than the corresponding element in
@en @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must
@en be switched into prior to the execution of @var{insn}.
@var{entity}为一个整数指定了模式切换的实体。
如果定义了@code{OPTIMIZE_MODE_SWITCHING}，
则必须定义该宏来返回一个不大于在@code{NUM_MODES_FOR_MODE_SWITCHING}
中相应元素的整数值，来指示@var{entity}在执行@var{insn}前必须被切换成的模式。
@end defmac

@defmac MODE_AFTER (@var{mode}, @var{insn})
@en If this macro is defined, it is evaluated for every @var{insn} during
@en mode switching.  It determines the mode that an insn results in (if
@en different from the incoming mode).
如果定义该宏，其在模式切换过程中对于每个@var{insn}进行求值。
其确定一个insn的结果时的模式（如果与输入时的模式不同）。
@end defmac

@defmac MODE_ENTRY (@var{entity})
@en If this macro is defined, it is evaluated for every @var{entity} that needs
@en mode switching.  It should evaluate to an integer, which is a mode that
@en @var{entity} is assumed to be switched to at function entry.  If @code{MODE_ENTRY}
@en is defined then @code{MODE_EXIT} must be defined.
如果定义该宏，其对每个需要模式切换的@var{entity}进行求值。
结果为一个整数，为@var{entity}在函数入口处被假定切换成的模式。
如果定义了@code{MODE_ENTRY}，则必须定义@code{MODE_EXIT}。
@end defmac

@defmac MODE_EXIT (@var{entity})
@en If this macro is defined, it is evaluated for every @var{entity} that needs
@en mode switching.  It should evaluate to an integer, which is a mode that
@en @var{entity} is assumed to be switched to at function exit.  If @code{MODE_EXIT}
@en is defined then @code{MODE_ENTRY} must be defined.
如果定义该宏，其对每个需要模式切换的实体进行求值。结果为一个整数，
为实体在函数出口处被假定切换成的模式。如果定义了@code{MODE_EXIT}，
则必须定义@code{MODE_ENTRY}。
@end defmac

@defmac MODE_PRIORITY_TO_MODE (@var{entity}, @var{n})
@en This macro specifies the order in which modes for @var{entity} are processed.
@en 0 is the highest priority, @code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1} the
@en lowest.  The value of the macro should be an integer designating a mode
@en for @var{entity}.  For any fixed @var{entity}, @code{mode_priority_to_mode}
@en (@var{entity}, @var{n}) shall be a bijection in 0 @dots{}
@en @code{num_modes_for_mode_switching[@var{entity}] - 1}.
该宏指定了被处理的@var{entity}的模式顺序。0为最高优先级，
@code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1}为最低。
宏的值应该为一个整数，表示@var{entity}的一个模式。对于任何固定的@var{entity}，
@code{mode_priority_to_mode}(@var{entity}, @var{n}))应该为0@dots{}
@code{num_modes_for_mode_switching[@var{entity}] - 1}之间的双向影射。
@end defmac

@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{hard_regs_live})
@en Generate one or more insns to set @var{entity} to @var{mode}.
@en @var{hard_reg_live} is the set of hard registers live at the point where
@en the insn(s) are to be inserted.
生成一个或多个insn来将@var{entity}设为@var{mode}。
@var{hard_reg_live}是在insn被插入点处的硬件寄存器活跃集。
@end defmac

@en @node Target Attributes
@en @section Defining target-specific uses of @code{__attribute__}
@node Target Attributes
@section 定义目标机特定的@code{__attribute__}用法
@cindex target attributes
@cindex machine attributes
@cindex attributes, target-specific

@en Target-specific attributes may be defined for functions, data and types.
@en These are described using the following target hooks; they also need to
@en be documented in @file{extend.texi}.
可以为函数，数据和类型定义target特定的属性。
这些使用下列target钩子来描述；它们还需要在@file{extend.texi}中被记述。

@deftypevr {Target Hook} {const struct attribute_spec *} TARGET_ATTRIBUTE_TABLE
@en If defined, this target hook points to an array of @samp{struct
@en attribute_spec} (defined in @file{tree.h}) specifying the machine
@en specific attributes for this target and some of the restrictions on the
@en entities to which these attributes are applied and the arguments they
@en take.
如果定义，
该目标钩子指向一个@samp{struct attribute_spec} (在@file{tree.h}中定义) 数组，
用来指定该目标的机器特定的属性，
以及这些属性被应用到的实体和它们接受的参数的一些限制。
@end deftypevr

@deftypefn {Target Hook} bool TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P (const_tree @var{name})
@en If defined, this target hook is a function which returns true if the
@en machine-specific attribute named @var{name} expects an identifier
@en given as its first argument to be passed on as a plain identifier, not
@en subjected to name lookup.  If this is not defined, the default is
@en false for all machine-specific attributes.
@end deftypefn

@deftypefn {Target Hook} int TARGET_COMP_TYPE_ATTRIBUTES (const_tree @var{type1}, const_tree @var{type2})
@en If defined, this target hook is a function which returns zero if the attributes on
@en @var{type1} and @var{type2} are incompatible, one if they are compatible,
@en and two if they are nearly compatible (which causes a warning to be
@en generated).  If this is not defined, machine-specific attributes are
@en supposed always to be compatible.
如果定义，该目标钩子为一个函数，
如果@var{type1}和@var{type2}的属性不匹配则返回0，匹配则返回1，
几乎匹配则返回2（这将产生一个warning）。如果没有被定义，
则机器特定的属性总被假定为匹配的。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SET_DEFAULT_TYPE_ATTRIBUTES (tree @var{type})
@en If defined, this target hook is a function which assigns default attributes to
@en the newly defined @var{type}.
如果定义，该目标钩子为一个函数，其将缺省属性赋予新定义的类型@var{type}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_MERGE_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})
@en Define this target hook if the merging of type attributes needs special
@en handling.  If defined, the result is a list of the combined
@en @code{TYPE_ATTRIBUTES} of @var{type1} and @var{type2}.  It is assumed
@en that @code{comptypes} has already been called and returned 1.  This
@en function may call @code{merge_attributes} to handle machine-independent
@en merging.
定义该target钩子，如果合并类型属性需要进行特殊的处理。
如果定义，则结果为@var{type1}和@var{type2}的组合@code{TYPE_ATTRIBUTES}列表。
其假设@code{comptypes}总是被调用并返回1。
该函数可以调用@code{merge_attributes}来处理机器无关的合并。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_MERGE_DECL_ATTRIBUTES (tree @var{olddecl}, tree @var{newdecl})
@en Define this target hook if the merging of decl attributes needs special
@en handling.  If defined, the result is a list of the combined
@en @code{DECL_ATTRIBUTES} of @var{olddecl} and @var{newdecl}.
@en @var{newdecl} is a duplicate declaration of @var{olddecl}.  Examples of
@en when this is needed are when one attribute overrides another, or when an
@en attribute is nullified by a subsequent definition.  This function may
@en call @code{merge_attributes} to handle machine-independent merging.
定义该target钩子，如果合并decl属性需要进行特殊的处理。如果定义，
则结果为@var{olddecl}和@var{newdecl}的组合@code{DECL_ATTRIBUTES}列表。
@var{newdecl}为@var{olddecl}的拷贝。这样的例子是当一个属性覆盖另一个，
或者当一个属性被后续的属性置空的情况。
该函数可以调用@code{merge_attributes}来处理机器无关的合并。

@findex TARGET_DLLIMPORT_DECL_ATTRIBUTES
@en If the only target-specific handling you require is @samp{dllimport}
@en for Microsoft Windows targets, you should define the macro
@en @code{TARGET_DLLIMPORT_DECL_ATTRIBUTES} to @code{1}.  The compiler
@en will then define a function called
@en @code{merge_dllimport_decl_attributes} which can then be defined as
@en the expansion of @code{TARGET_MERGE_DECL_ATTRIBUTES}.  You can also
@en add @code{handle_dll_attribute} in the attribute table for your port
@en to perform initial processing of the @samp{dllimport} and
@en @samp{dllexport} attributes.  This is done in @file{i386/cygwin.h} and
@en @file{i386/i386.c}, for example.
如果唯一需要target特定的处理是Microsoft Windows target的@samp{dllimport}，
则你应该定义宏@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}为@code{1}。
然后编译器将会定义一个叫做@code{merge_dllimport_decl_attributes}的函数，
其可以被定义为@code{TARGET_MERGE_DECL_ATTRIBUTES}的扩展。
你还可以为你的port在属性表中增加@code{handle_dll_attribute}，
来执行@samp{dllimport}和@samp{dllexport}属性的初始化处理。
例如，在@file{i386/cygwin.h}和@file{i386/i386.c}中。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VALID_DLLIMPORT_ATTRIBUTE_P (const_tree @var{decl})
@en @var{decl} is a variable or function with @code{__attribute__((dllimport))} specified.  Use this hook if the target needs to add extra validation checks to @code{handle_dll_attribute}.
@var{decl}为一个指定为@code{__attribute__((dllimport))}的变量或者函数。
使用该钩子，如果target需要给@code{handle_dll_attribute}增加额外的有效性检查。
@end deftypefn

@defmac TARGET_DECLSPEC
@en Define this macro to a nonzero value if you want to treat
@en @code{__declspec(X)} as equivalent to @code{__attribute((X))}.  By
@en default, this behavior is enabled only for targets that define
@en @code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}.  The current implementation
@en of @code{__declspec} is via a built-in macro, but you should not rely
@en on this implementation detail.
定义该宏为非零，
如果你想将@code{__declspec(X)}与@code{__attribute((X))}等同对待。
缺省下，只有在定义了@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}的target上才可以。
目前对于@code{__declspec}的实现是通过一个内建的宏，但是你不应该依赖于实现细节。
@end defmac

@deftypefn {Target Hook} void TARGET_INSERT_ATTRIBUTES (tree @var{node}, tree *@var{attr_ptr})
@en Define this target hook if you want to be able to add attributes to a decl
@en when it is being created.  This is normally useful for back ends which
@en wish to implement a pragma by using the attributes which correspond to
@en the pragma's effect.  The @var{node} argument is the decl which is being
@en created.  The @var{attr_ptr} argument is a pointer to the attribute list
@en for this decl.  The list itself should not be modified, since it may be
@en shared with other decls, but attributes may be chained on the head of
@en the list and @code{*@var{attr_ptr}} modified to point to the new
@en attributes, or a copy of the list may be made if further changes are
@en needed.
定义该target钩子，如果你想在decl被创建时，能够为其增加属性。
这在后端想要实现一个pragma，并且用到与pragma相关的属性的时候，
通常很有用。参数@var{node}是正在创建的decl。
参数@var{attr_ptr}是指向该decl的属性列表的指针。不要修改列表本身，
因为其可能与其它decl共享，但是可以将属性链接到列表的头部，
并且修改@code{*@var{attr_ptr}}以指向新的属性，或者如果需要进一步的修改，
创建一个列表的拷贝。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P (const_tree @var{fndecl})
@cindex inlining
@en This target hook returns @code{true} if it is ok to inline @var{fndecl}
@en into the current function, despite its having target-specific
@en attributes, @code{false} otherwise.  By default, if a function has a
@en target specific attribute attached to it, it will not be inlined.
该target钩子返回@code{true}，如果可以将@var{fndecl}内联到当前函数中，
而不管它具有的target特定属性，否则为@code{false}。
缺省下，如果函数具有一个target特定属性，则不会被内联。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_OPTION_VALID_ATTRIBUTE_P (tree @var{fndecl}, tree @var{name}, tree @var{args}, int @var{flags})
This hook is called to parse the @code{attribute(option("..."))}, and
it allows the function to set different target machine compile time
options for the current function that might be different than the
options specified on the command line.  The hook should return
@code{true} if the options are valid.

The hook should set the @var{DECL_FUNCTION_SPECIFIC_TARGET} field in
the function declaration to hold a pointer to a target specific
@var{struct cl_target_option} structure.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_SAVE (struct cl_target_option *@var{ptr})
This hook is called to save any additional target specific information
in the @var{struct cl_target_option} structure for function specific
options.
@xref{Option file format}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_RESTORE (struct cl_target_option *@var{ptr})
This hook is called to restore any additional target specific
information in the @var{struct cl_target_option} structure for
function specific options.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_PRINT (FILE *@var{file}, int @var{indent}, struct cl_target_option *@var{ptr})
This hook is called to print any additional target specific
information in the @var{struct cl_target_option} structure for
function specific options.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_OPTION_PRAGMA_PARSE (tree @var{args}, tree @var{pop_target})
This target hook parses the options for @code{#pragma GCC option} to
set the machine specific options for functions that occur later in the
input stream.  The options should be the same as handled by the
@code{TARGET_OPTION_VALID_ATTRIBUTE_P} hook.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_OVERRIDE (void)
Sometimes certain combinations of command options do not make sense on
a particular target machine.  You can override the hook
@code{TARGET_OPTION_OVERRIDE} to take account of this.  This hooks is called
once just after all the command options have been parsed.

Don't use this hook to turn on various extra optimizations for
@option{-O}.  That is what @code{TARGET_OPTION_OPTIMIZATION} is for.

If you need to do something whenever the optimization level is
changed via the optimize attribute or pragma, see
@code{TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE}
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CAN_INLINE_P (tree @var{caller}, tree @var{callee})
This target hook returns @code{false} if the @var{caller} function
cannot inline @var{callee}, based on target specific information.  By
default, inlining is not allowed if the callee function has function
specific target options and the caller does not use the same options.
@end deftypefn

@node Emulated TLS
@section Emulating TLS
@cindex Emulated TLS

For targets whose psABI does not provide Thread Local Storage via
specific relocations and instruction sequences, an emulation layer is
used.  A set of target hooks allows this emulation layer to be
configured for the requirements of a particular target.  For instance
the psABI may in fact specify TLS support in terms of an emulation
layer.

The emulation layer works by creating a control object for every TLS
object.  To access the TLS object, a lookup function is provided
which, when given the address of the control object, will return the
address of the current thread's instance of the TLS object.

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_GET_ADDRESS
Contains the name of the helper function that uses a TLS control
object to locate a TLS instance.  The default causes libgcc's
emulated TLS helper function to be used.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_REGISTER_COMMON
Contains the name of the helper function that should be used at
program startup to register TLS objects that are implicitly
initialized to zero.  If this is @code{NULL}, all TLS objects will
have explicit initializers.  The default causes libgcc's emulated TLS
registration function to be used.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_SECTION
Contains the name of the section in which TLS control variables should
be placed.  The default of @code{NULL} allows these to be placed in
any section.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_SECTION
Contains the name of the section in which TLS initializers should be
placed.  The default of @code{NULL} allows these to be placed in any
section.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_PREFIX
Contains the prefix to be prepended to TLS control variable names.
The default of @code{NULL} uses a target-specific prefix.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_PREFIX
Contains the prefix to be prepended to TLS initializer objects.  The
default of @code{NULL} uses a target-specific prefix.
@end deftypevr

@deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_FIELDS (tree @var{type}, tree *@var{name})
Specifies a function that generates the FIELD_DECLs for a TLS control
object type.  @var{type} is the RECORD_TYPE the fields are for and
@var{name} should be filled with the structure tag, if the default of
@code{__emutls_object} is unsuitable.  The default creates a type suitable
for libgcc's emulated TLS function.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_INIT (tree @var{var}, tree @var{decl}, tree @var{tmpl_addr})
Specifies a function that generates the CONSTRUCTOR to initialize a
TLS control object.  @var{var} is the TLS control object, @var{decl}
is the TLS object and @var{tmpl_addr} is the address of the
initializer.  The default initializes libgcc's emulated TLS control object.
@end deftypefn

@deftypevr {Target Hook} bool TARGET_EMUTLS_VAR_ALIGN_FIXED
Specifies whether the alignment of TLS control variable objects is
fixed and should not be increased as some backends may do to optimize
single objects.  The default is false.
@end deftypevr

@deftypevr {Target Hook} bool TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS
Specifies whether a DWARF @code{DW_OP_form_tls_address} location descriptor
may be used to describe emulated TLS control objects.
@end deftypevr

@en @node MIPS Coprocessors
@en @section Defining coprocessor specifics for MIPS targets.
@node MIPS Coprocessors
@section 定义MIPS target的协处理器的规范
@cindex MIPS coprocessor-definition macros

@en The MIPS specification allows MIPS implementations to have as many as 4
@en coprocessors, each with as many as 32 private registers.  GCC supports
@en accessing these registers and transferring values between the registers
@en and memory using asm-ized variables.  For example:
MIPS规范允许MIPS的实现最多具有4个协处理器，其中每个最多具有32个私有寄存器。
GCC支持使用汇编形式的变量对这些寄存器的访问，寄存器以及内存间的传值。例如：

@smallexample
  register unsigned int cp0count asm ("c0r1");
  unsigned int d;

  d = cp0count + 3;
@end smallexample

@en (``c0r1'' is the default name of register 1 in coprocessor 0; alternate
@en names may be added as described below, or the default names may be
@en overridden entirely in @code{SUBTARGET_CONDITIONAL_REGISTER_USAGE}.)
(“c0r1”是协处理器0的寄存器1的缺省名；可以按照下面的描述来增加可选名字，
或者可以通过@code{SUBTARGET_CONDITIONAL_REGISTER_USAGE}来覆写全部的缺省名字。)

@en Coprocessor registers are assumed to be epilogue-used; sets to them will
@en be preserved even if it does not appear that the register is used again
@en later in the function.
协处理器寄存器被假设为epilogue-used；对它们的赋值将被保存，
即使在函数中的后面不会再使用该寄存器。

@en Another note: according to the MIPS spec, coprocessor 1 (if present) is
@en the FPU@.  One accesses COP1 registers through standard mips
@en floating-point support; they are not included in this mechanism.
另一个需要注意的是：根据MIPS spec，协处理器1（如果存在）为FPU。
标准mips浮点支持的对COP1寄存器的访问，不包含在这个机制中。

@en There is one macro used in defining the MIPS coprocessor interface which
@en you may want to override in subtargets; it is described below.
下面描述的一个宏，用于定义MIPS协处理器接口，
可能在子目标（subtarget）中需要被覆写。

@defmac ALL_COP_ADDITIONAL_REGISTER_NAMES
@en A comma-separated list (with leading comma) of pairs describing the
@en alternate names of coprocessor registers.  The format of each entry should be
一个逗号分隔的列表（起始于逗号），是用于描述可选的协处理器寄存器的名字对。
每项的格式应该为
@smallexample
@{ @var{alternatename}, @var{register_number}@}
@end smallexample
Default: empty.
缺省情况: 空
@end defmac

@en @node PCH Target
@en @section Parameters for Precompiled Header Validity Checking
@node PCH Target
@section 预编译头文件有效性检查的参数
@cindex parameters, precompiled headers

@deftypefn {Target Hook} {void *} TARGET_GET_PCH_VALIDITY (size_t *@var{sz})
@en This hook returns a pointer to the data needed by
@en @code{TARGET_PCH_VALID_P} and sets
@en @samp{*@var{sz}} to the size of the data in bytes.
该钩子返回@code{TARGET_PCH_VALID_P}所需要的数据，
并且将@samp{*@var{sz}}设为以字节为单位的数据大小。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_PCH_VALID_P (const void *@var{data}, size_t @var{sz})
@en This hook checks whether the options used to create a PCH file are
@en compatible with the current settings.  It returns @code{NULL}
@en if so and a suitable error message if not.  Error messages will
@en be presented to the user and must be localized using @samp{_(@var{msg})}.
该钩子检查用于创建PCH文件的选项是否与现在的设置兼容。
如果是则返回@code{NULL}，否则为一个适当的错误消息。
错误消息将会展现给用户，所以必须使用@samp{_(@var{msg})}来本地化。

@en @var{data} is the data that was returned by @code{TARGET_GET_PCH_VALIDITY}
@en when the PCH file was created and @var{sz} is the size of that data in bytes.
@en It's safe to assume that the data was created by the same version of the
@en compiler, so no format checking is needed.
@var{data}为当PCH文件被创建时，@code{TARGET_GET_PCH_VALIDITY}所返回的数据，
@var{sz}为以字节为单位的数据大小。是可以假设data由同一版本的编译器所创建的，
所以不需要格式检查。

@en The default definition of @code{default_pch_valid_p} should be
@en suitable for most targets.
@code{default_pch_valid_p}的缺省定义应该适合于大多数target。
@end deftypefn

@deftypefn {Target Hook} const char *TARGET_CHECK_PCH_TARGET_FLAGS (int @var{pch_flags})
@en The default definition of @code{default_pch_valid_p} should be
@en suitable for most targets.
如果该钩子为非空，
则@code{TARGET_PCH_VALID_P}的缺省实现将用它来检查@code{target_flags}的兼容值。
@var{pch_flags}指定了当PCH文件被创建时，@code{target_flags}所具有的值。
返回值与@code{TARGET_PCH_VALID_P}的相同。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_CHECK_PCH_TARGET_FLAGS (int @var{pch_flags})
If this hook is nonnull, the default implementation of
@code{TARGET_PCH_VALID_P} will use it to check for compatible values
of @code{target_flags}.  @var{pch_flags} specifies the value that
@code{target_flags} had when the PCH file was created.  The return
value is the same as for @code{TARGET_PCH_VALID_P}.
@end deftypefn

@en @node C++ ABI
@en @section C++ ABI parameters
@node C++ ABI
@section C++ ABI参数
@cindex parameters, c++ abi

@deftypefn {Target Hook} tree TARGET_CXX_GUARD_TYPE (void)
@en Define this hook to override the integer type used for guard variables.
@en These are used to implement one-time construction of static objects.  The
@en default is long_long_integer_type_node.
定义该钩子来覆盖用于guard变量的整数类型。
这些被用于实现静态对象的一次构建。缺省为long_long_integer_type_node。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_GUARD_MASK_BIT (void)
@en This hook determines how guard variables are used.  It should return
@en @code{false} (the default) if the first byte should be used.  A return value of
@en @code{true} indicates that only the least significant bit should be used.
该钩子确定如何使用guard变量。如果第一个字节应该被使用，
则应该返回@code{false}（缺省）。返回值为@code{true}表明应该使用最低有效位。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_CXX_GET_COOKIE_SIZE (tree @var{type})
@en This hook returns the size of the cookie to use when allocating an array
@en whose elements have the indicated @var{type}.  Assumes that it is already
@en known that a cookie is needed.  The default is
@en @code{max(sizeof (size_t), alignof(type))}, as defined in section 2.7 of the
@en IA64/Generic C++ ABI@.
该钩子返回cookie的大小，其中cookie为当分配一个数组其元素具有@var{type}类型，
所使用的cookie。假设已经知道需要一个cookie。
缺省为@code{max(sizeof (size_t), alignof(type))}，
在2.7节IA64/Generic C++ ABI中定义。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_COOKIE_HAS_SIZE (void)
@en This hook should return @code{true} if the element size should be stored in
@en array cookies.  The default is to return @code{false}.
该钩子应该返回@code{true}，如果元素大小应该被存放在数组cookie中。
缺省为返回@code{false}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_CXX_IMPORT_EXPORT_CLASS (tree @var{type}, int @var{import_export})
@en If defined by a backend this hook allows the decision made to export
@en class @var{type} to be overruled.  Upon entry @var{import_export}
@en will contain 1 if the class is going to be exported, @minus{}1 if it is going
@en to be imported and 0 otherwise.  This function should return the
@en modified value and perform any other actions necessary to support the
@en backend's targeted operating system.
如果后端定义了该钩子，则允许覆盖对导出类@var{type}的决定。
@var{import_export}将包含1，如果类将被导出，@minus{}1如果其将被导入，否则为0.
该函数应该返回修改后的值，并执行其它需要的操作来支持后端的操作系统。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_CDTOR_RETURNS_THIS (void)
@en This hook should return @code{true} if constructors and destructors return
@en the address of the object created/destroyed.  The default is to return
@en @code{false}.
该钩子应该返回@code{true}，如果构造者和析构者返回创建/销毁对象的地址。
缺省为返回@code{false}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_KEY_METHOD_MAY_BE_INLINE (void)
@en This hook returns true if the key method for a class (i.e., the method
@en which, if defined in the current translation unit, causes the virtual
@en table to be emitted) may be an inline function.  Under the standard
@en Itanium C++ ABI the key method may be an inline function so long as
@en the function is not declared inline in the class definition.  Under
@en some variants of the ABI, an inline function can never be the key
@en method.  The default is to return @code{true}.
该钩子返回真，如果类的关键方法（即，如果方法在当前转换单元中定义，
其使得虚拟表被输出）可以为内联函数。对于标准的Itanium C++ ABI，
关键方法可以为内联函数，只要函数不在类定义中声明为内联的。
其它ABI的变体中，内联函数不能为关键方法。缺省为返回@code{true}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY (tree @var{decl})
@en @var{decl} is a virtual table, virtual table table, typeinfo object, or other similar implicit class data object that will be emitted with external linkage in this translation unit.  No ELF visibility has been explicitly specified.  If the target needs to specify a visibility other than that of the containing class, use this hook to set @code{DECL_VISIBILITY} and @code{DECL_VISIBILITY_SPECIFIED}.
@var{decl}为虚拟表，类型信息对象，或其它类似的隐含类数据对象，
其将在该转换单元中作为外部链接被输出。ELF的可视性不会被显示的指定。
如果target需要指定可视性，
可以使用该钩子来设置@code{DECL_VISIBILITY}和@code{DECL_VISIBILITY_SPECIFIED}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT (void)
@en This hook returns true (the default) if virtual tables and other
@en similar implicit class data objects are always COMDAT if they have
@en external linkage.  If this hook returns false, then class data for
@en classes whose virtual table will be emitted in only one translation
@en unit will not be COMDAT.
该钩子返回真（缺省情况）如果虚拟表和其它类似的隐式类数据对象总是为COMDAT，
如果它们具有外部连接。如果该钩子返回假，
则只在一个转换单元中被输出的虚拟表的类的类数据将不是COMDAT。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_LIBRARY_RTTI_COMDAT (void)
@en This hook returns true (the default) if the RTTI information for
@en the basic types which is defined in the C++ runtime should always
@en be COMDAT, false if it should not be COMDAT.
该钩子返回真（缺省情况），
如果在C++运行时定义的基本类型的RTTI信息应该总是为COMDAT，否则为假。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_USE_AEABI_ATEXIT (void)
@en This hook returns true if @code{__aeabi_atexit} (as defined by the ARM EABI)
@en should be used to register static destructors when @option{-fuse-cxa-atexit}
@en is in effect.  The default is to return false to use @code{__cxa_atexit}.
该钩子返回真，
如果@code{__aeabi_atexit}（如被ARM EABI定义）应该用于注册静态析构者，
当@option{-fuse-cxa-atexit}为有效时。缺省是返回假，使用@code{__cxa_atexit}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT (void)
@en This hook returns true if the target @code{atexit} function can be used
@en in the same manner as @code{__cxa_atexit} to register C++ static
@en destructors. This requires that @code{atexit}-registered functions in
@en shared libraries are run in the correct order when the libraries are
@en unloaded. The default is to return false.
该钩子返回真，
如果target的@code{atexit}函数可以跟@code{__cxa_atexit}一样被用于注册静态析构者。
这要求在共享库中@code{atexit}注册的函数要按照正确的顺序运行，当库被卸载时。
缺省为返回假。
@end deftypefn

@deftypefn {Target Hook} void TARGET_CXX_ADJUST_CLASS_AT_DEFINITION (tree @var{type})
@en @var{type} is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just been defined.  Use this hook to make adjustments to the class (eg, tweak visibility or perform any other required target modifications).
@var{type}为一个刚被定义的C++类（即RECORD_TYPE 或 UNION_TYPE）。
使用该钩子来调整类（例如tweak可视性或者执行其它target需要的修改）。
@end deftypefn

@node Named Address Spaces
@section Adding support for named address spaces
@cindex named address spaces

The draft technical report of the ISO/IEC JTC1 S22 WG14 N1275
standards committee, @cite{Programming Languages - C - Extensions to
support embedded processors}, specifies a syntax for embedded
processors to specify alternate address spaces.  You can configure a
GCC port to support section 5.1 of the draft report to add support for
address spaces other than the default address space.  These address
spaces are new keywords that are similar to the @code{volatile} and
@code{const} type attributes.

Pointers to named address spaces can have a different size than
pointers to the generic address space.

For example, the SPU port uses the @code{__ea} address space to refer
to memory in the host processor, rather than memory local to the SPU
processor.  Access to memory in the @code{__ea} address space involves
issuing DMA operations to move data between the host processor and the
local processor memory address space.  Pointers in the @code{__ea}
address space are either 32 bits or 64 bits based on the
@option{-mea32} or @option{-mea64} switches (native SPU pointers are
always 32 bits).

Internally, address spaces are represented as a small integer in the
range 0 to 15 with address space 0 being reserved for the generic
address space.

To register a named address space qualifier keyword with the C front end,
the target may call the @code{c_register_addr_space} routine.  For example,
the SPU port uses the following to declare @code{__ea} as the keyword for
named address space #1:
@smallexample
#define ADDR_SPACE_EA 1
c_register_addr_space ("__ea", ADDR_SPACE_EA);
@end smallexample

@deftypefn {Target Hook} {enum machine_mode} TARGET_ADDR_SPACE_POINTER_MODE (addr_space_t @var{address_space})
Define this to return the machine mode to use for pointers to
@var{address_space} if the target supports named address spaces.
The default version of this hook returns @code{ptr_mode} for the
generic address space only.
@end deftypefn

@deftypefn {Target Hook} {enum machine_mode} TARGET_ADDR_SPACE_ADDRESS_MODE (addr_space_t @var{address_space})
Define this to return the machine mode to use for addresses in
@var{address_space} if the target supports named address spaces.
The default version of this hook returns @code{Pmode} for the
generic address space only.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ADDR_SPACE_VALID_POINTER_MODE (enum machine_mode @var{mode}, addr_space_t @var{as})
Define this to return nonzero if the port can handle pointers
with machine mode @var{mode} to address space @var{as}.  This target
hook is the same as the @code{TARGET_VALID_POINTER_MODE} target hook,
except that it includes explicit named address space support.  The default
version of this hook returns true for the modes returned by either the
@code{TARGET_ADDR_SPACE_POINTER_MODE} or @code{TARGET_ADDR_SPACE_ADDRESS_MODE}
target hooks for the given address space.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P (enum machine_mode @var{mode}, rtx @var{exp}, bool @var{strict}, addr_space_t @var{as})
Define this to return true if @var{exp} is a valid address for mode
@var{mode} in the named address space @var{as}.  The @var{strict}
parameter says whether strict addressing is in effect after reload has
finished.  This target hook is the same as the
@code{TARGET_LEGITIMATE_ADDRESS_P} target hook, except that it includes
explicit named address space support.
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS (rtx @var{x}, rtx @var{oldx}, enum machine_mode @var{mode}, addr_space_t @var{as})
Define this to modify an invalid address @var{x} to be a valid address
with mode @var{mode} in the named address space @var{as}.  This target
hook is the same as the @code{TARGET_LEGITIMIZE_ADDRESS} target hook,
except that it includes explicit named address space support.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ADDR_SPACE_SUBSET_P (addr_space_t @var{superset}, addr_space_t @var{subset})
Define this to return whether the @var{subset} named address space is
contained within the @var{superset} named address space.  Pointers to
a named address space that is a subset of another named address space
will be converted automatically without a cast if used together in
arithmetic operations.  Pointers to a superset address space can be
converted to pointers to a subset address space via explicit casts.
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_ADDR_SPACE_CONVERT (rtx @var{op}, tree @var{from_type}, tree @var{to_type})
Define this to convert the pointer expression represented by the RTL
@var{op} with type @var{from_type} that points to a named address
space to a new pointer expression with type @var{to_type} that points
to a different named address space.  When this hook it called, it is
guaranteed that one of the two address spaces is a subset of the other,
as determined by the @code{TARGET_ADDR_SPACE_SUBSET_P} target hook.
@end deftypefn

@en @node Misc
@en @section Miscellaneous Parameters
@node Misc
@section 其它参数
@cindex parameters, miscellaneous

@c prevent bad page break with this line
@en Here are several miscellaneous parameters.
这是一些其它参数。

@defmac HAS_LONG_COND_BRANCH
@en Define this boolean macro to indicate whether or not your architecture
@en has conditional branches that can span all of memory.  It is used in
@en conjunction with an optimization that partitions hot and cold basic
@en blocks into separate sections of the executable.  If this macro is
@en set to false, gcc will convert any conditional branches that attempt
@en to cross between sections into unconditional branches or indirect jumps.
定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的条件分支转换为无条件分支或间接跳转。
@end defmac

@defmac HAS_LONG_UNCOND_BRANCH
@en Define this boolean macro to indicate whether or not your architecture
@en has unconditional branches that can span all of memory.  It is used in
@en conjunction with an optimization that partitions hot and cold basic
@en blocks into separate sections of the executable.  If this macro is
@en set to false, gcc will convert any unconditional branches that attempt
@en to cross between sections into indirect jumps.
定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的无条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的无条件分支转换为间接跳转。
@end defmac

@defmac CASE_VECTOR_MODE
@en An alias for a machine mode name.  This is the machine mode that
@en elements of a jump-table should have.
机器模式名字的一个别名。这是跳转表（jump-table）的元素应该具有的机器模式。
@end defmac

@defmac CASE_VECTOR_SHORTEN_MODE (@var{min_offset}, @var{max_offset}, @var{body})
@en Optional: return the preferred mode for an @code{addr_diff_vec}
@en when the minimum and maximum offset are known.  If you define this,
@en it enables extra code in branch shortening to deal with @code{addr_diff_vec}.
@en To make this work, you also have to define @code{INSN_ALIGN} and
@en make the alignment for @code{addr_diff_vec} explicit.
@en The @var{body} argument is provided so that the offset_unsigned and scale
@en flags can be updated.
可选的：当最小值和最大值位移已知时，返回@code{addr_diff_vec}的首选机器模式。
如果定义了该宏，这使得在分支缩短中增加了额外的代码来处理@code{addr_diff_vec}。
要使其工作，还必须要定义@code{INSN_ALIGN}，
并且显示的对@code{addr_diff_vec}进行对齐。参数@var{body}被提供，
使得可以更新@code{offset_unsigned}和标量标记。
@end defmac

@defmac CASE_VECTOR_PC_RELATIVE
@en Define this macro to be a C expression to indicate when jump-tables
@en should contain relative addresses.  You need not define this macro if
@en jump-tables never contain relative addresses, or jump-tables should
@en contain relative addresses only when @option{-fPIC} or @option{-fPIC}
@en is in effect.
定义该宏为一个C表达式，来指示跳转表什么时候应该包含相对地址。
你不需要定义该宏，如果跳转表从来不包含相对地址，
或者跳转表只在@option{-fPIC}或者@option{-fPIC}有效时才包含相对地址。
@end defmac

@deftypefn {Target Hook} {unsigned int} TARGET_CASE_VALUES_THRESHOLD (void)
@en This function return the smallest number of different values for which it
@en is best to use a jump-table instead of a tree of conditional branches.
@en The default is four for machines with a @code{casesi} instruction and
@en five otherwise.  This is best for most machines.
@end deftypefn

@defmac CASE_USE_BIT_TESTS
@en Define this macro to be a C expression to indicate whether C switch
@en statements may be implemented by a sequence of bit tests.  This is
@en advantageous on processors that can efficiently implement left shift
@en of 1 by the number of bits held in a register, but inappropriate on
@en targets that would require a loop.  By default, this macro returns
@en @code{true} if the target defines an @code{ashlsi3} pattern, and
@en @code{false} otherwise.
定义该宏为一个C表达式，来指示C switch语句是否可以通过位测试序列来实现。
这在可以通过寄存器中的位数来有效实现左移1位的处理器上很有利，
但不适合需要循环的target。缺省下，该宏返回@code{true}，
如果target定义了@code{ashlsi3}指令模式，否则返回@code{false}。
@end defmac

@defmac WORD_REGISTER_OPERATIONS
@en Define this macro if operations between registers with integral mode
@en smaller than a word are always performed on the entire register.
@en Most RISC machines have this property and most CISC machines do not.
定义该宏，如果整数机器模式的小于一个字的寄存器间的运算总是在整个寄存器中执行。
大多数RISC机器具有这个属性，大多数CISC机器不具有。
@end defmac

@defmac LOAD_EXTEND_OP (@var{mem_mode})
@en Define this macro to be a C expression indicating when insns that read
@en memory in @var{mem_mode}, an integral mode narrower than a word, set the
@en bits outside of @var{mem_mode} to be either the sign-extension or the
@en zero-extension of the data read.  Return @code{SIGN_EXTEND} for values
@en of @var{mem_mode} for which the
@en insn sign-extends, @code{ZERO_EXTEND} for which it zero-extends, and
@en @code{UNKNOWN} for other modes.
定义该宏为一个C表达式，
指示当insn使用比一个字窄的的整数模式的@var{mem_mode}模式读取内存时，
将读取的数据的@var{mem_mode}外的位进行符号扩展或者零扩展。
返回@code{SIGN_EXTEND}，对于那些要符号扩展的insn，
返回@code{ZERO_EXTEND}对那些零扩展的，对于其它的机器模式返回@code{UNKNOWN}。

@en This macro is not called with @var{mem_mode} non-integral or with a width
@en greater than or equal to @code{BITS_PER_WORD}, so you may return any
@en value in this case.  Do not define this macro if it would always return
@en @code{UNKNOWN}.  On machines where this macro is defined, you will normally
@en define it as the constant @code{SIGN_EXTEND} or @code{ZERO_EXTEND}.
该宏不会被非整型的，或者宽度大于等于@code{BITS_PER_WORD}的@var{mem_mode}调用，
所以对于这种情况你可以返回任何值。如果总是返回@code{UNKNOWN}，则不要定义该宏。
在定义该宏的机器上，你通常要定义其为常量@code{SIGN_EXTEND}或者@code{ZERO_EXTEND}。

@en You may return a non-@code{UNKNOWN} value even if for some hard registers
@en the sign extension is not performed, if for the @code{REGNO_REG_CLASS}
@en of these hard registers @code{CANNOT_CHANGE_MODE_CLASS} returns nonzero
@en when the @var{from} mode is @var{mem_mode} and the @var{to} mode is any
@en integral mode larger than this but not larger than @code{word_mode}.
你可以返回一个非@code{UNKNOWN}的值，即使对于一些硬件寄存器并没有执行符号扩展，如果对于这些硬件寄存器的@code{REGNO_REG_CLASS}，当@var{from}机器模式为@var{mem_mode}，并且@var{to}机器模式为任何大于其但是不大于@code{word_mode}的整形机器模式的时候，@code{CANNOT_CHANGE_MODE_CLASS}返回非零。

@en You must return @code{UNKNOWN} if for some hard registers that allow this
@en mode, @code{CANNOT_CHANGE_MODE_CLASS} says that they cannot change to
@en @code{word_mode}, but that they can change to another integral mode that
@en is larger then @var{mem_mode} but still smaller than @code{word_mode}.
你必须返回@code{UNKNOWN}，如果一些硬件寄存器允许该机器模式，@code{CANNOT_CHANGE_MODE_CLASS}说它们不能变成@code{word_mode}，但是它们可以变成其它大于@var{mem_mode}且仍然小于@code{word_mode}的整形机器模式。
@end defmac

@defmac SHORT_IMMEDIATES_SIGN_EXTEND
@en Define this macro if loading short immediate values into registers sign
@en extends.
定义该宏，如果将short立即数加载到寄存器中要进行符号扩展。
@end defmac

@defmac FIXUNS_TRUNC_LIKE_FIX_TRUNC
@en Define this macro if the same instructions that convert a floating
@en point number to a signed fixed point number also convert validly to an
@en unsigned one.
定义该宏，如果将浮点数转换为有符号定点数的指令，
同样可以有效的转换为无符号的。
@end defmac

@deftypefn {Target Hook} {unsigned int} TARGET_MIN_DIVISIONS_FOR_RECIP_MUL (enum machine_mode @var{mode})
@en When @option{-ffast-math} is in effect, GCC tries to optimize
@en divisions by the same divisor, by turning them into multiplications by
@en the reciprocal.  This target hook specifies the minimum number of divisions
@en that should be there for GCC to perform the optimization for a variable
@en of mode @var{mode}.  The default implementation returns 3 if the machine
@en has an instruction for the division, and 2 if it does not.
当@option{-ffast-math}有效时，GCC尝试使用相同的除数来优化除法，
通过将它们转换为乘以倒数的方式。
缺省实现返回3，如果机器具有除法指令，否则为2。
@end deftypefn

@defmac MOVE_MAX
@en The maximum number of bytes that a single instruction can move quickly
@en between memory and registers or between two memory locations.
单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
@end defmac

@defmac MAX_MOVE_MAX
@en The maximum number of bytes that a single instruction can move quickly
@en between memory and registers or between two memory locations.  If this
@en is undefined, the default is @code{MOVE_MAX}.  Otherwise, it is the
@en constant value that is the largest value that @code{MOVE_MAX} can have
@en at run-time.
单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
如果没有定义，则缺省为@code{MOVE_MAX}。
否则，其为@code{MOVE_MAX}在运行时可以具有的最大常数值。
@end defmac

@defmac SHIFT_COUNT_TRUNCATED
@en A C expression that is nonzero if on this machine the number of bits
@en actually used for the count of a shift operation is equal to the number
@en of bits needed to represent the size of the object being shifted.  When
@en this macro is nonzero, the compiler will assume that it is safe to omit
@en a sign-extend, zero-extend, and certain bitwise `and' instructions that
@en truncates the count of a shift operation.  On machines that have
@en instructions that act on bit-fields at variable positions, which may
@en include `bit test' instructions, a nonzero @code{SHIFT_COUNT_TRUNCATED}
@en also enables deletion of truncations of the values that serve as
@en arguments to bit-field instructions.
一个C表达式，为非零，如果在该机器上，实际用于计算移位运算的位数等同于，用来表示被移位的对象大小的位数。当该宏为非零的时候，编译器将假设可以安全的忽略掉对移位运算的计数进行截取的有符号扩展，零扩展和按位与指令。在一些机器上，具有指令可以作用于可变位置的位域，其可能会包含‘位测试’指令，非零的@code{SHIFT_COUNT_TRUNCATED}还可以使得作为位域指令参数的值的截取运算。

@en If both types of instructions truncate the count (for shifts) and
@en position (for bit-field operations), or if no variable-position bit-field
@en instructions exist, you should define this macro.
如果指令会截取计数（对于位移运算）和位置（对于位域运算），或者如果没有可变位置的位域指令存在，则你应该定义该宏。

@en However, on some machines, such as the 80386 and the 680x0, truncation
@en only applies to shift operations and not the (real or pretended)
@en bit-field operations.  Define @code{SHIFT_COUNT_TRUNCATED} to be zero on
@en such machines.  Instead, add patterns to the @file{md} file that include
@en the implied truncation of the shift instructions.
然而，在一些机器上，例如80386和680x0，截取操作只应用在移位运算上，而不在位域运算上。在这样的机器上，定义@code{SHIFT_COUNT_TRUNCATED}为零。可替代的，在@file{md}文件中增加指令模式，包含对移位指令隐式的截取操作。

@en You need not define this macro if it would always have the value of zero.
如果其值总是为零，则不需要定义该宏。
@end defmac

@anchor{TARGET_SHIFT_TRUNCATION_MASK}
@deftypefn {Target Hook} {unsigned HOST_WIDE_INT} TARGET_SHIFT_TRUNCATION_MASK (enum machine_mode @var{mode})
@en TARGET_SHIFT_TRUNCATION_MASK (enum machine_mode @var{mode})
@en This function describes how the standard shift patterns for @var{mode}
@en deal with shifts by negative amounts or by more than the width of the mode.
@en @xref{shift patterns}.
该函数描述了标准的移位指令模式，对于@var{mode}，如何处理负的数量或者大于机器模式宽度的数量的移位。
@xref{shift patterns}.

@en On many machines, the shift patterns will apply a mask @var{m} to the
@en shift count, meaning that a fixed-width shift of @var{x} by @var{y} is
@en equivalent to an arbitrary-width shift of @var{x} by @var{y & m}.  If
@en this is true for mode @var{mode}, the function should return @var{m},
@en otherwise it should return 0.  A return value of 0 indicates that no
@en particular behavior is guaranteed.
在许多机器上，移位指令模式将会应用一个掩码@var{m}到移位计数上，意味着将@var{x}固定宽度移位@var{y}等价于对@var{x}任意宽度移位@var{y & m}。如果这对机器模式@var{mode}为真，则函数应该返回@var{m}，否则应该返回0。返回值0意味着不保证特定的行为。

@en Note that, unlike @code{SHIFT_COUNT_TRUNCATED}, this function does
@en @emph{not} apply to general shift rtxes; it applies only to instructions
@en that are generated by the named shift patterns.
注意，不像@code{SHIFT_COUNT_TRUNCATED}，该函数不应用到通用的移位rtx上；其只应用到由命名移位指令模式生成的指令上。

@en The default implementation of this function returns
@en @code{GET_MODE_BITSIZE (@var{mode}) - 1} if @code{SHIFT_COUNT_TRUNCATED}
@en and 0 otherwise.  This definition is always safe, but if
@en @code{SHIFT_COUNT_TRUNCATED} is false, and some shift patterns
@en nevertheless truncate the shift count, you may get better code
@en by overriding it.
该函数的缺省实现返回@code{GET_MODE_BITSIZE (@var{mode}) - 1}，如果@code{SHIFT_COUNT_TRUNCATED}，否则为0。该定义总是安全的，但是如果@code{SHIFT_COUNT_TRUNCATED}为假，并且一些移位指令模式还是截取移位计数，则你可以通过重写覆盖该宏来获得更好的代码。
@end deftypefn

@defmac TRULY_NOOP_TRUNCATION (@var{outprec}, @var{inprec})
@en A C expression which is nonzero if on this machine it is safe to
@en ``convert'' an integer of @var{inprec} bits to one of @var{outprec}
@en bits (where @var{outprec} is smaller than @var{inprec}) by merely
@en operating on it as if it had only @var{outprec} bits.
一个C表达式，其为非零，如果在该机器上，将@var{inprec}个位数的整数转换成@var{outprec}个位数（@var{outprec}比@var{inprec}小），通过简单的认为其只具有@var{outprec}个位。

@en On many machines, this expression can be 1.
在许多机器上，该表达式可以为1。

@c rearranged this, removed the phrase "it is reported that".  this was
@c to fix an overfull hbox.  --mew 10feb93
When @code{TRULY_NOOP_TRUNCATION} returns 1 for a pair of sizes for
modes for which @code{MODES_TIEABLE_P} is 0, suboptimal code can result.
If this is the case, making @code{TRULY_NOOP_TRUNCATION} return 0 in
such cases may improve things.
@end defmac

@deftypefn {Target Hook} int TARGET_MODE_REP_EXTENDED (enum machine_mode @var{mode}, enum machine_mode @var{rep_mode})
@en The representation of an integral mode can be such that the values
@en are always extended to a wider integral mode.  Return
@en @code{SIGN_EXTEND} if values of @var{mode} are represented in
@en sign-extended form to @var{rep_mode}.  Return @code{UNKNOWN}
@en otherwise.  (Currently, none of the targets use zero-extended
@en representation this way so unlike @code{LOAD_EXTEND_OP},
@en @code{TARGET_MODE_REP_EXTENDED} is expected to return either
@en @code{SIGN_EXTEND} or @code{UNKNOWN}.  Also no target extends
@en @var{mode} to @var{rep_mode} so that @var{rep_mode} is not the next
@en widest integral mode and currently we take advantage of this fact.)
整型机器模式可以表示为一个值，其总是被扩展为更宽的整型模式。返回@code{SIGN_EXTEND}，如果机器模式为@var{mode}的值被表示为有符号扩展成@var{rep_mode}的形式。否则，返回@code{UNKNOWN}。（目前，没有目标机使用零扩展表示，所以不像@code{LOAD_EXTEND_OP}，@code{TARGET_MODE_REP_EXTENDED}被期望返回@code{SIGN_EXTEND}或者@code{UNKNOWN}。而且没有目标机将@var{mode}扩展为@var{mode_rep}，以至于@var{mode_rep}不是下一个最宽的整型机器模式，目前，我们利用了这个事实。）

@en Similarly to @code{LOAD_EXTEND_OP} you may return a non-@code{UNKNOWN}
@en value even if the extension is not performed on certain hard registers
@en as long as for the @code{REGNO_REG_CLASS} of these hard registers
@en @code{CANNOT_CHANGE_MODE_CLASS} returns nonzero.
类似于@code{LOAD_EXTEND_OP}，你可以返回一个非@code{UNKNOWN}的值，即使扩展在特定硬件寄存器上没有被执行，只要对于这些硬件寄存器的@code{REGNO_REG_CLASS}，@code{CANNOT_CHANGE_MODE_CLASS}返回非零。

@en Note that @code{TARGET_MODE_REP_EXTENDED} and @code{LOAD_EXTEND_OP}
@en describe two related properties.  If you define
@en @code{TARGET_MODE_REP_EXTENDED (mode, word_mode)} you probably also want
@en to define @code{LOAD_EXTEND_OP (mode)} to return the same type of
@en extension.
注意，@code{TARGET_MODE_REP_EXTENDED}和@code{LOAD_EXTEND_OP}描述了两个相关联的属性。如果你定义了@code{TARGET_MODE_REP_EXTENDED (mode, word_mode)}，你可能还要定义@code{LOAD_EXTEND_OP (mode)}，来返回相同类型的扩展。

@en In order to enforce the representation of @code{mode},
@en @code{TRULY_NOOP_TRUNCATION} should return false when truncating to
@en @code{mode}.
为了加强@code{mode}的表示，当截取成@code{mode}时，@code{TRULY_NOOP_TRUNCATION}应该返回假。
@end deftypefn

@defmac STORE_FLAG_VALUE
@en A C expression describing the value returned by a comparison operator
@en with an integral mode and stored by a store-flag instruction
@en (@samp{cstore@var{mode}4}) when the condition is true.  This description must
@en apply to @emph{all} the @samp{cstore@var{mode}4} patterns and all the
@en comparison operators whose results have a @code{MODE_INT} mode.
一个C表达式，描述了整型机器模式的比较运算符返回的值，并且当条件为真时由存储标记指令(@samp{s@var{cond}})存储。该描述必须应用到所有的@samp{s@var{cond}}指令模式，并且所有比较运算的结果必须具有@code{MODE_INT}机器模式。

@en A value of 1 or @minus{}1 means that the instruction implementing the
@en comparison operator returns exactly 1 or @minus{}1 when the comparison is true
@en and 0 when the comparison is false.  Otherwise, the value indicates
@en which bits of the result are guaranteed to be 1 when the comparison is
@en true.  This value is interpreted in the mode of the comparison
@en operation, which is given by the mode of the first operand in the
@en @samp{cstore@var{mode}4} pattern.  Either the low bit or the sign bit of
@en @code{STORE_FLAG_VALUE} be on.  Presently, only those bits are used by
@en the compiler.
值为1或者-1，意味着实现比较运算的指令当比较为真时返回确切的1或者-1，当比较为假时返回0。否则，值会表示当比较为真时结果的哪些位保证为1。该值按照比较运算的机器模式来解析，其由@samp{s@var{cond}}指令模式中的第一个操作数的机器模式给出。目前，编译器只用到了@code{STORE_FLAG_VALUE}的低位或者符号位。

@en If @code{STORE_FLAG_VALUE} is neither 1 or @minus{}1, the compiler will
@en generate code that depends only on the specified bits.  It can also
@en replace comparison operators with equivalent operations if they cause
@en the required bits to be set, even if the remaining bits are undefined.
@en For example, on a machine whose comparison operators return an
@en @code{SImode} value and where @code{STORE_FLAG_VALUE} is defined as
@en @samp{0x80000000}, saying that just the sign bit is relevant, the
@en expression
如果@code{STORE_FLAG_VALUE}不为1或者-1，则编译器将生成只依赖特定位的代码。其还可以用等价的运算来替换比较运算，如果它们会造成需要的位被设置，即使其它位没有被定义。例如，在比较运算返回一个@code{SImode}值的机器上，其@code{STORE_FLAG_VALUE}被定义为@samp{0x80000000}，说明只有符号位是相关的，表达式

@smallexample
(ne:SI (and:SI @var{x} (const_int @var{power-of-2})) (const_int 0))
@end smallexample

@noindent
@en can be converted to
可以被转换为

@smallexample
(ashift:SI @var{x} (const_int @var{n}))
@end smallexample

@noindent
@en where @var{n} is the appropriate shift count to move the bit being
@en tested into the sign bit.

其中@var{n}为适当的移位计数，用来将被测试的位移送到符号位。

@en There is no way to describe a machine that always sets the low-order bit
@en for a true value, but does not guarantee the value of any other bits,
@en but we do not know of any machine that has such an instruction.  If you
@en are trying to port GCC to such a machine, include an instruction to
@en perform a logical-and of the result with 1 in the pattern for the
@en comparison operators and let us know at @email{gcc@@gcc.gnu.org}.
没有办法来描述，一个机器对于真值，总是设置低顺序的位，而不保证其它位的值。但是，我们不知道是否有机器具有这样的指令。如果你正在尝试将GCC移植到这样的机器上，那么可以在比较运算的指令模式中，包含一条指令来执行将结果和1进行逻辑与，并且通过@email{gcc@@gcc.gnu.org}让我们知道。

@en Often, a machine will have multiple instructions that obtain a value
@en from a comparison (or the condition codes).  Here are rules to guide the
@en choice of value for @code{STORE_FLAG_VALUE}, and hence the instructions
@en to be used:
通常，机器将具有多个指令，从比较（或者条件代码）中获得一个值。这里有一些规则用来指导对@code{STORE_FLAG_VALUE}的值的选择，以及要使用的指令：

@en @itemize @bullet
@en @item
@en Use the shortest sequence that yields a valid definition for
@en @code{STORE_FLAG_VALUE}.  It is more efficient for the compiler to
@en ``normalize'' the value (convert it to, e.g., 1 or 0) than for the
@en comparison operators to do so because there may be opportunities to
@en combine the normalization with other operations.
@en 
@en @item
@en For equal-length sequences, use a value of 1 or @minus{}1, with @minus{}1 being
@en slightly preferred on machines with expensive jumps and 1 preferred on
@en other machines.
@en 
@en @item
@en As a second choice, choose a value of @samp{0x80000001} if instructions
@en exist that set both the sign and low-order bits but do not define the
@en others.
@en 
@en @item
@en Otherwise, use a value of @samp{0x80000000}.
@en @end itemize
@itemize @bullet
@item
使用最短的序列，产生@code{STORE_FLAG_VALUE}的有效定义。对编译器来说，将值正常化（例如，将其转成1或者0）要比进行比较运算更有效，因为可能会有一些机会来合并其它的正常化运算。

@item
对于等长的序列，使用值1或者－1。在跳转代价比较高的机器上，一般会倾向于－1，其它一些机器喜欢用1。

@item
作为第二种选择，选择值@samp{0x80000001}，如果存在指令，同时设置符号位和低顺序位，但是不定义其它位。

@item
否则，使用值@samp{0x80000000}。
@end itemize

@en Many machines can produce both the value chosen for
@en @code{STORE_FLAG_VALUE} and its negation in the same number of
@en instructions.  On those machines, you should also define a pattern for
@en those cases, e.g., one matching
许多机器可以同时产生供@code{STORE_FLAG_VALUE}选择的值，以及同样数量指令的取反。在那些机器上，你应该还定义这些情况的指令模式，例如，

@smallexample
(set @var{A} (neg:@var{m} (ne:@var{m} @var{B} @var{C})))
@end smallexample

@en Some machines can also perform @code{and} or @code{plus} operations on
@en condition code values with less instructions than the corresponding
@en @samp{cstore@var{mode}4} insn followed by @code{and} or @code{plus}.  On those
@en machines, define the appropriate patterns.  Use the names @code{incscc}
@en and @code{decscc}, respectively, for the patterns which perform
@en @code{plus} or @code{minus} operations on condition code values.  See
@en @file{rs6000.md} for some examples.  The GNU Superoptizer can be used to
@en find such instruction sequences on other machines.
一些机器还可以在条件代码值上，执行@code{and}或者@code{plus}运算，使用少于相应的@samp{s@var{cond}} insn后跟随@code{and}或者@code{plus}的指令数目。在这些机器上，需要定义适当的指令模式。分别使用名字@code{incscc}和@code{decscc}，对于在条件代码值上执行@code{plus}或者@code{minus}运算的指令模式。参见@file{rs6000.md}中的一些例子。可以使用GNU Superoptizer来在其它机器上查找这样的指令序列。

@en If this macro is not defined, the default value, 1, is used.  You need
@en not define @code{STORE_FLAG_VALUE} if the machine has no store-flag
@en instructions, or if the value generated by these instructions is 1.
如果该宏没有被定义，则使用缺省的值1。你不需要定义@code{STORE_FLAG_VALUE}，如果机器没有存储标记的指令，或者如果这些指令生成的值为1。
@end defmac

@defmac FLOAT_STORE_FLAG_VALUE (@var{mode})
@en A C expression that gives a nonzero @code{REAL_VALUE_TYPE} value that is
@en returned when comparison operators with floating-point results are true.
@en Define this macro on machines that have comparison operations that return
@en floating-point values.  If there are no such operations, do not define
@en this macro.
一个C表达式，给出一个非零的@code{REAL_VALUE_TYPE}值，当浮点比较运算的结果为真时返回该值。在一些机器上，具有返回浮点值的比较运算，可以定义该宏。如果没有这样的运算，则不要定义该宏。
@end defmac

@defmac VECTOR_STORE_FLAG_VALUE (@var{mode})
@en A C expression that gives a rtx representing the nonzero true element
@en for vector comparisons.  The returned rtx should be valid for the inner
@en mode of @var{mode} which is guaranteed to be a vector mode.  Define
@en this macro on machines that have vector comparison operations that
@en return a vector result.  If there are no such operations, do not define
@en this macro.  Typically, this macro is defined as @code{const1_rtx} or
@en @code{constm1_rtx}.  This macro may return @code{NULL_RTX} to prevent
@en the compiler optimizing such vector comparison operations for the
@en given mode.
一个C表达式，给出一个rtx，表示向量比较中非零的真元素。返回的rtx应该对于@var{mode}的内部机器模式是有效的，@var{mode}为一个向量机器模式。定义该宏，在一些机器上，具有返回向量结果的向量比较运算。如果没有这样的运算，则不要定义该宏。通常，该宏被定义为@code{const1_rtx}或者@code{constm1_rtx}。该宏可以返回@code{NULL_RTX}，来阻止编译器优化给定的机器模式的向量比较运算。
@end defmac

@defmac CLZ_DEFINED_VALUE_AT_ZERO (@var{mode}, @var{value})
@defmacx CTZ_DEFINED_VALUE_AT_ZERO (@var{mode}, @var{value})
@en A C expression that indicates whether the architecture defines a value
@en for @code{clz} or @code{ctz} with a zero operand.  
@en A result of @code{0} indicates the value is undefined.
@en If the value is defined for only the RTL expression, the macro should
@en evaluate to @code{1}; if the value applies also to the corresponding optab
@en entry (which is normally the case if it expands directly into
@en the corresponding RTL), then the macro should evaluate to @code{2}.  
@en In the cases where the value is defined, @var{value} should be set to
@en this value.  
一个C表达式，指示体系机构是否为@code{clz}或者@code{ctz}在操作数为零时，定义了值。结果为@code{0}，表示值未被定义。如果值只被定义为RTL表达式，则宏应该求值为@code{1}；如果还应用到相应的optab项（其通常情况为直接扩展为相应的RTL），则宏应该求值为@code{2}。在值被定义的情况下，@var{value}应该被设置为该值。

@en If this macro is not defined, the value of @code{clz} or
@en @code{ctz} at zero is assumed to be undefined.
如果该宏没有被定义，则@code{clz}或者@code{ctz}在操作数为零时，被认为未定义。

@en This macro must be defined if the target's expansion for @code{ffs}
@en relies on a particular value to get correct results.  Otherwise it
@en is not necessary, though it may be used to optimize some corner cases, and
@en to provide a default expansion for the @code{ffs} optab.
该宏必须被定义，如果目标机对@code{ffs}的扩展，依赖于特定的值，以获得正确的结果。否则，没有必要，虽然其可以用于优化一些边角的情况，并且为@code{ffs} optab提供缺省的扩展。

@en Note that regardless of this macro the ``definedness'' of @code{clz}
@en and @code{ctz} at zero do @emph{not} extend to the builtin functions
@en visible to the user.  Thus one may be free to adjust the value at will
@en to match the target expansion of these operations without fear of
@en breaking the API@.
注意，不论该宏是否定义，@code{clz}和@code{ctz}在操作数为0时的定义，都不会被扩展为用户可见的内建函数。因此，可以任意调整该值，来匹配对这些运算的目标机扩展，而无需担心会破坏API。
@end defmac

@defmac Pmode
@en An alias for the machine mode for pointers.  On most machines, define
@en this to be the integer mode corresponding to the width of a hardware
@en pointer; @code{SImode} on 32-bit machine or @code{DImode} on 64-bit machines.
@en On some machines you must define this to be one of the partial integer
@en modes, such as @code{PSImode}.
指针的机器模式别名。在大多数机器上，定义该宏为整型机器模式，对应于硬件指针宽度；32位机器上为@code{SImode}，64位机器上为@code{DImode}。在一些机器上，你必须定义该宏为部分整型机器模式，例如@code{PSImode}。

@en The width of @code{Pmode} must be at least as large as the value of
@en @code{POINTER_SIZE}.  If it is not equal, you must define the macro
@en @code{POINTERS_EXTEND_UNSIGNED} to specify how pointers are extended
@en to @code{Pmode}.
@code{Pmode}的宽度必须至少与@code{POINTER_SIZE}的值一样大。如果不相等，你必须定义宏@code{POINTERS_EXTEND_UNSIGNED}来描述指针如何被扩展为@code{Pmode}。
@end defmac

@defmac FUNCTION_MODE
@en An alias for the machine mode used for memory references to functions
@en being called, in @code{call} RTL expressions.  On most CISC machines,
@en where an instruction can begin at any byte address, this should be 
@en @code{QImode}.  On most RISC machines, where all instructions have fixed
@en size and alignment, this should be a mode with the same size and alignment
@en as the machine instruction words - typically @code{SImode} or @code{HImode}.
机器模式的别名，在@code{call} RTL表达式中，用于被调用函数的内存引用。在大多数CISC机器上，指令可以起始于任意字节地址，这应该为@code{QImode}。在大多RISC机器上，所有的指令都具有固定的大小和对齐方式，这应该为与机器指令字具有相同大小和对齐的机器模式，通常为@code{SImode}或者@code{HImode}。
@end defmac

@defmac STDC_0_IN_SYSTEM_HEADERS
@en In normal operation, the preprocessor expands @code{__STDC__} to the
@en constant 1, to signify that GCC conforms to ISO Standard C@.  On some
@en hosts, like Solaris, the system compiler uses a different convention,
@en where @code{__STDC__} is normally 0, but is 1 if the user specifies
@en strict conformance to the C Standard.
正常的操作中，预处理器会将@code{__STDC__}扩展为常量1，来表明GCC遵循ISO标准C。在一些主机上，例如Solaris，系统编译器使用不同的约定，@code{__STDC__}通常为0，但是如果用户指出要严格遵循C标准时为1。

@en Defining @code{STDC_0_IN_SYSTEM_HEADERS} makes GNU CPP follows the host
@en convention when processing system header files, but when processing user
@en files @code{__STDC__} will always expand to 1.
定义@code{STDC_0_IN_SYSTEM_HEADERS}使得GNU CPP遵循主机的约定，当处理系统头文件时，但是，当处理用户文件时@code{__STDC__}将总是被扩展为1。
@end defmac

@defmac NO_IMPLICIT_EXTERN_C
@en Define this macro if the system header files support C++ as well as C@.
@en This macro inhibits the usual method of using system header files in
@en C++, which is to pretend that the file's contents are enclosed in
@en @samp{extern "C" @{@dots{}@}}.
定义该宏，如果系统头文件支持C++，也支持C。该宏抑制了通常在C++中使用系统头文件的方法，即假设文件的内容包含在@samp{extern "C" @{@dots{}@}}中。
@end defmac

@findex #pragma
@findex pragma
@defmac REGISTER_TARGET_PRAGMAS ()
@en Define this macro if you want to implement any target-specific pragmas.
@en If defined, it is a C expression which makes a series of calls to
@en @code{c_register_pragma} or @code{c_register_pragma_with_expansion}
@en for each pragma.  The macro may also do any
@en setup required for the pragmas.
定义该宏，如果你想实现任何目标机特定的pragma。如果被定义，其为一个C表达式，为每个pragma使用一系列的对@code{c_register_pragma}或者@code{c_register_pragma_with_expansion}调用。该宏还可以做任何pragma所要求的设置。

@en The primary reason to define this macro is to provide compatibility with
@en other compilers for the same target.  In general, we discourage
@en definition of target-specific pragmas for GCC@.
定义该宏的主要原因是提供相同目标机上，与其它编译器的兼容性。大体上，我们不鼓励为GCC定义目标机特定的pragma。

@en If the pragma can be implemented by attributes then you should consider
@en defining the target hook @samp{TARGET_INSERT_ATTRIBUTES} as well.
如果pragma可以通过attribute属性来实现，则你也应该考虑定义目标机钩子@samp{TARGET_INSERT_ATTRIBUTES}。

@en Preprocessor macros that appear on pragma lines are not expanded.  All
@en @samp{#pragma} directives that do not match any registered pragma are
@en silently ignored, unless the user specifies @option{-Wunknown-pragmas}.
出现在pragma行中的预处理器宏不被扩展。所有不匹配被注册的@samp{#pragma}指令，将被安静的忽略，除非用户指定@option{-Wunknown-pragmas}。
@end defmac

@deftypefun void c_register_pragma (const char *@var{space}, const char *@var{name}, void (*@var{callback}) (struct cpp_reader *))
@deftypefunx void c_register_pragma_with_expansion (const char *@var{space}, const char *@var{name}, void (*@var{callback}) (struct cpp_reader *))

@en Each call to @code{c_register_pragma} or
@en @code{c_register_pragma_with_expansion} establishes one pragma.  The
@en @var{callback} routine will be called when the preprocessor encounters a
@en pragma of the form
每个对@code{c_register_pragma}或者@code{c_register_pragma_with_expansion}的调用，都建立了一个pragma。当预处理器遇到一个形式为

@smallexample
#pragma [@var{space}] @var{name} @dots{}
@end smallexample

的pragma，则@var{callback}函数将被调用。 

@en @var{space} is the case-sensitive namespace of the pragma, or
@en @code{NULL} to put the pragma in the global namespace.  The callback
@en routine receives @var{pfile} as its first argument, which can be passed
@en on to cpplib's functions if necessary.  You can lex tokens after the
@en @var{name} by calling @code{pragma_lex}.  Tokens that are not read by the
@en callback will be silently ignored.  The end of the line is indicated by
@en a token of type @code{CPP_EOF}.  Macro expansion occurs on the
@en arguments of pragmas registered with
@en @code{c_register_pragma_with_expansion} but not on the arguments of
@en pragmas registered with @code{c_register_pragma}.
@var{space}为大小写敏感的pragma命名空间，或者为@code{NULL}，将gragma放在全局命名空间中。回调函数接受@var{pfile}作为第一个参数，如果需要其可以被传递给cpplib的函数。你可以通过调用@code{pragma_lex}，来词法分析@var{name}之后的token。没有被回调函数读入的token将被安静的忽略。行尾由类型为@code{CPP_EOF}的token来指示。宏扩展发生在使用@code{c_register_pragma_with_expansion}注册的pragma的参数上，但不在使用@code{c_register_pragma}注册的pragma的参数上。

@en Note that the use of @code{pragma_lex} is specific to the C and C++
@en compilers.  It will not work in the Java or Fortran compilers, or any
@en other language compilers for that matter.  Thus if @code{pragma_lex} is going
@en to be called from target-specific code, it must only be done so when
@en building the C and C++ compilers.  This can be done by defining the
@en variables @code{c_target_objs} and @code{cxx_target_objs} in the
@en target entry in the @file{config.gcc} file.  These variables should name
@en the target-specific, language-specific object file which contains the
@en code that uses @code{pragma_lex}.  Note it will also be necessary to add a
@en rule to the makefile fragment pointed to by @code{tmake_file} that shows
@en how to build this object file.
注意，使用@code{pragma_lex}是特定于C和C++编译器的。其在Java或者Fortran编译器上，或者其它语言编译器上无法工作。因此，如果@code{pragma_lex}准备从目标机特定代码中被调用，其必须只在构建C和C++编译器的时候执行。这可以通过在@file{config.gcc}文件中的目标机项中，定义变量@code{c_target_objs}和@code{cxx_target_objs}来实现。这些变量应该命名目标机特定的，语言特定的对象文件，其包含了使用@code{pragma_lex}的代码。注意，还有必要增加一个规则到由@code{tmake_file}指定的makefile片断中，来显示如何构建该目标文件。
@end deftypefun

@findex #pragma
@findex pragma
@defmac HANDLE_SYSV_PRAGMA
@en Define this macro (to a value of 1) if you want the System V style
@en pragmas @samp{#pragma pack(<n>)} and @samp{#pragma weak <name>
@en [=<value>]} to be supported by gcc.
定义该宏（值为1），如果你想gcc支持System V风格的pragma @samp{#pragma pack(<n>)}和@samp{#pragma weak <name> [=<value>]}。

@en The pack pragma specifies the maximum alignment (in bytes) of fields
@en within a structure, in much the same way as the @samp{__aligned__} and
@en @samp{__packed__} @code{__attribute__}s do.  A pack value of zero resets
@en the behavior to the default.
pack pragma描述了结构体中域的最大对齐方式（以字节为单位），很大程度上等同于使用@samp{__aligned__}和@samp{__packed__} @code{__attribute__}。pack值为零，会将行为重置为缺省。

@en A subtlety for Microsoft Visual C/C++ style bit-field packing
@en (e.g.@: -mms-bitfields) for targets that support it:
@en When a bit-field is inserted into a packed record, the whole size
@en of the underlying type is used by one or more same-size adjacent
@en bit-fields (that is, if its long:3, 32 bits is used in the record,
@en and any additional adjacent long bit-fields are packed into the same
@en chunk of 32 bits.  However, if the size changes, a new field of that
@en size is allocated).
对于目标机支持的微软Visual C/C++风格的位域打包（例如-mms-bitfields），其微妙之处在于：当位域被插入到一个打包了的记录中时，则底层类型的整个大小会被一个或多个相同大小临近的位域使用（也就是说，如果为long:3，则记录会使用32位，任何额外的临近的long位域将被打包到32位块中。然而，如果大小改变了，则会分配一个新的同样大小的域）。

@en If both MS bit-fields and @samp{__attribute__((packed))} are used,
@en the latter will take precedence.  If @samp{__attribute__((packed))} is
@en used on a single field when MS bit-fields are in use, it will take
@en precedence for that field, but the alignment of the rest of the structure
@en may affect its placement.
如果MS位域和@samp{__attribute__((packed))}都被使用，则后者优先。如果当在使用MS位域的时候，@samp{__attribute__((packed))}被用于一个单独的域，则对于该域是优先的，但是结构体的其它部分的对齐方式会影响它的放置。

@en The weak pragma only works if @code{SUPPORTS_WEAK} and
@en @code{ASM_WEAKEN_LABEL} are defined.  If enabled it allows the creation
@en of specifically named weak labels, optionally with a value.
weak pragma只有当@code{SUPPORTS_WEAK}和@code{ASM_WEAKEN_LABEL}被定义时，才工作。如果可用，其允许创建特殊命名的弱标号，以及可选的值。
@end defmac

@findex #pragma
@findex pragma
@defmac HANDLE_PRAGMA_PACK_PUSH_POP
@en Define this macro (to a value of 1) if you want to support the Win32
@en style pragmas @samp{#pragma pack(push[,@var{n}])} and @samp{#pragma
@en pack(pop)}.  The @samp{pack(push,[@var{n}])} pragma specifies the maximum
@en alignment (in bytes) of fields within a structure, in much the same way as
@en the @samp{__aligned__} and @samp{__packed__} @code{__attribute__}s do.  A
@en pack value of zero resets the behavior to the default.  Successive
@en invocations of this pragma cause the previous values to be stacked, so
@en that invocations of @samp{#pragma pack(pop)} will return to the previous
@en value.
定义该宏（值为1），如果你想支持Win32风格的pragmas @samp{#pragma pack(push[,@var{n}])} and @samp{#pragma pack(pop)}。@samp{pack(push,[@var{n}])} pragma指定结构体内的域的最大对齐方式（按字节），等同于使用@samp{__aligned__} 和 @samp{__packed__} @code{__attribute__}。如果pack值为0，则会将行为重置为缺省情况。连续的调用该pragma会造成先前的值被压栈，所以调用@samp{#pragma pack(pop)}会返回先前的值。
@end defmac

@defmac HANDLE_PRAGMA_PACK_WITH_EXPANSION
@en Define this macro if macros should be expanded in the
@en arguments of @samp{#pragma pack}.
定义该宏，如果在@samp{#pragma pack}中的参数宏应该被扩展。
@end defmac

@deftypevr {Target Hook} bool TARGET_HANDLE_PRAGMA_EXTERN_PREFIX
True if @code{#pragma extern_prefix} is to be supported.
@end deftypevr

@defmac TARGET_DEFAULT_PACK_STRUCT
@en If your target requires a structure packing default other than 0 (meaning
@en the machine default), define this macro to the necessary value (in bytes).
@en This must be a value that would also be valid to use with
@en @samp{#pragma pack()} (that is, a small power of two).
如果你的目标机要求结构体缺省的打包方式不是0（意味着机器缺省方式），则定义该宏为必要的值（以字节为单位）。该值必须还对于@samp{#pragma pack()}有效（也就是说，2的小的幂数）。
@end defmac

@defmac DOLLARS_IN_IDENTIFIERS
@en Define this macro to control use of the character @samp{$} in
@en identifier names for the C family of languages.  0 means @samp{$} is
@en not allowed by default; 1 means it is allowed.  1 is the default;
@en there is no need to define this macro in that case.
定义该宏，来控制C语言家族，标识符名字中对字符@samp{$}的使用。0意味着缺省不允许使用@samp{$}；1意味着允许。缺省为1；对于这种情况，不需要定义该宏。
@end defmac

@defmac NO_DOLLAR_IN_LABEL
@en Define this macro if the assembler does not accept the character
@en @samp{$} in label names.  By default constructors and destructors in
@en G++ have @samp{$} in the identifiers.  If this macro is defined,
@en @samp{.} is used instead.
定义该宏，如果汇编器不接受标号名字中的@samp{$}。缺省的，G++的构造函数和析构函数会在标识符中使用@samp{$}。如果该宏被定义，则使用@samp{.}来替代。
@end defmac

@defmac NO_DOT_IN_LABEL
@en Define this macro if the assembler does not accept the character
@en @samp{.} in label names.  By default constructors and destructors in G++
@en have names that use @samp{.}.  If this macro is defined, these names
@en are rewritten to avoid @samp{.}.
定义该宏，如果汇编器不接受标号名字中的@samp{.}。缺省的，G++的构造函数和析构函数的名字会使用@samp{.}。如果该宏被定义，则这些名字被重写，以避免出现@samp{.}。
@end defmac

@defmac INSN_SETS_ARE_DELAYED (@var{insn})
@en Define this macro as a C expression that is nonzero if it is safe for the
@en delay slot scheduler to place instructions in the delay slot of @var{insn},
@en even if they appear to use a resource set or clobbered in @var{insn}.
@en @var{insn} is always a @code{jump_insn} or an @code{insn}; GCC knows that
@en every @code{call_insn} has this behavior.  On machines where some @code{insn}
@en or @code{jump_insn} is really a function call and hence has this behavior,
@en you should define this macro.
定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在@var{insn}的延迟槽中是安全的，即使它们可能会使用@var{insn}设置或者破坏的一个资源。@var{insn}总是一个@code{jump_insn}或者@code{insn}；GCC知道每个@code{call_insn}具有这种行为。在一些机器上，一些@code{insn}或者@code{jump_insn}确实为一个函数调用，因此也具有这种行为，你应该定义该宏。

@en You need not define this macro if it would always return zero.
如果其总是返回零，则不需要定义该宏。
@end defmac

@defmac INSN_REFERENCES_ARE_DELAYED (@var{insn})
@en Define this macro as a C expression that is nonzero if it is safe for the
@en delay slot scheduler to place instructions in the delay slot of @var{insn},
@en even if they appear to set or clobber a resource referenced in @var{insn}.
@en @var{insn} is always a @code{jump_insn} or an @code{insn}.  On machines where
@en some @code{insn} or @code{jump_insn} is really a function call and its operands
@en are registers whose use is actually in the subroutine it calls, you should
@en define this macro.  Doing so allows the delay slot scheduler to move
@en instructions which copy arguments into the argument registers into the delay
@en slot of @var{insn}.
定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在@var{insn}的延迟槽中是安全的，即使它们可能会设置或者破坏@var{insn}使用的一个资源。@var{insn}总是一个@code{jump_insn}或者@code{insn}。在一些机器上，一些@code{insn}或者@code{jump_insn}确实为一个函数调用，并且其操作数为寄存器，实际是在其调用的子函数中使用，你应该定义该宏。这使得延迟槽调度器将复制参数到参数寄存器的指令移送到@var{insn}的延迟槽中。

@en You need not define this macro if it would always return zero.
如果其总是返回零，则不需要定义该宏。
@end defmac

@defmac MULTIPLE_SYMBOL_SPACES
@en Define this macro as a C expression that is nonzero if, in some cases,
@en global symbols from one translation unit may not be bound to undefined
@en symbols in another translation unit without user intervention.  For
@en instance, under Microsoft Windows symbols must be explicitly imported
@en from shared libraries (DLLs).
定义该宏为一个C表达式，其为非零，如果对于一些情况，没有用户的介入，一个转换单元中的全局符号可能不会被发现为另一个转换单元中的未定义的符号。例如，在Microsoft Windows下，符号必须被从共享库（DLL）中显式的导入。

@en You need not define this macro if it would always evaluate to zero.
如果其总是为零，则不需要定义该宏。
@end defmac

@deftypefn {Target Hook} tree TARGET_MD_ASM_CLOBBERS (tree @var{outputs}, tree @var{inputs}, tree @var{clobbers})
@en This target hook should add to @var{clobbers} @code{STRING_CST} trees for
@en any hard regs the port wishes to automatically clobber for an asm.
@en It should return the result of the last @code{tree_cons} used to add a
@en clobber.  The @var{outputs}, @var{inputs} and @var{clobber} lists are the
@en corresponding parameters to the asm and may be inspected to avoid
@en clobbering a register that is an input or output of the asm.  You can use
@en @code{tree_overlaps_hard_reg_set}, declared in @file{tree.h}, to test
@en for overlap with regards to asm-declared registers.
该目标钩子将移植平台希望一个asm可以自动破坏的硬件寄存器增加到@var{clobbers} @code{STRING_CST} tree中。其应该返回最后一个用于增加一个破坏者的@code{tree_cons}。@var{outputs}, @var{inputs} 和 @var{clobber}为asm的相应的参数，可以用来检查以避免破坏asm的输入或者输出寄存器。你可以使用@file{tree.h}中声明的@code{tree_overlaps_hard_reg_set}来测试是否与asm声明的寄存器有重叠。
@end deftypefn

@defmac MATH_LIBRARY
@en Define this macro as a C string constant for the linker argument to link
@en in the system math library, minus the initial @samp{"-l"}, or
@en @samp{""} if the target does not have a
@en separate math library.
定义该宏为一个C字符串常量，为连接器的参数，作为系统数学库连接，或者@samp{""}，如果目标机没有单独的数学库。

@en You need only define this macro if the default of @samp{"m"} is wrong.
只有当缺省的@samp{"-lm"}有错误时，才需要定义该宏。
@end defmac

@defmac LIBRARY_PATH_ENV
@en Define this macro as a C string constant for the environment variable that
@en specifies where the linker should look for libraries.
定义该宏为一个C字符串常量，为一个环境变量，指定了连接器应该从哪里查找库。

@en You need only define this macro if the default of @samp{"LIBRARY_PATH"}
@en is wrong.
只有当缺省的@samp{"LIBRARY_PATH"}有错误时，才需要定义该宏。
@end defmac

@defmac TARGET_POSIX_IO
@en Define this macro if the target supports the following POSIX@ file
@en functions, access, mkdir and  file locking with fcntl / F_SETLKW@.
@en Defining @code{TARGET_POSIX_IO} will enable the test coverage code
@en to use file locking when exiting a program, which avoids race conditions
@en if the program has forked. It will also create directories at run-time
@en for cross-profiling.
定义该宏，如果目标机支持下列POSIX文件函数，access, mkdir和使用fcntl / F_SETLKW的文件加锁。其还在运行时为交叉profiling创建目录。
@end defmac

@defmac MAX_CONDITIONAL_EXECUTE
@en A C expression for the maximum number of instructions to execute via
@en conditional execution instructions instead of a branch.  A value of
@en @code{BRANCH_COST}+1 is the default if the machine does not use cc0, and
@en 1 if it does use cc0.
一个C表达式，为通过条件执行指令来替代分支的最大指令数。值@code{BRANCH_COST}+1为缺省值，如果机器没有使用cc0，如果使用了cc0，则为1。
@end defmac

@defmac IFCVT_MODIFY_TESTS (@var{ce_info}, @var{true_expr}, @var{false_expr})
@en Used if the target needs to perform machine-dependent modifications on the
@en conditionals used for turning basic blocks into conditionally executed code.
@en @var{ce_info} points to a data structure, @code{struct ce_if_block}, which
@en contains information about the currently processed blocks.  @var{true_expr}
@en and @var{false_expr} are the tests that are used for converting the
@en then-block and the else-block, respectively.  Set either @var{true_expr} or
@en @var{false_expr} to a null pointer if the tests cannot be converted.
使用该宏，如果目标机需要在将基本块转为条件执行代码时，对条件进行机器相关的修改。@var{ce_info}指向一个数据结构，@code{struct ce_if_block}，其包含了关于当前被处理的块的信息。@var{true_expr}和@var{false_expr}为测试，分别用于转换then-block和else-block。如果测试不能被转换，则将@var{true_expr}或者@var{false_expr}设置为空指针。
@end defmac

@defmac IFCVT_MODIFY_MULTIPLE_TESTS (@var{ce_info}, @var{bb}, @var{true_expr}, @var{false_expr})
@en Like @code{IFCVT_MODIFY_TESTS}, but used when converting more complicated
@en if-statements into conditions combined by @code{and} and @code{or} operations.
@en @var{bb} contains the basic block that contains the test that is currently
@en being processed and about to be turned into a condition.
类似于@code{IFCVT_MODIFY_TESTS}，不过用于将更加复杂的if语句转换为由@code{and}和@code{or}运算组合的条件。@var{bb}包含的基本块，包含了当前被处理的测试，并将被转换为一个条件。
@end defmac

@defmac IFCVT_MODIFY_INSN (@var{ce_info}, @var{pattern}, @var{insn})
@en A C expression to modify the @var{PATTERN} of an @var{INSN} that is to
@en be converted to conditional execution format.  @var{ce_info} points to
@en a data structure, @code{struct ce_if_block}, which contains information
@en about the currently processed blocks.
一个C表达式，来修改@var{INSN}的@var{PATTERN}，其将被转换为一个条件执行的格式。@var{ce_info}指向一个数据结构，@code{struct ce_if_block}，其包含了关于当前被处理的块的信息。
@end defmac

@defmac IFCVT_MODIFY_FINAL (@var{ce_info})
@en A C expression to perform any final machine dependent modifications in
@en converting code to conditional execution.  The involved basic blocks
@en can be found in the @code{struct ce_if_block} structure that is pointed
@en to by @var{ce_info}.
一个C表达式，用来执行在将代码转换为条件执行时，任何最终机器相关的修改。涉及到的基本块可以在由@var{ce_info}指向的@code{struct ce_if_block}结构体中找到。
@end defmac

@defmac IFCVT_MODIFY_CANCEL (@var{ce_info})
@en A C expression to cancel any machine dependent modifications in
@en converting code to conditional execution.  The involved basic blocks
@en can be found in the @code{struct ce_if_block} structure that is pointed
@en to by @var{ce_info}.
一个C表达式，用来取消在将代码转换为条件执行时，任何机器相关的修改。涉及到的基本块可以在由@var{ce_info}指向的@code{struct ce_if_block}结构体中找到。
@end defmac

@defmac IFCVT_INIT_EXTRA_FIELDS (@var{ce_info})
@en A C expression to initialize any extra fields in a @code{struct ce_if_block}
@en structure, which are defined by the @code{IFCVT_EXTRA_FIELDS} macro.
一个C表达式，来初始化任何@code{struct ce_if_block}结构体中额外的域，其通过@code{IFCVT_EXTRA_FIELDS}宏来定义。
@end defmac

@defmac IFCVT_EXTRA_FIELDS
@en If defined, it should expand to a set of field declarations that will be
@en added to the @code{struct ce_if_block} structure.  These should be initialized
@en by the @code{IFCVT_INIT_EXTRA_FIELDS} macro.
如果被定义，其应该扩展为一个域声明集合，其将被增加到@code{struct ce_if_block}结构体中。这些应该通过@code{IFCVT_INIT_EXTRA_FIELDS}宏来初始化。
@end defmac

@deftypefn {Target Hook} void TARGET_MACHINE_DEPENDENT_REORG (void)
@en If non-null, this hook performs a target-specific pass over the
@en instruction stream.  The compiler will run it at all optimization levels,
@en just before the point at which it normally does delayed-branch scheduling.
如果非空，则该钩子对指令流执行目标机特定的编译过程。编译器将在所有优化级别上执行该过程，就在其通常执行延迟分支调度之前的地方。

@en The exact purpose of the hook varies from target to target.  Some use
@en it to do transformations that are necessary for correctness, such as
@en laying out in-function constant pools or avoiding hardware hazards.
@en Others use it as an opportunity to do some machine-dependent optimizations.
该钩子的确切目的因目标机不同而不同。一些用来为了正确性执行必要的转换，例如布局函数常量池，或者避免硬件冒险。其它用来作为机器相关的优化。

@en You need not implement the hook if it has nothing to do.  The default
@en definition is null.
如果没有什么可做的，则不需要实现该钩子。缺省定义为空。
@end deftypefn

@deftypefn {Target Hook} void TARGET_INIT_BUILTINS (void)
@en Define this hook if you have any machine-specific built-in functions
@en that need to be defined.  It should be a function that performs the
@en necessary setup.
定义该钩子，如果你有任何需要被定义的机器特定的内建函数。其应该为一个函数，执行必要的设置。

@en Machine specific built-in functions can be useful to expand special machine
@en instructions that would otherwise not normally be generated because
@en they have no equivalent in the source language (for example, SIMD vector
@en instructions or prefetch instructions).
机器特定的内建函数可以用于扩展特定的机器指令，否则其通常不会被生成，因为在源语言中没有等价的对应（例如，SIMD向量指令或者预取指令）。

@en To create a built-in function, call the function
@en @code{lang_hooks.builtin_function}
@en which is defined by the language front end.  You can use any type nodes set
@en up by @code{build_common_tree_nodes} and @code{build_common_tree_nodes_2};
@en only language front ends that use those two functions will call
@en @samp{TARGET_INIT_BUILTINS}.
要创建一个内建函数，调用函数@code{lang_hooks.builtin_function}，其由语言前端定义。你可以使用任何由@code{build_common_tree_nodes}和@code{build_common_tree_nodes_2}建立的类型节点；只有使用这两个函数的语言前端会调用@samp{TARGET_INIT_BUILTINS}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_BUILTIN_DECL (unsigned @var{code}, bool @var{initialize_p})
Define this hook if you have any machine-specific built-in functions
that need to be defined.  It should be a function that returns the
builtin function declaration for the builtin function code @var{code}.
If there is no such builtin and it cannot be initialized at this time
if @var{initialize_p} is true the function should return @code{NULL_TREE}.
If @var{code} is out of range the function should return
@code{error_mark_node}.
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_EXPAND_BUILTIN (tree @var{exp}, rtx @var{target}, rtx @var{subtarget}, enum machine_mode @var{mode}, int @var{ignore})
@en Expand a call to a machine specific built-in function that was set up by
@en @samp{TARGET_INIT_BUILTINS}.  @var{exp} is the expression for the
@en function call; the result should go to @var{target} if that is
@en convenient, and have mode @var{mode} if that is convenient.
@en @var{subtarget} may be used as the target for computing one of
@en @var{exp}'s operands.  @var{ignore} is nonzero if the value is to be
@en ignored.  This function should return the result of the call to the
@en built-in function.
扩展由@samp{TARGET_INIT_BUILTINS}建立的对一个机器特定的内建函数的调用。@var{exp}为函数调用的表达式；如果方便的话，结果应该放到@var{target}，并且具有机器模式@var{mode}。@var{subtarget}可以用作目标，来计算@var{exp}的操作数。@var{ignore}为非零，如果值将被忽略。该函数应该返回调用内建函数的结果。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_RESOLVE_OVERLOADED_BUILTIN (unsigned int @var{loc}, tree @var{fndecl}, void *@var{arglist})
@en Select a replacement for a machine specific built-in function that
@en was set up by @samp{TARGET_INIT_BUILTINS}.  This is done
@en @emph{before} regular type checking, and so allows the target to
@en implement a crude form of function overloading.  @var{fndecl} is the
@en declaration of the built-in function.  @var{arglist} is the list of
@en arguments passed to the built-in function.  The result is a
@en complete expression that implements the operation, usually
@en another @code{CALL_EXPR}.
@en @var{arglist} really has type @samp{VEC(tree,gc)*}
为@samp{TARGET_INIT_BUILTINS}建立的机器特定内建函数选择一个替身。这发生在常规的类型检查之前，因此允许目标机来实现函数重载的粗糙形式。@var{fndecl}为内建函数的声明。@var{arglist}为传递给内建函数的参数列表。结果为一个完全表达式，实现了该运算，通常为另一个@code{CALL_EXPR}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_FOLD_BUILTIN (tree @var{fndecl}, int @var{n_args}, tree *@var{argp}, bool @var{ignore})
@en Fold a call to a machine specific built-in function that was set up by
@en @samp{TARGET_INIT_BUILTINS}.  @var{fndecl} is the declaration of the
@en built-in function.  @var{n_args} is the number of arguments passed to
@en the function; the arguments themselves are pointed to by @var{argp}.
@en The result is another tree containing a simplified expression for the
@en call's result.  If @var{ignore} is true the value will be ignored.
将@samp{TARGET_INIT_BUILTINS}建立的机器特定的内建函数的调用进行折叠。@var{fndecl}为内建函数的声明。@var{arglist}为传递给内建函数的参数列表。结果为另一个tree，包含了一个简化的表达式，为调用的结果。如果@var{ignore}为真，则值将被忽略。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_WITHIN_DOLOOP (const_rtx @var{insn})
@en Take an instruction in @var{insn} and return NULL if it is valid within a
@en low-overhead loop, otherwise return a string explaining why doloop
@en could not be applied.
接受一个指令@var{insn}，如果其在一个低开销循环中有效，则返回NULL，否则返回一个字符串说明为什么不能应用doloop。

@en Many targets use special registers for low-overhead looping. For any
@en instruction that clobbers these this function should return a string indicating
@en the reason why the doloop could not be applied.
@en By default, the RTL loop optimizer does not use a present doloop pattern for
@en loops containing function calls or branch on table instructions.
许多目标机使用特定的寄存器，用于低开销循环。对于任何破坏这些的指令，该函数应该返回一个字符串，指出不能应用doloop的原因。缺省的，RTL循环优化不对包含函数调用或者表指令分支的循环，使用现有的doloop指令模式。
@end deftypefn

@defmac MD_CAN_REDIRECT_BRANCH (@var{branch1}, @var{branch2})
@en Take a branch insn in @var{branch1} and another in @var{branch2}.
@en Return true if redirecting @var{branch1} to the destination of
@en @var{branch2} is possible.
接受一个分支insn @var{branch1}和另一个@var{branch2}。返回真，如果将@var{branch1}重定向到@var{branch2}的目的地是可能的。

@en On some targets, branches may have a limited range.  Optimizing the
@en filling of delay slots can result in branches being redirected, and this
@en may in turn cause a branch offset to overflow.
在一些目标机上，分支可能具有有限的范围。优化延迟槽的填充，可以导致分支可以被重定向，反过来也可能会造成一个分支的偏移量溢出。
@end defmac

@deftypefn {Target Hook} bool TARGET_COMMUTATIVE_P (const_rtx @var{x}, int @var{outer_code})
@en This target hook returns @code{true} if @var{x} is considered to be commutative.
@en Usually, this is just COMMUTATIVE_P (@var{x}), but the HP PA doesn't consider
@en PLUS to be commutative inside a MEM@.  @var{outer_code} is the rtx code
@en of the enclosing rtl, if known, otherwise it is UNKNOWN.
该目标钩子返回@code{true}，如果@var{x}被认为是可交换的。通常，这就是COMMUTATIVE_P (@var{x})。但是HP PA不认为PLUS在MEM中是可交换的。@var{outer_code}为包含rtl的rtx代码，如果知道，否则为UNKNOWN。
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_ALLOCATE_INITIAL_VALUE (rtx @var{hard_reg})
@en When the initial value of a hard register has been copied in a pseudo
@en register, it is often not necessary to actually allocate another register
@en to this pseudo register, because the original hard register or a stack slot
@en it has been saved into can be used.  @code{TARGET_ALLOCATE_INITIAL_VALUE}
@en is called at the start of register allocation once for each hard register
@en that had its initial value copied by using
@en @code{get_func_hard_reg_initial_val} or @code{get_hard_reg_initial_val}.
@en Possible values are @code{NULL_RTX}, if you don't want
@en to do any special allocation, a @code{REG} rtx---that would typically be
@en the hard register itself, if it is known not to be clobbered---or a
@en @code{MEM}.
@en If you are returning a @code{MEM}, this is only a hint for the allocator;
@en it might decide to use another register anyways.
@en You may use @code{current_function_leaf_function} in the hook, functions
@en that use @code{REG_N_SETS}, to determine if the hard
@en register in question will not be clobbered.
@en The default value of this hook is @code{NULL}, which disables any special
@en allocation.
当硬件寄存器的初始值已经被复制到伪寄存器中，通常没有必要为该伪寄存器分配另一个寄存器，因为可以使用原始的硬件寄存器或者被保存到的栈槽。在寄存器分配的起始处，@code{TARGET_ALLOCATE_INITIAL_VALUE}针对每个其初始值使用@code{get_func_hard_reg_initial_val}或者@code{get_hard_reg_initial_val}复制过的，硬件寄存器被调用一次。可能的值为，@code{NULL_RTX}如果你不想做任何特殊的分配，一个@code{REG} rtx——其通常为硬件寄存器本身，如果知道其不会被破坏——或者一个@code{MEM}。如果返回一个@code{MEM}，这只是一个给分配器的提示；其仍然有可能会决定用另一个寄存器。你可以在钩子中使用@code{current_function_leaf_function}，用来确定被询问的硬件寄存器是否会被破坏。该钩子的缺省值为@code{NULL}，其禁止了任何特殊的分配。
@end deftypefn

@deftypefn {Target Hook} int TARGET_UNSPEC_MAY_TRAP_P (const_rtx @var{x}, unsigned @var{flags})
@en This target hook returns nonzero if @var{x}, an @code{unspec} or
@en @code{unspec_volatile} operation, might cause a trap.  Targets can use
@en this hook to enhance precision of analysis for @code{unspec} and
@en @code{unspec_volatile} operations.  You may call @code{may_trap_p_1}
@en to analyze inner elements of @var{x} in which case @var{flags} should be
@en passed along.
该目标钩子返回非零，如果@var{x}，一个@code{unspec}或者@code{unspec_volatile}运算，可能会造成一个陷阱。目标机可以使用该钩子来加强对@code{unspec}和@code{unspec_volatile}运算的分析的精确性。你可以调用@code{may_trap_p_1}来分析@var{x}的内部元素，这种情况下，也应该传递@var{flags}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SET_CURRENT_FUNCTION (tree @var{decl})
@en The compiler invokes this hook whenever it changes its current function 
@en context (@code{cfun}).  You can define this function if
@en the back end needs to perform any initialization or reset actions on a
@en per-function basis.  For example, it may be used to implement function
@en attributes that affect register usage or code generation patterns.
@en The argument @var{decl} is the declaration for the new function context,
@en and may be null to indicate that the compiler has left a function context
@en and is returning to processing at the top level.
@en The default hook function does nothing.
编译器每当改变当前函数上下文(@code{cfun})时，便会调用该钩子。你可以定义该函数，如果后端需要基于每个函数执行任何初始化或者重置行为。例如，其可以用来实现函数属性，影响寄存器的使用或者代码生成指令模式。参数@var{decl}为新的函数上下文的声明，可以为空，表示编译器已经离开函数上下文，要返回顶层去处理。缺省钩子函数不做任何事情。

@en GCC sets @code{cfun} to a dummy function context during initialization of
@en some parts of the back end.  The hook function is not invoked in this
@en situation; you need not worry about the hook being invoked recursively,
@en or when the back end is in a partially-initialized state.
@en @code{cfun} might be @code{NULL} to indicate processing at top level,
@en outside of any function scope.
GCC将@code{cfun}设置为一个哑的函数上下文，在初始化后端一些部分的时候。钩子函数在这种情况下不会被调用；你不需要担心钩子函数被递归调用，或者当后端处于部分初始化的状态。
@end deftypefn

@defmac TARGET_OBJECT_SUFFIX
@en Define this macro to be a C string representing the suffix for object
@en files on your target machine.  If you do not define this macro, GCC will
@en use @samp{.o} as the suffix for object files.
定义该宏为C字符串，表示在你的目标机器上，对象文件的后缀。如果没有定义该宏，则GCC会使用@samp{.o}作为目标文件的后缀。
@end defmac

@defmac TARGET_EXECUTABLE_SUFFIX
@en Define this macro to be a C string representing the suffix to be
@en automatically added to executable files on your target machine.  If you
@en do not define this macro, GCC will use the null string as the suffix for
@en executable files.
定义该宏为C字符串，表示在你的目标机器上，为可执行文件自动增加的后缀。如果没有定义该宏，GCC将为可执行文件使用空字符串作为后缀。
@end defmac

@defmac COLLECT_EXPORT_LIST
@en If defined, @code{collect2} will scan the individual object files
@en specified on its command line and create an export list for the linker.
@en Define this macro for systems like AIX, where the linker discards
@en object files that are not referenced from @code{main} and uses export
@en lists.
如果被定义，@code{collect2}将在其命令行中扫描单独的目标文件，并为连接器创建一个导出列表。为AIX这样的系统定义该宏，并使用导出列表，其连接器会丢弃没有从@code{main}中引用的对象文件。
@end defmac

@defmac MODIFY_JNI_METHOD_CALL (@var{mdecl})
@en Define this macro to a C expression representing a variant of the
@en method call @var{mdecl}, if Java Native Interface (JNI) methods
@en must be invoked differently from other methods on your target.
@en For example, on 32-bit Microsoft Windows, JNI methods must be invoked using
@en the @code{stdcall} calling convention and this macro is then
@en defined as this expression:
定义该宏为一个C表达式，表示方法调用@var{mdecl}的一个变种，如果Java Native Interface (JNI)方法必须通过你目标机上其它方法来调用。例如，在32位Microsoft Windows上，JNI方法必须使用@code{stdcall}调用约定来调用，该宏则被定义为如下表达式：

@smallexample
build_type_attribute_variant (@var{mdecl},
                              build_tree_list
                              (get_identifier ("stdcall"),
                               NULL))
@end smallexample
@end defmac

@deftypefn {Target Hook} bool TARGET_CANNOT_MODIFY_JUMPS_P (void)
@en This target hook returns @code{true} past the point in which new jump
@en instructions could be created.  On machines that require a register for
@en every jump such as the SHmedia ISA of SH5, this point would typically be
@en reload, so this target hook should be defined to a function such as:
该目标钩子在一个点之后返回@code{true}，该处应该创建新的跳转指令。在一些机器上，对每个跳转都要求使用寄存器，例如SH5的SHmedia ISA，该点通常为重载，所以该目标钩子应该被定义为这样的函数：

@smallexample
static bool
cannot_modify_jumps_past_reload_p ()
@{
  return (reload_completed || reload_in_progress);
@}
@end smallexample
@end deftypefn

@deftypefn {Target Hook} reg_class_t TARGET_BRANCH_TARGET_REGISTER_CLASS (void)
@en This target hook returns a register class for which branch target register
@en optimizations should be applied.  All registers in this class should be
@en usable interchangeably.  After reload, registers in this class will be
@en re-allocated and loads will be hoisted out of loops and be subjected
@en to inter-block scheduling.
该目标钩子返回一个寄存器类，分支目标寄存器优化将会应用在该类别上。该类别中的所有寄存器应该是可以互换使用的。重载之后，该类别中的寄存器将被重新分配，并且加载将被悬挂在循环之外，从属于块间调度。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED (bool @var{after_prologue_epilogue_gen})
@en Branch target register optimization will by default exclude callee-saved
@en registers
@en that are not already live during the current function; if this target hook
@en returns true, they will be included.  The target code must than make sure
@en that all target registers in the class returned by
@en @samp{TARGET_BRANCH_TARGET_REGISTER_CLASS} that might need saving are
@en saved.  @var{after_prologue_epilogue_gen} indicates if prologues and
@en epilogues have already been generated.  Note, even if you only return
@en true when @var{after_prologue_epilogue_gen} is false, you still are likely
@en to have to make special provisions in @code{INITIAL_ELIMINATION_OFFSET}
@en to reserve space for caller-saved target registers.
分支目标寄存器优化，缺省的会将，被调用者保存的寄存器排除在外，其在当前函数中已经是不活跃的。如果目标钩子返回真，它们将被包含进来。目标代码必须确保在由@samp{TARGET_BRANCH_TARGET_REGISTER_CLASS}返回的类别中的所有寄存器，如果需要保存的，会被保存。@var{after_prologue_epilogue_gen}指出是否序言和尾声已经被生成。注意，即使你只当@var{after_prologue_epilogue_gen}为假时返回真，你还可能要在@code{INITIAL_ELIMINATION_OFFSET}做出特定的预防，来为调用者保存的目标寄存器保留空间。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_HAVE_CONDITIONAL_EXECUTION (void)
This target hook returns true if the target supports conditional execution.
This target hook is required only when the target has several different
modes and they have different conditional execution capability, such as ARM.
@end deftypefn

@deftypefn {Target Hook} unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned @var{nunroll}, struct loop *@var{loop})
This target hook returns a new value for the number of times @var{loop}
should be unrolled. The parameter @var{nunroll} is the number of times
the loop is to be unrolled. The parameter @var{loop} is a pointer to
the loop, which is going to be checked for unrolling. This target hook
is required only when the target has special constraints like maximum
number of memory accesses.
@end deftypefn

@defmac POWI_MAX_MULTS
If defined, this macro is interpreted as a signed integer C expression
that specifies the maximum number of floating point multiplications
that should be emitted when expanding exponentiation by an integer
constant inline.  When this value is defined, exponentiation requiring
more than this number of multiplications is implemented by calling the
system library's @code{pow}, @code{powf} or @code{powl} routines.
The default value places no upper bound on the multiplication count.
如果被定义，该宏被解析为一个有符号整型C表达式，描述了浮点乘法的最大数。
@end defmac

@deftypefn Macro void TARGET_EXTRA_INCLUDES (const char *@var{sysroot}, const char *@var{iprefix}, int @var{stdinc})
@en This target hook should register any extra include files for the
@en target.  The parameter @var{stdinc} indicates if normal include files
@en are present.  The parameter @var{sysroot} is the system root directory.
@en The parameter @var{iprefix} is the prefix for the gcc directory.
该钩子用于记录目标机的任何额外的include文件。参数@var{stdinc}指示是否存在通常的include文件。参数@var{sysroot}为系统根目录。参数@var{iprefix}为gcc目录的前缀。
@end deftypefn

@deftypefn Macro void TARGET_EXTRA_PRE_INCLUDES (const char *@var{sysroot}, const char *@var{iprefix}, int @var{stdinc})
@en This target hook should register any extra include files for the
@en target before any standard headers.  The parameter @var{stdinc}
@en indicates if normal include files are present.  The parameter
@en @var{sysroot} is the system root directory.  The parameter
@en @var{iprefix} is the prefix for the gcc directory.
该钩子用于记录目标机的任何先于标准头文件之前的include文件。参数@var{stdinc}指示是否存在通常的include文件。参数@var{sysroot}为系统根目录。参数@var{iprefix}为gcc目录的前缀。
@end deftypefn

@deftypefn Macro void TARGET_OPTF (char *@var{path})
@en This target hook should register special include paths for the target.
@en The parameter @var{path} is the include to register.  On Darwin
@en systems, this is used for Framework includes, which have semantics
@en that are different from @option{-I}.
该目标机钩子用来记录目标机特殊的include路径。参数@var{path}为要记录的include。在Darwin系统上，被用于Framework include，其语义与@option{-I}有所不同。
@end deftypefn

@defmac bool TARGET_USE_LOCAL_THUNK_ALIAS_P (tree @var{fndecl})
@en This target macro returns @code{true} if it is safe to use a local alias
@en for a virtual function @var{fndecl} when constructing thunks,
@en @code{false} otherwise.  By default, the macro returns @code{true} for all
@en functions, if a target supports aliases (i.e.@: defines
@en @code{ASM_OUTPUT_DEF}), @code{false} otherwise,
该目标机钩子返回@code{true}，如果当为虚函数构造thunk时，使用局部别名是安全的，否则为@code{false}。缺省的，钩子对所有函数返回@code{true}，如果目标机支持别名（即：定义了@code{ASM_OUTPUT_DEF}），否则@code{false}。
@end defmac

@defmac TARGET_FORMAT_TYPES
@en If defined, this macro is the name of a global variable containing
@en target-specific format checking information for the @option{-Wformat}
@en option.  The default is to have no target-specific format checks.
如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式检查信息，针对@option{-Wformat}选项。缺省为没有目标机特定的格式检查。
@end defmac

@defmac TARGET_N_FORMAT_TYPES
@en If defined, this macro is the number of entries in
@en @code{TARGET_FORMAT_TYPES}.
如果被定义，则该宏为@code{TARGET_FORMAT_TYPES}中的项数。
@end defmac

@defmac TARGET_OVERRIDES_FORMAT_ATTRIBUTES
@en If defined, this macro is the name of a global variable containing
@en target-specific format overrides for the @option{-Wformat} option. The
@en default is to have no target-specific format overrides. If defined,
@en @code{TARGET_FORMAT_TYPES} must be defined, too.
如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式，用来覆盖@option{-Wformat}选项。缺省为没有目标机特定的格式覆盖。如果被定义，则@code{TARGET_FORMAT_TYPES}也必须被定义。
@end defmac

@defmac TARGET_OVERRIDES_FORMAT_ATTRIBUTES_COUNT
@en If defined, this macro specifies the number of entries in
@en @code{TARGET_OVERRIDES_FORMAT_ATTRIBUTES}.
如果被定义，该宏描述@code{TARGET_OVERRIDES_FORMAT_ATTRIBUTES}中的项数。
@end defmac

@defmac TARGET_OVERRIDES_FORMAT_INIT
@en If defined, this macro specifies the optional initialization
@en routine for target specific customizations of the system printf
@en and scanf formatter settings.
如果被定义，则该宏描述可选的初始化程序，用于目标机特定的系统printf和scanf格式设置。
@end defmac

@deftypevr {Target Hook} bool TARGET_RELAXED_ORDERING
@en If set to @code{true}, means that the target's memory model does not
@en guarantee that loads which do not depend on one another will access
@en main memory in the order of the instruction stream; if ordering is
@en important, an explicit memory barrier must be used.  This is true of
@en many recent processors which implement a policy of ``relaxed,''
@en ``weak,'' or ``release'' memory consistency, such as Alpha, PowerPC,
@en and ia64.  The default is @code{false}.
如果设置为@code{true}，则意味着目标机的内存模型不保证，没有依赖关系的加载操作会按照指令流的顺序来访问主存；如果顺序很重要，那么必须使用显式的内存栅栏。这对许多现在的处理器是这样的，例如Alpha, PowerPC和ia64，其实现了关于内存一致性的``relaxed,'' ``weak,'' 或 ``release''策略。缺省为@code{false}。
@end deftypevr

@deftypefn {Target Hook} {const char *} TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN (const_tree @var{typelist}, const_tree @var{funcdecl}, const_tree @var{val})
@en TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN (const_tree @var{typelist}, const_tree @var{funcdecl}, const_tree @var{val})
@en If defined, this macro returns the diagnostic message when it is
@en illegal to pass argument @var{val} to function @var{funcdecl}
@en with prototype @var{typelist}.
如果被定义，则当传递参数@var{val}给函数原型为@var{typelist}的函数@var{funcdecl}是非法的时候，该宏会返回诊断信息。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_CONVERSION (const_tree @var{fromtype}, const_tree @var{totype})
@en If defined, this macro returns the diagnostic message when it is
@en invalid to convert from @var{fromtype} to @var{totype}, or @code{NULL}
@en if validity should be determined by the front end.
如果被定义，则当从@var{fromtype}转换成@var{totype}是无效的时候，该宏会返回诊断信息，或者返回@code{NULL}，如果有效性应该由前端来确定。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_UNARY_OP (int @var{op}, const_tree @var{type})
@en If defined, this macro returns the diagnostic message when it is
@en invalid to apply operation @var{op} (where unary plus is denoted by
@en @code{CONVERT_EXPR}) to an operand of type @var{type}, or @code{NULL}
@en if validity should be determined by the front end.
如果被定义，则当在类型为@var{type}的操作数上执行@var{op}（一元的加号通过@code{CONVERT_EXPR}来表示）是无效的时候，该宏会返回诊断信息，或者返回@code{NULL}，如果有效性应该由前端来确定。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_BINARY_OP (int @var{op}, const_tree @var{type1}, const_tree @var{type2})
@en If defined, this macro returns the diagnostic message when it is
@en invalid to apply operation @var{op} to operands of types @var{type1}
@en and @var{type2}, or @code{NULL} if validity should be determined by
@en the front end.
如果被定义，则当在类型为@var{type1}和@var{type2}的操作数上执行@var{op}是无效的时候，该宏会返回诊断信息，或者返回@code{NULL}，如果有效性应该由前端来确定。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_PARAMETER_TYPE (const_tree @var{type})
If defined, this macro returns the diagnostic message when it is
invalid for functions to include parameters of type @var{type}, 
or @code{NULL} if validity should be determined by
the front end.  This is currently used only by the C and C++ front ends.
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_RETURN_TYPE (const_tree @var{type})
If defined, this macro returns the diagnostic message when it is
invalid for functions to have return type @var{type}, 
or @code{NULL} if validity should be determined by
the front end.  This is currently used only by the C and C++ front ends.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_PROMOTED_TYPE (const_tree @var{type})
If defined, this target hook returns the type to which values of 
@var{type} should be promoted when they appear in expressions, 
analogous to the integer promotions, or @code{NULL_TREE} to use the
front end's normal promotion rules.  This hook is useful when there are
target-specific types with special promotion rules.
This is currently used only by the C and C++ front ends.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_CONVERT_TO_TYPE (tree @var{type}, tree @var{expr})
If defined, this hook returns the result of converting @var{expr} to 
@var{type}.  It should return the converted expression, 
or @code{NULL_TREE} to apply the front end's normal conversion rules.
This hook is useful when there are target-specific types with special 
conversion rules.
This is currently used only by the C and C++ front ends.
@end deftypefn

@defmac TARGET_USE_JCR_SECTION
@en This macro determines whether to use the JCR section to register Java
@en classes. By default, TARGET_USE_JCR_SECTION is defined to 1 if both
@en SUPPORTS_WEAK and TARGET_HAVE_NAMED_SECTIONS are true, else 0.
该宏定义是否使用JCR段来记录Java类。缺省的，如果SUPPORTS_WEAK和TARGET_HAVE_NAMED_SECTIONS都为真，则TARGET_USE_JCR_SECTION被定义为1，否则为0。
@end defmac

@defmac OBJC_JBLEN
@en This macro determines the size of the objective C jump buffer for the
@en NeXT runtime. By default, OBJC_JBLEN is defined to an innocuous value.
该宏为NeXT运行时，确定objective C跳转缓存的大小。缺省的，OBJC_JBLEN被定义为一个无害的值。
@end defmac

@defmac LIBGCC2_UNWIND_ATTRIBUTE
@en Define this macro if any target-specific attributes need to be attached
@en to the functions in @file{libgcc} that provide low-level support for 
@en call stack unwinding.  It is used in declarations in @file{unwind-generic.h}
@en and the associated definitions of those functions.
定义该宏，如果对于@file{libgcc}中那些为调用栈展开（call stack unwinding）提供低级别支持的函数上，需要附加目标机特定的属性时。其被用在@file{unwind-generic.h}中的声明和那些函数相关的定义中。
@end defmac

@deftypefn {Target Hook} void TARGET_UPDATE_STACK_BOUNDARY (void)
@en Define this macro to update the current function stack boundary if
@en necessary.
如果需要，定义该宏来更新当前函数栈边界。
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_GET_DRAP_RTX (void)
@en This hook should return an rtx for Dynamic Realign Argument Pointer (DRAP) if a
@en different argument pointer register is needed to access the function's
@en argument list due to stack realignment.  Return @code{NULL} if no DRAP
@en is needed.
定义该宏为动态重对齐参数指针（Dynamic Realign Argument Pointer）的rtx，如果当栈被对齐时，需要用不同的参数指针寄存器来访问函数的参数列表。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS (void)
@en When optimization is disabled, this hook indicates whether or not
@en arguments should be allocated to stack slots.  Normally, GCC allocates
@en stacks slots for arguments when not optimizing in order to make
@en debugging easier.  However, when a function is declared with
@en @code{__attribute__((naked))}, there is no stack frame, and the compiler
@en cannot safely move arguments from the registers in which they are passed
@en to the stack.  Therefore, this hook should return true in general, but
@en false for naked functions.  The default implementation always returns true.
当优化被禁止时，该钩子用来指示参数是否应该被分配到栈槽中。通常，GCC当不做优化时，会为参数分配栈槽，以便于调试。然而，当函数使用@code{__attribute__((naked))}声明时，将没有栈帧，因此编译器不能安全的将参数从用来传递它们的寄存器中移送到栈上。因此，该钩子通常应该返回真，但是对于裸露的函数应该返回假。缺省的实现总是返回真。
@end deftypefn

@deftypevr {Target Hook} {unsigned HOST_WIDE_INT} TARGET_CONST_ANCHOR
@en On some architectures it can take multiple instructions to synthesize
@en a constant.  If there is another constant already in a register that
@en is close enough in value then it is preferable that the new constant
@en is computed from this register using immediate addition or
@en subtraction.  We accomplish this through CSE.  Besides the value of
@en the constant we also add a lower and an upper constant anchor to the
@en available expressions.  These are then queried when encountering new
@en constants.  The anchors are computed by rounding the constant up and
@en down to a multiple of the value of @code{TARGET_CONST_ANCHOR}.
@en @code{TARGET_CONST_ANCHOR} should be the maximum positive value
@en accepted by immediate-add plus one.  We currently assume that the
@en value of @code{TARGET_CONST_ANCHOR} is a power of 2.  For example, on
@en MIPS, where add-immediate takes a 16-bit signed value,
@en @code{TARGET_CONST_ANCHOR} is set to @samp{0x8000}.  The default value
@en is zero, which disables this optimization.  @end deftypevr
有的体系结构它采用多指令来合成一个常数。如果一个寄存器中已经存在和这个常数值相近的另一个常数，那么它会优先使用寄存器中的这个常数值通过加减运算来得到新常数。我们通过CSE来完成这个功能。除了常数的值，我们还对可用表达式增加上下浮动的锚常量(a lower and an upper constant anchor)。这些在碰到新常数时将会被用到。这些锚通过对 @code{TARGET_CONST_ANCHOR} 值的倍数进行舍入而计算得到。@code{TARGET_CONST_ANCHOR}的值应该是立即数加加1(immediate-add plus one)所能接受的最大正数。我们现在假设 @code{TARGET_CONST_ANCHOR} 是2的乘方。例如，在MIPS上，立即数加的立即数为16位有符号值，而 @code{TARGET_CONST_ANCHOR} 被设置为 @samp{0x8000}。默认的值是0，也就是关掉了优化。
@end deftypevr
