
@c 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node 目标宏
@chapter 目标机描述宏和函数
@cindex machine description macros
@cindex target description macros
@cindex macros, target description
@cindex @file{tm.h} macros

除了文件@file{@var{machine}.md}，
机器描述还包括一个通常名为@file{@var{machine}.h}的C头文件和一个名为
@file{@var{machine}.c}的C源文件。
头文件定义了许多用来传达不适合@file{.md}文件框架的目标机器信息的宏。
文件@file{tm.h}应该为@file{@var{machine}.h}的一个链接。
头文件@file{config.h}包含@file{tm.h}，
并且大多数编译器源文件包含@file{config.h}。
源文件定义了变量@code{targetm}，
其为一个包含了与目标机器相关的函数指针和数据的结构体。
如果它们没有在GCC中的其它地方定义，@file{@var{machine}.c}还应该包含它们的定义，
其它通过宏调用的函数在@file{.h}文件中定义。

@menu
* 目标机结构::      @code{targetm}变量
* 驱动器::          控制驱动程序如何运行编译过程
* 运行时目标机::    定义像@option{-m68000}和@option{-m68020}这样的@samp{-m}选项
* 每个函数的数据::  定义每个函数的信息的数据结构体
* 存储布局::        定义数据的大小和对齐方式
* 类型布局::        定义基本用户数据类型的大小和属性
* 寄存器::          命名和描述硬件寄存器
* 寄存器类别::      定义硬件寄存器的类别
* 旧式约束::        定义机器特定约束的旧方式
* 栈和调用::        定义栈增长的方式和数量
* Varargs::         定义varargs宏
* Trampolines::     运行时建立的进入嵌套函数的代码
* 库调用::          控制库函数如何被隐式调用
* 寻址模式::        定义对内存操作数有效的寻址方式
* Anchored地址::    定义@option{-fsection-anchors}如何工作
* 条件代码::        定义insns如何更新条件代码
* 代价::            定义不同操作的相对开销
* 调度::            调整指令调度器的行为
* 段::              将存储拆分到代码，数据和其它的段
* PIC::             位置无关代码的宏
* 汇编格式::        定义如何输出insns和伪操作
* 调试信息::        定义调试输出的格式
* 浮点::            处理交叉编译器的浮点
* 机器模式切换::    插入模式切换指令
* 目标机属性::      定义目标机特定的@code{__attribute__}用法
* 模拟TLS::         模拟对TLS的支持
* MIPS协处理器::    对MIPS协处理器的支持，以及如何自定义
* PCH Target::      对预编译头文件的有效性检查
* C++ ABI::         控制C++ ABI的变动
* 其它::            其它
@end menu

@node 目标机结构
@section 全局变量@code{targetm}
@cindex target hooks
@cindex target functions

@deftypevar {struct gcc_target} targetm
目标机@file{.c}文件必须定义包含了目标机器相关的函数指针和数据的全局变量
@code{targetm}。该变量在@file{target.h}中声明；
@file{target-def.h}定义了用来初始化该变量的宏@code{TARGET_INITIALIZER}，
和结构体元素的缺省初始化宏。@file{.c}文件应该覆写这些缺省定义不合适的宏。例如：
@smallexample
#include "target.h"
#include "target-def.h"

/* @r{Initialize the GCC target structure.}  */

#undef TARGET_COMP_TYPE_ATTRIBUTES
#define TARGET_COMP_TYPE_ATTRIBUTES @var{machine}_comp_type_attributes

struct gcc_target targetm = TARGET_INITIALIZER;
@end smallexample
@end deftypevar

其中，宏应该通过这种方式在@file{.c}文件中被定义，
从而成为@code{targetm}结构体的一部分。
该宏将在下面作为具有函数原型的“目标钩子”来介绍。
在@file{.h}.h文件中定义的许多宏将来都会改为@code{targetm}结构体的一部分。

@node 驱动器
@section 控制编译驱动器，@file{gcc}
@cindex driver
@cindex controlling the compilation driver

@c prevent bad page break with this line
你可以控制编译驱动器。 

@defmac SWITCH_TAKES_ARG (@var{char})
一个C表达式，用来确定选项@option{-@var{char}}是否接受参数。
值应该为那个选项接受的参数个数，对于许多选项其为0。

缺省情况下，该宏被定义为@code{DEFAULT_SWITCH_TAKES_ARG}，
其可以正常处理标准的选项。除非你希望增加额外的接受参数的选项，
否则不需要定义@code{SWITCH_TAKES_ARG}。
任何重定义都应该先调用@code{DEFAULT_SWITCH_TAKES_ARG}，然后再检查额外的选项。
@end defmac

@defmac WORD_SWITCH_TAKES_ARG (@var{name})
一个C表达式，用来确定选项@option{-@var{name}}是否接受参数。
值应该为那个选项接受的参数个数，对于许多选项其为0。
该宏不同于@code{SWITCH_TAKES_ARG}，是用于选项名为多个字符的情况。

缺省情况下，该宏被定义为@code{DEFAULT_WORD_SWITCH_TAKES_ARG}，
其可以正常处理标准的选项。除非你希望增加额外的接受参数的选项，
否则不需要定义@code{WORD_SWITCH_TAKES_ARG}。
任何重定义都应该先调用@code{DEFAULT_WORD_SWITCH_TAKES_ARG}，然后再检查额外的选项。
@end defmac

@defmac SWITCH_CURTAILS_COMPILATION (@var{char})
一个C表达式，用来确定选项@option{-@var{char}}是否在生成可执行程序之前停止编译。
值为布尔型，如果选项确实停止生成可执行程序则为非0，否则为0。

缺省情况下，该宏被定义为@code{DEFAULT_SWITCH_CURTAILS_COMPILATION}，
其可以正常处理标准的选项。除非你希望增加额外的影响可执行程序生成的选项，
否则不需要定义@code{SWITCH_CURTAILS_COMPILATION}。
任何重定义都应该先调用@code{DEFAULT_SWITCH_CURTAILS_COMPILATION}，
然后再检查额外的选项。
@end defmac

@defmac SWITCHES_NEED_SPACES
一个值为字符串的C表达式，
用来枚举连接器在选项和其参数之间需要一个空格的那些选项。

如果该宏没有被定义，则缺省值为@code{""}。
@end defmac

@defmac TARGET_OPTION_TRANSLATE_TABLE
如果定义，则为字符串对（pairs of strings）列表，
其中第一个字符串为@file{gcc}驱动程序的一个可能的命令行目标，
第二个字符串为空格分隔的（不支持tab和其它whitespace）选项列表，
用来替换第一个选项。
定义该列表的目标机要负责确保结果是有效的。替换选项不可以为@code{--opt}风格的，
它们必须为@code{-opt}风格的。该宏的目的是为选择multilib提供一种替换机制，
例如通过一个选项可以打开许多选项，其中一些用来选择multilib。
例如，在下面这个无意义的定义中，
@option{-malt-abi}, @option{-EB}和@option{-mspoo}会导致不同的multilib被选择：

@smallexample
#define TARGET_OPTION_TRANSLATE_TABLE \
@{ "-fast",   "-march=fast-foo -malt-abi -I/usr/fast-foo" @}, \
@{ "-compat", "-EB -malign=4 -mspoo" @}
@end smallexample
@end defmac

@defmac DRIVER_SELF_SPECS
驱动器本身的specs列表。其应该为一个字符串数组的适当的初始化值，
并且不使用大括号包裹。

驱动器将这些specs应用到它自己的命令行上，位于加载缺省@file{specs}文件
（而不是由命令行指定的）和选择multilib目录或者运行任何子命令之间。
驱动器按照给定的顺序来应用它们，所以每个spec可以依赖于先前增加的选项。
还可以使用通常的方式，用@samp{%<@var{option}}来移除选项。

当一个port具有多个相互依赖的目标机选项时，该宏会有帮助。
它提供了一种标准化命令行的方法，使得其它specs的书写变得容易些。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac OPTION_DEFAULT_SPECS
一个specs列表，用于支持驱动器中的配置时（configure-time）缺省选项
（即，@option{--with}选项）。
其应该为一个结构体数组的适当的初始化值，每个元素包含两个字符串，
并且不带有最外层的大括号对。

字符串对的第一项为缺省名字。其必须匹配目标机的@file{config.gcc}中的代码。
第二项为一个spec，当那个缺省名字被指定的时候会被应用。
在spec中，字符串@samp{%(VALUE)}出现的所有地方都将被缺省值替换。

驱动器将这些specs应用到它自己的命令行上，
位于加载缺省@file{specs}文件和处理@code{DRIVER_SELF_SPECS}之间，
使用与@code{DRIVER_SELF_SPECS}相同的机制。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac CPP_SPEC
一个C字符串常量，告诉GCC驱动程序要传给CPP的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给CPP的选项。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac CPLUSPLUS_CPP_SPEC
该宏类似于@code{CPP_SPEC}，只不过是用于C++而不是C。如果你不定义该宏，
则会使用@code{CPP_SPEC}的值（如果存在）来替代。
@end defmac

@defmac CC1_SPEC
一个C字符串常量，告诉GCC驱动程序要传给@code{cc1}, @code{cc1plus}, 
@code{f771}和其它语言前端的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给前端的选项。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac CC1PLUS_SPEC
一个C字符串常量，告诉GCC驱动程序要传给@code{cc1plus}的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给@code{cc1plus}的选项。

如果不需要做任何事情的话，则不要定义该宏。
注意在CC1_SPEC中定义的所有选项已经被传给@code{cc1plus}，
所以不需要在CC1PLUS_SPEC中重复CC1_SPEC的内容。
@end defmac

@defmac ASM_SPEC
一个C字符串常量，告诉GCC驱动程序要传给汇编器的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给汇编器的选项。
参见文件@file{sun3.h}中的例子。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac ASM_FINAL_SPEC
一个C字符串常量，告诉GCC驱动程序如何在运行正常的汇编器之后，来运行任何清除程序。
通常，不需要该宏。参见文件@file{mips.h}中的例子。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac AS_NEEDS_DASH_FOR_PIPED_INPUT
如果驱动器应该传给汇编器一个由单横线@option{-}组成的参数，
来指示它从标准输入（其将为一个与编译器输出相连接的管道）读取时，
则定义该宏，并且不需要给出定义值。
该参数在任何指定输出文件名的@option{-o}选项后面被给出。

如果不定义该宏，则汇编器被认为在没有传给任何非选项参数时，才从标准输入读取。
如果你的汇编器根本不能从标准输入读取，则使用@samp{%@{pipe:%e@}}；
参见@file{mips.h}中的例子。
@end defmac

@defmac LINK_SPEC
一个C字符串常量，告诉GCC驱动程序要传给连接器的选项。
其还可以指定如何将你传给GCC的选项转换成GCC传给连接器的选项。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac LIB_SPEC
另一个C字符串常量，与@code{LINK_SPEC}的用法很相似。
两者的区别是@code{LIB_SPEC}用于传给连接器的命令的结尾处。

如果该宏没有被定义，则提供缺省的方式，从通常的地方来加载标准C库。
参见@file{gcc.c}。
@end defmac

@defmac LIBGCC_SPEC
另一个C字符串常量，
告诉GCC驱动程序如何以及什么时候将对@file{libgcc.a}的引用放到连接器的命令行中。
该常量同时被放在@code{LIB_SPEC}的值的前面和后面。

如果该宏没有被定义，则GCC驱动器提供了一个缺省的方式，
将字符串@option{-lgcc}传给连接器。
@end defmac

@defmac REAL_LIBGCC_SPEC
缺省情况下，如果@code{ENABLE_SHARED_LIBGCC}被定义，
则@code{LIBGCC_SPEC}不直接被驱动程序使用，而是根据命令行标记@option{-static}, 
@option{-shared}, @option{-static-libgcc}和@option{-shared-libgcc}的值，
进行修改，从而引用@file{libgcc.a}的不同版本。在一些目标机上，这些修改并不合适，
这样就可以定义@code{REAL_LIBGCC_SPEC}。
@code{REAL_LIBGCC_SPEC}告诉驱动器如何将对@file{libgcc}的引用放到连接器命令行中，
不过不像@code{LIBGCC_SPEC}，它不经过修改，被直接使用。
@end defmac

@defmac USE_LD_AS_NEEDED
一个宏，用于控制在@code{REAL_LIBGCC_SPEC}中提到的对@code{LIBGCC_SPEC}的修改。
如果非0，则会生成一个spec，当不使用任何@code{-static}, 
@code{-static-libgcc}或@code{-shared-libgcc}来连接的时候，
将使用–as-needed和静态异常处理库所在位置的共享libgcc。
@end defmac

@defmac LINK_EH_SPEC
如果定义，则该C字符串常量被增加到@code{LINK_SPEC}中。
当@code{USE_LD_AS_NEEDED}为0或者未定义时，
其还影响在@code{REAL_LIBGCC_SPEC}中提到的对@code{LIBGCC_SPEC}的修改。
@end defmac

@defmac STARTFILE_SPEC
另一个C字符串常量，与@code{LINK_SPEC}的用法很相似。
两者的不同之处是@code{STARTFILE_SPEC}用于传给连接器的命令的最开始处。

如果该宏没有被定义，则会提供一种缺省方式，
从通常的地方来加载标准C启动（startup）文件。参见@file{gcc.c}。
@end defmac

@defmac ENDFILE_SPEC
另一个C字符串常量，与@code{LINK_SPEC}的用法很相似。
两者的不同之处是@code{ENDFILE_SPEC}用于传给连接器的命令的最末尾处。

如果不需要做任何事情的话，则不要定义该宏。
@end defmac

@defmac THREAD_MODEL_SPEC
GCC @code{-v}将会打印GCC被配置使用的线程模式。然而，在有些平台上这是无法工作的，
像AIX 4.3。对于这样的平台，将@code{THREAD_MODEL_SPEC}定义为没有空格的字符串来
命名可识别的线程模式的名字。@code{%*}为该宏的缺省值，
将扩展为在@file{config.gcc}中设置的@code{thread_file}的值。
@end defmac

@defmac SYSROOT_SUFFIX_SPEC
定义该宏，当GCC使用sysroot被配置时，来为目标机的sysroot增加一个suffix。
这将导致GCC在sysroot+suffix下查找usr/lib等。
@end defmac

@defmac SYSROOT_HEADERS_SUFFIX_SPEC
定义该宏，当GCC使用sysroot被配置时，来为目标机的sysroot增加一个headers_suffix。
这将导致GCC将更新的sysroot+headers_suffix传给CPP，
使其在sysroot+headers_suffix下查找usr/include等。
@end defmac

@defmac EXTRA_SPECS
定义该宏，来提供放在@file{specs}文件中，
可以被各种specification，像@code{CC1_SPEC}，使用的额外的specification。

定义应该为一个结构体数组的初始化值，其包含一个字符串常量，
定义了specification的名字，以及一个字符串常量，提供相应的specification。

如果不需要做任何事情的话，则不要定义该宏。

当一种体系结构包含多个相关的目标机，所具有的各种@code{@dots{}_SPECS}彼此很相似
的时候，@code{EXTRA_SPECS}会很有用，维护者会希望有一个地方来集中保存这些定义。

例如，PowerPC System V.4的目标机使用@code{EXTRA_SPECS}，
在System V调用序列被使用时，来定义@code{_CALL_SYSV}，
在较老的基于AIX的调用序列被使用时，来定义@code{_CALL_AIX}。

@file{config/rs6000/rs6000.h}目标机文件这样定义:

@smallexample
#define EXTRA_SPECS \
  @{ "cpp_sysv_default", CPP_SYSV_DEFAULT @},

#define CPP_SYS_DEFAULT ""
@end smallexample

@file{config/rs6000/sysv.h}目标机文件这样定义:
@smallexample
#undef CPP_SPEC
#define CPP_SPEC \
"%@{posix: -D_POSIX_SOURCE @} \
%@{mcall-sysv: -D_CALL_SYSV @} \
%@{!mcall-sysv: %(cpp_sysv_default) @} \
%@{msoft-float: -D_SOFT_FLOAT@} %@{mcpu=403: -D_SOFT_FLOAT@}"

#undef CPP_SYSV_DEFAULT
#define CPP_SYSV_DEFAULT "-D_CALL_SYSV"
@end smallexample

而@file{config/rs6000/eabiaix.h}目标机文件将@code{CPP_SYSV_DEFAULT}定义为:

@smallexample
#undef CPP_SYSV_DEFAULT
#define CPP_SYSV_DEFAULT "-D_CALL_AIX"
@end smallexample
@end defmac

@defmac LINK_LIBGCC_SPECIAL_1
定义该宏，如果驱动程序应该找到库@file{libgcc.a}。
如果没有定义该宏，则驱动程序将参数@option{-lgcc}传给连接器，告诉连接器来查找。
@end defmac

@defmac LINK_GCC_C_SEQUENCE_SPEC
指定给连接器的libgcc和libc的顺序。缺省为@code{%G %L %G}。
@end defmac

@defmac LINK_COMMAND_SPEC
一个C字符串常量，给出执行连接器所需的完整的命令行。当定义时，
每次在@file{gcc.c}中对连接器命令行的修改，你都需要更新你的port。
因此，只有当你需要完全重定义所调用的连接器的命令行，并且没有其他方式来完成时，
才定义该宏。可以通过@code{LINK_GCC_C_SEQUENCE_SPEC}来替代该宏。
@end defmac

@defmac LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
一个非零值，
使得@command{collect2}从连接命令中移除重复的@option{-L@var{directory}}搜索目录。
如果移除重复的搜索目录会改变连接器的语法，则不要定义为非零。
@end defmac

@defmac MULTILIB_DEFAULTS
定义该宏为字符串数组的初始化C表达式，用来告诉驱动器程序对于该目标机，
哪些选项是缺省的，因此当使用@code{MULTILIB_OPTIONS}时，不需要单独处理。

如果在target makefile片段中没有定义@code{MULTILIB_OPTIONS}，
或者如果在@code{MULTILIB_OPTIONS}中列出的选项中没有被设为缺省的，
则不要定义该宏。参见@ref{目标机片段}。
@end defmac

@defmac RELATIVE_PREFIX_NOT_LINKDIR
定义该宏来告诉@command{gcc}，
如果前缀指示了一个绝对的文件名，
则其应该只将@option{-B}的前缀转换成@option{-L}连接器选项，
@end defmac

@defmac MD_EXEC_PREFIX
如果定义，该宏为一个可选前缀，其在@code{STANDARD_EXEC_PREFIX}之后进行尝试。
当使用@option{-b}选项，或者编译器被构建为交叉编译器时，
将不搜索@code{MD_EXEC_PREFIX}。如果你定义了@code{MD_EXEC_PREFIX}，
则要确保将其增加到@file{configure.in}中用于查找汇编器的目录列表中。
@end defmac

@defmac STANDARD_STARTFILE_PREFIX
定义该宏为C字符串常量，
如果你希望覆盖将@code{libdir}作为前缀来搜索起始文件@file{crt0.o}等的标准选择。
当构建为交叉编译器时，@code{STANDARD_STARTFILE_PREFIX}不被搜索。
@end defmac

@defmac STANDARD_STARTFILE_PREFIX_1
定义该宏为C字符串常量，如果你希望覆盖在缺省前缀之后，
将@code{/lib}作为前缀来搜索起始文件@file{crt0.o}等的标准选择。
当构建为交叉编译器时，@code{STANDARD_STARTFILE_PREFIX_1}不被搜索。
@end defmac

@defmac STANDARD_STARTFILE_PREFIX_2
定义该宏为C字符串常量，如果你希望覆盖在缺省前缀之后，
将@code{/lib}作为前缀来搜索起始文件@file{crt0.o}等的标准选择。
当构建为交叉编译器时，@code{STANDARD_STARTFILE_PREFIX_2}不被搜索。
@end defmac

@defmac MD_STARTFILE_PREFIX
如果定义，该宏提供了额外的前缀，在标准前缀之后被尝试。
当使用@option{-b}选项，或者编译器被构建为交叉编译器时，
将不搜索@code{MD_EXEC_PREFIX}。
@end defmac

@defmac MD_STARTFILE_PREFIX_1
如果定义，该宏提供了另一个额外的前缀，在标准前缀之后被尝试。
当使用@option{-b}选项，或者编译器被构建为交叉编译器时，其将不被搜索。
@end defmac

@defmac INIT_ENVIRONMENT
定义该宏为C字符串常量，如果你希望为驱动器调用的程序，例如汇编器和连接器，
来设置的环境变量。驱动器将该宏的值传给@code{putenv}来初始化需要的环境变量。
@end defmac

@defmac LOCAL_INCLUDE_DIR
定义该宏为C字符串常量，如果你希望覆写当尝试搜索局部头文件时，
将@file{/usr/local/include}作为缺省前缀的标准选择。
在搜索顺序中，@code{LOCAL_INCLUDE_DIR}位于@code{SYSTEM_INCLUDE_DIR}之前。

交叉编译器既不搜索@file{/usr/local/include}，也不搜索它的替换者。
@end defmac

@defmac MODIFY_TARGET_NAME
定义该宏，如果你希望定义命令行开关来修改缺省的目标机名字。

对于每个开关，你可以包含一个字符串，用来追加到配置名字的第一部分，
或者如果有的话，从配置名字中删除。该定义为一个结构体数组的初始化值。
每个数组元素具有三个元素：开关名（字符串常量，包括起始的横线），
一个枚举常量@code{ADD}或者@code{DELETE}，来表示插入或者删除字符串，
以及要插入或者删除的字符串（字符串常量）。

例如，在一台机器上，配置名字的结尾为@samp{64}表示其为64位目标机，
你想使用@option{-32}和@option{-64}开关来选择32位和64位目标机，则代码为

@smallexample
#define MODIFY_TARGET_NAME \
  @{ @{ "-32", DELETE, "64"@}, \
     @{"-64", ADD, "64"@}@}
@end smallexample
@end defmac

@defmac SYSTEM_INCLUDE_DIR
定义该宏作为C字符串常量，
如果你希望指定一个系统特定的目录在标准目录之前来搜索头文件。
在搜索顺序中，@code{SYSTEM_INCLUDE_DIR}位于@code{STANDARD_INCLUDE_DIR}之前。

交叉编译器不使用该宏，并且不搜索所指定的目录。
@end defmac

@defmac STANDARD_INCLUDE_DIR
定义该宏为C字符串常量，
如果你希望覆写将@file{/usr/include}作为缺省前缀来尝试搜索头文件的标准选择。

交叉编译器忽略该宏，并且不搜索@file{/usr/include}和它的替换者。
@end defmac

@defmac STANDARD_INCLUDE_COMPONENT
“component”对应于@code{STANDARD_INCLUDE_DIR}。关于组件的描述，
参见下面的@code{INCLUDE_DEFAULTS}。如果你没有定义该宏，则不使用组件。
@end defmac

@defmac INCLUDE_DEFAULTS
定义该宏，如果你希望覆写include文件的全部缺省搜索路径。对于一个本地编译器，
缺省搜索路径通常由@code{GCC_INCLUDE_DIR}, @code{LOCAL_INCLUDE_DIR}, 
@code{SYSTEM_INCLUDE_DIR}, @code{GPLUSPLUS_INCLUDE_DIR}和
@code{STANDARD_INCLUDE_DIR}组成。另外，@code{GPLUSPLUS_INCLUDE_DIR}和
@code{GCC_INCLUDE_DIR}由@file{Makefile}自动定义，并指定为GCC的私有搜索区域。
目录@code{GPLUSPLUS_INCLUDE_DIR}只用于C++程序。

该定义为一个结构体数组的初始化值。
每个数组元素具有四个元素：目录名（字符串常量），
组件名（也是字符串常量），一个标志用来指示只用于C++，
以及一个标志用来表示当编译C++时，对该目录下include进来的代码，
不需要使用@code{extern @samp{C}}进行包裹。
使用空元素来标记数组的结尾。

组件名指出了include文件属于什么GNU包，如果存在，则全部使用大写字母。
例如，可能为@samp{GCC}或@samp{BINUTILS}。
如果程序包是商家提供的操作系统的一部分，则将名字写为@samp{0}。

例如，这是用于VAX/VMS的定义:

@smallexample
#define INCLUDE_DEFAULTS \
@{                                       \
  @{ "GNU_GXX_INCLUDE:", "G++", 1, 1@},   \
  @{ "GNU_CC_INCLUDE:", "GCC", 0, 0@},    \
  @{ "SYS$SYSROOT:[SYSLIB.]", 0, 0, 0@},  \
  @{ ".", 0, 0, 0@},                      \
  @{ 0, 0, 0, 0@}                         \
@}
@end smallexample
@end defmac

这些是尝试查找exec文件的前缀顺序：

@enumerate
@item
用户使用@option{-B}指定的前缀。

@item
环境变量@code{GCC_EXEC_PREFIX}，
或者如果@code{GCC_EXEC_PREFIX}没有被设置并且编译器没有被安装到配置时的@var{prefix}处，
则搜索编译器实际被安装的位置。

@item
环境变量@code{COMPILER_PATH}指定的目录。

@item
宏@code{STANDARD_EXEC_PREFIX}，如果编译器安装在配置时的@var{prefix}处。

@item
位置@file{/usr/libexec/gcc/}，仅当是本地编译器。

@item
位置@file{/usr/lib/gcc/}，仅当是本地编译器。

@item
宏@code{MD_EXEC_PREFIX}，如果定义，仅当是本地编译器。
@end enumerate

这些是尝试查找启动文件的前缀顺序：

@enumerate
@item
用户使用@option{-B}指定的前缀。

@item
环境变量@code{GCC_EXEC_PREFIX}，或者基于工具链的安装位置被自动确定的值。

@item
由环境变量@code{LIBRARY_PATH}指定的目录（或者port特定的名字，只用于本地编译器，
交叉编译器不使用）。

@item
宏@code{STANDARD_EXEC_PREFIX}，但只当工具链被安装在配置的@var{prefix}处，
或者为本地编译器。

@item
位置@file{/usr/lib/gcc/}，仅当是本地编译器。

@item
宏@code{MD_EXEC_PREFIX}，如果定义，仅当是本地编译器。

@item
宏@code{MD_STARTFILE_PREFIX}，如果定义，
仅当为本地编译器，或者具有目标机系统根目录（system root）。

@item
宏@code{MD_STARTFILE_PREFIX_1}，如果定义，
仅当为本地编译器，或者具有目标机系统根目录。

@item
宏@code{STANDARD_STARTFILE_PREFIX}，带有任何sysroot的修改。
如果该路径相关，则会加上@code{GCC_EXEC_PREFIX}前缀和机器后缀，
或者@code{STANDARD_EXEC_PREFIX}和机器后缀。

@item
宏@code{STANDARD_STARTFILE_PREFIX_1}，仅当为本地编译器，
或者具有目标机系统根目录。该宏的缺省值为@file{/lib/}。

@item
宏@code{STANDARD_STARTFILE_PREFIX_2}，仅当为本地编译器，
或者具有目标机系统根目录。该宏的缺省值为@file{/usr/lib/}。
@end enumerate

@node 运行时目标机
@section 运行时的target指定
@cindex run-time target specification
@cindex predefined macros
@cindex target specifications

@c prevent bad page break with this line
这些是运行时的target指定。

@defmac TARGET_CPU_CPP_BUILTINS ()
该类函数的宏扩展成一块代码，其定义了target CPU内建的预处理器宏和断言，
使用函数@code{builtin_define}, @code{builtin_define_std}和
@code{builtin_assert}。当前端调用该宏时，其提供一个尾部的分号，
由于其已经结束了命令行选项处理，所以你的代码可以自由的使用那些结果。

@code{builtin_assert}接受一个字符串，按照传给命令行选项@option{-A}的形式，
例如@code{cpu=mips}，并且创建一个断言。@code{builtin_define}接受一个字符串，
按照传给命令行选项@option{-D}的形式，并且无条件的定义一个宏。

@code{builtin_define_std}接受一个字符串，来表示对象的名字。
如果其不在用户命名空间，则@code{builtin_define_std}无条件的定义它。否则，
定义一个具有两个前导下划线的版本，和另一个具有两个前导和后缀的下划线的版本。
例如传递@code{unix}，将定义@code{__unix}, @code{__unix__}以及可能的@code{unix}；
传递@code{_mips}，将定义@code{__mips}, @code{__mips__}和可能的@code{_mips}，
传递@code{_ABI64}，将指定义@code{_ABI64}。

你还可以测试被编译的C方言。变量@code{c_language}被设为@code{clk_c}, 
@code{clk_cplusplus}或者@code{clk_objective_c}。注意，如果我们在预处理汇编，
则该变量将为@code{clk_c}，不过类函数的宏@code{preprocessing_asm_p()}将返回真，
所以你可能要先检查它。如果你需要检查严格的ANSI，可以使用变量@code{flag_iso}。
类函数的宏@code{preprocessing_trad_p()}可以用来检查传统的预处理。
@end defmac

@defmac TARGET_OS_CPP_BUILTINS ()
类似于@code{TARGET_CPU_CPP_BUILTINS}，不过该宏是可选的，用于target操作系统。
@end defmac

@defmac TARGET_OBJFMT_CPP_BUILTINS ()
类似于@code{TARGET_CPU_CPP_BUILTINS}，不过该宏是可选的，用于target目标文件格式。
@file{elfos.h}使用该宏来定义@code{__ELF__}，所以你可能不需要自己定义。
@end defmac

@deftypevar {extern int} target_flags
该变量在@file{options.h}中声明，其在任何target特定的头文件之前被包含进来。
@end deftypevar

@deftypevar {Target Hook} int TARGET_DEFAULT_TARGET_FLAGS
该变量指定了@code{target_flags}的初始值。其缺省设置为0。
@end deftypevar

@cindex optional hardware or system features
@cindex features, optional, in system conventions

@deftypefn {Target Hook} bool TARGET_HANDLE_OPTION (size_t @var{code}, const char *@var{arg}, int @var{value})
该宏当用户指定了在@file{.opt}定义文件（参见@ref{选项}）中描述的target特定选项
时被调用。其可以做一些选项特定的处理，并且如果选项有效时应该返回真。
缺省的定义不做任何事情，只是返回真。

@var{code}指定了与选项相关的@code{OPT_@var{name}}枚举值；
这里的@var{name}只是对选项名的重写，将非字母和数字的字符替换为下划线。
@var{arg}指定了字符串参数，如果没有参数则为空。
如果选项被标记为@code{UInteger}（参见@ref{选项属性}），
则@var{value}为参数的数值。否则@var{value}为1，如果使用了正的选项，
为0如果使用了“no-”形式。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_HANDLE_C_OPTION (size_t @var{code}, const char *@var{arg}, int @var{value})
宏当用户指定了在@file{.opt}定义文件（参见“选项”）中描述的target特定的C语言家族
的选项时被调用。其可以做一些选项特定的处理，并且如果选项有效时应该返回真。
缺省的定义不做任何事情，只是返回假。

通常，你应该使用@code{TARGET_HANDLE_OPTION}来处理选项。然而，
如果选项处理只需要在C（和相关语言）前端中有效时，
你再使用@code{TARGET_HANDLE_C_OPTION}。
@end deftypefn

@defmac TARGET_VERSION
该宏为C语句，用来在@code{stderr}上打印表示特定机器描述选择的字符串。
每个机器描述都应该定义@code{TARGET_VERSION}。例如：

@smallexample
#ifdef MOTOROLA
#define TARGET_VERSION \
  fprintf (stderr, " (68k, Motorola syntax)");
#else
#define TARGET_VERSION \
  fprintf (stderr, " (68k, MIT syntax)");
#endif
@end smallexample
@end defmac

@defmac OVERRIDE_OPTIONS
有时特定的命令选项组合在特定的target机器上没有意义。
你可以定义该宏@code{OVERRIDE_OPTIONS}。
如果定义，则在所有的命令选项被解析后执行。

不要使用该宏来打开@option{-O}额外的优化。
使用@code{OPTIMIZATION_OPTIONS}来做这件事情。
@end defmac

@defmac C_COMMON_OVERRIDE_OPTIONS
类似于@code{OVERRIDE_OPTIONS}，但只用于C语言的前端（C, Objective-C, C++, 
Objective-C++），所以可以用于修改只存在于那些前端中的选项标志变量。
@end defmac

@defmac OPTIMIZATION_OPTIONS (@var{level}, @var{size})
一些机器可能需要改变不同优化级别所做的优化。该宏，如果定义，
将在优化级别被确定后，剩余命令选项被解析前执行。
该宏中设定的值将被作为其它命令行选项的缺省值。

@var{level}为指定的优化级别；如果指定@option{-O2}则为2，
如果指定@option{-O}则为1，如果都没指定则为0。

如果指定@option{-Os}则@var{size}为非零，否则为0。

不要使用该宏来改变不是机器特定的选项。
这些应该在所有支持的机器上的相同优化级别上被统一选择。
使用该宏来打开机器特定的优化。

不要在该宏中检查@code{write_symbols}！
@end defmac

@deftypefn {Target Hook} bool TARGET_HELP (void)
该钩子当用户在命令行中执行@option{--target-help}时被调用。
使得target可以显示在其@file{.opt}文件中找到的机器特定的命令行选项信息。
@end deftypefn

@defmac CAN_DEBUG_WITHOUT_FP
定义该宏，如果没有帧指针也可以进行调试。如果定义了该宏，
则只要指定@option{-O}，GCC便打开@option{-fomit-frame-pointer}选项。
@end defmac

@node 每个函数的数据
@section 为基于每个函数的信息定义数据结构
@cindex per-function data
@cindex data structures

如果target需要存储基于每个函数的信息，则GCC为此提供了一个宏和一些变量。
注意，只是使用静态变量来保存信息是一个糟糕的想法，因为GCC支持嵌套函数，
所以可能会在编码一个函数的中途遇到另一个。

GCC定义了称为@code{struct function}的数据结构体，
包含了特定于单个函数的所有数据。该结构体包含一个称为@code{machine}的域，
其类型为@code{struct machine_function *}，
可以被target用于指向它们自己的特定数据。

如果一个target需要基于每个函数的特定数据，
则应该定义类型@code{struct machine_function}，
以及宏@code{INIT_EXPANDERS}。
该宏将被用于初始化函数指针@code{init_machine_status}。
该指针将在下面说明。

一个典型的基于每个函数的target特定数据，
是用于创建一个RTX来存放含有函数返回地址的寄存器。
该RTX随后可以被用于实现@code{__builtin_return_address}函数。

注意，早期的GCC实现使用了单个数据区域来存放所有的基于每个函数的信息。
因此当开始处理嵌套函数时，旧式的基于每个函数的数据不得不被压入栈中，
并且当处理完成，还要出栈。
GCC曾经提供名为@code{save_machine_status}和@code{restore_machine_status}
函数指针来处理target特定信息的保存和恢复。
由于单数据区域的方法不再被使用了，这些指针也不再被支持。

@defmac INIT_EXPANDERS
被调用的宏，用来初始化任何target特定信息。
该宏在任何RTL生成开始之前，基于每个函数被调用一次。
该宏的目的是允许函数指针@code{init_machine_status}的初始化。
@end defmac

@deftypevar {void (*)(struct function *)} init_machine_status
如果该函数指针非空，则会在函数编译开始之前，基于每个函数被调用一次，
用于允许target来执行对@code{struct function}结构体的任何target特定初始化。
它将被用于初始化那个结构体的@code{machine}域。

结构体@code{struct machine_function}将期望被GC来释放。通常，
它们所引用的任何内存都必须使用@code{ggc_alloc}来分配，包括结构体本身。
@end deftypevar

@node 存储布局
@section 存储布局
@cindex storage layout

注意该表格中的宏定义中，对于以bit为单位的大小或对齐，不需要为常量。
它们可以为引用了静态变量的C表达式，例如@code{target_flags}。
参见@ref{运行时目标机}。

@defmac BITS_BIG_ENDIAN
定义该宏的值为1，如果字节中的最高有效位具有最低编号；否则定义其值为0。
这意味着bit-field指令从最高有效位计数。如果机器没有bit-field指令，
则该宏也需要被定义，但定义什么值都无所谓。该宏不需要为一个常量。

该宏不影响结构体域被打包成字节或者字的方式；
那是由@code{BYTES_BIG_ENDIAN}来控制的。
@end defmac

@defmac BYTES_BIG_ENDIAN
定义该宏的值为1，如果字中的最高有效字节具有最低编号。该宏不需要为一个常量。
@end defmac

@defmac WORDS_BIG_ENDIAN
定义该宏的值为1，如果在多字（multiword）对象中，最高有效字具有最低编号。
这同时应用于内存位置和寄存器中；
GCC从根本上假设在内存中的字的顺序与在寄存器中的一样。该宏不需要为一个常量。
@end defmac

@defmac LIBGCC2_WORDS_BIG_ENDIAN
定义该宏如果@code{WORDS_BIG_ENDIAN}不是常量。该宏必须为一个常量值，
其与@code{WORDS_BIG_ENDIAN}的具有相同的含义，
并只用于编译@file{libgcc2.c}的时候。通常该值会根据预处理器定义来设置。
@end defmac

@defmac FLOAT_WORDS_BIG_ENDIAN
定义该宏值为1，如果@code{DFmode}, @code{XFmode}或@code{TFmode}浮点数被存储在
内存中，并且包含符号位的字位于最低地址；否则值为0。该宏不需要为一个常量。

你不需要定义该宏，如果顺序与多字整数相同。
@end defmac

@defmac BITS_PER_UNIT
定义该宏为一个可寻址的存储单元（字节）中的位数。如果没有定义，缺省为8。
@end defmac

@defmac BITS_PER_WORD
字的位数。如果没有定义，缺省为@code{BITS_PER_UNIT * UNITS_PER_WORD}。
@end defmac

@defmac MAX_BITS_PER_WORD
字的最大位数。如果没有定义，缺省为@code{BITS_PER_WORD}。
否则其为一个常量，为@code{BITS_PER_WORD}在运行时可以具有的最大值。
@end defmac

@defmac UNITS_PER_WORD
字中的存储单元数；通常为通用目的寄存器的大小，2的1到8次幂。
@end defmac

@defmac MIN_UNITS_PER_WORD
字中的最小存储单元数。如果没有定义，缺省为@code{UNITS_PER_WORD}。否则，
其为一个常量，为@code{UNITS_PER_WORD}在运行时可以具有的最小值。
@end defmac

@defmac UNITS_PER_SIMD_WORD (@var{mode})
向量化可以产生的向量的单元数。缺省等于@code{UNITS_PER_WORD}，
因为向量化可以在即使没有专门的@acronym{SIMD}硬件的情况下做一些转换。
@end defmac

@defmac POINTER_SIZE
指针的宽度，位数。必须指定不比@code{Pmode}宽的值。
如果其不等于@code{Pmode}的宽度，则必须定义@code{POINTERS_EXTEND_UNSIGNED}。
如果没有指定一个值，则缺省为@code{BITS_PER_WORD}。
@end defmac

@defmac POINTERS_EXTEND_UNSIGNED
一个C表达式，用来确定指针应该如何从@code{ptr_mode}扩展为@code{Pmode}或者
@code{word_mode}。如果指针应该被零扩展，则其比0大，如果应该被符号扩展则为0，
如果需要其它转换方式则为负。对于最后一种情况，
扩展通过target的@code{ptr_extend}指令来完成。

你不需要定义该宏，如果@code{ptr_mode}, @code{Pmode}和@code{word_mode}都为相同的宽度。
@end defmac

@defmac PROMOTE_MODE (@var{m}, @var{unsignedp}, @var{type})
用来更新@var{m}和@var{unsignedp}，当一个类型为@var{type}并且具有特定的机器模式
的对象要被存储到寄存器中时。该宏只在@var{type}为一个标量类型时才被调用。

在大多数RISC机器上，只有作用于在整个寄存器上的运算，
定义该宏将@var{m}设为为@code{word_mode}，
如果@var{m}为一个比@code{BITS_PER_WORD}窄的整数模式。在大多数情况下，
只有整数模式应该被加宽，因为宽精度的浮点运算通常比相应的窄精度的运算代价要更高。

大多数机器，宏定义不改变@var{unsignedp}。然而，
一些机器具有优先处理特定模式的有符号或者无符号的指令。例如，在DEC Alpha上，
32位load和32位add指令会将结果有符号扩展为64位。在这样的机器上，
根据扩展的类型来设置@var{unsignedp}会更加有效。

如果从来不会修改@var{m}，则不要定义该宏。
@end defmac

@defmac PROMOTE_FUNCTION_MODE
类似于@code{PROMOTE_MODE}，但应用于输出的函数参数，或者函数返回值，
分别由@code{TARGET_PROMOTE_FUNCTION_ARGS}和@code{TARGET_PROMOTE_FUNCTION_RETURN}指定。

缺省为@code{PROMOTE_MODE}。
@end defmac

@deftypefn {Target Hook} bool TARGET_PROMOTE_FUNCTION_ARGS (tree @var{fntype})
该target钩子应该返回@code{true}，
如果由@code{PROMOTE_FUNCTION_MODE}描述的提升应该应用于输出的函数参数。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_PROMOTE_FUNCTION_RETURN (tree @var{fntype})
该target钩子应该返回@code{true}，
如果由@code{PROMOTE_FUNCTION_MODE}描述的提升应该应用于函数返回值。

如果该target钩子返回@code{true}，
则@code{TARGET_FUNCTION_VALUE}必须执行与@code{PROMOTE_FUNCTION_MODE}相同的提升。
@end deftypefn

@defmac PARM_BOUNDARY
函数参数在栈上的对齐方式，位数。所有栈参数都接受这样的对齐，
而不论数据类型是什么。在大多数机器上，这与整数的大小相同。
@end defmac

@defmac STACK_BOUNDARY
定义该宏为硬件要求的在该机器上的栈指针的最小对齐。定义为一个C表达式，
为所要的对齐（位数）。该值作为缺省值使用，
如果没有定义@code{PREFERRED_STACK_BOUNDARY}。在大多数机器上，
这应该与@code{PARM_BOUNDARY}相同。
@end defmac

@defmac PREFERRED_STACK_BOUNDARY
定义该宏，如果你希望对栈指针维持一个特定的对齐，大于硬件要求的对齐。
定义为一个C表达式，为所要的对齐（位数）。
该宏必须等于或大于@code{STACK_BOUNDARY}。
@end defmac

@defmac INCOMING_STACK_BOUNDARY
Define this macro if the incoming stack boundary may be different
from @code{PREFERRED_STACK_BOUNDARY}.  This macro must evaluate
to a value equal to or larger than @code{STACK_BOUNDARY}.
@end defmac

@defmac FUNCTION_BOUNDARY
函数入口点所需的对齐位数。
@end defmac

@defmac BIGGEST_ALIGNMENT
该机器上任何数据类型可以需要的最大对齐位数。注意这不是所支持的最大对齐，
而是如果违反该对齐则可能会造成错误。
@end defmac

@defmac MALLOC_ABI_ALIGNMENT
Alignment, in bits, a C conformant malloc implementation has to
provide.  If not defined, the default value is @code{BITS_PER_WORD}.
@end defmac

@defmac ATTRIBUTE_ALIGNED_VALUE
Alignment used by the @code{__attribute__ ((aligned))} construct.  If
not defined, the default value is @code{BIGGEST_ALIGNMENT}.
@end defmac

@defmac MINIMUM_ATOMIC_ALIGNMENT
如果被定义，则为最小对齐位数，可以分给一个对象并且在一个操作中被应用，
而不需要干扰任何附近的对象。通常为@code{BITS_PER_UNIT}，
但在没有字节或半字的存储运算的机器上可以更大些。
@end defmac

@defmac BIGGEST_FIELD_ALIGNMENT
任何结构体或者联合体域在该机器上需要的最大对齐。如果被定义，
这将只覆盖结构体和联合体的域的@code{BIGGEST_ALIGNMENT}，
除非域对齐已经通过@code{__attribute__ ((aligned (@var{n})))}设置。
@end defmac

@defmac ADJUST_FIELD_ALIGN (@var{field}, @var{computed})
一个表达式，为结构体域@var{field}的对齐方式，如果对齐方式是按照通常方式计算
（包括应用@code{BIGGEST_ALIGNMENT}和@code{BIGGEST_FIELD_ALIGNMENT}）。
其只覆盖没有通过@code{__attribute__ ((aligned (@var{n})))}设置的域。
@end defmac

@defmac MAX_STACK_ALIGNMENT
Biggest stack alignment guaranteed by the backend.  Use this macro
to specify the maximum alignment of a variable on stack.

If not defined, the default value is @code{STACK_BOUNDARY}.

@c FIXME: The default should be @code{PREFERRED_STACK_BOUNDARY}.
@c But the fix for PR 32893 indicates that we can only guarantee
@c maximum stack alignment on stack up to @code{STACK_BOUNDARY}, not
@c @code{PREFERRED_STACK_BOUNDARY}, if stack alignment isn't supported.
@end defmac

@defmac MAX_OFILE_ALIGNMENT
由该机器的目标文件格式所支持的最大对齐。使用该宏来限制可以使用
@code{__attribute__ ((aligned (@var{n})))}结构来指定的对齐。
如果没有定义，则缺省值为@code{BIGGEST_ALIGNMENT}。

在使用ELF的系统上，缺省（在@file{config/elfos.h}中）为在32位host上可以表示的
32位ELF section对齐，即@samp{(((unsigned HOST_WIDEST_INT) 1 << 28) * 8)}。
在32位ELF上，最大支持的section对齐位数是@samp{(0x80000000 * 8)}，
但这在32位host上无法表示。
@end defmac

@defmac DATA_ALIGNMENT (@var{type}, @var{basic-align})
如果定义，则为一个C表达式，来计算在静态存储中的变量的对齐。
@var{type}为数据类型，@var{basic-align}为对象通常具有的对齐。
该宏的值被用于替代那个对齐，并应用的对象上。

如果该宏没有定义，则使用@var{basic-align}。

@findex strcpy
该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。
另一种用法是使得字符数组按照字对齐，这样@code{strcpy}调用可以通过内联方式完成。
@end defmac

@defmac CONSTANT_ALIGNMENT (@var{constant}, @var{basic-align})
如果定义，为一个C表达式，来计算放在内存中的常量的对齐。@var{constant}为常量，
@var{basic-align}为该对象通常具有的对齐。该宏的值被用于替代那个对齐，
并应用的对象上。

如果该宏没有定义，则使用@var{basic-align}。

该宏的典型用法为增加字符串常量的对齐，使其为字对齐，
这样@code{strcpy}调用可以通过内联方式完成。
@end defmac

@defmac LOCAL_ALIGNMENT (@var{type}, @var{basic-align})
如果定义，为一个C表达式，来计算在局部存储中的对象的对齐。@var{type}为数据类型，
@var{basic-align}为对象通常的对齐。该宏的值被用于替代那个对齐，并应用的对象上。

如果该宏没有定义，则使用@var{basic-align}。

该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。
@end defmac

@defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})
If defined, a C expression to compute the alignment for stack slot.
@var{type} is the data type, @var{mode} is the widest mode available,
and @var{basic-align} is the alignment that the slot would ordinarily
have.  The value of this macro is used instead of that alignment to
align the slot.

If this macro is not defined, then @var{basic-align} is used when
@var{type} is @code{NULL}.  Otherwise, @code{LOCAL_ALIGNMENT} will
be used.

This macro is to set alignment of stack slot to the maximum alignment
of all possible modes which the slot may have.
@end defmac

@defmac LOCAL_DECL_ALIGNMENT (@var{decl})
If defined, a C expression to compute the alignment for a local
variable @var{decl}.

If this macro is not defined, then
@code{LOCAL_ALIGNMENT (TREE_TYPE (@var{decl}), DECL_ALIGN (@var{decl}))}
is used.

One use of this macro is to increase alignment of medium-size data to
make it all fit in fewer cache lines.
@end defmac

@defmac EMPTY_FIELD_BOUNDARY
允许像@code{int : 0;}；这样的空域的结构体位域的对齐位数。

如果@code{PCC_BITFIELD_TYPE_MATTERS}为真，则其覆盖该宏。
@end defmac

@defmac STRUCTURE_SIZE_BOUNDARY
任何结构体或联合体的大小必须为该位数的倍数。
每个结构体或联合体的大小都将被舍入到该位数的一个倍数。

如果没有定义该宏，则缺省与@code{BITS_PER_UNIT}相同。
@end defmac

@defmac STRICT_ALIGNMENT
定义该宏值为1，如果给定数据不在通常对齐方式上，则指令无法工作。
如果对于这种情况指令只不过是变慢，则定义该宏为0。
@end defmac

@defmac PCC_BITFIELD_TYPE_MATTERS
定义该宏，如果你希望仿效许多其它C编译器处理位域和包含它们的结构体的对齐方式。

该行为是书写为命名位域（@code{int},@code{short}或其它整数类型）的类型被实施
用于整个结构体的对齐，就好像结构体包含了一个该类型的普通的域。另外，
位域放在结构体中，使得其将适合这样的域，而不会跨越边界。

这样，大多数机器上，书写为@code{int}的命名位域将不会跨越一个四字节的边界，
并将使得整个结构体为四字节对齐。（可能不使用四字节对齐；其由其它对齐参数控制。）

一个没有命名的位域将不会影响包含结构体的对齐。

如果定义了该宏，则其定义为一个C表达式；该表达式的非0值会使用这样方式。

注意如果该宏没有定义，或者其值为0，则一些位域可能跨越多于一个的对齐边界。
编译器可以支持这种引用，如果有@samp{insv}, 
@samp{extv}和@samp{extzv} insns可以直接引用内存。

其它已知的可以使位域工作的的方式为定义@code{STRUCTURE_SIZE_BOUNDARY}和@code{BIGGEST_ALIGNMENT}一样大。

除非机器具有位域指令或者你按照那种方式定义了@code{STRUCTURE_SIZE_BOUNDARY}，
否则你必须定义@code{PCC_BITFIELD_TYPE_MATTERS}具有非0值。

如果你的目标是使得GCC使用与其它编译器相同的约定来布局位域，
则这里有一种方式可以调查其它编译器是如何做的。编译运行该程序：

@smallexample
struct foo1
@{
  char x;
  char :0;
  char y;
@};

struct foo2
@{
  char x;
  int :0;
  char y;
@};

main ()
@{
  printf ("Size of foo1 is %d\n",
          sizeof (struct foo1));
  printf ("Size of foo2 is %d\n",
          sizeof (struct foo2));
  exit (0);
@}
@end smallexample

如果其打印2和5，则编译器的行为就是你通过@code{PCC_BITFIELD_TYPE_MATTERS}获得的效果。
@end defmac

@defmac BITFIELD_NBYTES_LIMITED
跟@code{PCC_BITFIELD_TYPE_MATTERS}相似，除了它只影响结构体中的位域的对齐。
@end defmac

@deftypefn {Target Hook} bool TARGET_ALIGN_ANON_BITFIELD (void)
当@code{PCC_BITFIELD_TYPE_MATTERS}为真，
该钩子将确定未命名位域是否要影响包含它的结构体的对齐。
钩子应该返回真，如果结构体应该继承未命名位域的类型所要求的对齐。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_NARROW_VOLATILE_BITFIELD (void)
该target钩子应该返回@code{true}，如果访问volatile位域应该尽可能使用最窄的机器模式。其应该返回@code{false}，如果这些访问应该使用位域的容器的类型。

缺省为@code{!TARGET_STRICT_ALIGN}。
@end deftypefn

@defmac MEMBER_TYPE_FORCES_BLK (@var{field}, @var{mode})
返回1，如果一个包含@var{field}的结构体或者数组应该使用@code{BLKMODE}模式来访问。

如果@var{field}为结构体中唯一的域，则@var{mode}为它的机器模式，
否则@var{mode}为VOIDmode。

通常，不需要该宏。
@end defmac

@defmac ROUND_TYPE_ALIGN (@var{type}, @var{computed}, @var{specified})
定义该宏为一个表达式，为一个类型（由作为树节点的@var{type}给定）的对齐，
如果按照通常方式计算的对齐方式为@var{computed}并且显示指定的对齐方式为@var{specified}。

缺省是使用@var{specified}，如果其更大；
否则使用@var{computed}和@code{BIGGEST_ALIGNMENT}中较小的。
@end defmac

@defmac MAX_FIXED_MODE_SIZE
一个整数表达式，为实际应该被使用的最大的整数机器模式的位数。
所有该大小或者更小一些的整数机器模式都可以用于结构体和联合体。
如果哦没有定义该宏，则假设为@code{GET_MODE_BITSIZE (DImode)}。
@end defmac

@defmac STACK_SAVEAREA_MODE (@var{save_level})
如果定义，则为一个@code{enum machine_mode}类型的表达式，
指定名为@code{save_stack_@var{level}}的指令模式（参见@ref{标准名字}）的save区域操作数的机器模式。
@var{save_level}为@code{SAVE_BLOCK}, @code{SAVE_FUNCTION}或@code{SAVE_NONLOCAL}中之一。

你不需要定义该宏，如果其总是返回@code{Pmode}。你通常将会定义该宏，
如果@code{save_stack_@var{level}}指令模式需要同时支持32和64位机器模式。
@end defmac

@defmac STACK_SIZE_MODE
如果定义，为一个@code{enum machine_mode}类型的表达式，
指定名为@code{allocate_stack}的指令模式（参见@ref{标准名字}）的size increment操作数的机器模式。

你不需要定义该宏，如果其总是返回@code{word_mode}。你通常将会定义该宏，
如果@code{allocate_stack}指令模式需要同时支持32和64位机器模式。
@end defmac

@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_CMP_RETURN_MODE ()
该target钩子应该返回扩展为libgcc调用的比较指令的返回值的机器模式。
如果没有定义，则返回@code{word_mode}，其对于大多数target是正确的。
@end deftypefn

@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_SHIFT_COUNT_MODE ()
该target钩子应该返回扩展为libgcc调用的移位指令的shift count操作数的机器模式。
如果没有定义，则返回@code{word_mode}，其对于大多数target是正确的。
@end deftypefn

@defmac ROUND_TOWARDS_ZERO
如果定义，该宏应该为真，如果舍入的模式是朝向0。

定义该宏只影响@file{libgcc.a}模拟浮点算术的方式。

不定义该宏，等价于其返回0。
@end defmac

@defmac LARGEST_EXPONENT_IS_NORMAL (@var{size})
该宏应该返回真，如果具有@var{size}位数的浮点不具有NaN或无穷的表示，
但是使用最大的普通数的指数来替代表示。

定义该宏只影响@file{libgcc.a}模拟浮点算术的方式。

该宏缺省定义对所有的size都返回假。
@end defmac

@deftypefn {Target Hook} bool TARGET_VECTOR_OPAQUE_P (tree @var{type})
This target hook should return @code{true} a vector is opaque.  That
is, if no cast is needed when copying a vector value of type
@var{type} into another vector lvalue of the same size.  Vector opaque
types cannot be initialized.  The default is that there are no such
types.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_MS_BITFIELD_LAYOUT_P (tree @var{record_type})
This target hook returns @code{true} if bit-fields in the given
@var{record_type} are to be laid out following the rules of Microsoft
Visual C/C++, namely: (i) a bit-field won't share the same storage
unit with the previous bit-field if their underlying types have
different sizes, and the bit-field will be aligned to the highest
alignment of the underlying types of itself and of the previous
bit-field; (ii) a zero-sized bit-field will affect the alignment of
the whole enclosing structure, even if it is unnamed; except that
(iii) a zero-sized bit-field will be disregarded unless it follows
another bit-field of nonzero size.  If this hook returns @code{true},
other macros that control bit-field layout are ignored.

When a bit-field is inserted into a packed record, the whole size
of the underlying type is used by one or more same-size adjacent
bit-fields (that is, if its long:3, 32 bits is used in the record,
and any additional adjacent long bit-fields are packed into the same
chunk of 32 bits.  However, if the size changes, a new field of that
size is allocated).  In an unpacked record, this is the same as using
alignment, but not equivalent when packing.

If both MS bit-fields and @samp{__attribute__((packed))} are used,
the latter will take precedence.  If @samp{__attribute__((packed))} is
used on a single field when MS bit-fields are in use, it will take
precedence for that field, but the alignment of the rest of the structure
may affect its placement.
@end deftypefn

@deftypefn {Target Hook} {bool} TARGET_DECIMAL_FLOAT_SUPPORTED_P (void)
返回真，如果target支持十进制浮点。
@end deftypefn

@deftypefn {Target Hook} {bool} TARGET_FIXED_POINT_SUPPORTED_P (void)
返回真，如果target支持定点算术。
@end deftypefn

@deftypefn {Target Hook} void TARGET_EXPAND_TO_RTL_HOOK (void)
该钩子在扩展为rtl之前被调用，允许target在扩展前执行额外的实例化或者分析。
例如，rs6000port使用它来分配scratch栈槽，当被扩展的函数具有任何SDmode使用时，
用于在内存和浮点寄存器之间复制SDmode值。
@end deftypefn

@deftypefn {Target Hook} void TARGET_INSTANTIATE_DECLS (void)
该钩子允许后端执行额外的rtl实例化，这些实际上不存在于任何insn中，但在之后会有。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_MANGLE_TYPE (tree @var{type})
If your target defines any fundamental types, or any types your target
uses should be mangled differently from the default, define this hook
to return the appropriate encoding for these types as part of a C++
mangled name.  The @var{type} argument is the tree structure representing
the type to be mangled.  The hook may be applied to trees which are
not target-specific fundamental types; it should return @code{NULL}
for all such types, as well as arguments it does not recognize.  If the
return value is not @code{NULL}, it must point to a statically-allocated
string constant.

Target-specific fundamental types might be new fundamental types or
qualified versions of ordinary fundamental types.  Encode new
fundamental types as @samp{@w{u @var{n} @var{name}}}, where @var{name}
is the name used for the type in source code, and @var{n} is the
length of @var{name} in decimal.  Encode qualified versions of
ordinary types as @samp{@w{U @var{n} @var{name} @var{code}}}, where
@var{name} is the name used for the type qualifier in source code,
@var{n} is the length of @var{name} as above, and @var{code} is the
code used to represent the unqualified version of this type.  (See
@code{write_builtin_type} in @file{cp/mangle.c} for the list of
codes.)  In both cases the spaces are for clarity; do not include any
spaces in your string.

This hook is applied to types prior to typedef resolution.  If the mangled
name for a particular type depends only on that type's main variant, you
can perform typedef resolution yourself using @code{TYPE_MAIN_VARIANT}
before mangling.

The default version of this hook always returns @code{NULL}, which is
appropriate for a target that does not define any new fundamental
types.
@end deftypefn

@node 类型布局
@section 源语言的数据类型布局

这些宏定义了在被编译的程序中使用的标准基础数据类型的大小和其它特征。
不像之前章节中的宏，这些是应用到C和相关语言的特定特征上，
而不是存储布局的基础方面。

@defmac INT_TYPE_SIZE
一个C表达式，为在target机器上类型@code{int}的位大小。
如果没有定义，缺省为一个字。
@end defmac

@defmac SHORT_TYPE_SIZE
一个C表达式，为在target机器上类型@code{short}的位大小。如果没有定义，
缺省为半个字。（如果比一个存储单元小，则会向上舍入为一个单元。）
@end defmac

@defmac LONG_TYPE_SIZE
一个C表达式，为在target机器上类型@code{long}的位大小。
如果没有定义，缺省为一个字。
@end defmac

@defmac ADA_LONG_TYPE_SIZE
在一些机器上，本地Ada编译器使用的类型@code{long}的大小与C使用的不相同。
这种情况下，定义该宏为一个C表达式用于那个类型的大小。如果没有定义，
则缺省为@code{LONG_TYPE_SIZE}的值。
@end defmac

@defmac LONG_LONG_TYPE_SIZE
一个C表达式，为在target机器上类型@code{long long}的位大小。如果没有定义，
缺省为两个字。如果你想在你的机器上支持GNU Ada，则该宏的值最少必须为64。
@end defmac

@defmac CHAR_TYPE_SIZE
一个C表达式，为在target机器上类型@code{char}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT}。
@end defmac

@defmac BOOL_TYPE_SIZE
一个C表达式，为在target机器上C++类型@code{bool}和C99类型@code{_Bool}的位大小。
如果没有定义，并且通常不会定义，缺省为@code{CHAR_TYPE_SIZE}。
@end defmac

@defmac FLOAT_TYPE_SIZE
一个C表达式，为在target机器上类型@code{float}的位大小。
如果没有定义，缺省为一个字。
@end defmac

@defmac DOUBLE_TYPE_SIZE
一个C表达式，为在target机器上类型@code{double}的位大小。
如果没有定义，缺省为两个字。
@end defmac

@defmac LONG_DOUBLE_TYPE_SIZE
一个C表达式，为在target机器上类型@code{long double}的位大小。
如果没有定义，缺省为两个字。
@end defmac

@defmac SHORT_FRACT_TYPE_SIZE
一个C表达式，为在target机器上类型@code{short _Fract}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT}。
@end defmac

@defmac FRACT_TYPE_SIZE
一个C表达式，为在target机器上类型@code{_Fract}的位大小。如果没有定义，
缺省为@code{BITS_PER_UNIT * 2}。
@end defmac

@defmac LONG_FRACT_TYPE_SIZE
一个C表达式，为在target机器上类型@code{long _Fract}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 4}。
@end defmac

@defmac LONG_LONG_FRACT_TYPE_SIZE
一个C表达式，为在target机器上类型@code{long long _Fract}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 8}。
@end defmac

@defmac SHORT_ACCUM_TYPE_SIZE
一个C表达式，为在target机器上类型@code{short _Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 2}。
@end defmac

@defmac ACCUM_TYPE_SIZE
一个C表达式，为在target机器上类型@code{_Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 4}。
@end defmac

@defmac LONG_ACCUM_TYPE_SIZE
一个C表达式，为在target机器上类型@code{long _Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 8}。
@end defmac

@defmac LONG_LONG_ACCUM_TYPE_SIZE
一个C表达式，为在target机器上类型@code{long long _Accum}的位大小。
如果没有定义，缺省为@code{BITS_PER_UNIT * 16}。
@end defmac

@defmac LIBGCC2_LONG_DOUBLE_TYPE_SIZE
定义该宏，如果@code{LONG_DOUBLE_TYPE_SIZE}不是常量或者如果你想让@file{libgcc2.a}
中具有大小不是@code{LONG_DOUBLE_TYPE_SIZE}的程序。如果没有定义，
缺省为@code{LONG_DOUBLE_TYPE_SIZE}。
@end defmac

@defmac LIBGCC2_HAS_DF_MODE
定义该宏，如果@code{LIBGCC2_DOUBLE_TYPE_SIZE}和
@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}都不是@code{DFmode}，
但是你还想让@file{libgcc2.a}中具有@code{DFmode}的程序。如果没有定义，
并且@code{LIBGCC2_DOUBLE_TYPE_SIZE}或@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}为64，
则缺省为1，否则为0。
@end defmac

@defmac LIBGCC2_HAS_XF_MODE
定义该宏，如果@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}不是@code{XFmode}，
但是你还想让@file{libgcc2.a}中具有@code{XFmode}的程序。如果没有定义，
并且@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}为80，则缺省为1，否则为0。
@end defmac

@defmac LIBGCC2_HAS_TF_MODE
定义该宏，如果@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}不是@code{TFmode}，
但是你还想让@file{libgcc2.a}中具有@code{TFmode}的程序。如果没有定义，
并且@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}为128，则缺省为1，否则为0。
@end defmac

@defmac SF_SIZE
@defmacx DF_SIZE
@defmacx XF_SIZE
@defmacx TF_SIZE
定义这些宏为@code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}值的尾数
位大小，如果在@file{libgcc2.h}中的缺省定义不合适。缺省的，
@code{FLT_MANT_DIG}用于@code{SF_SIZE}, @code{LDBL_MANT_DIG}用于@code{XF_SIZE}和
@code{TF_SIZE}，并且@code{DBL_MANT_DIG}或@code{LDBL_MANT_DIG}用于
@code{DF_SIZE}，根据@code{LIBGCC2_DOUBLE_TYPE_SIZE}或
@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}是否为64。
@end defmac

@defmac TARGET_FLT_EVAL_METHOD
一个C表达式，为@file{float.h}中的@code{FLT_EVAL_METHOD}的值。
如果没有定义，则@code{FLT_EVAL_METHOD}的值将为0。
@end defmac

@defmac WIDEST_HARDWARE_FP_SIZE
一个C表达式，为硬件支持的最宽浮点格式的位数。如果定义该宏，
则必须指定一个小于或等于@code{LONG_DOUBLE_TYPE_SIZE}的值。如果没有定义，
则缺省为@code{LONG_DOUBLE_TYPE_SIZE}的值。
@end defmac

@defmac DEFAULT_SIGNED_CHAR
一个表达式，其值为1或者0，根据类型@code{char}缺省应该为有符号的还是无符号的。
用户总是可以使用选项@option{-fsigned-char}和@option{-funsigned-char}来覆盖该缺省定义。
@end defmac

@deftypefn {Target Hook} bool TARGET_DEFAULT_SHORT_ENUMS (void)
该target钩子应该返回真，如果编译器应该为@code{enum}类型设置为可以表示该类型值
范围的字节数。其应该返回假，如果所有的@code{enum}类型应该按照@code{int}类型的
方式来分配。

缺省为返回假。
@end deftypefn

@defmac SIZE_TYPE
一个C表达式，为一个字符串描述了用于size值的数据类型名。
typedef名@code{size_t}使用该字符串的内容来定义。

字符串可以包含多一个的关键字。如果是这样，则将它们使用空格分开，
首先是任意长度的关键字，然后是合适@code{unsigned} 的，最后是@code{int}。
字符串必须显示的匹配文件@file{c-decl.c}中函数@code{init_decl_processing}中
定义的数据类型名。不可以省略掉@code{int}或者改变顺序，
这将会使编译器在启动时崩溃。

如果没有定义，缺省为@code{"long unsigned int"}。
@end defmac

@defmac PTRDIFF_TYPE
一个C表达式，为一个字符串，描述了用于两个指针相减的结果的数据类型名。
typedef名@code{ptrdiff_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

如果没有定义，则缺省为@code{"long int"}。
@end defmac

@defmac WCHAR_TYPE
一个C表达式，为一个字符串，描述了用于宽字符的数据类型名。
typedef名@code{wchar_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

如果没有定义，则缺省为@code{"int"}。
@end defmac

@defmac WCHAR_TYPE_SIZE
一个C表达式，为宽字符数据类型的位数。
这用于不能使用@code{WCHAR_TYPE}的@code{cpp}中。
@end defmac

@defmac WINT_TYPE
一个C表达式，为一个字符串，
描述了传递给@code{printf}并且从@code{getwc}中返回的宽字符数据类型名。
typedef名@code{wint_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

如果没有定义，则缺省为@code{"unsigned int"}。
@end defmac

@defmac INTMAX_TYPE
一个C表达式，为一个字符串，
描述了可以表示任何标准或者扩展的有符号整数类型值的数据类型名。
typedef名@code{intmax_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

如果没有定义，则缺省为@code{"int"}, @code{"long int"}或
@code{"long long int"}中第一个与@code{long long int}具有相同精度的字符串。
@end defmac

@defmac UINTMAX_TYPE
一个C表达式，为一个字符串，
描述了可以表示任何标准或者扩展的无符号整数类型值的数据类型名。
typedef名@code{uintmax_t}使用该字符串的内容来定义。更多信息，
参见上面的@code{SIZE_TYPE}。

如果没有定义，则缺省为@code{"unsigned int"}, @code{"long unsigned int"}或
@code{"long long unsigned int"}中第一个与@code{long long unsigned int}
具有相同精度的字符串。
@end defmac

@defmac TARGET_PTRMEMFUNC_VBIT_LOCATION
The C++ compiler represents a pointer-to-member-function with a struct
that looks like:

@smallexample
  struct @{
    union @{
      void (*fn)();
      ptrdiff_t vtable_index;
    @};
    ptrdiff_t delta;
  @};
@end smallexample

@noindent
The C++ compiler must use one bit to indicate whether the function that
will be called through a pointer-to-member-function is virtual.
Normally, we assume that the low-order bit of a function pointer must
always be zero.  Then, by ensuring that the vtable_index is odd, we can
distinguish which variant of the union is in use.  But, on some
platforms function pointers can be odd, and so this doesn't work.  In
that case, we use the low-order bit of the @code{delta} field, and shift
the remainder of the @code{delta} field to the left.

GCC will automatically make the right selection about where to store
this bit using the @code{FUNCTION_BOUNDARY} setting for your platform.
However, some platforms such as ARM/Thumb have @code{FUNCTION_BOUNDARY}
set such that functions always start at even addresses, but the lowest
bit of pointers to functions indicate whether the function at that
address is in ARM or Thumb mode.  If this is the case of your
architecture, you should define this macro to
@code{ptrmemfunc_vbit_in_delta}.

In general, you should not have to define this macro.  On architectures
in which function addresses are always even, according to
@code{FUNCTION_BOUNDARY}, GCC will automatically define this macro to
@code{ptrmemfunc_vbit_in_pfn}.
@end defmac

@defmac TARGET_VTABLE_USES_DESCRIPTORS
Normally, the C++ compiler uses function pointers in vtables.  This
macro allows the target to change to use ``function descriptors''
instead.  Function descriptors are found on targets for whom a
function pointer is actually a small data structure.  Normally the
data structure consists of the actual code address plus a data
pointer to which the function's data is relative.

If vtables are used, the value of this macro should be the number
of words that the function descriptor occupies.
@end defmac

@defmac TARGET_VTABLE_ENTRY_ALIGN
By default, the vtable entries are void pointers, the so the alignment
is the same as pointer alignment.  The value of this macro specifies
the alignment of the vtable entry in bits.  It should be defined only
when special alignment is necessary. */
@end defmac

@defmac TARGET_VTABLE_DATA_ENTRY_DISTANCE
There are a few non-descriptor entries in the vtable at offsets below
zero.  If these entries must be padded (say, to preserve the alignment
specified by @code{TARGET_VTABLE_ENTRY_ALIGN}), set this to the number
of words in each data entry.
@end defmac

@node 寄存器
@section 寄存器的用法
@cindex register usage

这一节说明了如何描述目标机器具有什么寄存器，
以及它们（通常）可以被如何使用。

寄存器类别用来描述一个特定指令可以使用哪些寄存器；
参见 @ref{寄存器类别}。
关于使用寄存器来访问栈帧的信息，参见 @ref{帧寄存器}。
关于使用寄存器来传值，参见 @ref{寄存器参数}。
关于使用寄存器来返回值，参见 @ref{标量返回}。

@menu
* 寄存器基础::          寄存器编号和种类
* 分配顺序::            寄存器按照什么顺序分配
* 寄存器中的值::        每个寄存器可以存放什么类型的值
* 叶子函数::            为叶子函数重编号寄存器
* 栈寄存器::            处理像80387这样的寄存器栈
@end menu

@node 寄存器基础
@subsection 寄存器的基本特征

@c prevent bad page break with this line
寄存器具有不同的特征。

@defmac FIRST_PSEUDO_REGISTER
编译器知道的硬件寄存器个数。它们包括编号0到@code{FIRST_PSEUDO_REGISTER-1}；
因此，第一个伪寄存器的编号实际被赋值为@code{FIRST_PSEUDO_REGISTER}。
@end defmac

@defmac FIXED_REGISTERS
@cindex fixed register
一个初始化，说明哪些寄存器在整个编译代码中都用于固定用途，
因此不能用于通用分配。这些将包括栈指针，帧指针（在当不需要帧指针时，
可以用于通用寄存器的机器上除外），
在一些机器上被认为是可寻址的寄存器的程序计数器，
以及其它具有标准用法的编号寄存器。

这些信息作为一个序列编号来表示，由逗号分隔并由大括号包括。
第@var{n}个编号为1，如果寄存器@var{n}为固定的，否则为0。

从该宏初始化的表，以及由下面的初始化的表，都可以在运行时被覆盖，
或者通过执行宏@code{CONDITIONAL_REGISTER_USAGE}自动完成，
或者通过用户使用命令选项@option{-ffixed-@var{reg}}, 
@option{-fcall-used-@var{reg}}和@option{-fcall-saved-@var{reg}}。
@end defmac

@defmac CALL_USED_REGISTERS
@cindex call-used register
@cindex call-clobbered register
@cindex call-saved register
类似@code{FIXED_REGISTERS}，但是对于被函数调用破坏的每个寄存器，
以及固定寄存器，值为1。因此，
该宏标识了哪些寄存器不适合用于必须活跃于整个函数调用的值的通用分配。

如果寄存器在@code{CALL_USED_REGISTERS}中具有值0，
如果寄存器在函数中被使用，则编译器会自动的在函数入口保存它，
并在函数出口恢复它。
@end defmac

@defmac CALL_REALLY_USED_REGISTERS
@cindex call-used register
@cindex call-clobbered register
@cindex call-saved register
类似@code{CALL_USED_REGISTERS}，除了该宏不需要包含整个@code{FIXED_REGISTERS}集。
（@code{CALL_USED_REGISTERS}必须为@code{FIXED_REGISTERS}的超集）。
该宏为可选的。如果没有被指定，其缺省为@code{CALL_USED_REGISTERS}的值。
@end defmac

@defmac HARD_REGNO_CALL_PART_CLOBBERED (@var{regno}, @var{mode})
@cindex call-used register
@cindex call-clobbered register
@cindex call-saved register
一个C表达式，值为非0，
如果不允许将机器模式为@var{mode}的值存储在编号为@var{regno}的硬件寄存器中，
并且整个调用中没有破坏其某个部分。对于大多数机器，该宏不需要被定义。
其只用于一些在调用中不保护寄存器的整个内容的机器上。
@end defmac

@findex fixed_regs
@findex call_used_regs
@findex global_regs
@findex reg_names
@findex reg_class_contents
@defmac CONDITIONAL_REGISTER_USAGE
0条或者多条C语句，其可以条件修改5个变量@code{fixed_regs}, 
@code{call_used_rehs}, @code{global_regs}, @code{reg_names} 和
@code{reg_class_contents}，来考虑这些寄存器集对target标号的任何依赖。
前3个为@code{char []}类型（作为布尔向量来解析）。
@code{global_regs}为一个@code{const char *[]}，
@code{reg_class_contents}为一个@code{HARD_REG_SET}。
在宏被调用之前，@code{fixed_regs}, @code{call_used_regs}, 
@code{reg_class_contents}和@code{reg_names}已经分别通过@code{FIXED_REGISTERS},
@code{CALL_USED_REGISTERS}, @code{REG_CLASS_CONTENTS}和@code{REGISTER_NAMES}被初始化。
@code{global_regs}已经被清除，并且任何@option{-ffixed-@var{reg}}, 
@option{-fcall-used-@var{reg}}和@option{-fcall-saved-@var{reg}}选项已经被应用。

如果不需要做什么工作，则不必定义该宏。

@cindex disabling certain registers
@cindex controlling register usage
如果整个寄存器的类别的使用，取决于target标记，
则你可以通过使用该宏来指示GCC修改@code{fixed_regs}和@code{call_used_regs}为1，
对于类别中的每个不应由GCC使用的寄存器。还有就是，
定义宏@code{REG_CLASS_FROM_LETTER} / @code{REG_CLASS_FROM_CONSTRAINT}来返回@code{NO_REGS}，
如果其被调用，并带有一个不应该被使用的类别字母。

（然而，如果该类没有包含在@code{GENERAL_REGS}中，
并且所有的insn指令模式的约束允许该类通过target开关来控制，
则GCC将自动避免使用这些寄存器，当target开关与它们相反时。）
@end defmac

@defmac INCOMING_REGNO (@var{out})
定义该宏，如果target机器具有寄存器窗口。
该C表达式根据调用函数能看到的寄存器编号@var{out}，
返回被调用函数所能看到的寄存器编号。
返回@var{out}，如果寄存器编号@var{out}不是发送寄存器（outbound register）。
@end defmac

@defmac OUTGOING_REGNO (@var{in})
定义该宏，如果target机器具有寄存器窗口。
该C表达式根据被调用函数能看到的寄存器编号@var{in}，
返回调用函数所能看到的寄存器编号。
返回@var{in}，如果寄存器编号@var{in}不是运入寄存器（inbound register）。
@end defmac

@defmac LOCAL_REGNO (@var{regno})
定义该宏，如果target机器具有寄存器窗口。该C表达式返回真，
如果寄存器为调用保存的，但是在寄存器窗口中。不像大多调用保存的寄存器，
这样的寄存器不需要在函数出口或者非局部调转中被显示的恢复。
@end defmac

@defmac PC_REGNUM
如果程序计数器具有一个寄存器编号，则定义其为那个寄存器编号。否则不要定义它。
@end defmac

@node 分配顺序
@subsection 寄存器的分配顺序
@cindex order of register allocation
@cindex register allocation order

@c prevent bad page break with this line
寄存器按照顺序进行分配。

@defmac REG_ALLOC_ORDER
如果定义，则为一个整数向量的初始化值，包含了硬件寄存器号，
GCC将按该照顺序来使用它们（前面的优先）。

如果没有定义该宏，则寄存器按照低编号优先的方式使用。

该宏的一个用处是在一些机器上，
高编号的寄存器必须总是被保存并且save-multiple-registers指令
只支持连续序列的寄存器。在这些机器上，
可以定义@code{REG_ALLOC_ORDER}来初始化列表，
使得高编号寄存器优先分配。
@end defmac

@defmac ORDER_REGS_FOR_LOCAL_ALLOC
一条C语句（无分号），
用来选择按照什么顺序来为局部于一个基本块的伪寄存器分配硬件寄存器。

将想要的寄存器顺序存储在数组@code{reg_alloc_order}中。
元素0为先分配的寄存器；元素1为下一个；等等。

在执行宏之前，宏的内容体不应该对@code{reg_alloc_order}的内容作任何假设。

在大多数机器上，不需要定义该宏。
@end defmac

@defmac IRA_HARD_REGNO_ADD_COST_MULTIPLIER (@var{regno})
In some case register allocation order is not enough for the
Integrated Register Allocator (@acronym{IRA}) to generate a good code.
If this macro is defined, it should return a floating point value
based on @var{regno}.  The cost of using @var{regno} for a pseudo will
be increased by approximately the pseudo's usage frequency times the
value returned by this macro.  Not defining this macro is equivalent
to having it always return @code{0.0}.

在大多数机器上，不需要定义该宏。
@end defmac

@node 寄存器中的值
@subsection 如何使值适合寄存器

这节讨论的宏，描述了每个寄存器可以存放哪类的值（明确的说，
是哪些机器模式的），以及对于给定的机器模式需要多少个连续的寄存器。

@defmac HARD_REGNO_NREGS (@var{regno}, @var{mode})
一个C表达式，为存放模式@var{mode}的值所需要的连续的硬件寄存器，
起始于寄存器编号@var{regno}。该宏不要返回0，
即使寄存器不能存放指定的mode —— 替代的，
使用HARD_REGNO_MODE_OK 和/或 CANNOT_CHANGE_MODE_CLASS。

在所有寄存器都是一个字大小的机器上，该宏的一个合适的定义为

@smallexample
#define HARD_REGNO_NREGS(REGNO, MODE)            \
   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
    / UNITS_PER_WORD)
@end smallexample
@end defmac

@defmac HARD_REGNO_NREGS_HAS_PADDING (@var{regno}, @var{mode})
一个C表达式，为非0，如果模式为@var{mode}的值，存储在内存中，
并由padding结尾，这使得其占有更多的空间，
比在起始于寄存器编号@var{regno}的寄存器中。缺省的为0。

例如，如果浮点值存储在三个32位寄存器中，但是在内存中占有128位，则该宏应该为非0。

该宏只有当@code{subreg_get_info}会错误的确定一个@code{subreg}可以通过寄存器编号的偏移量来表示，
而实际上这样的@code{subreg}将会保存一些不应该被表示的padding时，
才需要被定义。
@end defmac

@defmac HARD_REGNO_NREGS_WITH_PADDING (@var{regno}, @var{mode})
对于@code{HARD_REGNO_NREGS_HAS_PADDING}会返回非0的@var{regno}和@var{mode}的值，
其为一个C表达式，返回保存包括任何padding的值所需要的寄存器的最大数。
在上面的例子中，值将为4。
@end defmac

@defmac REGMODE_NATURAL_SIZE (@var{mode})
定义该宏，如果存放模式@var{mode}的值的寄存器的自然大小，不是word大小。
其为一个C表达式，对于指定的mode给出以字节为单位的自然的大小。
其被寄存器分配用于尝试优化它的结果。
例如这出现在SPARC 64位机器上，其浮点寄存器的自然大小仍然是32位。
@end defmac

@defmac HARD_REGNO_MODE_OK (@var{regno}, @var{mode})
一个C表达式，其为非0，
如果允许将一个@var{mode}模式的值存储在硬件寄存器编号@var{regno}
（或者起始于它的多个寄存器）中。对于所有寄存器都是等价的机器上，
一个合适的定义为

@smallexample
#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
@end smallexample

你不需要包含检查固定寄存器编号的代码，
因为分配机制总是认为它们已经被占用了。

@cindex register pairs
在一些机器上，双精度值必须放在偶/奇寄存器对。
你可以通过定义该宏来拒绝这样模式的奇数寄存器编号。

对于一个模式可以放在寄存器中的最小需求为，
@samp{mov@var{mode}}指令模式支持在寄存器和同一类别的其它硬件寄存器之间的移动，
并且将一个值移动到寄存器中并移动回来，而不会改变。

由于用于move @code{word_mode}的同一指令，也可以用于所有更窄的整数模式，
所以@code{HARD_REGNO_MODE_OK}不必要在任何机器上对于这些模式都不同，
假定你定义了指令模式@samp{movhi}等。

许多机器对于浮点算术具有特定的寄存器。
通常人们假设浮点机器模式只在浮点寄存器中被允许。这并不真实。
任何可以存放整数的寄存器都可以安全的存放一个浮点机器模式，
而不管是否可以在这些寄存器上进行浮点算术。
整数move指令可以用于移动这些值。

然而在一些机器上，定点机器模式不可以放在浮点寄存器中。
比如如果浮点寄存器对任何存储的值进行标准化，
因为存储一个非浮点值将会使值变得混淆。这种情况下，
@code{HARD_REGNO_MODE_OK}应该拒绝定点机器模式放在浮点寄存器中。
但是，如果浮点寄存器不自动标准化，
如果你可以存储任何位的指令模式并无需改动的获得它，
则任何机器模式都可以放在浮点寄存器中，这样你可以定义该宏来表明可以这么做。

当然，特定的浮点寄存器的主要意义是它们在浮点算术指令中可以使用。
但是，这根@code{HARD_REGNO_MODE_OK}没有关系。
你可以通过对那些执行写合适的约束来处理。

在一些机器上，浮点寄存器访问起来特别慢，所以如果浮点算术没有完成前，
最好将值存在栈帧中，而不是在这样的寄存器中。
只要浮点寄存器不在@code{GENERAL_REGS}类别中，它们将不会被使用，
除非某个指令模式的约束要求这样。
@end defmac

@defmac HARD_REGNO_RENAME_OK (@var{from}, @var{to})
一个C表达式，为非0，
如果可以将一个硬件寄存器@var{from}重命名为另一个寄存器@var{to}。

该宏的一个通用的用法是防止将一个寄存器重命名为另一个寄存器，
而其在中断处理函数的序言中没有被保存。

缺省总是为非0。
@end defmac

@defmac MODES_TIEABLE_P (@var{mode1}, @var{mode2})
一个C表达式，其为非0，如果一个模式@var{mode1}的值，
不需要复制便可以按照模式@var{mode2}来访问。

如果@code{HARD_REGNO_MODE_OK (@var{r}, @var{mode1})}和
@code{HARD_REGNO_MODE_OK (@var{r}, @var{mode2})}对于任何@var{r}总是相同，
则@code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}应该为非0。
如果它们对于任何@var{r}都不同，则你应该定义该宏来返回0，
除非某个其它机制能够确保值可以按照更窄的模式来访问。

你应该定义该宏来尽可能情况的返回非0，
因为这样会使得GCC执行更好的寄存器分配。
@end defmac

@deftypefn {Target Hook} bool TARGET_HARD_REGNO_SCRATCH_OK (unsigned int @var{regno})
This target hook should return @code{true} if it is OK to use a hard register
@var{regno} as scratch reg in peephole2.

One common use of this macro is to prevent using of a register that
is not saved by a prologue in an interrupt handler.

The default version of this hook always returns @code{true}.
@end deftypefn

@defmac AVOID_CCMODE_COPIES
定义该宏，如果编译器应该避免复制从/到@code{CCmode}寄存器。
你应该只当对复制从/到@code{CCmode}寄存器的支持不完善的时候定义该宏。
@end defmac

@node 叶子函数
@subsection 处理叶子函数

@cindex leaf functions
@cindex functions, leaf
在一些机器上，一个叶子函数（即，不做任何调用的函数），如果其不创建自己的寄存器窗口，则可以运行的更加有效。通常这意味着，其需要通过调用者传递参数的寄存器来接收它的参数，而不是它们通常到达的寄存器。

通常只有当叶子函数还满足其它条件时，才会对其进行特殊的对待；例如，通常它们可能只使用，用于它自己的变量和临时对象的那些寄存器。我们使用术语“叶子函数”来指一个适合这样特殊处理的函数，所以没有函数调用的函数并不一定是“叶子函数”。

GCC是在它知道函数是否适合作为叶子函数来对待之前，分配寄存器编号的。所以它需要重编号寄存器，以便输出一个叶子函数。下面的宏用来完成此事。

@defmac LEAF_REGISTERS
一个char向量的名字，按照硬件寄存器编号进行索引，对于允许作为叶子函数处理的候选寄存器，其值为1。

如果叶子函数处理涉及到重编号寄存器，则这里标记的寄存器应该是重编号之前的——那些GCC通常分配的。重编号后，在汇编代码中实际被使用的寄存器，不要在该向量中被标记为1。

只有当目标机器提供了优化叶子函数处理的方法时，才定义该宏。
@end defmac

@defmac LEAF_REG_REMAP (@var{regno})
一个C表达式，当函数作为叶子函数来处理时，其值为应该对@var{regno}进行重编的寄存器编号。

如果@var{regno}为一个在重编号前不应该出现在叶子函数中的寄存器编号，则表达式的值应该为-1，这将造成编译器中断退出。

只有当目标机器提供了优化叶子函数处理的方法，并且寄存器需要被重编号的时候，才定义该宏。
@end defmac

@findex current_function_is_leaf
@findex current_function_uses_only_leaf_regs
@code{TARGET_ASM_FUNCTION_PROLOGUE}和@code{TARGET_ASM_FUNCTION_EPILOGUE}通常必须专门处理叶子函数。它们可以测试C变量@code{current_function_is_leaf}，其对于叶子函数为非0。@code{current_function_is_leaf}在局部寄存器分配之前被设置，并且可以用于剩余的编译器过程。它们还可以测试C变量@code{current_function_uses_only_leaf_regs}，其对于只用叶子寄存器的叶子函数为非0。@code{current_function_uses_only_leaf_regs}在所有修改指令的过程被运行完之后可用，并且只有当@code{LEAF_REGISTERS}被定义时才有用。

@c changed this to fix overfull.  ALSO:  why the "it" at the beginning
@c of the next paragraph?!  --mew 2feb93

@node 栈寄存器
@subsection 形成栈的寄存器

有一些特性用来处理计算机中形成栈的寄存器。
栈寄存器通常写成被压入一个栈中，并相对于栈顶进行编号。

目前，GCC只能处理一组类栈的寄存器，并且它们的编号必须是连续的。
而且，现存的对类栈寄存器的支持是特定于80387浮点协处理器。
如果你有一个新的体系结构使用了类栈寄存器，
你将需要在@file{reg-stack.c}上做大量的工作，并书写你自己的机器描述，
同时还要定义这些宏。

@defmac STACK_REGS
如果机器具有任何类栈寄存器，则定义该宏。
@end defmac

@defmac FIRST_STACK_REG
第一个类栈寄存器的编号。这是栈顶。
@end defmac

@defmac LAST_STACK_REG
最后一个类栈寄存器的编号，这是栈底。
@end defmac

@node 寄存器类别
@section 寄存器类别
@cindex register class definitions
@cindex class definitions, register

在许多机器上，编号寄存器并不都是等价的。例如，一些寄存器不可以用作索引寻址；
一些寄存器不可以用于某些指令。
这些机器限制使用寄存器类别(@dfn{register classes})来描述给编译器。

你定义一些寄存器类别，给出每个类别的名字并指名哪些寄存器属于它。然后，
你可以指定哪些寄存器类别对于特定的指令模式可以用作操作数。

@findex ALL_REGS
@findex NO_REGS
总的来说，每个寄存器将属于多个类别。实际上，
必须有一个名为@code{ALL_REGS}的类别，包含所有的寄存器。
另外必须有一个名为@code{NO_REGS}的类别，不包含寄存器。
通常两个类别的并集将成为另一个类别；但并不这么要求。

@findex GENERAL_REGS
其中一个类别必须名为@code{GENERAL_REGS}。该名字没有什么特殊的，
但是操作数约束字母@samp{r}和@samp{g}专门指定该类。
如果@code{GENERAL_REGS}与@code{ALL_REGS}相同，
则可以将其定义为扩展成@code{ALL_REGS}的宏。

对类别进行排序，使得如果类@var{x}包含在类@var{y}中，
则@var{x}具有比@var{y}更低的类别编号。

在操作数约束中指定@code{GENERAL_REGS}之外的类别的方法，
是通过机器相关的约束字母。你可以定义该字母来对应于不同的类别，
然后在操作数约束中使用它们。

只要有指令同时允许两个类别，就应该定义一个它们的并集的类别。
例如，如果对于一个特定的操作数，
有一条指令允许一个浮点（协处理器）寄存器或者一个通用寄存器，
则应该定义一个类别@code{FLOAT_OR_GENERAL_REGS}，其包含它们两。
否则你不会得到最优的代码。

你还必须指定关于寄存器类别的冗余信息：对于每个类别，
有哪些类别包含它以及哪些被它包含；
对于每个类别对，最大的类包含在它们的并集中。

当一个值占用多个连续的位于特定类别的寄存器时，
所有被使用的寄存器必须属于那个类别。因此，
寄存器类别不能用于要求寄存器对起始于偶数编号的寄存器。
用来指定该要求的方法是使用@code{HARD_REGNO_MODE_OK}。

用于按位与或者移位指令的操作数的寄存器类别具有特殊的要求：
对于每个定点机器模式，每个这样的类必须具有一个子类，
它的寄存器可以按照该机器模式与内存进行传送值。例如，在一些机器上，
对于单字节值的操作（@code{QImode}）被限制为特定的寄存器。这样的话，
每个用于按位与或者移位指令的寄存器类别必须具有一个子类，
组成它的寄存器可以用来加载或存储单字节值。
这使得@code{PREFERRED_RELOAD_CLASS}总是具有一个可以返回的值。

@deftp {Data type} {enum reg_class}
一个枚举类型，必须使用所有的寄存器类别名作为枚举值来定义。
@code{NO_REGS}必须位于最前面。@code{ALL_REGS}必须为最后一个寄存器类别，
后面再跟随一个枚举值，@code{LIM_REG_CLASSES}，其不是一个寄存器类别，
但是用来告诉有多少个类别。

每个寄存器类别具有一个编号，其为将类别名映射到@code{int}类型的值。
编号在下面描述的许多表中用作索引。
@end deftp

@defmac N_REG_CLASSES
不同寄存器类别的数目，定义为:

@smallexample
#define N_REG_CLASSES (int) LIM_REG_CLASSES
@end smallexample
@end defmac

@defmac REG_CLASS_NAMES
一个初始化值，包含了作为C字符串常量的寄存器类别的名字。
这些名字用于书写一些调试转储。
@end defmac

@defmac REG_CLASS_CONTENTS
一个初始化值，包含了寄存器类别的内容，作为位掩码的整数。
第@var{n}个整数指定了类别@var{n}的内容。整数掩码的解析方式为，
寄存器@var{r}在类别中，如果@code{@var{mask} & (1 << @var{r})}为1。

当机器具有多于32个寄存器的时候，一个整数还不能满足。这时整数被替换为子初始化值，
为括号包裹的多个整数。每个子初始化值必须适合类型@code{HARD_REG_SET}的初始化值，
其在@file{hard-reg-set.h}中定义。这种情况下，
每个子初始化值的第一个整数对应于寄存器0到31，第二个对应于32到63，等等。
@end defmac

@defmac REGNO_REG_CLASS (@var{regno})
一个C表达式，其值为包含了硬件寄存器@var{regno}的寄存器类别。总的来说，
会有不止一个这样的类别；选择最小的那个，这意味着没有更小的类别包含该寄存器。
@end defmac

@defmac BASE_REG_CLASS
一个宏，它的定义为有效的基址寄存器必须属于的类别名字。
基址寄存器用于由寄存器的值加上一个偏移量来表示的地址中。
@end defmac

@defmac MODE_BASE_REG_CLASS (@var{mode})
这是宏@code{BASE_REG_CLASS}的变体，其允许在机器模式相关的方式下选择基址寄存器。
如果@var{mode}为VOIDmode，则其应该返回根@code{BASE_REG_CLASS}同样的值。
@end defmac

@defmac MODE_BASE_REG_REG_CLASS (@var{mode})
一个C表达式，其值为有效的基址寄存器必须属于的类别名字，
且用于一个基址寄存器加上索引寄存器的地址中。你应该定义该宏，
如果表示为基址寄存器加上索引寄存器的地址具有不同于其它基址寄存器的用法要求时。
@end defmac

@defmac MODE_CODE_BASE_REG_CLASS (@var{mode}, @var{outer_code}, @var{index_code})
一个C表达式，其值为有效的基址寄存器必须属于的类别名字。
@var{outer_code}和@var{index_code}定义了基址寄存器出现的上下文。
@var{outer_code}为。@var{index_code}为相应的索引表达式的代码，
如果@var{outer_code}为@code{PLUS}；否则为@code{SCRATCH}。
@end defmac

@defmac INDEX_REG_CLASS
一个C表达式，其值为有效的索引寄存器必须属于的类别名字。
索引寄存器为一个用于地址中的寄存器，
它的值用于乘于一个标量因子或者加上另一个寄存器（也可以加上一个偏移量）。
@end defmac

@defmac REGNO_OK_FOR_BASE_P (@var{num})
一个C表达式，其为非0，
如果寄存器编号@var{num}适合在操作数地址中作为基址寄存器使用。
其可以为一个合适的硬件寄存器，或者一个已经被分配了这样的硬件寄存器的伪寄存器。
@end defmac

@defmac REGNO_MODE_OK_FOR_BASE_P (@var{num}, @var{mode})
一个C表达式，类似于@code{REGNO_OK_FOR_BASE_P}，
除了表达式可以检查内存引用的机器模式@var{mode}。你应该定义该宏，
如果内存引用的机器模式影响了一个寄存器是否可以作为基址寄存器使用。
如果你定义了该宏，则编译器将使用它来替代@code{REGNO_OK_FOR_BASE_P}。
对于出现在@code{MEM}之外的地址，即作为一个@code{address_operand}，
mode可以为@code{VOIDmode}。
@end defmac

@defmac REGNO_MODE_OK_FOR_REG_BASE_P (@var{num}, @var{mode})
一个C表达式，其为非0，
如果寄存器编号@var{num}适合在表示为基址加索引的地址中作为一个基址寄存器使用，
并通过模式@var{mode}来访问。其可以为一个合适的硬件寄存器，
或者一个已经被分配了这样的硬件寄存器的伪寄存器。你应该定义该宏，
如果表示为基址寄存器加上索引寄存器的地址具有不同于其它基址寄存器的用法要求时。

不赞成使用该宏；请使用更加通用的@code{REGNO_MODE_CODE_OK_FOR_BASE_P}。
@end defmac

@defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{outer_code}, @var{index_code})
一个C表达式，类似于@code{REGNO_MODE_OK_FOR_BASE_P}，
除了表达式可以检查寄存器出现内存引用中的上下文。@var{outer_code}为。
@var{index_code}为相应的索引表达式的代码，如果@var{outer_code}为@code{PLUS}；
否则为@code{SCRATCH}。对于出现在@code{MEM}之外的地址，
即作为一个@code{address_operand}，mode可以为@code{VOIDmode}。
A C expression that is just like @code{REGNO_MODE_OK_FOR_BASE_P}, except
that that expression may examine the context in which the register
appears in the memory reference.  @var{outer_code} is the code of the
immediately enclosing expression (@code{MEM} if at the top level of the
address, @code{ADDRESS} for something that occurs in an
@code{address_operand}).  @var{index_code} is the code of the
corresponding index expression if @var{outer_code} is @code{PLUS};
@code{SCRATCH} otherwise.  The mode may be @code{VOIDmode} for addresses
that appear outside a @code{MEM}, i.e., as an @code{address_operand}.
@end defmac

@defmac REGNO_OK_FOR_INDEX_P (@var{num})
一个C表达式，其为非0，
如果寄存器编号@var{num}适合作为索引寄存器用于操作数地址中。
其可以为一个合适的硬件寄存器或者一个已经被分配了这样的硬件寄存器的伪寄存器。

索引寄存器和基址寄存器的区别是，索引寄存器可以被标量化。
如果一个地址包含了两个寄存器的和，并且都不被标量化，
则一个可以被标签为“base” 另一个为“index”；但是使用哪个标签，
必须要适合机器的约束。编译器将尝试两种标签方式，来查找有效的一种，
并且当两种方式都无法工作时，重载一个或两个寄存器。
@end defmac

@defmac PREFERRED_RELOAD_CLASS (@var{x}, @var{class})
一个C表达式，对寄存器类别进行额外的限制，
用于当需要复制值@var{x}到类别为@var{class}的寄存器中。
值为一个寄存器类别；可能为@var{class}或者其它比@var{class}小的类别。
在许多机器上，下列定义是安全的：

@smallexample
#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS
@end smallexample

有时返回一个更加限制的类别将会产生更好的代码。例如，在68000上，
当@var{x}为一个整数常量，并且在@samp{moveq}指令的范围内，
则该宏的值总是为@code{DATA_REGS}，只要@var{class}包含数据寄存器。
需要一个数据寄存器保证了@samp{moveq}将使用。

一种@code{PREFERRED_RELOAD_CLASS}必须不返回@var{class}的情况为，
如果@var{x}为一个合法常量其不能被加载到某个寄存器类别中。
通过返回@code{NO_REGS}，你可以强迫@var{x}放入内存位置中。例如，
rs6000可以加载立即数值到通用寄存器中，
但没有指令可以加载立即数值到浮点寄存器中，
所以@code{PREFERRED_RELOAD_CLASS}返回@code{NO_REGS}，
当@var{x}为一个浮点常量时。如果常量不能被加载到任何种类的寄存器中，
如果@code{LEGITIMATE_CONSTANT_P}使常量为非法的，
而不是使用@code{PREFERRED_RELOAD_CLASS}，则代码生成将会更好。

如果一个insn在寄存器分配之后具有伪寄存器，
则重载将遍历选择项并且反复调用@code{PREFERRED_RELOAD_CLASS}来找到最好的一个。
返回@code{NO_REGS}，在这种情况下，使得重载在约束前增加一个@code{!}：
x86后端使用该特征来劝阻使用387寄存器，当算术在SSE寄存器中进行时（反之亦然）。
@end defmac

@defmac PREFERRED_OUTPUT_RELOAD_CLASS (@var{x}, @var{class})
类似于@code{PREFERRED_RELOAD_CLASS}，但是用于输出重载而不是输入重载。
如果没有定义该宏，则缺省为使用不变的@var{class}。

你还可以使用@code{PREFERRED_OUTPUT_RELOAD_CLASS}来劝阻使用一些可选项的重载，
类似于@code{PREFERRED_RELOAD_CLASS}。
@end defmac

@defmac LIMIT_RELOAD_CLASS (@var{mode}, @var{class})
一个C表达式，对寄存器类别实施额外的限制，
用于当需要在一个类别为@var{class}的重载寄存器中保存机器模式为@var{mode}的值的时候。

不像@code{PREFERRED_RELOAD_CLASS}，
该宏应该用于当有特定的机器模式不能简单的放入特定的重载类别中的时候。

值为一个寄存器类别；可能为@var{class}，或者其它更小的类别。

不要定义该宏，除非target机器具有一些限制，使得宏需要做一些事情。
@end defmac

@deftypefn {Target Hook} {enum reg_class} TARGET_SECONDARY_RELOAD (bool @var{in_p}, rtx @var{x}, enum reg_class @var{reload_class}, enum machine_mode @var{reload_mode}, secondary_reload_info *@var{sri})
许多机器具有一些寄存器，其不能直接和内存之间进行复制，
甚至不能和其它类型的寄存器。一个例子是@samp{MQ}寄存器，
在大多数机器上，只能与通用寄存器直接进行复制，而不能和内存之间。
下面，我们将使用术语‘中途寄存器’，当一个move操作不能直接执行，
而必须首先通过将源复制到中途寄存器中，然后再从中途寄存器复制到目的。
一个中途寄存器总是具有与源和目的相同的机器模式。由于其存放了被复制的实际的值，
所以重载可能进行优化来重用一个中途寄存器，并且省略掉从源进行复制的操作，
当它可以确定中途寄存器还保留着所需要的值的时候。

另一种需要执行二次重载的情况是，在一些机器上，
其允许所有的寄存器和内存之间进行复制，
但要求一个scratch寄存器来存储一些内存的位置（例如，在RT上那些具有符号地址的，
以及在SPARC上当编译PIC时那些具有特定符号地址的）。
草稿寄存器不需要与被复制的值具有相同的机器模式，并且通常保留一个不同的值。
在md文件中需要特殊的指令模式来描述复制在草稿寄存器的帮助下如何执行；
这些指令模式还描述了草稿寄存器的编号，寄存器类别和机器模式。

在一些情况下，同时需要中途寄存器和草稿寄存器。

对于输入重载，该target钩子使用非零的@var{in_p}来调用，并且@var{x}为一个rtx，
其需要被复制到一个类别为@var{reload_class}，机器模式为@var{reload_mode}的寄存器中。
对于输出重载，该target钩子使用为0的@var{in_p}调用，并且一个类别为@var{reload_class}，
需要复制到机器模式为reload_mode的rtx @var{x}中。

如果在类别为@var{reload_class}的寄存器和@var{x}直接进行复制需要一个中途寄存器，
则钩子@code{secondary_reload}应该返回一个该中途寄存器需要的寄存器类别。
如果不需要中途寄存器，则其应该返回NO_REGS。如果需要多个中途寄存器，
则描述在复制链中最近的那个。

如果需要草稿寄存器，
则还要描述如何如何在重载寄存器和这个最近的中途寄存器直接进行复制。
或者如果不需要中途寄存器，但仍然需要一个草稿寄存器，
则描述重载寄存器和重载操作数@var{x}之间的复制。

为此，你需要设置@code{sri->icode}为在md文件中执行move的指令模式的代码。
操作数0和1分别为该复制的输出和输入。从2以后的操作数为草稿操作数。
这些草稿操作数必须具有机器模式并且一个single-register-class的输出约束。

当使用中途寄存器的时候，@code{secondary_reload}钩子将会被再次调用，
来确定如何在中途寄存器和重载操作数之间进行复制，
所以你的钩子必须还要具有处理中途操作数的寄存器类别的代码。

@var{x}可以为伪寄存器或者一个伪寄存器的@code{subreg}，
其可以为一个硬件寄存器或者在内存中。使用@code{true_regnum}来查看；
其将返回-1如果伪寄存器在内存中，以及硬件寄存器编号，如果其在一个寄存器中。

在内存中的草稿操作数（约束@code{"=m"} / @code{"=&m"}）目前不被支持。
为此，目前你必须继续使用@code{SECONDARY_MEMORY_NEEDED}。

@code{copy_cost}还是要该target钩子来查找值如何被复制。
如果你想让其包含像分配草稿寄存器所需要的额外代价，
则可以设置@code{sri->extra_cost}为额外代价。
或者如果两个相关move会具有比两个单个move之和的代价要低，
则可以设置@code{sri->extra_cost}为一个负数。
@end deftypefn

@defmac SECONDARY_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})
@defmacx SECONDARY_INPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})
@defmacx SECONDARY_OUTPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})
These macros are obsolete, new ports should use the target hook
@code{TARGET_SECONDARY_RELOAD} instead.

These are obsolete macros, replaced by the @code{TARGET_SECONDARY_RELOAD}
target hook.  Older ports still define these macros to indicate to the
reload phase that it may
need to allocate at least one register for a reload in addition to the
register to contain the data.  Specifically, if copying @var{x} to a
register @var{class} in @var{mode} requires an intermediate register,
you were supposed to define @code{SECONDARY_INPUT_RELOAD_CLASS} to return the
largest register class all of whose registers can be used as
intermediate registers or scratch registers.

If copying a register @var{class} in @var{mode} to @var{x} requires an
intermediate or scratch register, @code{SECONDARY_OUTPUT_RELOAD_CLASS}
was supposed to be defined be defined to return the largest register
class required.  If the
requirements for input and output reloads were the same, the macro
@code{SECONDARY_RELOAD_CLASS} should have been used instead of defining both
macros identically.

The values returned by these macros are often @code{GENERAL_REGS}.
Return @code{NO_REGS} if no spare register is needed; i.e., if @var{x}
can be directly copied to or from a register of @var{class} in
@var{mode} without requiring a scratch register.  Do not define this
macro if it would always return @code{NO_REGS}.

If a scratch register is required (either with or without an
intermediate register), you were supposed to define patterns for
@samp{reload_in@var{m}} or @samp{reload_out@var{m}}, as required
(@pxref{标准名字}.  These patterns, which were normally
implemented with a @code{define_expand}, should be similar to the
@samp{mov@var{m}} patterns, except that operand 2 is the scratch
register.

These patterns need constraints for the reload register and scratch
register that
contain a single register class.  If the original reload register (whose
class is @var{class}) can meet the constraint given in the pattern, the
value returned by these macros is used for the class of the scratch
register.  Otherwise, two additional reload registers are required.
Their classes are obtained from the constraints in the insn pattern.

@var{x} might be a pseudo-register or a @code{subreg} of a
pseudo-register, which could either be in a hard register or in memory.
Use @code{true_regnum} to find out; it will return @minus{}1 if the pseudo is
in memory and the hard register number if it is in a register.

These macros should not be used in the case where a particular class of
registers can only be copied to memory and not to another class of
registers.  In that case, secondary reload registers are not needed and
would not be helpful.  Instead, a stack location must be used to perform
the copy and the @code{mov@var{m}} pattern should use memory as an
intermediate storage.  This case often occurs between floating-point and
general registers.
@end defmac

@defmac SECONDARY_MEMORY_NEEDED (@var{class1}, @var{class2}, @var{m})
一些机器要求某些寄存器必须使用内存才能与其它寄存器进行复制。
定义该宏在那些机器上，其为一个C表达式，
为非0如果机器模式为@var{m}的对象在类别为@var{class1}的寄存器中，
只能通过将@var{class1}的寄存器存储到内存中并且将内存位置加载到@var{class2}的寄存中。

如果其值总是为0，则不要定义该宏。
@end defmac

@defmac SECONDARY_MEMORY_NEEDED_RTX (@var{mode})
通常当@code{SECONDARY_MEMORY_NEEDED}被定义时，
编译器会分配一个栈槽为需要寄存器复制的内存位置。
如果该宏被定义，则编译器会替代的使用该宏定义的内存位置。

如果没有定义@code{SECONDARY_MEMORY_NEEDED}，则不要定义该宏。
@end defmac

@defmac SECONDARY_MEMORY_NEEDED_MODE (@var{mode})
当编译器需要一个二级内存位置在机器模式为@var{mode}的寄存器之间进行复制的时候，
其通常分配足够的内存来存放@code{BITS_PER_WORD}个位，
并且执行该位数宽度的@var{mode}的存储和加载操作。

这在大多数机器上是正确的，
因为其确保寄存器的所有位被复制并且阻止对寄存器按照较窄的机器模式来访问，
这对于浮点寄存器通常是禁止的。

然而，该缺省行为在一些机器上是不正确的，例如DEC Alpha，
其在浮点寄存器中存储short整数与在整数寄存器中是不同的。
在那些机器上，缺省的宽度将不正确，你必须定义该宏来抑制这种宽度。
详情参见@file{alpha.h}文件。

如果没有定义，或者如果@code{BITS_PER_WORD}个位数的宽度是正确的，则不要定义该宏。
@end defmac

@defmac SMALL_REGISTER_CLASSES
在一些机器上，让硬件寄存器的活跃性跨越任意的insn是危险的。
特别是，这些机器具有要求值要在特定寄存器中的指令（像累加器），
并且重载将会失败如果所要求的硬件寄存器用于其它目的。

定义@code{SMALL_REGISTER_CLASSES}为一个表达式，非0的值在这些机器上。
当该宏具有非0值，则编译器尝试最小化硬件寄存器的生命期。

定义该宏为非0值总是安全的，但是如果你没必要定义它，则你将会减少优化数目。
如果你没有定义该宏为非0，并且当其需要时，
则编译器会产生寄存器溢出并且打印一个fatal error消息。
对于大多数机器，你根本不需要定义该宏。
@end defmac

@defmac CLASS_LIKELY_SPILLED_P (@var{class})
A C expression whose value is nonzero if pseudos that have been assigned
to registers of class @var{class} would likely be spilled because
registers of @var{class} are needed for spill registers.

The default value of this macro returns 1 if @var{class} has exactly one
register and zero otherwise.  On most machines, this default should be
used.  Only define this macro to some other expression if pseudos
allocated by @file{local-alloc.c} end up in memory because their hard
registers were needed for spill registers.  If this macro returns nonzero
for those classes, those pseudos will only be allocated by
@file{global.c}, which knows how to reallocate the pseudo to another
register.  If there would not be another register available for
reallocation, you should not change the definition of this macro since
the only effect of such a definition would be to slow down register
allocation.
@end defmac

@defmac CLASS_MAX_NREGS (@var{class}, @var{mode})
一个C表达式，为需要存放机器模式为@var{mode}的值所需要的连续的类别为@var{class}的寄存器的最大数。

这与宏@code{HARD_REGNO_NREGS}很相近。实际上，
宏@code{CLASS_MAX_NREGS (@var{class}, @var{mode})}的值应该为@code{HARD_REGNO_NREGS (@var{regno},@var{mode})}的最大值。

该宏有助于处理多字的值，在重载过程中。
@end defmac

@defmac CANNOT_CHANGE_MODE_CLASS (@var{from}, @var{to}, @var{class})
如果被定义，为一个C表达式，其返回非0，对于一个@var{class}，
其由机器模式@var{from}到@var{to}的改变是无效的。

例如，加载32位整数或者浮点对象到浮点寄存器中，在Alpha上将被扩展为64位。
因此加载64位对象并存储为32位对象时将不保存第32位。
因此，@file{alpha.h}定义@code{CANNOT_CHANGE_MODE_CLASS}如下：

@smallexample
#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \
  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \
   ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)
@end smallexample
@end defmac

@deftypefn {Target Hook} {const enum reg_class *} TARGET_IRA_COVER_CLASSES ()
Return an array of cover classes for the Integrated Register Allocator
(@acronym{IRA}).  Cover classes are a set of non-intersecting register
classes covering all hard registers used for register allocation
purposes.  If a move between two registers in the same cover class is
possible, it should be cheaper than a load or store of the registers.
The array is terminated by a @code{LIM_REG_CLASSES} element.

This hook is called once at compiler startup, after the command-line
options have been processed. It is then re-examined by every call to
@code{target_reinit}.

The default implementation returns @code{IRA_COVER_CLASSES}, if defined,
otherwise there is no default implementation.  You must define either this
macro or @code{IRA_COVER_CLASSES} in order to use the integrated register
allocator with Chaitin-Briggs coloring. If the macro is not defined,
the only available coloring algorithm is Chow's priority coloring.
@end deftypefn

@defmac IRA_COVER_CLASSES
See the documentation for @code{TARGET_IRA_COVER_CLASSES}.
@end defmac

@node 旧式约束
@section 废弃的定义约束的宏
@cindex defining constraints, obsolete method
@cindex constraints, defining, obsolete method

机器特定的约束可以使用这些宏来定义，来替代在@ref{定义约束}中描述的机器描述结构。
这种机制已经被废弃；旧的port应该转换为新的机制。

@defmac CONSTRAINT_LEN (@var{char}, @var{str})
对于起始于@var{str}，其起始字母为@var{c}的约束，返回其长度。
这允许你具有比单个字母更长的寄存器类别/常量/额外约束；
你不需要定义该宏，如果你只用单个字母的约束。
该宏的定义应该使用DEFAULT_CONSTRAINT_LEN，对于你不想特别处理的所有字符。
在genoutput.c中有一些合理性检查，用来为md文件检查约束的长度。
@end defmac

@defmac REG_CLASS_FROM_LETTER (@var{char})
一个C表达式，其为寄存器类别定义了机器相关的操作数约束字母。
如果@var{char}为这样的字母，则值应该为对应的寄存器类别。否则，
值应该为@code{NO_REGS}。寄存器字母@samp{r}，对应于类别@code{GENERAL_REGS}，
将不被传给该宏；你不需要处理它。
@end defmac

@defmac REG_CLASS_FROM_CONSTRAINT (@var{char}, @var{str})
类似于@code{REG_CLASS_FROM_LETTER}，不过你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac CONST_OK_FOR_LETTER_P (@var{value}, @var{c})
一个C表达式，其定义了机器相关操作数约束字母（@samp{I}, @samp{J}, @samp{K}, 
@dots{} @samp{P}），指定了整数值的特定范围。如果@var{c}为那些字母中的，
则表达式应该检查@var{value}，一个整数，如果在合适的范围中则返回1，否则返回0。
如果@var{c}不是那些字母中的，则值应该为0，而不管@var{value}是多少。
@end defmac

@defmac CONST_OK_FOR_CONSTRAINT_P (@var{value}, @var{c}, @var{str})
类似@code{CONST_OK_FOR_LETTER_P}，但是你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac CONST_DOUBLE_OK_FOR_LETTER_P (@var{value}, @var{c})
一个C表达式，定义了机器相关操作数约束字母，
指定了@code{const_double}值的特定范围（@samp{G}或@samp{H}）。

如果@var{c}为那些字母中的，则表达式应该检查@var{value}，
一个代码为@code{const_double}的RTX，如果在合适的范围中则返回1，否则返回0。
如果@var{c}不是那些字母中的，则值应该为0，而不管@var{value}是多少。

@code{const_double}用于所有的浮点常量和@code{DImode}定点常量。
一个给定的字母可以接受一种或者这两种类型的值。
其可以使用@code{GET_MODE}来区别这些类型。
@end defmac

@defmac CONST_DOUBLE_OK_FOR_CONSTRAINT_P (@var{value}, @var{c}, @var{str})
类似@code{CONST_DOUBLE_OK_FOR_LETTER_P}，但是你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac EXTRA_CONSTRAINT (@var{value}, @var{c})
一个C表达式，定义了可选的机器相关约束字母，
其可以用于为target机器隔离特定类型的操作数，通常为内存引用。
任何没有在其它地方定义并且不被
@code{REG_CLASS_FROM_LETTER} / REG_CLASS_FROM_CONSTRAINT匹配的字母都可以使用。
通常该宏将不被定义。

如果对于特定的target机器需要该宏，则应该返回1，
如果@var{value}对应于由约束字母@var{c}表示的操作数类型。
如果@var{c}没有作为extra约束定义，则值应该为0，而不管@var{value}是多少。

例如，则ROMP上，加载指令不能将它们的输出放在r0中，
如果内存引用包含了一个符号地址。
约束字母@samp{Q}被定义来表示不包含符号地址的内存地址。
一个可选项使用@samp{Q}约束在输入上并且@samp{r}在输出上来指定。
下一个可选项指定了@samp{m}在输入上并且不包含r0的寄存器类别在输出上。
@end defmac

@defmac EXTRA_CONSTRAINT_STR (@var{value}, @var{c}, @var{str})
类似@code{EXTRA_CONSTRAINT}，但是你还得到在@var{str}中传递的字符串，
所以你可以使用后缀来区别不同的变种。
@end defmac

@defmac EXTRA_MEMORY_CONSTRAINT (@var{c}, @var{str})
一个C表达式，定义了可选的机器相关约束字母，
在那些由@code{EXTRA_CONSTRAINT}接受的字母中，
其应该被重载过程作为内存约束来对待。

其应该返回1，如果由@var{str}起始，并且第一个字母为@var{c}的约束所表示的操作数
类型所包含的所有内存引用为简单的基址寄存器。这允许重载过程来重载操作数，
如果其不直接对应于操作数类型@var{c}，通过将其地址复制到基址寄存器中。

例如，在S/390上，一些指令不接受任意的内存引用，只接受那些不使用索引寄存器的。
约束字母@samp{Q}被通过@code{EXTRA_CONSTRAINT}定义，来表示这种类型的内存地址。
如果字母@samp{Q}被标记为@code{EXTRA_MEMORY_CONSTRAINT}，
则一个@samp{Q}常量可以处理任何内存操作数，
因为重载过程知道其可以通过将内存地址复制到基址寄存器中如果需要的话。
这类似于可以处理任何内存操作数的@samp{o}约束的方式。
@end defmac

@defmac EXTRA_ADDRESS_CONSTRAINT (@var{c}, @var{str})
一个C表达式，定义了可选的机器相关约束字母，在那些由
@code{EXTRA_CONSTRAINT} / @code{EXTRA_CONSTRAINT_STR}接受的字母中，
其应该被重载过程作为地址约束来对待。

其应该返回1，如果由@var{str}起始，并且第一个字母为@var{c}的约束所表示的操作数
类型所包含的所有内存引用为简单的基址寄存器。这允许重载过程来重载操作数，
如果其不直接对应于操作数类型@var{str}，通过将其地址复制到基址寄存器中。

标记为@code{EXTRA_ADDRESS_CONSTRAINT}的约束只能与@code{address_operand}断言
一起使用。其类似于@samp{p}约束。
@end defmac

@node 栈和调用
@section 栈布局和调用约定
@cindex calling conventions

@c prevent bad page break with this line
这一节描述了栈的布局和调用约定。

@menu
* 帧布局::
* 异常处理::
* 栈检查::
* 帧寄存器::
* 消除::
* 栈参数::
* 寄存器参数::
* 标量返回::
* 聚合返回::
* 调用者保存::
* 函数入口::
* Profiling::
* 尾调用::
* 栈冲突保护::
@end menu

@node 帧布局
@subsection 基本的帧布局
@cindex stack frame layout
@cindex frame layout

@c prevent bad page break with this line
这里是基本的栈布局。

@defmac STACK_GROWS_DOWNWARD
定义该宏，如果将一个字压入栈中使得栈指针移向更小的地址。

当我们说“定义该宏，如果@dots{}”，这意味着编译器只是使用@code{#ifdef}来检查该宏，
所以具体定义的值并没有关系。
@end defmac

@defmac STACK_PUSH_CODE
该宏定义了当压栈所使用的操作。对于RTL形式，
压栈操作将为@code{(set (mem (STACK_PUSH_CODE (reg sp))) @dots{})}。

可选择的方式为@code{PRE_DEC}, @code{POST_DEC}, @code{PRE_INC}和@code{POST_INC}。
使用哪一个是正确的，取决于栈的方向和栈指针是否指向栈中的最后一项，
还是指向之后的空间。

缺省为@code{PRE_DEC}，当@code{STACK_GROWS_DOWNWARD}被定义时，
这大多情况下都是正确，否则为@code{PRE_INC}，这经常是错误的。
@end defmac

@defmac FRAME_GROWS_DOWNWARD
定义该宏为非零值，如果局部变量槽的地址位于帧指针的负偏移处。
@end defmac

@defmac ARGS_GROW_DOWNWARD
定义该宏，如果函数的连续的参数在栈上的地址是递减的。
@end defmac

@defmac STARTING_FRAME_OFFSET
帧指针到第一个被分配的局部变量槽的偏移量。

如果@code{FRAME_GROWS_DOWNWARD}，则通过从@code{STARTING_FRAME_OFFSET}减去第一个
栈槽的长度来查找下一个栈槽的偏移量。否则，通过从@code{STARTING_FRAME_OFFSET}
加上第一个栈槽的长度来查找。
@c i'm not sure if the above is still correct.. had to change it to get
@c rid of an overfull.  --mew 2feb93
@end defmac

@defmac STACK_ALIGNMENT_NEEDED
定义为0，来禁止在重载过程中对栈的对齐。缺省的非0值适合于大多part。

在一些port上，@code{STARTING_FRAME_OFFSET}为非0，
或者在局部块之后有一块寄存器保存区域，其不需要对齐到@code{STACK_BOUNDARY}，
这样禁止栈对齐并且在后端实现可能会更好。
@end defmac

@defmac STACK_POINTER_OFFSET
从栈指针寄存器到第一个输出的参数所放在的位置的偏移量。
如果没有指定，则缺省值0被使用。这对于大多数机器都合适。

如果@code{ARGS_GROW_DOWNWARD}，
则这是输出参数位于的第一个位置的上面的位置的偏移量。
@end defmac

@defmac FIRST_PARM_OFFSET (@var{fundecl})
参数指针寄存器到第一个参数的地址的偏移量。在一些机器上，
其可能依赖于函数的数据类型。

如果@code{ARGS_GROW_DOWNWARD}，则这是第一个参数的地址的上面的位置的偏移量。
@end defmac

@defmac STACK_DYNAMIC_OFFSET (@var{fundecl})
栈指针寄存器到在栈上动态分配的对象的偏移量，例如，通过@code{alloca}。

该宏的缺省值为@code{STACK_POINTER_OFFSET}加上输出参数的长度。
缺省值对于大多数机器是正确的。详情参见@file{function.c}。
@end defmac

@defmac INITIAL_FRAME_ADDRESS_RTX
一个C表达式，其值为RTL，表示初始栈帧的地址。
该地址被传给@code{RETURN_ADDR_RTX}和@code{DYNAMIC_CHAIN_ADDRESS}。
如果你没有定义该宏，则一个合理的缺省值将被使用。定义该宏，
可以使帧指针消除在@code{__builtin_frame_address (count)}和
@code{__builtin_return_address (count)}不等于0的情况下工作。
@end defmac

@defmac DYNAMIC_CHAIN_ADDRESS (@var{frameaddr})
一个C表达式，其值为RTL，表示栈帧中的地址，指向被存储的调用者的帧。
假设@var{frameaddr}为一个栈帧本身的地址的RTL表达式。

如果你没有定义该宏，则缺省为返回@var{frameaddr}的值——也就是说，
栈帧地址也是指向之前帧的地址。
@end defmac

@defmac SETUP_FRAME_ADDRESSES
如果定义，为一个C表达式，其产生机器特定的代码来建立栈，使得可以访问任意的帧。
例如，在SPARC上，我们必须刷新栈的所有寄存器窗口，在我们可以访问任意栈帧之前。
你很少会需要定义该宏。
@end defmac

@deftypefn {Target Hook} bool TARGET_BUILTIN_SETJMP_FRAME_VALUE ()
该target钩子应该返回一个rtx，用于将当前帧的地址存储到内建的@code{setjmp}缓存中。
缺省值，@code{virtual_stack_vars_rtx}，对于大多数机器是正确的。
一种你可能需要定义该target钩子的原因是，
如果@code{hard_frame_pointer_rtx}在你的机器上是合适的值。
@end deftypefn

@defmac FRAME_ADDR_RTX (@var{frameaddr})
一个C表达式，其值为RTL，表示当前帧的帧地址。@var{frameaddr}为当前帧的帧指针。
这用于__builtin_frame_address。你只有当帧地址与帧指针不同的时候才需要定义该宏。
大多数机器不需要定义该宏。
@end defmac

@defmac RETURN_ADDR_RTX (@var{count}, @var{frameaddr})
A C expression whose value is RTL representing the value of the return
address for the frame @var{count} steps up from the current frame, after
the prologue.  @var{frameaddr} is the frame pointer of the @var{count}
frame, or the frame pointer of the @var{count} @minus{} 1 frame if
@code{RETURN_ADDR_IN_PREVIOUS_FRAME} is defined.

The value of the expression must always be the correct address when
@var{count} is zero, but may be @code{NULL_RTX} if there is no way to
determine the return address of other frames.
@end defmac

@defmac RETURN_ADDR_IN_PREVIOUS_FRAME
定义该宏，如果一个特定的栈帧的返回地址是从之前栈帧的帧指针中访问的。
@end defmac

@defmac INCOMING_RETURN_ADDR_RTX
一个C表达式，其值为RTL，表示在任何函数的起始处，在序言之前，
流入的返回地址的位置。该RTL或者为一个@code{REG}，
指示返回地址保存在@samp{REG}中，或者一个@code{MEM}表示位于栈中。

你只在你想支持调用帧调试信息，像DWARF2提供的那样，的时候才需要定义该宏。

如果该RTL为一个@code{REG}，
你还要定义@code{DWARF_FRAME_RETURN_COLUMN}为@code{DWARF_FRAME_REGNUM (REGNO)}。
@end defmac

@defmac DWARF_ALT_FRAME_RETURN_COLUMN
一个C表达式，其值为一个整数，给出了DWARF2的列号，可以用作替代的返回列。
column必须不对应于任何gcc硬件寄存器（也就是说，
其必须不在@code{DWARF_FRAME_REGNUM}的范围中）。

该宏当被设为一个通用寄存器，但是候选的column需要用于signal帧的时候会很有用。
一些target还使用了不同的帧返回列。
@end defmac

@defmac DWARF_ZERO_REG
一个C表达式，其值为一个整数，给出了DWARF2寄存器编号，其被认为总是具有值0。
这应该只当target的体系结构中具有一个0寄存器并且认为使用寄存器编号来确定栈的
回溯是一个好主意的时候才被定义。新的part应该避免该宏。
@end defmac

@deftypefn {Target Hook} void TARGET_DWARF_HANDLE_FRAME_UNSPEC (const char *@var{label}, rtx @var{pattern}, int @var{index})
该target钩子允许后端生成帧相关的insn，其包含了UNSPECs或UNSPEC_VOLATILEs。
DWARF2调用帧调试信息引擎将会按照如下的形式来调用它
@smallexample
(set (reg) (unspec [@dots{}] UNSPEC_INDEX))
@end smallexample
和 
@smallexample
(set (reg) (unspec_volatile [@dots{}] UNSPECV_INDEX)).
@end smallexample
来使后端生成调用帧指令。@var{label}为insn附带的CFI标号，
@var{pattern}为insn的指令模式，
@var{index}为@code{UNSPEC_INDEX}或@code{UNSPECV_INDEX}。
@end deftypefn

@defmac INCOMING_FRAME_SP_OFFSET
一个C表达式，其值为一个整数，给出了偏移字节数，
从栈指针寄存器到任何函数的起始处，序言之前的栈帧的顶部。
帧的顶部被定义为之前帧的栈指针的值，就在call指令之前。

你只有当你想支持像DWARF2提供的那样的帧调试信息时才需要定义该宏。
@end defmac

@defmac ARG_POINTER_CFA_OFFSET (@var{fundecl})
一个C表达式，其值为一个整数，给出了偏移字节数，从参数指针到规范化帧地址（cfa）。
最终的值应该与通过@code{INCOMING_FRAME_SP_OFFSET}所计算的一致。
不幸的是这在虚寄存器实例化的时候不可用。

该宏的缺省值为@code{FIRST_PARM_OFFSET (fundecl)}，其对于大多数机器是正确的；
总的来说，参数在栈帧之前被找到。注意有些情况不是这样的，一些target将寄存器保存在调用者的帧中，像SPARC和rs6000，这样的target就不需要定义该宏。

你只有当缺省是不正确的时候，
以及你想支持像DWARF2提供的那样的帧调试信息时才需要定义该宏。
@end defmac

@defmac FRAME_POINTER_CFA_OFFSET (@var{fundecl})
如果被定义，则为一个C表达式，其值为一个整数，给出了偏移字节数，
从帧指针到规范化帧地址（cfa）。
最终的值应该与通过@code{INCOMING_FRAME_SP_OFFSET}所计算的一致。

通常CFA被作为参数指针的偏移量来计算，通过@code{ARG_POINTER_CFA_OFFSET}，
但是如果参数指针是一个变量，这就不太可能了。如果该宏被定义，
它暗示了虚寄存器实例化应该基于帧指针而不是参数指针。
@code{FRAME_POINTER_CFA_OFFSET}和@code{ARG_POINTER_CFA_OFFSET}只有一个应该被定义。
@end defmac

@defmac CFA_FRAME_BASE_OFFSET (@var{fundecl})
如果定义，则为一个C表达式，其值为一个整数，给出了偏移字节数，
从规范化帧地址（cfa）到DWARF2调试信息使用的frame base。缺省为0。
不同的值可以在一些port上减少调试信息的大小。
@end defmac

@node 异常处理
@subsection 对异常处理的支持
@cindex exception handling

@defmac EH_RETURN_DATA_REGNO (@var{N})
一个C表达式，其值为第@var{N}个寄存器的编号，用于异常处理的数据，
或者为@code{INVALID_REGNUM}，如果小于@var{N}个寄存器可用。

异常处理库程序与异常处理者通过一套协定好的寄存器来通讯。理想的，
这些寄存器应该为调用破坏的；可以使用调用保存的寄存器，
但可能会对代码大小产生负影响。target必须支持至少两个数据寄存器，
但如果有足够的可用的寄存器，则应该定义为4。

你必须定义该宏，如果你想支持像DWARF 2提供的调用帧异常处理。
@end defmac

@defmac EH_RETURN_STACKADJ_RTX
一个C表达式，其值为RTL，表示一个位置，用来存储栈调整，在函数返回前应用。
这用于unwind栈到一个异常处理的调用帧中。其将被赋予0在通常的返回代码路径上。

通常这是一个调用破坏的硬件寄存器，但也可以为一个栈槽。

不要定义该宏，如果栈指针在调用帧本身通过序言和尾声来保存和恢复时；
这种情况下，异常处理库函数将更新栈位置并保存。否则，你必须定义该宏，
如果你想支持调用帧异常处理，就像DWARF2提供的那样。
@end defmac

@defmac EH_RETURN_HANDLER_RTX
一个C表达式，其值为一个RTL，表示一个位置，用来存储我们应该返回的异常处理的地址。
其在通常的返回的代码路径上将不被赋值。

通常这是在调用帧中通常返回地址存储的位置。对于通过在栈中弹出地址的target，
这可以为一个内存地址，就在target调用帧的下面，而不是在当前调用帧中。
如果被定义，@code{EH_RETURN_STACKADJ_RTX}将已经被赋值，
所以其可以用于计算target调用帧的位置。

一些target具有更加复杂的要求，比在初始化代码生成阶段存储到地址中。
这种情况下，要替代的使用@code{eh_return}指令模式。

如果你想支持调用帧异常处理，你必须定义该宏或者@code{eh_return}指令模式。
@end defmac

@defmac RETURN_ADDR_OFFSET
如果定义，则为一个整数值的C表达式，并会为此生成rtl来加上异常处理地址，
在其在异常处理表中搜索之前，并且再减去它，在用它来返回到异常处理之前。
@end defmac

@defmac ASM_PREFERRED_EH_DATA_FORMAT (@var{code}, @var{global})
该宏选择在异常处理section中嵌入的指针的解码。如果尽可能，该宏应该被定义，
这样异常处理section将不会要求进行动态重定位，并可以为只读的。

@var{code}为0，对于数据，1对于代码标号，2对于函数指针。
@var{global}为真，如果符号可以由动态重定位影响。
宏应该返回在@file{dwarf2.h}中可以找到的@code{DW_EH_PE_*}的组合。

如果该宏没有定义，则指针将不被解码，而是直接表示。
@end defmac

@defmac ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX (@var{file}, @var{encoding}, @var{size}, @var{addr}, @var{done})
该宏允许target生成特定的magic，
用于表示@code{ASM_PREFERRED_EH_DATA_FORMAT}选择的encoding。
通常代码考虑pc-relative和indirect解码；
如果target使用text-relative或者data-relative解码，则必须定义该宏。

这是一个C语句，如果格式被处理，则执行分支跳转。@var{encoding}为选择的格式，
@var{size}为格式占用的字节数，@var{addr}为生成的@code{SYMBOL_REF}。
@end defmac

@defmac MD_UNWIND_SUPPORT
一个字符串，指定了文件在unwind-dw2.c中被#include包含进来。
被包含进来的文件通常定义了@code{MD_FALLBACK_FRAME_STATE_FOR}。
@end defmac

@defmac MD_FALLBACK_FRAME_STATE_FOR (@var{context}, @var{fs})
该宏允许target增加CPU和操作系统特定代码到call-frame unwinder，
用于当没有unwind数据可用时。最常见的原因是实现该宏来通过signal帧来unwind。

该宏由@file{unwind-dw2.c}, @file{unwind-dw2-xtensa.c}和@file{unwind-ia64.c}中的
@code{uw_frame_state_for}调用。@var{context}为一个@code{_Unwind_Context}；
@var{fs}为一个@code{_Unwind_FrameState}。检查@code{context->ra}来得到被执行的
代码的地址，检查@code{context->cfa}来得到栈指针的值。如果帧可以被解码，
则寄存器保存地址应该在@var{fs}中更新，并且宏应该求值为@code{_URC_NO_REASON}。
如果帧不能被解码，则宏应该求解为@code{_URC_END_OF_STACK}。

对于java中合适的信号处理，该宏通过@code{MAKE_THROW_FRAME}来应用，
在@file{libjava/include/*-signal.h}中定义。
@end defmac

@defmac MD_HANDLE_UNWABI (@var{context}, @var{fs})
该宏允许target增加操作系统特定的代码到调用帧unwinder，
来处理IA-64 @code{.unwabi} unwinding伪指令，通常用于signal或者interrrupt帧。

该宏由@file{unwind-ia64.c}中的@code{uw_update_context}调用。
@var{context}为一个@code{_Unwind_Context}；
@var{fs}为一个@code{_Unwind_FrameState}。检查@code{fs->unwabi}来得到abi。
如果@code{.unwabi}伪指令可以被处理，则寄存器保存地址应该在@var{fs}中更新。
@end defmac

@defmac TARGET_USES_WEAK_UNWIND_INFO
一个C表达式，计算为真，如果target需要unwind info给定comdat linkage。
定义其为@code{1}，如果comdat linkage有必要。缺省为@code{0}。
@end defmac

@node 栈检查
@subsection 指定如何进行栈检查

GCC将检查栈引用是否位于栈的边界里，如果指定了@option{-fstack-check}，
使用三种方式的之一：

@enumerate
@item
如果@code{STACK_CHECK_BUILTIN}宏的值为非0，
则GCC将假设你已经安排了在配置文件的合适的地方进行栈检查，例如，
在TARGET_ASM_FUNCTION_PROLOGUE中。GCC将不再做其它特殊的处理。

@item
If @code{STACK_CHECK_BUILTIN} is zero and the value of the
@code{STACK_CHECK_STATIC_BUILTIN} macro is nonzero, GCC will assume
that you have arranged for static stack checking (checking of the
static stack frame of functions) to be done at appropriate places
in the configuration files.  GCC will only emit code to do dynamic
stack checking (checking on dynamic stack allocations) using the third
approach below.

@item
如果上面两种方式都不是，则GCC将生成代码来周期的“探测”栈指针，
使用下面定义的宏的值。
@end enumerate

If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is defined,
GCC will change its allocation strategy for large objects if the option
@option{-fstack-check} is specified: they will always be allocated
dynamically if their size exceeds @code{STACK_CHECK_MAX_VAR_SIZE} bytes.

@defmac STACK_CHECK_BUILTIN
一个非0值，如果栈检查按照机器相关的方式通过配置文件来完成。
你应该定义该宏，如果栈检查被你的机器的ABI要求，
或者你想让栈检查使用比GCC可移植方式更有效的方法。该宏的缺省值为0。
@end defmac

@defmac STACK_CHECK_STATIC_BUILTIN
A nonzero value if static stack checking is done by the configuration files
in a machine-dependent manner.  You should define this macro if you would
like to do static stack checking in some more efficient way than the generic
approach.  The default value of this macro is zero.
@end defmac

@defmac STACK_CHECK_PROBE_INTERVAL
一个整数表示GCC必须生成栈探测指令的间隔。
你通常需要定义该宏为不大于在栈结尾处的“guard pages”的大小。
缺省值4096适合于大多数系统。
@end defmac

@defmac STACK_CHECK_PROBE_LOAD
一个整数，其为非0，如果GCC应该使用加载指令来执行栈探测，
为0如果GCC应该使用存储指令。缺省为0，其在大多数系统是更有效的选择。
@end defmac

@defmac STACK_CHECK_PROTECT
栈从栈溢出中恢复所需要的字节数，用于这样的恢复被支持的语言。
缺省值75个字应该适合大多数机器。
@end defmac

The following macros are relevant only if neither STACK_CHECK_BUILTIN
nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether
in the opposite case.

@defmac STACK_CHECK_MAX_FRAME_SIZE
一个栈帧的最大大小，以字节为单位。
GCC将生成探测指令在非叶子函数来确保栈中至少这么多大小的字节是可用的。
如果一个栈帧大于该大小，则栈检查将不可靠并且GCC将产生一个警告。缺省值被选择，
使得GCC只生成一条指令，在大多数系统上。你通常不应该修改该宏的缺省值。
@end defmac

@defmac STACK_CHECK_FIXED_FRAME_SIZE
GCC使用该值来生成上面的警告消息。其表示函数使用的固定的帧数量，
不包括用于任何被调用者保存的寄存器，临时变量和用户变量的空间。
你只需要指定该数量的上界并且通常使用缺省值，4个字。
@end defmac

@defmac STACK_CHECK_MAX_VAR_SIZE
为当用户指定@option{-fstack-check}时，GCC将在栈帧的固定域放入的对象的最大大小，
以字节为单位。GCC根据上面的宏来计算缺省值并且你通常不需要覆盖缺省值。
@end defmac

@need 2000
@node 帧寄存器
@subsection 用于栈帧寻址的寄存器

@c prevent bad page break with this line
这里讨论了用于栈帧寻址的寄存器。

@defmac STACK_POINTER_REGNUM
栈指针寄存器的寄存器编号，其还必须为一个@code{FIXED_REGISTERS}中的固定寄存器。
在大多数机器上，硬件决定了这是哪个寄存器。
@end defmac

@defmac FRAME_POINTER_REGNUM
帧指针寄存器的寄存器编号，其用于访问在栈帧中的自动变量。
在一些机器上，硬件决定了这是哪个寄存器。
在其它机器上，你可以选择任意寄存器来达到该目的。
@end defmac

@defmac HARD_FRAME_POINTER_REGNUM
在一些机器上，帧指针和自动变量的起始处之间的偏移量直到寄存器分配进行完之后才知道
（例如，因为保存寄存器位于这两个位置之间）。这些机器上，
定义@code{FRAME_POINTER_REGNUM}为一个特定的固定寄存器的编号，在内部使用，
直到位移已知，并且定义@code{HARD_FRAME_POINTER_REGNUM}为实际的硬件寄存器，
用于帧指针。

你只需要在非常少见的情况下定义该宏，当不可能计算帧指针和自动变量的偏移时，
并且直到寄存器分配完成。当该宏被定义，
你必须还要在你的@code{ELIMINABLE_REGS}的定义中指示如果消除
@code{FRAME_POINTER_REGNUM}为@code{HARD_FRAME_POINTER_REGNUM}或者
@code{STACK_POINTER_REGNUM}。

如果其与@code{FRAME_POINTER_REGNUM}相同，则不要定义该宏。
@end defmac

@defmac ARG_POINTER_REGNUM
arg指针寄存器的寄存器编号，其用于访问函数的参数列表。在大多数机器上，
这与帧指针寄存器相同。在一些机器上，硬件决定了其为那个寄存器。在其它机器上，
你可以选择任意的寄存器。如果这与帧指针寄存器不同，
则你必须标记其为一个固定寄存器，
根据@code{FIXED_REGISTERS}或者设法能够消除它（参见@ref{消除}）。
@end defmac

@defmac RETURN_ADDRESS_POINTER_REGNUM
返回地址指针寄存器的寄存器编号，其用于访问栈中当前函数的返回地址。
在一些机器上，返回地址不在帧指针或栈指针或参数指针的固定偏移处。
该寄存器被定义指向栈中的返回地址，
并且然后通过@code{ELIMINABLE_REGS}转换为帧指针或者栈指针。

不要定义该宏，除非没有其他的方式从栈中获得返回地址。
@end defmac

@defmac STATIC_CHAIN_REGNUM
@defmacx STATIC_CHAIN_INCOMING_REGNUM
用于传递函数static链指针的寄存器编号。如果寄存器窗口被使用，
则寄存器编号由被调用函数所看到是@code{STATIC_CHAIN_INCOMING_REGNUM}，
而由调用者函数看到的是@code{STATIC_CHAIN_REGNUM}。如果这些寄存器是相同的，
则不需要定义@code{STATIC_CHAIN_INCOMING_REGNUM}。

静态链寄存器不需要为一个固定寄存器。

如果静态链在内存中传递，则这些宏不需要定义；替代的，应该定义下面的两个宏。
@end defmac

@defmac STATIC_CHAIN
@defmacx STATIC_CHAIN_INCOMING
如果静态链在内存中传递，则这些宏提供了给出它们存储的@code{mem}表达式rtx。
@code{STATIC_CHAIN}和@code{STATIC_CHAIN_INCOMING}分别给出了由调用者和被调用函数
所看到的位置。通常前者将在栈指针的一个偏移处并且后者将在帧指针的一个偏移处。

@findex stack_pointer_rtx
@findex frame_pointer_rtx
@findex arg_pointer_rtx
变量@code{stack_pointer_rtx}, @code{frame_pointer_rtx}和@code{arg_pointer_rtx}将在使用这些宏之前被初始化，并可以引用。

如果静态链在寄存器中传递，则应该定义之前的两个宏。
@end defmac

@defmac DWARF_FRAME_REGISTERS
该宏指定了可以在一个调用帧中被保存的硬件寄存器的最大数。
这用于DWARF2异常处理中的size数据结构体。

在GCC3.0之前，该宏需要用来建立一个稳定的异常处理ABI。

如果该宏没有被定义，其缺省为@code{FIRST_PSEUDO_REGISTER}。
@end defmac

@defmac PRE_GCC3_DWARF_FRAME_REGISTERS
该宏类似于@code{DWARF_FRAME_REGISTERS}，是为了向后兼容在GCC3.0之前编译的代码而提供。

如果没有定义该宏，其缺省为@code{DWARF_FRAME_REGISTERS}。
@end defmac

@defmac DWARF_REG_TO_UNWIND_COLUMN (@var{regno})
定义该宏，如果target对于dwarf寄存器的表示与对于unwind column的内部表示不相同。
给定一个dwarf寄存器，该宏应该返回替代使用的内部unwind column编号。

例子参见PowerPC's SPE target。
@end defmac

@defmac DWARF_FRAME_REGNUM (@var{regno})
定义该宏，如果target对于用在.eh_frame或者.debug_frame的dwarf寄存器的表示与用在
其它调试信息section中的不同。给定一个GCC硬件寄存器编号，该宏应该返回.eh_frame
寄存器编号。缺省为@code{DBX_REGISTER_NUMBER (@var{regno})}。
@end defmac

@defmac DWARF2_FRAME_REG_OUT (@var{regno}, @var{for_eh})
定义该宏来影射在调用帧信息中存放的寄存器编号，
其为GCC使用@code{DWARF_FRAME_REGNUM}来搜集的应该放在.debug_frame
（@code{@var{for_eh}}为0）和.eh_frame（@code{@var{for_eh}}为非0）中的寄存器。
缺省为返回@code{@var{regno}}。
@end defmac

@node 消除
@subsection 消除帧指针和参数指针

@c prevent bad page break with this line
这些是关于消除帧指针和参数指针的。

@defmac FRAME_POINTER_REQUIRED
一个C表达式，其为非0，如果函数必须具有并且使用帧指针。
该表达式在重载过程被求值。如果值为非零，则函数将具有一个帧指针。

原则上表达式可以检查当前函数并根据事实来决定，但在大多数机器上，
常量0或者1就足够了。使用0当机器允许生成的代码不具有帧指针，
这将节省一些时间或空间。使用1当避免帧指针不会带来好处。

在一些情况下，编译器不知道如何生成没有帧指针的有效的代码。
编译器识别到哪些情况，并自动的给函数一个帧指针，
而不管@code{FRAME_POINTER_REQUIRED}如何。你不需要为此担心。

在不需要帧指针的函数中，帧指针寄存器可以被分配用于普通用法，
除非你标记其为一个固定寄存器。更多信息，参见@code{FIXED_REGISTERS}。
@end defmac

@findex get_frame_size
@defmac INITIAL_FRAME_POINTER_OFFSET (@var{depth-var})
一条C语句，用来紧接着函数序言之后，
将帧指针和栈指针值的差存储在@var{depth-var}中。
该值应该通过像@code{get_frame_size ()}这样的结果信息以及寄存器表
@code{regs_ever_live}和@code{call_used_regs}中被计算。

如果@code{ELIMINABLE_REGS}被定义，则该宏将不被使用并不需要被定义。
否则，其必须被定义，即使@code{FRAME_POINTER_REQUIRED}被定义为总是为真；
这这种情况下，你可以设置@var{depth-var}为任何值。
@end defmac

@defmac ELIMINABLE_REGS
如果被定义，则该宏指定了一个寄存器双对的表，用于消除不需要的指向栈帧的寄存器。
如果没有被定义，则编译器唯一尝试去做的消除是将对帧指针的引用替换为对栈指针的引用。

该宏的定义为一个结构体初始化列表，每个指定了最初的和替换后的寄存器。

在一些机器上，参数指针的位置直到编译结束时才知道。这种情况下，
一个单独的硬件寄存器必须用于参数指针。
该寄存器可以通过替换为帧指针或者参数指针来消除，这取决于帧指针是否已经被消除。

这种情况下，你可能会指定：

@smallexample
#define ELIMINABLE_REGS  \
@{@{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM@}, \
 @{ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM@}, \
 @{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM@}@}
@end smallexample

注意首先指定的是使用栈指针来消除参数指针，因为这是首选的消除方式。
@end defmac

@defmac CAN_ELIMINATE (@var{from-reg}, @var{to-reg})
一个C表达式，其返回非0，
如果编译器被允许尝试使用寄存器编号@var{to-reg}来替换寄存器编号@var{from-reg}。
该宏只在@code{ELIMINABLE_REGS}被定义时才需要定义，并且通常为常量1，
因为大多数情况下编译器已经知道是否不该进行寄存器消除。
@end defmac

@defmac INITIAL_ELIMINATION_OFFSET (@var{from-reg}, @var{to-reg}, @var{offset-var})
该宏类似于@code{INITIAL_FRAME_POINTER_OFFSET}。
其指定了被指定的寄存器双对的初始差。该宏必须被定义，
如果@code{ELIMINABLE_REGS}被定义。
@end defmac

@node 栈参数
@subsection 在栈上传递函数参数
@cindex arguments on stack
@cindex stack arguments

该节的宏控制如何在栈上传递参数。关于控制在寄存器中传递特定参数的其它宏，
参见后续的章节。

@deftypefn {Target Hook} bool TARGET_PROMOTE_PROTOTYPES (tree @var{fntype})
该target钩子返回@code{true}，如果在函数原型中声明的一个参数，
为整型的并且比@code{int}小，应该作为@code{int}来传递。
除了能够避免一些不匹配的错误以外，其还能在特定机器上生成更好的代码。
缺省为不提升原型。
@end deftypefn

@defmac PUSH_ARGS
一个C表达式。如果非0，则将使用push insn来传递输出参数。
如果target机器不具有push指令，则设置其为0。这将指示GCC使用替代的策略：
分配整个参数块然后将参数存进去。当@code{PUSH_ARGS}为非0时，
@code{PUSH_ROUNDING}也必须被定义。
@end defmac

@defmac PUSH_ARGS_REVERSED
一个C表达式。如果非0，则函数参数将按照从最后一个到第一个的顺序来求值，
而不是从第一个到最后一个。如果该宏没被定义，其缺省为@code{PUSH_ARGS}，
在栈和args按照相反的顺序进行增长的target上，否则为0。
@end defmac

@defmac PUSH_ROUNDING (@var{npushed})
一个C表达式，其为当一个指令试图压入@var{npushed}个字节时，实际压入栈中的字节数。

在一些机器上，定义

@smallexample
#define PUSH_ROUNDING(BYTES) (BYTES)
@end smallexample

@noindent
便可以满足。但是在其它机器上，指令压入一个字节时，
而为了保持对齐实际压入了两个字节。则定义应该为

@smallexample
#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)
@end smallexample
@end defmac

@findex current_function_outgoing_args_size
@defmac ACCUMULATE_OUTGOING_ARGS
一个C表达式。如果非0，则为输出参数中将被计算并放进变量
@code{current_function_outgoing_args_size}所需要的空间最大数目。
对于每个调用，将不会有空间被压入栈中；替代的，函数序言应该增加栈帧的大小。

同时设置@code{PUSH_ARGS}和@code{ACCUMULATE_OUTGOING_ARGS}是不合适的。
@end defmac

@defmac REG_PARM_STACK_SPACE (@var{fndecl})
定义该宏，如果函数应该假设参数的栈空间已经被分配，
即使它们的值是在寄存器中被传递的。

该宏的值是一个@var{fndecl}表示的函数在寄存器中传递的参数的保留空间的大小，
字节为单位，其可以为0如果GCC在调用一个库函数。

该空间可以被调用者分配，或者为机器相关的栈帧的一部分：
这由@code{OUTGOING_REG_PARM_STACK_SPACE}决定。
@end defmac
@c above is overfull.  not sure what to do.  --mew 5feb93  did
@c something, not sure if it looks good.  --mew 10feb93

@defmac OUTGOING_REG_PARM_STACK_SPACE (@var{fntype})
定义该宏为一个非0值，如果分配在寄存器中传递的参数的保留空间，是由调用者负责。

如果@code{ACCUMULATE_OUTGOING_ARGS}被定义，
则该宏控制这些参数的空间是否算在@code{current_function_outgoing_args_size}中。
@end defmac

@defmac STACK_PARMS_IN_REG_PARM_AREA
定义该宏，如果@code{REG_PARM_STACK_SPACE}被定义，
但是栈参数不跳过其所指定的区域。

通常，当一个参数没有在寄存器中传递时，
其被放在@code{REG_PARM_STACK_SPACE}区域之外的栈上。
定义该宏来抑制这种行为并使得在栈上传递的参数按照它的自然位置。
@end defmac

@defmac RETURN_POPS_ARGS (@var{fundecl}, @var{funtype}, @var{stack-size})
一个C表达式，指示函数在返回时所弹出的它自己的参数的字节个数，
或者为0如果函数不弹出参数并且调用者必须在函数返回后弹出它们。

@var{fundecl}为一个C变量，其值为一个树节点，描述了被讨论的函数。
通常其为一个@code{FUNCTION_DECL}类型的节点，描述了函数的声明。
你可以从中获得函数的@code{DECL_ATTRIBUTES}。

@var{funtype}为一个C变量，其值为一个树节点，描述了被讨论的函数。
通常其为一个@code{FUNCTION_TYPE}类型的节点，描述了函数的数据类型。
从中可以获得函数值和参数的数据类型（如果知道的话）。

当正在被考虑的函数是一个库函数调用时，
@var{fundecl}将包含一个库函数的标志符节点。这样，如果你需要区别不同的库函数，
则可以通过它们的名字进行。注意该上下文中的“库函数”是指用于执行算术的库函数，
其名字在编译器中是已知的并且在被编译的C代码中没有被提到。

@var{stack-size}为在栈上传递的参数的字节数。如果是传递的字节数是可变的，
则为0，并且参数弹出将总是为被调用函数的责任。

在VAX上，所有的函数总是弹出它们的参数，所以该宏的定义为@var{stack-size}。
在68000上，使用标准的调用约定，没有函数弹出它们的参数，
所以对于这种情况该宏的值总是0。但是也可以使用可选的调用约定，
这种情况下函数接受固定数目参数的将弹出它们，
其它的函数（例如@code{printf}）则不弹出（由调用者来弹出所有参数）。
当使用这种约定时，@var{funtype}被检查用来确定一个函数是否接受了固定数目的参数。
@end defmac

@defmac CALL_POPS_ARGS (@var{cum})
一个C表达式，指示一个调用序列从栈中弹出的字节数目。
其被加到@code{RETURN_POPS_ARGS}的值中，当编译一个函数调用时。

@var{cum}为一个变量，为被调用函数的所有参数的累积。

在特定的体系结构上，例如SH5，一个调用蹦床被用于弹出栈上特定的寄存器，
根据被传递给函数的参数。因为这是调用方的属性，而不是被调用函数的，
所以@code{RETURN_POPS_ARGS}不太适合。
@end defmac

@node 寄存器参数
@subsection 在寄存器中传递参数
@cindex arguments in registers
@cindex registers arguments

这节描述了让你控制不同类型的参数如何在寄存器中传递，
或者它们如何被安排在栈中的宏。

@defmac FUNCTION_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})
— Macro: FUNCTION_ARG (cum, mode, type, named)

一个C表达式，控制函数的参数是否在寄存器中传递，以及在那个寄存器中传递。

参数为@var{cum}，其总结了所有之前的参数；@var{mode}，参数的机器模式；
@var{type}，参数的数据类型，作为一个树节点或者0如果不知道（这发生于C支持库的
函数）；@var{named}，其为1对于普通参数，0对于无名参数，
对应于在被调用函数原型中的@samp{@dots{}}。@var{type}可以为一个不完全类型，
如果之前产生了语法错误。

表达式的值通常为一个在其中传递参数的硬件寄存器的@code{reg} RTX，或者0，
在栈上传递参数。

对于像VAX和68000的机器，其通常所有参数被压栈，则定义为0就行。

表达式的值也可以为一个@code{parallel} RTX。这用于当参数在多个位置传递的时候。
@code{parallel}的机器模式应该为整个参数的机器模式。
@code{parallel}保存了任意数目的@code{expr_list}对；
每一个描述了该部分参数在哪里传递，
@code{reg} RTX的机器模式指示了该部分的参数有多大。
@code{expr_list}的第二个操作数为一个const_int，
其给出了该部分起始处与整个参数的偏移字节数。作为一个特例，
@code{parallel} RTX中的第一个@code{expr_list}的第一个操作数可以为0。
这意味着整个参数也在栈中存储。

该宏最后一次被调用的时候，@code{MODE == VOIDmode}，
并且结果被传递给@code{call}或者@code{call_value}指令模式，分别作为其操作数2和3。

@cindex @file{stdarg.h} and register arguments
通常使ISO库@file{stdarg.h}在一些参数在寄存器中传递的机器上工作的方法，
是使无名参数在栈上传递。这通过使@code{FUNCTION_ARG}当@var{named}为0时返回0来实现。

@cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{FUNCTION_ARG}
@cindex @code{REG_PARM_STACK_SPACE}, and @code{FUNCTION_ARG}
你可以在该宏的定义中，使用钩子@code{targetm.calls.must_pass_in_stack}来确定该
参数是否为一个必须在栈中传递的类型。如果@code{REG_PARM_STACK_SPACE}没有定义并且
@code{FUNCTION_ARG}对于这样的参数返回非0，则编译器会abort。
如果@code{REG_PARM_STACK_SPACE}被定义，则参数会在栈中计算并且然后加载到寄存器中。
@end defmac

@deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (enum machine_mode @var{mode}, tree @var{type})
该target钩子应该返回@code{true}，如果我们不应该只在寄存器中传递@var{type}。
文件@file{expr.h}中有一个定义，其通常是合适的，更多的文档请参考@file{expr.h}。
@end deftypefn

@defmac FUNCTION_INCOMING_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})
定义该宏，如果target机器具有“寄存器窗口”，
这样函数看到的参数寄存器没有必要与调用者传递参数的寄存器相同。

对于这样的机器，@code{FUNCTION_ARG}计算调用者传递值的寄存器，
@code{FUNCTION_INCOMING_ARG}应该按照类似的方式定义，
来告诉被调用的函数参数在哪里到来。

如果@code{FUNCTION_INCOMING_ARG}没有定义，则@code{FUNCTION_ARG}具有这两种用途。
@end defmac

@deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})
该target钩子返回在参数的起始处必须被放入寄存器的字节数。
值必须为0对于参数全部放在寄存器中或者全部压入栈中。

一些机器上，特定的参数必须部分在寄存器中传递并且部分在内存中传递。
在这些机器上，通常参数的起始一些字在寄存器中传递，其余的在栈上。
如果一个多字的参数（@code{double}或者结构体）跨越了边界，
则其起始的一些字必须在寄存器中传递并且剩余的被压栈。
该宏告诉编译器这种情况什么时候发生，以及多少字节应该在寄存器中。

@code{FUNCTION_ARG}对于这些参数应该返回第一个寄存器，被调用者用于该参数；
通常@code{FUNCTION_INCOMING_ARG}用于被调用的函数。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})
该target钩子应该返回@code{true}，
如果@var{cum}所指示的位置的参数应该按照引用的方式来传递。

如果钩子返回真，则参数的副本在内存中产生并且指向参数的指针被替代参数本身来传递。
指针按照传递该类型的指针的方式来传递。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CALLEE_COPIES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})
由该钩子的参数所描述的函数的参数已知为通过引用来传递的。钩子应该返回真，
如果函数参数应该由被调用者复制，而不是调用者。

对于任何该钩子返回真的参数，如果其可以被确定参数没有被修改，则不需要产生副本。

该钩子的缺省版本总是返回假。
@end deftypefn

@defmac CUMULATIVE_ARGS
一个C类型，用来声明一个变量，
被用作@code{FUNCTION_ARG}的第一个参数以及其它相关的值。对于一些target机器，
类型@code{int}可以满足并且目前可以保持参数的字节数。

不需要在@code{CUMULATIVE_ARGS}中记录任何已经在栈中传递的参数的信息。
编译器有其它变量来记录。对于所有参数在栈上传递的target机器，
不需要在@code{CUMULATIVE_ARGS}中保存任何事物；然而，
数据结构体必须存在并且不能为空，因此可以使用@code{int}。
@end defmac

@defmac OVERRIDE_ABI_FORMAT (@var{fndecl})

If defined, this macro is called before generating any code for a
function, but after the @var{cfun} descriptor for the function has been
created.  The back end may use this macro to update @var{cfun} to
reflect an ABI other than that which would normally be used by default.
If the compiler is generating code for a compiler-generated function,
@var{fndecl} may be @code{NULL}.
@end defmac

@defmac INIT_CUMULATIVE_ARGS (@var{cum}, @var{fntype}, @var{libname}, @var{fndecl}, @var{n_named_args})
一条C语句（没有分号），用于初始化变量@var{cum}，在参数列表的起始处。
变量具有类型@code{CUMULATIVE_ARGS}。@var{fntype}的值为树节点，
为将要接受参数的函数的数据类型，或者为0如果参数是传给编译器支持库的函数。
对于直接调用，没有libcall，@var{fndecl}包含了被编译的函数。
@var{fndecl}在当@code{INIT_CUMULATIVE_ARGS}被用于查找被编译的函数的参数时，
也被设置。@var{n_named_args}被设为命名参数的个数，包括一个结构体返回地址，
如果其作为参数被传递。当处理流入参数时，@var{n_named_args}被设为-1。

当处理对编译器支持库的函数的调用时，@var{libname}指示了为哪一个函数。
其为一个@code{symbol_ref} rtx，包含了函数的名字，作为字符串。@var{libname}为0，
当一个普通C函数被处理。因此，每次该宏被调用时，
或者@var{libname}或者@var{fntype}为非 0，但不会同时非0。
@end defmac

@defmac INIT_CUMULATIVE_LIBCALL_ARGS (@var{cum}, @var{mode}, @var{libname})
类似于@code{INIT_CUMULATIVE_ARGS}，但只用于流出的libcall，
其接受一个@code{MODE}参数而不是@var{fntype}。如果该宏没有定义，
则使用@code{INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname,0)}来替代。
@end defmac

@defmac INIT_CUMULATIVE_INCOMING_ARGS (@var{cum}, @var{fntype}, @var{libname})
类似于@code{INIT_CUMULATIVE_ARGS}，但会覆盖其，用于查找被编译的函数的参数。
如果该宏没有被定义，则使用@code{INIT_CUMULATIVE_ARGS}来替代。

传递给@var{libname}的值总是为0，因为库函数具有特定的调用约定，从来不被GCC编译。
参数@var{libname}的存在是为了与@code{INIT_CUMULATIVE_ARGS}对称。
@end defmac

@defmac FUNCTION_ARG_ADVANCE (@var{cum}, @var{mode}, @var{type}, @var{named})
一条C语句（没有分号），来更新总结变量@var{cum}来在参数列表中前进一个参数。
值@var{mode}, @var{type}和@var{named}描述了那个参数。一旦执行后，
变量@var{cum}便适合分析随后的参数。

该宏不需要做任何事情，如果要询问的参数是在栈中传递的。
编译器知道如何追踪用于参数的栈空间，不需要任何特殊帮助。
@end defmac


@defmac FUNCTION_ARG_OFFSET (@var{mode}, @var{type})
If defined, a C expression that is the number of bytes to add to the
offset of the argument passed in memory.  This is needed for the SPU,
which passes @code{char} and @code{short} arguments in the preferred
slot that is in the middle of the quad word instead of starting at the
top.
@end defmac

@defmac FUNCTION_ARG_PADDING (@var{mode}, @var{type})
如果被定义，则为一个C表达式，其确定是否使用额外的空间来填补参数，
以及按照什么方向。值应该为类型@code{enum direction}：或者@code{upward}，
向上填补参数，@code{downward}向下，或者@code{none}不进行填补。

填补的数目总是刚足够达到下一个@code{FUNCTION_ARG_BOUNDARY}的倍数；
该宏不进行控制。

该宏具有一个缺省定义，其对大多数系统是对的。对于小端机器，缺省为向上填补。
对于大端机器，缺省为如果参数的大小比@code{int}短则向下填补，否则向上。
@end defmac

@defmac PAD_VARARGS_DOWN
如果定义，则为一个C表达式，其确定va_arg的缺省实现是否会尝试向下填补，
在读取下一个参数之前，如果那个参数比@code{PARM_BOUNDARY}所控制的对齐空间要小。
如果该宏没有定义，则所有这样的参数都被向下填补，
如果@code{BYTES_BIG_ENDIAN}为真。
@end defmac

@defmac BLOCK_REG_PADDING (@var{mode}, @var{type}, @var{first})
指定了寄存器和内存间移动的块的最后一个元素的填补。@var{first}为非0，
如果这是唯一的元素。定义该宏，允许更好的处理在大端机器上寄存器函数参数，
不使用@code{PARALLEL} rtl。特别的，
@code{MUST_PASS_IN_STACK}不需要测试填充和寄存器中的类型的机器模式，
因为在寄存器中不在有“错误的”部分；例如，
一个三字节的聚合类型可能在寄存器的高部传递，如果需要的话。
@end defmac

@defmac FUNCTION_ARG_BOUNDARY (@var{mode}, @var{type})
如果定义，为一个C表达式，其给出了指定的mode和type的参数的对齐边界位数。
如果没有定义，则@code{PARM_BOUNDARY}用于所有参数。
@end defmac

@defmac FUNCTION_ARG_REGNO_P (@var{regno})
一个C表达式，其为非0，如果@var{regno}为硬件寄存器的编号，
函数参数有时在其中传递。这不包括隐式参数，像静态链和结构体值的地址。
在许多机器上，没有寄存器可以用于此目的，因为所有函数参数都被压到栈上。
@end defmac

@deftypefn {Target Hook} bool TARGET_SPLIT_COMPLEX_ARG (tree @var{type})
该钩子应该返回真，如果参数@var{type}作为两个标量参数传递。缺省的，
GCC将尝试将复数参数打包成target的字大小。
一些ABI要求复数参数要被拆分开并且作为单独的部分对待。例如，在AIX64上，
复数浮点应该在一对浮点寄存器中传递，即使复数浮点可以适合一个64位的浮点寄存器。

该钩子的缺省值为@code{NULL}，其被最为假来对待。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_BUILD_BUILTIN_VA_LIST (void)
该钩子返回一个target的@code{va_list}的类型节点。缺省版本返回@code{void*}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_FN_ABI_VA_LIST (tree @var{fndecl})
This hook returns the va_list type of the calling convention specified by
@var{fndecl}.
The default version of this hook returns @code{va_list_type_node}.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_CANONICAL_VA_LIST_TYPE (tree @var{type})
This hook returns the va_list type of the calling convention specified by the
type of @var{type}. If @var{type} is not a valid va_list type, it returns
@code{NULL_TREE}.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree @var{valist}, tree @var{type}, tree *@var{pre_p}, tree *@var{post_p})
该钩子执行target特定的@code{VA_ARG_EXPR}的gimplification。
前两个参数对应于@code{va_arg}的参数；后两个作为@code{gimplify.c:gimplify_expr}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VALID_POINTER_MODE (enum machine_mode @var{mode})
定义该钩子返回非0，如果port可以处理具有机器模式@var{mode}的指针。
缺省版本对于@code{ptr_mode}和@code{Pmode}都返回真。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SCALAR_MODE_SUPPORTED_P (enum machine_mode @var{mode})
定义该钩子来返回非0，如果port准备好了处理涉及标量机器模式@var{mode}的insn。
对于被考虑支持的一个标量机器模式，所有的基本算术和比较都必须能工作。

缺省版本返回真，对于任何要求处理基本C类型（被port定义）的机器模式。
包括在@file{optabs.c}中的代码支持的双字算术。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VECTOR_MODE_SUPPORTED_P (enum machine_mode @var{mode})
定义该钩子来返回非0，如果port准备好了处理涉及向量模式@var{mode}的insn。
最起码，其必须有该机器模式的move指令模式。
@end deftypefn

@node 标量返回
@subsection 标量函数值如何被返回
@cindex return values in registers
@cindex values, returned by functions
@cindex scalars, returned as values

这节讨论了控制返回标量值的宏，值可以放在寄存器中。

@deftypefn {Target Hook} rtx TARGET_FUNCTION_VALUE (tree @var{ret_type}, tree @var{fn_decl_or_type}, bool @var{outgoing})
定义该宏返回一个RTX，用来表示函数返回或者接受数据类型为@var{ret_type}的值的
地方。@var{ret_type}为一个树节点，表示一个数据类型。 
@var{fn_decl_or_type}为一个树节点，表示被调用的函数的@code{FUNCTION_DECL}或者
@code{FUNCTION_TYPE}。如果@var{outgoing}为假，
则钩子应该计算调用者将要看到返回值的寄存器。否则，钩子应该返回一个RTX，
其表示函数在哪儿返回一个值。

在许多机器上，只有@code{TYPE_MODE (@var{ret_type})}是相关的。
（实际上，在大多数机器上，标量值不管机器模式如何，都在同一地方返回。）
表达式的值通常为一个硬件寄存器的@code{reg} RTX，为存放返回值的地方。
该值还可以为一个@code{parallel} RTX，如果返回值在多个地方。
对于@code{parallel}形式的解释，参见@code{FUNCTION_ARG}。
m68k port使用了这种@code{parallel}类型来返回指针，
在@samp{%a0}(规范化位置) 和@samp{%d0}中。

如果@code{TARGET_PROMOTE_FUNCTION_RETURN}返回真，如果valtype为一个标量类型，
则你必须应用在@code{PROMOTE_MODE}中指定的相同的提升规则。

如果确切的知道被调用的函数，则@var{func}为它的树节点（@code{FUNCTION_DECL}）；
否则，@var{func}为一个空指针。这是的可以使用不同的值返回约定，
对于所有调用都知道的特定的函数。

一些target机器具有“寄存器窗口”，
这使得函数返回它的值所用的寄存器与调用者看到值所在的寄存器不同。
对于这样的机器，你应该返回不同的RTX，根据@var{outgoing}。

@code{TARGET_FUNCTION_VALUE}不用于返回聚合数据类型的值，
因为这些通过其它方式返回。参见下面的@code{TARGET_STRUCT_VALUE_RTX}以及相关的宏。
@end deftypefn

@defmac FUNCTION_VALUE (@var{valtype}, @var{func})
该宏已经不赞成被使用。对于新的target，使用@code{TARGET_FUNCTION_VALUE}来替代。
@end defmac

@defmac FUNCTION_OUTGOING_VALUE (@var{valtype}, @var{func})
该宏已经不赞成被使用。对于新的target，使用@code{TARGET_FUNCTION_VALUE}来替代。
@end defmac

@defmac LIBCALL_VALUE (@var{mode})
一个C表达式，用来创建一个RTX，表示库函数返回模式@var{mode}的值的地方。
如果确切的知道被调用的函数，则func为它的树节点（FUNCTION_DECL）；
否则func为一个空指针。这使得可以使用不同的值返回约定，
对于所有调用都知道的特定的函数。

注意“库函数”在该上下文中意味着是编译器支持的程序，用于执行算术运算，
其名字由编译器知道并且没有在被编译的C代码中提到。

LIBRARY_VALUE的定义不需要考虑聚合数据类型，因为没有库函数返回这样的类型。
@end defmac

@defmac FUNCTION_VALUE_REGNO_P (@var{regno})
一个C表达式，为非0，如果@var{regno}为硬件寄存器的编号，
且被调用的函数可以通过它来返回值。

用于返回值的寄存器，并且其被限制为一个寄存器对（比如，
对于类型@code{double}的值）的第二个时，不需要被该宏识别。
所以对于大多数机器，该定义可以为：

@smallexample
#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)
@end smallexample

如果机器具有寄存器窗口，使得调用者和被调用函数使用不同的寄存器来返回值，
则该宏应该只是识别调用者的寄存器编号。
@end defmac

@defmac TARGET_ENUM_VA_LIST (@var{idx}, @var{pname}, @var{ptype})
This target macro is used in function @code{c_common_nodes_and_builtins}
to iterate through the target specific builtin types for va_list. The
variable @var{idx} is used as iterator. @var{pname} has to be a pointer
to a @code{const char *} and @var{ptype} a pointer to a @code{tree} typed
variable.
The arguments @var{pname} and @var{ptype} are used to store the result of
this macro and are set to the name of the va_list builtin type and its
internal type.
If the return value of this macro is zero, then there is no more element.
Otherwise the @var{IDX} should be increased for the next call of this
macro to iterate through all types.
@end defmac

@defmac APPLY_RESULT_SIZE
定义该宏，如果@samp{untyped_call}和@samp{untyped_return}需要比
@code{FUNCTION_VALUE_REGNO_P}用于保存和恢复一个任意返回地址所用的更多的空间。
@end defmac

@deftypefn {Target Hook} bool TARGET_RETURN_IN_MSB (tree @var{type})
该钩子应该返回真，如果类型@var{type}的值按照在寄存器中的最高有效位返回
（换句话说，如果他们在最低有效位进行被padded）。
你可以假设该@var{type}在寄存器中被返回；调用者被要求进行该检查。

注意@code{TARGET_FUNCTION_VALUE}提供的寄存器必须能够保存完整的返回值。
例如，如果一个1，2或者3字节的结构体被返回，按照4字节寄存器中的最高有效位的方式，
则@code{TARGET_FUNCTION_VALUE}应该提供一个@code{SImode} rtx。
@end deftypefn

@node 聚合返回
@subsection 如何返回大的值
@cindex aggregates as return values
@cindex large return values
@cindex returning aggregate values
@cindex structure value address

当函数值的机器模式为@code{BLKmode}（并且在一些其它情况下），
值不根据@code{TARGET_FUNCTION_VALUE}来返回（参见 @ref{标量返回}）。
替代的，调用者传递内存块的地址。
该地址被称为结构体地址（@dfn{structure value address}）。

这一节描述了如何控制在内存中返回结构体值。

@deftypefn {Target Hook} bool TARGET_RETURN_IN_MEMORY (tree @var{type}, tree @var{fntype})
该target钩子应该返回一个非零值，来指明在内存中返回函数值，
正如返回大的结构体的方式。这里@var{type}为值的数据类型，
@var{fntype}为函数的类型，或者@code{NULL}，如果是libcall。

注意模式@code{BLKmode}的值必须被该函数显示的处理。
而且，选项@option{-fpcc-struct-return}将会其作用，
而不管该宏如何定义。在大多数系统上，可能会没有定义该钩子；
这将使用一个缺省定义，其值为常数1对于@code{BLKmode}值，其它的为0。

不要使用该宏来指示结构体和联合体应该总是在内存中返回。
你应该使用@code{DEFAULT_PCC_STRUCT_RETURN}来做这件事情。
@end deftypefn

@defmac DEFAULT_PCC_STRUCT_RETURN
定义该宏为1，如果所有的结构体和联合体返回值必须在内存中。
由于这将使得代码变慢，所以应该只有需要与其它编译器或者ABI兼容时才定义。
如果你定义了该宏为0，
则对于结构体和联合体返回值的约定则由@code{TARGET_RETURN_IN_MEMORY} target钩子来决定。

如果没有定义，将缺省为1。
@end defmac

@deftypefn {Target Hook} rtx TARGET_STRUCT_VALUE_RTX (tree @var{fndecl}, int @var{incoming})
该target钩子应该返回结构体值的地址位置（通常为@code{mem}或者@code{reg}），
或者0，如果地址作为“不可视”的第一个参数传递。
注意@var{fndecl}可以为@code{NULL}，对于libcall。
你不需要定义该target钩子，如果地址总是作为“不可视”的第一个参数传递。

在一些体系结构上，
被调用函数寻找结构体值地址的地方与调用者放入的地方不相同。
这可能是由于寄存器窗口，或者函数序言将其移动到一个不同的地方。
@var{incoming}为@code{1}或者@code{2}，
当地址在被调用函数的上下文中需要，
为@code{0}如果在调用者的上下文中需要。

如果@var{incoming}为非0并且地址是在栈中找到，
则返回一个@code{mem}，其引用帧指针。
如果@var{incoming}为@code{2}，
则结果用于在函数的起始处获取结构体值的地址。
如果你需要输出调整代码，你应该在这里进行。
@end deftypefn

@defmac PCC_STATIC_STRUCT_RETURN
定义该宏，如果在target机器上的通常的系统约定，
对于返回结构体和联合体，为被调用函数返回包含该值的静态变量的地址。

不要定义该宏，如果通常的系统约定为调用者将地址传给子程序。

该宏具有@option{-fpcc-struct-return}模式下的效果，
但是当你使用@option{-freg-struct-return}模式时，其将不做任何事。
@end defmac

@node 调用者保存
@subsection 调用者保存的寄存器分配

如果你使用这种功能，GCC可以将寄存器保存在函数调用附近。
这使得可以使用调用破坏的（call-clobbered）寄存器来存放必须活跃于调用之间的变量。

@defmac CALLER_SAVE_PROFITABLE (@var{refs}, @var{calls})
一个C表达式来确定是否值得考虑将一个伪寄存器放在一个调用破坏的硬件寄存器中，
并在每个函数调用的附近进行保存和恢复。表达式应该为1，当值得去做，否则为0。

如果没有定义该宏，缺省值将被使用，
其在大多数机器上都是好的：@code{4 * @var{calls} < @var{refs}}。
@end defmac

@defmac HARD_REGNO_CALLER_SAVE_MODE (@var{regno}, @var{nregs})
一个C表达式指定了将伪寄存器@var{nregs}保存在调用破坏的硬件寄存器@var{regno}中，
需要哪种机器模式。如果@var{regno}不适合调用者保存，则应该返回@code{VOIDmode}。
对于大多数机器，该宏不需要被定义，因为GCC将选择最小的合适的机器模式。
@end defmac

@node 函数入口
@subsection 函数入口和出口
@cindex function entry and exit
@cindex prologue
@cindex epilogue

这一章描述了输出函数入口（@dfn{prologue}）和出口（@dfn{epilogue}）代码的宏。

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_PROLOGUE (FILE *@var{file}, HOST_WIDE_INT @var{size})
如果被定义，则为一个函数，其为函数的入口输出汇编代码。序言负责设置栈帧，
初始化帧指针寄存器，保存必须被保存的机器，并分配保存局部变量所需要的额外字节数
@var{size}。@var{size}为一个整数。
@var{file}为汇编代码应该被输出到的一个stdio流。

函数起始处的标号不需要被该宏输出。其已经在该宏运行时被输出了。

@findex regs_ever_live
要确定哪些寄存器要保存，该宏可以引用数组@code{regs_ever_live}：
元素@var{r}为非零，如果硬件寄存器@var{r}在函数某处被使用。
这意味着倘若其不是调用使用的（call-used）寄存器，
则函数序言应该保存寄存器@var{r}。
(同样@code{TARGET_ASM_FUNCTION_EPILOGUE}也必须使用@code{regs_ever_live}。)

在具有“寄存器窗口”的机器上，函数入口代码不在栈中保存位于窗口中的寄存器，
即使它们认为被函数调用保留；替代的，如果在函数中使用了任何非调用使用的寄存器，
其使用适当的步骤来“压入”寄存器栈中。

@findex frame_pointer_needed
在一些机器上，函数可以有帧指针，也可以没有，则函数入口代码必须相应的有所不同；
如果需要则其必须建立帧指针，否则不建立。要确定是否想要帧指针，
宏可以引用变量@code{frame_pointer_needed}。在运行时，如果函数需要帧指针，
则变量的值将被设为1。参见@ref{消除}。

函数入口代码负责分配函数需要的任何栈空间。该栈空间包括下面列出的域。
大多数情况下，这些域按照列出的顺序被分配，最后列出的域最靠近栈顶
（如果@code{STACK_GROWS_DOWNWARD}被定义，则为最低地址，如果没有定义，
则为最高地址）。你可以为一个机器使用不同的顺序，
如果这样做更加方便或者出于兼容的原因。除了由于标准或者调试器的要求之外，
没有理由GCC使用的栈布局需要适合机器上的其它编译器所使用的。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_END_PROLOGUE (FILE *@var{file})
如果被定义，则为一个函数，在序言的结尾处输出汇编代码。
这应该被用于当函数序言作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“序言指令模式”
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_BEGIN_EPILOGUE (FILE *@var{file})
如果被定义，则为一个函数，在尾声的起始处输出汇编代码。
这应该被用于当函数尾声作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“尾声指令模式”
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_EPILOGUE (FILE *@var{file}, HOST_WIDE_INT @var{size})
如果被定义，则为一个函数，其为函数的退出输出汇编代码。
尾声负责恢复保存的寄存器和栈指针为函数被调用时的值，并将控制返回给调用者。
该宏接受跟@code{TARGET_ASM_FUNCTION_PROLOGUE}相同的参数，
并且要恢复的寄存器按照相同的方式通过@code{regs_ever_live}和
@code{CALL_USED_REGISTERS}来确定。

在一些机器上，有一个单独的指令，可以做从函数中返回的所有工作。
在这些机器上，给出那个名为@samp{return}的指令，
并且不要定义宏@code{TARGET_ASM_FUNCTION_EPILOGUE}。

如果你想使用@code{TARGET_ASM_FUNCTION_EPILOGUE}，
则不要定义名为@samp{return}的指令模式。
如果你想target切换使用return指令或者尾声，则定义一个@samp{return}指令模式，
带有一个有效性条件用来测试target的适当的切换。
如果@samp{return}指令模式的有效性条件为假，则使用尾声。

在一些机器上，函数可以有帧指针，也可以没有，则函数的退出代码必须相应有所不同。
有时这两种情况的代码会完全不同。要确定是否需要帧指针，
该宏可以引用变量@code{frame_pointer_needed}。当编译一个需要帧指针的函数时，
变量的值将为1。

通常，@code{TARGET_ASM_FUNCTION_PROLOGUE}和@code{TARGET_ASM_FUNCTION_EPILOGUE}
必须单独处理叶子函数。对于这样的函数，C变量@code{current_function_is_leaf}为
非零。参见@ref{叶子函数}。

在一些机器上，一些函数在退出时弹出它们的参数，而其它的则将它们留给调用者来完成。
例如，68020当给定@option{-mrtd}时会弹出具有固定参数个数的函数的参数。

@findex current_function_pops_args
你对宏的定义决定了哪些函数弹出它们的自己的参数。
@code{TARGET_ASM_FUNCTION_EPILOGUE}需要知道这些。
称作@code{current_function_pops_args}的变量为函数应该弹出的参数的字节个数。
参见@ref{标量返回}。
@end deftypefn

@itemize @bullet
@item
@findex current_function_pretend_args_size
@code{current_function_pretend_args_size}个字节大小的未初始化空间位于栈中第一个
参数的下面。（这可能不是被分配的栈域的最起始处，如果调用序列在压入栈参数时还压入
了其它东西。通常，在这样的机器上，并没有压入其它东西，因为函数序言本身来做所有的
压栈操作）该域用于参数可以部分在寄存器中传递，部分在内存中传递的机器上，
以及支持@code{<stdarg.h>}的特性的情况。

@item
有一块内存用于保存函数使用的特定的寄存器。该区域的大小，
可能还包括作为返回地址和指向之前栈帧的指针的一些空间，
其为机器特定的并且通常取决于函数中已经使用了哪些寄存器。
具有寄存器窗口的机器通常不需要这样的存储区域。

@item
一块至少@var{size}个字节的区域，可能舍人到一个分配边界的大小，
来保存函数的局部变量。在一些机器上，该域和保存域可以按照相反的顺序出现，
使得保存域接近于栈顶。

@item
@cindex @code{ACCUMULATE_OUTGOING_ARGS} and stack frames
可选的，当@code{ACCUMULATE_OUTGOING_ARGS}被定义时，
还有一块@code{current_function_outgoing_args_size}字节大小的区域用于函数的传出
的参数列表。参见@ref{栈参数}。
@end itemize

@defmac EXIT_IGNORE_STACK
定义该宏为一个C表达式，其为非0，如果返回指令或者函数尾声忽略栈指针的值；
换句话说，如果在从函数中返回前，删除调整栈指针的指令是安全的。缺省为0。

注意该宏的值只于维护帧指针的函数相关。
在没有帧指针的函数中删除最后的栈调整是绝对不安全的，并且编译器知道这种情况，
而不管@code{EXIT_IGNORE_STACK}定义如何。
@end defmac

@defmac EPILOGUE_USES (@var{regno})
定义该宏为一个C表达式，其为非0，对于用于尾声或者@samp{return}指令模式的寄存器。
栈和帧指针寄存器已经被假设需要使用。
@end defmac

@defmac EH_USES (@var{regno})
定义该宏为一个C表达式，其为非0，对于用于异常处理机制的寄存器，
所以其应该被考虑为在一个异常边的入口上是活跃的。
@end defmac

@defmac DELAY_SLOTS_FOR_EPILOGUE
定义该宏，如果函数尾声包含延迟槽，并且函数其余的指令可以被移动过去。
该定义应该为一个C表达式，其值为一个整数表示有多少个延迟槽。
@end defmac

@defmac ELIGIBLE_FOR_EPILOGUE_DELAY (@var{insn}, @var{n})
一个C表达式，返回1，如果@var{insn}可以放在尾声中的延迟槽编号@var{n}中。

参数@var{n}为一个整数，其标识了目前被考虑的延迟槽（由于不同的延迟槽可以具有不同
的适任规则）。其从不为负，并且总是小于尾声延迟槽的总数
（@code{DELAY_SLOTS_FOR_EPILOGUE}的返回值）。
如果你为给定的延迟槽拒绝了一个特定的insn，原则上，其可以被后续的延迟槽重新考虑。
而且，其它insn还可以（至少原则上）被目前为止还没有被填充的延迟槽考虑。

@findex current_function_epilogue_delay_list
@findex final_scan_insn
被接受填充尾声延迟槽的insn被放在一个RTL链表中，使用@code{insn_list}对象，
并存储在变量@code{current_function_epilogue_delay_list}中。
第一个延迟槽的insn位于链表中的第一个。你对宏@code{TARGET_ASM_FUNCTION_EPILOGUE}
的定义应该通过输出该链表的insn来填充延迟槽，通常是调用@code{final_scan_insn}。

你不需要定义该宏，如果你没有定义@code{DELAY_SLOTS_FOR_EPILOGUE}。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_MI_THUNK (FILE *@var{file}, tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, tree @var{function})
一个函数，输出一个thunk函数的汇编代码，用于实现具有多继承的C++虚函数调用。
thunk作为一个虚函数的封装，用来调整隐式对象参数，在将控制移交给实函数之前。

首选，输出代码来增加整数@var{delta}为包含传递进来的第一个参数的为。
假设该参数包含一个指针，并用于在C++中传递@code{this}指针。
这是在函数序言之前的参数，例如在sparc上为@samp{%o0}。

然后，如果@var{vcall_offset}非0，则在增加@var{delta}之后应该进行额外的调整。
特别是，如果@var{p}为被调整的指针，则应该进行如下的调整：

@smallexample
p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]
@end smallexample

加法之后，输出代码跳转到@var{function}，其为@code{FUNCTION_DECL}。
这是一个直接跳转，而不是调用，并且不触及返回地址。因此从@var{FUNCTION}中返回时，
将返回到调用当前@samp{thunk}的地方。

其效果就好像是函数被直接调用，并使用调整后的第一个参数。
该宏负责输出thunk函数的所有代码；@code{TARGET_ASM_FUNCTION_PROLOGUE}和@code{TARGET_ASM_FUNCTION_EPILOGUE}不被调用。

@var{thunk_fndecl}是冗余的。（@var{delta}和@var{function}已经从中被抽取出来。）
其可能在一些target上有用，也很可能没用。

如果你没有定义该宏，则C++前端的target无关代码将会生成一个不太有效的重量级的
thunk，其调用@var{function}而不是直接跳转过去。普通的方法不支持varargs。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, tree @var{function})
一个函数，返回真，如果TARGET_ASM_OUTPUT_MI_THUNK应该能够为其传递的参数所指定的
thunk函数输出汇编代码，否则为假。在后一种情况下，C++前端将会使用普通的方式，
并具有之前提到的限制。
@end deftypefn

@node Profiling
@subsection 为profiling生成代码
@cindex profiling, code generation

这些宏将帮助你为profiling生成代码。

@defmac FUNCTION_PROFILER (@var{file}, @var{labelno})
一条C语句或者复合语句，来输出到@var{file}中一些汇编代码，
来调用profiling子程序@code{mcount}。

@findex mcount
关于@code{mcount}期望如何被调用的细节，由你的操作系统环境来决定，
而不是GCC。要弄清楚它们，可以编译一个小程序，
使用系统安装的C编译进行profiling，并查看生成的汇编代码。

@code{mcount}的旧的实现，期望一个计数变量的地址被加载到某个寄存器中。
该变量的名字为@samp{LP}，后面跟随数字@var{labelno}，
所以你应该生成该名字，在@code{fprintf}中使用@samp{LP%d}。
@end defmac

@defmac PROFILE_HOOK
一条C语句或者复合语句，来输出到@var{file}中一些汇编代码，
来调用profiling子程序@code{mcount}，即使target不支持profiling。
@end defmac

@defmac NO_PROFILE_COUNTERS
定义该宏为一个表达式，具有一个非0的值，
如果你系统上的@code{mcount}子程序不需要为每个函数分配一个计数变量。
这对于大多数现代实现都是正确的。如果你定义了该宏，
你一定不要使用@code{FUNCTION_PROFILER}的@var{labelno}参数。
@end defmac

@defmac PROFILE_BEFORE_PROLOGUE
定义该宏，如果函数profiling的代码应该位于函数序言之前。
通常profiling代码位于之后。
@end defmac

@node 尾调用
@subsection 允许尾调用
@cindex tail calls

@deftypefn {Target Hook} bool TARGET_FUNCTION_OK_FOR_SIBCALL (tree @var{decl}, tree @var{exp})
如果可以为指定的调用表达式@var{exp}做sibling call优化，则为真。
@var{decl}为被调用的函数，或者为@var{NULL}，如果这是一个间接调用。

通常调用约定的限制不会阻止当前转换单元之外的或者PIC编译过程中的函数尾调用。
钩子用来加强这些限制，由于@code{sibcall} md模式不能fail。
成功的sibling call优化的标准可能在不同的体系结构上有很大的差别。
@end deftypefn

@deftypefn {Target Hook} void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap *@var{regs})
增加任何在函数入口为活跃的硬件寄存器到@var{regs}。
该钩子只需要被定义来提供不能通过检查FUNCTION_ARG_REGNO_P，
callee保存的寄存器，STATIC_CHAIN_INCOMING_REGNUM，
STATIC_CHAIN_REGNUM， TARGET_STRUCT_VALUE_RTX，FRAME_POINTER_REGNUM，
EH_USES， FRAME_POINTER_REGNUM，
ARG_POINTER_REGNUM和PIC_OFFSET_TABLE_REGNUM来发现的寄存器。
@end deftypefn

@node 栈冲突保护
@subsection 栈冲突保护
@cindex stack smashing protection

@deftypefn {Target Hook} tree TARGET_STACK_PROTECT_GUARD (void)
该钩子返回一个外部变量的@code{DECL}节点，用作栈保护者。
该变量在运行时被初始化为某个随即值，
并用于初始化放在局部栈帧顶端的警卫值。
该变量的类型必须为@code{ptr_type_node}。

该钩子的缺省版本创建一个叫做@samp{__stack_chk_guard}的变量，
其通常在@file{libgcc2.c}中被定义。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_STACK_PROTECT_FAIL (void)
该钩子返回一个tree表达式，用以警告运行时，栈保护者变量被修改了。
该表达式应该包括一个对无返回的（@code{noreturn}）函数的调用。

该钩子的缺省版本调用一个叫做@samp{__stack_chk_fail}的函数，
不接受任何参数。该函数通常在@file{libgcc2.c}中被定义。
@end deftypefn

@node Varargs
@section 实现Varargs宏
@cindex varargs implementation

GCC自带了@code{<varargs.h>}和@code{<stdarg.h>}的实现，
可直接用于在栈上传递参数的机器上。其它机器需要它们自己的varargs实现，
并且两个机器独立的头文件必须条件包含它。

ISO @code{<stdarg.h>}与传统@code{<varargs.h>}的区别主要在@code{va_start}的调用
约定上。传统的实现只接受一个参数，其为存储参数指针的变量。
ISO的实现接受额外的第二个参数。用户应该将函数的最后一个命名参数写在这里。

然而，@code{va_start}不应该使用这个参数。
发现命名参数结尾的方法为使用下面描述的内建函数。

@defmac __builtin_saveregs ()
使用该内建函数来将参数寄存器保存在内存中，使得varargs机制可以访问它们。
@code{va_start}的ISO版本和传统版本都必须使用@code{__builtin_saveregs}，
除非你使用@code{TARGET_SETUP_INCOMING_VARARGS}来替代（参见下面）。

在一些机器上，@code{__builtin_saveregs}为开放编码的，
在target钩子@code{TARGET_EXPAND_BUILTIN_SAVEREGS}的控制下。
在其它机器上，其调用了汇编语言写的例程，可以在@file{libgcc2.c}中找到。

不管怎样，调用@code{__builtin_saveregs}的生成代码都出现在函数的起始处。
这是因为寄存器必须在函数开始使用它们前被保存。
@c i rewrote the first sentence above to fix an overfull hbox. --mew
@c 10feb93
@end defmac

@defmac __builtin_args_info (@var{category})
使用该内建函数来找到寄存器中第一个匿名参数。

通常，机器可以具有多个用于参数的寄存器类别，每一个用于特定的数据类型。
（例如，在一些机器上，浮点寄存器用于浮点参数，而其它参数在通用寄存器中传递。）
要使非varargs函数使用合适的调用约定，你已经定义了@code{CUMULATIVE_ARGS}数据类型
来记录在每个类别中有多少寄存器已被使用。

@code{__builtin_args_info}在普通参数布局完成之后，
访问同一数据结构体@code{CUMULATIVE_ARGS}，使用@var{category}来指定访问哪个字。
因此，其值指示了在给定category中的第一个未使用的寄存器。

通常，你会在@code{va_start}的实现中使用@code{__builtin_args_info}，
访问每个类一次，并将值存储到@code{va_list}对象中。
这是因为@code{va_list}将必须更新值，
因此无法修改通过@code{__builtin_args_info}访问的值。
@end defmac

@defmac __builtin_next_arg (@var{lastarg})
这与@code{__builtin_args_info}等价，用于栈参数。其返回第一个匿名栈参数的地址，
类型为@code{void *}。如果@code{ARGS_GROW_DOWNWARD}，
其返回第一个匿名栈参数的上面的位置地址。在@code{va_start}中使用它来初始化指针，
来从栈中获得参数。同样，在@code{va_start}中使用它来验证第二个参数@var{lastarg}
为当前函数的最后一个命名参数。
@end defmac

@defmac __builtin_classify_type (@var{object})
由于每个机器具有它自己的约定，对于哪些数据类型在哪种寄存器中传递，
因此你的@code{va_arg}实现必须包含这些约定。
将指定数据类型归类的最简单方法是使用@code{__builtin_classify_type}，
加上@code{sizeof}和@code{__alignof__}。

@code{__builtin_classify_type}忽略@var{object}的值，只考虑它的数据类型。
其返回一个整数来描述什么类型为，整型，浮点，指针，结构体等。

文件@file{typeclass.h}定义了一个枚举，
你可以用来解析@code{__builtin_classify_type}的值。
@end defmac

这些机器描述宏用来帮助实现varargs：

@deftypefn {Target Hook} rtx TARGET_EXPAND_BUILTIN_SAVEREGS (void)
如果定义，该钩子产生机器特定代码，用于调用@code{__builtin_saveregs}。
该代码将被移动到函数的最开始处，在访问任何参数之前。
该函数的返回值应该为一个RTX，其包含了@code{__builtin_saveregs}的返回值。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARGS (CUMULATIVE_ARGS *@var{args_so_far}, enum machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})
该target钩子提供了使用@code{__builtin_saveregs}和定义
@code{TARGET_EXPAND_BUILTIN_SAVEREGS}钩子的替代。
使用它来将匿名寄存器参数存储到栈中，使得所有参数都像是通过栈连续的传递。
当这样做时，你可以使用varargs的标准实现，其用于将所有参数在栈上传递的机器上。

参数@var{args_so_far}指向@code{CUMULATIVE_ARGS}数据结构体，
包含了处理完命名参数之后所获得的值。
参数@var{mode}和@var{type}描述了最后一个命名参数的机器模式和作为树结点的数据类型。

该target钩子应该做两件事：第一，将所有不用于命名参数的参数寄存器压入栈中，
第二，存储数据的大小，把@var{pretend_args_size}指向的@code{int}值得变量压入。
这里你存储的值将作为额外的偏移量，用来建立栈帧。

因为你必须生成代码来将匿名参数在编译时压入，而不需要知道它们的数据类型，
所以@code{TARGET_SETUP_INCOMING_VARARGS}只在只有一种参数寄存器类别并用于所有
数据类型的机器上有用。

如果参数@var{second_time}非0，其以为着函数的参数被第二次分析。
这发生于内联函数，其直到源文件结尾才被实际编译。对于这种情况，
钩子@code{TARGET_SETUP_INCOMING_VARARGS}不应该产生任何指令。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_STRICT_ARGUMENT_NAMING (CUMULATIVE_ARGS *@var{ca})
定义该钩子来返回@code{true}，如果函数参数传递的位置依赖于其是否为一个命名参数。

该钩子控制对于varargs和stdarg函数，如何设置FUNCTION_ARG的@var{named}参数。
如果该钩子返回@code{true}，则@var{named}参数总是为命名参数，未命名参数总是未假。
如果返回@code{false}，但是@code{TARGET_PRETEND_OUTGOING_VARARGS_NAMED}返回
@code{true}，则所有参数都被作为命名的对待。否则所有命名参数，除了最后一个，
被作为命名的对待。

如果其总是返回0，则不需要定义该钩子。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED
如果你需要条件的改变ABI，使得一种工作于@code{TARGET_SETUP_INCOMING_VARARGS}，
另一种工作于@code{TARGET_SETUP_INCOMING_VARARGS}和
@code{TARGET_STRICT_ARGUMENT_NAMING}都没有被定义，则定义该钩子返回@code{true}，
如果使用@code{TARGET_SETUP_INCOMING_VARARGS}，否则返回@code{false}。
否则，你不需要定义该钩子。
@end deftypefn

@node Trampolines
@section 嵌套函数的蹦床
@cindex trampolines for nested functions
@cindex nested functions, trampolines for

一个蹦床@dfn{trampoline}为在运行时，当使用嵌套函数的地址时，创建的一小块代码。其通常驻于栈上，在包含函数的栈帧中。这些宏告诉GCC如何生成代码来分配和初始化一个蹦床。

在蹦床中的指令必须做两件事情：将一个常量地址加载到静态链寄存器中，并跳转到嵌套函数的实际地址。在CISC机器，像m68k上，这要求两条指令，一个move立即数和一个jump。然后两个地址存放在蹦床中作为字长的立即操作数。在RISC机器上，其通常需要分成两部分加载每个地址到寄存器中。然后地址的各部分形成独立的立即操作数。

用来初始化蹦床的代码必须将变量的组成部分——静态链值和函数地址——存储到指令的立即操作数中。在CISC机器上，这是简单的复制每个地址到一个内存引用，在蹦床起始处的合适偏移量上。在RISC机器上，其可能需要拿出部分地址并单独存储它们。

@defmac TRAMPOLINE_TEMPLATE (@var{file})
一条C语句，来在流@var{file}上，为一个包含蹦床常量部分的数据块输出汇编代码。
该代码应该不包括标号——标号被自动考虑。

如果没有定义该宏，其意味着target不需要模版。
不要在将蹦床复制到一个地方的块移动代码会比在该处生成它的代码大的系统上定义该宏。
@end defmac

@defmac TRAMPOLINE_SECTION
返回蹦床模版被放入的section（参见@ref{段}）。
缺省值为@code{readonly_data_section}。
@end defmac

@defmac TRAMPOLINE_SIZE
一个C表达式，蹦床的字节单位的大小，为整数。
@end defmac

@defmac TRAMPOLINE_ALIGNMENT
蹦床需要的对齐，以位为单位。

如果没有定义该宏，则使用@code{BIGGEST_ALIGNMENT}的值来对齐蹦床。
@end defmac

@defmac INITIALIZE_TRAMPOLINE (@var{addr}, @var{fnaddr}, @var{static_chain})
一条C语句用来初始化蹦床的可变部分。@var{addr}为一个RTX，蹦床的地址；
@var{fnaddr}为一个RTX，嵌套函数的地址；@var{static_chain}为一个RTX，
当其被调用时，应该传递给函数的静态链值。
@end defmac

@defmac TRAMPOLINE_ADJUST_ADDRESS (@var{addr})
一条C语句，应该执行任何机器特定的调整，对蹦床的地址。
其参数包含传给@code{INITIALIZE_TRAMPOLINE}的地址。
对于用于函数调用的地址应该不同于模版被存储的地址的情况，
应该赋给@var{addr}不同的地址。如果没有定义该宏，则@var{addr}将被用于函数调用。

@cindex @code{TARGET_ASM_FUNCTION_EPILOGUE} and trampolines
@cindex @code{TARGET_ASM_FUNCTION_PROLOGUE} and trampolines
如果没有定义该宏，缺省的蹦床作为一个栈槽被分配。这对于大多数机器是正确的。
例外的是一些机器，其不可能在栈区域中执行指令。在这样的机器上，
你可能必须实行一个独立的栈，使用该宏，
并结合@code{TARGET_ASM_FUNCTION_PROLOGUE}和@code{TARGET_ASM_FUNCTION_EPILOGUE}。

@var{fp}指向一个数据结构体，一个@code{struct function}，
其描述了对直接包含蹦床所对应函数的函数的编译状态。
蹦床的栈槽在该包含函数的栈帧中。其它分配策略可能也必须作一些类似的事情。
@end defmac

在许多机器上实现蹦床是困难的，因为它们具有独立的指令和数据缓存。
写到栈位置中使得无法清除指令缓存中的内存，所以当程序跳转到那个位置时，
其执行了旧的内容。

有两种可能的解决方法。一种是清除指令缓存的相关部分，当蹦床被建立的时候。
另一种是使所有蹦床为等同的，通过使它们跳转到一个标准的子程序中。
前者使得蹦床执行更快；后者使得初始化更快。

要在初始化蹦床时清除指令缓存，定义下列宏。

@defmac CLEAR_INSN_CACHE (@var{beg}, @var{end})
如果被定义，将扩展为一个C表达式，在指定的间隔处来清除指令缓存。
该宏的定义通常为一系列@code{asm}语句。@var{beg}和@var{end}都为指针表达式。
@end defmac

操作系统可能还需要栈被设为可执行的，在调用蹦床之前。要实现这种需求，定义下列宏。

@defmac ENABLE_EXECUTE_STACK
定义该宏，如果在执行位于栈上的代码之前必须执行特定的操作。
宏应该扩展为一系列的C文件作用域的结构（例如函数）并提供一个唯一的如何口点名
为@code{__enable_execute_stack}。target负责生成对入口点的调用，
例如从@code{INITIALIZE_TRAMPOLINE}宏中。
@end defmac

要使用标准的子程序，定义下列宏。另外，
你必须确信在蹦床中的指令使用相同的指令来填充整个缓存行，
或者蹦床代码的起始处总是在缓存行的某点被对齐。查看@file{m68k.h}作为参考。

@defmac TRANSFER_FROM_TRAMPOLINE
定义该宏，如果蹦床需要一个特定的子程序来做它们的工作。
该宏应该扩展为一系列的@code{asm}语句，其将由GCC来编译。
它们放在名为@code{__transfer_from_trampoline}的库函数中。

如果当你跳转到子程序时，你需要避免普通的被编译的C函数的序言代码，
你可以通过在汇编代码中放一个你自己的特定标号。
使用一条@code{asm}语句来生成汇编标号，另一条语句使得标号为global的。
然后蹦床可以使用该标号直接跳到你特定的汇编代码上。
@end defmac

@node 库调用
@section 库例程的隐式调用
@cindex library subroutine names
@cindex @file{libgcc.a}

@c prevent bad page break with this line
这是库函数的隐式调用的说明。

@defmac DECLARE_LIBRARY_RENAMES
该宏，如果被定义，应该扩展为一块C代码，当编译libgcc.a的函数时被扩展。
其可以被用于提供GCC内部库函数的替代名字，如果有编译应该提供的ABI名字。
@end defmac

@findex init_one_libfunc
@findex set_optab_libfunc
@deftypefn {Target Hook} void TARGET_INIT_LIBFUNCS (void)
该钩子应该声明额外的库函数或者重命名存在的，
使用@file{optabs.c}中定义的函数@code{set_optab_libfunc}和
@code{init_one_libfunc}。
@code{init_optabs}调用该宏，在初始化所有正常的库函数之后。

缺省为不作任何事情。大多数port不需要定义该钩子。
@end deftypefn

@defmac FLOAT_LIB_COMPARE_RETURNS_BOOL (@var{mode}, @var{comparison})
该宏应该返回@code{true}，如果实现在模式@var{mode}下的浮点比较操作符
@var{comparison}的库函数应该返回一个布尔值，
如果应该返回一个三态值则返回@var{false}。

GCC本身的浮点库从比较运算符中返回三态值，所以缺省总是返回假。
大多数port不需要定义该宏。
@end defmac

@defmac TARGET_LIB_INT_CMP_BIASED
该宏应该求解为@code{true}，如果整型比较函数（像@code{__cmpdi2}）
应该返回0来指示第一个操作数比第二个小，1来指示相等，
2来指示第一个操作数大于第二个。如果该宏求解为@code{false}，
则比较函数返回-1，0和1，来替代0，1和2。如果target使用@file{libgcc.a}中的函数，
则不需要定义该宏。
@end defmac

@cindex US Software GOFAST, floating point emulation library
@cindex floating point emulation library, US Software GOFAST
@cindex GOFAST, floating point emulation library
@findex gofast_maybe_init_libfuncs
@defmac US_SOFTWARE_GOFAST
定义该宏，如果你的系统C库使用US Software GOFAST库来提供浮点模拟。

除了定义该宏以外，你的体系结构必须将@code{TARGET_INIT_LIBFUNCS}设为
@code{gofast_maybe_init_libfuncs}，或者从那个钩子版本中调用该函数。
其在@file{config/gofast.h}中定义，
且必须被你的体系结构的@file{@var{cpu}.c}文件包含进来。
例如参见@file{sparc/sparc.c}。

如果该宏被定义，
则@code{TARGET_FLOAT_LIB_COMPARE_RETURNS_BOOL} target钩子必须返回假，
对于@code{SFmode}和@code{DFmode}比较。
@end defmac

@cindex @code{EDOM}, implicit usage
@findex matherr
@defmac TARGET_EDOM
target机器上的@code{EDOM}的值，作为一个C整型常量表达式。如果没有定义该宏，
则GCC不尝试将@code{EDOM}的值直接存放到@code{errno}中。
查看@file{/usr/include/errno.h}来查找你的系统上的@code{EDOM}的值。

如果没有定义@code{TARGET_EDOM}则被编译的代码通过调用库函数并使其报告错误，
来报告domain错误。如果对于这样的错误，你系统上的数学函数使用@code{matherr}，
则应该不定义@code{TARGET_EDOM}，以便@code{matherr}被正常使用。
@end defmac

@cindex @code{errno}, implicit usage
@defmac GEN_ERRNO_RTX
定义该宏为C表达式来创建一个rtl表达式，来引用全局“变量”@code{errno}。
（在一些系统上，@code{errno}可能实际不是一个变量。）如果没有定义该宏，
则会使用一个合理的缺省。
@end defmac

@cindex C99 math functions, implicit usage
@defmac TARGET_C99_FUNCTIONS
当该宏非0时，GCC将隐式的优化@code{sin}调用为@code{sinf}，
类似的还有C99标准中定义的其它函数。缺省为非0，这对于大多现代系统是合适的，
然而有一些系统缺少对这些函数的运行时支持，所以它们需要该宏被重定义为0。
@end defmac

@cindex sincos math function, implicit usage
@defmac TARGET_HAS_SINCOS
当该宏非0时，
GCC将隐式的优化@code{sin}和@code{cos}调用为使用相同参数的@code{sincos}调用。
缺省为0。target必须提供下列函数：
@smallexample
void sincos(double x, double *sin, double *cos);
void sincosf(float x, float *sin, float *cos);
void sincosl(long double x, long double *sin, long double *cos);
@end smallexample
@end defmac

@defmac NEXT_OBJC_RUNTIME
定义该宏来使用NeXT系统约定为Objective-C消息发送生成代码。
该调用约定包括将对象，选择者和方法一起传递给方法查询库函数。

缺省调用约定只将对象和选择者传递给查询函数，其返回一个指向方法的指针。
@end defmac

@node 寻址模式
@section 寻址模式
@cindex addressing modes

@c prevent bad page break with this line
这是关于寻址模式的宏。

@defmac HAVE_PRE_INCREMENT
@defmacx HAVE_PRE_DECREMENT
@defmacx HAVE_POST_INCREMENT
@defmacx HAVE_POST_DECREMENT
一个C表达式，为非0，如果机器分别支持前增，前减，后增，或者后减寻址。
@end defmac

@defmac HAVE_PRE_MODIFY_DISP
@defmacx HAVE_POST_MODIFY_DISP
一个C表达式，非零，如果机器支持pre-或者post-address，
除了生成内存操作数的大小以外，还有常量副作用生成。
@end defmac

@defmac HAVE_PRE_MODIFY_REG
@defmacx HAVE_POST_MODIFY_REG
一个C表达式，非零，如果机器支持pre-或者post-address，
除了生成内存操作数的大小以外，还有寄存器置换的副作用生成。
@end defmac

@defmac CONSTANT_ADDRESS_P (@var{x})
一个C表达式，为1，如果RTX @var{x}为一个常量，其为一个有效地址。
在大多数机器上，这可以被定义为@code{CONSTANT_P (@var{x})}，
但一些机器在支持哪些常量地址方面更加严格。
@end defmac

@defmac CONSTANT_P (@var{x})
@code{CONSTANT_P}，其由target无关代码定义，接受整数值表达式，
其值不被显示的知道，例如@code{symbol_ref}, @code{label_ref}，@code{high}表达式，
以及@code{const}算术表达式，@code{const_int}和@code{const_double}表达式。
@end defmac

@defmac MAX_REGS_PER_ADDRESS
一个数，为可以出现在一个有效的内存地址中的最大寄存器编号。
注意需要你来指定@code{GO_IF_LEGITIMATE_ADDRESS}应该能够接受的等于该最大值的值。
@end defmac

@defmac GO_IF_LEGITIMATE_ADDRESS (@var{mode}, @var{x}, @var{label})
一个C复合语句，带有条件@code{goto @var{label};}；
如果对于一个模式为@var{mode}的内存操作数，
@var{x}（一个RTX）为一个在target机器上的合法内存地址时，被执行。

通常定义多个相对简单的宏来作为该宏的子程序。否则其可能会太复杂，难以理解。

该宏必须按照两种方式退出：一种严格的方式和一种非严格的。严格的方式用于重载阶段。
其必须被定义，以便任何没有被分配硬件寄存器的伪寄存器被作为内存引用考虑。
在需要某种寄存器的上下文中，一个没有硬件寄存器的伪寄存器必须被拒绝。

非严格的方式用于其它过程。其必须被定义来接受所有伪寄存器，
在每个需要某种寄存器的上下文中。

@findex REG_OK_STRICT
想要使用该宏的严格方式的编译器源文件定义宏@code{REG_OK_STRICT}。
你应该使用一个@code{#ifdef REG_OK_STRICT}条件来定义严格方式，反之定义非严格的。

出于不同目的（对于基址寄存器，对于索引寄存器等等）来检查可接受的寄存器的子程序通常用于定义@code{GO_IF_LEGITIMATE_ADDRESS}。
那么只有这些子程序宏需要这两种方式；高级别的宏对于严格的或者不严格的可以相同。

通常常量地址，其为一个@code{symbol_ref}和一个整数的和，
被存储在一个@code{const} RTX中，来标记它们为一个常量。
因此，不需要专门识别这样的和是否为合法地址。
通常你应该简化识别任何合法的@code{const}。

通常@code{PRINT_OPERAND_ADDRESS}不准备处理没有标记为@code{const}的常量和。
其假设@code{plus}表示为索引。如果是这样，
你@emph{必须}作为非法地址来拒绝这样的常量sum，
以便不会提供给@code{PRINT_OPERAND_ADDRESS}。

@cindex @code{TARGET_ENCODE_SECTION_INFO} and address validation
在一些机器上，一个符号地址是否为合法的，依赖于地址所引用的section。
在这些机器上，定义target钩子@code{TARGET_ENCODE_SECTION_INFO}来将信息存储
到@code{symbol_ref}中，然后在此处检查。当你遇到一个@code{const}，
你将必须查看内部，来找到@code{symbol_ref}，以便确定section。参见@ref{汇编格式}。
@end defmac

@defmac TARGET_MEM_CONSTRAINT
A single character to be used instead of the default @code{'m'}
character for general memory addresses.  This defines the constraint
letter which matches the memory addresses accepted by
@code{GO_IF_LEGITIMATE_ADDRESS_P}.  Define this macro if you want to
support new address formats in your back end without changing the
semantics of the @code{'m'} constraint.  This is necessary in order to
preserve functionality of inline assembly constructs using the
@code{'m'} constraint.
@end defmac

@defmac FIND_BASE_TERM (@var{x})
一个C表达式，用来确定地址@var{x}的base term。该宏只在两个地方使用：
@file{alias.c}的@code{find_base_value}和 @code{find_base_term}。

不定义该宏也总是安全的。它的存在是为了别名分析可以理解机器相关的地址。

该宏的典型用法是处理在UNSPEC中包含label_ref或symbol_ref的地址。
@end defmac

@defmac LEGITIMIZE_ADDRESS (@var{x}, @var{oldx}, @var{mode}, @var{win})
一个c复合语句，对于模式为@var{mode}的操作数，
尝试使用有效的内存地址来替换@var{x}。@var{win}为代码中某处的一个c语句标号；
宏定义可以使用

@smallexample
GO_IF_LEGITIMATE_ADDRESS (@var{mode}, @var{x}, @var{win});
@end smallexample

@noindent
来避免进一步的处理，如果地址已经变为合法的。

@findex break_out_memory_refs
@var{x}总是为调用@code{break_out_memory_refs}的结果，
@var{oldx}将为传给那个函数来生成@var{x}的操作数。

该宏生成的代码不应该修改@var{x}的子结构。
如果其将@var{x}转换为一个更加合法的形式，
其应该为@var{x}（其总为一个c变量）赋予一个新的值。

该宏不必要产生一个合法的地址。编译器具有做这件事的标准方法。
实际上省略掉该宏是安全的。但是通常机器相关的策略可以产生更好的代码。
@end defmac

@defmac LEGITIMIZE_RELOAD_ADDRESS (@var{x}, @var{mode}, @var{opnum}, @var{type}, @var{ind_levels}, @var{win})
一条C复合语句，其尝试使用一个机器模式为@var{mode}的操作数的有效内存地址，
来替换地址需要重载的@var{x}。@var{win}为代码中的一个C语句标号。
不必要定义该宏，但其可能会对性能有帮助。

例如，在i386上，有时可能通过将两个伪寄存器的和重载到一个寄存器中，
从而只使用一个重载寄存器，而不是两个。另一方面，
许多RISC处理器的偏移量是有限制的，使得经常要生成一个中间地址来寻址一个栈槽。
通过适当的定义@code{LEGITIMIZE_RELOAD_ADDRESS}，
为邻近的一些栈槽生成的中间地址可以为同一个，实现共享。

注意：该宏应该慎重使用。有必要了解重载是如何工作的，以便有效的使用该宏。

注意：该宏必须能够重载由该宏的之前调用所创建的地址。
如果不能处理这样的地址，则编译器可能会产生不正确的代码或者中断退出。

@findex push_reload
宏定义应该使用@code{push_reload}来指示需要重载的部分；
@var{opnum}，@var{type}和@var{ind_levels}通常无需更改而直接传给@code{push_reload}。

该宏生成的代码必须不要修改@var{x}的子结构体。如果其将@var{x}转换成更合法的形式，
则其必须为@var{x}（其总为一个c变量）赋予一个新的值。
这也通常应用于你通过调用@code{push_reload}而间接改变的部分。

@findex strict_memory_address_p
宏定义可以使用@code{strict_memory_address_p}来测试地址是否已经为合法的。

@findex copy_rtx
如果你只想改变@var{x}的一部分，一种标准的方法是使用@code{copy_rtx}。
但是注意，其只与rtl同一级不共享。因此，如果改变的部分不在顶层，
则你要首先替换顶层。

该宏不必要产生一个合法的地址；但是通常机器相关的策略可以产生更好的代码。
@end defmac

@defmac GO_IF_MODE_DEPENDENT_ADDRESS (@var{addr}, @var{label})
一条C语句或者复合语句，具有一个条件@code{goto @var{label};}；
当内存地址@var{x}（一个RTX）可以具有不同的含义，
该含义取决于内存引用的机器模式时，被执行。

自动递增和自动递减地址通常具有机器模式相关的效果，
因为递增或递减的数量为被寻址的操作数的大小。
一些机器具有其它机器模式相关的地址。许多RISC机器没有机器模式相关的地址。

你可以假设@var{addr}对于机器是一个有效的地址。
@end defmac

@defmac LEGITIMATE_CONSTANT_P (@var{x})
一个C表达式，如果@var{x}对于target机器上的一个立即操作数为合法的常量，
则为非0。你可以假设@var{x}满足@code{CONSTANT_P}，所以不需要进行检查。
实际上，在任何@code{CONSTANT_P}都是有效的机器上，为该宏定义为@samp{1}是合适的。
@end defmac

@deftypefn {Target Hook} rtx TARGET_DELEGITIMIZE_ADDRESS (rtx @var{x})
该钩子用于撤销@code{LEGITIMIZE_ADDRESS}和@code{LEGITIMIZE_RELOAD_ADDRESS} target
宏可能造成的模糊效果。这些宏的一些后端实现，
将符号引用包含在一个@code{UNSPEC} rtx中来表示PIC或者类似的寻址模式。
该target钩子允许GCC的优化器来理解这些透明的@code{UNSPEC}的语义，
通过将它们转换回到它们最初的形式。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CANNOT_FORCE_CONST_MEM (rtx @var{x})
该钩子应该返回真，如果@var{x}不能够（或不应该）被溢出到常量池中。
该钩子的缺省版本返回假。

定义该钩子的主要原因是阻止重载决定将一个不合法的常量从常量池中重载，
而不是溢出并重载一个寄存器来保存常量。对于不同的target，
该限制对于TLS符号的地址常常是真。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_USE_BLOCKS_FOR_CONSTANT_P (enum machine_mode @var{mode}, rtx @var{x})
该钩子应该返回真，
如果常量@var{x}的池实体（pool entries）可以放在一个@code{object_block}结构体中。
@var{mode}为@var{x}的机器模式。

缺省版本为所有的常量返回假。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_BUILTIN_RECIPROCAL (enum tree_code @var{fn}, bool @var{tm_fn}, bool @var{sqrt})
该钩子应该返回一个函数的decl，该函数实现了代码为@var{fn}的内建函数的倒数，
或者如果没有这样的函数，则返回@code{NULL_TREE}。
当@var{fn}为一个机器相关的内建函数的代码时，@var{tm_fn}为真。
当@var{sqrt}为真时，只对平方根函数进行额外的优化，
并且只有@var{sqrt}函数的倒数可用。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)
该钩子应该返回一个函数@var{f}的decl，给定一个地址@var{addr}作为参数，
该函数返回一个掩码@var{m}，在@var{addr}没有被适当的对齐时，
其可以用于从两个向量中抽取位于@var{addr}中的相关数据。

自动向量化，当向量化一个加载操作，且地址@var{addr}可以没有对齐，
则会生成两个向量加载，从@var{addr}附件的两个对齐的地址。
其然后生成一个@code{REALIGN_LOAD}操作，来从两个加载的向量中抽取相关数据。
@code{REALIGN_LOAD}的前两个参数，@var{v1}和@var{v2}，为两个向量，
每个的大小为@var{VS}，第三个参数，@var{OFF}，定义了数据如何从这两个向量中抽取：
如果@var{OFF}为0，则返回的向量为@var{V2}；
否则返回的向量由@var{v1}的后@var{VS}-@var{OFF}个元素连接到@var{v2}的前@var{OFF}个元素而组成。

如果定义了该钩子，则自动向量化会生成一个对@var{f}的调用（使用该钩子返回的DECL）
并使用@var{f}的返回值作为@code{REALIGN_LOAD}的参数@var{OFF}。因此，
@var{f}返回的掩码@var{m}应该遵守@code{REALIGN_LOAD}所期望的上面描述的语义。
如果该钩子没有被定义，
则@var{addr}将作为@code{REALIGN_LOAD}的参数@var{OFF}来使用，
这种情况下将会考虑@var{addr}的低log2(@var{VS})-1位。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN (tree @var{x})
该钩子应该返回一个函数@var{f}的decl，
该函数实现了两个类型为@var{x}的输入向量作为偶数元素的加宽乘法。

如果定义了该钩子，则自动化向量当进行向量化加宽乘法时，
将会使用它和@code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD} target钩子，
以防结果顺序不需要被保存（例如，只用于减法计算）。
否则将使用@code{widen_mult_hi/lo}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD (tree @var{x})
该钩子应该返回一个函数@var{f}的decl，
该函数实现了两个类型为@var{x}的输入向量作为奇数元素的加宽乘法。

如果定义了该钩子，则自动化向量当进行向量化加宽乘法时，
将会使用它和@code{TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN} target钩子，
以防结果顺序不需要被保存（例如，只用于减法计算）。
否则将使用@code{widen_mult_hi/lo}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_CONVERSION (enum tree_code @var{code}, tree @var{type})
该钩子应该返回一个函数的decl，该函数实现了类型为@var{type}的输入向量的转换。
如果@var{type}为一个整数类型，则转换结果为一个同样大小的浮点类型的向量。
如果@var{type}为浮点类型，则转换结果为一个同样大小的整数类型的向量。
@var{code}指定了如何应用转换（截断，舍入，等）。

如果定义了该钩子，则自动向量化当进行向量化转换时，
会使用@code{TARGET_VECTORIZE_BUILTIN_CONVERSION} target钩子。
否则，其应该返回@code{NULL_TREE}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (enum built_in_function @var{code}, tree @var{vec_type_out}, tree @var{vec_type_in})
该钩子应该返回一个函数的decl，
该函数实现了代码为@var{code}的内建函数的向量化变体，
或者如果没有这样的函数则返回@code{NULL_TREE}。
向量化的函数的返回类型应该为向量类型@var{vec_type_out}，
并且参数类型应该为@var{vec_type_in}。
@end deftypefn

@node Anchored地址
@section 锚定的地址
@cindex anchored addresses
@cindex @option{-fsection-anchors}

GCC通常将每一个静态对象作为一个单独的实体来寻址。例如，如果我们有：

@smallexample
static int a, b, c;
int foo (void) @{ return a + b + c; @}
@end smallexample

@code{foo}的代码通常会计算三个独立的符号地址：@code{a}，@code{b}和@code{c}的。
在一些target上，只计算一个符号地址并且通过相对地址来访问这三个变量会更好些。
等价的伪代码可能为：

@smallexample
int foo (void)
@{
  register int *xr = &x;
  return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
@}
@end smallexample

（这不是有效的C）。我们称像@code{x}这样的共享地址为“section anchors”。
它们的用法由@option{-fsection-anchors}控制。

下面的钩子描述了GCC需要知道的target属性，以便有效利用section anchors。
除非@code{TARGET_MIN_ANCHOR_OFFSET}或@code{TARGET_MAX_ANCHOR_OFFSET}
被设为一个非0的值，否则section anchors根本不会被使用。

@deftypevar {Target Hook} HOST_WIDE_INT TARGET_MIN_ANCHOR_OFFSET
应该应用到section anchor的最小偏移量。在大多数target上，
其应该为可以应用到基址寄存器并且对每种机器模式都可以给出合法地址的最小偏移量。
缺省值为0。
@end deftypevar

@deftypevar {Target Hook} HOST_WIDE_INT TARGET_MAX_ANCHOR_OFFSET
类似@code{TARGET_MIN_ANCHOR_OFFSET}，
但是为可以应用到section anchors的最大(包括)偏移量。缺省为0。
@end deftypevar

@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_ANCHOR (rtx @var{x})
写汇编代码来定义section anchor @var{x}，其为一个@code{SYMBOL_REF}，
并且@samp{SYMBOL_REF_ANCHOR_P (@var{x})}为真。该钩子被调用时，
汇编输出位置被设为@code{SYMBOL_REF_BLOCK (@var{x})}的起始处。

如果@code{ASM_OUTPUT_DEF}可用，
则钩子的缺省定义使用它来定义符号为@samp{. + SYMBOL_REF_BLOCK_OFFSET (@var{x})}。
如果@code{ASM_OUTPUT_DEF}不可用，则钩子的缺省定义为@code{NULL}，
其禁止了section anchors的使用。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_USE_ANCHORS_FOR_SYMBOL_P (rtx @var{x})
返回真，如果GCC应该尝试使用anchors来访问@code{SYMBOL_REF} @var{x}。
你可以假设@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}和
@samp{!SYMBOL_REF_ANCHOR_P (@var{x})}。

缺省版本对于大多数target都正确，
但是你可能需要截取该钩子来处理target特定的属性或者target特定的section。
@end deftypefn

@node 条件代码
@section 条件代码状态
@cindex condition code status

@c prevent bad page break with this line
这节描述了条件代码状态。

@findex cc_status
文件@file{conditions.h}定义了变量@code{cc_status}，
用来描述条件代码如何被计算（对于条件代码的解释取决于设置它的指令的情况）。
该变量包含了条件码目前基于的RTL表达式，以及一些标准的标记。

有时额外的机器特定的标记必须被定义，在机器描述头文件中。
其还可以增加额外的机器特定信息，通过定义@code{CC_STATUS_MDEP}。

@defmac CC_STATUS_MDEP
一个数据类型的C代码，其用于声明@code{cc_status}的@code{mdep}部件。
缺省为@code{int}。

该宏在不使用@code{cc0}的机器上不被使用。
@end defmac

@defmac CC_STATUS_MDEP_INIT
一个C表达式，用来初始化@code{mdep}域为“空”。缺省定义不做任何事，
因为大多数机器不使用该域。如果你想使用该域，则可能应该定义该宏来初始化它。

该宏在不使用@code{cc0}的机器上不被使用。
@end defmac

@defmac NOTICE_UPDATE_CC (@var{exp}, @var{insn})
一个C复合语句，用来适当的为主体为@var{exp}的@var{insn}，
设置@code{cc_status}的部件。
该宏负责识别insn将条件码设置作为副产品以及显示的set @code{(cc0)}。

该宏在不使用@code{cc0}的机器上不被使用。

如果insn不设置条件码，但修改其它机器寄存器，
则该宏必须检查它们是否使得记录条件码的表达式变为无效。例如，在68000上，
在地址寄存器上存储insn不设置条件码，
其意味着通常@code{NOTICE_UPDATE_CC}对于这样的insn可以不修改@code{cc_status}。
但是假设之前的insn将条件码设成基于位置@samp{a4@@(102)}，
并且当前insn在@samp{a4}上存储了一个新值。虽然条件码没有被改变，
但其不再为真，因为其反映了@samp{a4@@(102)}的内容。因此对于这种情况，
@code{NOTICE_UPDATE_CC}必须修改@code{cc_status}，来表示条件码值不可知。

@code{NOTICE_UPDATE_CC}的定义必须要准备处理窥孔优化的结果：
insn的指令模式为@code{parallel} RTXs，其包含了不同的@code{reg}，
@code{mem}或者常量操作数。这些insn的RTL结构体不足以表明insn实际要做的事情。
@code{NOTICE_UPDATE_CC}应该做的是当遇到这样的，就直接运行@code{CC_STATUS_INIT}。

@code{NOTICE_UPDATE_CC}可能的定义为调用一个函数，
来查看一个属性（参见 @ref{Insn属性}），例如名为@samp{cc}。这避免了在两个地方，
@file{md}文件和@code{NOTICE_UPDATE_CC}中具有指令模式的详细信息。
@end defmac

@defmac SELECT_CC_MODE (@var{op}, @var{x}, @var{y})
当比较运算代码@var{op}应用到rtx @var{x}和@var{y}上时，
从@code{MODE_CC}类中返回一个机器模式。例如，在SPARC上，
@code{SELECT_CC_MODE}被定义为（该定义的描述，参见 @ref{跳转指令模式}）

@smallexample
#define SELECT_CC_MODE(OP,X,Y) \
  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT          \
   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)    \
   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS    \
       || GET_CODE (X) == NEG) \
      ? CC_NOOVmode : CCmode))
@end smallexample

你应该定义该宏，当且仅当你在@file{@var{machine}-modes.def}中定义了额外的CC机器模式。
@end defmac

@defmac CANONICALIZE_COMPARISON (@var{code}, @var{op0}, @var{op1})
在一些机器上，并不是所有可能的比较都被定义，
但你可以将一个无效的比较转换为一个有效的。例如，Alpha没有@code{GT}比较，
但你可以使用@code{LT}比较来替代，并且交换操作数的顺序。

在一些机器上，定义该宏为一条C语句来做任何需要的转换。
@var{code}为初始化比较代码，@var{op0}和@var{op1}为比较的左，右操作数。
你应该根据需要来修改@var{code}，@var{op0}和@var{op1}。

GCC将不假设该宏的比较结果为有效的，
但会查看结果insn是否匹配@file{md}文件中的指令模式。

你不需要定义该宏，如果其不会改变比较代码或者操作数。
@end defmac

@defmac REVERSIBLE_CC_MODE (@var{mode})
一个C表达式，其值为1，如果总是可以安全的将模式为@var{mode}的比较运算逆转。
如果@code{SELECT_CC_MODE}可以为浮点不等于比较返回@var{mode}，
则@code{REVERSIBLE_CC_MODE (@var{mode})}必须为0。

你不需要定义该宏，如果其总是返回0，
或者如果浮点格式不是@code{IEEE_FLOAT_FORMAT}。
例如，这是在SPARC上的定义，其中浮点不等于比较总是为@code{CCFPEmode}：

@smallexample
#define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)
@end smallexample
@end defmac

@defmac REVERSE_CONDITION (@var{code}, @var{mode})
一个C表达式，其值为按照CC_MODE模式进行比较的条件码的逆转。
宏只用于@code{REVERSIBLE_CC_MODE (@var{mode})}为非0的情况。
当机器具有某种非标准的方式来反转特定条件时，定义该宏。
例如，当所有浮点条件为非陷阱的，编译器可以自由的转换未排序的比较为排序的。
则定义可以为：

@smallexample
#define REVERSE_CONDITION(CODE, MODE) \
   ((MODE) != CCFPmode ? reverse_condition (CODE) \
    : reverse_condition_maybe_unordered (CODE))
@end smallexample
@end defmac

@defmac REVERSE_CONDEXEC_PREDICATES_P (@var{op1}, @var{op2})
C表达式，返回真，如果条件执行断言@var{op1}，一个比较操作，为@var{op2}的反转，
反之亦然。定义该宏返回0，如果target具有条件执行断言，且不能被安全的反转。
不需要验证参数op1和op2相等，这已经被单独执行过。如果没有指定，该宏被定义为：

@smallexample
#define REVERSE_CONDEXEC_PREDICATES_P (x, y) \
   (GET_CODE ((x)) == reversed_comparison_code ((y), NULL))
@end smallexample
@end defmac

@deftypefn {Target Hook} bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *, unsigned int *)
对于一些target，其不使用@code{(cc0)}，而是使用硬件寄存器来存放条件码，
而不是伪寄存器，则正规的CSE过程通常不能识别硬件寄存器被设为一个普通值的情况。
使用该钩子来开启一个小的过程，来优化这种情况。该钩子应该返回真，来开启该过程，
并且应该将参数设置成指向用于条件码的硬件寄存器编号。当只有一个这样的寄存器时，
这在大多数系统上都为真，则第二个参数指向的整数应该被设为@code{INVALID_REGNUM}。

该钩子的缺省版本返回假。
@end deftypefn

@deftypefn {Target Hook} enum machine_mode TARGET_CC_MODES_COMPATIBLE (enum machine_mode, enum machine_mode)
对于一些target，其使用@code{MODE_CC}类别中的多个条件码机器模式，
有时比较可以对多个机器模式都有效。在这样的系统上，
定义该target钩子来接收两个mode参数并返回一个mode，
对于该模式两个比较都可以被有效执行。如果没有这样的模式，则返回@code{VOIDmode}。

该钩子的缺省版本检查模式是否相同。如果是，则返回该模式。如果不同，
则返回@code{VOIDmode}。
@end deftypefn

@node 代价
@section 描述操作的相对代价
@cindex costs of instructions
@cindex relative costs
@cindex speed of instructions

这些宏让你描述target机器上各种操作的相对速度。

@defmac REGISTER_MOVE_COST (@var{mode}, @var{from}, @var{to})
一个C表达式，
为从寄存器类别@var{from}到类别@var{to}移动模式为@var{mode}的数据的代价。
类别使用枚举值表示，例如@code{GENERAL_REGS}。缺省值为2；其它值相对于它来解析。

当@var{from}与@var{to}相同时，并不要求代价总是为2；在一些机器上，
如果不是通用寄存器，则寄存器之间的移动代价是昂贵的。

如果重载遇到一个insn，由两个硬件寄存器之间的单个@code{set}组成，
并且如果@code{REGISTER_MOVE_COST}应用到它们的类别上返回2，
则重载不检查insn的约束是否满足。将代价设为2以外的值将允许重载验证约束是否满足。
如果@samp{mov@var{m}}模式的约束不允许这样的复制，则你应该这样做。
@end defmac

@defmac MEMORY_MOVE_COST (@var{mode}, @var{class}, @var{in})
一个C表达式，
为在寄存器类别@var{class}和内存之间移动模式为@var{mode}的数据的代价；
@var{in}为0，如果值要被写到内存中，非0，如果要从内存中读进。
该代价为@code{REGISTER_MOVE_COST}的相对值。
如果在寄存器和内存间移动比两个寄存器之间更昂贵，则应该定义该宏来表示相对代价。

如果你没有定义该宏，如果需要的话，
则GCC使用缺省值4加上通过第二个重载寄存器复制的代价。
如果你的机器需要第二个重载寄存器在内存和寄存器类别@var{class}直接复制，
但是重载机制比通过中间物质复制更复杂，则定义该宏来反映move的实际代价。

GCC定义函数@code{memory_move_secondary_cost}，如果需要第二次重载。
其根据通过第二个寄存器复制来计算代价。
如果你的机器使用第二个寄存器按照约定的方式从内存中复制，
但是缺省值4对你的机器不正确，则定义该宏来增加某个其它值作为那个函数的结果。
函数的参数与该宏相同。
@end defmac

@defmac BRANCH_COST (@var{speed_p}, @var{predictable_p})
一个C表达式，为分支指令的代价。缺省值为1；其它值相对于它来解析。
@end defmac

这些是额外的宏，其不指定确切的相对代价，而只是指定特定的动作比GCC通常期望的要昂贵。

@defmac SLOW_BYTE_ACCESS
定义该宏为一个C表达式，如果访问小于一个字的内存
（即@code{char}或者@code{short}）不如访问一个字的内存快，即，
如果这样的访问需要多于一条的指令，并且如果字节和（对齐的）字加载的代价没有区别，
则值为非零。

当该宏没有被定义，则编译器将通过找到最小的包含对象来访问一个域；当其被定义，
如果允许对齐，则会使用全字的加载。除非字节访问比字访问快，则使用字访问比较好，
因为其可以消除后续的内存访问，如果后续的访问发生在结构体的相同字的其它域。
@end defmac

@defmac SLOW_UNALIGNED_ACCESS (@var{mode}, @var{alignment})
定义该宏的值为1，
如果由@var{mode}和@var{alignment}参数描述的内存访问比对齐的访问具有多倍的代价，
例如如果它们在陷阱处理中被模拟。

当该宏为非0时，编译器在为块移动生成代码时，
将按照@code{STRICT_ALIGNMENT}为非0的方式执行。这可以引起相当多的指令被产生。
因此如果非对齐访问只是增加一个周期或者两个，则不要设置该宏为非零。

如果该宏的值总是0，则不需要被定义。如果该宏被定义，其应该产生一个非0值，
当@code{STRICT_ALIGNMENT}非0时。
@end defmac

@defmac MOVE_RATIO
标量的内存到内存的move insn的临界数，@emph{低于}其值的时候，
应该生成一个insn序列，而不是字符串move insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

注意在一些机器上，对应的move insn为一个@code{define_expand}，
其产生一个insn序列，则该宏为该序列的个数。

如果没有定义，则会使用一个合理的缺省值。
@end defmac

@defmac MOVE_BY_PIECES_P (@var{size}, @var{alignment})
一个C表达式，用于确定是否使用@code{move_by_pieces}来复制一块内存，
或者使用其它某种块移动机制。缺省为1，
如果@code{move_by_pieces_ninsns}返回值小于@code{MOVE_RATIO}。
@end defmac

@defmac MOVE_MAX_PIECES
一个C表达式，
由@code{move_by_pieces}使用用于确定load或者store用于复制内存的最大单元。
缺省为@code{MOVE_MAX}。
@end defmac

@defmac CLEAR_RATIO
标量move insn的临界数，@emph{低于}其值时，应该生成一个insn序列来清除内存，
而不是字符串clear insn或者库调用。增加值将总是使得代码更快，
但是会最终由于代码大小的增加而产生高的代价。

如果没有定义，则会使用一个合理的缺省值。
@end defmac

@defmac CLEAR_BY_PIECES_P (@var{size}, @var{alignment})
一个C表达式，用于确定是否使用@code{clear_by_pieces}来清除一块内存，
或者使用其它块清楚机制。缺省为1，
如果@code{move_by_pieces_ninsns}返回值小于@code{CLEAR_RATIO}。
@end defmac

@defmac SET_RATIO
标量move insn的临界数，@emph{低于}其值时，
应该生成一个insn序列来将内存设为一个常量值，而不是一个块设置insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

如果没有定义，缺省值为@code{MOVE_RATIO}。
@end defmac

@defmac SET_BY_PIECES_P (@var{size}, @var{alignment})
一个C表达式用来确定是否使用@code{store_by_pieces}来设置内存块为常量值，
或者使用其它机制。当存储非常数0的值时，由@code{__builtin_memset}使用。
缺省为1，如果@code{move_by_pieces_ninsns}返回值小于@code{SET_RATIO}。
@end defmac

@defmac STORE_BY_PIECES_P (@var{size}, @var{alignment})
一个C表达式用来确定是否使用@code{store_by_pieces}来设置内存块为常量字符串，
或者使用其它的机制。当使用常量源字符串调用时，被@code{__builtin_strcpy}使用。
缺省为1，如果@code{move_by_pieces_ninsns}返回值小于@code{MOVE_RATIO}。
@end defmac

@defmac USE_LOAD_POST_INCREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，后增加载是否好。
缺省值为@code{HAVE_POST_INCREMENT}。
@end defmac

@defmac USE_LOAD_POST_DECREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，后减加载是否好。
缺省值为@code{HAVE_POST_DECREMENT}。
@end defmac

@defmac USE_LOAD_PRE_INCREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，前增加载是否好。
缺省值为@code{HAVE_PRE_INCREMENT}。
@end defmac

@defmac USE_LOAD_PRE_DECREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，前减加载是否好。
缺省值为@code{HAVE_PRE_DECREMENT}。
@end defmac

@defmac USE_STORE_POST_INCREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，后增存储是否好。
缺省值为@code{HAVE_POST_INCREMENT}。
@end defmac

@defmac USE_STORE_POST_DECREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，后减存储是否好。
缺省值为@code{HAVE_POST_DECREMENT}。
@end defmac

@defmac USE_STORE_PRE_INCREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，前增存储是否好。
缺省值为@code{HAVE_PRE_INCREMENT}。
@end defmac

@defmac USE_STORE_PRE_DECREMENT (@var{mode})
一个C表达式用于确定对于给定的mode，前减存储是否好。
缺省值为@code{HAVE_PRE_DECREMENT}。
@end defmac

@defmac NO_FUNCTION_CSE
定义该宏，如果调用常量函数地址要比调用保存在寄存器中的地址好些。
@end defmac

@defmac RANGE_TEST_NON_SHORT_CIRCUIT
定义该宏，如果由@samp{fold_range_test ()}产生的non-short-circuit操作为可选的。
该宏缺省为真，如果@code{BRANCH_COST}大于或等于2。
@end defmac

@deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, int @var{code}, int @var{outer_code}, int *@var{total})
该target钩子描述了RTL表达式的相对代价。

代价可以依赖于表达式的确切形式，可以通过检查@var{x}来获得表达式的形式，
表达式包含的rtx的代码为@var{outer_code}。@var{code}为表达式代码，冗余的，
因为其可以使用@code{GET_CODE (@var{x})}获得。

实现该钩子时，
你可以使用结构@code{COSTS_N_INSNS (@var{n})}来指定代价等价于@var{n}个指令。

在钩子的入口处，@code{*@var{total}}包含了缺省的表达式代价的估值。需要的话，
钩子应该修改该值。传统的，缺省代价对于乘法为@code{COSTS_N_INSNS (5)}，
对于除法和求模为@code{COSTS_N_INSNS (7)}，
对于其它操作为@code{COSTS_N_INSNS (1)}。

当优化代码大小时，即，当@code{optimize_size}非0时，
该target钩子应该用于估计一个表达式的相对大小代价，
同样也是相对于@code{COSTS_N_INSNS}。

钩子返回真，当所有@var{x}的子表达式都被处理，当@code{rtx_cost}应该递归时返回假。
@end deftypefn

@deftypefn {Target Hook} int TARGET_ADDRESS_COST (rtx @var{address})
该钩子计算包含@var{address}的寻址模式的代价。如果没有定义，
代价通过@var{address}表达式和@code{TARGET_RTX_COST}钩子来计算。

对于大多数CISC机器，缺省代价为寻址模式的真实代价的合理近似值。
然而，在RISC机器上，所有指令通常具有相同的长度和执行时间。
因此所有寻址将具有相等的代价。

对于多于一个的形式的寻址，将会使用最低代价的形式。
如果多个形式具有相同的，最低的代价，则使用最复杂的。

例如，假设地址等于寄存器和常量的和，并在同一基本块中使用两次。
当该宏没有被定义，地址将在寄存器中计算，并且内存引用将通过寄存器间接实现。
在一些机器上，包含该和的寻址模式的代价不比简单的间接引用高，
这样则会产生一条额外的指令，并且可能需要一个额外的寄存器。
对该宏进行合适的指定，会消除这样的情况。

该钩子从不会被无效地址调用。

在一些机器上，地址包括多于一个寄存器的代价，
跟只包含一个寄存器的地址计算代价一样低，
则定义@code{TARGET_ADDRESS_COST}来反映这种情况，
可以使得两个寄存器在代码域中为活跃的，如果没有定义则可能只有一个为活跃的。
这种效果在定义该宏时应该被考虑。
可能只有对于有大量寄存器的机器才可能会有相等的代价。
@end deftypefn

@node 调度
@section 调整指令调度器

指令调度器可能需要一些机器特定的调整，来产生好的代码。GCC为此提供了几个target钩子。通常定义它们的一部分就足够了：先尝试该列表中最前面的。

@deftypefn {Target Hook} int TARGET_SCHED_ISSUE_RATE (void)
该钩子返回在target机器上同一时间可以发射的最大指令数目。缺省为1。
虽然insn调度器本身可以定义同一周期发射一个insn的可能能性，
但该值可以作为额外的约束，用于相同模拟处理器周期的insn发射
（参见钩子@samp{TARGET_SCHED_REORDER}和@samp{TARGET_SCHED_REORDER2}）。
该值在整个编译过程中必须为常量。如果你需要其依赖指令是什么而变化，
则必须使用@samp{TARGET_SCHED_VARIABLE_ISSUE}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_VARIABLE_ISSUE (FILE *@var{file}, int @var{verbose}, rtx @var{insn}, int @var{more})
该钩子在调度器从就绪列表中调度了一个insn之后被执行。
其应该返回在当前周期仍然可以被发射的insn数目。
对于@code{CLOBBER}和@code{USE}之外的insn，缺省为@samp{@w{@var{more} - 1}}，
其通常不根据发射频率来计数。你应该定义该钩子，
如果一些insn比其它的需要更多的机器资源，
使得在同一周期它们后面可以跟随较少的insn。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{insn}为被调度的指针。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_ADJUST_COST (rtx @var{insn}, rtx @var{link}, rtx @var{dep_insn}, int @var{cost})
该函数根据@var{insn}和@var{dep_insn}通过依赖链接的关系来更正@var{cost}值。
其应该返回新的值。缺省为不对@var{cost}进行调整。
例如这可以用于指定调度器使用传统的流水线描述，
即输出或反向依赖不产生与数据依赖相同的代价。
如果调度器使用基于流水线描述的自动机，则反向依赖的代码为0，
输出依赖的代价为1和第一个insn与第二个insn之间的延迟时间的最大值。
如果这些值无法接受，你应该使用该钩子来修改它们。参见 @ref{处理器流水线描述}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_ADJUST_PRIORITY (rtx @var{insn}, int @var{priority})
该钩子调整@var{insn}的整数调度有限级@var{priority}。其应该返回新的priority。
增加优先级来提前执行@var{insn}，减少优先级来推迟执行@var{insn}。
如果不需要调整insn的调度优先级，则不需要定义该钩子。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_REORDER (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_readyp}, int @var{clock})
该钩子在调度器调度完就绪列表后被执行，
以允许机器描述来重新排序（例如在@samp{VLIW}机器上，将两个小指令合并一起）。
@var{file}或者为一个null指针，或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{ready}为指向已经被调度的指令就绪列表的指针。
@var{n_readyp}为指向在就绪列表中的元素个数的指针。
调度器按照相反的顺序读取就绪列表，从@var{ready}[@var{*n_readyp}-1]开始，
到@var{ready}[0]。@var{clock}为调度器的时钟tick。你可以修改就绪列表和insn。
返回值为这个周期可以发射的insn数；这通常只是为@code{issue_rate}。
参见@samp{TARGET_SCHED_REORDER2}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_REORDER2 (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_ready}, @var{clock})
类似于@samp{TARGET_SCHED_REORDER}，只不过在不同的时间被调用。
该函数每当调度器开始一个新的周期时被调用。其在每个周期都被调用一次，
紧跟在@samp{TARGET_SCHED_VARIABLE_ISSUE}之后；
其可以重排就绪列表并返回在同一周期被调度的insn数目。
如果常常调度一个insn会引起其他insn可以在同一周期就绪，则定义该钩子会很有用。
这样其它insn便可以被适当的考虑进来。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx @var{head}, rtx @var{tail})
该钩子在由两个参数值给出的链中向前评估完insn的依赖关系之后，
但在insn链的调度之前被调用。例如，其可以被用于更好的insn分类，
如果其需要依赖分析。该钩子可以使用insn调度器的向后和向前依赖，
因为它们已经被计算好了。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT (FILE *@var{file}, int @var{verbose}, int @var{max_ready})
该钩子在每个要被调度的指令块的起始处被调用。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{max_ready}为在当前调度域中可以同时活跃的insn最大数。
这可以用来分配需要的草稿空间，例如，@samp{TARGET_SCHED_REORDER}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FINISH (FILE *@var{file}, int @var{verbose})
该钩子在每个要被调度的指令块的起始处被调用。
其可以用于执行清除由其它调度钩子完成的任何动作。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_GLOBAL (FILE *@var{file}, int @var{verbose}, int @var{old_max_uid})
该钩子在函数级初始化的时候被调度器执行。@var{file}或者为一个null指针，
或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@var{old_max_uid}为调度开始时，最大的insn uid。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FINISH_GLOBAL (FILE *@var{file}, int @var{verbose})
这是一个清除钩子，对应于@code{TARGET_SCHED_INIT_GLOBAL}。
@var{file}或者为一个null指针，或者一个stdio流，用来写入调试输出。
@var{verbose}为@option{-fsched-verbose-@var{n}}提供的详细级别。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)
该钩子返回一个RTL insn。流水线冒险识别器中的自动机状态，
按照当新的模拟处理器周期开始，insn被调度的样子被改变。
该钩子的用法可以简化一些@acronym{VLIW}处理器的自动机流水线描述。
如果钩子被定义，其只用于基于自动机的流水线描述。缺省为不改变状态，
当新的模拟处理器周期开始时。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN (void)
该钩子可以用于初始化先前的钩子所使用的数据。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_DFA_POST_CYCLE_INSN (void)
该钩子与@samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN}类似，但用于改变状态，
按照当新的模拟处理器周期结束时insn被调度的方式。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN (void)
该钩子与@samp{TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN}类似，
但用于初始化先前的钩子所使用的数据。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_DFA_PRE_CYCLE_ADVANCE (void)
该钩子用来通报target，当前模拟周期将要完成。
该钩子类似于@samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN}，
但用于在更复杂的情况下改变状态，例如当在一个单独的insn上前移一个状态并不足够时。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_DFA_POST_CYCLE_ADVANCE (void)
该钩子用来通报target，新的模拟周期刚刚开始。
该钩子类似于@samp{TARGET_SCHED_DFA_POST_CYCLE_INSN}，
但用于在更复杂的情况下改变状态，例如当在一个单独的insn上前移一个状态并不足够时。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD (void)
该钩子控制基于@acronym{DFA}的insn调度器来更好的选择一个insn，
从就绪insn队列中。通常调度器从队列中选择第一个insn。如果钩子返回一个正值，
则会有额外的调度器代码来尝试所有的@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()}的排列组合，
来选择一个insn，使得发射该insn将在同一周期产生最大的insn发射数。
对于@acronym{VLIW}处理器，
代码实际上解决了将简单insn打包成@acronym{VLIW} insn的问题。
当然，如果@acronym{VLIW}打包规则在自动机中有描述。

该代码还能用于超标量@acronym{RISC}处理器。
让我们考虑一个具有3级流水的超标量@acronym{RISC}处理器。
一些insn可以在流水线@var{A}或@var{B}中被执行，
一些insn只能在流水线@var{B}或@var{C}中执行，
并且有一个insn可以在流水线@var{B}中被执行。处理器可以发射第一个insn到@var{A}，
第二个到@var{B}。这种情况下，第三个insn将会等待释放@var{B}，直到下一个周期。
如果调度器先发射第三个insn，则处理器可以一个周期发射所有的3个insn。

实际上该代码证明了基于自动机的流水线冒险识别器的优点。
我们最快且最容易的尝试许多insn调度，并选择最好的一种。

缺省为不进行多遍的调度。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD (rtx)
该钩子控制了对于多遍insn调度，就绪insn队列中的什么样的insn将被考虑。
如果钩子返回0，对于最为参数传递的insn，则insn将不被选择发射。

缺省为所有的就绪insn都可以被选择发射。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_DFA_NEW_CYCLE (FILE *, int, rtx, int, int, int *)
该钩子在给定的周期，在发射作为第三个参数传递的insn之前被insn调度器调用。
如果钩子返回非零，则insn在给定的处理器周期将不被发射。替代的，
处理器周期将前移。如果最后一个参数的值为0，
则insn就绪队列没有在新的周期开始时按照通常的方式被排序。
第一个参数传递了调试输出的文件。第二个参数传递了调试输出的详细级别。
第四个和第五个参数值分别对应于之前insn被发射的处理器周期，以及当前处理器周期。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct dep_def *@var{_dep}, int @var{cost}, int @var{distance})
该钩子用于定义哪种依赖被target认为是具有昂贵代价的，
以至于将insn调度成依赖太近是不明智的。参数为：
第一个参数@var{_dep}为被评估的依赖。第二个参数@var{cost}为依赖的代价，
第三个参数@var{distance}为两个insn的周期距离。钩子返回@code{true}，
如果考虑两个insn间的距离，它们间的依赖被 target认为是昂贵的，
否则为@code{false}。

在多发射，乱序机器上，定义该钩子可以有用，
（a）实际中是无法预测真实的数据/资源延迟，
但是（b）有一个更好的机会来预测实际要被执行的组，
并且（c）正确模拟分组会非常重要。在这样的target上，
可能想要允许发射距离较近的依赖insn，即，比依赖距离近；
但是对于“昂贵的依赖”不这样做，这样就可以定义该钩子。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_H_I_D_EXTENDED (void)
该钩子在输出一个新的指令到指令流之后被insn调度器调用。
钩子通知target后端来延伸它的每个指令的数据结构。
@end deftypefn

@deftypefn {Target Hook} void * TARGET_SCHED_ALLOC_SCHED_CONTEXT (void)

Return a pointer to a store large enough to hold target scheduling context.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_SCHED_CONTEXT (void *@var{tc}, bool @var{clean_p})
Initialize store pointed to by @var{tc} to hold target scheduling context.
It @var{clean_p} is true then initialize @var{tc} as if scheduler is at the
beginning of the block.  Otherwise, make a copy of the current context in
@var{tc}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_CONTEXT (void *@var{tc})
Copy target scheduling context pointer to by @var{tc} to the current context.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_CLEAR_SCHED_CONTEXT (void *@var{tc})
Deallocate internal data in target scheduling context pointed to by @var{tc}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FREE_SCHED_CONTEXT (void *@var{tc})
Deallocate a store for target scheduling context pointed to by @var{tc}.
@end deftypefn

@deftypefn {Target Hook} void * TARGET_SCHED_ALLOC_SCHED_CONTEXT (void)
Return a pointer to a store large enough to hold target scheduling context.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_INIT_SCHED_CONTEXT (void *@var{tc}, bool @var{clean_p})
Initialize store pointed to by @var{tc} to hold target scheduling context.
It @var{clean_p} is true then initialize @var{tc} as if scheduler is at the
beginning of the block.  Otherwise, make a copy of the current context in
@var{tc}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_CONTEXT (void *@var{tc})
Copy target scheduling context pointer to by @var{tc} to the current context.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_CLEAR_SCHED_CONTEXT (void *@var{tc})
Deallocate internal data in target scheduling context pointed to by @var{tc}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_FREE_SCHED_CONTEXT (void *@var{tc})
Deallocate a store for target scheduling context pointed to by @var{tc}.
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_SPECULATE_INSN (rtx @var{insn}, int @var{request}, rtx *@var{new_pat})
该钩子当@var{insn}只有投机依赖，并因此可以被投机的调度时，被调用。
钩子用于检查@var{insn}的指令模式是否具有一个投机版本，并且如果检查成功，
则生成那个投机模式。钩子应该返回1，如果具有投机形式，或者-1，如果不具有。
@var{request}描述了请求投机的类型。如果返回值等于1，
则@var{new_pat}被赋值为生成的投机指令模式。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_NEEDS_BLOCK_P (rtx @var{insn})
该钩子在为@var{insn}生成恢复代码时，被insn调度器调用。其应该返回非零，
如果相应的检查指令应该分支跳转到回复代码，否则为0.
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_SCHED_GEN_CHECK (rtx @var{insn}, rtx @var{label}, int @var{mutate_p})
该钩子被insn调度器调用，来为恢复检查指令产生一个指令模式。
如果@var{mutate_p}为0，则@var{insn}为一个投机指令，对此应该生成检查。
@var{label}或者为一个基本快的标号，恢复代码应该被生成的地方，
或者为一个null指针，当请求的检查没有分支到恢复代码（简单的检查）。
如果@var{mutate_p}为非 0，
则由@var{insn}注解的对应于一个简单检查的指令模式应该被生成。
这种情况下，@var{label}不能为null。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC (rtx @var{insn})
该钩子用于在就绪列表中第一个指令上没有调用@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD}的情况。
钩子用于丢弃从当前周期调度的起始于就绪列表的投机指令。对于非投机指令，
钩子应该总是返回非零。例如，在ia64后端，钩子用于取消数据投机insn，
当ALAT表将满时。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_FLAGS (unsigned int *@var{flags}, spec_info_t @var{spec_info})
该钩子被insn调度器用于查找什么特点应该被启用。
@var{flags}初始时可以设置了SCHED_RGN或SCHED_EBB位。这指示调度器过程，
应该提供什么数据。target后端应该修改@var{flags}，通过修改对应于下列特点的位：
USE_DEPS_LIST, USE_GLAT, DETACH_LIFE_INFO和DO_SPECULATION。
对于DO_SPECULATION特点，一个额外的结构体@var{spec_info}应该由target来填充。
该结构体描述了调度器中可以使用的投机类型。
@end deftypefn

@deftypefn {Target Hook} int TARGET_SCHED_SMS_RES_MII (struct ddg *@var{g})
该钩子被swing modulo调度器调用，来计算基于资源的下界，
其基于在机器上可用的资源以及每个指令要求的资源。
target后端可以使用@var{g}来计算这个边界。如果没有实现该钩子，
则会使用一个非常简单的下界：指令总数除以发射率。
@end deftypefn

@node 段
@section 将输出划分到section中（Texts, Data, @dots{}）
@c the above section title is WAY too long.  maybe cut the part between
@c the (...)?  --mew 10feb93

目标文件被划分到包含不同类型数据的section中。大多数情况下，
有三个section：@dfn{text section}，存放指令和只读数据；@dfn{data section}，
存放初始化的可写数据；@dfn{bss section}，存放未初始化的数据。
一些系统还具有其它类型的section。

@file{varasm.c}提供了一些已知的section，例如@code{text_section}, 
@code{data_section}和@code{bss_section}。
通常控制一个@code{@var{foo}_section}变量的方式是定义一个相关联的
宏@code{@var{FOO}_SECTION_ASM_OP}，正如下面将要描述的。
宏只在@file{varasm.c}初始化时被读一次，
所以它们的值必须为运行时常量。不过它们可以依赖于命令行标记。

注意：一些运行时文件，例如@file{crtstuff.c}，
也使用@code{@var{FOO}_SECTION_ASM_OP}宏，并且将它们作为字符串文字。

一些汇编器要求每次选择section时，都要写入一个不同的字符串。
如果你的汇编器属于这类，
你应该定义@code{TARGET_ASM_INIT_SECTIONS}钩子并使用
@code{get_unnamed_section}来建立section。

你必须总是创建一个@code{text_section}，
或者通过定义@code{TEXT_SECTION_ASM_OP}，
或者通过在@code{TARGET_ASM_INIT_SECTIONS}中初始化@code{text_section}。
同样对于@code{data_section}和@code{DATA_SECTION_ASM_OP}。
如果你没有创建一个独立的@code{readonly_data_section}，
则缺省使用@code{text_section}。

所有其他@file{varasm.c} section都是可选的，如果target不提供则为null。

@defmac TEXT_SECTION_ASM_OP
一个C表达式，值为一个字符串，包括空格，
其包含了在指令和只读数据之前的汇编操作。通常为@code{"\t.text"}。
@end defmac

@defmac HOT_TEXT_SECTION_NAME
如果定义，则为一个C字符串常量，为包含最频繁被执行的程序的函数的section名字。
如果没有定义，GCC将会提供一个缺省定义，如果target支持命名section。
@end defmac

@defmac UNLIKELY_EXECUTED_TEXT_SECTION_NAME
如果定义，则为一个C字符串常量，为包含程序中不太可能被执行的函数的section名字。
@end defmac

@defmac DATA_SECTION_ASM_OP
一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为可写的初始化数据的汇编操作。通常为@code{"\t.data"}。
@end defmac

@defmac SDATA_SECTION_ASM_OP
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为初始化的，可写的小数据的汇编操作。
@end defmac

@defmac READONLY_DATA_SECTION_ASM_OP
一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为只读的初始化数据的汇编操作。
@end defmac

@defmac BSS_SECTION_ASM_OP
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为未初始化的，global数据的汇编操作。如果没有定义，
并且@code{ASM_OUTPUT_BSS}和@code{ASM_OUTPUT_ALIGNED_BSS}也都没有定义，
则为初始化的global数据将被输出在data section，如果使用了@option{-fno-common}，
否则将使用@code{ASM_OUTPUT_COMMON}。
@end defmac

@defmac SBSS_SECTION_ASM_OP
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为未初始化的，可写的小数据的汇编操作。
@end defmac

@defmac INIT_SECTION_ASM_OP
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为初始化代码的汇编操作。如果没有定义，
GCC将假设这样的section不存在。该section没有相应的@code{init_section}变量；
其完全在运行时代码中使用。
@end defmac

@defmac FINI_SECTION_ASM_OP
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为结束代码的汇编操作。如果没有定义，
GCC将假设这样的section不存在。该section没有相应的@code{fini_section}变量；
其完全在运行时代码中使用。
@end defmac

@defmac INIT_ARRAY_SECTION_ASM_OP
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为@code{.init_array}（或相当的） section的一部分的
汇编操作。如果没有定义，GCC将假设这样的section不存在。
不要同时定义该宏和@code{INIT_SECTION_ASM_OP}。
@end defmac

@defmac FINI_ARRAY_SECTION_ASM_OP
如果定义，则为一个C表达式，值为一个字符串，包括空格，
其包含了标识后续的数据为@code{.fini_array}（或相当的） section的一部分的
汇编操作。如果没有定义，GCC将假设这样的section不存在。
不要同时定义该宏和@code{FINI_SECTION_ASM_OP}。
@end defmac

@defmac CRT_CALL_STATIC_FUNCTION (@var{section_op}, @var{function})
如果定义，为一个ASM语句，其通过@var{section_op}来切换到不同的section，
调用@var{function}，然后切换回到text section。这在@file{crtstuff.c}中使用，
如果@code{INIT_SECTION_ASM_OP}或@code{FINI_SECTION_ASM_OP}从init和
fini section中调用初始化和结束函数。缺省下，该宏使用简单的函数调用。
一些port需要手工的代码来避免在函数前奏中对寄存器初始化的依赖，
或者确保常量池在text section中不要结束的太远。
@end defmac

@defmac TARGET_LIBGCC_SDATA_SECTION
如果定义，则为一个字符串，
其命名了在crtstuff和libgcc中定义的小变量应该存放的section。
这在target具有选项来优化访问小数据的时候很有用。例如，
对于具有@code{.sdata} section（像MIPS）的target，
你可以使用@code{-G 0}来编译crtstuff，使得其不需要小数据的支持，
但是使用该宏将小数据放到@code{.sdata}中，
这样你的应用程序不管是否使用小数据，都可以访问到这些变量。
@end defmac

@defmac FORCE_CODE_SECTION_ALIGN
如果定义，则为一个ASM语句，其将code section对齐到某个任意的边界。
这用于使得所有@code{.init}和@code{.fini} section的fragment都具有同样的对齐，
这样就可以阻止连接器增加任何padding。
@end defmac

@defmac JUMP_TABLES_IN_TEXT_SECTION
定义该宏为一个表达式，具有非零值，如果跳转表（对于@code{tablejump} insn）
应该被输出到text secton中，以及汇编指令。否则，使用只读data section。

如果没有独立的只读data section，则该宏不相关。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_INIT_SECTIONS (void)
定义该钩子，如果你需要在建立@file{varasm.c} section时做一些特殊的处理，
或者你的target具有一些特殊的section需要创建。

GCC在处理完命令行之后，在写任何汇编代码之前，
并在调用任何下面描述的返回section的钩子之前调用该钩子。
@end deftypefn

@deftypefn {Target Hook} TARGET_ASM_RELOC_RW_MASK (void)
返回一个掩码，用来描述当选择section时，应该如何对待重定位。
如果全局重定位应该放在读写section中，则应该设置位1；
如果局部重定位应该被放在读写section中，则应该设置位0。

该函数的缺省版本返回3，当@option{-fpic}有效时，否则返回0。
当target不支持（某种）在只读section中，甚至在可执行程序中的动态重定位时，
通常会重定义该钩子。
@end deftypefn

@deftypefn {Target Hook} {section *} TARGET_ASM_SELECT_SECTION (tree @var{exp}, int @var{reloc}, unsigned HOST_WIDE_INT @var{align})
返回@var{exp}应该被放入的section。
你可以假设@var{exp}为@code{VAR_DECL}节点或者一个常量。
@var{reloc}指示@var{exp}的初始化值是否需要连接时重定位。
当变量只包含局部重定位时位0被设置，对于全局重定位位1被设置。
@var{align}为常量对齐位数。

该函数的缺省版本只关心将只读变量放到@code{readonly_data_section}中。

参见@var{USE_SELECT_SECTION_FOR_FUNCTIONS}.
@end deftypefn

@defmac USE_SELECT_SECTION_FOR_FUNCTIONS
如果你希望对于@code{FUNCTION_DECL}，
将会调用TARGET_ASM_SELECT_SECTION，则定义该宏。同样对于变量和常量。

对于@code{FUNCTION_DECL}，@var{reloc}将为0，如果函数被确定有可能被调用，
非零如果其不能被调用。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_UNIQUE_SECTION (tree @var{decl}, int @var{reloc})
构建一个唯一的section名，使用@code{STRING_CST}节点表示，
并赋值为@samp{DECL_SECTION_NAME (@var{decl})}。
跟@code{TARGET_ASM_SELECT_SECTION}一样，
@var{reloc}指示@var{exp}的初始化值是否需要连接时重定位。

该函数的缺省版本向ELF section名中追加一个符号名。例如，
函数@code{foo}将被放在@code{.text.foo}中。
这对于实际的target目标格式通常是可以的。
@end deftypefn

@deftypefn {Target Hook} {section *} TARGET_ASM_FUNCTION_RODATA_SECTION (tree @var{decl})
返回与@samp{DECL_SECTION_NAME (@var{decl})}关联的只读data section。
该函数的缺省版本选择@code{.gnu.linkonce.r.name}，
如果函数的section为@code{.gnu.linkonce.t.name}，
@code{.rodata.name}如果函数在@code{.text.name}中，
否则为通常的只读data section。
@end deftypefn

@deftypefn {Target Hook} {section *} TARGET_ASM_SELECT_RTX_SECTION (enum machine_mode @var{mode}, rtx @var{x}, unsigned HOST_WIDE_INT @var{align})
返回具有机器模式mode的常量x应该放入的section。
你可以假设@var{x}为RTL形式的某种常量。参数@var{mode}除了@code{const_int}之外，
是冗余的。@var{align}为常量对齐位数。

该函数的缺省版本考虑将符号常量@code{flag_pic}模式的，放在@code{data_section}中，
其它放在@code{readonly_data_section}中。
@end deftypefn

@deftypefn {Target Hook} void TARGET_MANGLE_DECL_ASSEMBLER_NAME (tree @var{decl}, tree @var{id})
定义该钩子，如果你需要处理由target无关的代码生成的汇编名。
提供给该钩子的@var{id}将为被计算的名字（例如C中的@code{DECL_NAME}宏，
或者C++中的mangled name）。该钩子的返回值为一个@code{IDENTIFIER_NODE}。
该钩子的缺省实现只是返回提供的@var{id}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ENCODE_SECTION_INFO (tree @var{decl}, rtx @var{rtl}, int @var{new_decl_p})
定义该钩子，如果对符号或者常量的引用必须根据符号所命名的变量或者函数来不同处理
（例如其在哪个section中）。

钩子在为@var{decl}创建@var{rtl}之后立即被执行，
@var{decl}可能为一个变量或者函数声明，或者常量池的入口。@emph{不要}在该钩子中
使用@code{DECL_RTL (@var{decl})}；那个域可能还没有被初始化。

对于常量，可以假设rtl为一个@code{mem}，其地址为一个 @code{symbol_ref}。
大多数decl将具有这种形式，但不被保证。全局寄存器变量，例如，
它们的rtl将具有一个@code{reg}。（对于这样不寻常的rtl通常是将其放在一边）。

参数@var{new_decl_p}将为真，
如果这是第一次对于该decl调用@code{TARGET_ENCODE_SECTION_INFO}。
对于后续的调用其将为假，这放生在复制的声明中。对于复制声明，是否需要做什么，
取决于钩子是否检查@code{DECL_ATTRIBUTES}。当钩子对于常量被调用，
则@var{new_decl_p}总为真。

@cindex @code{SYMBOL_REF_FLAG}, in @code{TARGET_ENCODE_SECTION_INFO}
该钩子通常做的事情是记录@code{symbol_ref}中的标记，
使用@code{SYMBOL_REF_FLAG}或@code{SYMBOL_REF_FLAGS}。

该钩子的缺省定义，@file{varasm.c}中的@code{default_encode_section_info}，
设置了@code{SYMBOL_REF_FLAGS}中通常有用的位。
在覆盖它之前检查缺省代码是否做了你所需要的。
@end deftypefn

@deftypefn {Target Hook} const char *TARGET_STRIP_NAME_ENCODING (const char *name)
解析@var{name}并返回真实的名字部分，
没有@code{TARGET_ENCODE_SECTION_INFO}可能加进去的字符。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_IN_SMALL_DATA_P (tree @var{exp})
返回真，如果@var{exp}应该被放到“小数据”section中。该钩子的缺省版本总是返回假。
@end deftypefn

@deftypevar {Target Hook} bool TARGET_HAVE_SRODATA_SECTION
如果target将只读“小数据”放到单独的section中，则包含值为真。缺省值为假。
@end deftypevar

@deftypefn {Target Hook} bool TARGET_BINDS_LOCAL_P (tree @var{exp})
返回真，如果@var{exp}命名了一个对象，其名字解析规则必须

该钩子的缺省版本实现了ELF的名字解析规则，
其具有一个比目前支持的其它目标文件格式较松散的全局名字绑定模型。
@end deftypefn

@deftypevar {Target Hook} bool TARGET_HAVE_TLS
如果target支持thread-local storage，则包含值为真。缺省值为假。
@end deftypevar


@node PIC
@section 位置独立代码
@cindex position independent code
@cindex PIC

这一节描述了帮助实现位置独立代码生成的宏。
简单的定义这些宏并不足以生成有效的PIC；
你必须还要增加对宏@code{GO_IF_LEGITIMATE_ADDRESS}和
@code{PRINT_OPERAND_ADDRESS}的支持，还有@code{LEGITIMIZE_ADDRESS}。
你必须修改@samp{movsi}的定义，
当源操作数包含一个符号地址时来做一些适当的处理。
还可能需要修改switch语句的处理，使得它们使用相对地址。

@c i rearranged the order of the macros above to try to force one of
@c them to the next line, to eliminate an overfull hbox. --mew 10feb93

@defmac PIC_OFFSET_TABLE_REGNUM
用于寻址内存中静态数据地址表的寄存器的编号。一些情况下，
该寄存器由处理器的“应用二进制接口”（ABI）定义。当该宏被定义时，
会为该寄存器生成一次 RTL，使用栈指针和帧指针寄存器。如果该宏没有被定义，
则需要机器相关文件来分配这样的寄存器（如果需要的话）。
注意该寄存器在使用时（即当@code{flag_pic}为真时）必须为固定的。
@end defmac

@defmac PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
定义该宏，如果由@code{PIC_OFFSET_TABLE_REGNUM}定义的寄存器被调用破坏。
如果@code{PIC_OFFSET_TABLE_REGNUM}没有被定义，则不要定义该宏。
@end defmac

@defmac LEGITIMATE_PIC_OPERAND_P (@var{x})
一个C表达式，如果当生成位置独立代码时，
@var{x}为target机器上的合法的立即数操作数，则为非零。
你可以假设@var{x}满足@code{CONSTANT_P}，所以不需要进行检查。
你还可以假设@var{flag_pic}为真，所以也不需要进行检查。
如果当生成位置独立代码时，
所有的常量（包括@code{SYMBOL_REF}）都可以为立即操作数，则不需要定义该宏。
@end defmac

@node 汇编格式
@section 定义汇编语言输出

这一节描述的宏，主要用于描述如何使用汇编语言书写指令，而不是指令本身。

@menu
* 文件框架::                   汇编文件的结构化信息  
* 数据输出::                   常量（数目，字符串，地址）的输出
* 未初始化的数据::             未初始化变量的输出
* 标号输出::                   标号的输出和生成
* 初始化::                     初始化程序和终止程序的通用原则
* 用于初始化的宏::             控制处理初始化程序和终止程序的特定宏
* 指令输出::                   实际指令的输出
* 派遣表::                     跳转表的输出
* 异常区域输出::               异常区域代码的输出
* 对齐输出::                   用于对齐和跳过数据的伪操作
@end menu

@node 文件框架
@subsection 汇编文件的总体框架
@cindex assembler format
@cindex output of assembler code

@c prevent bad page break with this line
这章描述了汇编文件的总体框架。

@deftypefn {Target Hook} void TARGET_ASM_FILE_START ()
@findex default_file_start
将汇编器期望在文件起始处发现的任何文本输出到@code{asm_out_file}。
缺省行为由两个标志控制，将在下面介绍。除非你target的汇编器十分不常见，
如果你覆盖了缺省，则应该在你的target钩子上的某处调用@code{default_file_start}。
这将让其它target文件依赖于这些变量。
@end deftypefn

@deftypevr {Target Hook} bool TARGET_ASM_FILE_START_APP_OFF
如果该标记为真，则宏@code{ASM_APP_OFF}的文本将作为汇编文本的第一行被打印，
除非正在使用@option{-fverbose-asm}。（如果那个宏被定义为空字符串，
则该变量将不起作用。）对于@code{ASM_APP_OFF}的通常定义，
其效果是告知GNU汇编器不需要费功夫从输入中去除掉注释或额外的空格。
这将使得运行更快些。

缺省为假。不要将其设为真，除非你已经核实你的port不会产生任何额外的空格或者注释，
这将使得GAS在NO_APP模式下产生错误。
@end deftypevr

@deftypevr {Target Hook} bool TARGET_ASM_FILE_START_FILE_DIRECTIVE
如果该标记为真，对于主源文件，@code{output_file_directive}将被调用，
就在打印了@code{ASM_APP_OFF}之后（如果启用了该功能）。
大多数ELF汇编器期望做这件事。缺省为假。
@end deftypevr

@deftypefn {Target Hook} void TARGET_ASM_FILE_END ()
将汇编器期望在文件结尾发现的任何文本输出到中。缺省为什么也不输出。
@end deftypefn

@deftypefun void file_end_indicate_exec_stack ()
一些系统使用通用的约定，用特定的@samp{.note.GNU-stack} section，
来指示一个依赖栈的目标文件是否被执行。如果你的系统使用了该约定，
你应该将@code{TARGET_ASM_FILE_END}定义为该函数。
如果你需要在钩子中做其它事情，则要在你的钩子函数中调用该函数。
@end deftypefun

@defmac ASM_COMMENT_START
一个C字符串常量，描述了如何在target汇编语言中起始一条注释。
编译器假设注释将结束于行尾。
@end defmac

@defmac ASM_APP_ON
一个C字符串常量，将在每个@code{asm}语句或者一组连续的@code{asm}语句之前被输出。
通常为@code{"#APP"}，其为一条注释，对于多数汇编器不起作用，
但可以告诉GNU汇编器必须对随后的行检查所有的有效汇编结构。
@end defmac

@defmac ASM_APP_OFF
一个C字符串常量，将在每个@code{asm}语句或者一组连续的@code{asm}语句之前被输出。
通常为@code{"#NO_APP"}，告诉GNU汇编器继续进行省时的假设，
认为通常的编译器输出是有效的。
@end defmac

@defmac ASM_OUTPUT_SOURCE_FILENAME (@var{stream}, @var{name})
一条C语句，输出COFF信息或者DWARF调试信息，
用来指示文件名@var{name}为当前的对于标准输入输出流@var{stream}的源文件。

该宏不需要被定义，如果输出的标准形式适用于正在使用的文件格式。
@end defmac

@defmac OUTPUT_QUOTED_STRING (@var{stream}, @var{string})
一条C语句，将字符串@var{string}输出到stdio流@var{stream}中。
如果你不在你的配置文件中调用函数@code{output_quoted_string}，
则GCC将只调用它来输出文件名到汇编源文件中。
所以你可以使用它来规范使用该宏的文件名的格式。
@end defmac

@defmac ASM_OUTPUT_IDENT (@var{stream}, @var{string})
一条C语句，用来输出一些东西到汇编文件中，
以处理包含文本@var{string}的@samp{#ident}伪指令。如果没有定义该宏，
对于@samp{#ident}伪指令，将不输出任何东西。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_NAMED_SECTION (const char *@var{name}, unsigned int @var{flags}, unsigned int @var{align})
输出汇编伪指令来切换section名字。section应该具有@var{flags}指定的属性，
其为@file{output.h}中定义的@code{SECTION_*}标记的位掩码。如果@var{align}非零，
则其包含了用于section的对齐字节数，否则将使用target缺省的。
只有那些必须在section伪指令里指定对齐的target才需要关注@var{align}
 — 我们仍然使用@code{ASM_OUTPUT_ALIGN}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_HAVE_NAMED_SECTIONS
该标记为真，如果target支持@code{TARGET_ASM_NAMED_SECTION}。
@end deftypefn

@anchor{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}
@deftypefn {Target Hook} bool TARGET_HAVE_SWITCHABLE_BSS_SECTIONS
该标记为真，如果我们能够通过切换到BSS section来创建初始化为0的数据，
并且使用@code{ASM_OUTPUT_SKIP}来分配空间。这在大多数ELF target上为真。
@end deftypefn

@deftypefn {Target Hook} {unsigned int} TARGET_SECTION_TYPE_FLAGS (tree @var{decl}, const char *@var{name}, int @var{reloc})
根据变量或函数decl，section名name，和声明的初始化是否可以包含运行时重定位，
来选择供@code{TARGET_ASM_NAMED_SECTION}使用的section属性集。
@var{decl}可以为null，这种情况下，将假设为可读写数据。

该函数的缺省版本用来处理选择代码和数据，只读数据和可读写数据，
以及@code{flag_pic}。
你应该只有在你的target具有通过@code{__attribute__}设置的特定标记时，
才需要覆盖该函数。
@end deftypefn

@deftypefn {Target Hook} {int} TARGET_ASM_RECORD_GCC_SWITCHES (print_switch_type @var{type}, const char * @var{text})
使得target能够记录传给编译器的gcc命令行开关，和打开的选项。
参数@var{type}指定了要记录的内容。其可以为下面的值：

@table @gcctabopt
@item SWITCH_TYPE_PASSED
@var{text}为用户设置的命令行开关。 

@item SWITCH_TYPE_ENABLED
@var{text}为开启的选项。这可能为命令行开关的直接结果，或者是因为其被缺省打开，
或者因为其被不同的命令行开关的副作用打开。例如，
@option{-O2}开关打开了各种不同的独立的优化过程。 

@item SWITCH_TYPE_DESCRIPTIVE
@var{text}或者为NULL，或者为一些应该被忽略的描述文本。如果@var{text}text为NULL，
则其被用来警告target钩子记录开始或者结束。第一次，
@var{type}为SWITCH_TYPE_DESCRIPTIVE并且@var{text}为NULL，这是警告记录开始了，
第二次，是警告结束了。该特征可以允许target钩子来做任何需要的准备，
在其开始记录开关的时候，并执行一些比较的整理，在其完成记录开关之后。

@item SWITCH_TYPE_LINE_START
该选项可以被该target钩子忽略掉。 

@item  SWITCH_TYPE_LINE_END
该选项可以被该target钩子忽略掉。 
@end table

钩子的返回值必须为0。其它返回值可能在将来被支持。

缺省下，该钩子被设为NULL，但是对于基于ELF的target，有一个实现例子。
叫做@var{elf_record_gcc_switches}，其记录了开关，
并作为ASCII文本放在汇编输出文件中一个新的，可以字符串合并的section。
新section的名字由target钩子@code{TARGET_ASM_RECORD_GCC_SWITCHES_SECTION}提供。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_ASM_RECORD_GCC_SWITCHES_SECTION
这是@code{TARGET_ASM_RECORD_GCC_SWITCHES} target钩子的ELF实现的例子所创建的section名字。
@end deftypefn

@need 2000
@node 数据输出
@subsection 数据的输出


@deftypevr {Target Hook} {const char *} TARGET_ASM_BYTE_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_HI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_SI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_DI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_TI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_HI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_SI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_DI_OP
@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_TI_OP
这些钩子指定了用于创建特定类型的整数对象的汇编伪指令。
@code{TARGET_ASM_BYTE_OP}伪指令创建一个字节大小的对象，
@code{TARGET_ASM_ALIGNED_HI_OP}创建一个两个字节对齐的对象，等等。
这些钩子都可以为@code{NULL}，这表示没有合适的伪指令。

编译器将在一个新行中的起始处打印这些字符串，随后紧跟对象的初始化值。
大多数情况下，字符串应该包含一个tab，一个伪操作符，然后是另一个tab。
@end deftypevr

@deftypefn {Target Hook} bool TARGET_ASM_INTEGER (rtx @var{x}, unsigned int @var{size}, int @var{aligned_p})
函数@code{assemble_integer}使用该钩子来输出一个整数对象。@var{x}为对象的值，
@var{size}为它的以字节为单位的大小，@var{aligned_p}指示其是否为对齐的。
函数应该返回真，如果它能够输出对象。如果返回假，
则@code{assemble_integer}将尝试把对象分割为更小的部分。

该钩子的缺省实现将使用@code{TARGET_ASM_BYTE_OP}字符串家族，
当相应字符串为@code{NULL}时返回假。
@end deftypefn

@defmac OUTPUT_ADDR_CONST_EXTRA (@var{stream}, @var{x}, @var{fail})
一条C语句用来识别@code{output_addr_const}不能处理的@var{rtx}模式，
并输出汇编代码到模式@var{x}对应的@var{stream}中。
这可以用来允许在常量中出现机器相关的@code{UNSPEC}。

如果@code{OUTPUT_ADDR_CONST_EXTRA}没有能够识别出指令模式，
其必须@code{goto fail}， 这样就会打印出一个标准错误消息。
如果其本身打印了一个错误消息，
例如通过调用@code{output_operand_lossage}，其可以正常的结束。
@end defmac

@defmac ASM_OUTPUT_ASCII (@var{stream}, @var{ptr}, @var{len})
一条C语句，用来输出到stdio流@var{stream}中一条汇编指令，
以组合一个在@var{ptr}处包含@var{len}个字节的字符串常量。
@var{ptr}将为一个@code{char *}类型的C表达式，
@var{len}为一个@code{int}型的C表达式。

如果汇编器具有一个@code{.ascii}伪指令，正如在Berkeley Unix汇编器上的，
则不要定义宏@code{ASM_OUTPUT_ASCII}。
@end defmac

@defmac ASM_OUTPUT_FDESC (@var{stream}, @var{decl}, @var{n})
一条C语句，用来输出@var{decl}的函数描述符的字@var{n}。
这必须在定义@code{TARGET_VTABLE_USES_DESCRIPTORS}时被定义，否则将不起作用。
@end defmac

@defmac CONSTANT_POOL_BEFORE_FUNCTION
你可以定义该宏为一个C表达式。你应该定义表达式具有非零值，
如果GCC应该在输出函数的代码前，输出常量池，或者定义为0，
如果GCC应该在函数后输出常量池。如果你不定义该宏，则通常情况下，
GCC将在函数前输出常量池。
@end defmac

@defmac ASM_OUTPUT_POOL_PROLOGUE (@var{file}, @var{funname}, @var{fundecl}, @var{size})
一条C语句，用来输出汇编命令，以定义函数的常量池的起始。
@var{funname}为一个字符串，给定了函数的名字。如果需要函数的返回类型，
则可以通过@var{fundecl}来获得。
@var{size}为在该调用之后要立即写入的常量池的大小，以字节为单位。

通常情况下，如果不需要常量池前缀，该宏不需要被定义。
@end defmac

@defmac ASM_OUTPUT_SPECIAL_POOL_ENTRY (@var{file}, @var{x}, @var{mode}, @var{align}, @var{labelno}, @var{jumpto})
一条C语句（带有或者不带有分号），用来输出一个常量在常量池中，
如果其需要特殊的处理。（该宏对于可以正常输出的RTL表达式不需要做任何事情。）

参数@var{file}为将汇编代码输出到的标准I/O流。@var{x}为要输出的常量的RTL表达式，
@var{mode}为机器模式（用于@var{x}为@samp{const_int}时）。
@var{align}为值@var{x}所需要的对齐；你应该输出一个汇编伪指令来执行该对齐。

参数@var{labelno}为该池中实体的地址的内部标号的编号。
该宏的定义负责在合适的地方输出标号的定义。这里有一个实现的例子：

@smallexample
@code{(*targetm.asm_out.internal_label)} (@var{file}, "LC", @var{labelno});
@end smallexample

当你专门输出一个池中实体时，你应该结束于一个@code{goto}，
以跳转到标号@var{jumpto}。这将阻止相同的池中实体通过通常的方式被再一次输出。

如果不做任何事情，则不要定义该宏。
@end defmac

@defmac ASM_OUTPUT_POOL_EPILOGUE (@var{file} @var{funname} @var{fundecl} @var{size})
一条C语句，用来输出汇编命令到函数常量池的结尾。@var{funname}为一个字符串，
给出了函数的名字。如果需要函数的返回类型，可以通过@var{fundecl}来获得。
@var{size}为GCC在该调用之前立即写入的常量池的大小，以字节为单位。

通常情况下，如果不需要常量池结束语，则不需要定义该宏。
@end defmac

@defmac IS_ASM_LOGICAL_LINE_SEPARATOR (@var{C}, @var{STR})
定义该宏为一个C表达式，其为非零，如果@var{C}被汇编器用作逻辑行分隔符。
@var{STR}指向在字符串中@var{C}被发现的位置；
这可以用于行分隔符使用多个字符的时候。

如果你不定义该宏，则缺省的为只将字符@samp{;}作为逻辑行的分隔符。
@end defmac

@deftypevr {Target Hook} {const char *} TARGET_ASM_OPEN_PAREN
@deftypevrx {Target Hook} {const char *} TARGET_ASM_CLOSE_PAREN
这些target钩子为C字符串常量，描述了算术表达式组合的汇编语法。
如果没有被覆盖，它们缺省为通常的括号，这对大多数汇编器都是正确的。
@end deftypevr

这些宏由@file{real.h}提供，用于写@code{ASM_OUTPUT_DOUBLE}等的定义：

@defmac REAL_VALUE_TO_TARGET_SINGLE (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DOUBLE (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_LONG_DOUBLE (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DECIMAL32 (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DECIMAL64 (@var{x}, @var{l})
@defmacx REAL_VALUE_TO_TARGET_DECIMAL128 (@var{x}, @var{l})
这些将类型为@code{REAL_VALUE_TYPE}的@var{x}，转换为target的浮点表示，
并将其存储在变量@var{l}中。
对于@code{REAL_VALUE_TO_TARGET_SINGLE}和@code{REAL_VALUE_TO_TARGET_DECIMAL32}，
该变量应该为一个简单的@code{long int}。对于其它的，
其应该为一个@code{long int}的数组。
该数组的元素个数由所需要的target浮点数据类型的大小决定：
每个@code{long int}数组元素有32位。每个数组元素存放32位的结果，
即使@code{long int}在host机器上比32位宽。

数组元素值被设计成，
可以使用@code{fprintf}按照在target机器内存中的顺序来打印它们。
@end defmac

@node 未初始化的数据
@subsection 未初始化变量的输出

这一节的每个宏都是用于输出单个未初始化变量的整个工作中。

@defmac ASM_OUTPUT_COMMON (@var{stream}, @var{name}, @var{size}, @var{rounded})
一条C语句（没有分号），用来将大小为@var{size}，
名字为@var{name}的通用标号的汇编定义，输出到stdio流@var{stream}中。
变量@var{rounded}为调用者想要对齐而舍入的大小。

使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在这之前和之后，输出额外的定义name的汇编语法，以及换行。

该宏控制如何输出未初始化的通用全局变量的汇编定义。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_COMMON (@var{stream}, @var{name}, @var{size}, @var{alignment})
类似@code{ASM_OUTPUT_COMMON}，除了其接受一个alignment，作为独立，显式的参数。
如果你定义了该宏，其被用于替换@code{ASM_OUTPUT_COMMON}，
使得你在处理变量对齐方面变得更加灵活。aligment被指定为位的数目。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_DECL_COMMON (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
类似@code{ASM_OUTPUT_ALIGNED_COMMON}，除了要被输出的变量的@var{decl}，
如果存在的话，或者为@code{NULL_TREE}如果没有相应的变量。如果你定义了该宏，
GCC将替换@code{ASM_OUTPUT_COMMON}和@code{ASM_OUTPUT_ALIGNED_COMMON}。
当你需要看到变量的decl，以便选择如何输出时，可以定义该宏。
@end defmac

@defmac ASM_OUTPUT_BSS (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{rounded})
一条C语句（没有分号），用来将名字为@var{name}，
大小为@var{size}个字节的未初始化的全局@var{decl}的汇编定义输出到stdio流
@var{stream}中。变量@var{rounded}为调用者想要对齐而舍入的大小。

当定义该宏时，可以尝试使用@file{varasm.c}中定义的@code{asm_output_bss}。
如果不行，
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出额外的定义name的汇编语法，以及换行。

有两种方式来处理全局BSS。一种是定义该宏或者它的对齐副本，
@code{ASM_OUTPUT_ALIGNED_BSS}。
另一种是让@code{TARGET_ASM_SELECT_SECTION}返回一个可切换的BSS section
（参见 @ref{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}）。你不需要两者都做。

一些语言不具有@code{common}数据，并且要求全局BSS为non-common的，
以便高效的处理未初始化全局变量。C++就是这样的例子。然而，
如果target不支持全局BSS，则前端可以选择生成全局common，
以便在目标文件中节省空间。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_BSS (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
类似@code{ASM_OUTPUT_BSS}，除了其接受需要的aligment作为单独，显式的参数。
如果你定义了该宏，其被用于替换@code{ASM_OUTPUT_BSS}，
这使得你在处理变量所需的对齐方面更加灵活。aligment被指定为位数。

当定义该宏时，
尝试使用在文件@file{varasm.c}中定义的函数@code{asm_output_aligned_bss}。
@file{varasm.c} when defining this macro.
@end defmac

@defmac ASM_OUTPUT_LOCAL (@var{stream}, @var{name}, @var{size}, @var{rounded})
一条C语句（没有分号），用来将名字为@var{name}，
大小为@var{size}个字节的local-common标号的汇编定义输出到stdio流@var{stream}中。
变量@var{rounded}为调用者想要对齐而舍入的大小。

使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出额外的定义name的汇编语法，以及换行。

该宏控制如何输出未初始化的静态变量的汇编定义。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_LOCAL (@var{stream}, @var{name}, @var{size}, @var{alignment})
类似@code{ASM_OUTPUT_LOCAL}，除了其接受需要的aligment作为单独，显式的参数。
如果你定义了该宏，其被用于替换@code{ASM_OUTPUT_LOCAL}，
这使得你在处理变量所需的对齐方面更加灵活。aligment被指定为位数。
@end defmac

@defmac ASM_OUTPUT_ALIGNED_DECL_LOCAL (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
类似@code{ASM_OUTPUT_ALIGNED_DECL}，除了要被输出的变量的@var{decl}，
如果存在的话，或者为@code{NULL_TREE}如果没有相应的变量。如果你定义了该宏，
GCC将替换@code{ASM_OUTPUT_DECL}和@code{ASM_OUTPUT_ALIGNED_DECL}。
当你需要看到变量的decl，以便选择如何输出时，可以定义该宏。
@end defmac

@node 标号输出
@subsection 标号的生成和输出

@c prevent bad page break with this line
这节是关于标号输出的。

@findex assemble_name
@defmac ASM_OUTPUT_LABEL (@var{stream}, @var{name})
一条C语句（没有分号），
用来将名字为@var{name}的标号的汇编定义输出到stdio流@var{stream}中。
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出定义name的额外的汇编语法，以及换行。
该宏的缺省定义被提供，其对于多数系统都是正确的。
@end defmac

@findex assemble_name_raw
@defmac ASM_OUTPUT_INTERNAL_LABEL (@var{stream}, @var{name})
等同于@code{ASM_OUTPUT_LABEL}，除了@var{name}为已知的，引用了编译器生成的标号。
缺省定义使用@code{assemble_name_raw}，其类似于@code{assemble_name}，
只不过更加高效。
@end defmac

@defmac SIZE_ASM_OP
一个C字符串，包含了适当的汇编伪指令，用于指定符号的大小，不需要任何参数。
在使用ELF的系统上，缺省为（在@file{config/elfos.h}中）@samp{"\t.size\t"}；
在其它系统上，缺省为不定义该宏。

只有在你的系统上可以正确的使用@code{ASM_OUTPUT_SIZE_DIRECTIVE}和
@code{ASM_OUTPUT_MEASURED_SIZE}的缺省定义时，才定义该宏。
如果对于那些宏，你需要自己特定的定义，或者如果你根本不需要显式的符号大小，
则不要定义该宏。
@end defmac

@defmac ASM_OUTPUT_SIZE_DIRECTIVE (@var{stream}, @var{name}, @var{size})
一条C语句（没有分号），用来将一条伪指令输出到stdio流@var{stream}中，
以告诉汇编器符号@var{name}的大小为@var{size}。@var{size}为@code{HOST_WIDE_INT}。
如果你定义了@code{SIZE_ASM_OP}，则该宏的缺省定义会被提供。
@end defmac

@defmac ASM_OUTPUT_MEASURED_SIZE (@var{stream}, @var{name})
一条C语句（没有分号），用来将一条伪指令输出到stdio流@var{stream}中，
以告诉汇编器通过从当前地址减去符号@var{name}的地址，来计算符号的大小。

如果你定义了@code{SIZE_ASM_OP}，则该宏的缺省定义会被提供。
缺省定义假设汇编器可以识别特殊的@samp{.}符号，作为引用当前地址，
并能够计算该处和其它符号的差。如果你的汇编器不识别@samp{.}，或者不能计算差，
你需要重定义@code{ASM_OUTPUT_MEASURED_SIZE}来使用其它技术。
@end defmac

@defmac TYPE_ASM_OP
一个C字符串，包含了适当的汇编伪指令，用于指定符号的类型，不需要任何参数。
在使用ELF的系统上，缺省为（在@file{config/elfos.h}中）@samp{"\t.type\t"}；
在其它系统上，缺省为不定义该宏。

只有在你的系统上可以正确的使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}的缺省定义时，
才定义该宏。如果对于该宏，你需要自己特定的定义，
或者如果你根本不需要显式的符号类型，则不要定义该宏。
@end defmac

@defmac TYPE_OPERAND_FMT
一个C字符串，
指定了@code{TYPE_ASM_OP}的第二个操作数的格式（使用@code{printf}语法）。
在使用ELF的系统上，缺省为（在@file{config/elfos.h}中）@samp{"@@%s"}；
在其它系统上，缺省为不定义该宏。

只有在你的系统上可以正确的使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}的缺省定义时，
才定义该宏。如果对于该宏，你需要自己特定的定义，
或者如果你根本不需要显式的符号类型，则不要定义该宏。
@end defmac

@defmac ASM_OUTPUT_TYPE_DIRECTIVE (@var{stream}, @var{type})
一条C语句（没有分号），用以将一条伪指令输出到stdio流@var{stream}中，
以告诉汇编器符号@var{name}的类型为@var{type}。@var{type}是一个C字符串；
目前该字符串总是@samp{"function"}或者@samp{"object"}，但你不要依赖于此。

如果你定义了@code{TYPE_ASM_OP}和@code{TYPE_OPERAND_FMT}，
则该宏的缺省定义会被提供。
@end defmac

@defmac ASM_DECLARE_FUNCTION_NAME (@var{stream}, @var{name}, @var{decl})
一条C语句（没有分号），用以将任何声明被定义的函数名字@var{name}所需要的文本，
输出到stdio流@var{stream}中。
该宏负责输出标号定义（或者使用@code{ASM_OUTPUT_LABEL}）。
参数@var{decl}为表示函数的@code{FUNCTION_DECL}树结点。

如果该宏没有被定义，
则函数名被作为标号按照通常的方式来定义（使用@code{ASM_OUTPUT_LABEL}）。

你可能希望在定义该宏时使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}。
@end defmac

@defmac ASM_DECLARE_FUNCTION_SIZE (@var{stream}, @var{name}, @var{decl})
一条C语句（没有分号），用以将任何声明被定义的函数的大小所需要的文本，
输出到stdio流@var{stream}中。参数@var{name}为函数的名字。
参数@var{decl}为表示函数的@code{FUNCTION_DECL}树结点。

如果该宏没有被定义，则函数大小没有被定义。

你可能希望在定义该宏时使用@code{ASM_OUTPUT_MEASURED_SIZE}。
@end defmac

@defmac ASM_DECLARE_OBJECT_NAME (@var{stream}, @var{name}, @var{decl})
一条C语句（没有分号），
用以将任何声明被定义的初始化变量名字@var{name}所需要的文本，
输出到stdio流@var{stream}中。
该宏必须输出标号定义（可能使用@code{ASM_OUTPUT_LABEL}）。
参数@var{decl}为表示变量的@code{VAR_DECL}树结点。

如果该宏没有被定义，
则变量名被作为标号按照通常的方式来定义（使用@code{ASM_OUTPUT_LABEL}）。

你可能希望在定义该宏时使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}和/或@code{ASM_OUTPUT_SIZE_DIRECTIVE}。
@end defmac

@defmac ASM_DECLARE_CONSTANT_NAME (@var{stream}, @var{name}, @var{exp}, @var{size})
一条C语句（没有分号），用以将任何声明被定义的常量名字@var{name}所需要的文本，
输出到stdio流@var{stream}中。
该宏负责输出标号定义（可能使用@code{ASM_OUTPUT_LABEL}）。
参数@var{exp}为常量的值，@var{size}为常量的大小，以字节为单位。
@var{name}为内部标号。

如果该宏没有被定义，
则@var{name}被作为标号按照通常的方式来定义（使用@code{ASM_OUTPUT_LABEL}）。

你可能希望在定义该宏时使用@code{ASM_OUTPUT_TYPE_DIRECTIVE}。
@end defmac

@defmac ASM_DECLARE_REGISTER_GLOBAL (@var{stream}, @var{decl}, @var{regno}, @var{name})
一条C语句（没有分号），用以将任何为具有名字@var{name}的全局变量声明一个寄存器@var{regno}所需要的文本，输出到stdio流@var{stream}中。

如果没有定义该宏，则相当于定义其什么都不做。
@end defmac

@defmac ASM_FINISH_DECLARE_OBJECT (@var{stream}, @var{decl}, @var{toplevel}, @var{atend})
一条C语句（没有分号），用于在编译器完全处理了初始化者之后，
来完成声明一个变量名，这样当数组的大小由初始化者控制的时候，
就有机会来确定数组的大小。这用于需要声明对象的大小的系统上。

如果没有定义该宏，则相当于定义其什么都不做。

你可能希望在定义该宏时使用@code{ASM_OUTPUT_SIZE_DIRECTIVE}和/或@code{ASM_OUTPUT_MEASURED_SIZE}。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_GLOBALIZE_LABEL (FILE *@var{stream}, const char *@var{name})
该target钩子为一个函数，用于将一些命令输出到stdio流@var{stream}中，
从而使得标号@var{name}为全局的；也就是，可以从其它文件中引用。

缺省实现依赖于@code{GLOBAL_ASM_OP}的适当定义。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_GLOBALIZE_DECL_NAME (FILE *@var{stream}, tree @var{decl})
该target钩子为一个函数，用于将一些命令输出到stdio流@var{stream}中，
从而使得@var{decl}相关联的名字为全局的；也就是，可以从其它文件中引用。

缺省实现使用TARGET_ASM_GLOBALIZE_LABEL target钩子。
@end deftypefn

@defmac ASM_WEAKEN_LABEL (@var{stream}, @var{name})
一条C语句（没有分号），用于将一些命令输出到stdio流@var{stream}中，
从而使得标号@var{name}为弱的；也就是，可以从其它文件中引用，
但只有在没有其它定义的时候。
使用表达式@code{assemble_name (@var{stream}, @var{name})}来输出name本身；
在此之前和之后，输出使得name为弱的额外的汇编语法，以及换行。

如果没有定义该宏或者@code{ASM_WEAKEN_DECL}，
GCC将不支持弱符号并且你不要定义宏@code{SUPPORTS_WEAK}。
@end defmac

@defmac ASM_WEAKEN_DECL (@var{stream}, @var{decl}, @var{name}, @var{value})
组合（并替换）了函数@code{ASM_WEAKEN_LABEL}和@code{ASM_OUTPUT_WEAK_ALIAS}，
允许访问相关的函数或变量decl。如果@var{value}不为@code{NULL}，
该C语句应该将定义弱符号@var{name}具有值@var{value}的汇编代码，
输出到stdio流@var{stream}中。如果@var{value}为@code{NULL}，
其应该输出命令来使得@var{name}为弱的。
@end defmac

@defmac ASM_OUTPUT_WEAKREF (@var{stream}, @var{decl}, @var{name}, @var{value})
输出一条伪指令，使得@var{name}被用来使用弱符号语义引用符号@var{value}。
@code{decl}为@code{name}的声明。
@end defmac

@defmac SUPPORTS_WEAK
一个C表达式，如果target支持弱符号，则求值为真。

如果你没有定义该宏，@file{defaults.h}会提供一个缺省的定义。
如果@code{ASM_WEAKEN_LABEL}或者@code{ASM_WEAKEN_DECL}被定义，
则缺省定义为@samp{1}；否则为@samp{0}。如果你想使用编译器标记，
例如@option{-melf}，来控制弱符号的支持，则定义该宏。
@end defmac

@defmac MAKE_DECL_ONE_ONLY (@var{decl})
一条C语句（没有分号），用来标记@var{decl}作为public符号生成，
这样在多个转换单元中额外的副本将被连接器丢弃。
如果你的目标文件格式提供了这样的支持，
例如在Microsoft Windows PE/COFF格式中的@samp{COMDAT} section标记，
并且这种支持需要对@var{decl}进行改动，例如将其放到独立的section中，则定义该宏。
@end defmac

@defmac SUPPORTS_ONE_ONLY
一个C表达式，如果target支持one-only语义，则其求值为真。

如果你没有定义该宏，@file{varasm.c}会提供一个缺省的定义。
如果@code{MAKE_DECL_ONE_ONLY}被定义，则缺省定义为@samp{1}；否则为@samp{0}。
如果你想使用编译器标记来控制one-only符号的支持，
或者如果设置@code{DECL_ONE_ONLY}标记就足以标记声明被作为one-only生成时，
定义该宏。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_ASSEMBLE_VISIBILITY (tree @var{decl}, const char *@var{visibility})
该target钩子为一个函数，用来将一些命令输出到@var{asm_out_file}，
其将使得与@var{decl}相关的符号具有通过@var{visibility}指定的隐藏，
保护或者内部可见的属性。
@end deftypefn

@defmac TARGET_WEAK_NOT_IN_ARCHIVE_TOC
一个C表达式，如果target的连接器期望弱符号不出现在静态归档的目录表中，
则其求值为真。缺省为@code{0}。

将弱符号置于归档的目录表之外，意味着如果符号将只在一个转换单元中有一个定义，
并且有从其它转换单元中进行未定义的引用，则该符号将不为弱的。定义该宏为非零，
将使得这样通常为弱的符号成为非弱的。

C++ ABI要求该宏为0。当target不能完全遵守C++ ABI，
并且连接器要求弱符号在静态归档的目录表外面时，定义该宏。
@end defmac

@defmac ASM_OUTPUT_EXTERNAL (@var{stream}, @var{decl}, @var{name})
一条C语句（没有分号），
用于将声明在该编译中被引用但没有被定义的外部符号名字@var{name}，
所需要的任何文本输出到stdio流@var{stream}中。@var{decl}的值为声明的树结点。

如果不需要输出任何东西，则不需要定义该宏。
GNU汇编器和大多数Unix汇编器不需要做任何事情。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_EXTERNAL_LIBCALL (rtx @var{symref})
该target钩子是一个函数，用于将一条汇编伪指令输出到@var{asm_out_file}中，
用以声明一个库函数名字为外部的。库函数的名字由@var{symref}给出，
@var{symref}为一个@code{symbol_ref}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_MARK_DECL_PRESERVED (tree @var{decl})
该target钩子为一个函数，用于将一条汇编伪指令输出到@var{asm_out_file}中，
用以注释使用的符号。Darwin target使用.no_dead_code_strip伪指令。
@end deftypefn

@defmac ASM_OUTPUT_LABELREF (@var{stream}, @var{name})
一条C语句（没有分号），
用于将名为@var{name}的标号的引用的汇编语法输出到stdio流@var{stream}中。
这应该在name前加上@samp{_}。该宏用于@code{assemble_name}。
@end defmac

@defmac ASM_OUTPUT_SYMBOL_REF (@var{stream}, @var{sym})
一条C语句（没有分号），用于输出对@code{SYMBOL_REF} @var{sym}的引用。
如果没有定义，@code{assemble_name}将被用来输出符号的名字。
该宏可以用于修改符号被引用的方式，根据@code{TARGET_ENCODE_SECTION_INFO}的信息。
@end defmac

@defmac ASM_OUTPUT_LABEL_REF (@var{stream}, @var{buf})
一条C语句（没有分号），用于输出对@code{ASM_GENERATE_INTERNAL_LABEL}的结果，
@var{buf}的引用。如果没有定义，@code{assemble_name}将被用来输出符号的名字。
该宏不被调用它的@code{output_asm_label}或者@code{%l}指示符使用；
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_INTERNAL_LABEL (FILE *@var{stream}, const char *@var{prefix}, unsigned long @var{labelno})
一个函数，将标号输出到stdio流@var{stream}中，
标号的名字由字符串@var{prefix}和编号@var{labelno}组成。

当然这些标号应该与用户级别函数和变量使用的标号不同。
否则，程序将具有与内部标号的命名冲突。

通常要求内部标号不包含在目标文件的符号表中。大多数汇编器具有命名约定，
来处理这些标号。在许多系统上，位于标号的起始处的字母@samp{L}，具有这样的效果。
你应该找到你的系统使用的约定，并遵守。

该函数的缺省版本利用@code{ASM_GENERATE_INTERNAL_LABEL}了。
@end deftypefn

@defmac ASM_OUTPUT_DEBUG_LABEL (@var{stream}, @var{prefix}, @var{num})
一条C语句，用来将调试信息标号输出到stdio流@var{stream}中，
标号的名字由字符串@var{prefix}和编号@var{num}组成。这对VLIW target很有用，
因为调试信息标号可能需要与分支目标标号进行不同的处理。在一些系统上，
分支目标标号必须在指令束的起始处，但是调试信息标号可以出现在指令束的中间。

如果该宏没有被定义，则会使用@code{(*targetm.asm_out.internal_label)}。
@end defmac

@defmac ASM_GENERATE_INTERNAL_LABEL (@var{string}, @var{prefix}, @var{num})
一条C语句，用于将标号存储到字符串@var{string}中，
标号的名字由字符串@var{prefix}和编号@var{num}组成。

如果字符串起始于@samp{*}，
则@code{assemble_name}将按照不改变剩余字符串的方式被输出。
这对于@code{ASM_GENERATE_INTERNAL_LABEL}非常方便。
如果字符串不起始于@samp{*}，则会使用@code{ASM_OUTPUT_LABELREF}来输出字符串，
并且可能会做改变。（当然，@code{ASM_OUTPUT_LABELREF}也是你的机器描述的一部分，
所以你知道它在你的机器上做了什么。）
@end defmac

@defmac ASM_FORMAT_PRIVATE_NAME (@var{outvar}, @var{name}, @var{number})
一个C表达式，给@var{outvar}（类型为@code{char *}*的变量）
赋值一个新分配的字符串，该字符串由字符串@var{name}和编号@var{number}组成，
并增加适当的标点符号。使用@code{alloca}为字符串获得空间。

字符串将被@code{ASM_OUTPUT_LABELREF}作为参数使用，
来产生一个名字为@var{name}的内部静态变量的汇编标号。
因此，字符串必须为有效的汇编代码。参数@var{number}在每次执行该宏时都不相同；
其使得在不同作用域下的内部静态变量的名字不会有冲突。

理想情况下，该字符串应该不是一个有效的C标识符，
以阻止任何与用户自己的符号的冲突。大多数汇编器运行点或者百分号在汇编符号中；
在名字和编号之间加入至少一个这样的字符便可以。

如果该宏没有被定义，一个缺省的定义将被提供，其在大多数系统上都是正确的。
@end defmac

@defmac ASM_OUTPUT_DEF (@var{stream}, @var{name}, @var{value})
一条C语句，用于将定义符号@var{name}具有值@var{value}的汇编代码输出到stdio流@var{stream}中。

@findex SET_ASM_OP
如果定义了@code{SET_ASM_OP}，一个缺省的定义将被提供，
其在大多数系统上都是正确的。
@end defmac

@defmac ASM_OUTPUT_DEF_FROM_DECLS (@var{stream}, @var{decl_of_name}, @var{decl_of_value})
一条C语句，用于将定义树结点为@var{decl_of_name}的符号，
具有树结点@var{decl_of_value}的值的汇编代码输出到stdio流@var{stream}中。
该宏将优先于`ASM_OUTPUT_DEF'被使用，如果其被定义，并且如果树结点有效。

@findex SET_ASM_OP
如果定义了@code{SET_ASM_OP}，一个缺省的定义将被提供，
其在大多数系统上都是正确的。
@end defmac

@defmac TARGET_DEFERRED_OUTPUT_DEFS (@var{decl_of_name}, @var{decl_of_value})
一条C语句，如果定义树结点为@var{decl_of_name}的符号具有树结点为
@var{decl_of_value}的值的汇编代码，应该在当前编译单元结尾处被生成，
则求值为真。缺省为不推迟定义的输出。
该宏影响`ASM_OUTPUT_DEF' 和 `ASM_OUTPUT_DEF_FROM_DECLS'的定义输出。
@end defmac

@defmac ASM_OUTPUT_WEAK_ALIAS (@var{stream}, @var{name}, @var{value})
一条C语句，用来将定义弱符号@var{name}具有值@var{value}的汇编代码输出
到stdio流@var{stream}中。如果@var{value}为@code{NULL}，
其定义@var{name}为未定义的符号。

如果target只支持弱别名时，定义该宏；否则尽量定义@code{ASM_OUTPUT_DEF}。
@end defmac

@defmac OBJC_GEN_METHOD_LABEL (@var{buf}, @var{is_inst}, @var{class_name}, @var{cat_name}, @var{sel_name})
定义该宏来覆盖缺省的用于Objective-C方法的汇编名。

缺省名为一个唯一的方法编号，跟随class的名字（例如@samp{_1_Foo}）。
对于在category中的方法，category也包含在汇编名中（例如@samp{_1_Foo_Bar}）。

这些名字在大多数系统上是安全的，但是使得调试变得困难，
因为方法selector不在名字中。因此一些特定的系统定义了其它计算名字的方式。

@var{buf}为@code{char *}类型的表达式，给出一个缓存来存储名字；
其长度等于@var{class_name}，@var{cat_name}和@var{sel_name}的和，
再加上额外的50个字符。

参数@var{is_inst}指定了方法是一个实例方法，还是一个类方法；
@var{class_name}为类的名字；@var{cat_name}为category的名字（或者为空，
如果方法不在category中）；@var{sel_name}为selector的名字。

在汇编器可以处理带引号的名字的系统上，你可以使用该宏来提供更加可读的名字。
@end defmac

@defmac ASM_DECLARE_CLASS_REFERENCE (@var{stream}, @var{name})
一条C语句（没有分号），用于将命令输出到stdio流@var{stream}中，
来声明标号@var{name}为Objective-C class引用。
这只在连接器具有对NeXT-style运行时的特殊支持的target上需要。
@end defmac

@defmac ASM_DECLARE_UNRESOLVED_REFERENCE (@var{stream}, @var{name})
一条C语句（没有分号），用于将命令输出到stdio流@var{stream}中，
来声明标号@var{name}为未解决的Objective-C class引用。
这只在连接器具有对NeXT-style运行时的特殊支持的target上需要。
@end defmac

@node 初始化
@subsection 如何处理初始化函数
@cindex initialization routines
@cindex termination routines
@cindex constructors, output of
@cindex destructors, output of

一些语言被编译后的代码中会包含构造者（也称为初始化例程）---当程序启动时，
用来初始化程序中的数据的函数。这些函数需要在程序开始前被调用---也就是说，
在调用@code{main}之前。

编译一些语言还会生成析构者（也成为终止例程），将在程序终止时被调用。

为了让初始化和终止函数工作，编译器必须在汇编代码中输出一些东西，
使得那些函数在适当的时候被调用。当你将编译器移植到一个新的系统时，
你需要指定如何做。

GCC目前支持两种主要的方式，来执行初始化和终止函数。
每种方式都有两个变体。大多数结构体对于这四个变体都是通用的。

@findex __CTOR_LIST__
@findex __DTOR_LIST__
连接器必须构建两个这些函数的链表---一个是初始化函数链表，
叫做@code{__CTOR_LIST__}，一个是终止函数，叫做@code{__DTOR_LIST__}。

每个列表总是起始于一个被忽略的函数指针（其可能为0，-1，
或者之后的函数指针的个数，这取决于具体环境）。
随后是一系列指向构造者（或析构者）的零个或多个函数指针，
然后是一个包含0的函数指针。

取决于操作系统和它的可执行文件格式，或者@file{crtstuff.c}，
或者@file{libgcc2.c}会在起始时间和退出时间遍历这些列表。
构造者按照列表相反的顺序被调用；析构者按照向前的顺序。

处理静态构造者的最好的方式，
只有在目标文件格式提供任意命名section的时候才可以工作。
这会在构造者列表旁边设置一个section，析构者列表旁边设置另一个，
通常称作@samp{.ctors}和@samp{.dtors}。
每个定义了初始化函数的目标文件，还在构造section中放入一个字，
以指向那个函数。
连接器将所有这些字累积放入到一个邻近的@samp{.ctors} section中。
终止函数按照类似的方式处理。

如果定义了TARGET_ASM_NAMED_SECTION，
则该方法将被@file{target-def.h}作为缺省方式选择。
不支持任意section，但是支持特定的构造者和析构者section的target，
可以定义@code{CTORS_SECTION_ASM_OP}和@code{DTORS_SECTION_ASM_OP}
来达到相同的效果。

当支持任意section时，有两个变体，
取决于如何调用@file{crtstuff.c}中的代码。
在支持@dfn{.init} section（其在程序起始时被执行）的系统上，
@file{crtstuff.c}的部分代码被编译到那个section中。
程序按照类似于下面的方式被@command{gcc}驱动连接：

@smallexample
ld -o @var{output_file} crti.o crtbegin.o @dots{} -lgcc crtend.o crtn.o
@end smallexample

函数（@code{__init}）的序言出现在@file{crti.o}的@code{.init} section中；
尾声出现在@file{crtn.o}中。同样的，函数@code{__fini}在@dfn{.fini} section中。
通常这些文件由操作系统或者GNU C库提供，但GCC也为一些target提供。

目标文件@file{crtbegin.o}和@file{crtend.o}是从@file{crtstuff.c}
中编译出来的（对于大多target）。它们包含了，在@code{.init}和@code{.fini} 
section中的代码片断，用于跳转到@code{.text} section中的例程中。
连接器会把section的所有部分放在一起，形成完整的@code{__init}函数，
其可以在起始处调用我们需要的例程。

要使用这个变体，你必须适当的定义@code{INIT_SECTION_ASM_OP}宏。

如果init section不可用，GCC在编译任何叫做@code{main}（或者更加确切的说，
任何被语言前端@code{expand_main_function}指定为程序入口点的函数）的函数时，
其会插入一个调用@code{__main}的程序，以作为在函数序言之后首先执行的代码。
@code{__main}函数在@file{libgcc2.c}中定义，并运行全局的构造者。

对于文件格式不支持任意section的，也有两个变体。对于最简单的变体，
必须使用GNU连接器（GNU @code{ld}）和'a.out'格式。在这种情况下，
@code{TARGET_ASM_CONSTRUCTOR}被定义，
用来生成一个@samp{N_SETT}类型的@code{.stabs}条目，
来引用名字@code{__CTOR_LIST__}，
并且其值为一个包含了初始化代码的void函数地址。
GNU连接器将其识别为一个要设定的值；该值会被累积，
并最终作为一个向量放在可执行程序中，
一个前导（被忽略的）数目和一个尾部的0元素。
@code{TARGET_ASM_DESTRUCTOR}按照类似的情况被处理。
由于init section不可用，所以使得编译@code{main}来调用@code{__main}，
以开始初始化。

最后一个变体既不使用任意section，也不使用GNU连接器。这适合于，
你想进行动态连接并使用GNU连接器不支持的文件格式的时候，例如 'ECOFF'。
在这种情况下，@code{TARGET_HAVE_CTORS_DTORS}为假，
初始化和终止函数简单的通过它们的名字来识别。这要求在连接过程中的额外程序，
叫做@command{collect2}。该程序作为GCC使用的连接器；
它通过运行普通的连接器来完成工作，但是还负责包含初始化和终止函数的向量。
这些函数通过@code{__main}调用。要使用这种方式，
必须在@file{config.gcc}中定义@code{use_collect2}。

@ifinfo
The following section describes the specific macros that control and
customize the handling of initialization and termination functions.
@end ifinfo

@node 用于初始化的宏
@subsection 控制初始化例程的宏

这里是控制编译器如何处理初始化和终止函数的宏：

@defmac INIT_SECTION_ASM_OP
如果定义，为一个C字符串常量，包括空格，
用于将随后的数据作为初始化代码的汇编操作。如果没有定义，
GCC将假设这样的section不存在。当你使用用于初始化和终止函数的特定的section时，
该宏还控制@file{crtstuff.c}和@file{libgcc2.c}如何运行初始化函数。
@end defmac

@defmac HAS_INIT_SECTION
如果定义，@code{main}将不会调用@code{__main}。对于控制起始代码，
像OSF/1这样的系统，应该定义该宏，
对于支持@code{INIT_SECTION_ASM_OP}的系统不应该显式的定义。
@end defmac

@defmac LD_INIT_SWITCH
如果定义，为一个C字符串，作为一个开关，告诉连接器后面的符号为一个初始化例程。
@end defmac

@defmac LD_FINI_SWITCH
如果定义，为一个C字符串常量，作为一个开关，告诉连接器后面的符号为一个结束例程。
@end defmac

@defmac COLLECT_SHARED_INIT_FUNC (@var{stream}, @var{func})
如果定义，为一条C语句，其将写一个在加载共享库时可以被自动调用的函数。
函数应该调用@var{func}，其不接受任何参数。如果没有定义，
并且目标格式要求显示的初始化函数，则将会生成一个叫做@code{_GLOBAL__DI}的函数。

该函数和下面的一个，被collect2使用，用于连接一个需要构造者或者析构者，
或者代码中具有DWARF2异常表嵌入的共享库的时候。
@end defmac

@defmac COLLECT_SHARED_FINI_FUNC (@var{stream}, @var{func})
如果定义，为一条C语句，其将写一个在卸载共享库时可以被自动调用的函数。
函数应该调用@var{func}，其不接受任何参数。如果没有定义，
并且目标格式要求显示的初始化函数，则将会生成一个叫做@code{_GLOBAL__DD}的函数。
@end defmac

@defmac INVOKE__main
如果定义，@code{main}将调用@code{__main}，
而不管@code{INIT_SECTION_ASM_OP}的存在。对于init section不被自动运行，
但是仍可以用于搜集构建者和析构者列表的系统，该宏应该被定义。
@end defmac

@defmac SUPPORTS_INIT_PRIORITY
如果非零，则支持C++ @code{init_priority}属性，
并且编译器应该生成指令来控制对象初始化的顺序。
如果为0，编译器遇到@code{init_priority}属性时，将产生一条错误信息。
@end defmac

@deftypefn {Target Hook} bool TARGET_HAVE_CTORS_DTORS
该值为真，如果target支持一些搜集构造者和析构者在起始和退出时运行的本地方法。
如果我们必须使用@command{collect2}，则为假。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_CONSTRUCTOR (rtx @var{symbol}, int @var{priority})
如果定义，为一个函数，输出汇编代码来调用在初始化时@var{symbol}引用的函数。

假定@var{symbol}为一个没有参数并没有返回值的函数的@code{SYMBOL_REF}。
如果target支持初始化优先级，
@var{priority}为一个0到@code{MAX_INIT_PRIORITY}之间的值；
否则，其必须为@code{DEFAULT_INIT_PRIORITY}。

如果该宏没有被taret定义，则一个适当的缺省将被选择，
如果（1）target支持任意section名，
（2）target定义了@code{CTORS_SECTION_ASM_OP}，
或者（3）没有定义@code{USE_COLLECT2}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_DESTRUCTOR (rtx @var{symbol}, int @var{priority})
类似于@code{TARGET_ASM_CONSTRUCTOR}，不过用于终止函数，而不是初始化函数。
@end deftypefn

如果@code{TARGET_HAVE_CTORS_DTORS}为真，
对于生成的目标文件的初始化例程将具有静态连接。

如果你的系统使用@command{collec2}作为处理构造者的方法，
则那个程序通常使用@command{nm}来扫描目标文件，寻找被调用的构造者。

在一些特定的系统上，你可以定义该宏，使得@command{collect2}工作的更快。

@defmac OBJECT_FORMAT_COFF
定义该宏，如果系统使用COFF（Common Object File Format）目标文件，
这样@command{collect2}能够假设为该格式，并扫描直接目标文件的构造/析构函数。

该宏只有在本地编译器上才有效率；
对于交叉编译器，@command{collect2}总是使用@command{nm}。
@end defmac

@defmac REAL_NM_FILE_NAME
定义该宏为一个C字符串常量，包含用来执行@command{nm}的文件名。
缺省为搜索通常的路径。

如果你的系统支持共享库，并具有一个程序能够列出给定库或可执行程序的动态依赖，
你可以定义这些宏使得能够运行共享库中的初始化和终止函数。
@end defmac

@defmac LDD_SUFFIX
定义该宏为一个C字符串常量，包含程序的名字，其可以列出动态依赖，
像SunOS 4中的@command{"ldd"}。
@end defmac

@defmac PARSE_LDD_OUTPUT (@var{ptr})
定义该宏为C代码，从@code{LDD_SUFFIX}指定的程序的输出中抽取文件名。
@var{ptr}为@code{char *}类型的变量，指向@code{LDD_SUFFIX}的输出中的一行。
如果行中列出的是动态依赖，则代码必须将@var{ptr}前进到那一行的文件名起始处。
否则，其必须设置@var{ptr}为@code{NULL}。
@end defmac

@defmac SHLIB_SUFFIX
定义该宏为一个C字符串常量，包含了target缺省的共享库扩展名（例如@samp{".so"}）。
当生成全局构造者和析构者名字时，@command{collect2}从该后缀的后面剥去版本信息。
该定义只在使用@command{collect2}来处理构造者和析构者的target上需要。
@end defmac

@node 指令输出
@subsection 汇编指令的输出

@c prevent bad page break with this line
这章描述了汇编指令的输出。

@defmac REGISTER_NAMES
一段C初始化程序，包含了机器寄存器的汇编名字，每个名字使用C字符串常量表示。
这用来将编译器中的寄存器编号转换成汇编语言。
@end defmac

@defmac ADDITIONAL_REGISTER_NAMES
如果定义，则为结构体数组的初始化程序，结构体包含了名字和寄存器编号。
该宏定义了硬件寄存器的附加名字，这样就可以允许在声明中的@code{asm}选项，
来使用附加名引用寄存器。
@end defmac

@defmac ASM_OUTPUT_OPCODE (@var{stream}, @var{ptr})
定义该宏，如果你在使用一个不常见的汇编器，其需要不一样的机器指令名字。

定义为C语句，输出一个汇编指令代码到标准输入输出流@var{stream}中。
宏操作数@var{ptr}为类型是@code{char *}的变量，其指向内部形式中的指令码名字，
内部形式使用机器描述来表示。该定义应该输出操作码名字到@var{stream}中，
执行你想要的任何转换，并且将变量@var{ptr}增加到指向opcode的尾部，
这样其才不会被输出两次。

实际上，相对于整个指令码的名字，你的宏定义可以处理或多或少的部分；
但是如果你想处理包含@samp{%}序列的文本，则必须小心你所做的替换。
要保证增加@var{ptr}，使得不会输出不应该被输出的文本。

@findex recog_data.operand
如果需要查看操作数的值，它们可以作为@code{recog_data.operand}的元素被找到。

如果宏定义不做任何事情，则指令使用通常的方式来输出。
@end defmac

@defmac FINAL_PRESCAN_INSN (@var{insn}, @var{opvec}, @var{noperands})
如果定义，则为一条C语句，其就在为@var{insn}输出汇编代码之前将被执行，
用来修改被抽取的操作数，从而可以被不同方式的输出。

这里的参数@var{opvec}为一个向量，包含了从@var{insn}中抽取的操作数，
@var{noperands}为向量的元素个数。该向量的内容用于将insn模板转换成汇编代码，
所以你可以通过修改向量的内容来改变汇编输出。

该宏当有多个汇编语法共用一个指令模式文件时很有用；通过定义该宏，
你可以使大量类别的指令按照不同的方式输出（例如重组操作）。
自然的，影响单个insn模式的汇编语法，
应该通过在那些指令模式中写条件输出程序来处理。

如果没有定义该宏，则其相当于一条空语句。
@end defmac

@defmac PRINT_OPERAND (@var{stream}, @var{x}, @var{code})
C复合语句，用来将指令操作数@var{x}的汇编语法输出到标准输入输出流@var{stream}中。
@var{x}为RTL表达式。

@var{code}值可以用来指定打印操作数的方式。
用于当操作数必须根据上下文进行不同的打印的时候。
@var{code}来自用于打印操作数的@samp{%}指定语句。
如果指定语句只是@samp{%@var{digit}}，则@var{code}为0；
如果指定语句为@samp{%@var{ltr}@var{digit}}，则@var{code}为@var{ltr}的ASCII码。

@findex reg_names
如果@var{x}为寄存器，则该宏应该打印寄存器的名字。
名字可以在数组@code{reg_names}中找到，数组的类型为@code{char *[]}。
@code{reg_names}通过@code{REGISTER_NAMES}来初始化。

当机器描述具有一个@samp{%@var{punct}}指定语句时
（@samp{%}后面跟随一个标点符号字符），则该宏被调用时，@var{x}为空指针，
@var{code}为标点符号字符。
@end defmac

@defmac PRINT_OPERAND_PUNCT_VALID_P (@var{code})
一个C表达式，
当@var{code}为在@code{PRINT_OPERAND}宏中使用的有效的标点符号字符时，
其计算为真。如果没有定义@code{PRINT_OPERAND_PUNCT_VALID_P}，
则意味着不以这种方式使用标点符号字符（除了标准的@samp{%}以外）。
@end defmac

@defmac PRINT_OPERAND_ADDRESS (@var{stream}, @var{x})
C复合语句，用来将指令操作数为内存引用，其地址为@var{x}的汇编语法，
输出到标准输入输出流@var{stream}中。@var{x}为一个RTL表达式。

@cindex @code{TARGET_ENCODE_SECTION_INFO} usage
在一些机器上，符号地址的语法取决于地址所引用的section。在这些机器上，
定义钩子@code{TARGET_ENCODE_SECTION_INFO}来将信息存储到@code{symbol_ref}，
并在这里进行检查。参见 @ref{汇编格式}。
@end defmac

@findex dbr_sequence_length
@defmac DBR_OUTPUT_SEQEND (@var{file})
C语句，在所有的栈槽填充指令被输出之后执行。如果需要的话，
调用@code{dbr_sequence_length}来判定在序列中被填充的栈槽数目
（如果当前不是输出一个序列，则为0），用来决定输出多少个no-ops，或其它。

如果不做任何事情，就不要定义该宏，但是如果将延迟序列显示化，
则会有助于阅读汇编输出（例如，使用空格）。
@end defmac

@findex final_sequence
注意，用于带有延迟槽的指令的输出程序，
必须准备好处理没有被作为序列输出的情况（即，当没有运行调度过程，
或者没有找到栈槽填充者）。当没有处理序列时，变量@code{final_sequence}为空，
否则其包含了被输出的rtx @code{sequence}。

@findex asm_fprintf
@defmac REGISTER_PREFIX
@defmacx LOCAL_LABEL_PREFIX
@defmacx USER_LABEL_PREFIX
@defmacx IMMEDIATE_PREFIX
如果定义，则为C字符串表达式，用于@code{asm_fprintf}（参见 @file{final.c}）
的选项@samp{%R}, @samp{%L}, @samp{%U}和 @samp{%I}。
这在单个@file{md}文件必须支持多个汇编格式时很有用。这种情况下，
不同的@file{tm.h}文件可以定义不同的这些宏。
@end defmac

@defmac ASM_FPRINTF_EXTENSIONS (@var{file}, @var{argptr}, @var{format})
如果定义，该宏应该被扩展为一系列@code{case}语句，
其将在@code{asm_fprintf}函数中的@code{switch}语句里被解析。
这将应允许target来定义额外的printf格式，其在生成它们的汇编语句时很有帮助。
注意，大写字母被保留用于@code{asm_fprintf}将来的通用扩展，
所以不要用于target特定代码中。输出文件由参数@var{file}给定。
varargs输出指针为@var{argptr}，格式字符串的其余部分，由@var{format}指向。
@end defmac

@defmac ASSEMBLER_DIALECT
如果你的target支持多个汇编语言方言（例如不同的操作码），
可以定义该宏作为C表达式，给出汇编语言方言的索引，0作为第一个。

如果该宏被定义，你可以在指令模式的输出模版中（参见输出模版）或者asm_fprintf的第一个参数中使用如下的结构形式

@smallexample
@samp{@{option0|option1|option2@dots{}@}}
@end smallexample
@noindent
该结构输出@samp{option0}, @samp{option1}, @samp{option2}等等，
如果@code{ASSEMBLER_DIALECT}的值为0，1，2，等等。
这些字符串中的任何特殊字符将保留它们通常的含义。
如果括号中的可选项多于@code{ASSEMBLER_DIALECT}的值，则什么也不输出。

如果没有定义该宏，字符@samp{@{}, @samp{|}和@samp{@}}在模版中或
@code{asm_fprintf}的操作数中不具有任何特殊含义。

如果你能够通过定义宏@code{REGISTER_PREFIX}, @code{LOCAL_LABEL_PREFIX}, 
@code{USER_LABEL_PREFIX}和@code{IMMEDIATE_PREFIX}来表达出汇编语言语法的
不同之处，则定义这些宏。如果语法差异比较大，涉及到操作码不同或操作数顺序，
则定义@code{ASSEMBLER_DIALECT}，使用@samp{@{option0|option1@}}语法。
@end defmac

@defmac ASM_OUTPUT_REG_PUSH (@var{stream}, @var{regno})
C表达式，向@var{stream}中输出汇编代码，用于将硬件寄存器编号@var{regno}压入栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
@end defmac

@defmac ASM_OUTPUT_REG_POP (@var{stream}, @var{regno})
C表达式，向@var{stream}中输出汇编代码，用于将硬件寄存器编号@var{regno}弹出栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
@end defmac

@node 派遣表
@subsection 派遣表的输出

@c prevent bad page break with this line
这些是关于派遣表的。

@cindex dispatch table
@defmac ASM_OUTPUT_ADDR_DIFF_ELT (@var{stream}, @var{body}, @var{value}, @var{rel})
一条C语句，用来将汇编伪指令输出到stdio流@var{stream}中，
以生成两个标号间的距离。@var{value}和@var{rel}为两个内部标号的编号。
这些标号的定义通过使用@code{(*targetm.asm_out.internal_label)}来输出，
并且它们必须使用相同的方式打印。例如，

@smallexample
fprintf (@var{stream}, "\t.word L%d-L%d\n",
         @var{value}, @var{rel})
@end smallexample

在一些机器上，派遣表中的地址是相对于表自己的地址，对此你必须提供该宏。
如果定义，GCC还将在生成PIC的所有机器上使用该宏。
@var{body}为@code{ADDR_DIFF_VEC}的主体；提供它使得可以读取模式和标记。
@end defmac

@defmac ASM_OUTPUT_ADDR_VEC_ELT (@var{stream}, @var{value})
在一些机器上，派遣表中的地址为绝对地址，对此应该提供该宏。

定义应该为一条C语句，用来将汇编伪指令输出到stdio流@var{stream}中，
以生成对一个标号的引用。@var{value}为内部标号的编号，
其定义应该使用@code{(*targetm.asm_out.internal_label)}输出。例如，

@smallexample
fprintf (@var{stream}, "\t.word L%d\n", @var{value})
@end smallexample
@end defmac

@defmac ASM_OUTPUT_CASE_LABEL (@var{stream}, @var{prefix}, @var{num}, @var{table})
定义该宏，如果在跳转表之前的标号需要被特殊输出。
前三个参数跟@code{(*targetm.asm_out.internal_label)}相同；
第四个参数为随后的跳转表（一个包含@code{addr_vec}或@code{addr_diff_vec}
的@code{jump_insn}）。

该特点用于system V，来为table输出一条@code{swbeg}语句。

如果没有定义该宏，这些标号使用@code{(*targetm.asm_out.internal_label)}输出。
@end defmac

@defmac ASM_OUTPUT_CASE_END (@var{stream}, @var{num}, @var{table})
定义该宏，如果在跳转表的结尾必须输出一些特殊的东西。定义应该为一条C语句，
在写完table的汇编代码后被执行。其应该将适当的代码写入到stdio流@var{stream}中。
参数@var{table}为jump-table insn，@var{num}为前面的标号的编号。

如果没有定义该宏，在跳转表的结尾不输出任何特殊的东西。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_EMIT_UNWIND_LABEL (@var{stream}, @var{decl}, @var{for_eh}, @var{empty})
该target钩子在每个FDE的起始处生成一个标号。在一些target上，FDE需要特殊的标号，
对此应该定义该宏。其应该为函数声明@var{decl}相关联的FDE写入适当的标号到stdio流
@var{stream}中。第三个参数，@var{for_eh}，为一个布尔值；当是异常表时为真。
第四个参数@var{empty}，为一个布尔值；当是一个省略掉的FDE的占位符标号时为真。

缺省为FDE不给出非局部标号。
@end deftypefn

@deftypefn {Target Hook} void TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL (@var{stream})
该target钩子在异常表的起始处生成一个标号。在一些target上，
异常表需要根据函数被分割开，对此应该定义该宏。

缺省为不生成标号。
@end deftypefn

@deftypefn {Target Hook} void TARGET_UNWIND_EMIT (FILE * @var{stream}, rtx @var{insn})
该target钩子生成需要展开给定指定的汇编伪指令。
这只在设置了TARGET_UNWIND_INFO的时候才被使用。
@end deftypefn

@node 异常区域输出
@subsection 用于异常区域的汇编命令

@c prevent bad page break with this line

这一节描述了标记异常区域的起始和结束的命令。

@defmac EH_FRAME_SECTION_NAME
如果定义，为一个C字符串常量，包含异常处理帧展开信息的section名字。
如果没有定义，GCC将提供一个缺省定义，如果target支持命名section。
@file{crtstuff.c}使用该宏来切换到适当的section。

你应该定义该符号，如果你的target支持DWARF2帧展开信息并且缺省定义不工作。
@end defmac

@defmac EH_FRAME_IN_DATA_SECTION
如果定义，DWARF2帧展开信息将被放到data section，即使target支持命名section。
例如当系统连接器进行垃圾搜集并且section不能被标记为不被搜集的时候，
可能需要这样。

不要定义该宏，除非@code{TARGET_ASM_NAMED_SECTION}也被定义。
@end defmac

@defmac EH_TABLES_CAN_BE_READ_ONLY
定义该宏为1，如果你的target对于没有使用non-PIC代码编码的帧展开信息，
将总是要求运行时重定位，
但是连接器可能不支持将只读和读写section合并到单独的读写section中。
@end defmac

@defmac MASK_RETURN_ADDR
一个rtx，用于对通过@code{RETURN_ADDR_RTX}发现的返回地址进行掩码操作，
使得其不包含任何无关的位。
@end defmac

@defmac DWARF2_UNWIND_INFO
定义该宏为0，如果你的target支持DWARF2帧展开信息，
但是其还不能与异常处理一起工作。否则，
如果你的target支持这样的信息（如果定义了@samp{INCOMING_RETURN_ADDR_RTX}，
并且@samp{UNALIGNED_INT_ASM_OP}和@samp{OBJECT_FORMAT_ELF}之一），
GCC将提供缺省的定义，1。

如果定义了@code{TARGET_UNWIND_INFO}，target特定的展开者将用于所有情况。
定义该宏将使得可以生成DWARF2帧调试信息。

如果没有定义@code{TARGET_UNWIND_INFO}，并且该宏被定义为1，
则DWARF2 unwider将为缺省的异常处理机制；
否则基于@code{setjmp}/@code{longjmp}的框架将被缺省使用。
@end defmac

@defmac TARGET_UNWIND_INFO
定义该宏，如果你的target具有ABI指定的unwind表。
通常这些将由@code{TARGET_UNWIND_EMIT}输出。
@end defmac

@deftypevar {Target Hook} bool TARGET_UNWIND_TABLES_DEFAULT
该变量应该被设为@code{true}，如果target ABI即使不使用异常的时候也要求展开表。
@end deftypevar

@defmac MUST_USE_SJLJ_EXCEPTIONS
该宏只有当@code{DWARF2_UNWIND_INFO}为运行时变量时才需要被定义。那种情况下，
@file{except.h}不能正确的确定@code{MUST_USE_SJLJ_EXCEPTIONS}的相应定义，
所以target必须直接提供。
@end defmac

@defmac DONT_USE_BUILTIN_SETJMP
定义该宏为1，如果基于@code{setjmp}/@code{longjmp}的框架应该使用C库中的
@code{setjmp}/@code{longjmp}，
而不是@code{__builtin_setjmp}/@code{__builtin_longjmp}。
@end defmac

@defmac DWARF_CIE_DATA_ALIGNMENT
该宏只有当target可能会在函数序言中存储寄存器，
并且相对栈指针的偏移量没有对齐于@code{UNITS_PER_WORD}的时候，才需要被定义。
定义应该为负的最小对齐数，如果@code{STACK_GROWS_DOWNWARD}被定义，
否则为正的最小对齐数。参见 @ref{SDB和DWARF}。
只有当target支持DWARF2帧展开信息的时候才有用。
@end defmac

@deftypevar {Target Hook} bool TARGET_TERMINATE_DW2_EH_FRAME_INFO
值为真，如果target应该增加一个0字到Dwarf-2帧信息section的结尾，
当用于异常处理时。缺省值为假，如果@code{EH_FRAME_SECTION_NAME}被定义，否则为真。
@end deftypevar

@deftypefn {Target Hook} rtx TARGET_DWARF_REGISTER_SPAN (rtx @var{reg})
给定一个寄存器，该钩子应该返回一个并行的寄存器，来表示到哪里发现寄存器块。
定义该钩子，如果寄存器和它的机器模式在Dwarf中被表示为非连接的位置，
或者如果在Dwarf中寄存器应该被表示为多于一个寄存器。
否则该钩子应该返回@code{NULL_RTX}。如果没有定义，缺省为返回@code{NULL_RTX}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_INIT_DWARF_REG_SIZES_EXTRA (tree @var{address})
如果一些寄存器在Dwarf-2展开信息中按照多个块来表示，
定义该钩子在运行时来填充信息。
其将被@code{expand_builtin_init_dwarf_reg_sizes}调用。@var{address}为表的地址。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ASM_TTYPE (rtx @var{sym})
该钩子被用于从帧展开表中输出一个引用到由@var{sym}标识的type_info对象中。
其应该返回@code{true}，如果引用被输出。
返回@code{false}将会造成引用使用通常的Dwarf2例程被输出。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_ARM_EABI_UNWINDER
该钩子应该被设为@code{true}，在使用基于ARM EABI的展开库的target上，
并且在其它target上为@code{false}。这将影响展开表的格式。缺省为@code{false}。
@end deftypefn

@node 对齐输出
@subsection 用于对齐的汇编命令

@c prevent bad page break with this line
这一节描述了用于对齐的命令。

@defmac JUMP_ALIGN (@var{label})
在@var{label}前放入的对齐数（基于2的log），
label为跳转的普通目的地并且不具有fallthru入边。

如果你目前不想做任何特殊的对齐，则不需要定义该宏。
大多数机器描述目前都没有定义该宏。

除非需要检查@var{label}参数，
最好在target的@code{OVERRIDE_OPTIONS}中设置变量@var{align_jumps}。
否则应该尽量在@code{JUMP_ALIGN}实现中尊重用户在@var{align_jumps}中的选择。
@end defmac

@defmac LABEL_ALIGN_AFTER_BARRIER (@var{label})
在@var{label}前放入的对齐数（基于2的log），@var{label}后跟随一个@code{BARRIER}。

如果你目前不想做任何特殊的对齐，则不需要定义该宏。
大多数机器描述目前都没有定义该宏。
@end defmac

@defmac LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP
当应用@code{LABEL_ALIGN_AFTER_BARRIER}时，要跳过的最大字节个数。
这只在定义了@code{ASM_OUTPUT_MAX_SKIP_ALIGN}时才起作用。
@end defmac

@defmac LOOP_ALIGN (@var{label})
在@var{label}前放入的对齐数（基于2的log），
@var{label}后跟随一个@code{NOTE_INSN_LOOP_BEG}注解。

如果你目前不想做任何特殊的对齐，则不需要定义该宏。
大多数机器描述目前都没有定义该宏。

除非需要检查@var{label}参数，
最好在target的@code{OVERRIDE_OPTIONS}中设置变量@code{align_loops}。
否则应该尽量在@code{LOOP_ALIGN}实现中尊重用户在@code{align_loops}中的选择。
@end defmac

@defmac LOOP_ALIGN_MAX_SKIP
当应用@code{LOOP_ALIGN}时，要跳过的最大字节个数。
这只在定义了@code{ASM_OUTPUT_MAX_SKIP_ALIGN}时才起作用。
@end defmac

@defmac LABEL_ALIGN (@var{label})
在@var{label}前放入的对齐数（基于2的log），
如果@code{LABEL_ALIGN_AFTER_BARRIER} / @code{LOOP_ALIGN}指定了不相同的对齐，
则使用最大的值。

除非需要检查@var{label}参数，
最好在target的@code{OVERRIDE_OPTIONS}中设置变量@code{align_labels}。
否则应该尽量在@code{LABEL_ALIGN}实现中尊重用户在@code{align_labels}中的选择。
@end defmac

@defmac LABEL_ALIGN_MAX_SKIP
当应用@code{LABEL_ALIGN}时，要跳过的最大字节个数。
这只在定义了@code{ASM_OUTPUT_MAX_SKIP_ALIGN}时才起作用。
@end defmac

@defmac ASM_OUTPUT_SKIP (@var{stream}, @var{nbytes})
一条C语句，将一条汇编指令输出到stdio流@var{stream}中，
使得将位置计数器前移@var{nbytes}个字节。那些字节在加载时应该为0。
@var{nbytes}将为@code{unsigned HOST_WIDE_INT}类型的C表达式。
@end defmac

@defmac ASM_NO_SKIP_IN_TEXT
定义该宏，如果@code{ASM_OUTPUT_SKIP}不应该在text section中使用，
因为无法在跳过的字节中放入0。这在许多Unix系统上都为，
当在text section中使用时，跳过字节的伪指令会产生no-op指令，而不是0。
@end defmac

@defmac ASM_OUTPUT_ALIGN (@var{stream}, @var{power})
一条C语句，将一条汇编指令输出到stdio流@var{stream}中，
使得将位置计数器前移2的@var{power}次幂个字节。
@var{power}为@code{int}类型的表达式。
@end defmac

@defmac ASM_OUTPUT_ALIGN_WITH_NOP (@var{stream}, @var{power})
类似@code{ASM_OUTPUT_ALIGN}，除了使用“nop”指令来填充，如果需要的话。
@end defmac

@defmac ASM_OUTPUT_MAX_SKIP_ALIGN (@var{stream}, @var{power}, @var{max_skip})
一条C语句，将一条汇编指令输出到stdio流@var{stream}中，
使得将位置计数器前移2的@var{power}次幂个字节，
但只有当需要@var{max_skip}个或者更少的字节来满足对齐要求的时候才行。
@var{power}和@var{max_skip}为@code{int}类型的表达式。
@end defmac

@need 3000
@node 调试信息
@section 控制调试信息格式

@c prevent bad page break with this line
描述了如何指定调试信息。

@menu
* 所有调试器::  影响所有调试信息的宏   
* DBX选项::     启用DBX格式的特定选项的宏  
* DBX钩子::     变更DBX格式的钩子宏 
* 文件名和DBX:: 控制DBX格式中文件名的输出
* SDB和DWARF::  用于SDB（COFF）和DWARF格式的宏
* VMS调试::     用于VMS调试格式的宏
@end menu

@node 所有调试器
@subsection 影响所有调试格式的宏

@c prevent bad page break with this line
这些宏影响所有的调试格式。

@defmac DBX_REGISTER_NUMBER (@var{regno})
一个C表达式，返回编译器寄存器号@var{regno}的DBX寄存器号。
在提供的缺省宏中，该表达式的值将为@var{regno}本身。
但是有时候，有些寄存器编译器知道但是DBX不知道，或者相反。
对于这种情况，寄存器可能需要在编译器中具有一个编号，
而在DBX中具有另一个。

如果两个寄存器在GCC中具有连续的编号，
并且可以作为一对用来保存多字的值，
则它们在使用@code{DBX_REGISTER_NUMBER}重新编号之后
@emph{必须}还具有连续的编号。
否则，调试器将无法访问这样的寄存器对，
因为调试器期望寄存器对在自己的编号方案下也是连续的。

如果你发现自己定义的@code{DBX_REGISTER_NUMBER}不能保持寄存器对，
则必须重定义实际的寄存器编号方案。
@end defmac

@defmac DEBUGGER_AUTO_OFFSET (@var{x})
一个C表达式，返回具有地址@var{x}（RTL表达式）的自动变量的整数偏移量。
缺省计算是假设@var{x}基于帧指针的，并会给出相对帧指针的偏移量。
这对于产生DBX调试输出或COFF风格的SDB调试输出，
并且在使用@option{-g}选项时也允许消除帧指针的目标，会有需要。
@end defmac

@defmac DEBUGGER_ARG_OFFSET (@var{offset}, @var{x})
一个C表达式，返回具有地址@var{x}（RTL表达式）的参数的整数偏移量。
名义上的偏移量为@var{offset}。
@end defmac

@defmac PREFERRED_DEBUGGING_TYPE
一个C表达式，返回当用户只指定@option{-g}时，
GCC应该产生的调试输出类型。
如果你已经使得GCC支持多种调试输出格式的时候，则定义该宏。
目前，允许的值为@code{DBX_DEBUG}, @code{SDB_DEBUG}, @code{DWARF_DEBUG}, 
@code{DWARF2_DEBUG}, @code{XCOFF_DEBUG}, 
@code{VMS_DEBUG}和@code{VMS_AND_DWARF2_DEBUG}。

当用户指定@option{-ggdb}时，GCC通常还使用该宏的值来选择调试输出格式，
但是有两个例外。如果定义了@code{DWARF2_DEBUGGING_INFO}，
则GCC使用值@code{DWARF2_DEBUG}，如果定义了@code{DBX_DEBUGGING_INFO}，
则GCC使用@code{DBX_DEBUG}。

该宏的值只影响缺省调试输出；用户总是可以通过使用@option{-gstabs},
@option{-gcoff}, @option{-gdwarf-2}, 
@option{-gxcoff}或@option{-gvms}来获得指定类型的输出。
@end defmac

@node DBX选项
@subsection 用于DBX输出的特定选项

@c prevent bad page break with this line
这些是用于DBX输出的特定选项。

@defmac DBX_DEBUGGING_INFO
定义该宏，如果对于@option{-g}选项，GCC应该产生DBX的调试输出。
@end defmac

@defmac XCOFF_DEBUGGING_INFO
定义该宏，如果对于@option{-g}选项，GCC应该产生XCOFF格式的调试输出。
这是DBX格式的变体。
@end defmac

@defmac DEFAULT_GDB_EXTENSIONS
定义该宏来控制GCC是否缺省的生成GDB的扩展版本DBX调试信息
（假设是使用DBX格式的调试信息）。如果没有定义该宏，则缺省为1：
如果可能的话，总是生成扩展信息。
@end defmac

@defmac DEBUG_SYMS_TEXT
定义该宏，如果所有@code{.stabs}命令应该输出在text section中。
@end defmac

@defmac ASM_STABS_OP
一个C字符串常量，包括空格，
命名了用来替代@code{"\t.stabs\t"}的汇编伪指令，
来定义一个普通调试符号。
如果没有定义该宏，则使用@code{"\t.stabs\t"}。
该宏只用于DBX调试信息格式。
@end defmac

@defmac ASM_STABD_OP
一个C字符串常量，包括空格，
命名了用来替代@code{"\t.stabd\t"}的汇编伪指令，
来定义一个普通调试符号。
如果没有定义该宏，则使用@code{"\t.stabd\t"}。
该宏只用于DBX调试信息格式。
@end defmac

@defmac ASM_STABN_OP
一个C字符串常量，包括空格，
命名了用来替代@code{"\t.stabn\t"}的汇编伪指令，来定义一个普通调试符号。
如果没有定义该宏，则使用@code{"\t.stabn\t"}。该宏只用于DBX调试信息格式。
@end defmac

@defmac DBX_NO_XREFS
定义该宏，如果DBX在你的系统上不支持@samp{xs@var{tagname}}结构。
在一些系统上，该结构被用于描述对名字叫@var{tagname}的结构体的向前引用。
在其它系统上，该结构根本不被支持。
@end defmac

@defmac DBX_CONTIN_LENGTH
DBX格式的调试信息中的符号名被连续的处理
（分成两个独立的@code{.stabs}指令）
当其达到一个特定长度时（缺省为80个字符）。
在一些操作系统上，DBX 要求做这样的分割；在其它上面，则不能进行分割。
你可以通过定义该宏为0来约束分割。
你可以覆盖缺省的分割长度，通过定义该宏为一个长度的表达式。
@end defmac

@defmac DBX_CONTIN_CHAR
通常通过在@code{.stabs}字符串的结尾增加一个@samp{\}字符来表示连续的处理。
要是用不用的字符，定义该宏为一个你想使用的字符常量。
不要定义该宏，如果反斜杠在你的系统上是正确的。
@end defmac

@defmac DBX_STATIC_STAB_DATA_SECTION
定义该宏，如果需要在为非全局的静态变量输出@samp{.stabs}伪操作符之前进入data section。
@end defmac

@defmac DBX_TYPE_DECL_STABS_CODE
对于typedef，@code{.stabs}指令的“code”域所使用的值。
缺省为@code{N_LSYM}。
@end defmac

@defmac DBX_STATIC_CONST_VAR_CODE
对于位于text section的静态变量，@code{.stabs}指令的“code”域所使用的值。
DBX格式不提供任何正确是方式。缺省为@code{N_FUN}。
@end defmac

@defmac DBX_REGPARM_STABS_CODE
对于寄存器中传递的参数，@code{.stabs}指令的“code”域所使用的值。
DBX格式不提供任何正确是方式。缺省为@code{N_RSYM}。
@end defmac

@defmac DBX_REGPARM_STABS_LETTER
在DBX符号数据中使用的字母，用来标识一个符号为在寄存器中传递的参数。
DBX格式目前没有提供任何这样做的方式。缺省为@code{'P'}。
@end defmac

@defmac DBX_FUNCTION_FIRST
定义该宏，如果对于函数和它的参数的DBX信息应该位于函数的汇编代码之前。
通常，在DBX格式中，调试信息完全位于汇编代码之后。
@end defmac

@defmac DBX_BLOCKS_FUNCTION_RELATIVE
定义该宏为1，
如果描述块（@code{N_LBRAC}或@code{N_RBRAC}）的作用域的符号的值，
应该相对于函数括号的起始处。通常GCC使用绝对值。
@end defmac

@defmac DBX_LINES_FUNCTION_RELATIVE
定义该宏为1，如果指示当前行（@code{N_SLINE}）的符号的值，
应该相对于函数括号的起始处。通常GCC使用绝对值。
@end defmac

@defmac DBX_USE_BINCL
定义该宏，
如果GCC应该为被包含的头文件生成@code{N_BINCL}和@code{N_EINCL} stabs，
如Sun系统。通常，GCC不生成@code{N_BINCL}或@code{N_EINCL} stabs。
@end defmac

@node DBX钩子 
@subsection 针对DBX格式的钩子

@c prevent bad page break with this line
这些是针对DBX格式的钩子。

@defmac DBX_OUTPUT_LBRAC (@var{stream}, @var{name})
定义该宏，
以告知如何将变量名的作用域级别的起始调试信息输出到@var{stream}中。
参数@var{name}为一个汇编符号的名字（使用@code{assemble_name}），
其值为作用域起始的地址。
@end defmac

@defmac DBX_OUTPUT_RBRAC (@var{stream}, @var{name})
类似@code{DBX_OUTPUT_LBRAC}，不过是作用域级别的结尾。
@end defmac

@defmac DBX_OUTPUT_NFUN (@var{stream}, @var{lscope_label}, @var{decl})
定义该宏，
如果target机器要求对函数@var{decl}输出一个@code{N_FUN}条目进行特殊处理。
@end defmac

@defmac DBX_OUTPUT_SOURCE_LINE (@var{stream}, @var{line}, @var{counter})
一条C语句，将DBX调试信息在当前源文件行号@var{line}的代码前，
输出到stdio流@var{stream}中。@var{counter}为宏被调用的次数，
包括当前调用；其用于在汇编输出中生成为一个标号。

如果缺省输出是正确的，
或者其能够通过定义@code{DBX_LINES_FUNCTION_RELATIVE}而变的正确，
则不要定义该宏。
@end defmac

@defmac NO_DBX_FUNCTION_END
一些stab封装格式（特别是ECOFF），
不能处理@code{.stabs "",N_FUN,,0,0,Lscope-function-1} gdb dbx扩展结构。
在那些机器上，定义该宏来关掉这个特点，并且不影响其它gdb扩展。
@end defmac

@defmac NO_DBX_BNSYM_ENSYM
一些汇编器不能处理@code{.stabd BNSYM/ENSYM,0,0} gdb dbx扩展结构。
在那些机器上，定义该宏来关掉这个特点，并且不影响其它gdb扩展。
@end defmac

@node 文件名和DBX
@subsection DBX格式的文件名

@c prevent bad page break with this line
这一节描述了DBX格式的文件名。

@defmac DBX_OUTPUT_MAIN_SOURCE_FILENAME (@var{stream}, @var{name})
一条C语句，
将DBX调试信息输出到标准输入输出（stdio）流@var{stream}上，
其中文件@var{name}为主源文件——被指定为被编译的输入文件。
该宏只被调用一次，在编译的开始处。

如果DBX调试信息输出的标准形式合适，则该宏不需要被定义。

有时可能需要引用相当与text段起始处的标号。
这时可以使用@samp{assemble_name (stream, ltext_label_name)}来完成。
如果这样做，则必须还要将变量@var{used_ltext_label_name}设为@code{true}。
@end defmac

@defmac NO_DBX_MAIN_SOURCE_DIRECTORY
定义该宏的值为1，
如果不让GCC在文件起始处产生对当前的编译目录和当前的源语言的指示。
@end defmac

@defmac NO_DBX_GCC_MARKER
定义该宏的值为1，如果不让GCC产生该目标文件是由GCC编译的指示。
缺省情况是在每个源文件的起始处产生一个@code{N_OPT} stab，
其中字符串为@samp{gcc2_compiled.}，值为0。
@end defmac

@defmac DBX_OUTPUT_MAIN_SOURCE_FILE_END (@var{stream}, @var{name})
一条C语句，用来在主源文件@var{name}的编译结尾输出DBX调试信息。
输出将被写入标准输入输出流@var{stream}中。

如果没有定义该宏，则在编译的结尾将不做任何特定的输出，
这对于大多数机器都是正确的。
@end defmac

@defmac DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END
定义该宏而不是定义@code{DBX_OUTPUT_MAIN_SOURCE_FILE_END}，
如果要在编译结尾输出的是一个@code{N_SO} stab，
其具有空字符串，值为文件中最高的绝对text地址。
@end defmac

@need 2000
@node SDB和DWARF
@subsection 用于SDB和DWARF输出的宏

@c prevent bad page break with this line
这些是用于SDB和DWARF输出的宏。

@defmac SDB_DEBUGGING_INFO
定义该宏，如果对于@option{-g}选项，GCC应该为SDB产生COFF风格的调试输出。
@end defmac

@defmac DWARF2_DEBUGGING_INFO
定义该宏，如果对于@option{-g}选项，GCC应该产生dwarf本版2格式的调试输出。

@deftypefn {Target Hook} int TARGET_DWARF_CALLING_CONVENTION (tree @var{function})
定义该钩子，使得为个函数输出dwarf属性@code{DW_AT_calling_convention}。
返回@code{DW_CC_}标记的enum值。
@end deftypefn

要支持可选的调用帧调试信息，
你必须还要定义@code{INCOMING_RETURN_ADDR_RTX}，并如果在序言中使用RTL，
则设置@code{RTX_FRAME_RELATED_P}，或者如果没有使用RTL，
则从@code{TARGET_ASM_FUNCTION_PROLOGUE}中调用@code{dwarf2out_def_cfa}
和@code{dwarf2out_reg_save}。
@end defmac

@defmac DWARF2_FRAME_INFO
定义该宏为非0值，如果GCC应该总是输出Dwarf2帧信息。
如果@code{DWARF2_UNWIND_INFO}（参见 @ref{异常区域输出}）为非0，
则GCC将不管你如何定义@code{DWARF2_FRAME_INFO}，都会输出该信息。
@end defmac

@defmac DWARF2_ASM_LINE_DEBUG_INFO
定义该宏为非0值，如果汇编器能够生成Dwarf2行调试信息section。
@end defmac

@defmac ASM_OUTPUT_DWARF_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})
一条C语句，来输出汇编伪指令，
以创建一个@var{lab1}减去@var{lab2}的差，使用给定的@var{size}。
@end defmac

@defmac ASM_OUTPUT_DWARF_OFFSET (@var{stream}, @var{size}, @var{label}, @var{section})
一条C语句，来输出汇编伪指令，
以创建一个相对的@var{section}的给定@var{label}的引用，
使用给定的@var{size}。@var{label}为在给定@var{section}中定义的@var{label}。
@end defmac

@defmac ASM_OUTPUT_DWARF_PCREL (@var{stream}, @var{size}, @var{label})
一条C语句，来输出汇编伪指令，
以创建一个给定@var{label}的引用，使用给定的@var{size}。
@end defmac

@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_DWARF_DTPREL (FILE *@var{FILE}, int @var{size}, rtx @var{x})
如果定义，该target钩子为一个函数，其输出一个相对DTP的引用，对给定的TLS符号。
@end deftypefn

@defmac PUT_SDB_@dots{}
定义这些宏来覆盖汇编语法，为特定的SDB汇编伪指令。
参见@file{sdbout.c}，关于这些宏和它们的参数的列表。
如果使用标准语法，你不需要定义它们。
@end defmac

@defmac SDB_DELIM
一些汇编器不支持分号作为分隔符，即使在SDB汇编伪指令之间。
这种情况下，定义该宏为要使用的分隔符（通常为@samp{\n}）。
如果只需要改变该宏，则不需要定义新的@code{PUT_SDB_@var{op}}宏集合。
@end defmac

@defmac SDB_ALLOW_UNKNOWN_REFERENCES
定义该宏以允许对未知结构体，联合体和枚举标记的引用，被输出。
标准的COFF不允许处理未知的引用，MIPS ECOFF支持该特定。
@end defmac

@defmac SDB_ALLOW_FORWARD_REFERENCES
定义该宏以允许对未遇到的结构体，联合体和枚举标记的引用，被输出。
一些汇编器对此会出错。
@end defmac

@defmac SDB_OUTPUT_SOURCE_LINE (@var{stream}, @var{line})
一条C语句，输出当前源文件的行号的SDB调试信息在代码前。
缺省为输出一个@code{.ln}伪指令。
@end defmac

@need 2000
@node VMS调试
@subsection 用于VMS调试格式的宏

@c prevent bad page break with this line
这是用于VMS调试格式的宏。

@defmac VMS_DEBUGGING_INFO
定义该宏，如果GCC应该为@option{-g}选项产生VMS调试输出。
VMS的缺省行为是在没有@option{-g}时，生成可以回溯的最少调试信息，
除非使用@option{-g0}显示的覆盖。
该行为由@code{OPTIMIZATION_OPTIONS}和@code{OVERRIDE_OPTIONS}控制。
@end defmac

@node 浮点
@section 交叉编译和浮点
@cindex cross compilation and floating point
@cindex floating point and cross compilation

虽然所有现代机器都使用二进制补码来表示整数，但对于浮点数却有不同的表示。
这意味着在交叉编译器中，
被编译的程序中的浮点数的表示可能与执行编译的机器上的表示不相同。

因为不同的表示方式可能会提供不同的取值范围和精度，
所以所有的浮点常量必须被表示成target机器的格式。
因此，交叉编译器不能使用host机器的浮点算术；其必须模拟target的算术运算。
为了确保一致性，GCC总是使用模拟方式来处理浮点值，
即使host和target的浮点格式相同。

下列宏由@file{real.h}提供给编译器使用。
编译器的生成或者优化浮点计算的所有部分必须使用这些宏。
它们可能会计算操作数多次，所以操作数一定不要有副作用。

@defmac REAL_VALUE_TYPE
C数据类型，用于存放target机器格式的浮点值。
通常为一个包含@code{HOST_WIDE_INT}型数组的结构体，
但是所有的代码应该将其作为不透明的量。
@end defmac

@deftypefn Macro int REAL_VALUES_EQUAL (REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})
比较两个值是否相等，@var{x}和@var{y}。如果target浮点格式支持负0和/或NaN，
则@samp{REAL_VALUES_EQUAL (-0.0, 0.0)} 为真, 
@samp{REAL_VALUES_EQUAL (NaN, NaN)}为假。
@end deftypefn

@deftypefn Macro int REAL_VALUES_LESS (REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})
测试@var{x}是否小于@var{y}。
@end deftypefn

@deftypefn Macro HOST_WIDE_INT REAL_VALUE_FIX (REAL_VALUE_TYPE @var{x})
将@var{x}截取为有符号整数，向0舍入。
@end deftypefn

@deftypefn Macro {unsigned HOST_WIDE_INT} REAL_VALUE_UNSIGNED_FIX (REAL_VALUE_TYPE @var{x})
将@var{x}截取为无符号整数，向0舍入。如果@var{x}为负，则返回0。
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_ATOF (const char *@var{string}, enum machine_mode @var{mode})
将@var{string}转换为target机器模式@var{mode}所表示的浮点数。
该程序可以处理十进制和十六进制的浮点常量，使用C语言定义的语法。
@end deftypefn

@deftypefn Macro int REAL_VALUE_NEGATIVE (REAL_VALUE_TYPE @var{x})
如果@var{x}为负数（包括负零），返回1，否则0。
@end deftypefn

@deftypefn Macro int REAL_VALUE_ISINF (REAL_VALUE_TYPE @var{x})
确定@var{x}是否表示无穷（正的或负的）。
@end deftypefn

@deftypefn Macro int REAL_VALUE_ISNAN (REAL_VALUE_TYPE @var{x})
确定@var{x}是否表示“NaN” (not-a-number)。
@end deftypefn

@deftypefn Macro void REAL_ARITHMETIC (REAL_VALUE_TYPE @var{output}, enum tree_code @var{code}, REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})
计算一个算术运算对浮点值@var{x}和@var{y}，将结果存到@var{output}（其必须为一个变量）中。

要执行的运算由@var{code}指定。只有下列代码被支持：@code{PLUS_EXPR}, @code{MINUS_EXPR}, @code{MULT_EXPR}, @code{RDIV_EXPR}, @code{MAX_EXPR}, @code{MIN_EXPR}。

如果@code{REAL_ARITHMETIC}被要求计算除0，并且target的浮点格式不能表示无穷，则会调用@code{abort}。调用者应该首先检查这种情况，使用@code{MODE_HAS_INFINITIES}。@xref{存储布局}.
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_NEGATE (REAL_VALUE_TYPE @var{x})
返回浮点值@var{x}的负数。
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_ABS (REAL_VALUE_TYPE @var{x})
返回@var{x}的绝对值。
@end deftypefn

@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_TRUNCATE (REAL_VALUE_TYPE @var{mode}, enum machine_mode @var{x})
将浮点值@var{x}截取为适合@var{mode}。返回值仍然是@code{REAL_VALUE_TYPE}，但是具有一个合适的位模式，其精度根据模式@var{mode}来输出浮点常量。
@end deftypefn

@deftypefn Macro void REAL_VALUE_TO_INT (HOST_WIDE_INT @var{low}, HOST_WIDE_INT @var{high}, REAL_VALUE_TYPE @var{x})
转换浮点值@var{x}为双精度整数，存储到@var{low}和@var{high}中。如果值不是整形的，则进行截取。
@end deftypefn

@deftypefn Macro void REAL_VALUE_FROM_INT (REAL_VALUE_TYPE @var{x}, HOST_WIDE_INT @var{low}, HOST_WIDE_INT @var{high}, enum machine_mode @var{mode})
转换在@var{low}和@var{high}中的一个双精度整数为浮点值，其被存储在@var{x}中。值被截取以适合机器模式@var{mode}。
@end deftypefn

@node 机器模式切换
@section 机器模式切换指令
@cindex mode switching
下列的宏用来控制模式切换优化：

@defmac OPTIMIZE_MODE_SWITCHING (@var{entity})
定义该宏，如果在优化编译中，port需要为机器模式切换插入额外的指令。

例如，SH4可以执行单精度和双精度的浮点运算，但是执行单精度运算时，
必须清除FPSCR PR位，而执行双精度运算时，必须设置该位。
改变PR位需要一个通用寄存器来作为草稿寄存器，
因此这些FPSCR设置必须在重载之前被插入，
即你不能将它放在指令输出或者@code{TARGET_MACHINE_DEPENDENT_REORG}阶段。

你可以具有多个具有模式切换的实体，并且在运行时选择哪些实体实际需要。
对于任何需要模式切换的@var{entity}，@code{OPTIMIZE_MODE_SWITCHING}应该返回非零。
如果你定义了该宏，你还必须定义@code{NUM_MODES_FOR_MODE_SWITCHING}, 
@code{MODE_NEEDED}, @code{MODE_PRIORITY_TO_MODE}和@code{EMIT_MODE_SET}。
@code{MODE_AFTER}, @code{MODE_ENTRY}和@code{MODE_EXIT}是可选的。
@end defmac

@defmac NUM_MODES_FOR_MODE_SWITCHING
如果你定义了@code{OPTIMIZE_MODE_SWITCHING}，你必须定义该宏，
作为整数数组的初始化。每个初始化元素N引用一个需要模式切换的实体，
并且指定了该实体可能需要被设置的不同模式的数目。
初始化的位置——起始于0——确定了被用于引用有问题的模式切换实体的整数。
@end defmac

@defmac MODE_NEEDED (@var{entity}, @var{insn})
@var{entity}为一个整数指定了模式切换的实体。
如果定义了@code{OPTIMIZE_MODE_SWITCHING}，
则必须定义该宏来返回一个不大于在@code{NUM_MODES_FOR_MODE_SWITCHING}
中相应元素的整数值，来指示@var{entity}在执行@var{insn}前必须被切换成的模式。
@end defmac

@defmac MODE_AFTER (@var{mode}, @var{insn})
如果定义该宏，其在模式切换过程中对于每个@var{insn}进行求值。
其确定一个insn的结果时的模式（如果与输入时的模式不同）。
@end defmac

@defmac MODE_ENTRY (@var{entity})
如果定义该宏，其对每个需要模式切换的@var{entity}进行求值。
结果为一个整数，为@var{entity}在函数入口处被假定切换成的模式。
如果定义了@code{MODE_ENTRY}，则必须定义@code{MODE_EXIT}。
@end defmac

@defmac MODE_EXIT (@var{entity})
如果定义该宏，其对每个需要模式切换的实体进行求值。结果为一个整数，
为实体在函数出口处被假定切换成的模式。如果定义了@code{MODE_EXIT}，
则必须定义@code{MODE_ENTRY}。
@end defmac

@defmac MODE_PRIORITY_TO_MODE (@var{entity}, @var{n})
该宏指定了被处理的@var{entity}的模式顺序。0为最高优先级，
@code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1}为最低。
宏的值应该为一个整数，表示@var{entity}的一个模式。对于任何固定的@var{entity}，
@code{mode_priority_to_mode}(@var{entity}, @var{n}))应该为0@dots{}
@code{num_modes_for_mode_switching[@var{entity}] - 1}之间的双向影射。
@end defmac

@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{hard_regs_live})
生成一个或多个insn来将@var{entity}设为@var{mode}。
@var{hard_reg_live}是在insn被插入点处的硬件寄存器活跃集。
@end defmac

@node 目标机属性
@section 定义目标机特定的@code{__attribute__}用法
@cindex target attributes
@cindex machine attributes
@cindex attributes, target-specific

可以为函数，数据和类型定义target特定的属性。
这些使用下列target钩子来描述；它们还需要在@file{extend.texi}中被记述。

@deftypevr {Target Hook} {const struct attribute_spec *} TARGET_ATTRIBUTE_TABLE
如果定义，
该目标钩子指向一个@samp{struct attribute_spec} (在@file{tree.h}中定义) 数组，
用来指定该目标的机器特定的属性，
以及这些属性被应用到的实体和它们接受的参数的一些限制。
@end deftypevr

@deftypefn {Target Hook} int TARGET_COMP_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})
如果定义，该目标钩子为一个函数，
如果@var{type1}和@var{type2}的属性不匹配则返回0，匹配则返回1，
几乎匹配则返回2（这将产生一个warning）。如果没有被定义，
则机器特定的属性总被假定为匹配的。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SET_DEFAULT_TYPE_ATTRIBUTES (tree @var{type})
如果定义，该目标钩子为一个函数，其将缺省属性赋予新定义的类型@var{type}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_MERGE_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})
定义该target钩子，如果合并类型属性需要进行特殊的处理。
如果定义，则结果为@var{type1}和@var{type2}的组合@code{TYPE_ATTRIBUTES}列表。
其假设@code{comptypes}总是被调用并返回1。
该函数可以调用@code{merge_attributes}来处理机器无关的合并。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_MERGE_DECL_ATTRIBUTES (tree @var{olddecl}, tree @var{newdecl})
定义该target钩子，如果合并decl属性需要进行特殊的处理。如果定义，
则结果为@var{olddecl}和@var{newdecl}的组合@code{DECL_ATTRIBUTES}列表。
@var{newdecl}为@var{olddecl}的拷贝。这样的例子是当一个属性覆盖另一个，
或者当一个属性被后续的属性置空的情况。
该函数可以调用@code{merge_attributes}来处理机器无关的合并。

@findex TARGET_DLLIMPORT_DECL_ATTRIBUTES
如果唯一需要target特定的处理是Microsoft Windows target的@samp{dllimport}，
则你应该定义宏@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}为@code{1}。
然后编译器将会定义一个叫做@code{merge_dllimport_decl_attributes}的函数，
其可以被定义为@code{TARGET_MERGE_DECL_ATTRIBUTES}的扩展。
你还可以为你的port在属性表中增加@code{handle_dll_attribute}，
来执行@samp{dllimport}和@samp{dllexport}属性的初始化处理。
例如，在@file{i386/cygwin.h}和@file{i386/i386.c}中。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VALID_DLLIMPORT_ATTRIBUTE_P (tree @var{decl})
@var{decl}为一个指定为@code{__attribute__((dllimport))}的变量或者函数。
使用该钩子，如果target需要给@code{handle_dll_attribute}增加额外的有效性检查。
@end deftypefn

@defmac TARGET_DECLSPEC
定义该宏为非零，
如果你想将@code{__declspec(X)}与@code{__attribute((X))}等同对待。
缺省下，只有在定义了@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}的target上才可以。
目前对于@code{__declspec}的实现是通过一个内建的宏，但是你不应该依赖于实现细节。
@end defmac

@deftypefn {Target Hook} void TARGET_INSERT_ATTRIBUTES (tree @var{node}, tree *@var{attr_ptr})
定义该target钩子，如果你想在decl被创建时，能够为其增加属性。
这在后端想要实现一个pragma，并且用到与pragma相关的属性的时候，
通常很有用。参数@var{node}是正在创建的decl。
参数@var{attr_ptr}是指向该decl的属性列表的指针。不要修改列表本身，
因为其可能与其它decl共享，但是可以将属性链接到列表的头部，
并且修改@code{*@var{attr_ptr}}以指向新的属性，或者如果需要进一步的修改，
创建一个列表的拷贝。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P (tree @var{fndecl})
@cindex inlining
该target钩子返回@code{true}，如果可以将@var{fndecl}内联到当前函数中，
而不管它具有的target特定属性，否则为@code{false}。
缺省下，如果函数具有一个target特定属性，则不会被内联。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_VALID_OPTION_ATTRIBUTE_P (tree @var{fndecl}, tree @var{name}, tree @var{args}, int @var{flags})
This hook is called to parse the @code{attribute(option("..."))}, and
it allows the function to set different target machine compile time
options for the current function that might be different than the
options specified on the command line.  The hook should return
@code{true} if the options are valid.

The hook should set the @var{DECL_FUNCTION_SPECIFIC_TARGET} field in
the function declaration to hold a pointer to a target specific
@var{struct cl_target_option} structure.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_SAVE (struct cl_target_option *@var{ptr})
This hook is called to save any additional target specific information
in the @var{struct cl_target_option} structure for function specific
options.
@xref{选项文件格式}.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_RESTORE (struct cl_target_option *@var{ptr})
This hook is called to restore any additional target specific
information in the @var{struct cl_target_option} structure for
function specific options.
@end deftypefn

@deftypefn {Target Hook} void TARGET_OPTION_PRINT (struct cl_target_option *@var{ptr})
This hook is called to print any additional target specific
information in the @var{struct cl_target_option} structure for
function specific options.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_OPTION_PRAGMA_PARSE (target @var{args})
This target hook parses the options for @code{#pragma GCC option} to
set the machine specific options for functions that occur later in the
input stream.  The options should be the same as handled by the
@code{TARGET_VALID_OPTION_ATTRIBUTE_P} hook.
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CAN_INLINE_P (tree @var{caller}, tree @var{callee})
This target hook returns @code{false} if the @var{caller} function
cannot inline @var{callee}, based on target specific information.  By
default, inlining is not allowed if the callee function has function
specific target options and the caller does not use the same options.
@end deftypefn

@node 模拟TLS
@section 模拟TLS
@cindex Emulated TLS

For targets whose psABI does not provide Thread Local Storage via
specific relocations and instruction sequences, an emulation layer is
used.  A set of target hooks allows this emulation layer to be
configured for the requirements of a particular target.  For instance
the psABI may in fact specify TLS support in terms of an emulation
layer.

The emulation layer works by creating a control object for every TLS
object.  To access the TLS object, a lookup function is provided
which, when given the address of the control object, will return the
address of the current thread's instance of the TLS object.

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_GET_ADDRESS
Contains the name of the helper function that uses a TLS control
object to locate a TLS instance.  The default causes libgcc's
emulated TLS helper function to be used.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_REGISTER_COMMON
Contains the name of the helper function that should be used at
program startup to register TLS objects that are implicitly
initialized to zero.  If this is @code{NULL}, all TLS objects will
have explicit initializers.  The default causes libgcc's emulated TLS
registration function to be used.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_SECTION
Contains the name of the section in which TLS control variables should
be placed.  The default of @code{NULL} allows these to be placed in
any section.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_SECTION
Contains the name of the section in which TLS initializers should be
placed.  The default of @code{NULL} allows these to be placed in any
section.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_PREFIX
Contains the prefix to be prepended to TLS control variable names.
The default of @code{NULL} uses a target-specific prefix.
@end deftypevr

@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_PREFIX
Contains the prefix to be prepended to TLS initializer objects.  The
default of @code{NULL} uses a target-specific prefix.
@end deftypevr

@deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_FIELDS (tree @var{type}, tree *@var{name})
Specifies a function that generates the FIELD_DECLs for a TLS control
object type.  @var{type} is the RECORD_TYPE the fields are for and
@var{name} should be filled with the structure tag, if the default of
@code{__emutls_object} is unsuitable.  The default creates a type suitable
for libgcc's emulated TLS function.
@end deftypefn

@deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_INIT (tree @var{var}, tree @var{decl}, tree @var{tmpl_addr})
Specifies a function that generates the CONSTRUCTOR to initialize a
TLS control object.  @var{var} is the TLS control object, @var{decl}
is the TLS object and @var{tmpl_addr} is the address of the
initializer.  The default initializes libgcc's emulated TLS control object.
@end deftypefn

@deftypevr {Target Hook} {bool} TARGET_EMUTLS_VAR_ALIGN_FIXED
Specifies whether the alignment of TLS control variable objects is
fixed and should not be increased as some backends may do to optimize
single objects.  The default is false.
@end deftypevr

@deftypevr {Target Hook} {bool} TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS
Specifies whether a DWARF @code{DW_OP_form_tls_address} location descriptor
may be used to describe emulated TLS control objects.
@end deftypevr

@node MIPS协处理器
@section 定义MIPS target的协处理器的规范
@cindex MIPS coprocessor-definition macros

MIPS规范允许MIPS的实现最多具有4个协处理器，其中每个最多具有32个私有寄存器。
GCC支持使用汇编形式的变量对这些寄存器的访问，寄存器以及内存间的传值。例如：

@smallexample
  register unsigned int cp0count asm ("c0r1");
  unsigned int d;

  d = cp0count + 3;
@end smallexample

(“c0r1”是协处理器0的寄存器1的缺省名；可以按照下面的描述来增加可选名字，
或者可以通过@code{SUBTARGET_CONDITIONAL_REGISTER_USAGE}来覆写全部的缺省名字。)

协处理器寄存器被假设为epilogue-used；对它们的赋值将被保存，
即使在函数中的后面不会再使用该寄存器。

另一个需要注意的是：根据MIPS spec，协处理器1（如果存在）为FPU。
标准mips浮点支持的对COP1寄存器的访问，不包含在这个机制中。

下面描述的一个宏，用于定义MIPS协处理器接口，
可能在子目标（subtarget）中需要被覆写。

@defmac ALL_COP_ADDITIONAL_REGISTER_NAMES
一个逗号分隔的列表（起始于逗号），是用于描述可选的协处理器寄存器的名字对。
每项的格式应该为
@smallexample
@{ @var{alternatename}, @var{register_number}@}
@end smallexample
缺省情况: 空
@end defmac

@node PCH Target
@section 预编译头文件有效性检查的参数
@cindex parameters, precompiled headers

@deftypefn {Target Hook} void *TARGET_GET_PCH_VALIDITY (size_t *@var{sz})
该钩子返回@code{TARGET_PCH_VALID_P}所需要的数据，
并且将@samp{*@var{sz}}设为以字节为单位的数据大小。
@end deftypefn

@deftypefn {Target Hook} const char *TARGET_PCH_VALID_P (const void *@var{data}, size_t @var{sz})
该钩子检查用于创建PCH文件的选项是否与现在的设置兼容。
如果是则返回@code{NULL}，否则为一个适当的错误消息。
错误消息将会展现给用户，所以必须使用@samp{_(@var{msg})}来本地化。

@var{data}为当PCH文件被创建时，@code{TARGET_GET_PCH_VALIDITY}所返回的数据，
@var{sz}为以字节为单位的数据大小。是可以假设data由同一版本的编译器所创建的，
所以不需要格式检查。

@code{default_pch_valid_p}的缺省定义应该适合于大多数target。
@end deftypefn

@deftypefn {Target Hook} const char *TARGET_CHECK_PCH_TARGET_FLAGS (int @var{pch_flags})
如果该钩子为非空，
则@code{TARGET_PCH_VALID_P}的缺省实现将用它来检查@code{target_flags}的兼容值。
@var{pch_flags}指定了当PCH文件被创建时，@code{target_flags}所具有的值。
返回值与@code{TARGET_PCH_VALID_P}的相同。
@end deftypefn

@node C++ ABI
@section C++ ABI参数
@cindex parameters, c++ abi

@deftypefn {Target Hook} tree TARGET_CXX_GUARD_TYPE (void)
定义该钩子来覆盖用于guard变量的整数类型。
这些被用于实现静态对象的一次构建。缺省为long_long_integer_type_node。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_GUARD_MASK_BIT (void)
该钩子确定如何使用guard变量。如果第一个字节应该被使用，
则应该返回@code{false}（缺省）。返回值为@code{true}表明应该使用最低有效位。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_CXX_GET_COOKIE_SIZE (tree @var{type})
该钩子返回cookie的大小，其中cookie为当分配一个数组其元素具有@var{type}类型，
所使用的cookie。假设已经知道需要一个cookie。
缺省为@code{max(sizeof (size_t), alignof(type))}，
在2.7节IA64/Generic C++ ABI中定义。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_COOKIE_HAS_SIZE (void)
该钩子应该返回@code{true}，如果元素大小应该被存放在数组cookie中。
缺省为返回@code{false}。
@end deftypefn

@deftypefn {Target Hook} int TARGET_CXX_IMPORT_EXPORT_CLASS (tree  @var{type}, int @var{import_export})
如果后端定义了该钩子，则允许覆盖对导出类@var{type}的决定。
@var{import_export}将包含1，如果类将被导出，@minus{}1如果其将被导入，否则为0.
该函数应该返回修改后的值，并执行其它需要的操作来支持后端的操作系统。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_CDTOR_RETURNS_THIS (void)
该钩子应该返回@code{true}，如果构造者和析构者返回创建/销毁对象的地址。
缺省为返回@code{false}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_KEY_METHOD_MAY_BE_INLINE (void)
该钩子返回真，如果类的关键方法（即，如果方法在当前转换单元中定义，
其使得虚拟表被输出）可以为内联函数。对于标准的Itanium C++ ABI，
关键方法可以为内联函数，只要函数不在类定义中声明为内联的。
其它ABI的变体中，内联函数不能为关键方法。缺省为返回@code{true}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY (tree @var{decl})
@var{decl}为虚拟表，类型信息对象，或其它类似的隐含类数据对象，
其将在该转换单元中作为外部链接被输出。ELF的可视性不会被显示的指定。
如果target需要指定可视性，
可以使用该钩子来设置@code{DECL_VISIBILITY}和@code{DECL_VISIBILITY_SPECIFIED}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT (void)
该钩子返回真（缺省情况）如果虚拟表和其它类似的隐式类数据对象总是为COMDAT，
如果它们具有外部连接。如果该钩子返回假，
则只在一个转换单元中被输出的虚拟表的类的类数据将不是COMDAT。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_LIBRARY_RTTI_COMDAT (void)
该钩子返回真（缺省情况），
如果在C++运行时定义的基本类型的RTTI信息应该总是为COMDAT，否则为假。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_USE_AEABI_ATEXIT (void)
该钩子返回真，
如果@code{__aeabi_atexit}（如被ARM EABI定义）应该用于注册静态析构者，
当@option{-fuse-cxa-atexit}为有效时。缺省是返回假，使用@code{__cxa_atexit}。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT (void)
该钩子返回真，
如果target的@code{atexit}函数可以跟@code{__cxa_atexit}一样被用于注册静态析构者。
这要求在共享库中@code{atexit}注册的函数要按照正确的顺序运行，当库被卸载时。
缺省为返回假。
@end deftypefn

@deftypefn {Target Hook} void TARGET_CXX_ADJUST_CLASS_AT_DEFINITION (tree @var{type})
@var{type}为一个刚被定义的C++类（即RECORD_TYPE 或 UNION_TYPE）。
使用该钩子来调整类（例如tweak可视性或者执行其它target需要的修改）。
@end deftypefn

@node 其它
@section 其它参数
@cindex parameters, miscellaneous

@c prevent bad page break with this line
这是一些其它参数。

@defmac HAS_LONG_COND_BRANCH
定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的条件分支转换为无条件分支或间接跳转。
@end defmac

@defmac HAS_LONG_UNCOND_BRANCH
定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的无条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的无条件分支转换为间接跳转。
@end defmac

@defmac CASE_VECTOR_MODE
机器模式名字的一个别名。这是跳转表（jump-table）的元素应该具有的机器模式。
@end defmac

@defmac CASE_VECTOR_SHORTEN_MODE (@var{min_offset}, @var{max_offset}, @var{body})
可选的：当最小值和最大值位移已知时，返回@code{addr_diff_vec}的首选机器模式。
如果定义了该宏，这使得在分支缩短中增加了额外的代码来处理@code{addr_diff_vec}。
要使其工作，还必须要定义@code{INSN_ALIGN}，
并且显示的对@code{addr_diff_vec}进行对齐。参数@var{body}被提供，
使得可以更新@code{offset_unsigned}和标量标记。
@end defmac

@defmac CASE_VECTOR_PC_RELATIVE
定义该宏为一个C表达式，来指示跳转表什么时候应该包含相对地址。
你不需要定义该宏，如果跳转表从来不包含相对地址，
或者跳转表只在@option{-fPIC}或者@option{-fPIC}有效时才包含相对地址。
@end defmac

@defmac CASE_VALUES_THRESHOLD
定义其为一个最小差值数，用于选择是使用跳转表来替代条件分支树。
缺省为4，对于具有@code{casesi}指令的机器，其它的为5。这对大多数机器是最好的。
@end defmac

@defmac CASE_USE_BIT_TESTS
定义该宏为一个C表达式，来指示C switch语句是否可以通过位测试序列来实现。
这在可以通过寄存器中的位数来有效实现左移1位的处理器上很有利，
但不适合需要循环的target。缺省下，该宏返回@code{true}，
如果target定义了@code{ashlsi3}指令模式，否则返回@code{false}。
@end defmac

@defmac WORD_REGISTER_OPERATIONS
定义该宏，如果整数机器模式的小于一个字的寄存器间的运算总是在整个寄存器中执行。
大多数RISC机器具有这个属性，大多数CISC机器不具有。
@end defmac

@defmac LOAD_EXTEND_OP (@var{mem_mode})
定义该宏为一个C表达式，
指示当insn使用比一个字窄的的整数模式的@var{mem_mode}模式读取内存时，
将读取的数据的@var{mem_mode}外的位进行符号扩展或者零扩展。
返回@code{SIGN_EXTEND}，对于那些要符号扩展的insn，
返回@code{ZERO_EXTEND}对那些零扩展的，对于其它的机器模式返回@code{UNKNOWN}。

该宏不会被非整型的，或者宽度大于等于@code{BITS_PER_WORD}的@var{mem_mode}调用，
所以对于这种情况你可以返回任何值。如果总是返回@code{UNKNOWN}，则不要定义该宏。
在定义该宏的机器上，你通常要定义其为常量@code{SIGN_EXTEND}或者@code{ZERO_EXTEND}。

你可以返回一个非@code{UNKNOWN}的值，即使对于一些硬件寄存器并没有执行符号扩展，如果对于这些硬件寄存器的@code{REGNO_REG_CLASS}，当@var{from}机器模式为@var{mem_mode}，并且@var{to}机器模式为任何大于其但是不大于@code{word_mode}的整形机器模式的时候，@code{CANNOT_CHANGE_MODE_CLASS}返回非零。

你必须返回@code{UNKNOWN}，如果一些硬件寄存器允许该机器模式，@code{CANNOT_CHANGE_MODE_CLASS}说它们不能变成@code{word_mode}，但是它们可以变成其它大于@var{mem_mode}且仍然小于@code{word_mode}的整形机器模式。
@end defmac

@defmac SHORT_IMMEDIATES_SIGN_EXTEND
定义该宏，如果将short立即数加载到寄存器中要进行符号扩展。
@end defmac

@defmac FIXUNS_TRUNC_LIKE_FIX_TRUNC
定义该宏，如果将浮点数转换为有符号定点数的指令，
同样可以有效的转换为无符号的。
@end defmac

@deftypefn {Target Hook} int TARGET_MIN_DIVISIONS_FOR_RECIP_MUL (enum machine_mode @var{mode})
当@option{-ffast-math}有效时，GCC尝试使用相同的除数来优化除法，
通过将它们转换为乘以倒数的方式。
缺省实现返回3，如果机器具有除法指令，否则为2。
@end deftypefn

@defmac MOVE_MAX
单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
@end defmac

@defmac MAX_MOVE_MAX
单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
如果没有定义，则缺省为@code{MOVE_MAX}。
否则，其为@code{MOVE_MAX}在运行时可以具有的最大常数值。
@end defmac

@defmac SHIFT_COUNT_TRUNCATED
一个C表达式，为非零，如果在该机器上，实际用于计算移位运算的位数等同于，用来表示被移位的对象大小的位数。当该宏为非零的时候，编译器将假设可以安全的忽略掉对移位运算的计数进行截取的有符号扩展，零扩展和按位与指令。在一些机器上，具有指令可以作用于可变位置的位域，其可能会包含‘位测试’指令，非零的@code{SHIFT_COUNT_TRUNCATED}还可以使得作为位域指令参数的值的截取运算。

如果指令会截取计数（对于位移运算）和位置（对于位域运算），或者如果没有可变位置的位域指令存在，则你应该定义该宏。

然而，在一些机器上，例如80386和680x0，截取操作只应用在移位运算上，而不在位域运算上。在这样的机器上，定义@code{SHIFT_COUNT_TRUNCATED}为零。可替代的，在@file{md}文件中增加指令模式，包含对移位指令隐式的截取操作。

如果其值总是为零，则不需要定义该宏。
@end defmac

@anchor{TARGET_SHIFT_TRUNCATION_MASK}
@deftypefn {Target Hook} int TARGET_SHIFT_TRUNCATION_MASK (enum machine_mode @var{mode})
该函数描述了标准的移位指令模式，对于@var{mode}，如何处理负的数量或者大于机器模式宽度的数量的移位。
@xref{shift patterns}.

在许多机器上，移位指令模式将会应用一个掩码@var{m}到移位计数上，意味着将@var{x}固定宽度移位@var{y}等价于对@var{x}任意宽度移位@var{y & m}。如果这对机器模式@var{mode}为真，则函数应该返回@var{m}，否则应该返回0。返回值0意味着不保证特定的行为。

注意，不像@code{SHIFT_COUNT_TRUNCATED}，该函数不应用到通用的移位rtx上；其只应用到由命名移位指令模式生成的指令上。

该函数的缺省实现返回@code{GET_MODE_BITSIZE (@var{mode}) - 1}，如果@code{SHIFT_COUNT_TRUNCATED}，否则为0。该定义总是安全的，但是如果@code{SHIFT_COUNT_TRUNCATED}为假，并且一些移位指令模式还是截取移位计数，则你可以通过重写覆盖该宏来获得更好的代码。
@end deftypefn

@defmac TRULY_NOOP_TRUNCATION (@var{outprec}, @var{inprec})
一个C表达式，其为非零，如果在该机器上，将@var{inprec}个位数的整数转换成@var{outprec}个位数（@var{outprec}比@var{inprec}小），通过简单的认为其只具有@var{outprec}个位。

在许多机器上，该表达式可以为1。
@end defmac

@deftypefn {Target Hook} int TARGET_MODE_REP_EXTENDED (enum machine_mode @var{mode}, enum machine_mode @var{rep_mode})
整型机器模式可以表示为一个值，其总是被扩展为更宽的整型模式。返回@code{SIGN_EXTEND}，如果机器模式为@var{mode}的值被表示为有符号扩展成@var{rep_mode}的形式。否则，返回@code{UNKNOWN}。（目前，没有目标机使用零扩展表示，所以不像@code{LOAD_EXTEND_OP}，@code{TARGET_MODE_REP_EXTENDED}被期望返回@code{SIGN_EXTEND}或者@code{UNKNOWN}。而且没有目标机将@var{mode}扩展为@var{mode_rep}，以至于@var{mode_rep}不是下一个最宽的整型机器模式，目前，我们利用了这个事实。）

类似于@code{LOAD_EXTEND_OP}，你可以返回一个非@code{UNKNOWN}的值，即使扩展在特定硬件寄存器上没有被执行，只要对于这些硬件寄存器的@code{REGNO_REG_CLASS}，@code{CANNOT_CHANGE_MODE_CLASS}返回非零。

注意，@code{TARGET_MODE_REP_EXTENDED}和@code{LOAD_EXTEND_OP}描述了两个相关联的属性。如果你定义了@code{TARGET_MODE_REP_EXTENDED (mode, word_mode)}，你可能还要定义@code{LOAD_EXTEND_OP (mode)}，来返回相同类型的扩展。

为了加强@code{mode}的表示，当截取成@code{mode}时，@code{TRULY_NOOP_TRUNCATION}应该返回假。
@end deftypefn

@defmac STORE_FLAG_VALUE
一个C表达式，描述了整型机器模式的比较运算符返回的值，并且当条件为真时由存储标记指令(@samp{s@var{cond}})存储。该描述必须应用到所有的@samp{s@var{cond}}指令模式，并且所有比较运算的结果必须具有@code{MODE_INT}机器模式。

值为1或者-1，意味着实现比较运算的指令当比较为真时返回确切的1或者-1，当比较为假时返回0。否则，值会表示当比较为真时结果的哪些位保证为1。该值按照比较运算的机器模式来解析，其由@samp{s@var{cond}}指令模式中的第一个操作数的机器模式给出。目前，编译器只用到了@code{STORE_FLAG_VALUE}的低位或者符号位。

如果@code{STORE_FLAG_VALUE}不为1或者-1，则编译器将生成只依赖特定位的代码。其还可以用等价的运算来替换比较运算，如果它们会造成需要的位被设置，即使其它位没有被定义。例如，在比较运算返回一个@code{SImode}值的机器上，其@code{STORE_FLAG_VALUE}被定义为@samp{0x80000000}，说明只有符号位是相关的，表达式

@smallexample
(ne:SI (and:SI @var{x} (const_int @var{power-of-2})) (const_int 0))
@end smallexample

@noindent
可以被转换为

@smallexample
(ashift:SI @var{x} (const_int @var{n}))
@end smallexample

@noindent
其中@var{n}为适当的移位计数，用来将被测试的位移送到符号位。

没有办法来描述，一个机器对于真值，总是设置低顺序的位，而不保证其它位的值。但是，我们不知道是否有机器具有这样的指令。如果你正在尝试将GCC移植到这样的机器上，那么可以在比较运算的指令模式中，包含一条指令来执行将结果和1进行逻辑与，并且通过@email{gcc@@gcc.gnu.org}让我们知道。

通常，机器将具有多个指令，从比较（或者条件代码）中获得一个值。这里有一些规则用来指导对@code{STORE_FLAG_VALUE}的值的选择，以及要使用的指令：

@itemize @bullet
@item
使用最短的序列，产生@code{STORE_FLAG_VALUE}的有效定义。对编译器来说，将值正常化（例如，将其转成1或者0）要比进行比较运算更有效，因为可能会有一些机会来合并其它的正常化运算。

@item
对于等长的序列，使用值1或者－1。在跳转代价比较高的机器上，一般会倾向于－1，其它一些机器喜欢用1。

@item
作为第二种选择，选择值@samp{0x80000001}，如果存在指令，同时设置符号位和低顺序位，但是不定义其它位。

@item
否则，使用值@samp{0x80000000}。
@end itemize

许多机器可以同时产生供@code{STORE_FLAG_VALUE}选择的值，以及同样数量指令的取反。在那些机器上，你应该还定义这些情况的指令模式，例如，

@smallexample
(set @var{A} (neg:@var{m} (ne:@var{m} @var{B} @var{C})))
@end smallexample

一些机器还可以在条件代码值上，执行@code{and}或者@code{plus}运算，使用少于相应的@samp{s@var{cond}} insn后跟随@code{and}或者@code{plus}的指令数目。在这些机器上，需要定义适当的指令模式。分别使用名字@code{incscc}和@code{decscc}，对于在条件代码值上执行@code{plus}或者@code{minus}运算的指令模式。参见@file{rs6000.md}中的一些例子。可以使用GNU Superoptizer来在其它机器上查找这样的指令序列。

如果该宏没有被定义，则使用缺省的值1。你不需要定义@code{STORE_FLAG_VALUE}，如果机器没有存储标记的指令，或者如果这些指令生成的值为1。
@end defmac

@defmac FLOAT_STORE_FLAG_VALUE (@var{mode})
一个C表达式，给出一个非零的@code{REAL_VALUE_TYPE}值，当浮点比较运算的结果为真时返回该值。在一些机器上，具有返回浮点值的比较运算，可以定义该宏。如果没有这样的运算，则不要定义该宏。
@end defmac

@defmac VECTOR_STORE_FLAG_VALUE (@var{mode})
一个C表达式，给出一个rtx，表示向量比较中非零的真元素。返回的rtx应该对于@var{mode}的内部机器模式是有效的，@var{mode}为一个向量机器模式。定义该宏，在一些机器上，具有返回向量结果的向量比较运算。如果没有这样的运算，则不要定义该宏。通常，该宏被定义为@code{const1_rtx}或者@code{constm1_rtx}。该宏可以返回@code{NULL_RTX}，来阻止编译器优化给定的机器模式的向量比较运算。
@end defmac

@defmac CLZ_DEFINED_VALUE_AT_ZERO (@var{mode}, @var{value})
@defmacx CTZ_DEFINED_VALUE_AT_ZERO (@var{mode}, @var{value})
一个C表达式，指示体系机构是否为@code{clz}或者@code{ctz}在操作数为零时，定义了值。结果为@code{0}，表示值未被定义。如果值只被定义为RTL表达式，则宏应该求值为@code{1}；如果还应用到相应的optab项（其通常情况为直接扩展为相应的RTL），则宏应该求值为@code{2}。在值被定义的情况下，@var{value}应该被设置为该值。

如果该宏没有被定义，则@code{clz}或者@code{ctz}在操作数为零时，被认为未定义。

该宏必须被定义，如果目标机对@code{ffs}的扩展，依赖于特定的值，以获得正确的结果。否则，没有必要，虽然其可以用于优化一些边角的情况，并且为@code{ffs} optab提供缺省的扩展。

注意，不论该宏是否定义，@code{clz}和@code{ctz}在操作数为0时的定义，都不会被扩展为用户可见的内建函数。因此，可以任意调整该值，来匹配对这些运算的目标机扩展，而无需担心会破坏API。
@end defmac

@defmac Pmode
指针的机器模式别名。在大多数机器上，定义该宏为整型机器模式，对应于硬件指针宽度；32位机器上为@code{SImode}，64位机器上为@code{DImode}。在一些机器上，你必须定义该宏为部分整型机器模式，例如@code{PSImode}。

@code{Pmode}的宽度必须至少与@code{POINTER_SIZE}的值一样大。如果不相等，你必须定义宏@code{POINTERS_EXTEND_UNSIGNED}来描述指针如何被扩展为@code{Pmode}。
@end defmac

@defmac FUNCTION_MODE
机器模式的别名，在@code{call} RTL表达式中，用于被调用函数的内存引用。在大多数CISC机器上，指令可以起始于任意字节地址，这应该为@code{QImode}。在大多RISC机器上，所有的指令都具有固定的大小和对齐方式，这应该为与机器指令字具有相同大小和对齐的机器模式，通常为@code{SImode}或者@code{HImode}。
@end defmac

@defmac STDC_0_IN_SYSTEM_HEADERS
正常的操作中，预处理器会将@code{__STDC__}扩展为常量1，来表明GCC遵循ISO标准C。在一些主机上，例如Solaris，系统编译器使用不同的约定，@code{__STDC__}通常为0，但是如果用户指出要严格遵循C标准时为1。

定义@code{STDC_0_IN_SYSTEM_HEADERS}使得GNU CPP遵循主机的约定，当处理系统头文件时，但是，当处理用户文件时@code{__STDC__}将总是被扩展为1。
@end defmac

@defmac NO_IMPLICIT_EXTERN_C
定义该宏，如果系统头文件支持C++，也支持C。该宏抑制了通常在C++中使用系统头文件的方法，即假设文件的内容包含在@samp{extern "C" @{@dots{}@}}中。
@end defmac

@findex #pragma
@findex pragma
@defmac REGISTER_TARGET_PRAGMAS ()
定义该宏，如果你想实现任何目标机特定的pragma。如果被定义，其为一个C表达式，为每个pragma使用一系列的对@code{c_register_pragma}或者@code{c_register_pragma_with_expansion}调用。该宏还可以做任何pragma所要求的设置。

定义该宏的主要原因是提供相同目标机上，与其它编译器的兼容性。大体上，我们不鼓励为GCC定义目标机特定的pragma。

如果pragma可以通过attribute属性来实现，则你也应该考虑定义目标机钩子@samp{TARGET_INSERT_ATTRIBUTES}。

出现在pragma行中的预处理器宏不被扩展。所有不匹配被注册的@samp{#pragma}指令，将被安静的忽略，除非用户指定@option{-Wunknown-pragmas}。
@end defmac

@deftypefun void c_register_pragma (const char *@var{space}, const char *@var{name}, void (*@var{callback}) (struct cpp_reader *))
@deftypefunx void c_register_pragma_with_expansion (const char *@var{space}, const char *@var{name}, void (*@var{callback}) (struct cpp_reader *))

每个对@code{c_register_pragma}或者@code{c_register_pragma_with_expansion}的调用，都建立了一个pragma。当预处理器遇到一个形式为

@smallexample
#pragma [@var{space}] @var{name} @dots{}
@end smallexample

的pragma，则@var{callback}函数将被调用。 

@var{space}为大小写敏感的pragma命名空间，或者为@code{NULL}，将gragma放在全局命名空间中。回调函数接受@var{pfile}作为第一个参数，如果需要其可以被传递给cpplib的函数。你可以通过调用@code{pragma_lex}，来词法分析@var{name}之后的token。没有被回调函数读入的token将被安静的忽略。行尾由类型为@code{CPP_EOF}的token来指示。宏扩展发生在使用@code{c_register_pragma_with_expansion}注册的pragma的参数上，但不在使用@code{c_register_pragma}注册的pragma的参数上。

注意，使用@code{pragma_lex}是特定于C和C++编译器的。其在Java或者Fortran编译器上，或者其它语言编译器上无法工作。因此，如果@code{pragma_lex}准备从目标机特定代码中被调用，其必须只在构建C和C++编译器的时候执行。这可以通过在@file{config.gcc}文件中的目标机项中，定义变量@code{c_target_objs}和@code{cxx_target_objs}来实现。这些变量应该命名目标机特定的，语言特定的对象文件，其包含了使用@code{pragma_lex}的代码。注意，还有必要增加一个规则到由@code{tmake_file}指定的makefile片断中，来显示如何构建该目标文件。
@end deftypefun

@findex #pragma
@findex pragma
@defmac HANDLE_SYSV_PRAGMA
定义该宏（值为1），如果你想gcc支持System V风格的pragma @samp{#pragma pack(<n>)}和@samp{#pragma weak <name> [=<value>]}。

pack pragma描述了结构体中域的最大对齐方式（以字节为单位），很大程度上等同于使用@samp{__aligned__}和@samp{__packed__} @code{__attribute__}。pack值为零，会将行为重置为缺省。

对于目标机支持的微软Visual C/C++风格的位域打包（例如-mms-bitfields），其微妙之处在于：当位域被插入到一个打包了的记录中时，则底层类型的整个大小会被一个或多个相同大小临近的位域使用（也就是说，如果为long:3，则记录会使用32位，任何额外的临近的long位域将被打包到32位块中。然而，如果大小改变了，则会分配一个新的同样大小的域）。

如果MS位域和@samp{__attribute__((packed))}都被使用，则后者优先。如果当在使用MS位域的时候，@samp{__attribute__((packed))}被用于一个单独的域，则对于该域是优先的，但是结构体的其它部分的对齐方式会影响它的放置。

weak pragma只有当@code{SUPPORTS_WEAK}和@code{ASM_WEAKEN_LABEL}被定义时，才工作。如果可用，其允许创建特殊命名的弱标号，以及可选的值。
@end defmac

@findex #pragma
@findex pragma
@defmac HANDLE_PRAGMA_PACK_PUSH_POP
定义该宏（值为1），如果你想支持Win32风格的pragmas @samp{#pragma pack(push[,@var{n}])} and @samp{#pragma pack(pop)}。@samp{pack(push,[@var{n}])} pragma指定结构体内的域的最大对齐方式（按字节），等同于使用@samp{__aligned__} 和 @samp{__packed__} @code{__attribute__}。如果pack值为0，则会将行为重置为缺省情况。连续的调用该pragma会造成先前的值被压栈，所以调用@samp{#pragma pack(pop)}会返回先前的值。
@end defmac

@defmac HANDLE_PRAGMA_PACK_WITH_EXPANSION
定义该宏，以及@code{HANDLE_SYSV_PRAGMA}，如果在@samp{#pragma pack}中的参数宏应该被扩展。
@end defmac

@defmac TARGET_DEFAULT_PACK_STRUCT
如果你的目标机要求结构体缺省的打包方式不是0（意味着机器缺省方式），则定义该宏为必要的值（以字节为单位）。该值必须还对于@samp{#pragma pack()}有效（也就是说，2的小的幂数）。
@end defmac

@findex #pragma
@findex pragma
@defmac HANDLE_PRAGMA_PUSH_POP_MACRO
定义该宏，如果你想支持Win32风格的pragmas @samp{#pragma push_macro(macro-name-as-string)}和@samp{#pragma pop_macro(macro-name-as-string)}。@samp{#pragma push_macro(macro-name-as-string)}用来保存命名的宏，并且通过@samp{#pragma pop_macro(macro-name-as-string)}来返回先前的值。
@end defmac


@defmac DOLLARS_IN_IDENTIFIERS
定义该宏，来控制C语言家族，标识符名字中对字符@samp{$}的使用。0意味着缺省不允许使用@samp{$}；1意味着允许。缺省为1；对于这种情况，不需要定义该宏。
@end defmac

@defmac NO_DOLLAR_IN_LABEL
定义该宏，如果汇编器不接受标号名字中的@samp{$}。缺省的，G++的构造函数和析构函数会在标识符中使用@samp{$}。如果该宏被定义，则使用@samp{.}来替代。
@end defmac

@defmac NO_DOT_IN_LABEL
定义该宏，如果汇编器不接受标号名字中的@samp{.}。缺省的，G++的构造函数和析构函数的名字会使用@samp{.}。如果该宏被定义，则这些名字被重写，以避免出现@samp{.}。
@end defmac

@defmac INSN_SETS_ARE_DELAYED (@var{insn})
定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在@var{insn}的延迟槽中是安全的，即使它们可能会使用@var{insn}设置或者破坏的一个资源。@var{insn}总是一个@code{jump_insn}或者@code{insn}；GCC知道每个@code{call_insn}具有这种行为。在一些机器上，一些@code{insn}或者@code{jump_insn}确实为一个函数调用，因此也具有这种行为，你应该定义该宏。

如果其总是返回零，则不需要定义该宏。
@end defmac

@defmac INSN_REFERENCES_ARE_DELAYED (@var{insn})
定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在@var{insn}的延迟槽中是安全的，即使它们可能会设置或者破坏@var{insn}使用的一个资源。@var{insn}总是一个@code{jump_insn}或者@code{insn}。在一些机器上，一些@code{insn}或者@code{jump_insn}确实为一个函数调用，并且其操作数为寄存器，实际是在其调用的子函数中使用，你应该定义该宏。这使得延迟槽调度器将复制参数到参数寄存器的指令移送到@var{insn}的延迟槽中。

如果其总是返回零，则不需要定义该宏。
@end defmac

@defmac MULTIPLE_SYMBOL_SPACES
定义该宏为一个C表达式，其为非零，如果对于一些情况，没有用户的介入，一个转换单元中的全局符号可能不会被发现为另一个转换单元中的未定义的符号。例如，在Microsoft Windows下，符号必须被从共享库（DLL）中显式的导入。

如果其总是为零，则不需要定义该宏。
@end defmac

@deftypefn {Target Hook} tree TARGET_MD_ASM_CLOBBERS (tree @var{outputs}, tree @var{inputs}, tree @var{clobbers})
该目标钩子将移植平台希望一个asm可以自动破坏的硬件寄存器增加到@var{clobbers} @code{STRING_CST} tree中。其应该返回最后一个用于增加一个破坏者的@code{tree_cons}。@var{outputs}, @var{inputs} 和 @var{clobber}为asm的相应的参数，可以用来检查以避免破坏asm的输入或者输出寄存器。你可以使用@file{tree.h}中声明的@code{tree_overlaps_hard_reg_set}来测试是否与asm声明的寄存器有重叠。
@end deftypefn

@defmac MATH_LIBRARY
定义该宏为一个C字符串常量，为连接器的参数，作为系统数学库连接，或者@samp{""}，如果目标机没有单独的数学库。

只有当缺省的@samp{"-lm"}有错误时，才需要定义该宏。
@end defmac

@defmac LIBRARY_PATH_ENV
定义该宏为一个C字符串常量，为一个环境变量，指定了连接器应该从哪里查找库。

只有当缺省的@samp{"LIBRARY_PATH"}有错误时，才需要定义该宏。
@end defmac

@defmac TARGET_POSIX_IO
定义该宏，如果目标机支持下列POSIX文件函数，access, mkdir和使用fcntl / F_SETLKW的文件加锁。其还在运行时为交叉profiling创建目录。
@end defmac

@defmac MAX_CONDITIONAL_EXECUTE
一个C表达式，为通过条件执行指令来替代分支的最大指令数。值@code{BRANCH_COST}+1为缺省值，如果机器没有使用cc0，如果使用了cc0，则为1。
@end defmac

@defmac IFCVT_MODIFY_TESTS (@var{ce_info}, @var{true_expr}, @var{false_expr})
使用该宏，如果目标机需要在将基本块转为条件执行代码时，对条件进行机器相关的修改。@var{ce_info}指向一个数据结构，@code{struct ce_if_block}，其包含了关于当前被处理的块的信息。@var{true_expr}和@var{false_expr}为测试，分别用于转换then-block和else-block。如果测试不能被转换，则将@var{true_expr}或者@var{false_expr}设置为空指针。
@end defmac

@defmac IFCVT_MODIFY_MULTIPLE_TESTS (@var{ce_info}, @var{bb}, @var{true_expr}, @var{false_expr})
类似于@code{IFCVT_MODIFY_TESTS}，不过用于将更加复杂的if语句转换为由@code{and}和@code{or}运算组合的条件。@var{bb}包含的基本块，包含了当前被处理的测试，并将被转换为一个条件。
@end defmac

@defmac IFCVT_MODIFY_INSN (@var{ce_info}, @var{pattern}, @var{insn})
一个C表达式，来修改@var{INSN}的@var{PATTERN}，其将被转换为一个条件执行的格式。@var{ce_info}指向一个数据结构，@code{struct ce_if_block}，其包含了关于当前被处理的块的信息。
@end defmac

@defmac IFCVT_MODIFY_FINAL (@var{ce_info})
一个C表达式，用来执行在将代码转换为条件执行时，任何最终机器相关的修改。涉及到的基本块可以在由@var{ce_info}指向的@code{struct ce_if_block}结构体中找到。
@end defmac

@defmac IFCVT_MODIFY_CANCEL (@var{ce_info})
一个C表达式，用来取消在将代码转换为条件执行时，任何机器相关的修改。涉及到的基本块可以在由@var{ce_info}指向的@code{struct ce_if_block}结构体中找到。
@end defmac

@defmac IFCVT_INIT_EXTRA_FIELDS (@var{ce_info})
一个C表达式，来初始化任何@code{struct ce_if_block}结构体中额外的域，其通过@code{IFCVT_EXTRA_FIELDS}宏来定义。
@end defmac

@defmac IFCVT_EXTRA_FIELDS
如果被定义，其应该扩展为一个域声明集合，其将被增加到@code{struct ce_if_block}结构体中。这些应该通过@code{IFCVT_INIT_EXTRA_FIELDS}宏来初始化。
@end defmac

@deftypefn {Target Hook} void TARGET_MACHINE_DEPENDENT_REORG ()
如果非空，则该钩子对指令流执行目标机特定的编译过程。编译器将在所有优化级别上执行该过程，就在其通常执行延迟分支调度之前的地方。

该钩子的确切目的因目标机不同而不同。一些用来为了正确性执行必要的转换，例如布局函数常量池，或者避免硬件冒险。其它用来作为机器相关的优化。

如果没有什么可做的，则不需要实现该钩子。缺省定义为空。
@end deftypefn

@deftypefn {Target Hook} void TARGET_INIT_BUILTINS ()
定义该钩子，如果你有任何需要被定义的机器特定的内建函数。其应该为一个函数，执行必要的设置。

机器特定的内建函数可以用于扩展特定的机器指令，否则其通常不会被生成，因为在源语言中没有等价的对应（例如，SIMD向量指令或者预取指令）。

要创建一个内建函数，调用函数@code{lang_hooks.builtin_function}，其由语言前端定义。你可以使用任何由@code{build_common_tree_nodes}和@code{build_common_tree_nodes_2}建立的类型节点；只有使用这两个函数的语言前端会调用@samp{TARGET_INIT_BUILTINS}。
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_EXPAND_BUILTIN (tree @var{exp}, rtx @var{target}, rtx @var{subtarget}, enum machine_mode @var{mode}, int @var{ignore})
扩展由@samp{TARGET_INIT_BUILTINS}建立的对一个机器特定的内建函数的调用。@var{exp}为函数调用的表达式；如果方便的话，结果应该放到@var{target}，并且具有机器模式@var{mode}。@var{subtarget}可以用作目标，来计算@var{exp}的操作数。@var{ignore}为非零，如果值将被忽略。该函数应该返回调用内建函数的结果。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_RESOLVE_OVERLOADED_BUILTIN (tree @var{fndecl}, tree @var{arglist})
为@samp{TARGET_INIT_BUILTINS}建立的机器特定内建函数选择一个替身。这发生在常规的类型检查之前，因此允许目标机来实现函数重载的粗糙形式。@var{fndecl}为内建函数的声明。@var{arglist}为传递给内建函数的参数列表。结果为一个完全表达式，实现了该运算，通常为另一个@code{CALL_EXPR}。
@end deftypefn

@deftypefn {Target Hook} tree TARGET_FOLD_BUILTIN (tree @var{fndecl}, tree @var{arglist}, bool @var{ignore})
将@samp{TARGET_INIT_BUILTINS}建立的机器特定的内建函数的调用进行折叠。@var{fndecl}为内建函数的声明。@var{arglist}为传递给内建函数的参数列表。结果为另一个tree，包含了一个简化的表达式，为调用的结果。如果@var{ignore}为真，则值将被忽略。
@end deftypefn

@deftypefn {Target Hook} const char * TARGET_INVALID_WITHIN_DOLOOP (rtx @var{insn})
接受一个指令@var{insn}，如果其在一个低开销循环中有效，则返回NULL，否则返回一个字符串说明为什么不能应用doloop。

许多目标机使用特定的寄存器，用于低开销循环。对于任何破坏这些的指令，该函数应该返回一个字符串，指出不能应用doloop的原因。缺省的，RTL循环优化不对包含函数调用或者表指令分支的循环，使用现有的doloop指令模式。
@end deftypefn

@defmac MD_CAN_REDIRECT_BRANCH (@var{branch1}, @var{branch2})
接受一个分支insn @var{branch1}和另一个@var{branch2}。返回真，如果将@var{branch1}重定向到@var{branch2}的目的地是可能的。

在一些目标机上，分支可能具有有限的范围。优化延迟槽的填充，可以导致分支可以被重定向，反过来也可能会造成一个分支的偏移量溢出。
@end defmac

@deftypefn {Target Hook} bool TARGET_COMMUTATIVE_P (rtx @var{x}, @var{outer_code})
该目标钩子返回@code{true}，如果@var{x}被认为是可交换的。通常，这就是COMMUTATIVE_P (@var{x})。但是HP PA不认为PLUS在MEM中是可交换的。@var{outer_code}为包含rtl的rtx代码，如果知道，否则为UNKNOWN。
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_ALLOCATE_INITIAL_VALUE (rtx @var{hard_reg})
当硬件寄存器的初始值已经被复制到伪寄存器中，通常没有必要为该伪寄存器分配另一个寄存器，因为可以使用原始的硬件寄存器或者被保存到的栈槽。在寄存器分配的起始处，@code{TARGET_ALLOCATE_INITIAL_VALUE}针对每个其初始值使用@code{get_func_hard_reg_initial_val}或者@code{get_hard_reg_initial_val}复制过的，硬件寄存器被调用一次。可能的值为，@code{NULL_RTX}如果你不想做任何特殊的分配，一个@code{REG} rtx——其通常为硬件寄存器本身，如果知道其不会被破坏——或者一个@code{MEM}。如果返回一个@code{MEM}，这只是一个给分配器的提示；其仍然有可能会决定用另一个寄存器。你可以在钩子中使用@code{current_function_leaf_function}，用来确定被询问的硬件寄存器是否会被破坏。该钩子的缺省值为@code{NULL}，其禁止了任何特殊的分配。
@end deftypefn

@deftypefn {Target Hook} int TARGET_UNSPEC_MAY_TRAP_P (const_rtx @var{x}, unsigned @var{flags})
该目标钩子返回非零，如果@var{x}，一个@code{unspec}或者@code{unspec_volatile}运算，可能会造成一个陷阱。目标机可以使用该钩子来加强对@code{unspec}和@code{unspec_volatile}运算的分析的精确性。你可以调用@code{may_trap_p_1}来分析@var{x}的内部元素，这种情况下，也应该传递@var{flags}。
@end deftypefn

@deftypefn {Target Hook} void TARGET_SET_CURRENT_FUNCTION (tree @var{decl})
编译器每当改变当前函数上下文(@code{cfun})时，便会调用该钩子。你可以定义该函数，如果后端需要基于每个函数执行任何初始化或者重置行为。例如，其可以用来实现函数属性，影响寄存器的使用或者代码生成指令模式。参数@var{decl}为新的函数上下文的声明，可以为空，表示编译器已经离开函数上下文，要返回顶层去处理。缺省钩子函数不做任何事情。

GCC将@code{cfun}设置为一个哑的函数上下文，在初始化后端一些部分的时候。钩子函数在这种情况下不会被调用；你不需要担心钩子函数被递归调用，或者当后端处于部分初始化的状态。
@end deftypefn

@defmac TARGET_OBJECT_SUFFIX
定义该宏为C字符串，表示在你的目标机器上，对象文件的后缀。如果没有定义该宏，则GCC会使用@samp{.o}作为目标文件的后缀。
@end defmac

@defmac TARGET_EXECUTABLE_SUFFIX
定义该宏为C字符串，表示在你的目标机器上，为可执行文件自动增加的后缀。如果没有定义该宏，GCC将为可执行文件使用空字符串作为后缀。
@end defmac

@defmac COLLECT_EXPORT_LIST
如果被定义，@code{collect2}将在其命令行中扫描单独的目标文件，并为连接器创建一个导出列表。为AIX这样的系统定义该宏，并使用导出列表，其连接器会丢弃没有从@code{main}中引用的对象文件。
@end defmac

@defmac MODIFY_JNI_METHOD_CALL (@var{mdecl})
定义该宏为一个C表达式，表示方法调用@var{mdecl}的一个变种，如果Java Native Interface (JNI)方法必须通过你目标机上其它方法来调用。例如，在32位Microsoft Windows上，JNI方法必须使用@code{stdcall}调用约定来调用，该宏则被定义为如下表达式：

@smallexample
build_type_attribute_variant (@var{mdecl},
                              build_tree_list
                              (get_identifier ("stdcall"),
                               NULL))
@end smallexample
@end defmac

@deftypefn {Target Hook} bool TARGET_CANNOT_MODIFY_JUMPS_P (void)
该目标钩子在一个点之后返回@code{true}，该处应该创建新的跳转指令。在一些机器上，对每个跳转都要求使用寄存器，例如SH5的SHmedia ISA，该点通常为重载，所以该目标钩子应该被定义为这样的函数：

@smallexample
static bool
cannot_modify_jumps_past_reload_p ()
@{
  return (reload_completed || reload_in_progress);
@}
@end smallexample
@end deftypefn

@deftypefn {Target Hook} int TARGET_BRANCH_TARGET_REGISTER_CLASS (void)
该目标钩子返回一个寄存器类，分支目标寄存器优化将会应用在该类别上。该类别中的所有寄存器应该是可以互换使用的。重载之后，该类别中的寄存器将被重新分配，并且加载将被悬挂在循环之外，从属于块间调度。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED (bool @var{after_prologue_epilogue_gen})
分支目标寄存器优化，缺省的会将，被调用者保存的寄存器排除在外，其在当前函数中已经是不活跃的。如果目标钩子返回真，它们将被包含进来。目标代码必须确保在由@samp{TARGET_BRANCH_TARGET_REGISTER_CLASS}返回的类别中的所有寄存器，如果需要保存的，会被保存。@var{after_prologue_epilogue_gen}指出是否序言和尾声已经被生成。注意，即使你只当@var{after_prologue_epilogue_gen}为假时返回真，你还可能要在@code{INITIAL_ELIMINATION_OFFSET}做出特定的预防，来为调用者保存的目标寄存器保留空间。
@end deftypefn

@defmac POWI_MAX_MULTS
如果被定义，该宏被解析为一个有符号整型C表达式，描述了浮点乘法的最大数。
@end defmac

@deftypefn Macro void TARGET_EXTRA_INCLUDES (const char *@var{sysroot}, const char *@var{iprefix}, int @var{stdinc})
该钩子用于记录目标机的任何额外的include文件。参数@var{stdinc}指示是否存在通常的include文件。参数@var{sysroot}为系统根目录。参数@var{iprefix}为gcc目录的前缀。
@end deftypefn

@deftypefn Macro void TARGET_EXTRA_PRE_INCLUDES (const char *@var{sysroot}, const char *@var{iprefix}, int @var{stdinc})
该钩子用于记录目标机的任何先于标准头文件之前的include文件。参数@var{stdinc}指示是否存在通常的include文件。参数@var{sysroot}为系统根目录。参数@var{iprefix}为gcc目录的前缀。
@end deftypefn

@deftypefn Macro void TARGET_OPTF (char *@var{path})
该目标机钩子用来记录目标机特殊的include路径。参数@var{path}为要记录的include。在Darwin系统上，被用于Framework include，其语义与@option{-I}有所不同。
@end deftypefn

@deftypefn {Target Hook} bool TARGET_USE_LOCAL_THUNK_ALIAS_P (tree @var{fndecl})
该目标机钩子返回@code{true}，如果当为虚函数构造thunk时，使用局部别名是安全的，否则为@code{false}。缺省的，钩子对所有函数返回@code{true}，如果目标机支持别名（即：定义了@code{ASM_OUTPUT_DEF}），否则@code{false}。
@end deftypefn

@defmac TARGET_FORMAT_TYPES
如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式检查信息，针对@option{-Wformat}选项。缺省为没有目标机特定的格式检查。
@end defmac

@defmac TARGET_N_FORMAT_TYPES
如果被定义，则该宏为@code{TARGET_FORMAT_TYPES}中的项数。
@end defmac

@defmac TARGET_OVERRIDES_FORMAT_ATTRIBUTES
如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式，用来覆盖@option{-Wformat}选项。缺省为没有目标机特定的格式覆盖。如果被定义，则@code{TARGET_FORMAT_TYPES}也必须被定义。
@end defmac

@defmac TARGET_OVERRIDES_FORMAT_ATTRIBUTES_COUNT
如果被定义，该宏描述@code{TARGET_OVERRIDES_FORMAT_ATTRIBUTES}中的项数。
@end defmac

@defmac TARGET_OVERRIDES_FORMAT_INIT
如果被定义，则该宏描述可选的初始化程序，用于目标机特定的系统printf和scanf格式设置。
@end defmac

@deftypefn {Target Hook} bool TARGET_RELAXED_ORDERING
如果设置为@code{true}，则意味着目标机的内存模型不保证，没有依赖关系的加载操作会按照指令流的顺序来访问主存；如果顺序很重要，那么必须使用显式的内存栅栏。这对许多现在的处理器是这样的，例如Alpha, PowerPC和ia64，其实现了关于内存一致性的``relaxed,'' ``weak,'' 或 ``release''策略。缺省为@code{false}。
@end deftypefn

@deftypefn {Target Hook} const char *TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN (tree @var{typelist}, tree @var{funcdecl}, tree @var{val})
如果被定义，则当传递参数@var{val}给函数原型为@var{typelist}的函数@var{funcdecl}是非法的时候，该宏会返回诊断信息。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_CONVERSION (tree @var{fromtype}, tree @var{totype})
如果被定义，则当从@var{fromtype}转换成@var{totype}是无效的时候，该宏会返回诊断信息，或者返回@code{NULL}，如果有效性应该由前端来确定。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_UNARY_OP (int @var{op}, tree @var{type})
如果被定义，则当在类型为@var{type}的操作数上执行@var{op}（一元的加号通过@code{CONVERT_EXPR}来表示）是无效的时候，该宏会返回诊断信息，或者返回@code{NULL}，如果有效性应该由前端来确定。
@end deftypefn

@deftypefn {Target Hook} {const char *} TARGET_INVALID_BINARY_OP (int @var{op}, tree @var{type1}, tree @var{type2})
如果被定义，则当在类型为@var{type1}和@var{type2}的操作数上执行@var{op}是无效的时候，该宏会返回诊断信息，或者返回@code{NULL}，如果有效性应该由前端来确定。
@end deftypefn

@defmac TARGET_USE_JCR_SECTION
该宏定义是否使用JCR段来记录Java类。缺省的，如果SUPPORTS_WEAK和TARGET_HAVE_NAMED_SECTIONS都为真，则TARGET_USE_JCR_SECTION被定义为1，否则为0。
@end defmac

@defmac OBJC_JBLEN
该宏为NeXT运行时，确定objective C跳转缓存的大小。缺省的，OBJC_JBLEN被定义为一个无害的值。
@end defmac

@defmac LIBGCC2_UNWIND_ATTRIBUTE
定义该宏，如果对于@file{libgcc}中那些为调用栈展开（call stack unwinding）提供低级别支持的函数上，需要附加目标机特定的属性时。其被用在@file{unwind-generic.h}中的声明和那些函数相关的定义中。
@end defmac

@deftypefn {Target Hook} void TARGET_UPDATE_STACK_BOUNDARY (void)
如果需要，定义该宏来更新当前函数栈边界。
@end deftypefn

@deftypefn {Target Hook} rtx TARGET_GET_DRAP_RTX (void)
定义该宏为动态重对齐参数指针（Dynamic Realign Argument Pointer）的rtx，如果当栈被对齐时，需要用不同的参数指针寄存器来访问函数的参数列表。
@end deftypefn

@deftypefn {Target Hook} {bool} TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS (void)
当优化被禁止时，该钩子用来指示参数是否应该被分配到栈槽中。通常，GCC当不做优化时，会为参数分配栈槽，以便于调试。然而，当函数使用@code{__attribute__((naked))}声明时，将没有栈帧，因此编译器不能安全的将参数从用来传递它们的寄存器中移送到栈上。因此，该钩子通常应该返回真，但是对于裸露的函数应该返回假。缺省的实现总是返回真。
@end deftypefn
