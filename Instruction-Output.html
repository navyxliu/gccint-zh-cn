<html lang="zh">
<head>
<title>Instruction Output - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Assembler-Format.html#Assembler-Format" title="Assembler Format">
<link rel="prev" href="Macros-for-Initialization.html#Macros-for-Initialization" title="Macros for Initialization">
<link rel="next" href="Dispatch-Tables.html#Dispatch-Tables" title="Dispatch Tables">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Instruction-Output"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Dispatch-Tables.html#Dispatch-Tables">Dispatch Tables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Macros-for-Initialization.html#Macros-for-Initialization">Macros for Initialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Assembler-Format.html#Assembler-Format">Assembler Format</a>
<hr>
</div>

<h4 class="subsection">17.21.7 汇编指令的输出</h4>

<!-- prevent bad page break with this line -->
<!-- This describes assembler instruction output. -->
<p>这章描述了汇编指令的输出。

<div class="defun">
&mdash; Macro: <b>REGISTER_NAMES</b><var><a name="index-REGISTER_005fNAMES-4580"></a></var><br>
<blockquote><!-- A C initializer containing the assembler's names for the machine -->
     <!-- registers, each one as a C string constant.  This is what translates -->
     <!-- register numbers in the compiler into assembler language. -->
      <p>一段C初始化程序，包含了机器寄存器的汇编名字，每个名字使用C字符串常量表示。
这用来将编译器中的寄存器编号转换成汇编语言。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ADDITIONAL_REGISTER_NAMES</b><var><a name="index-ADDITIONAL_005fREGISTER_005fNAMES-4581"></a></var><br>
<blockquote><!-- If defined, a C initializer for an array of structures containing a name -->
     <!-- and a register number.  This macro defines additional names for hard -->
     <!-- registers, thus allowing the @code{asm} option in declarations to refer -->
     <!-- to registers using alternate names. -->
      <p>如果定义，则为结构体数组的初始化程序，结构体包含了名字和寄存器编号。
该宏定义了硬件寄存器的附加名字，这样就可以允许在声明中的<code>asm</code>选项，
来使用附加名引用寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>OVERLAPPING_REGISTER_NAMES</b><var><a name="index-OVERLAPPING_005fREGISTER_005fNAMES-4582"></a></var><br>
<blockquote><p>If defined, a C initializer for an array of structures containing a
name, a register number and a count of the number of consecutive
machine registers the name overlaps.  This macro defines additional
names for hard registers, thus allowing the <code>asm</code> option in
declarations to refer to registers using alternate names.  Unlike
<code>ADDITIONAL_REGISTER_NAMES</code>, this macro should be used when the
register name implies multiple underlying registers.

      <p>This macro should be used when it is important that a clobber in an
<code>asm</code> statement clobbers all the underlying values implied by the
register name.  For example, on ARM, clobbering the double-precision
VFP register &ldquo;d0&rdquo; implies clobbering both single-precision registers
&ldquo;s0&rdquo; and &ldquo;s1&rdquo;. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_OPCODE</b> (<var>stream, ptr</var>)<var><a name="index-ASM_005fOUTPUT_005fOPCODE-4583"></a></var><br>
<blockquote><!-- Define this macro if you are using an unusual assembler that -->
     <!-- requires different names for the machine instructions. -->
      <p>定义该宏，如果你在使用一个不常见的汇编器，其需要不一样的机器指令名字。

     <!-- The definition is a C statement or statements which output an -->
     <!-- assembler instruction opcode to the stdio stream @var{stream}.  The -->
     <!-- macro-operand @var{ptr} is a variable of type @code{char *} which -->
     <!-- points to the opcode name in its ``internal'' form-the form that is -->
     <!-- written in the machine description.  The definition should output the -->
     <!-- opcode name to @var{stream}, performing any translation you desire, and -->
     <!-- increment the variable @var{ptr} to point at the end of the opcode -->
     <!-- so that it will not be output twice. -->
      <p>定义为C语句，输出一个汇编指令代码到标准输入输出流<var>stream</var>中。
宏操作数<var>ptr</var>为类型是<code>char *</code>的变量，其指向内部形式中的指令码名字，
内部形式使用机器描述来表示。该定义应该输出操作码名字到<var>stream</var>中，
执行你想要的任何转换，并且将变量<var>ptr</var>增加到指向opcode的尾部，
这样其才不会被输出两次。

     <!-- In fact, your macro definition may process less than the entire opcode -->
     <!-- name, or more than the opcode name; but if you want to process text -->
     <!-- that includes @samp{%}-sequences to substitute operands, you must take -->
     <!-- care of the substitution yourself.  Just be sure to increment -->
     <!-- @var{ptr} over whatever text should not be output normally. -->
      <p>实际上，相对于整个指令码的名字，你的宏定义可以处理或多或少的部分；
但是如果你想处理包含&lsquo;<samp><span class="samp">%</span></samp>&rsquo;序列的文本，则必须小心你所做的替换。
要保证增加<var>ptr</var>，使得不会输出不应该被输出的文本。

      <p><a name="index-recog_005fdata_002eoperand-4584"></a><!-- If you need to look at the operand values, they can be found as the -->
<!-- elements of @code{recog_data.operand}. -->
如果需要查看操作数的值，它们可以作为<code>recog_data.operand</code>的元素被找到。

     <!-- If the macro definition does nothing, the instruction is output -->
     <!-- in the usual way. -->
      <p>如果宏定义不做任何事情，则指令使用通常的方式来输出。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FINAL_PRESCAN_INSN</b> (<var>insn, opvec, noperands</var>)<var><a name="index-FINAL_005fPRESCAN_005fINSN-4585"></a></var><br>
<blockquote><!-- If defined, a C statement to be executed just prior to the output of -->
     <!-- assembler code for @var{insn}, to modify the extracted operands so -->
     <!-- they will be output differently. -->
      <p>如果定义，则为一条C语句，其就在为<var>insn</var>输出汇编代码之前将被执行，
用来修改被抽取的操作数，从而可以被不同方式的输出。

     <!-- Here the argument @var{opvec} is the vector containing the operands -->
     <!-- extracted from @var{insn}, and @var{noperands} is the number of -->
     <!-- elements of the vector which contain meaningful data for this insn. -->
     <!-- The contents of this vector are what will be used to convert the insn -->
     <!-- template into assembler code, so you can change the assembler output -->
     <!-- by changing the contents of the vector. -->
      <p>这里的参数<var>opvec</var>为一个向量，包含了从<var>insn</var>中抽取的操作数，
<var>noperands</var>为向量的元素个数。该向量的内容用于将insn模板转换成汇编代码，
所以你可以通过修改向量的内容来改变汇编输出。

     <!-- This macro is useful when various assembler syntaxes share a single -->
     <!-- file of instruction patterns; by defining this macro differently, you -->
     <!-- can cause a large class of instructions to be output differently (such -->
     <!-- as with rearranged operands).  Naturally, variations in assembler -->
     <!-- syntax affecting individual insn patterns ought to be handled by -->
     <!-- writing conditional output routines in those patterns. -->
      <p>该宏当有多个汇编语法共用一个指令模式文件时很有用；通过定义该宏，
你可以使大量类别的指令按照不同的方式输出（例如重组操作）。
自然的，影响单个insn模式的汇编语法，
应该通过在那些指令模式中写条件输出程序来处理。

     <!-- If this macro is not defined, it is equivalent to a null statement. -->
      <p>如果没有定义该宏，则其相当于一条空语句。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FINAL_POSTSCAN_INSN</b> (<var>FILE *file, rtx insn, rtx *opvec, int noperands</var>)<var><a name="index-TARGET_005fASM_005fFINAL_005fPOSTSCAN_005fINSN-4586"></a></var><br>
<blockquote><p>If defined, this target hook is a function which is executed just after the
output of assembler code for <var>insn</var>, to change the mode of the assembler
if necessary.

      <p>Here the argument <var>opvec</var> is the vector containing the operands
extracted from <var>insn</var>, and <var>noperands</var> is the number of
elements of the vector which contain meaningful data for this insn. 
The contents of this vector are what was used to convert the insn
template into assembler code, so you can change the assembler mode
by checking the contents of the vector. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRINT_OPERAND</b> (<var>stream, x, code</var>)<var><a name="index-PRINT_005fOPERAND-4587"></a></var><br>
<blockquote><!-- A C compound statement to output to stdio stream @var{stream} the -->
     <!-- assembler syntax for an instruction operand @var{x}.  @var{x} is an -->
     <!-- RTL expression. -->
      <p>C复合语句，用来将指令操作数<var>x</var>的汇编语法输出到标准输入输出流<var>stream</var>中。
<var>x</var>为RTL表达式。

      <p><var>code</var> is a value that can be used to specify one of several ways
<!-- of printing the operand.  It is used when identical operands must be -->
<!-- printed differently depending on the context.  @var{code} comes from -->
<!-- the @samp{%} specification that was used to request printing of the -->
<!-- operand.  If the specification was just @samp{%@var{digit}} then -->
<!-- @var{code} is 0; if the specification was @samp{%@var{ltr} -->
<!-- @var{digit}} then @var{code} is the ASCII code for @var{ltr}. -->
<var>code</var>值可以用来指定打印操作数的方式。
用于当操作数必须根据上下文进行不同的打印的时候。
<var>code</var>来自用于打印操作数的&lsquo;<samp><span class="samp">%</span></samp>&rsquo;指定语句。
如果指定语句只是&lsquo;<samp><span class="samp">%</span><var>digit</var></samp>&rsquo;，则<var>code</var>为0；
如果指定语句为&lsquo;<samp><span class="samp">%</span><var>ltr</var><var>digit</var></samp>&rsquo;，则<var>code</var>为<var>ltr</var>的ASCII码。

      <p><a name="index-reg_005fnames-4588"></a><!-- If @var{x} is a register, this macro should print the register's name. -->
<!-- The names can be found in an array @code{reg_names} whose type is -->
<!-- @code{char *[]}.  @code{reg_names} is initialized from -->
<!-- @code{REGISTER_NAMES}. -->
如果<var>x</var>为寄存器，则该宏应该打印寄存器的名字。
名字可以在数组<code>reg_names</code>中找到，数组的类型为<code>char *[]</code>。
<code>reg_names</code>通过<code>REGISTER_NAMES</code>来初始化。

     <!-- When the machine description has a specification @samp{%@var{punct}} -->
     <!-- (a @samp{%} followed by a punctuation character), this macro is called -->
     <!-- with a null pointer for @var{x} and the punctuation character for -->
     <!-- @var{code}. -->
      <p>当机器描述具有一个&lsquo;<samp><span class="samp">%</span><var>punct</var></samp>&rsquo;指定语句时
（&lsquo;<samp><span class="samp">%</span></samp>&rsquo;后面跟随一个标点符号字符），则该宏被调用时，<var>x</var>为空指针，
<var>code</var>为标点符号字符。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRINT_OPERAND_PUNCT_VALID_P</b> (<var>code</var>)<var><a name="index-PRINT_005fOPERAND_005fPUNCT_005fVALID_005fP-4589"></a></var><br>
<blockquote><!-- A C expression which evaluates to true if @var{code} is a valid -->
     <!-- punctuation character for use in the @code{PRINT_OPERAND} macro.  If -->
     <!-- @code{PRINT_OPERAND_PUNCT_VALID_P} is not defined, it means that no -->
     <!-- punctuation characters (except for the standard one, @samp{%}) are used -->
     <!-- in this way. -->
      <p>一个C表达式，
当<var>code</var>为在<code>PRINT_OPERAND</code>宏中使用的有效的标点符号字符时，
其计算为真。如果没有定义<code>PRINT_OPERAND_PUNCT_VALID_P</code>，
则意味着不以这种方式使用标点符号字符（除了标准的&lsquo;<samp><span class="samp">%</span></samp>&rsquo;以外）。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRINT_OPERAND_ADDRESS</b> (<var>stream, x</var>)<var><a name="index-PRINT_005fOPERAND_005fADDRESS-4590"></a></var><br>
<blockquote><!-- A C compound statement to output to stdio stream @var{stream} the -->
     <!-- assembler syntax for an instruction operand that is a memory reference -->
     <!-- whose address is @var{x}.  @var{x} is an RTL expression. -->
      <p>C复合语句，用来将指令操作数为内存引用，其地址为<var>x</var>的汇编语法，
输出到标准输入输出流<var>stream</var>中。<var>x</var>为一个RTL表达式。

      <p><a name="index-g_t_0040code_007bTARGET_005fENCODE_005fSECTION_005fINFO_007d-usage-4591"></a><!-- On some machines, the syntax for a symbolic address depends on the -->
<!-- section that the address refers to.  On these machines, define the hook -->
<!-- @code{TARGET_ENCODE_SECTION_INFO} to store the information into the -->
<!-- @code{symbol_ref}, and then check for it here.  @xref{Assembler -->
<!-- Format}. -->
在一些机器上，符号地址的语法取决于地址所引用的section。在这些机器上，
定义钩子<code>TARGET_ENCODE_SECTION_INFO</code>来将信息存储到<code>symbol_ref</code>，
并在这里进行检查。参见<a href="Assembler-Format.html#Assembler-Format">Assembler Format</a>。
</p></blockquote></div>

 <p><a name="index-dbr_005fsequence_005flength-4592"></a>

<div class="defun">
&mdash; Macro: <b>DBR_OUTPUT_SEQEND</b> (<var>file</var>)<var><a name="index-DBR_005fOUTPUT_005fSEQEND-4593"></a></var><br>
<blockquote><!-- A C statement, to be executed after all slot-filler instructions have -->
     <!-- been output.  If necessary, call @code{dbr_sequence_length} to -->
     <!-- determine the number of slots filled in a sequence (zero if not -->
     <!-- currently outputting a sequence), to decide how many no-ops to output, -->
     <!-- or whatever. -->
      <p>C语句，在所有的栈槽填充指令被输出之后执行。如果需要的话，
调用<code>dbr_sequence_length</code>来判定在序列中被填充的栈槽数目
（如果当前不是输出一个序列，则为0），用来决定输出多少个no-ops，或其它。

     <!-- Don't define this macro if it has nothing to do, but it is helpful in -->
     <!-- reading assembly output if the extent of the delay sequence is made -->
     <!-- explicit (e.g.@: with white space). -->
      <p>如果不做任何事情，就不要定义该宏，但是如果将延迟序列显示化，
则会有助于阅读汇编输出（例如，使用空格）。
</p></blockquote></div>

 <p><a name="index-final_005fsequence-4594"></a><!-- Note that output routines for instructions with delay slots must be -->
<!-- prepared to deal with not being output as part of a sequence -->
<!-- (i.e.@: when the scheduling pass is not run, or when no slot fillers could be -->
<!-- found.)  The variable @code{final_sequence} is null when not -->
<!-- processing a sequence, otherwise it contains the @code{sequence} rtx -->
<!-- being output. -->
注意，用于带有延迟槽的指令的输出程序，
必须准备好处理没有被作为序列输出的情况（即，当没有运行调度过程，
或者没有找到栈槽填充者）。当没有处理序列时，变量<code>final_sequence</code>为空，
否则其包含了被输出的rtx <code>sequence</code>。

 <p><a name="index-asm_005ffprintf-4595"></a>

<div class="defun">
&mdash; Macro: <b>REGISTER_PREFIX</b><var><a name="index-REGISTER_005fPREFIX-4596"></a></var><br>
&mdash; Macro: <b>LOCAL_LABEL_PREFIX</b><var><a name="index-LOCAL_005fLABEL_005fPREFIX-4597"></a></var><br>
&mdash; Macro: <b>USER_LABEL_PREFIX</b><var><a name="index-USER_005fLABEL_005fPREFIX-4598"></a></var><br>
&mdash; Macro: <b>IMMEDIATE_PREFIX</b><var><a name="index-IMMEDIATE_005fPREFIX-4599"></a></var><br>
<blockquote><!-- If defined, C string expressions to be used for the @samp{%R}, @samp{%L}, -->
     <!-- @samp{%U}, and @samp{%I} options of @code{asm_fprintf} (see -->
     <!-- @file{final.c}).  These are useful when a single @file{md} file must -->
     <!-- support multiple assembler formats.  In that case, the various @file{tm.h} -->
     <!-- files can define these macros differently. -->
      <p>如果定义，则为C字符串表达式，用于<code>asm_fprintf</code>（参见 <samp><span class="file">final.c</span></samp>）
的选项&lsquo;<samp><span class="samp">%R</span></samp>&rsquo;, &lsquo;<samp><span class="samp">%L</span></samp>&rsquo;, &lsquo;<samp><span class="samp">%U</span></samp>&rsquo;和 &lsquo;<samp><span class="samp">%I</span></samp>&rsquo;。
这在单个<samp><span class="file">md</span></samp>文件必须支持多个汇编格式时很有用。这种情况下，
不同的<samp><span class="file">tm.h</span></samp>文件可以定义不同的这些宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_FPRINTF_EXTENSIONS</b> (<var>file, argptr, format</var>)<var><a name="index-ASM_005fFPRINTF_005fEXTENSIONS-4600"></a></var><br>
<blockquote><!-- If defined this macro should expand to a series of @code{case} -->
     <!-- statements which will be parsed inside the @code{switch} statement of -->
     <!-- the @code{asm_fprintf} function.  This allows targets to define extra -->
     <!-- printf formats which may useful when generating their assembler -->
     <!-- statements.  Note that uppercase letters are reserved for future -->
     <!-- generic extensions to asm_fprintf, and so are not available to target -->
     <!-- specific code.  The output file is given by the parameter @var{file}. -->
     <!-- The varargs input pointer is @var{argptr} and the rest of the format -->
     <!-- string, starting the character after the one that is being switched -->
     <!-- upon, is pointed to by @var{format}. -->
      <p>如果定义，该宏应该被扩展为一系列<code>case</code>语句，
其将在<code>asm_fprintf</code>函数中的<code>switch</code>语句里被解析。
这将应允许target来定义额外的printf格式，其在生成它们的汇编语句时很有帮助。
注意，大写字母被保留用于<code>asm_fprintf</code>将来的通用扩展，
所以不要用于target特定代码中。输出文件由参数<var>file</var>给定。
varargs输出指针为<var>argptr</var>，格式字符串的其余部分，由<var>format</var>指向。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASSEMBLER_DIALECT</b><var><a name="index-ASSEMBLER_005fDIALECT-4601"></a></var><br>
<blockquote><!-- If your target supports multiple dialects of assembler language (such as -->
     <!-- different opcodes), define this macro as a C expression that gives the -->
     <!-- numeric index of the assembler language dialect to use, with zero as the -->
     <!-- first variant. -->
      <p>如果你的target支持多个汇编语言方言（例如不同的操作码），
可以定义该宏作为C表达式，给出汇编语言方言的索引，0作为第一个。

     <!-- If this macro is defined, you may use constructs of the form -->
      <p>如果该宏被定义，你可以在指令模式的输出模版中（参见输出模版）或者asm_fprintf的第一个参数中使用如下的结构形式

     <pre class="smallexample">          &lsquo;<samp><span class="samp">{option0|option1|option2...}</span></samp>&rsquo;
</pre>
      <p class="noindent"><!-- in the output templates of patterns (@pxref{Output Template}) or in the -->
<!-- first argument of @code{asm_fprintf}.  This construct outputs -->
<!-- @samp{option0}, @samp{option1}, @samp{option2}, etc., if the value of -->
<!-- @code{ASSEMBLER_DIALECT} is zero, one, two, etc.  Any special characters -->
<!-- within these strings retain their usual meaning.  If there are fewer -->
<!-- alternatives within the braces than the value of -->
<!-- @code{ASSEMBLER_DIALECT}, the construct outputs nothing. -->
该结构输出&lsquo;<samp><span class="samp">option0</span></samp>&rsquo;, &lsquo;<samp><span class="samp">option1</span></samp>&rsquo;, &lsquo;<samp><span class="samp">option2</span></samp>&rsquo;等等，
如果<code>ASSEMBLER_DIALECT</code>的值为0，1，2，等等。
这些字符串中的任何特殊字符将保留它们通常的含义。
如果括号中的可选项多于<code>ASSEMBLER_DIALECT</code>的值，则什么也不输出。

     <!-- If you do not define this macro, the characters @samp{@{}, @samp{|} and -->
     <!-- @samp{@}} do not have any special meaning when used in templates or -->
     <!-- operands to @code{asm_fprintf}. -->
      <p>如果没有定义该宏，字符&lsquo;<samp><span class="samp">{</span></samp>&rsquo;, &lsquo;<samp><span class="samp">|</span></samp>&rsquo;和&lsquo;<samp><span class="samp">}</span></samp>&rsquo;在模版中或
<code>asm_fprintf</code>的操作数中不具有任何特殊含义。

     <!-- Define the macros @code{REGISTER_PREFIX}, @code{LOCAL_LABEL_PREFIX}, -->
     <!-- @code{USER_LABEL_PREFIX} and @code{IMMEDIATE_PREFIX} if you can express -->
     <!-- the variations in assembler language syntax with that mechanism.  Define -->
     <!-- @code{ASSEMBLER_DIALECT} and use the @samp{@{option0|option1@}} syntax -->
     <!-- if the syntax variant are larger and involve such things as different -->
     <!-- opcodes or operand order. -->
      <p>如果你能够通过定义宏<code>REGISTER_PREFIX</code>, <code>LOCAL_LABEL_PREFIX</code>,
<code>USER_LABEL_PREFIX</code>和<code>IMMEDIATE_PREFIX</code>来表达出汇编语言语法的
不同之处，则定义这些宏。如果语法差异比较大，涉及到操作码不同或操作数顺序，
则定义<code>ASSEMBLER_DIALECT</code>，使用&lsquo;<samp><span class="samp">{option0|option1}</span></samp>&rsquo;语法。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_REG_PUSH</b> (<var>stream, regno</var>)<var><a name="index-ASM_005fOUTPUT_005fREG_005fPUSH-4602"></a></var><br>
<blockquote><!-- A C expression to output to @var{stream} some assembler code -->
     <!-- which will push hard register number @var{regno} onto the stack. -->
     <!-- The code need not be optimal, since this macro is used only when -->
     <!-- profiling. -->
      <p>C表达式，向<var>stream</var>中输出汇编代码，用于将硬件寄存器编号<var>regno</var>压入栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_REG_POP</b> (<var>stream, regno</var>)<var><a name="index-ASM_005fOUTPUT_005fREG_005fPOP-4603"></a></var><br>
<blockquote><!-- A C expression to output to @var{stream} some assembler code -->
     <!-- which will pop hard register number @var{regno} off of the stack. -->
     <!-- The code need not be optimal, since this macro is used only when -->
     <!-- profiling. -->
      <p>C表达式，向<var>stream</var>中输出汇编代码，用于将硬件寄存器编号<var>regno</var>弹出栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
</p></blockquote></div>

<!-- @node Dispatch Tables -->
<!-- @subsection Output of Dispatch Tables -->
 </body></html>

