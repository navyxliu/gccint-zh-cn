<html lang="zh">
<head>
<title>C++ ABI - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="PCH-Target.html#PCH-Target" title="PCH Target">
<link rel="next" href="Named-Address-Spaces.html#Named-Address-Spaces" title="Named Address Spaces">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="C++-ABI"></a>
<a name="C_002b_002b-ABI"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Named-Address-Spaces.html#Named-Address-Spaces">Named Address Spaces</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="PCH-Target.html#PCH-Target">PCH Target</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.29 C++ ABI参数</h3>

<p><a name="index-parameters_002c-c_002b_002b-abi-4763"></a>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_CXX_GUARD_TYPE</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fGUARD_005fTYPE-4764"></a></var><br>
<blockquote><!-- Define this hook to override the integer type used for guard variables. -->
     <!-- These are used to implement one-time construction of static objects.  The -->
     <!-- default is long_long_integer_type_node. -->
      <p>定义该钩子来覆盖用于guard变量的整数类型。
这些被用于实现静态对象的一次构建。缺省为long_long_integer_type_node。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_GUARD_MASK_BIT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fGUARD_005fMASK_005fBIT-4765"></a></var><br>
<blockquote><!-- This hook determines how guard variables are used.  It should return -->
     <!-- @code{false} (the default) if the first byte should be used.  A return value of -->
     <!-- @code{true} indicates that only the least significant bit should be used. -->
      <p>该钩子确定如何使用guard变量。如果第一个字节应该被使用，
则应该返回<code>false</code>（缺省）。返回值为<code>true</code>表明应该使用最低有效位。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_CXX_GET_COOKIE_SIZE</b> (<var>tree type</var>)<var><a name="index-TARGET_005fCXX_005fGET_005fCOOKIE_005fSIZE-4766"></a></var><br>
<blockquote><!-- This hook returns the size of the cookie to use when allocating an array -->
     <!-- whose elements have the indicated @var{type}.  Assumes that it is already -->
     <!-- known that a cookie is needed.  The default is -->
     <!-- @code{max(sizeof (size_t), alignof(type))}, as defined in section 2.7 of the -->
     <!-- IA64/Generic C++ ABI@. -->
      <p>该钩子返回cookie的大小，其中cookie为当分配一个数组其元素具有<var>type</var>类型，
所使用的cookie。假设已经知道需要一个cookie。
缺省为<code>max(sizeof (size_t), alignof(type))</code>，
在2.7节IA64/Generic C++ ABI中定义。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_COOKIE_HAS_SIZE</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fCOOKIE_005fHAS_005fSIZE-4767"></a></var><br>
<blockquote><!-- This hook should return @code{true} if the element size should be stored in -->
     <!-- array cookies.  The default is to return @code{false}. -->
      <p>该钩子应该返回<code>true</code>，如果元素大小应该被存放在数组cookie中。
缺省为返回<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_CXX_IMPORT_EXPORT_CLASS</b> (<var>tree type, int import_export</var>)<var><a name="index-TARGET_005fCXX_005fIMPORT_005fEXPORT_005fCLASS-4768"></a></var><br>
<blockquote><!-- If defined by a backend this hook allows the decision made to export -->
     <!-- class @var{type} to be overruled.  Upon entry @var{import_export} -->
     <!-- will contain 1 if the class is going to be exported, @minus{}1 if it is going -->
     <!-- to be imported and 0 otherwise.  This function should return the -->
     <!-- modified value and perform any other actions necessary to support the -->
     <!-- backend's targeted operating system. -->
      <p>如果后端定义了该钩子，则允许覆盖对导出类<var>type</var>的决定。
<var>import_export</var>将包含1，如果类将被导出，&minus;1如果其将被导入，否则为0. 
该函数应该返回修改后的值，并执行其它需要的操作来支持后端的操作系统。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_CDTOR_RETURNS_THIS</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fCDTOR_005fRETURNS_005fTHIS-4769"></a></var><br>
<blockquote><!-- This hook should return @code{true} if constructors and destructors return -->
     <!-- the address of the object created/destroyed.  The default is to return -->
     <!-- @code{false}. -->
      <p>该钩子应该返回<code>true</code>，如果构造者和析构者返回创建/销毁对象的地址。
缺省为返回<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_KEY_METHOD_MAY_BE_INLINE</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fKEY_005fMETHOD_005fMAY_005fBE_005fINLINE-4770"></a></var><br>
<blockquote><!-- This hook returns true if the key method for a class (i.e., the method -->
     <!-- which, if defined in the current translation unit, causes the virtual -->
     <!-- table to be emitted) may be an inline function.  Under the standard -->
     <!-- Itanium C++ ABI the key method may be an inline function so long as -->
     <!-- the function is not declared inline in the class definition.  Under -->
     <!-- some variants of the ABI, an inline function can never be the key -->
     <!-- method.  The default is to return @code{true}. -->
      <p>该钩子返回真，如果类的关键方法（即，如果方法在当前转换单元中定义，
其使得虚拟表被输出）可以为内联函数。对于标准的Itanium C++ ABI，
关键方法可以为内联函数，只要函数不在类定义中声明为内联的。
其它ABI的变体中，内联函数不能为关键方法。缺省为返回<code>true</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY</b> (<var>tree decl</var>)<var><a name="index-TARGET_005fCXX_005fDETERMINE_005fCLASS_005fDATA_005fVISIBILITY-4771"></a></var><br>
<blockquote><!-- @var{decl} is a virtual table, virtual table table, typeinfo object, or other similar implicit class data object that will be emitted with external linkage in this translation unit.  No ELF visibility has been explicitly specified.  If the target needs to specify a visibility other than that of the containing class, use this hook to set @code{DECL_VISIBILITY} and @code{DECL_VISIBILITY_SPECIFIED}. -->
      <p><var>decl</var>为虚拟表，类型信息对象，或其它类似的隐含类数据对象，
其将在该转换单元中作为外部链接被输出。ELF的可视性不会被显示的指定。
如果target需要指定可视性，
可以使用该钩子来设置<code>DECL_VISIBILITY</code>和<code>DECL_VISIBILITY_SPECIFIED</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fCLASS_005fDATA_005fALWAYS_005fCOMDAT-4772"></a></var><br>
<blockquote><!-- This hook returns true (the default) if virtual tables and other -->
     <!-- similar implicit class data objects are always COMDAT if they have -->
     <!-- external linkage.  If this hook returns false, then class data for -->
     <!-- classes whose virtual table will be emitted in only one translation -->
     <!-- unit will not be COMDAT. -->
      <p>该钩子返回真（缺省情况）如果虚拟表和其它类似的隐式类数据对象总是为COMDAT，
如果它们具有外部连接。如果该钩子返回假，
则只在一个转换单元中被输出的虚拟表的类的类数据将不是COMDAT。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_LIBRARY_RTTI_COMDAT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fLIBRARY_005fRTTI_005fCOMDAT-4773"></a></var><br>
<blockquote><!-- This hook returns true (the default) if the RTTI information for -->
     <!-- the basic types which is defined in the C++ runtime should always -->
     <!-- be COMDAT, false if it should not be COMDAT. -->
      <p>该钩子返回真（缺省情况），
如果在C++运行时定义的基本类型的RTTI信息应该总是为COMDAT，否则为假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_USE_AEABI_ATEXIT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fUSE_005fAEABI_005fATEXIT-4774"></a></var><br>
<blockquote><!-- This hook returns true if @code{__aeabi_atexit} (as defined by the ARM EABI) -->
     <!-- should be used to register static destructors when @option{-fuse-cxa-atexit} -->
     <!-- is in effect.  The default is to return false to use @code{__cxa_atexit}. -->
      <p>该钩子返回真，
如果<code>__aeabi_atexit</code>（如被ARM EABI定义）应该用于注册静态析构者，
当<samp><span class="option">-fuse-cxa-atexit</span></samp>为有效时。缺省是返回假，使用<code>__cxa_atexit</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fUSE_005fATEXIT_005fFOR_005fCXA_005fATEXIT-4775"></a></var><br>
<blockquote><!-- This hook returns true if the target @code{atexit} function can be used -->
     <!-- in the same manner as @code{__cxa_atexit} to register C++ static -->
     <!-- destructors. This requires that @code{atexit}-registered functions in -->
     <!-- shared libraries are run in the correct order when the libraries are -->
     <!-- unloaded. The default is to return false. -->
      <p>该钩子返回真，
如果target的<code>atexit</code>函数可以跟<code>__cxa_atexit</code>一样被用于注册静态析构者。
这要求在共享库中<code>atexit</code>注册的函数要按照正确的顺序运行，当库被卸载时。
缺省为返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_CXX_ADJUST_CLASS_AT_DEFINITION</b> (<var>tree type</var>)<var><a name="index-TARGET_005fCXX_005fADJUST_005fCLASS_005fAT_005fDEFINITION-4776"></a></var><br>
<blockquote><!-- @var{type} is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just been defined.  Use this hook to make adjustments to the class (eg, tweak visibility or perform any other required target modifications). -->
      <p><var>type</var>为一个刚被定义的C++类（即RECORD_TYPE 或 UNION_TYPE）。
使用该钩子来调整类（例如tweak可视性或者执行其它target需要的修改）。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_CXX_DECL_MANGLING_CONTEXT</b> (<var>const_tree decl</var>)<var><a name="index-TARGET_005fCXX_005fDECL_005fMANGLING_005fCONTEXT-4777"></a></var><br>
<blockquote><p>Return target-specific mangling context of <var>decl</var> or <code>NULL_TREE</code>. 
</p></blockquote></div>

 </body></html>

