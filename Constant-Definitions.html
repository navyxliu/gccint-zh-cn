<html lang="zh">
<head>
<title>Constant Definitions - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Machine-Desc.html#Machine-Desc" title="Machine Desc">
<link rel="prev" href="Conditional-Execution.html#Conditional-Execution" title="Conditional Execution">
<link rel="next" href="Iterators.html#Iterators" title="Iterators">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Constant-Definitions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Iterators.html#Iterators">Iterators</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Conditional-Execution.html#Conditional-Execution">Conditional Execution</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Machine-Desc.html#Machine-Desc">Machine Desc</a>
<hr>
</div>

<h3 class="section">16.21 常量定义</h3>

<p><a name="index-constant-definitions-3728"></a><a name="index-define_005fconstants-3729"></a>
<!-- Using literal constants inside instruction patterns reduces legibility and -->
<!-- can be a maintenance problem. -->
<!-- To overcome this problem, you may use the @code{define_constants} -->
<!-- expression.  It contains a vector of name-value pairs.  From that -->
<!-- point on, wherever any of the names appears in the MD file, it is as -->
<!-- if the corresponding value had been written instead.  You may use -->
<!-- @code{define_constants} multiple times; each appearance adds more -->
<!-- constants to the table.  It is an error to redefine a constant with -->
<!-- a different value. -->
<!-- To come back to the a29k load multiple example, instead of -->
在指令模板中使用文字常量会减小可读性并会成为一个维护问题。

 <p>要克服该问题，你可以使用 <code>define_constants</code> 表达式。它包含了一个
“名字-值”成对向量。从定义处开始，任何出现在MD文件中的那些名字，都作为
相应的值被替换。你可以多次使用 <code>define_constants</code>；每次都为表格中
增加更多的常量。使用不同的值来重新定义一个常量将会产生一个错误。

 <p>回到a29k加载乘的例子，对于

<!-- @smallexample -->
<!-- (define_insn "" -->
<!-- [(match_parallel 0 "load_multiple_operation" -->
<!-- [(set (match_operand:SI 1 "gpc_reg_operand" "=r") -->
<!-- (match_operand:SI 2 "memory_operand" "m")) -->
<!-- (use (reg:SI 179)) -->
<!-- (clobber (reg:SI 179))])] -->
<!-- "" -->
<!-- "loadm 0,0,%1,%2") -->
<!-- @end smallexample -->
<!-- You could write: -->
<!-- @smallexample -->
<!-- (define_constants [ -->
<!-- (R_BP 177) -->
<!-- (R_FC 178) -->
<!-- (R_CR 179) -->
<!-- (R_Q  180) -->
<!-- ]) -->
<!-- (define_insn "" -->
<!-- [(match_parallel 0 "load_multiple_operation" -->
<!-- [(set (match_operand:SI 1 "gpc_reg_operand" "=r") -->
<!-- (match_operand:SI 2 "memory_operand" "m")) -->
<!-- (use (reg:SI R_CR)) -->
<!-- (clobber (reg:SI R_CR))])] -->
<!-- "" -->
<!-- "loadm 0,0,%1,%2") -->
<!-- @end smallexample -->
<pre class="smallexample">     (define_insn ""
       [(match_parallel 0 "load_multiple_operation"
          [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                (match_operand:SI 2 "memory_operand" "m"))
           (use (reg:SI 179))
           (clobber (reg:SI 179))])]
       ""
       "loadm 0,0,%1,%2")
</pre>
 <p>你可以写成:

<pre class="smallexample">     (define_constants [
         (R_BP 177)
         (R_FC 178)
         (R_CR 179)
         (R_Q  180)
     ])
     
     (define_insn ""
       [(match_parallel 0 "load_multiple_operation"
          [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                (match_operand:SI 2 "memory_operand" "m"))
           (use (reg:SI R_CR))
           (clobber (reg:SI R_CR))])]
       ""
       "loadm 0,0,%1,%2")
</pre>
 <!-- The constants that are defined with a define_constant are also output -->
<!-- in the insn-codes.h header file as #defines. -->
 <p>使用define_constants定义的常量也在insn-codes.h头文件中作为#defines被输出。

<!-- @cindex enumerations -->
<!-- @findex define_c_enum -->
<!-- You can also use the machine description file to define enumerations. -->
<!-- Like the constants defined by @code{define_constant}, these enumerations -->
<!-- are visible to both the machine description file and the main C code. -->
<!-- The syntax is as follows: -->
<!-- @smallexample -->
<!-- (define_c_enum "@var{name}" [ -->
<!-- @var{value0} -->
<!-- @var{value1} -->
<!-- @dots{} -->
<!-- @var{valuen} -->
<!-- ]) -->
<!-- @end smallexample -->
<!-- This definition causes the equivalent of the following C code to appear -->
<!-- in @file{insn-constants.h}: -->
<!-- @smallexample -->
<!-- enum @var{name} @{ -->
<!-- @var{value0} = 0, -->
<!-- @var{value1} = 1, -->
<!-- @dots{} -->
<!-- @var{valuen} = @var{n} -->
<!-- @}; -->
<!-- #define NUM_@var{cname}_VALUES (@var{n} + 1) -->
<!-- @end smallexample -->
<!-- where @var{cname} is the capitalized form of @var{name}. -->
<!-- It also makes each @var{valuei} available in the machine description -->
<!-- file, just as if it had been declared with: -->
<!-- @smallexample -->
<!-- (define_constants [(@var{valuei} @var{i})]) -->
<!-- @end smallexample -->
<!-- Each @var{valuei} is usually an upper-case identifier and usually -->
<!-- begins with @var{cname}. -->
<!-- You can split the enumeration definition into as many statements as -->
<!-- you like.  The above example is directly equivalent to: -->
<!-- @smallexample -->
<!-- (define_c_enum "@var{name}" [@var{value0}]) -->
<!-- (define_c_enum "@var{name}" [@var{value1}]) -->
<!-- @dots{} -->
<!-- (define_c_enum "@var{name}" [@var{valuen}]) -->
<!-- @end smallexample -->
<!-- Splitting the enumeration helps to improve the modularity of each -->
<!-- individual @code{.md} file.  For example, if a port defines its -->
<!-- synchronization instructions in a separate @file{sync.md} file, -->
<!-- it is convenient to define all synchronization-specific enumeration -->
<!-- values in @file{sync.md} rather than in the main @file{.md} file. -->
<!-- Some enumeration names have special significance to GCC: -->
<!-- @table @code -->
<!-- @item unspecv -->
<!-- @findex unspec_volatile -->
<!-- If an enumeration called @code{unspecv} is defined, GCC will use it -->
<!-- when printing out @code{unspec_volatile} expressions.  For example: -->
<!-- @smallexample -->
<!-- (define_c_enum "unspecv" [ -->
<!-- UNSPECV_BLOCKAGE -->
<!-- ]) -->
<!-- @end smallexample -->
<!-- causes GCC to print @samp{(unspec_volatile @dots{} 0)} as: -->
<!-- @smallexample -->
<!-- (unspec_volatile ... UNSPECV_BLOCKAGE) -->
<!-- @end smallexample -->
<!-- @item unspec -->
<!-- @findex unspec -->
<!-- If an enumeration called @code{unspec} is defined, GCC will use -->
<!-- it when printing out @code{unspec} expressions.  GCC will also use -->
<!-- it when printing out @code{unspec_volatile} expressions unless an -->
<!-- @code{unspecv} enumeration is also defined.  You can therefore -->
<!-- decide whether to keep separate enumerations for volatile and -->
<!-- non-volatile expressions or whether to use the same enumeration -->
<!-- for both. -->
<!-- @end table -->
<!-- @findex define_enum -->
<!-- @anchor{define_enum} -->
<!-- Another way of defining an enumeration is to use @code{define_enum}: -->
<!-- @smallexample -->
<!-- (define_enum "@var{name}" [ -->
<!-- @var{value0} -->
<!-- @var{value1} -->
<!-- @dots{} -->
<!-- @var{valuen} -->
<!-- ]) -->
<!-- @end smallexample -->
<!-- This directive implies: -->
<!-- @smallexample -->
<!-- (define_c_enum "@var{name}" [ -->
<!-- @var{cname}_@var{cvalue0} -->
<!-- @var{cname}_@var{cvalue1} -->
<!-- @dots{} -->
<!-- @var{cname}_@var{cvaluen} -->
<!-- ]) -->
<!-- @end smallexample -->
<!-- @findex define_enum_attr -->
<!-- where @var{cvaluei} is the capitalized form of @var{valuei}. -->
<!-- However, unlike @code{define_c_enum}, the enumerations defined -->
<!-- by @code{define_enum} can be used in attribute specifications -->
<!-- (@pxref{define_enum_attr}). -->
<!-- @end ifset -->
<!-- @ifset INTERNALS -->
<!-- @node Iterators -->
<!-- @section Iterators -->
<!-- @cindex iterators in @file{.md} files -->
 </body></html>

