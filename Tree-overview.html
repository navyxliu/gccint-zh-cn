<html lang="zh">
<head>
<title>Tree overview - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="GENERIC.html#GENERIC" title="GENERIC">
<link rel="prev" href="Deficiencies.html#Deficiencies" title="Deficiencies">
<link rel="next" href="Types.html#Types" title="Types">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Tree-overview"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Types.html#Types">Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Deficiencies.html#Deficiencies">Deficiencies</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="GENERIC.html#GENERIC">GENERIC</a>
<hr>
</div>

<h3 class="section">11.2 概述</h3>

<p><a name="index-tree-2308"></a><a name="index-TREE_005fCODE-2309"></a>
<!-- The central data structure used by the internal representation is the -->
<!-- @code{tree}.  These nodes, while all of the C type @code{tree}, are of -->
<!-- many varieties.  A @code{tree} is a pointer type, but the object to -->
<!-- which it points may be of a variety of types.  From this point forward, -->
<!-- we will refer to trees in ordinary type, rather than in @code{this -->
<!-- font}, except when talking about the actual C type @code{tree}. -->
内部表示所使用的最重要的数据结构是<code>tree</code>。这些节点，虽然都为C类型<code>tree</code>，但具有许多变种。一个<code>tree</code>为一个指针类型，但是其指向的对象可以具有不同的类型。从现在开始，我们将用tree来表示普通类型，而当讨论实际的C类型<code>tree</code>时，则用<code>这样的字体</code>。

<!-- You can tell what kind of node a particular tree is by using the -->
<!-- @code{TREE_CODE} macro.  Many, many macros take trees as input and -->
<!-- return trees as output.  However, most macros require a certain kind of -->
<!-- tree node as input.  In other words, there is a type-system for trees, -->
<!-- but it is not reflected in the C type-system. -->
 <p>可以使用<code>TREE_CODE</code>宏来判别一个特定的tree的类型。有许许多多的宏，将tree作为输入，并返回tree作为输出。然而，大多数宏需要特定种类的tree节点作为输入。换句话说，tree是有一个类型系统的，但只不过是没有在C的类型系统中反映出来。

<!-- For safety, it is useful to configure GCC with @option{-enable-checking}. -->
<!-- Although this results in a significant performance penalty (since all -->
<!-- tree types are checked at run-time), and is therefore inappropriate in a -->
<!-- release version, it is extremely helpful during the development process. -->
 <p>为了安全起见，可以使用<samp><span class="option">--enable-checking</span></samp>来配置GCC。虽然这会对性能造成明显的影响（因为所有的tree类型都会在运行时被检查），并且因此不适合用于发行版，但这在开发阶段非常有帮助。

<!-- Many macros behave as predicates.  Many, although not all, of these -->
<!-- predicates end in @samp{_P}.  Do not rely on the result type of these -->
<!-- macros being of any particular type.  You may, however, rely on the fact -->
<!-- that the type can be compared to @code{0}, so that statements like -->
 <p>许多宏是作为断言（predicates）来使用的。许多这些断言，虽然不是所有的，会以&lsquo;<samp><span class="samp">_P</span></samp>&rsquo;为结尾。不要认为这些宏的结果类型就是一个特定的类型。不过，你可以将该类型和<code>0</code>进行比较。所以，像语句
<pre class="smallexample">     if (TEST_P (t) &amp;&amp; !TEST_P (y))
       x = 1;
</pre>
 <p class="noindent"><!-- and -->
和
<pre class="smallexample">     int i = (TEST_P (t) != 0);
</pre>
 <p class="noindent"><!-- are legal.  Macros that return @code{int} values now may be changed to -->
<!-- return @code{tree} values, or other pointers in the future.  Even those -->
<!-- that continue to return @code{int} may return multiple nonzero codes -->
<!-- where previously they returned only zero and one.  Therefore, you should -->
<!-- not write code like -->
都是合法的。现在返回<code>int</code>值的宏在将来也许会被改为返回<code>tree</code>值，或者其它指针。甚至那些继续返回<code>int</code>的，之前它们只返回0或者1，但将来也可能会返回多种非零码。因此，不要将代码写成
<pre class="smallexample">     if (TEST_P (t) == 1)
</pre>
 <p class="noindent"><!-- as this code is not guaranteed to work correctly in the future. -->
因为，该代码在将来不保证可以正确工作。

<!-- You should not take the address of values returned by the macros or -->
<!-- functions described here.  In particular, no guarantee is given that the -->
<!-- values are lvalues. -->
 <p>不要使用这里描述的宏或者函数所返回的值的地址。特别的，不保证值为左值。

<!-- In general, the names of macros are all in uppercase, while the names of -->
<!-- functions are entirely in lowercase.  There are rare exceptions to this -->
<!-- rule.  You should assume that any macro or function whose name is made -->
<!-- up entirely of uppercase letters may evaluate its arguments more than -->
<!-- once.  You may assume that a macro or function whose name is made up -->
<!-- entirely of lowercase letters will evaluate its arguments only once. -->
 <p>通常，宏的名字都为大写，而函数的名字全是小写。很少有例外的情况。你需要假定，任何名字完全为大写字母的宏或者函数，其可能会对它的参数进行多次求值。你可以假定，名字完全为小写字母的宏或者函数，其对它的参数只进行一次求值。

<!-- The @code{error_mark_node} is a special tree.  Its tree code is -->
<!-- @code{ERROR_MARK}, but since there is only ever one node with that code, -->
<!-- the usual practice is to compare the tree against -->
<!-- @code{error_mark_node}.  (This test is just a test for pointer -->
<!-- equality.)  If an error has occurred during front-end processing the -->
<!-- flag @code{errorcount} will be set.  If the front end has encountered -->
<!-- code it cannot handle, it will issue a message to the user and set -->
<!-- @code{sorrycount}.  When these flags are set, any macro or function -->
<!-- which normally returns a tree of a particular kind may instead return -->
<!-- the @code{error_mark_node}.  Thus, if you intend to do any processing of -->
<!-- erroneous code, you must be prepared to deal with the -->
<!-- @code{error_mark_node}. -->
 <p><code>error_mark_node</code>是一个特殊的树。它的树代码为<code>ERROR_MARK</code>，但由于只有一个节点具有那个代码，所以通常的做法是将树与<code>error_mark_node</code>进行比较。（该测试只是一个指针相等的测试。）如果在前端处理中，有一个错误发生，则标识<code>errorcount</code>将会被设置。如果前端遇到无法处理的代码，则会给用户发送一个消息，并设置<code>sorrycount</code>。当这些标识被设置时，则通常返回特定类型树的宏和函数，可能会替代的返回<code>error_mark_node</code>。因此，如果你打算进行任何错误代码处理，则必须准备好跟<code>error_mark_node</code>打交道。

<!-- Occasionally, a particular tree slot (like an operand to an expression, -->
<!-- or a particular field in a declaration) will be referred to as -->
<!-- ``reserved for the back end''.  These slots are used to store RTL when -->
<!-- the tree is converted to RTL for use by the GCC back end.  However, if -->
<!-- that process is not taking place (e.g., if the front end is being hooked -->
<!-- up to an intelligent editor), then those slots may be used by the -->
<!-- back end presently in use. -->
 <p>有时，一个特定的树插槽slot（就像表达式的操作数，或声明里的特定域）将被称为“为后端保留”。这些插槽用于存储RTL，当树被转换为RTL，被GCC后端使用时。然而，如果没有进行那种处理（例如，如果前端被钩子转向给一个智能编辑器），那么这些插槽就可以被使用了。

<!-- If you encounter situations that do not match this documentation, such -->
<!-- as tree nodes of types not mentioned here, or macros documented to -->
<!-- return entities of a particular kind that instead return entities of -->
<!-- some different kind, you have found a bug, either in the front end or in -->
<!-- the documentation.  Please report these bugs as you would any other -->
<!-- bug. -->
 <p>如果你遇到的情况不符合这个文档，如没有在这里提到的树节点的类型，或记载的宏返回了不同的某一类型实体，那么你发现了一个bug ，要么是前端的，要么是该文档的。请报告这些bug，以及是否有任何其他的bug。

<!-- @menu -->
<!-- * Macros and Functions::Macros and functions that can be used with all trees. -->
<!-- * Identifiers::         The names of things. -->
<!-- * Containers::          Lists and vectors. -->
<!-- @end menu -->
<ul class="menu">
<li><a accesskey="1" href="Macros-and-Functions.html#Macros-and-Functions">Macros and Functions</a>: 可以用于所有tree的宏和函数。
<li><a accesskey="2" href="Identifiers.html#Identifiers">Identifiers</a>:          事物的名字。
<li><a accesskey="3" href="Containers.html#Containers">Containers</a>:           列表和向量。
</ul>

<!--  -->
<!-- Trees -->
<!--  -->
 </body></html>

