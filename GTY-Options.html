<html lang="zh">
<head>
<title>GTY Options - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Type-Information.html#Type-Information" title="Type Information">
<link rel="next" href="GGC-Roots.html#GGC-Roots" title="GGC Roots">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="GTY-Options"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="GGC-Roots.html#GGC-Roots">GGC Roots</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Type-Information.html#Type-Information">Type Information</a>
<hr>
</div>

<h3 class="section">22.1 <code>GTY(())</code>的内部</h3>

<!-- Sometimes the C code is not enough to fully describe the type -->
<!-- structure.  Extra information can be provided with @code{GTY} options -->
<!-- and additional markers.  Some options take a parameter, which may be -->
<!-- either a string or a type name, depending on the parameter.  If an -->
<!-- option takes no parameter, it is acceptable either to omit the -->
<!-- parameter entirely, or to provide an empty string as a parameter.  For -->
<!-- example, @code{@w{GTY ((skip))}} and @code{@w{GTY ((skip ("")))}} are -->
<!-- equivalent. -->
<p>有时候C代码不足以完全描述类型结构体，这时可以使用<code>GTY</code>选项和额外标记来提供额外的信息。一些选项接受一个参数，其可以为字符串或者类型名。如果一个选项不需要参数，则可以完全省略参数，或者提供一个空字符串作为参数。例如，<code>GTY&nbsp;((skip))<!-- /@w --></code>和<code>GTY&nbsp;((skip("")))<!-- /@w --></code>是等价的。

<!-- When the parameter is a string, often it is a fragment of C code.  Four -->
<!-- special escapes may be used in these strings, to refer to pieces of -->
<!-- the data structure being marked: -->
 <p>当参数为字符串时，通常为一个C代码片段。有四种特定的转义符可以在字符串中使用，用来指定被标记的数据结构体部分：

 <p><a name="index-g_t_0025-in-GTY-option-4945"></a>
     <dl>
<dt><code>%h</code><dd><!-- The current structure. -->
当前结构体。
<br><dt><code>%1</code><dd><!-- The structure that immediately contains the current structure. -->
直接包含当前结构体的结构体。
<br><dt><code>%0</code><dd><!-- The outermost structure that contains the current structure. -->
包含当前结构体的最外层结构体。
<br><dt><code>%a</code><dd><!-- A partial expression of the form @code{[i1][i2]@dots{}} that indexes -->
<!-- the array item currently being marked. -->
<code>[i1][i2]...</code>形式的部分表达式，用来索引当前被标记的数组项。
</dl>

<!-- For instance, suppose that you have a structure of the form -->
 <p>例如，假设有一个结构体
<pre class="smallexample">     struct A {
       ...
     };
     struct B {
       struct A foo[12];
     };
</pre>
 <p class="noindent"><!-- and @code{b} is a variable of type @code{struct B}.  When marking -->
<!-- @samp{b.foo[11]}, @code{%h} would expand to @samp{b.foo[11]}, -->
<!-- @code{%0} and @code{%1} would both expand to @samp{b}, and @code{%a} -->
<!-- would expand to @samp{[11]}. -->
并且<code>b</code>是<code>struct B</code>类型的变量。当标记&lsquo;<samp><span class="samp">b.foo[11]</span></samp>&rsquo;时，<code>%h</code>将扩展为&lsquo;<samp><span class="samp">b.foo[11]</span></samp>&rsquo;，<code>%0</code>和<code>%1</code>都会扩展为&lsquo;<samp><span class="samp">b</span></samp>&rsquo;，<code>%a</code>会扩展为&lsquo;<samp><span class="samp">[11]</span></samp>&rsquo;。

<!-- As in ordinary C, adjacent strings will be concatenated; this is -->
<!-- helpful when you have a complicated expression. -->
 <p>和普通的C一样，相邻的字符串会被连接；这对于复杂的表达式是有帮助的。

<pre class="smallexample">     GTY ((chain_next ("TREE_CODE (&amp;%h.generic) == INTEGER_TYPE"
                       " ? TYPE_NEXT_VARIANT (&amp;%h.generic)"
                       " : TREE_CHAIN (&amp;%h.generic)")))
</pre>
 <!-- The available options are: -->
 <p>可用的选项：

     
<a name="index-length-4946"></a>
<dl><dt><code>length ("</code><var>expression</var><code>")</code><dd>
<!-- There are two places the type machinery will need to be explicitly told -->
<!-- the length of an array.  The first case is when a structure ends in a -->
<!-- variable-length array, like this: -->
有两个地方需要显式的告诉类型系统一个数组的长度。第一种情况是当结构体结束于一个可变长度数组，像这样：
     <pre class="smallexample">          struct GTY(()) rtvec_def {
            int num_elem;         /* <span class="roman">number of elements</span> */
            rtx GTY ((length ("%h.num_elem"))) elem[1];
          };
</pre>
     <!-- In this case, the @code{length} option is used to override the specified -->
     <!-- array length (which should usually be @code{1}).  The parameter of the -->
     <!-- option is a fragment of C code that calculates the length. -->
     <p>在这种情况下，<code>length</code>选项用来覆盖指定数组的长度（通常本应该为<code>1</code>）。选项的参数是用来计算长度的C代码片断。

     <!-- The second case is when a structure or a global variable contains a -->
     <!-- pointer to an array, like this: -->
     <p>第二种情况是当结构体或者全局变量包含一个指向数组的指针，像这样：
     <pre class="smallexample">          struct gimple_omp_for_iter * GTY((length ("%h.collapse"))) iter;
</pre>
     <!-- In this case, @code{iter} has been allocated by writing something like -->
     <p>在这种情况下，<code>iter</code>已经通过类似下面的方式被分配：
     <pre class="smallexample">            x-&gt;iter = ggc_alloc_cleared_vec_gimple_omp_for_iter (collapse);
</pre>
     <!-- and the @code{collapse} provides the length of the field. -->
     <p>并且<code>collapse</code>提供了指定域的长度。

     <!-- This second use of @code{length} also works on global variables, like: -->
     <p><code>lenght</code>的第二种用法还包括在全局变量上，像这样：
<pre class="verbatim">     static GTY((length("reg_known_value_size"))) rtx *reg_known_value;
</pre>

     <p><a name="index-skip-4947"></a><br><dt><code>skip</code><dd>
<!-- If @code{skip} is applied to a field, the type machinery will ignore it. -->
<!-- This is somewhat dangerous; the only safe use is in a union when one -->
<!-- field really isn't ever used. -->
如果<code>skip</code>应用在一个域上，则类型机构将会忽略该域。这有些危险；唯一安全的使用方式是在一个联合体中，当一个域确实不会被使用到的时候。

     <p><a name="index-desc-4948"></a><a name="index-tag-4949"></a><a name="index-default-4950"></a><br><dt><code>desc ("</code><var>expression</var><code>")</code><dt><code>tag ("</code><var>constant</var><code>")</code><dt><code>default</code><dd>
<!-- The type machinery needs to be told which field of a @code{union} is -->
<!-- currently active.  This is done by giving each field a constant -->
<!-- @code{tag} value, and then specifying a discriminator using @code{desc}. -->
<!-- The value of the expression given by @code{desc} is compared against -->
<!-- each @code{tag} value, each of which should be different.  If no -->
<!-- @code{tag} is matched, the field marked with @code{default} is used if -->
<!-- there is one, otherwise no field in the union will be marked. -->
类型系统需要知道<code>union</code>的哪一个域是当前活跃的。这是通过赋给每个域一个常数<code>tag</code>值，并且使用<code>desc</code>指定一个判别器来完成的。由<code>desc</code>给出的表达式的值用来与每个<code>tag</code>值比较，每个<code>tag</code>值应该不同。如果没有<code>tag</code>匹配，则会使用标记为<code>default</code>的域。

     <!-- In the @code{desc} option, the ``current structure'' is the union that -->
     <!-- it discriminates.  Use @code{%1} to mean the structure containing it. -->
     <!-- There are no escapes available to the @code{tag} option, since it is a -->
     <!-- constant. -->
     <p>在<code>desc</code>选项中，“当前结构体”是指要进行判别的联合体，可以使用<code>%1</code>来指定。<code>tag</code>选项为常数，不可以使用转义符。

     <!-- For example, -->
     <p>例如,

     <pre class="smallexample">          struct GTY(()) tree_binding
          {
            struct tree_common common;
            union tree_binding_u {
              tree GTY ((tag ("0"))) scope;
              struct cp_binding_level * GTY ((tag ("1"))) level;
            } GTY ((desc ("BINDING_HAS_LEVEL_P ((tree)&amp;%0)"))) xscope;
            tree value;
          };
</pre>
     <!-- In this example, the value of BINDING_HAS_LEVEL_P when applied to a -->
     <!-- @code{struct tree_binding *} is presumed to be 0 or 1.  If 1, the type -->
     <!-- mechanism will treat the field @code{level} as being present and if 0, -->
     <!-- will treat the field @code{scope} as being present. -->
     <p>在这个例子中，当BINDING_HAS_LEVEL_P应用到<code>struct tree_binding*</code>时，其值会被假设为0或者1。如果是1，类型系统则会认为域<code>level</code>存在，如果是0，则会认为域<code>scope</code>存在。

     <p><a name="index-param_005fis-4951"></a><a name="index-use_005fparam-4952"></a><br><dt><code>param_is (</code><var>type</var><code>)</code><dt><code>use_param</code><dd>
<!-- Sometimes it's convenient to define some data structure to work on -->
<!-- generic pointers (that is, @code{PTR}) and then use it with a specific -->
<!-- type.  @code{param_is} specifies the real type pointed to, and -->
<!-- @code{use_param} says where in the generic data structure that type -->
<!-- should be put. -->
有时候，定义某种数据结构作为通用指针（也就是<code>PTR</code>），并且与特定类型一起使用是比较方便的。<code>param_is</code>指定了所指向的真正类型，<code>use_param</code>说明了该类型应该放在通用数据结构的哪个地方。

     <!-- For instance, to have a @code{htab_t} that points to trees, one would -->
     <!-- write the definition of @code{htab_t} like this: -->
     <p>例如，为了让<code>htab_t</code>指向trees，则应该像这样来写<code>htab_t</code>的定义：

     <pre class="smallexample">          typedef struct GTY(()) {
            ...
            void ** GTY ((use_param, ...)) entries;
            ...
          } htab_t;
</pre>
     <!-- and then declare variables like this: -->
     <p>然后按这种方式声明变量：
     <pre class="smallexample">            static htab_t GTY ((param_is (union tree_node))) ict;
</pre>
     <p><a name="index-param_0040var_007bn_007d_005fis-4953"></a><a name="index-use_005fparam_0040var_007bn_007d-4954"></a><br><dt><code>param</code><var>n</var><code>_is (</code><var>type</var><code>)</code><dt><code>use_param</code><var>n</var><dd>
<!-- In more complicated cases, the data structure might need to work on -->
<!-- several different types, which might not necessarily all be pointers. -->
<!-- For this, @code{param1_is} through @code{param9_is} may be used to -->
<!-- specify the real type of a field identified by @code{use_param1} through -->
<code>use_param9</code>. 
在更复杂的情况下，数据结构可能需要工作在多个不同类型之上，而且这些类型也不必都是指针。对于这样的，可以使用<code>param1_is</code>到<code>param9_is</code>来指定由<code>use_param1</code>到<code>use_param9</code>标识的实际类型域。

     <p><a name="index-use_005fparams-4955"></a><br><dt><code>use_params</code><dd>
<!-- When a structure contains another structure that is parameterized, -->
<!-- there's no need to do anything special, the inner structure inherits the -->
<!-- parameters of the outer one.  When a structure contains a pointer to a -->
<!-- parameterized structure, the type machinery won't automatically detect -->
<!-- this (it could, it just doesn't yet), so it's necessary to tell it that -->
<!-- the pointed-to structure should use the same parameters as the outer -->
<!-- structure.  This is done by marking the pointer with the -->
<!-- @code{use_params} option. -->
当结构体包含另一个参数化的结构体时，不需要做特别的处理，内部结构体会继承外部的参数。当结构体包含指向一个参数化的结构体的指针时，类型机构不会自动检测到（是应该可以的，只是还没有实现），所以需要告诉类型系统所指向的结构体将使用外部结构体的相同参数。这可以通过使用<code>usr_params</code>选项来标识指针。

     <p><a name="index-deletable-4956"></a><br><dt><code>deletable</code><dd>
<!-- @code{deletable}, when applied to a global variable, indicates that when -->
<!-- garbage collection runs, there's no need to mark anything pointed to -->
<!-- by this variable, it can just be set to @code{NULL} instead.  This is used -->
<!-- to keep a list of free structures around for re-use. -->
将<code>deletable</code>应用到全局变量上时，表示当垃圾收集运行时，不需要标记由该变量指向的任何对象，可以只是将其设为<code>NULL</code>。这可以用来维护一个可以重用的空闲结构体列表。

     <p><a name="index-if_005fmarked-4957"></a><br><dt><code>if_marked ("</code><var>expression</var><code>")</code><dd>
<!-- Suppose you want some kinds of object to be unique, and so you put them -->
<!-- in a hash table.  If garbage collection marks the hash table, these -->
<!-- objects will never be freed, even if the last other reference to them -->
<!-- goes away.  GGC has special handling to deal with this: if you use the -->
<!-- @code{if_marked} option on a global hash table, GGC will call the -->
<!-- routine whose name is the parameter to the option on each hash table -->
<!-- entry.  If the routine returns nonzero, the hash table entry will -->
<!-- be marked as usual.  If the routine returns zero, the hash table entry -->
<!-- will be deleted. -->
假设你想要一些类别的对象是唯一的，并且为此你将它们放在了哈希表中。如果垃圾搜集标记了哈希表，这些对象将永远不会被释放掉，即使最后一个引用也不存在。对此GCC有特定的处理方式：如果你使用<code>if_marked</code>选项在一个全局哈希表上，GCC将会对每个哈希表项调用该选项参数命名的函数。如果函数返回非0，哈希表项将按照通常的方式被标记，如果返回0，则哈希表项将会被删除。

     <!-- The routine @code{ggc_marked_p} can be used to determine if an element -->
     <!-- has been marked already; in fact, the usual case is to use -->
     <!-- @code{if_marked ("ggc_marked_p")}. -->
     <p>函数<code>ggc_marded_p</code>可以用来判断一个元素是否已经被标记。实际上，通常的情况是使用<code>if_marked ("ggc_marked_p")</code>。

     <p><a name="index-mark_005fhook-4958"></a><br><dt><code>mark_hook ("</code><var>hook-routine-name</var><code>")</code><dd>
<!-- If provided for a structure or union type, the given -->
<!-- @var{hook-routine-name} (between double-quotes) is the name of a -->
<!-- routine called when the garbage collector has just marked the data as -->
<!-- reachable. This routine should not change the data, or call any ggc -->
<!-- routine. Its only argument is a pointer to the just marked (const) -->
<!-- structure or union. -->
如果用在结构体或者联合体类型上，给出的（双引号之间的）<var>hook-routine-name</var>则为一个函数名，其在垃圾搜集器刚刚标记数据为可达（reachable）时会被调用。该函数不应该改变数据，或者调用任何ggc函数。它的唯一参数是一个指向刚刚被标记的结构体或联合体的指针。

     <p><a name="index-maybe_005fundef-4959"></a><br><dt><code>maybe_undef</code><dd>
<!-- When applied to a field, @code{maybe_undef} indicates that it's OK if -->
<!-- the structure that this fields points to is never defined, so long as -->
<!-- this field is always @code{NULL}.  This is used to avoid requiring -->
<!-- backends to define certain optional structures.  It doesn't work with -->
<!-- language frontends. -->
当应用到一个域时，<code>maybe_undef</code>表示可以允许该域所指向的结构体没有被定义，只要该域总是为<code>NULL</code>。这可以用来避免要求后端去定义一些可选的结构体。该选项对语言前端不起作用。

     <p><a name="index-nested_005fptr-4960"></a><br><dt><code>nested_ptr (</code><var>type</var><code>, "</code><var>to expression</var><code>", "</code><var>from expression</var><code>")</code><dd>
<!-- The type machinery expects all pointers to point to the start of an -->
<!-- object.  Sometimes for abstraction purposes it's convenient to have -->
<!-- a pointer which points inside an object.  So long as it's possible to -->
<!-- convert the original object to and from the pointer, such pointers -->
<!-- can still be used.  @var{type} is the type of the original object, -->
<!-- the @var{to expression} returns the pointer given the original object, -->
<!-- and the @var{from expression} returns the original object given -->
<!-- the pointer.  The pointer will be available using the @code{%h} -->
<!-- escape. -->
类型系统期望所有指针都指向一个对象的起始处。有时候出于抽象目的，使用指向对象内部的指针是比较方便的。只要能够对原始对象和指针进行相互转换，这样的指针还是可以使用的。<var>type</var>是原始对象的类型，<var>to expression</var>返回给定原始对象的指针，<var>from expression</var>返回给定指针的原始对象。指针可以使用<code>%h</code>转义符得到。

     <p><a name="index-chain_005fnext-4961"></a><a name="index-chain_005fprev-4962"></a><a name="index-chain_005fcircular-4963"></a><br><dt><code>chain_next ("</code><var>expression</var><code>")</code><dt><code>chain_prev ("</code><var>expression</var><code>")</code><dt><code>chain_circular ("</code><var>expression</var><code>")</code><dd>
<!-- It's helpful for the type machinery to know if objects are often -->
<!-- chained together in long lists; this lets it generate code that uses -->
<!-- less stack space by iterating along the list instead of recursing down -->
<!-- it.  @code{chain_next} is an expression for the next item in the list, -->
<!-- @code{chain_prev} is an expression for the previous item.  For singly -->
<!-- linked lists, use only @code{chain_next}; for doubly linked lists, use -->
<!-- both.  The machinery requires that taking the next item of the -->
<!-- previous item gives the original item.  @code{chain_circular} is similar -->
<!-- to @code{chain_next}, but can be used for circular single linked lists. -->
让类型系统知道对象是否经常被链接在长的链表中是有帮助的。这可以让其使用遍历链表的方式来替代递归调用，从而使得生成的代码使用很少的栈空间。<code>chain_next</code>是链表中的下一项，<code>chain_prev</code>是前一项。对于单向链表，只使用<code>chain_next</code>；对于双向链表，两者都使用。类型系统要求对一个项求<code>chain_prev</code>，然后 <code>chain_next</code>，可以得到原始的项。

     <p><a name="index-reorder-4964"></a><br><dt><code>reorder ("</code><var>function name</var><code>")</code><dd>
<!-- Some data structures depend on the relative ordering of pointers.  If -->
<!-- the precompiled header machinery needs to change that ordering, it -->
<!-- will call the function referenced by the @code{reorder} option, before -->
<!-- changing the pointers in the object that's pointed to by the field the -->
<!-- option applies to.  The function must take four arguments, with the -->
<!-- signature @samp{@w{void *, void *, gt_pointer_operator, void *}}. -->
<!-- The first parameter is a pointer to the structure that contains the -->
<!-- object being updated, or the object itself if there is no containing -->
<!-- structure.  The second parameter is a cookie that should be ignored. -->
<!-- The third parameter is a routine that, given a pointer, will update it -->
<!-- to its correct new value.  The fourth parameter is a cookie that must -->
<!-- be passed to the second parameter. -->
一些数据结构依赖于相应的指针顺序。如果预编译头文件系统需要改变顺序，其将会调用由<code>reorder</code>选项指定的函数。函数必须接收4个参数，&lsquo;<samp><span class="samp">void&nbsp;*,&nbsp;void&nbsp;*,&nbsp;gt_pointer_operator,&nbsp;void&nbsp;*<!-- /@w --></span></samp>&rsquo;。第一个参数是指向更新对象的结构体的指针，或者对象本身，如果没有包含的结构体。第二个参数为一个cookie，目前被忽略。第三个参数是一个函数，给定指针，将会更新该指针为正确的新值。第四个参数是一个cookie，且必须传给第二个参数。

     <!-- PCH cannot handle data structures that depend on the absolute values -->
     <!-- of pointers.  @code{reorder} functions can be expensive.  When -->
     <!-- possible, it is better to depend on properties of the data, like an ID -->
     <!-- number or the hash of a string instead. -->
     <p>PCH无法处理依赖于指针绝对值的数据结构。<code>reorder</code>函数代价很高。在可能的情况下，最好依赖于数据的属性，像ID号或者字符串的哈希值。

     <p><a name="index-variable_005fsize-4965"></a><br><dt><code>variable_size</code><dd>
<!-- The type machinery expects the types to be of constant size.  When this -->
<!-- is not true, for example, with structs that have array fields or unions, -->
<!-- the type machinery cannot tell how many bytes need to be allocated at -->
<!-- each allocation.  The @code{variable_size} is used to mark such types. -->
<!-- The type machinery then provides allocators that take a parameter -->
<!-- indicating an exact size of object being allocated.  Note that the size -->
<!-- must be provided in bytes whereas the @code{length} option works with -->
<!-- array lengths in number of elements. -->
类型系统期望类型是常数大小的。如果不这样，例如，对于具有数组域或者联合体域的结构体，类型系统则无法得知每次需要分配多少字节。<code>variable_size</code>用来标记这样的类型。类型系统则会提供一个分配器，接收一个参数，用来指示要被分配的对象的具体大小。注意，必须是字节为单位的大小，而<code>length</code>选项是用于数组长度，即元素个数。

     <!-- For example, -->
     <p>例如，
     <pre class="smallexample">          struct GTY((variable_size)) sorted_fields_type {
            int len;
            tree GTY((length ("%h.len"))) elts[1];
          };
</pre>
     <!-- Then the objects of @code{struct sorted_fields_type} are allocated in GC -->
     <!-- memory as follows: -->
     <p>则<code>struct sorted_fields_type</code>类型的对象在GC内存中会按照如下方式被分配：
     <pre class="smallexample">            field_vec = ggc_alloc_sorted_fields_type (size);
</pre>
     <!-- If @var{field_vec->elts} stores @var{n} elements, then @var{size} -->
     <!-- could be calculated as follows: -->
     <p>如果<var>field_vec-&gt;elts</var>存储了<var>n</var>个元素，则<var>size</var>可以按照如下方式来计算：
     <pre class="smallexample">            size_t size = sizeof (struct sorted_fields_type) + n * sizeof (tree);
</pre>
     <p><a name="index-atomic-4966"></a><br><dt><code>atomic</code><dd>
The <code>atomic</code> option can only be used with pointers.  It informs
the GC machinery that the memory that the pointer points to does not
contain any pointers, and hence it should be treated by the GC and PCH
machinery as an &ldquo;atomic&rdquo; block of memory that does not need to be
examined when scanning memory for pointers.  In particular, the
machinery will not scan that memory for pointers to mark them as
reachable (when marking pointers for GC) or to relocate them (when
writing a PCH file).

     <p>The <code>atomic</code> option differs from the <code>skip</code> option. 
<code>atomic</code> keeps the memory under Garbage Collection, but makes the
GC ignore the contents of the memory.  <code>skip</code> is more drastic in
that it causes the pointer and the memory to be completely ignored by
the Garbage Collector.  So, memory marked as <code>atomic</code> is
automatically freed when no longer reachable, while memory marked as
<code>skip</code> is not.

     <p>The <code>atomic</code> option must be used with great care, because all
sorts of problem can occur if used incorrectly, that is, if the memory
the pointer points to does actually contain a pointer.

     <p>Here is an example of how to use it:
     <pre class="smallexample">          struct GTY(()) my_struct {
            int number_of_elements;
            unsigned int GTY ((atomic)) * elements;
          };
</pre>
     <p>In this case, <code>elements</code> is a pointer under GC, and the memory it
points to needs to be allocated using the Garbage Collector, and will
be freed automatically by the Garbage Collector when it is no longer
referenced.  But the memory that the pointer points to is an array of
<code>unsigned int</code> elements, and the GC must not try to scan it to
find pointers to mark or relocate, which is why it is marked with the
<code>atomic</code> option.

     <p>Note that, currently, global variables can not be marked with
<code>atomic</code>; only fields of a struct can.  This is a known
limitation.  It would be useful to be able to mark global pointers
with <code>atomic</code> to make the PCH machinery aware of them so that
they are saved and restored correctly to PCH files.

     <p><a name="index-special-4967"></a><br><dt><code>special ("</code><var>name</var><code>")</code><dd>
<!-- The @code{special} option is used to mark types that have to be dealt -->
<!-- with by special case machinery.  The parameter is the name of the -->
<!-- special case.  See @file{gengtype.c} for further details.  Avoid -->
<!-- adding new special cases unless there is no other alternative. -->
<code>special</code>选项用来标记类型必须由特定情况的机制来处理。参数是特定情况的名字。详细信息参见<samp><span class="file">gengtype.c</span></samp>。应避免添加新的特定情况，除非没有别的办法。
</dl>

<!-- @node GGC Roots -->
<!-- @section Marking Roots for the Garbage Collector -->
 </body></html>

