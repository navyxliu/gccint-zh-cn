<html lang="zh">
<head>
<title>Values in Registers - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Registers.html#Registers" title="Registers">
<link rel="prev" href="Allocation-Order.html#Allocation-Order" title="Allocation Order">
<link rel="next" href="Leaf-Functions.html#Leaf-Functions" title="Leaf Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Values-in-Registers"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Leaf-Functions.html#Leaf-Functions">Leaf Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Allocation-Order.html#Allocation-Order">Allocation Order</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Registers.html#Registers">Registers</a>
<hr>
</div>

<h4 class="subsection">17.7.3 如何使值适合寄存器</h4>

<!-- This section discusses the macros that describe which kinds of values -->
<!-- (specifically, which machine modes) each register can hold, and how many -->
<!-- consecutive registers are needed for a given mode. -->
<p>这节讨论的宏，描述了每个寄存器可以存放哪类的值（明确的说，是哪些机器模式的），以及对于给定的机器模式需要多少个连续的寄存器。

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_NREGS</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fNREGS-3980"></a></var><br>
<blockquote><!-- A C expression for the number of consecutive hard registers, starting -->
     <!-- at register number @var{regno}, required to hold a value of mode -->
     <!-- @var{mode}.  This macro must never return zero, even if a register -->
     <!-- cannot hold the requested mode - indicate that with HARD_REGNO_MODE_OK -->
     <!-- and/or CANNOT_CHANGE_MODE_CLASS instead. -->
      <p>一个C表达式，为存放模式<var>mode</var>的值所需要的连续的硬件寄存器，起始于寄存器编号<var>regno</var>。该宏不要返回0，即使寄存器不能存放指定的mode —— 替代的，使用HARD_REGNO_MODE_OK 和/或 CANNOT_CHANGE_MODE_CLASS。

     <!-- On a machine where all registers are exactly one word, a suitable -->
     <!-- definition of this macro is -->
      <p>在所有寄存器都是一个字大小的机器上，该宏的一个合适的定义为

     <pre class="smallexample">          #define HARD_REGNO_NREGS(REGNO, MODE)            \
             ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
              / UNITS_PER_WORD)
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_NREGS_HAS_PADDING</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fNREGS_005fHAS_005fPADDING-3981"></a></var><br>
<blockquote><!-- A C expression that is nonzero if a value of mode @var{mode}, stored -->
     <!-- in memory, ends with padding that causes it to take up more space than -->
     <!-- in registers starting at register number @var{regno} (as determined by -->
     <!-- multiplying GCC's notion of the size of the register when containing -->
     <!-- this mode by the number of registers returned by -->
     <!-- @code{HARD_REGNO_NREGS}).  By default this is zero. -->
      <p>一个C表达式，为非0，如果模式为<var>mode</var>的值，存储在内存中，并由padding结尾，这使得其占有更多的空间，比在起始于寄存器编号<var>regno</var>的寄存器中。缺省的为0。

     <!-- For example, if a floating-point value is stored in three 32-bit -->
     <!-- registers but takes up 128 bits in memory, then this would be -->
     <!-- nonzero. -->
      <p>例如，如果浮点值存储在三个32位寄存器中，但是在内存中占有128位，则该宏应该为非0。

     <!-- This macros only needs to be defined if there are cases where -->
     <!-- @code{subreg_get_info} -->
     <!-- would otherwise wrongly determine that a @code{subreg} can be -->
     <!-- represented by an offset to the register number, when in fact such a -->
     <!-- @code{subreg} would contain some of the padding not stored in -->
     <!-- registers and so not be representable. -->
      <p>该宏只有当<code>subreg_get_info</code>会错误的确定一个<code>subreg</code>可以通过寄存器编号的偏移量来表示，而实际上这样的<code>subreg</code>将会保存一些不应该被表示的padding时，才需要被定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_NREGS_WITH_PADDING</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fNREGS_005fWITH_005fPADDING-3982"></a></var><br>
<blockquote><!-- For values of @var{regno} and @var{mode} for which -->
     <!-- @code{HARD_REGNO_NREGS_HAS_PADDING} returns nonzero, a C expression -->
     <!-- returning the greater number of registers required to hold the value -->
     <!-- including any padding.  In the example above, the value would be four. -->
      <p>对于<code>HARD_REGNO_NREGS_HAS_PADDING</code>会返回非0的<var>regno</var>和<var>mode</var>的值，其为一个C表达式，返回保存包括任何padding的值所需要的寄存器的最大数。在上面的例子中，值将为4。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGMODE_NATURAL_SIZE</b> (<var>mode</var>)<var><a name="index-REGMODE_005fNATURAL_005fSIZE-3983"></a></var><br>
<blockquote><!-- Define this macro if the natural size of registers that hold values -->
     <!-- of mode @var{mode} is not the word size.  It is a C expression that -->
     <!-- should give the natural size in bytes for the specified mode.  It is -->
     <!-- used by the register allocator to try to optimize its results.  This -->
     <!-- happens for example on SPARC 64-bit where the natural size of -->
     <!-- floating-point registers is still 32-bit. -->
      <p>定义该宏，如果存放模式<var>mode</var>的值的寄存器的自然大小，不是word大小。其为一个C表达式，对于指定的mode给出以字节为单位的自然的大小。其被寄存器分配用于尝试优化它的结果。例如这出现在SPARC 64位机器上，其浮点寄存器的自然大小仍然是32位。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_MODE_OK</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fMODE_005fOK-3984"></a></var><br>
<blockquote><!-- A C expression that is nonzero if it is permissible to store a value -->
     <!-- of mode @var{mode} in hard register number @var{regno} (or in several -->
     <!-- registers starting with that one).  For a machine where all registers -->
     <!-- are equivalent, a suitable definition is -->
      <p>一个C表达式，其为非0，如果允许将一个<var>mode</var>模式的值存储在硬件寄存器编号<var>regno</var>（或者起始于它的多个寄存器）中。对于所有寄存器都是等价的机器上，一个合适的定义为

     <pre class="smallexample">          #define HARD_REGNO_MODE_OK(REGNO, MODE) 1
</pre>
      <!-- You need not include code to check for the numbers of fixed registers, -->
     <!-- because the allocation mechanism considers them to be always occupied. -->
      <p>你不需要包含检查固定寄存器编号的代码，因为分配机制总是认为它们已经被占用了。

      <p><a name="index-register-pairs-3985"></a><!-- On some machines, double-precision values must be kept in even/odd -->
<!-- register pairs.  You can implement that by defining this macro to reject -->
<!-- odd register numbers for such modes. -->
在一些机器上，双精度值必须放在偶/奇寄存器对。你可以通过定义该宏来拒绝这样模式的奇数寄存器编号。

     <!-- The minimum requirement for a mode to be OK in a register is that the -->
     <!-- @samp{mov@var{mode}} instruction pattern support moves between the -->
     <!-- register and other hard register in the same class and that moving a -->
     <!-- value into the register and back out not alter it. -->
      <p>对于一个模式可以放在寄存器中的最小需求为，&lsquo;<samp><span class="samp">mov</span><var>mode</var></samp>&rsquo;指令模式支持在寄存器和同一类别的其它硬件寄存器之间的移动，并且将一个值移动到寄存器中并移动回来，而不会改变。

     <!-- Since the same instruction used to move @code{word_mode} will work for -->
     <!-- all narrower integer modes, it is not necessary on any machine for -->
     <!-- @code{HARD_REGNO_MODE_OK} to distinguish between these modes, provided -->
     <!-- you define patterns @samp{movhi}, etc., to take advantage of this.  This -->
     <!-- is useful because of the interaction between @code{HARD_REGNO_MODE_OK} -->
     <!-- and @code{MODES_TIEABLE_P}; it is very desirable for all integer modes -->
     <!-- to be tieable. -->
      <p>由于用于move <code>word_mode</code>的同一指令，也可以用于所有更窄的整数模式，所以<code>HARD_REGNO_MODE_OK</code>不必要在任何机器上对于这些模式都不同，假定你定义了指令模式&lsquo;<samp><span class="samp">movhi</span></samp>&rsquo;等。

     <!-- Many machines have special registers for floating point arithmetic. -->
     <!-- Often people assume that floating point machine modes are allowed only -->
     <!-- in floating point registers.  This is not true.  Any registers that -->
     <!-- can hold integers can safely @emph{hold} a floating point machine -->
     <!-- mode, whether or not floating arithmetic can be done on it in those -->
     <!-- registers.  Integer move instructions can be used to move the values. -->
      <p>许多机器对于浮点算术具有特定的寄存器。通常人们假设浮点机器模式只在浮点寄存器中被允许。这并不真实。任何可以存放整数的寄存器都可以安全的存放一个浮点机器模式，而不管是否可以在这些寄存器上进行浮点算术。整数move指令可以用于移动这些值。

     <!-- On some machines, though, the converse is true: fixed-point machine -->
     <!-- modes may not go in floating registers.  This is true if the floating -->
     <!-- registers normalize any value stored in them, because storing a -->
     <!-- non-floating value there would garble it.  In this case, -->
     <!-- @code{HARD_REGNO_MODE_OK} should reject fixed-point machine modes in -->
     <!-- floating registers.  But if the floating registers do not automatically -->
     <!-- normalize, if you can store any bit pattern in one and retrieve it -->
     <!-- unchanged without a trap, then any machine mode may go in a floating -->
     <!-- register, so you can define this macro to say so. -->
      <p>然而在一些机器上，定点机器模式不可以放在浮点寄存器中。比如如果浮点寄存器对任何存储的值进行标准化，因为存储一个非浮点值将会使值变得混淆。这种情况下，<code>HARD_REGNO_MODE_OK</code>应该拒绝定点机器模式放在浮点寄存器中。但是，如果浮点寄存器不自动标准化，如果你可以存储任何位的指令模式并无需改动的获得它，则任何机器模式都可以放在浮点寄存器中，这样你可以定义该宏来表明可以这么做。

     <!-- The primary significance of special floating registers is rather that -->
     <!-- they are the registers acceptable in floating point arithmetic -->
     <!-- instructions.  However, this is of no concern to -->
     <!-- @code{HARD_REGNO_MODE_OK}.  You handle it by writing the proper -->
     <!-- constraints for those instructions. -->
      <p>当然，特定的浮点寄存器的主要意义是它们在浮点算术指令中可以使用。但是，这根<code>HARD_REGNO_MODE_OK</code>没有关系。你可以通过对那些执行写合适的约束来处理。

     <!-- On some machines, the floating registers are especially slow to access, -->
     <!-- so that it is better to store a value in a stack frame than in such a -->
     <!-- register if floating point arithmetic is not being done.  As long as the -->
     <!-- floating registers are not in class @code{GENERAL_REGS}, they will not -->
     <!-- be used unless some pattern's constraint asks for one. -->
      <p>在一些机器上，浮点寄存器访问起来特别慢，所以如果浮点算术没有完成前，最好将值存在栈帧中，而不是在这样的寄存器中。只要浮点寄存器不在<code>GENERAL_REGS</code>类别中，它们将不会被使用，除非某个指令模式的约束要求这样。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_RENAME_OK</b> (<var>from, to</var>)<var><a name="index-HARD_005fREGNO_005fRENAME_005fOK-3986"></a></var><br>
<blockquote><!-- A C expression that is nonzero if it is OK to rename a hard register -->
     <!-- @var{from} to another hard register @var{to}. -->
      <p>一个C表达式，为非0，如果可以将一个硬件寄存器<var>from</var>重命名为另一个寄存器<var>to</var>。

     <!-- One common use of this macro is to prevent renaming of a register to -->
     <!-- another register that is not saved by a prologue in an interrupt -->
     <!-- handler. -->
      <p>该宏的一个通用的用法是防止将一个寄存器重命名为另一个寄存器，而其在中断处理函数的序言中没有被保存。

     <!-- The default is always nonzero. -->
      <p>缺省总是为非0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MODES_TIEABLE_P</b> (<var>mode1, mode2</var>)<var><a name="index-MODES_005fTIEABLE_005fP-3987"></a></var><br>
<blockquote><!-- A C expression that is nonzero if a value of mode -->
     <!-- @var{mode1} is accessible in mode @var{mode2} without copying. -->
      <p>一个C表达式，其为非0，如果一个模式<var>mode1</var>的值，不需要复制便可以按照模式<var>mode2</var>来访问。

     <!-- If @code{HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and -->
     <!-- @code{HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same for -->
     <!-- any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})} -->
     <!-- should be nonzero.  If they differ for any @var{r}, you should define -->
     <!-- this macro to return zero unless some other mechanism ensures the -->
     <!-- accessibility of the value in a narrower mode. -->
      <p>如果<code>HARD_REGNO_MODE_OK (</code><var>r</var><code>, </code><var>mode1</var><code>)</code>和<code>HARD_REGNO_MODE_OK (</code><var>r</var><code>, </code><var>mode2</var><code>)</code>对于任何<var>r</var>总是相同，则<code>MODES_TIEABLE_P (</code><var>mode1</var><code>, </code><var>mode2</var><code>)</code>应该为非0。如果它们对于任何<var>r</var>都不同，则你应该定义该宏来返回0，除非某个其它机制能够确保值可以按照更窄的模式来访问。

     <!-- You should define this macro to return nonzero in as many cases as -->
     <!-- possible since doing so will allow GCC to perform better register -->
     <!-- allocation. -->
      <p>你应该定义该宏来尽可能情况的返回非0，因为这样会使得GCC执行更好的寄存器分配。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_HARD_REGNO_SCRATCH_OK</b> (<var>unsigned int regno</var>)<var><a name="index-TARGET_005fHARD_005fREGNO_005fSCRATCH_005fOK-3988"></a></var><br>
<blockquote><!-- This target hook should return @code{true} if it is OK to use a hard register -->
     <!-- @var{regno} as scratch reg in peephole2. -->
      <p>如果在peephole2中可以使用硬件寄存器<var>regno</var>来作为临时寄存器，则该目标钩子应该返回<code>true</code>。

     <!-- One common use of this macro is to prevent using of a register that -->
     <!-- is not saved by a prologue in an interrupt handler. -->
      <p>该宏的一种通常用法为阻止在中断处理中，对函数起始处没有保存的寄存器的使用。

     <!-- The default version of this hook always returns @code{true}. -->
      <p>该钩子的缺省版本总是返回<code>true</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>AVOID_CCMODE_COPIES</b><var><a name="index-AVOID_005fCCMODE_005fCOPIES-3989"></a></var><br>
<blockquote><!-- Define this macro if the compiler should avoid copies to/from @code{CCmode} -->
     <!-- registers.  You should only define this macro if support for copying to/from -->
     <!-- @code{CCmode} is incomplete. -->
      <p>如果编译器应该避免从/向<code>CCmode</code>寄存器中进行复制，则定义该宏。应该只有当从/向<code>CCmode</code>寄存器中进行复制，支持的不完善的时候，才定义该宏。
</p></blockquote></div>

<!-- @node Leaf Functions -->
<!-- @subsection Handling Leaf Functions -->
 </body></html>

