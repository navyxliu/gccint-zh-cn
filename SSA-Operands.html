<html lang="zh">
<head>
<title>SSA Operands - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tree-SSA.html#Tree-SSA" title="Tree SSA">
<link rel="prev" href="Annotations.html#Annotations" title="Annotations">
<link rel="next" href="SSA.html#SSA" title="SSA">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="SSA-Operands"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="SSA.html#SSA">SSA</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Annotations.html#Annotations">Annotations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tree-SSA.html#Tree-SSA">Tree SSA</a>
<hr>
</div>

<h3 class="section">13.2 SSA操作数</h3>

<p><a name="index-operands-3093"></a><a name="index-virtual-operands-3094"></a><a name="index-real-operands-3095"></a><a name="index-update_005fstmt-3096"></a>
<!-- Almost every GIMPLE statement will contain a reference to a variable -->
<!-- or memory location.  Since statements come in different shapes and -->
<!-- sizes, their operands are going to be located at various spots inside -->
<!-- the statement's tree.  To facilitate access to the statement's -->
<!-- operands, they are organized into lists associated inside each -->
<!-- statement's annotation.  Each element in an operand list is a pointer -->
<!-- to a @code{VAR_DECL}, @code{PARM_DECL} or @code{SSA_NAME} tree node. -->
<!-- This provides a very convenient way of examining and replacing -->
<!-- operands. -->
几乎每条GIMPLE语句都会包含对变量或者内存地址的引用。由于语句的形状和大小不同，
它们的操作数也将会位于语句树中的不同位置。为了便于访问语句的操作数，
它们被组织到与语句的注解（annotation）相关联的一个列表中。
操作数列表中的每个元素都是一个指向<code>VAR_DECL</code>, <code>PARM_DECL</code>
或<code>SSA_NAME</code>树结点的指针。这就为检查和替换操作数提供了一种非常方便的方法。

<!-- Data flow analysis and optimization is done on all tree nodes -->
<!-- representing variables.  Any node for which @code{SSA_VAR_P} returns -->
<!-- nonzero is considered when scanning statement operands.  However, not -->
<!-- all @code{SSA_VAR_P} variables are processed in the same way.  For the -->
<!-- purposes of optimization, we need to distinguish between references to -->
<!-- local scalar variables and references to globals, statics, structures, -->
<!-- arrays, aliased variables, etc.  The reason is simple, the compiler -->
<!-- can gather complete data flow information for a local scalar.  On the -->
<!-- other hand, a global variable may be modified by a function call, it -->
<!-- may not be possible to keep track of all the elements of an array or -->
<!-- the fields of a structure, etc. -->
 <p>数据流分析和优化是在所有表示变量的树结点上完成的。扫描语句操作数时，
将会考虑所有<code>SSA_VAR_P</code>返回非零的节点。但是，
并不是所有的<code>SSA_VAR_P</code>变量都使用同一种方式来处理。出于优化的目的，
我们需要区分对局部标量的引用和对全局变量，静态变量，结构体，数组，别名变量的引用，等等。
原因很简单，一方面，编译器能够为局部标量收集完整的数据流信息；另一方面，
全局变量可能会被函数调用所修改，
另外，可能无法追踪数组所有的元素或结构体所有的域的信息，等等。

<!-- The operand scanner gathers two kinds of operands: @dfn{real} and -->
<!-- @dfn{virtual}.  An operand for which @code{is_gimple_reg} returns true -->
<!-- is considered real, otherwise it is a virtual operand.  We also -->
<!-- distinguish between uses and definitions.  An operand is used if its -->
<!-- value is loaded by the statement (e.g., the operand at the RHS of an -->
<!-- assignment).  If the statement assigns a new value to the operand, the -->
<!-- operand is considered a definition (e.g., the operand at the LHS of -->
<!-- an assignment). -->
 <p>操作数扫描器搜集两类操作数：实的（<dfn>real</dfn>）和虚的（<dfn>virtual</dfn>）。
<code>is_gimple_reg</code>返回真的操作数被认为是实操作数，否则为一个虚操作数。
我们还区分了它们的使用和定义。如果操作数的值被语句加载（例如，操作数在赋值的右边），
则为使用。如果语句给操作数赋于了一个新的值（例如，操作数在赋值语句的左边），则为定义。

<!-- Virtual and real operands also have very different data flow -->
<!-- properties.  Real operands are unambiguous references to the -->
<!-- full object that they represent.  For instance, given -->
 <p>虚操作数和实操作数还具有不同的数据流属性。
实操作数是对它们表示的完整对象的明确引用。例如，给定

<pre class="smallexample">     {
       int a, b;
       a = b
     }
</pre>
 <!-- Since @code{a} and @code{b} are non-aliased locals, the statement -->
<!-- @code{a = b} will have one real definition and one real use because -->
<!-- variable @code{a} is completely modified with the contents of -->
<!-- variable @code{b}.  Real definition are also known as @dfn{killing -->
<!-- definitions}.  Similarly, the use of @code{b} reads all its bits. -->
 <p>由于<code>a</code>和<code>b</code>为非别名的局部变量，
语句<code>a = b</code>将具有一个实定义和一个实使用，
因为变量<code>a</code>完全被变量<code>b</code>的内容修改了。
实定义还被称作为<dfn>killing definition</dfn>（杀死定义）。
类似的，对<code>b</code>的使用是读取了它的所有位。

<!-- In contrast, virtual operands are used with variables that can have -->
<!-- a partial or ambiguous reference.  This includes structures, arrays, -->
<!-- globals, and aliased variables.  In these cases, we have two types of -->
<!-- definitions.  For globals, structures, and arrays, we can determine from -->
<!-- a statement whether a variable of these types has a killing definition. -->
<!-- If the variable does, then the statement is marked as having a -->
<!-- @dfn{must definition} of that variable.  However, if a statement is only -->
<!-- defining a part of the variable (i.e.@: a field in a structure), or if we -->
<!-- know that a statement might define the variable but we cannot say for sure, -->
<!-- then we mark that statement as having a @dfn{may definition}.  For -->
<!-- instance, given -->
 <p>与此相反，虚操作数用于具有部分或者不明确引用的变量。这包括结构体，数组，全局变量和别名变量。
这些情况下，我们具有两种类型的定义。对于全局变量，结构体和数组，
我们能够从语句中确定这些类型的变量是否具有一个killing definition（杀死定义）。如果具有，
则语句被标记为具有那个变量的必然定义（<dfn>must definition</dfn>）。但是，
如果语句只是定义了变量的一部分（即，结构体中的一个域），
或者如果我们知道语句可能会定义变量，但是不确定，
则我们将那条语句标记为具有一个可能定义（<dfn>may definition</dfn>）。例如，给定

<pre class="smallexample">     {
       int a, b, *p;
     
       if (...)
         p = &amp;a;
       else
         p = &amp;b;
       *p = 5;
       return *p;
     }
</pre>
 <!-- The assignment @code{*p = 5} may be a definition of @code{a} or -->
<!-- @code{b}.  If we cannot determine statically where @code{p} is -->
<!-- pointing to at the time of the store operation, we create virtual -->
<!-- definitions to mark that statement as a potential definition site for -->
<!-- @code{a} and @code{b}.  Memory loads are similarly marked with virtual -->
<!-- use operands.  Virtual operands are shown in tree dumps right before -->
<!-- the statement that contains them.  To request a tree dump with virtual -->
<!-- operands, use the @option{-vops} option to @option{-fdump-tree}: -->
 <p>赋值<code>*p = 5</code>可能为<code>a</code>或者<code>b</code>的定义。
如果我们不能静态地确定在存储操作的时候<code>p</code>的指向，
我们便创建一个虚定义来标记那条语句为一个<code>a</code>和<code>b</code>的潜在的定义。
内存加载也类似的使用虚操作数进行标记。
虚操作数在树转储（dump）中显示在包含它们的语句前面。
要获得带有虚操作数的树转储，使用<samp><span class="option">-fdump-tree</span></samp>的<samp><span class="option">-vops</span></samp>选项：

<pre class="smallexample">     {
       int a, b, *p;
     
       if (...)
         p = &amp;a;
       else
         p = &amp;b;
       # a = VDEF &lt;a&gt;
       # b = VDEF &lt;b&gt;
       *p = 5;
     
       # VUSE &lt;a&gt;
       # VUSE &lt;b&gt;
       return *p;
     }
</pre>
 <!-- Notice that @code{VDEF} operands have two copies of the referenced -->
<!-- variable.  This indicates that this is not a killing definition of -->
<!-- that variable.  In this case we refer to it as a @dfn{may definition} -->
<!-- or @dfn{aliased store}.  The presence of the second copy of the -->
<!-- variable in the @code{VDEF} operand will become important when the -->
<!-- function is converted into SSA form.  This will be used to link all -->
<!-- the non-killing definitions to prevent optimizations from making -->
<!-- incorrect assumptions about them. -->
 <p>注意<code>VDEF</code>操作数具有被引用变量的两个副本。
这表明不是一个那个变量的killing definition（杀死定义）。在这种情况下，
我们称它为一个可能定义（<dfn>may definition</dfn>）或者
别名存储（<dfn>aliased store</dfn>）。
当函数被转换为SSA形式的时候，<code>VDEF</code>操作数的第二个变量副本将会变得很重要。
其将用于链接所有的非killing definition（杀死定义），用来防止优化对它们做错误的假设。

<!-- Operands are updated as soon as the statement is finished via a call -->
<!-- to @code{update_stmt}.  If statement elements are changed via -->
<!-- @code{SET_USE} or @code{SET_DEF}, then no further action is required -->
<!-- (i.e., those macros take care of updating the statement).  If changes -->
<!-- are made by manipulating the statement's tree directly, then a call -->
<!-- must be made to @code{update_stmt} when complete.  Calling one of the -->
<!-- @code{bsi_insert} routines or @code{bsi_replace} performs an implicit -->
<!-- call to @code{update_stmt}. -->
 <p>当语句完成时，便会立刻通过调用<code>update_stmt</code>来更新操作数。
如果语句元素通过<code>SET_USE</code>或<code>SET_DEF</code>被改变，
则不需要进一步的动作（即，那些宏会处理好语句更新）。
如果改变是通过直接操作语句的树，则必须在完成时调用<code>update_stmt</code>。
调用<code>bsi_insert</code>例程中的任何一个，或者<code>bsi_replace</code>，
都会隐式的调用<code>update_stmt</code>。

<!-- @subsection Operand Iterators And Access Routines -->
<h4 class="subsection">13.2.1 操作数迭代器和访问例程</h4>

<p><a name="index-Operand-Iterators-3097"></a><a name="index-Operand-Access-Routines-3098"></a>
<!-- Operands are collected by @file{tree-ssa-operands.c}.  They are stored -->
<!-- inside each statement's annotation and can be accessed through either the -->
<!-- operand iterators or an access routine. -->
与操作数相关的代码都在<samp><span class="file">tree-ssa-operands.c</span></samp>中。
操作数被存储在每条语句的注解中并且可以通过操作数迭代器或者访问例程来访问。

<!-- The following access routines are available for examining operands: -->
 <p>下列访问例程可以用来检查操作数：

     <ol type=1 start=1>
<!-- @item @code{SINGLE_SSA_@{USE,DEF,TREE@}_OPERAND}: These accessors will return -->
<!-- NULL unless there is exactly one operand matching the specified flags.  If -->
<!-- there is exactly one operand, the operand is returned as either a @code{tree}, -->
<!-- @code{def_operand_p}, or @code{use_operand_p}. -->
<!-- @item @code{SINGLE_SSA_@{USE,DEF,TREE@}_OPERAND}: -->
这些访问例程将会返回NULL，除非恰好有一个操作数匹配指定的标志。
如果恰好存在一个操作数，则操作数被作为<code>tree</code>,<code>def_operand_p</code>或者
<code>use_operand_p</code>返回。

     <pre class="smallexample">          tree t = SINGLE_SSA_TREE_OPERAND (stmt, flags);
          use_operand_p u = SINGLE_SSA_USE_OPERAND (stmt, SSA_ALL_VIRTUAL_USES);
          def_operand_p d = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_ALL_DEFS);
</pre>
     <!-- @item @code{ZERO_SSA_OPERANDS}: This macro returns true if there are no -->
     <!-- operands matching the specified flags. -->
     <li><code>ZERO_SSA_OPERANDS</code>: 该宏返回真，如果没有操作数匹配指定的标志。

     <pre class="smallexample">          if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))
            return;
</pre>
     <!-- @item @code{NUM_SSA_OPERANDS}: This macro Returns the number of operands -->
     <!-- matching 'flags'.  This actually executes a loop to perform the count, so -->
     <!-- only use this if it is really needed. -->
     <li><code>NUM_SSA_OPERANDS</code>:
该宏返回匹配'flags'的操作数数目。其实际上是执行了一个循环来进行统计，
所以最好只有在真正需要的时候才使用它。

     <pre class="smallexample">          int count = NUM_SSA_OPERANDS (stmt, flags)
</pre>
     </ol>

<!-- If you wish to iterate over some or all operands, use the -->
<!-- @code{FOR_EACH_SSA_@{USE,DEF,TREE@}_OPERAND} iterator.  For example, to print -->
<!-- all the operands for a statement: -->
 <p>如果你想迭代一些或者所有操作数，
使用<code>FOR_EACH_SSA_{USE,DEF,TREE}_OPERAND</code>迭代器。
例如，要打印语句的所有操作数：

<pre class="smallexample">     void
     print_ops (tree stmt)
     {
       ssa_op_iter;
       tree var;
     
       FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)
         print_generic_expr (stderr, var, TDF_SLIM);
     }
</pre>
 <!-- How to choose the appropriate iterator: -->
 <p>如何选择合适的迭代器：

     <ol type=1 start=1>
<!-- @item Determine whether you are need to see the operand pointers, or just the -->
<!-- trees, and choose the appropriate macro: -->
<li>确定你是否需要看到操作数指针，或者只是树，并选择合适的宏

     <pre class="smallexample">          Need            Macro:
          ----            -------
          use_operand_p   FOR_EACH_SSA_USE_OPERAND
          def_operand_p   FOR_EACH_SSA_DEF_OPERAND
          tree            FOR_EACH_SSA_TREE_OPERAND
</pre>
     <!-- @item You need to declare a variable of the type you are interested -->
     <!-- in, and an ssa_op_iter structure which serves as the loop controlling -->
     <!-- variable. -->
     <li>你需要声明一个你感兴趣的类型的变量，和一个用作循环控制变量的ssa_op_iter结构体

     <!-- @item Determine which operands you wish to use, and specify the flags of -->
     <!-- those you are interested in.  They are documented in -->
     <!-- @file{tree-ssa-operands.h}: -->
     <li>确定你想使用哪些操作数，并指定你所感兴趣的那些操作数的标志。
这些标志在<samp><span class="file">tree-ssa-operands.h</span></samp>中声明：

     <pre class="smallexample">          #define SSA_OP_USE              0x01    /* <span class="roman">Real USE operands.</span>  */
          #define SSA_OP_DEF              0x02    /* <span class="roman">Real DEF operands.</span>  */
          #define SSA_OP_VUSE             0x04    /* <span class="roman">VUSE operands.</span>  */
          #define SSA_OP_VMAYUSE          0x08    /* <span class="roman">USE portion of VDEFS.</span>  */
          #define SSA_OP_VDEF             0x10    /* <span class="roman">DEF portion of VDEFS.</span>  */
          
          /* <span class="roman">These are commonly grouped operand flags.</span>  */
          #define SSA_OP_VIRTUAL_USES     (SSA_OP_VUSE | SSA_OP_VMAYUSE)
          #define SSA_OP_VIRTUAL_DEFS     (SSA_OP_VDEF)
          #define SSA_OP_ALL_USES         (SSA_OP_VIRTUAL_USES | SSA_OP_USE)
          #define SSA_OP_ALL_DEFS         (SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)
          #define SSA_OP_ALL_OPERANDS     (SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)
</pre>
     </ol>

<!-- So if you want to look at the use pointers for all the @code{USE} and -->
<!-- @code{VUSE} operands, you would do something like: -->
 <p>所以，如果你想查看所有<code>USE</code>和<code>VUSE</code>操作数的use指针，
则可以使用类似下面的方法：

<pre class="smallexample">       use_operand_p use_p;
       ssa_op_iter iter;
     
       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, (SSA_OP_USE | SSA_OP_VUSE))
         {
           process_use_ptr (use_p);
         }
</pre>
 <!-- The @code{TREE} macro is basically the same as the @code{USE} and -->
<!-- @code{DEF} macros, only with the use or def dereferenced via -->
<!-- @code{USE_FROM_PTR (use_p)} and @code{DEF_FROM_PTR (def_p)}.  Since we -->
<!-- aren't using operand pointers, use and defs flags can be mixed. -->
 <p>宏<code>TREE</code>基本上与宏<code>USE</code>和<code>DEF</code>相同，
除了通过<code>USE_FROM_PTR (use_p)</code>和<code>DEF_FROM_PTR (def_p)</code>进行的
use或def的解引用。因为我们不会使用操作数指针，所以可以混合use和def标志。

<pre class="smallexample">       tree var;
       ssa_op_iter iter;
     
       FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE)
         {
            print_generic_expr (stderr, var, TDF_SLIM);
         }
</pre>
 <!-- @code{VDEF}s are broken into two flags, one for the -->
<!-- @code{DEF} portion (@code{SSA_OP_VDEF}) and one for the USE portion -->
<!-- (@code{SSA_OP_VMAYUSE}).  If all you want to look at are the -->
<!-- @code{VDEF}s together, there is a fourth iterator macro for this, -->
<!-- which returns both a def_operand_p and a use_operand_p for each -->
<!-- @code{VDEF} in the statement.  Note that you don't need any flags for -->
<!-- this one. -->
 <p><code>VDEF</code>被分解为两个标记，一个是<code>DEF</code>部分（<code>SSA_OP_VDEF</code>），
一个是USE部分（<code>SSA_OP_VMAYUSE</code>）。
如果你只是想要查看合在一起的<code>VDEF</code>，则可以使用第四个迭代器，
其返回语句中每个<code>VDEF</code>的 def_operand_p和use_operand_p。
注意该宏不需要任何标记。

<pre class="smallexample">       use_operand_p use_p;
       def_operand_p def_p;
       ssa_op_iter iter;
     
       FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)
         {
           my_code;
         }
</pre>
 <!-- There are many examples in the code as well, as well as the -->
<!-- documentation in @file{tree-ssa-operands.h}. -->
 <p>代码中也有很多例子，同时在<samp><span class="file">tree-ssa-operands.h</span></samp>中也有文档。

<!-- There are also a couple of variants on the stmt iterators regarding PHI -->
<!-- nodes. -->
 <p>还有一些stmt迭代器是用于处理PHI节点的。

<!-- @code{FOR_EACH_PHI_ARG} Works exactly like -->
<!-- @code{FOR_EACH_SSA_USE_OPERAND}, except it works over @code{PHI} arguments -->
<!-- instead of statement operands. -->
 <p><code>FOR_EACH_PHI_ARG</code>跟<code>FOR_EACH_SSA_USE_OPERAND</code>非常类似，
只不过它是工作于<code>PHI</code>参数，而不是语句操作数。

<pre class="smallexample">     /* Look at every virtual PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_VIRTUAL_USES)
     {
        my_code;
     }
     
     /* Look at every real PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_USES)
       my_code;
     
     /* Look at every PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_ALL_USES)
       my_code;
</pre>
 <!-- @code{FOR_EACH_PHI_OR_STMT_@{USE,DEF@}} works exactly like -->
<!-- @code{FOR_EACH_SSA_@{USE,DEF@}_OPERAND}, except it will function on -->
<!-- either a statement or a @code{PHI} node.  These should be used when it is -->
<!-- appropriate but they are not quite as efficient as the individual -->
<!-- @code{FOR_EACH_PHI} and @code{FOR_EACH_SSA} routines. -->
 <p><code>FOR_EACH_PHI_OR_STMT_{USE,DEF}</code>与
<code>FOR_EACH_SSA_{USE,DEF}_OPERAND</code>非常类似，
只不过它是作用于语句或者<code>PHI</code>节点。
这些宏可以在合适的时候使用，但是它们比单独使用<code>FOR_EACH_PHI</code>和
<code>FOR_EACH_SSA</code>例程的效率要低。

<pre class="smallexample">     FOR_EACH_PHI_OR_STMT_USE (use_operand_p, stmt, iter, flags)
       {
          my_code;
       }
     
     FOR_EACH_PHI_OR_STMT_DEF (def_operand_p, phi, iter, flags)
       {
          my_code;
       }
</pre>
 <!-- @subsection Immediate Uses -->
<h4 class="subsection">13.2.2 立即使用</h4>

<p><a name="index-Immediate-Uses-3099"></a>
<!-- Immediate use information is now always available.  Using the immediate use -->
<!-- iterators, you may examine every use of any @code{SSA_NAME}. For instance, -->
<!-- to change each use of @code{ssa_var} to @code{ssa_var2} and call fold_stmt on -->
<!-- each stmt after that is done: -->
现在immediate use（这个短语咋翻译？）信息总是可以被获得。
使用immediate use迭代器，你可以检查任意<code>SSA_NAME</code>的所有使用。
例如，要将<code>ssa_var</code>的所有使用改为<code>ssa_var2</code>，
并且之后在每个stmt上调用fold_stmt：

<pre class="smallexample">       use_operand_p imm_use_p;
       imm_use_iterator iterator;
       tree ssa_var, stmt;
     
     
       FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
         {
           FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
             SET_USE (imm_use_p, ssa_var_2);
           fold_stmt (stmt);
         }
</pre>
 <!-- There are 2 iterators which can be used. @code{FOR_EACH_IMM_USE_FAST} is -->
<!-- used when the immediate uses are not changed, i.e., you are looking at the -->
<!-- uses, but not setting them. -->
 <p>这里有两个可以使用的迭代器。
<code>FOR_EACH_IMM_USE_FAST</code>用于当immediate use没有被改变的情况下，即，
只是进行查看use，但不设置它们。

<!-- If they do get changed, then care must be taken that things are not changed -->
<!-- under the iterators, so use the @code{FOR_EACH_IMM_USE_STMT} and -->
<!-- @code{FOR_EACH_IMM_USE_ON_STMT} iterators.  They attempt to preserve the -->
<!-- sanity of the use list by moving all the uses for a statement into -->
<!-- a controlled position, and then iterating over those uses.  Then the -->
<!-- optimization can manipulate the stmt when all the uses have been -->
<!-- processed.  This is a little slower than the FAST version since it adds a -->
<!-- placeholder element and must sort through the list a bit for each statement. -->
<!-- This placeholder element must be also be removed if the loop is -->
<!-- terminated early.  The macro @code{BREAK_FROM_IMM_USE_SAFE} is provided -->
<!-- to do this : -->
 <p>如果确实要做改变，则必须要考虑到迭代器下没有被改变的事物，这时，
可以使用<code>FOR_EACH_IMM_USE_STMT</code>和<code>FOR_EACH_IMM_USE_ON_STMT</code>迭代器。
它们试图通过将语句的所有use移动到一个被控制的位置并对它们进行迭代的方式，
来保证use列表的完整性。然后优化就能够在所有的use被处理完后来操作stmt。
这比FAST版本的有点慢，因为它增加了一个占位元素并且必须对每条语句的列表进行排序。
如果循环被提前终止，则该占位元素还必须被移除。
宏<code>BREAK_FROM_IMM_USE_SAFE</code>用于做这个：

<pre class="smallexample">       FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
         {
           if (stmt == last_stmt)
             BREAK_FROM_SAFE_IMM_USE (iter);
     
           FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
             SET_USE (imm_use_p, ssa_var_2);
           fold_stmt (stmt);
         }
</pre>
 <!-- There are checks in @code{verify_ssa} which verify that the immediate use list -->
<!-- is up to date, as well as checking that an optimization didn't break from the -->
<!-- loop without using this macro.  It is safe to simply 'break'; from a -->
<!-- @code{FOR_EACH_IMM_USE_FAST} traverse. -->
 <p>在<code>verify_ssa</code>中有一些检测用来验证immediate use列表是最新的，
同时还检测一个优化是否没有使用该宏而中断循环。
在<code>FOR_EACH_IMM_USE_FAST</code>遍历中，直接使用'break'语句是安全的。

<!-- Some useful functions and macros: -->
<!-- @enumerate -->
<!-- @item  @code{has_zero_uses (ssa_var)} : Returns true if there are no uses of -->
<!-- @code{ssa_var}. -->
<!-- @item   @code{has_single_use (ssa_var)} : Returns true if there is only a -->
<!-- single use of @code{ssa_var}. -->
<!-- @item   @code{single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)} : -->
<!-- Returns true if there is only a single use of @code{ssa_var}, and also returns -->
<!-- the use pointer and statement it occurs in, in the second and third parameters. -->
<!-- @item   @code{num_imm_uses (ssa_var)} : Returns the number of immediate uses of -->
<!-- @code{ssa_var}. It is better not to use this if possible since it simply -->
<!-- utilizes a loop to count the uses. -->
<!-- @item  @code{PHI_ARG_INDEX_FROM_USE (use_p)} : Given a use within a @code{PHI} -->
<!-- node, return the index number for the use.  An assert is triggered if the use -->
<!-- isn't located in a @code{PHI} node. -->
<!-- @item  @code{USE_STMT (use_p)} : Return the statement a use occurs in. -->
<!-- @end enumerate -->
 <p>一些有用的函数和宏：
     <ol type=1 start=1>
<li><code>has_zero_uses (ssa_var)</code> : 如果没有<code>ssa_var</code>的使用，则返回真。
<li><code>has_single_use (ssa_var)</code> :
如果只有<code>ssa_var</code>的单个使用，则返回真。
<li><code>single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)</code> :
如果只有<code>ssa_var</code>的单个使用，则返回真，
并且还在第二和第三个参数中返回使用指针和所在的语句。
<li><code>num_imm_uses (ssa_var)</code> :
返回<code>ssa_var</code>的immediate use的数目。最好不要使用该宏，
因为它只是简单的使用循环来统计use。
<li><code>PHI_ARG_INDEX_FROM_USE (use_p)</code> :
给定一个在<code>PHI</code>节点中的use，返回use的索引数。
如果use不位于<code>PHI</code>节点中，则会触发一个断言。
<li><code>USE_STMT (use_p)</code> : 返回use所在的语句。
      </ol>

<!-- Note that uses are not put into an immediate use list until their statement is -->
<!-- actually inserted into the instruction stream via a @code{bsi_*} routine. -->
 <p>注意在语句通过<code>bsi_*</code>程序被实际插入指令流中之前，
use是不被放入immediate use列表中的。

<!-- It is also still possible to utilize lazy updating of statements, but this -->
<!-- should be used only when absolutely required.  Both alias analysis and the -->
<!-- dominator optimizations currently do this. -->
 <p>还可以使用懒散的语句更新方式，不过这应该在确实需要的时候才使用。
别名分析和dominator优化目前都采用了这种方式。

<!-- When lazy updating is being used, the immediate use information is out of date -->
<!-- and cannot be used reliably.  Lazy updating is achieved by simply marking -->
<!-- statements modified via calls to @code{mark_stmt_modified} instead of -->
<!-- @code{update_stmt}.  When lazy updating is no longer required, all the -->
<!-- modified statements must have @code{update_stmt} called in order to bring them -->
<!-- up to date.  This must be done before the optimization is finished, or -->
<!-- @code{verify_ssa} will trigger an abort. -->
 <p>当使用懒散更新（lazy updating）时，immediate use信息是过时的，不能被信赖。
懒散更新简单的调用<code>mark_stmt_modified</code>来标记语句被修改了，
而不使用<code>update_stmt</code>。当不再需要进行懒散更新时，
所有修改的语句都必须调用<code>update_stmt</code>来保持更新。
这必须在优化完成之前进行，否则<code>verify_ssa</code>将触发abort 异常中断。

<!-- This is done with a simple loop over the instruction stream: -->
 <p>这是通过对指令流进行简单的循环来实现的：

<pre class="smallexample">       block_stmt_iterator bsi;
       basic_block bb;
       FOR_EACH_BB (bb)
         {
           for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&amp;bsi))
             update_stmt_if_modified (bsi_stmt (bsi));
         }
</pre>
 <!-- @node SSA -->
<!-- @section Static Single Assignment -->
 </body></html>

