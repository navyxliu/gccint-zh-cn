<html lang="zh">
<head>
<title>Regs and Memory - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="Constants.html#Constants" title="Constants">
<link rel="next" href="Arithmetic.html#Arithmetic" title="Arithmetic">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Regs-and-Memory"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Arithmetic.html#Arithmetic">Arithmetic</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Constants.html#Constants">Constants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.8 寄存器和内存</h3>

<p><a name="index-RTL-register-expressions-1995"></a><a name="index-RTL-memory-expressions-1996"></a>
<!-- Here are the RTL expression types for describing access to machine -->
<!-- registers and to main memory. -->
这些是描述访问机器寄存器和内存的RTL表达式类型。

     
<a name="index-reg-1997"></a>
<a name="index-hard-registers-1998"></a>
<a name="index-pseudo-registers-1999"></a>
<dl><dt><code>(reg:</code><var>m</var> <var>n</var><code>)</code><dd><!-- For small values of the integer @var{n} (those that are less than -->
<!-- @code{FIRST_PSEUDO_REGISTER}), this stands for a reference to machine -->
<!-- register number @var{n}: a @dfn{hard register}.  For larger values of -->
<!-- @var{n}, it stands for a temporary value or @dfn{pseudo register}. -->
<!-- The compiler's strategy is to generate code assuming an unlimited -->
<!-- number of such pseudo registers, and later convert them into hard -->
<!-- registers or into memory references. -->
对于值小（那些小于<code>FIRST_PSEUDO_REGISTER</code>）的整数<var>n</var>，这表示对机器寄存器号为<var>n</var>的引用。对于值大的<var>n</var>，它表示一个临时的值或者伪寄存器（<dfn>pseudo register</dfn>）。编译器的策略是，在生成代码时假设有无限数目的伪寄存器，并在之后将它们转换为硬件寄存器（<dfn>hard register</dfn>）或者内存的引用。

     <!-- @var{m} is the machine mode of the reference.  It is necessary because -->
     <!-- machines can generally refer to each register in more than one mode. -->
     <!-- For example, a register may contain a full word but there may be -->
     <!-- instructions to refer to it as a half word or as a single byte, as -->
     <!-- well as instructions to refer to it as a floating point number of -->
     <!-- various precisions. -->
     <p><var>m</var>为引用的机器模式。指定机器模式是有必要的，因为机器通常可以使用多种机器模式来引用每个寄存器。例如，一个寄存器可以包含一个整字，但是可以有指令来作为半字或者一个单独的字节来引用，同样，也有指令可以作为不同精度的浮点来引用。

     <!-- Even for a register that the machine can access in only one mode, -->
     <!-- the mode must always be specified. -->
     <p>即使对于机器只能使用一种机器模式来引用的寄存器，mode也必须被指定。

     <!-- The symbol @code{FIRST_PSEUDO_REGISTER} is defined by the machine -->
     <!-- description, since the number of hard registers on the machine is an -->
     <!-- invariant characteristic of the machine.  Note, however, that not -->
     <!-- all of the machine registers must be general registers.  All the -->
     <!-- machine registers that can be used for storage of data are given -->
     <!-- hard register numbers, even those that can be used only in certain -->
     <!-- instructions or can hold only certain types of data. -->
     <p>符号<code>FIRST_PSEUDO_REGISTER</code>被机器描述定义，由于机器的硬件寄存器数目是一个不变的特征。然而要注意，并不是所有的机器寄存器都必须是通用寄存器。所有的可以用于存储数据的机器寄存器都为被给定硬件寄存器编号，即使那些只可以被用于特定指令或者只能存放特定类型数据。

     <!-- A hard register may be accessed in various modes throughout one -->
     <!-- function, but each pseudo register is given a natural mode -->
     <!-- and is accessed only in that mode.  When it is necessary to describe -->
     <!-- an access to a pseudo register using a nonnatural mode, a @code{subreg} -->
     <!-- expression is used. -->
     <p>一个硬件寄存器可以在整个函数中按照多种机器模式来访问，但是每个伪寄存器都被给定一个自然的机器模式并且只能按照那个机器模式来访问。当需要描述一个使用非自然机器模式来访问伪寄存器的时候，则使用一个<code>subreg</code>表达式。

     <!-- A @code{reg} expression with a machine mode that specifies more than -->
     <!-- one word of data may actually stand for several consecutive registers. -->
     <!-- If in addition the register number specifies a hardware register, then -->
     <!-- it actually represents several consecutive hardware registers starting -->
     <!-- with the specified one. -->
     <p>一个<code>reg</code>表达式具有的机器模式，如果指定了多于一个字的数据，则实际上代表了多个连续的寄存器。如果寄存器编号还指定了一个硬件寄存器，则其实际上表示起始于指定寄存器的多个连续的硬件寄存器。

     <!-- Each pseudo register number used in a function's RTL code is -->
     <!-- represented by a unique @code{reg} expression. -->
     <p>每个在函数的RTL代码中使用的伪寄存器编号，使用一个唯一的<code>reg</code>表达式来表示。

     <p><a name="index-FIRST_005fVIRTUAL_005fREGISTER-2000"></a><a name="index-LAST_005fVIRTUAL_005fREGISTER-2001"></a><!-- Some pseudo register numbers, those within the range of -->
<!-- @code{FIRST_VIRTUAL_REGISTER} to @code{LAST_VIRTUAL_REGISTER} only -->
<!-- appear during the RTL generation phase and are eliminated before the -->
<!-- optimization phases.  These represent locations in the stack frame that -->
<!-- cannot be determined until RTL generation for the function has been -->
<!-- completed.  The following virtual register numbers are defined: -->
一些伪寄存器编号，处于<code>FIRST_VIRTUAL_REGISTER</code>到<code>LAST_VIRTUAL_REGISTER</code>之间，只在RTL生成阶段出现并且在优化阶段之前被消除。这些表示在栈帧中的位置，并且直到函数的RTL生成完成后才能确定。下列虚寄存器编号被定义：

          
<a name="index-VIRTUAL_005fINCOMING_005fARGS_005fREGNUM-2002"></a>
<dl><dt><code>VIRTUAL_INCOMING_ARGS_REGNUM</code><dd><!-- This points to the first word of the incoming arguments passed on the -->
<!-- stack.  Normally these arguments are placed there by the caller, but the -->
<!-- callee may have pushed some arguments that were previously passed in -->
<!-- registers. -->
这指向栈上传递的参数的第一个字。通常这些参数由调用者存放，但是被调用者可能已经将之前在寄存器中传递的参数压入栈中。

          <p><a name="index-g_t_0040code_007bFIRST_005fPARM_005fOFFSET_007d-and-virtual-registers-2003"></a><a name="index-g_t_0040code_007bARG_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2004"></a><!-- When RTL generation is complete, this virtual register is replaced -->
<!-- by the sum of the register given by @code{ARG_POINTER_REGNUM} and the -->
<!-- value of @code{FIRST_PARM_OFFSET}. -->
当RTL生成完成时，该虚寄存器由<code>ARG_POINTER_REGNUM</code>给定的寄存器和<code>FIRST_PARM_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fSTACK_005fVARS_005fREGNUM-2005"></a><a name="index-g_t_0040code_007bFRAME_005fGROWS_005fDOWNWARD_007d-and-virtual-registers-2006"></a><br><dt><code>VIRTUAL_STACK_VARS_REGNUM</code><dd><!-- If @code{FRAME_GROWS_DOWNWARD} is defined to a nonzero value, this points -->
<!-- to immediately above the first variable on the stack.  Otherwise, it points -->
<!-- to the first variable on the stack. -->
如果<code>FRAME_GROWS_DOWNWARD</code>被定义为非0的值，则该宏指向栈上第一个变量的上一个位置。否则，其指向栈上的第一个变量。

          <p><a name="index-g_t_0040code_007bSTARTING_005fFRAME_005fOFFSET_007d-and-virtual-registers-2007"></a><a name="index-g_t_0040code_007bFRAME_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2008"></a><code>VIRTUAL_STACK_VARS_REGNUM</code> is replaced with the sum of the
<!-- register given by @code{FRAME_POINTER_REGNUM} and the value -->
<!-- @code{STARTING_FRAME_OFFSET}. -->
<code>VIRTUAL_STACK_VARS_REGNUM</code>由<code>FRAME_POINTER_REGNUM</code>给定的寄存器和<code>STARTING_FRAME_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fSTACK_005fDYNAMIC_005fREGNUM-2009"></a><br><dt><code>VIRTUAL_STACK_DYNAMIC_REGNUM</code><dd><!-- This points to the location of dynamically allocated memory on the stack -->
<!-- immediately after the stack pointer has been adjusted by the amount of -->
<!-- memory desired. -->
该宏指向栈指针根据内存需要已经被调整后的栈上动态分配内存的位置。

          <p><a name="index-g_t_0040code_007bSTACK_005fDYNAMIC_005fOFFSET_007d-and-virtual-registers-2010"></a><a name="index-g_t_0040code_007bSTACK_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2011"></a><!-- This virtual register is replaced by the sum of the register given by -->
<!-- @code{STACK_POINTER_REGNUM} and the value @code{STACK_DYNAMIC_OFFSET}. -->
该虚寄存器由<code>STACK_POINTER_REGNUM</code>给定的寄存器和<code>STACK_DYNAMIC_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fOUTGOING_005fARGS_005fREGNUM-2012"></a><br><dt><code>VIRTUAL_OUTGOING_ARGS_REGNUM</code><dd><!-- This points to the location in the stack at which outgoing arguments -->
<!-- should be written when the stack is pre-pushed (arguments pushed using -->
<!-- push insns should always use @code{STACK_POINTER_REGNUM}). -->
其指向栈中，当预先压栈时（使用push insn压栈的参数应该总是使用<code>STACK_POINTER_REGNUM</code>），书写输出参数的位置。

          <p><a name="index-g_t_0040code_007bSTACK_005fPOINTER_005fOFFSET_007d-and-virtual-registers-2013"></a><!-- This virtual register is replaced by the sum of the register given by -->
<!-- @code{STACK_POINTER_REGNUM} and the value @code{STACK_POINTER_OFFSET}. -->
该虚拟寄存器，被替换成由<code>STACK_POINTER_REGNUM</code>给定的寄存器与值<code>STACK_POINTER_OFFSET</code>的和。

     </dl>

     <p><a name="index-subreg-2014"></a><br><dt><code>(subreg:</code><var>m1</var> <var>reg:m2</var> <var>bytenum</var><code>)</code><dd><!-- @code{subreg} expressions are used to refer to a register in a machine -->
<!-- mode other than its natural one, or to refer to one register of -->
<!-- a multi-part @code{reg} that actually refers to several registers. -->
<code>subreg</code>表达式用于按照自然的机器模式之外的，其它机器模式来引用一个寄存器，或者引用有多个寄存器组成的<code>reg</code>的其中一个寄存器。

     <!-- Each pseudo register has a natural mode.  If it is necessary to -->
     <!-- operate on it in a different mode, the register must be -->
     <!-- enclosed in a @code{subreg}. -->
     <p>每个伪寄存器都具有一个自然的机器模式。如果需要按照不同的机器模式来对其操作，则寄存器必须用<code>subreg</code>进行包含。

     <!-- There are currently three supported types for the first operand of a -->
     <!-- @code{subreg}: -->
     <p>目前对于<code>subreg</code>的第一个操作数，有三种被支持的类型：

          <ul>
<li>pseudo registers
<!-- This is the most common case.  Most @code{subreg}s have pseudo -->
<!-- @code{reg}s as their first operand. -->
这是最常见的情况。大多<code>subreg</code>将伪寄存器<code>reg</code>作为它们的第一个操作数。

          <li>mem
<!-- @code{subreg}s of @code{mem} were common in earlier versions of GCC and -->
<!-- are still supported.  During the reload pass these are replaced by plain -->
<!-- @code{mem}s.  On machines that do not do instruction scheduling, use of -->
<!-- @code{subreg}s of @code{mem} are still used, but this is no longer -->
<!-- recommended.  Such @code{subreg}s are considered to be -->
<!-- @code{register_operand}s rather than @code{memory_operand}s before and -->
<!-- during reload.  Because of this, the scheduling passes cannot properly -->
<!-- schedule instructions with @code{subreg}s of @code{mem}, so for machines -->
<!-- that do scheduling, @code{subreg}s of @code{mem} should never be used. -->
<!-- To support this, the combine and recog passes have explicit code to -->
<!-- inhibit the creation of @code{subreg}s of @code{mem} when -->
<!-- @code{INSN_SCHEDULING} is defined. -->
<code>mem</code>的<code>subreg</code>，在早期版本的GCC中比较常见，现在仍被支持。在重载过程中，这些被普通的<code>mem</code>替换掉。在不进行指令调度的机器上，仍然使用<code>mem</code>的<code>subreg</code>，但是不推荐这样。在重载过程之前和过程之中，这样的<code>subreg</code>被考虑成<code>register_operand</code>，而不是<code>memory_operand</code>。因此，调度过程无法对具有<code>mem</code>的<code>subreg</code>这样的指令进行合适的调度。所以，对于进行调度的机器，不要使用<code>mem</code>的<code>subreg</code>。为此，当<code>INSN_SCHEDULING</code>被定义的时候，合并过程和recog过程，具有显式的代码来禁止创建<code>mem</code>的<code>subreg</code>。

          <!-- The use of @code{subreg}s of @code{mem} after the reload pass is an area -->
          <!-- that is not well understood and should be avoided.  There is still some -->
          <!-- code in the compiler to support this, but this code has possibly rotted. -->
          <!-- This use of @code{subreg}s is discouraged and will most likely not be -->
          <!-- supported in the future. -->
          <p>在重载过程之后使用<code>mem</code>的<code>subreg</code>，将难以理解，应该避免这样。编译器中还有一些代码支持这些，但是这些代码可能已经过时了。这种<code>subreg</code>的用法不被推荐，将来很可能不被支持。

          <li>hard registers
<!-- It is seldom necessary to wrap hard registers in @code{subreg}s; such -->
<!-- registers would normally reduce to a single @code{reg} rtx.  This use of -->
<!-- @code{subreg}s is discouraged and may not be supported in the future. -->
很少有必要在<code>subreg</code>中包裹硬件寄存器；这样的寄存器通常应该被缩减为一个单独的<code>reg</code> rtx。这种<code>subreg</code>的用法不被推荐，将来可能不被支持。

     </ul>

     <!-- @code{subreg}s of @code{subreg}s are not supported.  Using -->
     <!-- @code{simplify_gen_subreg} is the recommended way to avoid this problem. -->
     <p><code>subreg</code>的<code>subreg</code>不被支持。推荐使用<code>simplify_gen_subreg</code>来避免这种问题。

     <!-- @code{subreg}s come in two distinct flavors, each having its own -->
     <!-- usage and rules: -->
     <p><code>subreg</code>有两种不同的风格，分别具有自己的用法和规则：

          <dl>
<dt>Paradoxical subregs<dd><!-- When @var{m1} is strictly wider than @var{m2}, the @code{subreg} -->
<!-- expression is called @dfn{paradoxical}.  The canonical test for this -->
<!-- class of @code{subreg} is: -->
当<var>m1</var>严格宽于<var>m2</var>的时候，<code>subreg</code>表达式被称作反常的（<dfn>paradoxical</dfn>）。对该类别的<code>subreg</code>的正规测试为：

          <pre class="smallexample">               GET_MODE_SIZE (<var>m1</var>) &gt; GET_MODE_SIZE (<var>m2</var>)
</pre>
          <!-- Paradoxical @code{subreg}s can be used as both lvalues and rvalues. -->
          <!-- When used as an lvalue, the low-order bits of the source value -->
          <!-- are stored in @var{reg} and the high-order bits are discarded. -->
          <!-- When used as an rvalue, the low-order bits of the @code{subreg} are -->
          <!-- taken from @var{reg} while the high-order bits may or may not be -->
          <!-- defined. -->
          <p>反常的<code>subreg</code>可以用于左值和右值。当用于左值时，源值的低位被存储在<var>reg</var>中，高位被丢弃。当用作右值时，<code>subreg</code>的低位来自<var>reg</var>，而高位可以被定义，也可以未被定义。

          <!-- The high-order bits of rvalues are in the following circumstances: -->
          <p>右值的高位有以下几种情况：

               <ul>
<li><code>subreg</code>s of <code>mem</code>
<!-- When @var{m2} is smaller than a word, the macro @code{LOAD_EXTEND_OP}, -->
<!-- can control how the high-order bits are defined. -->
当<var>m2</var>小于一个字的时候，宏<code>LOAD_EXTEND_OP</code>可以控制高位如何被定义。

               <li><code>subreg</code> of <code>reg</code>s
<!-- The upper bits are defined when @code{SUBREG_PROMOTED_VAR_P} is true. -->
<!-- @code{SUBREG_PROMOTED_UNSIGNED_P} describes what the upper bits hold. -->
<!-- Such subregs usually represent local variables, register variables -->
<!-- and parameter pseudo variables that have been promoted to a wider mode. -->
当<code>SUBREG_PROMOTED_VAR_P</code>为真时，高位被定义。<code>SUBREG_PROMOTED_UNSIGNED_P</code>描述了高位的内容。这样的subreg通常表示已经被提升为更宽的机器模式的局部变量，寄存器变量以及参数伪变量。

          </ul>

          <!-- @var{bytenum} is always zero for a paradoxical @code{subreg}, even on -->
          <!-- big-endian targets. -->
          <p>对于反常的<code>subreg</code>，<var>bytenum</var>总是为零，即使在大端的目标机上。

          <!-- For example, the paradoxical @code{subreg}: -->
          <p>例如反常的<code>subreg</code>:

          <pre class="smallexample">               (set (subreg:SI (reg:HI <var>x</var>) 0) <var>y</var>)
</pre>
          <!-- stores the lower 2 bytes of @var{y} in @var{x} and discards the upper -->
          <!-- 2 bytes.  A subsequent: -->
          <p>在<var>x</var>中存储了<var>y</var>的低位2个字节，并丢弃高位2个字节。接着：

          <pre class="smallexample">               (set <var>z</var> (subreg:SI (reg:HI <var>x</var>) 0))
</pre>
          <!-- would set the lower two bytes of @var{z} to @var{y} and set the upper -->
          <!-- two bytes to an unknown value assuming @code{SUBREG_PROMOTED_VAR_P} is -->
          <!-- false. -->
          <p>将会把<var>z</var>的低位2个字节设置成<var>x</var>，并将高位两个字节设置为未知的值，假定<code>SUBREG_PROMOTED_VAR_P</code>为假。

          <br><dt>Normal subregs<dd><!-- When @var{m1} is at least as narrow as @var{m2} the @code{subreg} -->
<!-- expression is called @dfn{normal}. -->
当<var>m1</var>最多跟<var>m2</var>一样宽的时候，<code>subreg</code>表达式被称作正常的（<dfn>normal</dfn>）。

          <!-- Normal @code{subreg}s restrict consideration to certain bits of -->
          <!-- @var{reg}.  There are two cases.  If @var{m1} is smaller than a word, -->
          <!-- the @code{subreg} refers to the least-significant part (or -->
          <!-- @dfn{lowpart}) of one word of @var{reg}.  If @var{m1} is word-sized or -->
          <!-- greater, the @code{subreg} refers to one or more complete words. -->
          <p>正常的<code>subreg</code>被限定为<var>reg</var>的特定位。有两种情况。如果<var>m1</var>比一个字小，则<code>subreg</code>指的是一个<var>reg</var>字的最小有效部分。如果<var>m1</var>为字大小，或者更大，则<code>subreg</code>指的是一个或者更多个完整的字。

          <!-- When used as an lvalue, @code{subreg} is a word-based accessor. -->
          <!-- Storing to a @code{subreg} modifies all the words of @var{reg} that -->
          <!-- overlap the @code{subreg}, but it leaves the other words of @var{reg} -->
          <!-- alone. -->
          <p>当用作左值时，<code>subreg</code>为一个基于字的访问。对<code>subreg</code>进行存储，会修改<var>reg</var>中所有与<code>subreg</code>重叠的字，并将<var>reg</var>中的其它字保持不变。

          <!-- When storing to a normal @code{subreg} that is smaller than a word, -->
          <!-- the other bits of the referenced word are usually left in an undefined -->
          <!-- state.  This laxity makes it easier to generate efficient code for -->
          <!-- such instructions.  To represent an instruction that preserves all the -->
          <!-- bits outside of those in the @code{subreg}, use @code{strict_low_part} -->
          <!-- or @code{zero_extract} around the @code{subreg}. -->
          <p>当对小于一个字的正常<code>subreg</code>进行存储的时候，被引用的字的其它位通常处于未定义的状态。这种松弛的方式易于对这样的指令产生高效的代码。要表示保持<code>subreg</code>之外的所有位的指令，在<code>subreg</code>周围使用<code>strict_low_part</code>或者<code>zero_extract</code>。

          <!-- @var{bytenum} must identify the offset of the first byte of the -->
          <!-- @code{subreg} from the start of @var{reg}, assuming that @var{reg} is -->
          <!-- laid out in memory order.  The memory order of bytes is defined by -->
          <!-- two target macros, @code{WORDS_BIG_ENDIAN} and @code{BYTES_BIG_ENDIAN}: -->
          <p><var>bytenum</var>必须标识从<var>reg</var>的起始，<code>subreg</code>的第一个字节的偏移量，假设<var>reg</var>按照内存的顺序布局。字节的内存顺序通过两个目标宏定义，<code>WORDS_BIG_ENDIAN</code>和<code>BYTES_BIG_ENDIAN</code>：

               <ul>
<li><a name="index-g_t_0040code_007bWORDS_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2015"></a><!-- @code{WORDS_BIG_ENDIAN}, if set to 1, says that byte number zero is -->
<!-- part of the most significant word; otherwise, it is part of the least -->
<!-- significant word. -->
<code>WORDS_BIG_ENDIAN</code>，如果设为1，则说明第零个字节为最大有效字的部分；否则，为最小有效字的部分。

               <li><a name="index-g_t_0040code_007bBYTES_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2016"></a><a name="index-g_t_0040code_007bBYTES_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2017"></a><!-- @code{BYTES_BIG_ENDIAN}, if set to 1, says that byte number zero is -->
<!-- the most significant byte within a word; otherwise, it is the least -->
<!-- significant byte within a word. -->
<code>BYTES_BIG_ENDIAN</code>，如果设为1，则说明第零个字节为字中的最高有效字节；否则，为字中的最低有效字节。

          </ul>

          <p><a name="index-g_t_0040code_007bFLOAT_005fWORDS_005fBIG_005fENDIAN_007d_002c-_0028lack-of_0029-effect-on-_0040code_007bsubreg_007d-2018"></a><!-- On a few targets, @code{FLOAT_WORDS_BIG_ENDIAN} disagrees with -->
<!-- @code{WORDS_BIG_ENDIAN}.  However, most parts of the compiler treat -->
<!-- floating point values as if they had the same endianness as integer -->
<!-- values.  This works because they handle them solely as a collection of -->
<!-- integer values, with no particular numerical value.  Only real.c and -->
<!-- the runtime libraries care about @code{FLOAT_WORDS_BIG_ENDIAN}. -->
在一些目标机上，<code>FLOAT_WORDS_BIG_ENDIAN</code>与<code>WORDS_BIG_ENDIAN</code>不一致。然而，编译器的大部分地方会将浮点值看作它们与整数值具有相同的大小端。这是因为只将它们作为整数值的集合来处理，没有特定的数值。只有real.c和运行时库关心<code>FLOAT_WORDS_BIG_ENDIAN</code>。

          <!-- Thus, -->
          <p>因此，

          <pre class="smallexample">               (subreg:HI (reg:SI <var>x</var>) 2)
</pre>
          <!-- on a @code{BYTES_BIG_ENDIAN}, @samp{UNITS_PER_WORD == 4} target is the same as -->
          <p>在一个<code>BYTES_BIG_ENDIAN</code>，&lsquo;<samp><span class="samp">UNITS_PER_WORD == 4</span></samp>&rsquo;的目标机上，等同于

          <pre class="smallexample">               (subreg:HI (reg:SI <var>x</var>) 0)
</pre>
          <!-- on a little-endian, @samp{UNITS_PER_WORD == 4} target.  Both -->
          <!-- @code{subreg}s access the lower two bytes of register @var{x}. -->
          <p>在一个小端，&lsquo;<samp><span class="samp">UNITS_PER_WORD == 4</span></samp>&rsquo;的目标机上。两个<code>subreg</code>都是访问寄存器<var>x</var>的低两个字节。

     </dl>

     <!-- A @code{MODE_PARTIAL_INT} mode behaves as if it were as wide as the -->
     <!-- corresponding @code{MODE_INT} mode, except that it has an unknown -->
     <!-- number of undefined bits.  For example: -->
     <p><code>MODE_PARTIAL_INT</code>机器模式的行为就好像其与相对应的<code>MODE_INT</code>机器模式一样宽，只不过其具有未知数目的未定义的位。例如：

     <pre class="smallexample">          (subreg:PSI (reg:SI 0) 0)
</pre>
     <!-- accesses the whole of @samp{(reg:SI 0)}, but the exact relationship -->
     <!-- between the @code{PSImode} value and the @code{SImode} value is not -->
     <!-- defined.  If we assume @samp{UNITS_PER_WORD <= 4}, then the following -->
     <!-- two @code{subreg}s: -->
     <p>访问整个&lsquo;<samp><span class="samp">(reg:SI 0)</span></samp>&rsquo;，但是<code>PSImode</code>值和<code>SImode</code>值的确切关系没有被定义。如果我们假设&lsquo;<samp><span class="samp">UNITS_PER_WORD &lt;= 4</span></samp>&rsquo;，则下面两个<code>subreg</code>：

     <pre class="smallexample">          (subreg:PSI (reg:DI 0) 0)
          (subreg:PSI (reg:DI 0) 4)
</pre>
     <!-- represent independent 4-byte accesses to the two halves of -->
     <!-- @samp{(reg:DI 0)}.  Both @code{subreg}s have an unknown number -->
     <!-- of undefined bits. -->
     <p>表示对&lsquo;<samp><span class="samp">(reg:DI 0)</span></samp>&rsquo;的两个部分进行无关的四个字节访问。每个<code>subreg</code>都具有未知数目的未定义位。

     <!-- If @samp{UNITS_PER_WORD <= 2} then these two @code{subreg}s: -->
     <p>如果&lsquo;<samp><span class="samp">UNITS_PER_WORD &lt;= 2</span></samp>&rsquo;，则这两个<code>subreg</code>

     <pre class="smallexample">          (subreg:HI (reg:PSI 0) 0)
          (subreg:HI (reg:PSI 0) 2)
</pre>
     <!-- represent independent 2-byte accesses that together span the whole -->
     <!-- of @samp{(reg:PSI 0)}.  Storing to the first @code{subreg} does not -->
     <!-- affect the value of the second, and vice versa.  @samp{(reg:PSI 0)} -->
     <!-- has an unknown number of undefined bits, so the assignment: -->
     <p>表示无关的两个字节访问，一起贯穿整个&lsquo;<samp><span class="samp">(reg:PSI 0)</span></samp>&rsquo;。对第一个<code>subreg</code>进行存储不影响第二个的值，反之亦然。&lsquo;<samp><span class="samp">(reg:PSI 0)</span></samp>&rsquo;具有未知数目的未定义位，所以赋值：

     <pre class="smallexample">          (set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
</pre>
     <!-- does not guarantee that @samp{(subreg:HI (reg:PSI 0) 0)} has the -->
     <!-- value @samp{(reg:HI 4)}. -->
     <p>不保证&lsquo;<samp><span class="samp">(subreg:HI (reg:PSI 0) 0)</span></samp>&rsquo;具有值&lsquo;<samp><span class="samp">(reg:HI 4)</span></samp>&rsquo;。

     <p><a name="index-g_t_0040code_007bCANNOT_005fCHANGE_005fMODE_005fCLASS_007d-and-subreg-semantics-2019"></a><!-- The rules above apply to both pseudo @var{reg}s and hard @var{reg}s. -->
<!-- If the semantics are not correct for particular combinations of -->
<!-- @var{m1}, @var{m2} and hard @var{reg}, the target-specific code -->
<!-- must ensure that those combinations are never used.  For example: -->
上面的规则应用于伪寄存器<var>reg</var>和硬件寄存器<var>reg</var>。如果对于<var>m1</var>, <var>m2</var>和硬件寄存器<var>reg</var>的特定组合，其语义不正确，则目标机特定的代码必须确保这些组合不会被用到。例如：

     <pre class="smallexample">          CANNOT_CHANGE_MODE_CLASS (<var>m2</var>, <var>m1</var>, <var>class</var>)
</pre>
     <!-- must be true for every class @var{class} that includes @var{reg}. -->
     <p>必须为真，对于每个包含<var>reg</var>的类别<var>class</var>。

     <p><a name="index-SUBREG_005fREG-2020"></a><a name="index-SUBREG_005fBYTE-2021"></a><!-- The first operand of a @code{subreg} expression is customarily accessed -->
<!-- with the @code{SUBREG_REG} macro and the second operand is customarily -->
<!-- accessed with the @code{SUBREG_BYTE} macro. -->
<code>subreg</code>表达式的第一个操作数通常使用<code>SUBREG_REG</code>宏来访问，第二个操作数通常使用<code>SUBREG_BYTE</code>宏来访问。

     <!-- It has been several years since a platform in which -->
     <!-- @code{BYTES_BIG_ENDIAN} not equal to @code{WORDS_BIG_ENDIAN} has -->
     <!-- been tested.  Anyone wishing to support such a platform in the future -->
     <!-- may be confronted with code rot. -->
     <p><code>BYTES_BIG_ENDIAN</code>不等于<code>WORDS_BIG_ENDIAN</code>的平台是在很多年前被测试的。对于希望在将来支持这样一个平台的人们，可能会面对一些过时的代码。

     <p><a name="index-scratch-2022"></a><a name="index-scratch-operands-2023"></a><br><dt><code>(scratch:</code><var>m</var><code>)</code><dd><!-- This represents a scratch register that will be required for the -->
<!-- execution of a single instruction and not used subsequently.  It is -->
<!-- converted into a @code{reg} by either the local register allocator or -->
<!-- the reload pass. -->
这表示一个scratch寄存器，其在单个指令的执行中用到，并随后不再被使用。其被局部寄存器分配或者重载过程，转换成一个<code>reg</code>。

     <!-- @code{scratch} is usually present inside a @code{clobber} operation -->
     <!-- (@pxref{Side Effects}). -->
     <p><code>scratch</code>通常位于<code>clobber</code>操作中。(参见<a href="Side-Effects.html#Side-Effects">Side Effects</a>)。

     <p><a name="index-cc0-2024"></a><a name="index-condition-code-register-2025"></a><br><dt><code>(cc0)</code><dd><!-- This refers to the machine's condition code register.  It has no -->
<!-- operands and may not have a machine mode.  There are two ways to use it: -->
为机器的条件代码寄存器。其没有参数，并可以没有机器模式。有两种使用它的方式：

          <ul>
<li><!-- To stand for a complete set of condition code flags.  This is best on -->
<!-- most machines, where each comparison sets the entire series of flags. -->
表示一个完整的条件代码标记的集合。这在大多机器上是最好的方式，每个比较都会设置整个标记系列。

          <!-- With this technique, @code{(cc0)} may be validly used in only two -->
          <!-- contexts: as the destination of an assignment (in test and compare -->
          <!-- instructions) and in comparison operators comparing against zero -->
          <!-- (@code{const_int} with value zero; that is to say, @code{const0_rtx}). -->
          <p>使用这种技术，<code>(cc0)</code>只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中）和在跟零进行比较的比较运算符中（值为零的<code>const_int</code>；也就是说，<code>const0_rtx</code>）。

          <li><!-- To stand for a single flag that is the result of a single condition. -->
<!-- This is useful on machines that have only a single flag bit, and in -->
<!-- which comparison instructions must specify the condition to test. -->
表示单个标记，为单个条件的结果。这用于只有一个标记位，比较指令必须指定要测试的条件的机器上。

          <!-- With this technique, @code{(cc0)} may be validly used in only two -->
          <!-- contexts: as the destination of an assignment (in test and compare -->
          <!-- instructions) where the source is a comparison operator, and as the -->
          <!-- first operand of @code{if_then_else} (in a conditional branch). -->
          <p>使用这种技术，<code>(cc0)</code>只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中），其中源操作数为一个比较运算符，以及<code>if_then_else</code>的第一个参数（在条件分支中）。

     </ul>

     <p><a name="index-cc0_005frtx-2026"></a><!-- There is only one expression object of code @code{cc0}; it is the -->
<!-- value of the variable @code{cc0_rtx}.  Any attempt to create an -->
<!-- expression of code @code{cc0} will return @code{cc0_rtx}. -->
只有一个代码为<code>cc0</code>的表达式对象；其为变量<code>cc0_rtx</code>的值。任何尝试创建一个代码为<code>cc0</code>的表达式，将返回<code>cc0_rtx</code>。

     <!-- Instructions can set the condition code implicitly.  On many machines, -->
     <!-- nearly all instructions set the condition code based on the value that -->
     <!-- they compute or store.  It is not necessary to record these actions -->
     <!-- explicitly in the RTL because the machine description includes a -->
     <!-- prescription for recognizing the instructions that do so (by means of -->
     <!-- the macro @code{NOTICE_UPDATE_CC}).  @xref{Condition Code}.  Only -->
     <!-- instructions whose sole purpose is to set the condition code, and -->
     <!-- instructions that use the condition code, need mention @code{(cc0)}. -->
     <p>指令可以隐式的设置条件代码。在许多机器上，几乎所有的指令根据它们计算或者存储的值来设置条件码。没有必要在RTL中显式的记录这些行为，因为机器描述包含一个对策，用于识别这样做的指令（通过宏<code>NOTICE_UPDATE_CC</code>）。参见<a href="Condition-Code.html#Condition-Code">Condition Code</a>. 只有目的纯粹是设置条件码的指令，以及使用条件码的指令，才需要提及<code>(cc0)</code>。

     <!-- On some machines, the condition code register is given a register number -->
     <!-- and a @code{reg} is used instead of @code{(cc0)}.  This is usually the -->
     <!-- preferable approach if only a small subset of instructions modify the -->
     <!-- condition code.  Other machines store condition codes in general -->
     <!-- registers; in such cases a pseudo register should be used. -->
     <p>在一些机器上，条件码寄存器被给定一个寄存器编号，并且一个<code>reg</code>用于替代<code>(cc0)</code>。这通常为更好的方式，如果只有一个小的指令子集修改条件码。其它机器将条件码存储在通用寄存器中；这种情况下应该使用伪寄存器。

     <!-- Some machines, such as the SPARC and RS/6000, have two sets of -->
     <!-- arithmetic instructions, one that sets and one that does not set the -->
     <!-- condition code.  This is best handled by normally generating the -->
     <!-- instruction that does not set the condition code, and making a pattern -->
     <!-- that both performs the arithmetic and sets the condition code register -->
     <!-- (which would not be @code{(cc0)} in this case).  For examples, search -->
     <!-- for @samp{addcc} and @samp{andcc} in @file{sparc.md}. -->
     <p>一些机器，例如SPARC和RS/6000，具有两个算术指令集合，一个设置条件码，另一个不设置。可以通常情况下生成不设置条件码的指令，并创建一个同时执行算术运算并设置条件码寄存器（这种情况下将不会是<code>(cc0)</code>）的指令模式。例如，搜一下<samp><span class="file">sparc.md</span></samp>中的&lsquo;<samp><span class="samp">addcc</span></samp>&rsquo;和&lsquo;<samp><span class="samp">andcc</span></samp>&rsquo;。

     <p><a name="index-pc-2027"></a><br><dt><code>(pc)</code><dd><a name="index-program-counter-2028"></a><!-- This represents the machine's program counter.  It has no operands and -->
<!-- may not have a machine mode.  @code{(pc)} may be validly used only in -->
<!-- certain specific contexts in jump instructions. -->
表示机器的程序计数器。其没有操作数并可能没有机器模式。<code>(pc)</code>只在跳转指令的特定上下文中使用。

     <p><a name="index-pc_005frtx-2029"></a><!-- There is only one expression object of code @code{pc}; it is the value -->
<!-- of the variable @code{pc_rtx}.  Any attempt to create an expression of -->
<!-- code @code{pc} will return @code{pc_rtx}. -->
只有一个代码为<code>pc</code>的表达式对象；其为变量<code>pc_rtx</code>的值。任何尝试创建一个代码为<code>pc</code>的表达式，将返回<code>pc_rtx</code>。

     <!-- All instructions that do not jump alter the program counter implicitly -->
     <!-- by incrementing it, but there is no need to mention this in the RTL@. -->
     <p>所有不进行跳转的指令会隐式的通过递增的方式改变程序计数器，但是不需要在RTL中提起这些。

     <p><a name="index-mem-2030"></a><br><dt><code>(mem:</code><var>m</var> <var>addr</var> <var>alias</var><code>)</code><dd><!-- This RTX represents a reference to main memory at an address -->
<!-- represented by the expression @var{addr}.  @var{m} specifies how large -->
<!-- a unit of memory is accessed.  @var{alias} specifies an alias set for the -->
<!-- reference.  In general two items are in different alias sets if they cannot -->
<!-- reference the same memory address. -->
该RTX表示对表达式<var>addr</var>所表示的地址的主内存进行引用。<var>m</var>描述了被访问的内存的单元大小。<var>alias</var>描述了该引用的别名集合。总得来说，两个项如果不引用相同的内存地址，则在不同的别名集合里。

     <!-- The construct @code{(mem:BLK (scratch))} is considered to alias all -->
     <!-- other memories.  Thus it may be used as a memory barrier in epilogue -->
     <!-- stack deallocation patterns. -->
     <p>结构<code>(mem:BLK (scratch))</code>被认为是所有其它内存的别名。因此其可以在函数尾声的栈销毁中用作内存栅栏。

     <p><a name="index-concat-2031"></a><br><dt><code>(concat</code><var>m</var> <var>rtx</var> <var>rtx</var><code>)</code><dd><!-- This RTX represents the concatenation of two other RTXs.  This is used -->
<!-- for complex values.  It should only appear in the RTL attached to -->
<!-- declarations and during RTL generation.  It should not appear in the -->
<!-- ordinary insn chain. -->
该RTX表示对两个其它RTX的连结。这用于复数值。其应该只出现在附加在声明中的RTL中，以及RTL生成中。不应该出现在普通的insn链上。

     <p><a name="index-concatn-2032"></a><br><dt><code>(concatn</code><var>m</var><code> [</code><var>rtx</var><code> ...])</code><dd><!-- This RTX represents the concatenation of all the @var{rtx} to make a -->
<!-- single value.  Like @code{concat}, this should only appear in -->
<!-- declarations, and not in the insn chain. -->
该RTX表示将所有的<var>rtx</var>进行连结，生成一个单个的值。类似<code>concat</code>，其应该只出现在声明中，不应该出现在insn链上。

 </dl>

<!-- @node Arithmetic -->
<!-- @section RTL Expressions for Arithmetic -->
 </body></html>

