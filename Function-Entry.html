<html lang="zh">
<head>
<title>Function Entry - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="prev" href="Caller-Saves.html#Caller-Saves" title="Caller Saves">
<link rel="next" href="Profiling.html#Profiling" title="Profiling">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Function-Entry"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Profiling.html#Profiling">Profiling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Caller-Saves.html#Caller-Saves">Caller Saves</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>
<hr>
</div>

<h4 class="subsection">17.10.11 函数入口和出口</h4>

<p><a name="index-function-entry-and-exit-4194"></a><a name="index-prologue-4195"></a><a name="index-epilogue-4196"></a>
<!-- This section describes the macros that output function entry -->
<!-- (@dfn{prologue}) and exit (@dfn{epilogue}) code. -->
这一章描述了输出函数入口（<dfn>prologue</dfn>）和出口（<dfn>epilogue</dfn>）代码的宏。

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_PROLOGUE</b> (<var>FILE *file, HOST_WIDE_INT size</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fPROLOGUE-4197"></a></var><br>
<blockquote><!-- If defined, a function that outputs the assembler code for entry to a -->
     <!-- function.  The prologue is responsible for setting up the stack frame, -->
     <!-- initializing the frame pointer register, saving registers that must be -->
     <!-- saved, and allocating @var{size} additional bytes of storage for the -->
     <!-- local variables.  @var{size} is an integer.  @var{file} is a stdio -->
     <!-- stream to which the assembler code should be output. -->
      <p>如果被定义，则为一个函数，其为函数的入口输出汇编代码。序言负责设置栈帧，
初始化帧指针寄存器，保存必须被保存的机器，并分配保存局部变量所需要的额外字节数
<var>size</var>。<var>size</var>为一个整数。
<var>file</var>为汇编代码应该被输出到的一个stdio流。

     <!-- The label for the beginning of the function need not be output by this -->
     <!-- macro.  That has already been done when the macro is run. -->
      <p>函数起始处的标号不需要被该宏输出。其已经在该宏运行时被输出了。

      <p><a name="index-regs_005fever_005flive-4198"></a><!-- To determine which registers to save, the macro can refer to the array -->
<!-- @code{regs_ever_live}: element @var{r} is nonzero if hard register -->
<!-- @var{r} is used anywhere within the function.  This implies the function -->
<!-- prologue should save register @var{r}, provided it is not one of the -->
<!-- call-used registers.  (@code{TARGET_ASM_FUNCTION_EPILOGUE} must likewise use -->
<!-- @code{regs_ever_live}.) -->
要确定哪些寄存器要保存，该宏可以引用数组<code>regs_ever_live</code>：
元素<var>r</var>为非零，如果硬件寄存器<var>r</var>在函数某处被使用。
这意味着倘若其不是调用使用的（call-used）寄存器，
则函数序言应该保存寄存器<var>r</var>。
(同样<code>TARGET_ASM_FUNCTION_EPILOGUE</code>也必须使用<code>regs_ever_live</code>。)

     <!-- On machines that have ``register windows'', the function entry code does -->
     <!-- not save on the stack the registers that are in the windows, even if -->
     <!-- they are supposed to be preserved by function calls; instead it takes -->
     <!-- appropriate steps to ``push'' the register stack, if any non-call-used -->
     <!-- registers are used in the function. -->
      <p>在具有“寄存器窗口”的机器上，函数入口代码不在栈中保存位于窗口中的寄存器，
即使它们认为被函数调用保留；替代的，如果在函数中使用了任何非调用使用的寄存器，
其使用适当的步骤来“压入”寄存器栈中。

      <p><a name="index-frame_005fpointer_005fneeded-4199"></a><!-- On machines where functions may or may not have frame-pointers, the -->
<!-- function entry code must vary accordingly; it must set up the frame -->
<!-- pointer if one is wanted, and not otherwise.  To determine whether a -->
<!-- frame pointer is in wanted, the macro can refer to the variable -->
<!-- @code{frame_pointer_needed}.  The variable's value will be 1 at run -->
<!-- time in a function that needs a frame pointer.  @xref{Elimination}. -->
在一些机器上，函数可以有帧指针，也可以没有，则函数入口代码必须相应的有所不同；
如果需要则其必须建立帧指针，否则不建立。要确定是否想要帧指针，
宏可以引用变量<code>frame_pointer_needed</code>。在运行时，如果函数需要帧指针，
则变量的值将被设为1。参见<a href="Elimination.html#Elimination">Elimination</a>。

     <!-- The function entry code is responsible for allocating any stack space -->
     <!-- required for the function.  This stack space consists of the regions -->
     <!-- listed below.  In most cases, these regions are allocated in the -->
     <!-- order listed, with the last listed region closest to the top of the -->
     <!-- stack (the lowest address if @code{STACK_GROWS_DOWNWARD} is defined, and -->
     <!-- the highest address if it is not defined).  You can use a different order -->
     <!-- for a machine if doing so is more convenient or required for -->
     <!-- compatibility reasons.  Except in cases where required by standard -->
     <!-- or by a debugger, there is no reason why the stack layout used by GCC -->
     <!-- need agree with that used by other compilers for a machine. -->
      <p>函数入口代码负责分配函数需要的任何栈空间。该栈空间包括下面列出的域。
大多数情况下，这些域按照列出的顺序被分配，最后列出的域最靠近栈顶
（如果<code>STACK_GROWS_DOWNWARD</code>被定义，则为最低地址，如果没有定义，
则为最高地址）。你可以为一个机器使用不同的顺序，
如果这样做更加方便或者出于兼容的原因。除了由于标准或者调试器的要求之外，
没有理由GCC使用的栈布局需要适合机器上的其它编译器所使用的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_END_PROLOGUE</b> (<var>FILE *file</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fEND_005fPROLOGUE-4200"></a></var><br>
<blockquote><!-- If defined, a function that outputs assembler code at the end of a -->
     <!-- prologue.  This should be used when the function prologue is being -->
     <!-- emitted as RTL, and you have some extra assembler that needs to be -->
     <!-- emitted.  @xref{prologue instruction pattern}. -->
      <p>如果被定义，则为一个函数，在序言的结尾处输出汇编代码。
这应该被用于当函数序言作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“序言指令模式”
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_BEGIN_EPILOGUE</b> (<var>FILE *file</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fBEGIN_005fEPILOGUE-4201"></a></var><br>
<blockquote><!-- If defined, a function that outputs assembler code at the start of an -->
     <!-- epilogue.  This should be used when the function epilogue is being -->
     <!-- emitted as RTL, and you have some extra assembler that needs to be -->
     <!-- emitted.  @xref{epilogue instruction pattern}. -->
      <p>如果被定义，则为一个函数，在尾声的起始处输出汇编代码。
这应该被用于当函数尾声作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“尾声指令模式”
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_EPILOGUE</b> (<var>FILE *file, HOST_WIDE_INT size</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fEPILOGUE-4202"></a></var><br>
<blockquote><!-- If defined, a function that outputs the assembler code for exit from a -->
     <!-- function.  The epilogue is responsible for restoring the saved -->
     <!-- registers and stack pointer to their values when the function was -->
     <!-- called, and returning control to the caller.  This macro takes the -->
     <!-- same arguments as the macro @code{TARGET_ASM_FUNCTION_PROLOGUE}, and the -->
     <!-- registers to restore are determined from @code{regs_ever_live} and -->
     <!-- @code{CALL_USED_REGISTERS} in the same way. -->
      <p>如果被定义，则为一个函数，其为函数的退出输出汇编代码。
尾声负责恢复保存的寄存器和栈指针为函数被调用时的值，并将控制返回给调用者。
该宏接受跟<code>TARGET_ASM_FUNCTION_PROLOGUE</code>相同的参数，
并且要恢复的寄存器按照相同的方式通过<code>regs_ever_live</code>和
<code>CALL_USED_REGISTERS</code>来确定。

     <!-- On some machines, there is a single instruction that does all the work -->
     <!-- of returning from the function.  On these machines, give that -->
     <!-- instruction the name @samp{return} and do not define the macro -->
     <!-- @code{TARGET_ASM_FUNCTION_EPILOGUE} at all. -->
      <p>在一些机器上，有一个单独的指令，可以做从函数中返回的所有工作。
在这些机器上，给出那个名为&lsquo;<samp><span class="samp">return</span></samp>&rsquo;的指令，
并且不要定义宏<code>TARGET_ASM_FUNCTION_EPILOGUE</code>。

     <!-- Do not define a pattern named @samp{return} if you want the -->
     <!-- @code{TARGET_ASM_FUNCTION_EPILOGUE} to be used.  If you want the target -->
     <!-- switches to control whether return instructions or epilogues are used, -->
     <!-- define a @samp{return} pattern with a validity condition that tests the -->
     <!-- target switches appropriately.  If the @samp{return} pattern's validity -->
     <!-- condition is false, epilogues will be used. -->
      <p>如果你想使用<code>TARGET_ASM_FUNCTION_EPILOGUE</code>，
则不要定义名为&lsquo;<samp><span class="samp">return</span></samp>&rsquo;的指令模式。
如果你想target切换使用return指令或者尾声，则定义一个&lsquo;<samp><span class="samp">return</span></samp>&rsquo;指令模式，
带有一个有效性条件用来测试target的适当的切换。
如果&lsquo;<samp><span class="samp">return</span></samp>&rsquo;指令模式的有效性条件为假，则使用尾声。

     <!-- On machines where functions may or may not have frame-pointers, the -->
     <!-- function exit code must vary accordingly.  Sometimes the code for these -->
     <!-- two cases is completely different.  To determine whether a frame pointer -->
     <!-- is wanted, the macro can refer to the variable -->
     <!-- @code{frame_pointer_needed}.  The variable's value will be 1 when compiling -->
     <!-- a function that needs a frame pointer. -->
      <p>在一些机器上，函数可以有帧指针，也可以没有，则函数的退出代码必须相应有所不同。
有时这两种情况的代码会完全不同。要确定是否需要帧指针，
该宏可以引用变量<code>frame_pointer_needed</code>。当编译一个需要帧指针的函数时，
变量的值将为1。

     <!-- Normally, @code{TARGET_ASM_FUNCTION_PROLOGUE} and -->
     <!-- @code{TARGET_ASM_FUNCTION_EPILOGUE} must treat leaf functions specially. -->
     <!-- The C variable @code{current_function_is_leaf} is nonzero for such a -->
     <!-- function.  @xref{Leaf Functions}. -->
      <p>通常，<code>TARGET_ASM_FUNCTION_PROLOGUE</code>和<code>TARGET_ASM_FUNCTION_EPILOGUE</code>
必须单独处理叶子函数。对于这样的函数，C变量<code>current_function_is_leaf</code>为
非零。参见<a href="Leaf-Functions.html#Leaf-Functions">Leaf Functions</a>。

     <!-- On some machines, some functions pop their arguments on exit while -->
     <!-- others leave that for the caller to do.  For example, the 68020 when -->
     <!-- given @option{-mrtd} pops arguments in functions that take a fixed -->
     <!-- number of arguments. -->
      <p>在一些机器上，一些函数在退出时弹出它们的参数，而其它的则将它们留给调用者来完成。
例如，68020当给定<samp><span class="option">-mrtd</span></samp>时会弹出具有固定参数个数的函数的参数。

      <p><a name="index-current_005ffunction_005fpops_005fargs-4203"></a><!-- Your definition of the macro @code{RETURN_POPS_ARGS} decides which -->
<!-- functions pop their own arguments.  @code{TARGET_ASM_FUNCTION_EPILOGUE} -->
<!-- needs to know what was decided.  The number of bytes of the current -->
<!-- function's arguments that this function should pop is available in -->
<!-- @code{crtl->args.pops_args}.  @xref{Scalar Return}. -->
你对宏的定义决定了哪些函数弹出它们的自己的参数。
<code>TARGET_ASM_FUNCTION_EPILOGUE</code>需要知道这些。
称作<code>current_function_pops_args</code>的变量为函数应该弹出的参数的字节个数。
参见<a href="Scalar-Return.html#Scalar-Return">Scalar Return</a>。
</p></blockquote></div>

     <ul>
<li><a name="index-current_005ffunction_005fpretend_005fargs_005fsize-4204"></a><!-- A region of @code{current_function_pretend_args_size} bytes of -->
<!-- uninitialized space just underneath the first argument arriving on the -->
<!-- stack.  (This may not be at the very start of the allocated stack region -->
<!-- if the calling sequence has pushed anything else since pushing the stack -->
<!-- arguments.  But usually, on such machines, nothing else has been pushed -->
<!-- yet, because the function prologue itself does all the pushing.)  This -->
<!-- region is used on machines where an argument may be passed partly in -->
<!-- registers and partly in memory, and, in some cases to support the -->
<!-- features in @code{<stdarg.h>}. -->
<code>current_function_pretend_args_size</code>个字节大小的未初始化空间位于栈中第一个
参数的下面。（这可能不是被分配的栈域的最起始处，如果调用序列在压入栈参数时还压入
了其它东西。通常，在这样的机器上，并没有压入其它东西，因为函数序言本身来做所有的
压栈操作）该域用于参数可以部分在寄存器中传递，部分在内存中传递的机器上，
以及支持<code>&lt;stdarg.h&gt;</code>的特性的情况。

     <li><!-- An area of memory used to save certain registers used by the function. -->
<!-- The size of this area, which may also include space for such things as -->
<!-- the return address and pointers to previous stack frames, is -->
<!-- machine-specific and usually depends on which registers have been used -->
<!-- in the function.  Machines with register windows often do not require -->
<!-- a save area. -->
有一块内存用于保存函数使用的特定的寄存器。该区域的大小，
可能还包括作为返回地址和指向之前栈帧的指针的一些空间，
其为机器特定的并且通常取决于函数中已经使用了哪些寄存器。
具有寄存器窗口的机器通常不需要这样的存储区域。

     <li><!-- A region of at least @var{size} bytes, possibly rounded up to an allocation -->
<!-- boundary, to contain the local variables of the function.  On some machines, -->
<!-- this region and the save area may occur in the opposite order, with the -->
<!-- save area closer to the top of the stack. -->
一块至少<var>size</var>个字节的区域，可能舍人到一个分配边界的大小，
来保存函数的局部变量。在一些机器上，该域和保存域可以按照相反的顺序出现，
使得保存域接近于栈顶。

     <li><a name="index-g_t_0040code_007bACCUMULATE_005fOUTGOING_005fARGS_007d-and-stack-frames-4205"></a><!-- Optionally, when @code{ACCUMULATE_OUTGOING_ARGS} is defined, a region of -->
<!-- @code{current_function_outgoing_args_size} bytes to be used for outgoing -->
<!-- argument lists of the function.  @xref{Stack Arguments}. -->
可选的，当<code>ACCUMULATE_OUTGOING_ARGS</code>被定义时，
还有一块<code>current_function_outgoing_args_size</code>字节大小的区域用于函数的传出
的参数列表。参见<a href="Stack-Arguments.html#Stack-Arguments">Stack Arguments</a>。
</ul>

<div class="defun">
&mdash; Macro: <b>EXIT_IGNORE_STACK</b><var><a name="index-EXIT_005fIGNORE_005fSTACK-4206"></a></var><br>
<blockquote><!-- Define this macro as a C expression that is nonzero if the return -->
     <!-- instruction or the function epilogue ignores the value of the stack -->
     <!-- pointer; in other words, if it is safe to delete an instruction to -->
     <!-- adjust the stack pointer before a return from the function.  The -->
     <!-- default is 0. -->
      <p>定义该宏为一个C表达式，其为非0，如果返回指令或者函数尾声忽略栈指针的值；
换句话说，如果在从函数中返回前，删除调整栈指针的指令是安全的。缺省为0。

     <!-- Note that this macro's value is relevant only for functions for which -->
     <!-- frame pointers are maintained.  It is never safe to delete a final -->
     <!-- stack adjustment in a function that has no frame pointer, and the -->
     <!-- compiler knows this regardless of @code{EXIT_IGNORE_STACK}. -->
      <p>注意该宏的值只于维护帧指针的函数相关。
在没有帧指针的函数中删除最后的栈调整是绝对不安全的，并且编译器知道这种情况，
而不管<code>EXIT_IGNORE_STACK</code>定义如何。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EPILOGUE_USES</b> (<var>regno</var>)<var><a name="index-EPILOGUE_005fUSES-4207"></a></var><br>
<blockquote><!-- Define this macro as a C expression that is nonzero for registers that are -->
     <!-- used by the epilogue or the @samp{return} pattern.  The stack and frame -->
     <!-- pointer registers are already assumed to be used as needed. -->
      <p>定义该宏为一个C表达式，其为非0，对于用于尾声或者&lsquo;<samp><span class="samp">return</span></samp>&rsquo;指令模式的寄存器。
栈和帧指针寄存器已经被假设需要使用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EH_USES</b> (<var>regno</var>)<var><a name="index-EH_005fUSES-4208"></a></var><br>
<blockquote><!-- Define this macro as a C expression that is nonzero for registers that are -->
     <!-- used by the exception handling mechanism, and so should be considered live -->
     <!-- on entry to an exception edge. -->
      <p>定义该宏为一个C表达式，其为非0，对于用于异常处理机制的寄存器，
所以其应该被考虑为在一个异常边的入口上是活跃的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DELAY_SLOTS_FOR_EPILOGUE</b><var><a name="index-DELAY_005fSLOTS_005fFOR_005fEPILOGUE-4209"></a></var><br>
<blockquote><!-- Define this macro if the function epilogue contains delay slots to which -->
     <!-- instructions from the rest of the function can be ``moved''.  The -->
     <!-- definition should be a C expression whose value is an integer -->
     <!-- representing the number of delay slots there. -->
      <p>定义该宏，如果函数尾声包含延迟槽，并且函数其余的指令可以被移动过去。
该定义应该为一个C表达式，其值为一个整数表示有多少个延迟槽。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ELIGIBLE_FOR_EPILOGUE_DELAY</b> (<var>insn, n</var>)<var><a name="index-ELIGIBLE_005fFOR_005fEPILOGUE_005fDELAY-4210"></a></var><br>
<blockquote><!-- A C expression that returns 1 if @var{insn} can be placed in delay -->
     <!-- slot number @var{n} of the epilogue. -->
      <p>一个C表达式，返回1，如果<var>insn</var>可以放在尾声中的延迟槽编号<var>n</var>中。

     <!-- The argument @var{n} is an integer which identifies the delay slot now -->
     <!-- being considered (since different slots may have different rules of -->
     <!-- eligibility).  It is never negative and is always less than the number -->
     <!-- of epilogue delay slots (what @code{DELAY_SLOTS_FOR_EPILOGUE} returns). -->
     <!-- If you reject a particular insn for a given delay slot, in principle, it -->
     <!-- may be reconsidered for a subsequent delay slot.  Also, other insns may -->
     <!-- (at least in principle) be considered for the so far unfilled delay -->
     <!-- slot. -->
      <p>参数<var>n</var>为一个整数，其标识了目前被考虑的延迟槽（由于不同的延迟槽可以具有不同
的适任规则）。其从不为负，并且总是小于尾声延迟槽的总数
（<code>DELAY_SLOTS_FOR_EPILOGUE</code>的返回值）。
如果你为给定的延迟槽拒绝了一个特定的insn，原则上，其可以被后续的延迟槽重新考虑。
而且，其它insn还可以（至少原则上）被目前为止还没有被填充的延迟槽考虑。

      <p><a name="index-current_005ffunction_005fepilogue_005fdelay_005flist-4211"></a><a name="index-final_005fscan_005finsn-4212"></a><!-- The insns accepted to fill the epilogue delay slots are put in an RTL -->
<!-- list made with @code{insn_list} objects, stored in the variable -->
<!-- @code{current_function_epilogue_delay_list}.  The insn for the first -->
<!-- delay slot comes first in the list.  Your definition of the macro -->
<!-- @code{TARGET_ASM_FUNCTION_EPILOGUE} should fill the delay slots by -->
<!-- outputting the insns in this list, usually by calling -->
<!-- @code{final_scan_insn}. -->
被接受填充尾声延迟槽的insn被放在一个RTL链表中，使用<code>insn_list</code>对象，
并存储在变量<code>current_function_epilogue_delay_list</code>中。
第一个延迟槽的insn位于链表中的第一个。你对宏<code>TARGET_ASM_FUNCTION_EPILOGUE</code>
的定义应该通过输出该链表的insn来填充延迟槽，通常是调用<code>final_scan_insn</code>。

     <!-- You need not define this macro if you did not define -->
     <!-- @code{DELAY_SLOTS_FOR_EPILOGUE}. -->
      <p>你不需要定义该宏，如果你没有定义<code>DELAY_SLOTS_FOR_EPILOGUE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_OUTPUT_MI_THUNK</b> (<var>FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, tree function</var>)<var><a name="index-TARGET_005fASM_005fOUTPUT_005fMI_005fTHUNK-4213"></a></var><br>
<blockquote><!-- A function that outputs the assembler code for a thunk -->
     <!-- function, used to implement C++ virtual function calls with multiple -->
     <!-- inheritance.  The thunk acts as a wrapper around a virtual function, -->
     <!-- adjusting the implicit object parameter before handing control off to -->
     <!-- the real function. -->
      <p>一个函数，输出一个thunk函数的汇编代码，用于实现具有多继承的C++虚函数调用。
thunk作为一个虚函数的封装，用来调整隐式对象参数，在将控制移交给实函数之前。

     <!-- First, emit code to add the integer @var{delta} to the location that -->
     <!-- contains the incoming first argument.  Assume that this argument -->
     <!-- contains a pointer, and is the one used to pass the @code{this} pointer -->
     <!-- in C++.  This is the incoming argument @emph{before} the function prologue, -->
     <!-- e.g.@: @samp{%o0} on a sparc.  The addition must preserve the values of -->
     <!-- all other incoming arguments. -->
      <p>首选，输出代码来增加整数<var>delta</var>为包含传递进来的第一个参数的为。
假设该参数包含一个指针，并用于在C++中传递<code>this</code>指针。
这是在函数序言之前的参数，例如在sparc上为&lsquo;<samp><span class="samp">%o0</span></samp>&rsquo;。

     <!-- Then, if @var{vcall_offset} is nonzero, an additional adjustment should be -->
     <!-- made after adding @code{delta}.  In particular, if @var{p} is the -->
     <!-- adjusted pointer, the following adjustment should be made: -->
      <p>然后，如果<var>vcall_offset</var>非0，则在增加<var>delta</var>之后应该进行额外的调整。
特别是，如果<var>p</var>为被调整的指针，则应该进行如下的调整：

     <pre class="smallexample">          p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]
</pre>
      <!-- After the additions, emit code to jump to @var{function}, which is a -->
     <!-- @code{FUNCTION_DECL}.  This is a direct pure jump, not a call, and does -->
     <!-- not touch the return address.  Hence returning from @var{FUNCTION} will -->
     <!-- return to whoever called the current @samp{thunk}. -->
      <p>加法之后，输出代码跳转到<var>function</var>，其为<code>FUNCTION_DECL</code>。
这是一个直接跳转，而不是调用，并且不触及返回地址。因此从<var>FUNCTION</var>中返回时，
将返回到调用当前&lsquo;<samp><span class="samp">thunk</span></samp>&rsquo;的地方。

     <!-- The effect must be as if @var{function} had been called directly with -->
     <!-- the adjusted first argument.  This macro is responsible for emitting all -->
     <!-- of the code for a thunk function; @code{TARGET_ASM_FUNCTION_PROLOGUE} -->
     <!-- and @code{TARGET_ASM_FUNCTION_EPILOGUE} are not invoked. -->
      <p>其效果就好像是函数被直接调用，并使用调整后的第一个参数。
该宏负责输出thunk函数的所有代码；<code>TARGET_ASM_FUNCTION_PROLOGUE</code>和<code>TARGET_ASM_FUNCTION_EPILOGUE</code>不被调用。

     <!-- The @var{thunk_fndecl} is redundant.  (@var{delta} and @var{function} -->
     <!-- have already been extracted from it.)  It might possibly be useful on -->
     <!-- some targets, but probably not. -->
      <p><var>thunk_fndecl</var>是冗余的。（<var>delta</var>和<var>function</var>已经从中被抽取出来。）
其可能在一些target上有用，也很可能没用。

     <!-- If you do not define this macro, the target-independent code in the C++ -->
     <!-- front end will generate a less efficient heavyweight thunk that calls -->
     <!-- @var{function} instead of jumping to it.  The generic approach does -->
     <!-- not support varargs. -->
      <p>如果你没有定义该宏，则C++前端的target无关代码将会生成一个不太有效的重量级的
thunk，其调用<var>function</var>而不是直接跳转过去。普通的方法不支持varargs。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ASM_CAN_OUTPUT_MI_THUNK</b> (<var>const_tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, const_tree function</var>)<var><a name="index-TARGET_005fASM_005fCAN_005fOUTPUT_005fMI_005fTHUNK-4214"></a></var><br>
<blockquote><!-- A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would be able -->
     <!-- to output the assembler code for the thunk function specified by the -->
     <!-- arguments it is passed, and false otherwise.  In the latter case, the -->
     <!-- generic approach will be used by the C++ front end, with the limitations -->
     <!-- previously exposed. -->
      <p>一个函数，返回真，如果TARGET_ASM_OUTPUT_MI_THUNK应该能够为其传递的参数所指定的
thunk函数输出汇编代码，否则为假。在后一种情况下，C++前端将会使用普通的方式，
并具有之前提到的限制。
</p></blockquote></div>

<!-- @node Profiling -->
<!-- @subsection Generating Code for Profiling -->
 </body></html>

