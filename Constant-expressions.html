<html lang="zh">
<head>
<title>Constant expressions - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Expression-trees.html#Expression-trees" title="Expression trees">
<link rel="next" href="Storage-References.html#Storage-References" title="Storage References">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Constant-expressions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Storage-References.html#Storage-References">Storage References</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Expression-trees.html#Expression-trees">Expression trees</a>
<hr>
</div>

<h4 class="subsection">11.6.1 常量表达式</h4>

<p><a name="index-INTEGER_005fCST-2419"></a><a name="index-TREE_005fINT_005fCST_005fHIGH-2420"></a><a name="index-TREE_005fINT_005fCST_005fLOW-2421"></a><a name="index-tree_005fint_005fcst_005flt-2422"></a><a name="index-tree_005fint_005fcst_005fequal-2423"></a><a name="index-REAL_005fCST-2424"></a><a name="index-FIXED_005fCST-2425"></a><a name="index-COMPLEX_005fCST-2426"></a><a name="index-VECTOR_005fCST-2427"></a><a name="index-STRING_005fCST-2428"></a><a name="index-TREE_005fSTRING_005fLENGTH-2429"></a><a name="index-TREE_005fSTRING_005fPOINTER-2430"></a>
<!-- The table below begins with constants, moves on to unary expressions, -->
<!-- then proceeds to binary expressions, and concludes with various other -->
<!-- kinds of expressions: -->
下面的列表格首先介绍了常数，接着是一元表达式，然后是二元表达式，以及各种其它类型的表达式：

     <dl>
<dt><code>INTEGER_CST</code><dd><!-- These nodes represent integer constants.  Note that the type of these -->
<!-- constants is obtained with @code{TREE_TYPE}; they are not always of type -->
<!-- @code{int}.  In particular, @code{char} constants are represented with -->
<!-- @code{INTEGER_CST} nodes.  The value of the integer constant @code{e} is -->
<!-- given by -->
这些节点表示整数常量。注意这些常量的类型通过<code>TREE_TYPE</code>来获得；并不总是<code>int</code>型的。特别是，
<code>char</code>型常量使用<code>INTEGER_CST</code>节点表示。整数常量<code>e</code>的值通过下面的方式给出
     <pre class="smallexample">          ((TREE_INT_CST_HIGH (e) &lt;&lt; HOST_BITS_PER_WIDE_INT)
          + TREE_INST_CST_LOW (e))
</pre>
     <p class="noindent"><!-- HOST_BITS_PER_WIDE_INT is at least thirty-two on all platforms.  Both -->
<!-- @code{TREE_INT_CST_HIGH} and @code{TREE_INT_CST_LOW} return a -->
<!-- @code{HOST_WIDE_INT}.  The value of an @code{INTEGER_CST} is interpreted -->
<!-- as a signed or unsigned quantity depending on the type of the constant. -->
<!-- In general, the expression given above will overflow, so it should not -->
<!-- be used to calculate the value of the constant. -->
HOST_BITS_PER_WIDE_INT在所有的平台上最少为32。<code>TREE_INT_CST_HIGH</code>和<code>TREE_INT_CST_LOW</code>都返回一个<code>HOST_WIDE_INT</code>。一个<code>INTEGER_CST</code>的值根据常量的类型而被解析为有符号或无符号的数。一般来说，上面给出的表达式将会溢出，因此不要用来计算常量的值。

     <!-- The variable @code{integer_zero_node} is an integer constant with value -->
     <!-- zero.  Similarly, @code{integer_one_node} is an integer constant with -->
     <!-- value one.  The @code{size_zero_node} and @code{size_one_node} variables -->
     <!-- are analogous, but have type @code{size_t} rather than @code{int}. -->
     <p>变量<code>integer_zero_node</code>是一个值为0的整数常量。类似的，<code>integer_one_node</code>是值为1的整数常量。变量<code>size_zero_node</code>和<code>size_one_node</code>比较类似，只是具有<code>size_t</code>类型，而不是<code>int</code>。

     <!-- The function @code{tree_int_cst_lt} is a predicate which holds if its -->
     <!-- first argument is less than its second.  Both constants are assumed to -->
     <!-- have the same signedness (i.e., either both should be signed or both -->
     <!-- should be unsigned.)  The full width of the constant is used when doing -->
     <!-- the comparison; the usual rules about promotions and conversions are -->
     <!-- ignored.  Similarly, @code{tree_int_cst_equal} holds if the two -->
     <!-- constants are equal.  The @code{tree_int_cst_sgn} function returns the -->
     <!-- sign of a constant.  The value is @code{1}, @code{0}, or @code{-1} -->
     <!-- according on whether the constant is greater than, equal to, or less -->
     <!-- than zero.  Again, the signedness of the constant's type is taken into -->
     <!-- account; an unsigned constant is never less than zero, no matter what -->
     <!-- its bit-pattern. -->
     <p>函数<code>tree_int_cst_lt</code>是一个断言，当第一个参数小于第二个时有效。两个常量被假设为具有相同的符号性（即，要么都是有符号的，要么都是无符号的。）在作比较时，使用常量的全部宽度；并忽略掉通常的类型提升和转换规则。类似的，<code>tree_int_cst_equal</code>在两个常熟相等时有效。函数<code>tree_int_cst_sgn</code>返回常数的符号。根据常数是大于，等于，或小于0，而返回值<code>1</code>, <code>0</code>或<code>-1</code>。此外，会顾及到常数类型的符号性；无符号常数是永远小于0的，不论它的位模式如何。

     <br><dt><code>REAL_CST</code><dd>
<!-- FIXME: Talk about how to obtain representations of this constant, do -->
<!-- comparisons, and so forth. -->
FIXME: 讨论如何获得该常量的表示，如何进行比较等等。

     <br><dt><code>FIXED_CST</code><dd>
<!-- These nodes represent fixed-point constants.  The type of these constants -->
<!-- is obtained with @code{TREE_TYPE}.  @code{TREE_FIXED_CST_PTR} points to -->
<!-- a @code{struct fixed_value};  @code{TREE_FIXED_CST} returns the structure -->
<!-- itself.  @code{struct fixed_value} contains @code{data} with the size of two -->
<!-- @code{HOST_BITS_PER_WIDE_INT} and @code{mode} as the associated fixed-point -->
<!-- machine mode for @code{data}. -->
这些节点表示定点常数。这些常量的类型通过<code>TREE_TYPE</code>获得。<code>TREE_FIXED_CST_PTR</code>指向struct fixed_value；<code>TREE_FIXED_CST</code>返回结构体本身。Struct fixed_value包含了具有2个HOST_BITS_PER_WIDE_INT大小的<code>data</code>，以及与<code>data</code>关联的定点机器模式<code>mode</code>。

     <br><dt><code>COMPLEX_CST</code><dd><!-- These nodes are used to represent complex number constants, that is a -->
<!-- @code{__complex__} whose parts are constant nodes.  The -->
<!-- @code{TREE_REALPART} and @code{TREE_IMAGPART} return the real and the -->
<!-- imaginary parts respectively. -->
这些节点用于表示复数常量，即<code>__complex__</code> ，其组成部分为常数节点。<code>TREE_REALPART</code>和<code>TREE_IMAGPART</code>返回相应的实部和虚部。

     <br><dt><code>VECTOR_CST</code><dd><!-- These nodes are used to represent vector constants, whose parts are -->
<!-- constant nodes.  Each individual constant node is either an integer or a -->
<!-- double constant node.  The first operand is a @code{TREE_LIST} of the -->
<!-- constant nodes and is accessed through @code{TREE_VECTOR_CST_ELTS}. -->
这些节点用于表示向量常数，其组成部分为常量节点。每个单独的常量节点或者是一个常整数节点，或者是一个双精度的常数节点。第一个操作数为常数节点的<code>TREE_LIST</code>，并可以通过<code>TREE_VECTOR_CST_ELTS</code>来访问。

     <br><dt><code>STRING_CST</code><dd><!-- These nodes represent string-constants.  The @code{TREE_STRING_LENGTH} -->
<!-- returns the length of the string, as an @code{int}.  The -->
<!-- @code{TREE_STRING_POINTER} is a @code{char*} containing the string -->
<!-- itself.  The string may not be @code{NUL}-terminated, and it may contain -->
<!-- embedded @code{NUL} characters.  Therefore, the -->
<!-- @code{TREE_STRING_LENGTH} includes the trailing @code{NUL} if it is -->
<!-- present. -->
这些节点表示字符串常量。<code>TREE_STRING_LENGTH</code>返回<code>int</code>型的字符串长度。<code>TREE_STRING_POINTER</code>是一个<code>char*</code>型，包含了字符串本身。字符串可以不是<code>NUL</code>结尾的，并且可以包含嵌入的<code>NUL</code>字符。因此，如果字符串的结尾存在<code>NUL</code>，则<code>TREE_STRING_LENGTH</code>也包括了结尾的NUL。

     <!-- For wide string constants, the @code{TREE_STRING_LENGTH} is the number -->
     <!-- of bytes in the string, and the @code{TREE_STRING_POINTER} -->
     <!-- points to an array of the bytes of the string, as represented on the -->
     <!-- target system (that is, as integers in the target endianness).  Wide and -->
     <!-- non-wide string constants are distinguished only by the @code{TREE_TYPE} -->
     <!-- of the @code{STRING_CST}. -->
     <p>对于宽字符串常量，<code>TREE_STRING_LENGTH</code>为字符串的字节数，并且<code>TREE_STRING_POINTER</code>指向在目标系统上表示的，字符串的字节数组（即，符合目标大小端的整数系列）。宽字符串和非宽字符串常量，只区别于<code>STRING_CST</code>的<code>TREE_TYPE</code>。

     <!-- FIXME: The formats of string constants are not well-defined when the -->
     <!-- target system bytes are not the same width as host system bytes. -->
     <p>FIXME: 当目标系统的字节与主机系统的字节宽度不同时，字符串的格式没有被很好的定义。

 </dl>

<!-- @node Storage References -->
<!-- @subsection References to storage -->
 </body></html>

