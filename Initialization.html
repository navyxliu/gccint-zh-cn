<html lang="zh">
<head>
<title>Initialization - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Assembler-Format.html#Assembler-Format" title="Assembler Format">
<link rel="prev" href="Label-Output.html#Label-Output" title="Label Output">
<link rel="next" href="Macros-for-Initialization.html#Macros-for-Initialization" title="Macros for Initialization">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Initialization"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Macros-for-Initialization.html#Macros-for-Initialization">Macros for Initialization</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Label-Output.html#Label-Output">Label Output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Assembler-Format.html#Assembler-Format">Assembler Format</a>
<hr>
</div>

<h4 class="subsection">17.21.5 如何处理初始化函数</h4>

<p><a name="index-initialization-routines-4557"></a><a name="index-termination-routines-4558"></a><a name="index-constructors_002c-output-of-4559"></a><a name="index-destructors_002c-output-of-4560"></a>
<!-- The compiled code for certain languages includes @dfn{constructors} -->
<!-- (also called @dfn{initialization routines})-functions to initialize -->
<!-- data in the program when the program is started.  These functions need -->
<!-- to be called before the program is ``started''-that is to say, before -->
<!-- @code{main} is called. -->
一些语言被编译后的代码中会包含构造者（也称为初始化例程）&mdash;当程序启动时，
用来初始化程序中的数据的函数。这些函数需要在程序开始前被调用&mdash;也就是说，
在调用<code>main</code>之前。

<!-- Compiling some languages generates @dfn{destructors} (also called -->
<!-- @dfn{termination routines}) that should be called when the program -->
<!-- terminates. -->
 <p>编译一些语言还会生成析构者（也成为终止例程），将在程序终止时被调用。

<!-- To make the initialization and termination functions work, the compiler -->
<!-- must output something in the assembler code to cause those functions to -->
<!-- be called at the appropriate time.  When you port the compiler to a new -->
<!-- system, you need to specify how to do this. -->
 <p>为了让初始化和终止函数工作，编译器必须在汇编代码中输出一些东西，
使得那些函数在适当的时候被调用。当你将编译器移植到一个新的系统时，
你需要指定如何做。

<!-- There are two major ways that GCC currently supports the execution of -->
<!-- initialization and termination functions.  Each way has two variants. -->
<!-- Much of the structure is common to all four variations. -->
 <p>GCC目前支持两种主要的方式，来执行初始化和终止函数。
每种方式都有两个变体。大多数结构体对于这四个变体都是通用的。

 <p><a name="index-g_t_005f_005fCTOR_005fLIST_005f_005f-4561"></a><a name="index-g_t_005f_005fDTOR_005fLIST_005f_005f-4562"></a><!-- The linker must build two lists of these functions-a list of -->
<!-- initialization functions, called @code{__CTOR_LIST__}, and a list of -->
<!-- termination functions, called @code{__DTOR_LIST__}. -->
连接器必须构建两个这些函数的链表&mdash;一个是初始化函数链表，
叫做<code>__CTOR_LIST__</code>，一个是终止函数，叫做<code>__DTOR_LIST__</code>。

<!-- Each list always begins with an ignored function pointer (which may hold -->
<!-- 0, @minus{}1, or a count of the function pointers after it, depending on -->
<!-- the environment).  This is followed by a series of zero or more function -->
<!-- pointers to constructors (or destructors), followed by a function -->
<!-- pointer containing zero. -->
 <p>每个列表总是起始于一个被忽略的函数指针（其可能为0，-1，
或者之后的函数指针的个数，这取决于具体环境）。
随后是一系列指向构造者（或析构者）的零个或多个函数指针，
然后是一个包含0的函数指针。

<!-- Depending on the operating system and its executable file format, either -->
<!-- @file{crtstuff.c} or @file{libgcc2.c} traverses these lists at startup -->
<!-- time and exit time.  Constructors are called in reverse order of the -->
<!-- list; destructors in forward order. -->
 <p>取决于操作系统和它的可执行文件格式，或者<samp><span class="file">crtstuff.c</span></samp>，
或者<samp><span class="file">libgcc2.c</span></samp>会在起始时间和退出时间遍历这些列表。
构造者按照列表相反的顺序被调用；析构者按照向前的顺序。

<!-- The best way to handle static constructors works only for object file -->
<!-- formats which provide arbitrarily-named sections.  A section is set -->
<!-- aside for a list of constructors, and another for a list of destructors. -->
<!-- Traditionally these are called @samp{.ctors} and @samp{.dtors}.  Each -->
<!-- object file that defines an initialization function also puts a word in -->
<!-- the constructor section to point to that function.  The linker -->
<!-- accumulates all these words into one contiguous @samp{.ctors} section. -->
<!-- Termination functions are handled similarly. -->
 <p>处理静态构造者的最好的方式，
只有在目标文件格式提供任意命名section的时候才可以工作。
这会在构造者列表旁边设置一个section，析构者列表旁边设置另一个，
通常称作&lsquo;<samp><span class="samp">.ctors</span></samp>&rsquo;和&lsquo;<samp><span class="samp">.dtors</span></samp>&rsquo;。
每个定义了初始化函数的目标文件，还在构造section中放入一个字，
以指向那个函数。
连接器将所有这些字累积放入到一个邻近的&lsquo;<samp><span class="samp">.ctors</span></samp>&rsquo; section中。
终止函数按照类似的方式处理。

<!-- This method will be chosen as the default by @file{target-def.h} if -->
<!-- @code{TARGET_ASM_NAMED_SECTION} is defined.  A target that does not -->
<!-- support arbitrary sections, but does support special designated -->
<!-- constructor and destructor sections may define @code{CTORS_SECTION_ASM_OP} -->
<!-- and @code{DTORS_SECTION_ASM_OP} to achieve the same effect. -->
 <p>如果定义了TARGET_ASM_NAMED_SECTION，
则该方法将被<samp><span class="file">target-def.h</span></samp>作为缺省方式选择。
不支持任意section，但是支持特定的构造者和析构者section的target，
可以定义<code>CTORS_SECTION_ASM_OP</code>和<code>DTORS_SECTION_ASM_OP</code>
来达到相同的效果。

<!-- When arbitrary sections are available, there are two variants, depending -->
<!-- upon how the code in @file{crtstuff.c} is called.  On systems that -->
<!-- support a @dfn{.init} section which is executed at program startup, -->
<!-- parts of @file{crtstuff.c} are compiled into that section.  The -->
<!-- program is linked by the @command{gcc} driver like this: -->
 <p>当支持任意section时，有两个变体，
取决于如何调用<samp><span class="file">crtstuff.c</span></samp>中的代码。
在支持<dfn>.init</dfn> section（其在程序起始时被执行）的系统上，
<samp><span class="file">crtstuff.c</span></samp>的部分代码被编译到那个section中。
程序按照类似于下面的方式被<samp><span class="command">gcc</span></samp>驱动连接：

<pre class="smallexample">     ld -o <var>output_file</var> crti.o crtbegin.o ... -lgcc crtend.o crtn.o
</pre>
 <!-- The prologue of a function (@code{__init}) appears in the @code{.init} -->
<!-- section of @file{crti.o}; the epilogue appears in @file{crtn.o}.  Likewise -->
<!-- for the function @code{__fini} in the @dfn{.fini} section.  Normally these -->
<!-- files are provided by the operating system or by the GNU C library, but -->
<!-- are provided by GCC for a few targets. -->
 <p>函数（<code>__init</code>）的序言出现在<samp><span class="file">crti.o</span></samp>的<code>.init</code> section中；
尾声出现在<samp><span class="file">crtn.o</span></samp>中。同样的，函数<code>__fini</code>在<dfn>.fini</dfn> section中。
通常这些文件由操作系统或者GNU C库提供，但GCC也为一些target提供。

<!-- The objects @file{crtbegin.o} and @file{crtend.o} are (for most targets) -->
<!-- compiled from @file{crtstuff.c}.  They contain, among other things, code -->
<!-- fragments within the @code{.init} and @code{.fini} sections that branch -->
<!-- to routines in the @code{.text} section.  The linker will pull all parts -->
<!-- of a section together, which results in a complete @code{__init} function -->
<!-- that invokes the routines we need at startup. -->
 <p>目标文件<samp><span class="file">crtbegin.o</span></samp>和<samp><span class="file">crtend.o</span></samp>是从<samp><span class="file">crtstuff.c</span></samp>
中编译出来的（对于大多target）。它们包含了，在<code>.init</code>和<code>.fini</code>
section中的代码片断，用于跳转到<code>.text</code> section中的例程中。
连接器会把section的所有部分放在一起，形成完整的<code>__init</code>函数，
其可以在起始处调用我们需要的例程。

<!-- To use this variant, you must define the @code{INIT_SECTION_ASM_OP} -->
 <p>macro properly. 
要使用这个变体，你必须适当的定义<code>INIT_SECTION_ASM_OP</code>宏。

<!-- If no init section is available, when GCC compiles any function called -->
<!-- @code{main} (or more accurately, any function designated as a program -->
<!-- entry point by the language front end calling @code{expand_main_function}), -->
<!-- it inserts a procedure call to @code{__main} as the first executable code -->
<!-- after the function prologue.  The @code{__main} function is defined -->
<!-- in @file{libgcc2.c} and runs the global constructors. -->
 <p>如果init section不可用，GCC在编译任何叫做<code>main</code>（或者更加确切的说，
任何被语言前端<code>expand_main_function</code>指定为程序入口点的函数）的函数时，
其会插入一个调用<code>__main</code>的程序，以作为在函数序言之后首先执行的代码。
<code>__main</code>函数在<samp><span class="file">libgcc2.c</span></samp>中定义，并运行全局的构造者。

<!-- In file formats that don't support arbitrary sections, there are again -->
<!-- two variants.  In the simplest variant, the GNU linker (GNU @code{ld}) -->
<!-- and an `a.out' format must be used.  In this case, -->
<!-- @code{TARGET_ASM_CONSTRUCTOR} is defined to produce a @code{.stabs} -->
<!-- entry of type @samp{N_SETT}, referencing the name @code{__CTOR_LIST__}, -->
<!-- and with the address of the void function containing the initialization -->
<!-- code as its value.  The GNU linker recognizes this as a request to add -->
<!-- the value to a @dfn{set}; the values are accumulated, and are eventually -->
<!-- placed in the executable as a vector in the format described above, with -->
<!-- a leading (ignored) count and a trailing zero element. -->
<!-- @code{TARGET_ASM_DESTRUCTOR} is handled similarly.  Since no init -->
<!-- section is available, the absence of @code{INIT_SECTION_ASM_OP} causes -->
<!-- the compilation of @code{main} to call @code{__main} as above, starting -->
<!-- the initialization process. -->
 <p>对于文件格式不支持任意section的，也有两个变体。对于最简单的变体，
必须使用GNU连接器（GNU <code>ld</code>）和'a.out'格式。在这种情况下，
<code>TARGET_ASM_CONSTRUCTOR</code>被定义，
用来生成一个&lsquo;<samp><span class="samp">N_SETT</span></samp>&rsquo;类型的<code>.stabs</code>条目，
来引用名字<code>__CTOR_LIST__</code>，
并且其值为一个包含了初始化代码的void函数地址。
GNU连接器将其识别为一个要设定的值；该值会被累积，
并最终作为一个向量放在可执行程序中，
一个前导（被忽略的）数目和一个尾部的0元素。
<code>TARGET_ASM_DESTRUCTOR</code>按照类似的情况被处理。
由于init section不可用，所以使得编译<code>main</code>来调用<code>__main</code>，
以开始初始化。

<!-- The last variant uses neither arbitrary sections nor the GNU linker. -->
<!-- This is preferable when you want to do dynamic linking and when using -->
<!-- file formats which the GNU linker does not support, such as `ECOFF'@.  In -->
<!-- this case, @code{TARGET_HAVE_CTORS_DTORS} is false, initialization and -->
<!-- termination functions are recognized simply by their names.  This requires -->
<!-- an extra program in the linkage step, called @command{collect2}.  This program -->
<!-- pretends to be the linker, for use with GCC; it does its job by running -->
<!-- the ordinary linker, but also arranges to include the vectors of -->
<!-- initialization and termination functions.  These functions are called -->
<!-- via @code{__main} as described above.  In order to use this method, -->
<!-- @code{use_collect2} must be defined in the target in @file{config.gcc}. -->
 <p>最后一个变体既不使用任意section，也不使用GNU连接器。这适合于，
你想进行动态连接并使用GNU连接器不支持的文件格式的时候，例如 'ECOFF'。
在这种情况下，<code>TARGET_HAVE_CTORS_DTORS</code>为假，
初始化和终止函数简单的通过它们的名字来识别。这要求在连接过程中的额外程序，
叫做<samp><span class="command">collect2</span></samp>。该程序作为GCC使用的连接器；
它通过运行普通的连接器来完成工作，但是还负责包含初始化和终止函数的向量。
这些函数通过<code>__main</code>调用。要使用这种方式，
必须在<samp><span class="file">config.gcc</span></samp>中定义<code>use_collect2</code>。

<!-- @node Macros for Initialization -->
<!-- @subsection Macros Controlling Initialization Routines -->
 </body></html>

