@c Copyright (C) 1988, 1989, 1992, 1994, 1997, 1998, 1999, 2000, 2001, 2002,
@c 2003, 2004, 2005, 2006, 2007, 2008
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node RTL
@chapter RTL表示
@cindex RTL表示
@cindex representation of RTL
@cindex Register Transfer Language (RTL)

编译器的大部分工作都是基于一种中间表示，叫做寄存器传送语言（register transfer language）。在该语言中，描述了将要输出的指令，并且差不多是按照字母顺序一个一个的来描述指令的行为。

RTL的灵感来自Lisp列表。它同时具有一个内部形式，由指向结构体的结构体组成，以及一个文本形式，用在机器描述和打印的调试输出中。文本形式使用嵌套的括号，来表示内部形式中的指针。

@menu
* RTL对象::       表达式、向量、字符串、整数 
* RTL类别::       RTL表达式对象的类别，以及它们的结构 
* 访问方式::      用来访问表达式操作数和向量成员的宏
* 访问特殊操作数::  用来访问RTL中的特殊注解
* 标记::          RTL表达式中的其它标记
* 机器模式::      描述一个数据的大小和格式
* 常数::          常数值表达式
* 寄存器和内存::  表示寄存器内容或内存的表达式
* 算术运算::      表示算术运算的表达式 
* 比较运算::      表示比较运算的表达式
* 位域运算::      表示内存或寄存器中位域的表达式
* 向量运算::      关于向量数据类型的表达式
* 转换运算::      扩展，截断，浮点化或者定点化
* RTL声明::       声明为volatile的，constant的，等等
* 副作用::        存储到寄存器的表达式，等
* Incdec::        自动增量寻址的嵌入的副作用
* 汇编::          表示带有操作数的asm
* Insns::         整个insn的表达式类型
* 函数调用::      函数call insn的RTL表示
* 共享::          一些表达式是唯一的；其它的必须要被复制
* 读取RTL::       从文件中读取文本的RTL
@end menu

@node RTL对象
@section RTL对象类型
@cindex RTL object types

@cindex RTL integers
@cindex RTL strings
@cindex RTL vectors
@cindex RTL expression
@cindex RTX (See RTL)
RTL使用五种对象：表达式、整数、宽整数、字符串和向量。其中，最重要的是表达式。RTL 表达式（简称RTX）是一个C结构体，通常用指针来引用它。这种引用它的指针的类型定义名为@code{rtx}。

整数就是C中的@code{int}，书写形式使用十进制表示。宽整数是@code{HOST_WIDE_INT}类型的一个整数对象，其书写形式也用十进制表示。

字符串为一串字符，在存储器中以C的@code{char *}形式表示且按C语法规定书写。然而，RTL中的字符串决不会为空值。若机器描述中有一空字符串，它在存储器中则表示成一个空指针而不是通常意义上的指向空字符的指针。在某些上下文中，允许用这种空指针表示空字符串。在RTL代码中，字符串经常出现在@code{symbol_ref}表达式中，但也出现在某些机器描述的RTL表达式中。

对于字符串，还有一种特殊的语法，用于在机器描述中嵌入C代码。只要字符串可以出现的地方，都可以书写一个C风格的大括号代码块。整个大括号代码块，包括最外面的一对括号，被作为字符串常量看待。括号里面的双引号字符不是特殊字符。因此，如果你在C代码中书写字符串常量，则不需要使用反斜杠来转义每个引号字符。

向量包含任意数目的指向表达式的指针。向量中元素的个数，在向量中显式的存在。向量的书写形式为，方括号（@samp{[@dots{}]}），里面是元素，并使用空格分隔。长度为0的向量不会被创建；而是使用空指针来替代。

@cindex expression codes
@cindex codes, RTL expression
@findex GET_CODE
@findex PUT_CODE
表达式根据@dfn{expression codes}来划分类别（也称作RTX代码）。表达式代码为在@file{rtl.def}中定义的一个名字，其也是一个（大写的）C枚举常量。合理的表达式代码以及它们的含义，是机器无关的。RTX的代码可以使用宏@code{GET_CODE (@var{x})}来抽取，以及使用@code{PUT_CODE (@var{x}, @var{newcode})}来修改。

表达式代码决定了表达式包含了多少个操作数，以及它们都是什么对象。在RTL中，不像Lisp，你不能通过查看一个操作数来得知它是什么对象。替代的，你必须通过它的上下文来知道——通过所包含的表达式的表达式代码。例如，在一个表达式代码为@code{subreg}的表达式中，第一个操作数被作为一个表达式，第二个操作数为一个整数。在代码为@code{plus}的表达式中，有两个操作数，都作为表达式。在@code{symbol_ref}表达式中，有一个操作数，作为一个字符串。

表达式被书写为，一对括号，包含了表达式类型的名字，它的标记和机器模式（如果存在的话），然后是表达式的操作数（通过空格分隔）。

表达式代码名，在@samp{md}文件中按小写形式书写，但在C代码中出现时按大写形式书写。在这个手册里，它们按照如下形式表示：@code{const_int}。

@cindex (nil)
@cindex nil
在一些上下文中，表达式通常会需要一个空指针。这种书写形式为@code{(nil)}。

@node RTL类别
@section RTL类别和格式
@cindex RTL classes
@cindex classes of RTX codes
@cindex RTX codes, classes of
@findex GET_RTX_CLASS

不同的表达式代码被分为几个类别（@dfn{classes}），其有单个字符表示。你可以使用宏@code{GET_RTX_CLASS (@var{code})}来确定RTX代码的类别。当前，@file{rtl.def}定义了这些类别：

@table @code
@item RTX_OBJ
一个RTX代码，表示一个实际的对象，例如一个寄存器(@code{REG})或者一个内存位置(@code{MEM}, @code{SYMBOL_REF})。也包括@code{LO_SUM})；但是，@code{SUBREG}和@code{STRICT_LOW_PART}不在这个类别中，而是在@code{x}类别中。

@item RTX_CONST_OBJ
一个RTX代码，表示一个常量对象。@code{HIGH}也包含在该类别中。

@item RTX_COMPARE
一个RTX代码，针对一个非对称的比较，例如@code{GEU}或@code{LT}。

@item RTX_COMM_COMPARE
一个RTX代码，针对一个对称（可交换）比较，例如，例如@code{EQ}或@code{ORDERED}。

@item RTX_UNARY
一个RTX代码，针对一元算术运算，例如@code{NEG}，@code{NOT}或者@code{ABS}。这个类别还包括值扩展（符号扩展或者零扩展），以及整数和浮点之间的转换。

@item RTX_COMM_ARITH
一个RTX代码，针对可交换的二元运算，例如@code{PLUS}或者@code{AND}。@code{NE}和@code{EQ}为比较运算，所以它们具有类别@code{<}。

@item RTX_BIN_ARITH
一个RTX代码，针对不可交换的二元运算，例如@code{MINUS}，@code{DIV}或者@code{ASHIFTRT}。

@item RTX_BITFIELD_OPS
一个RTX代码，针对位域运算。当前只有@code{ZERO_EXTRACT}和@code{SIGN_EXTRACT}。这些有三个输入，并且为左值。@zhxref{Bit-Fields}。

@item RTX_TERNARY
一个RTX代码，针对其它有三个输入的运算。当前只有@code{IF_THEN_ELSE}和@code{VEC_MERGE}。

@item RTX_INSN
一个RTX代码，针对整个指令：@code{INSN}，@code{JUMP_INSN}和@code{CALL_INSN}。@zhxref{Insns}。

@item RTX_MATCH
一个RTX代码，针对在insn中的一些匹配，例如@code{MATCH_DUP}。这些只出现在机器描述中。

@item RTX_AUTOINC
一个RTX代码，针对一个自动增量寻址模式，例如@code{POST_INC}。

@item RTX_EXTRA
所有其它的RTX代码。这个类别包括只在机器描述(@code{DEFINE_*}等)中使用的其它RTX代码。其还表示所有表述副作用的RTX代码（@code{SET}，@code{USE}，@code{CLOBBER}等），以及在insn链中可能出现的非insn，例如@code{NOTE}，@code{BARRIER}和@code{CODE_LABEL}。@code{SUBREG}也属于该类。

@end table

@cindex RTL format
对于每个表达式代码，@file{rtl.def}使用称作表达式代码格式（@dfn{format}）的字符序列，来说明所包含的对象数目，以及它们的种类。例如，@code{subreg}的格式为@samp{ei}。

@cindex RTL format characters
这些是最常用的格式字符：

@table @code
@item e
一个表达式（实际是一个表达式指针）

@item i
一个整数。

@item w
一个宽整数。

@item s
一个字符串。

@item E
一个表达式向量。
@end table

还有一些其它的格式字符有时会被用到：

@table @code
@item u
@samp{u}等价于@samp{e}，只不过是在调试转储中的打印有所区别。其用于insn指针。

@item n
@samp{n}等价于@samp{i}， 只不过是在调试转储中的打印有所区别。其用于@code{note} insn的行号和代码号。

@item S
@samp{S}表示一个可选的字符串。在内部的RTX对象中，@samp{S}等价于@samp{s}，但当对象从@samp{md}文件中读取的时候，该操作数的字符串值可以被忽略。被忽略的字符串被当作一个空字符串。

@item V
@samp{V}表示一个可选的向量。在内部的RTX对象中，@samp{V}等价于@samp{E}，但是当对象从@samp{md}文件中读取的时候，该操作数的向量值可以被忽略。被忽略的向量被当作一个没有元素的向量。 

@item B
@samp{B}表示一个指向基本块结构体的指针。

@item 0
@samp{0}表示一个插槽，其内容不使用任何常规的类别。@samp{0}插槽根本不在转储中打印，通常在编译器中用于特定的方式。
@end table

这些是获得操作数数目和表达式代码格式的宏：

@table @code
@findex GET_RTX_LENGTH
@item GET_RTX_LENGTH (@var{code})
代码为@var{code}的RTX的操作数个数。

@findex GET_RTX_FORMAT
@item GET_RTX_FORMAT (@var{code})
代码为@var{code}的RTX的格式，为C字符串。
@end table

一些RTX代码的类别总是具有相同的格式。例如，可以安全的假设所有的比较运算都具有格式@code{ee}。

@table @code
@item 1
所有该类别的代码都具有格式@code{e}。

@item <
@itemx c
@itemx 2
所有这些类别的代码都具有格式@code{ee}。

@item b
@itemx 3
所有这些类别的代码都具有格式@code{eee}。

@item i
所有该类别的代码具有的格式都起始于@code{iuueiee}。@zhxref{Insns}。注意，并不是所有被链接到insn链表中的RTX对象都属于类别@code{i}。

@item o
@itemx m
@itemx x
你可以不去假设这些代码的格式。
@end table

@node 访问方式
@section 访问操作数
@cindex accessors
@cindex access to operands
@cindex operand access

@findex XEXP
@findex XINT
@findex XWINT
@findex XSTR
表达式的操作数用宏@code{XEXP}、@code{XINT}、@code{XWINT}和@code{XSTR}访问。
所有这些宏都有两个参数：一个为表达式指针（RTX），
另一个为操作数序号 ( 从0 开始计算 )。如：

@smallexample
XEXP (@var{x}, 2)
@end smallexample

@noindent
表示以表达式方式访问表达式@var{x}的第2个操作数。

@smallexample
XINT (@var{x}, 2)
@end smallexample

@noindent
表示以整数方式访问@code{x}的第2个操作数。
@code{XSTR}表示以字符串方式访问。

任何一个操作数都能以整数方式、表达式方式或字符串方式来访问，
但必须根据存贮在操作数中的实际值选择正确的访问方式。
这可根据表达式的代码而获得，同样也可表达式代码获得操作数的个数。

例如：若@var{x}是@code{subreg}表达式，通过表达式代码可知它有二个操作数，
这两个操作数的访问应该是@code{XEXP (@var{x}, 0)} 和@code{XINT (@var{x}, 1)}，
若写成@code{XINT (@var{x}, 0)}，那么，你得到的表达式地址将被强制成整数，
偶尔可能会需要这样做，但在这种情况下用@code{(int) XEXP (@var{x}, 0)}表示要更好。
同样写成@code{XEXP (@var{x}, 1)} 也不会导致编译错误，
它将返回强制为表达式指针而实际为整数的1号操作数，在运行中访问该指针时，
这可能会导致出错。同样，你也可以写成@code{XEXP (@var{x}, 28)}，
但这超出了此表达式的存贮边界，所得到的将是一个预料不到的结果。

对向量操作数的访问较为复杂些，可用@code{XVEC}宏来获取向量指针本身，
@code{XVECEXP}和@code{XVECLEN}宏访问一个向量的元素和长度。

@table @code
@findex XVEC
@item XVEC (@var{exp}, @var{idx})
获得@var{exp}中第@var{idx}个操作数的向量指针。

@findex XVECLEN
@item XVECLEN (@var{exp}, @var{idx})
获得@var{exp}中第@var{idx}个操作数（为向量操作数）的向量长度（元素个数），
其值是@code{int}。

@findex XVECEXP
@item XVECEXP (@var{exp}, @var{idx}, @var{eltnum})
访问@var{exp}中第@var{idx}个操作数（为向量操作数）的第@var{eltnum}个元素，
其值是一个RTX。

需要由你来确保@var{eltnum}不为负，并且小于@code{XVECLEN (@var{exp}, @var{idx})}。
@end table

在本节中所定义的所有宏定义都被扩展成左值，
因而也可用于对操作数、长度和向量元素赋值。

@node 访问特殊操作数
@section 访问特殊操作数
@cindex access to special operands

一些RTL节点具有与它们相关联的特殊的注解。

@table @code
@item MEM
@table @code
@findex MEM_ALIAS_SET
@item MEM_ALIAS_SET (@var{x})
如果为0，则@var{x}不在任何别名集中，并可能为任何对象的别名。否则，@var{x}只能为在冲突别名集中的@code{MEM}的别名。该值在前端使用语言相关的方式来设置，并且不能在后端修改。在一些前端中，这些可以通过某种方式对应到类型，或者其它语言级的实体，但是不要求非要这样，所以在后端不要做这样的假设。这些集合编号使用@code{alias_sets_conflict_p}来测试。

@findex MEM_EXPR
@item MEM_EXPR (@var{x})
如果该寄存器被已知为存放了一些用户级的声明的值，则为那个tree节点。其也可以为@code{COMPONENT_REF}，这种情况下，其为某个域的引用，并且@code{TREE_OPERAND (@var{x}, 0)}包含了声明，或者另一个@code{COMPONENT_REF}，或者如果没有编译时对象相关引用，则为空。

@findex MEM_OFFSET
@item MEM_OFFSET (@var{x})
从@code{MEM_EXPR}起始的偏移量，为一个@code{CONST_INT} rtx。

@findex MEM_SIZE
@item MEM_SIZE (@var{x})
以字节为单位的内存引用长度，为一个@code{CONST_INT} rtx。这主要与@code{BLKmode}引用相关，否则机器模式已经隐含了长度。

@findex MEM_ALIGN
@item MEM_ALIGN (@var{x})
内存引用的已知的对齐方式，以位为单位。
@end table

@item REG
@table @code
@findex ORIGINAL_REGNO
@item ORIGINAL_REGNO (@var{x})
该域存放了寄存器原先具有的编号；对于伪寄存器放入到一个硬寄存器中，其将存放旧的伪寄存器编号。

@findex REG_EXPR
@item REG_EXPR (@var{x})
如果该寄存器被已知存放了某个用户级的声明的值，则其为那个tree节点。

@findex REG_OFFSET
@item REG_OFFSET (@var{x})
如果该寄存器被已知存放了某个用户级的声明的值，则其为相对那个逻辑存储的便宜量。

@end table

@item SYMBOL_REF
@table @code
@findex SYMBOL_REF_DECL
@item SYMBOL_REF_DECL (@var{x})
如果是针对@code{VAR_DECL}或@code{FUNCTION_DECL}创建的@code{symbol_ref} @var{x}，则那个tree被记录在这里。如果该值为空，则@var{x}由后端代码生成例程创建，并不与前端的符号表实体相关联。

@code{SYMBOL_REF_DECL}也可以指向@code{'c'}类别的tree，即某种常量。这种情况下，@code{symbol_ref}为每个文件的常量池中的实体；同样，不与前端的符号表实体相关联。

@findex SYMBOL_REF_CONSTANT
@item SYMBOL_REF_CONSTANT (@var{x})
如果@samp{CONSTANT_POOL_ADDRESS_P (@var{x})}为真，则为@var{x}的常量池实体。否则为空。

@findex SYMBOL_REF_DATA
@item SYMBOL_REF_DATA (@var{x})
一个不透明类型的域，用来存储@code{SYMBOL_REF_DECL}或@code{SYMBOL_REF_CONSTANT}。

@findex SYMBOL_REF_FLAGS
@item SYMBOL_REF_FLAGS (@var{x})
在一个@code{symbol_ref}中，其用于传达关于符号的各种断言。它们中的一些可以使用通用的代码来计算，一些是特定于目标机器的。通用的位：

@table @code
@findex SYMBOL_REF_FUNCTION_P
@findex SYMBOL_FLAG_FUNCTION
@item SYMBOL_FLAG_FUNCTION
用来表示符号引用一个函数。

@findex SYMBOL_REF_LOCAL_P
@findex SYMBOL_FLAG_LOCAL
@item SYMBOL_FLAG_LOCAL
用来表示符号局部于该模块。参见@code{TARGET_BINDS_LOCAL_P}。

@findex SYMBOL_REF_EXTERNAL_P
@findex SYMBOL_FLAG_EXTERNAL
@item SYMBOL_FLAG_EXTERNAL
用来表示该符号不在该转换单元中定义。注意，其并不是@code{SYMBOL_FLAG_LOCAL}的反转。

@findex SYMBOL_REF_SMALL_P
@findex SYMBOL_FLAG_SMALL
@item SYMBOL_FLAG_SMALL
用来表示符号位于小数据段。参见@code{TARGET_IN_SMALL_DATA_P}。

@findex SYMBOL_FLAG_TLS_SHIFT
@findex SYMBOL_REF_TLS_MODEL
@item SYMBOL_REF_TLS_MODEL (@var{x})
这是多个位的域访问，其返回用于线程局部存储符号的@code{tls_model}。对于非线程局部符号，其返回0。

@findex SYMBOL_REF_HAS_BLOCK_INFO_P
@findex SYMBOL_FLAG_HAS_BLOCK_INFO
@item SYMBOL_FLAG_HAS_BLOCK_INFO
用来表示符号具有@code{SYMBOL_REF_BLOCK}和@code{SYMBOL_REF_BLOCK_OFFSET}域。

@findex SYMBOL_REF_ANCHOR_P
@findex SYMBOL_FLAG_ANCHOR
@cindex @option{-fsection-anchors}
@item SYMBOL_FLAG_ANCHOR
用来表示符号作为section anchor。``Section anchors''为在@code{object_block}中具有一个已知位置的符号，并且可以用来访问该块中的附近成员。它们用来实现@option{-fsection-anchors}。

如果该标记被设置，则@code{SYMBOL_FLAG_HAS_BLOCK_INFO}也被设置。

@end table

起始于@code{SYMBOL_FLAG_MACH_DEP}的位，可供目标机器使用。
@end table

@findex SYMBOL_REF_BLOCK
@item SYMBOL_REF_BLOCK (@var{x})
如果@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}，则其为该符号所属的@samp{object_block}结构体， 或者如果其没有被分配给一个块，则为@code{NULL}。

@findex SYMBOL_REF_BLOCK_OFFSET
@item SYMBOL_REF_BLOCK_OFFSET (@var{x})
如果@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}，则其为@var{x}的偏移量，从@samp{SYMBOL_REF_BLOCK (@var{x})}中的第一个对象开始。如果@var{x}还没有被分配给一个块，或者其还没有在那个块中给定一个偏移量，则值为负数。

@end table

@node 标记
@section RTL表达式中的标记
@cindex flags in RTL expression

RTL表达式包含几个标记（位域），用于特定类型的表达式。通常它们使用下列的宏来访问，并被扩展为左值。

@table @code
@findex CONSTANT_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/u}
@cindex @code{unchanging}, in @code{symbol_ref}
@item CONSTANT_POOL_ADDRESS_P (@var{x})
位于@code{symbol_ref}中，如果其引用了当前函数的常量池中的一部分，则非零。对于大多数目标机器，这些地址在@code{.rodata}段中，与函数完全分离，但是对于有些目标机器，这些地址是靠近函数起始处。不管哪种情况，GCC都假设这些地址可以被直接寻址，或者通过基址寄存器。其被存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex RTL_CONST_CALL_P
@cindex @code{call_insn} and @samp{/u}
@cindex @code{unchanging}, in @code{call_insn}
@item RTL_CONST_CALL_P (@var{x})
位于@code{call_insn}中，表明该insn表示一个对const函数的调用。存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex RTL_PURE_CALL_P
@cindex @code{call_insn} and @samp{/i}
@cindex @code{return_val}, in @code{call_insn}
@item RTL_PURE_CALL_P (@var{x})
位于@code{call_insn}中，表明该insn表示一个对pure函数的调用。存储在@code{return_val}域，打印输出为@samp{/i}。

@findex RTL_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/u} or @samp{/i}
@item RTL_CONST_OR_PURE_CALL_P (@var{x})
位于@code{call_insn}中，如果@code{RTL_CONST_CALL_P}或者@code{RTL_PURE_CALL_P}为真，则其为真。

@findex RTL_LOOPING_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/c}
@cindex @code{call}, in @code{call_insn}
@item RTL_LOOPING_CONST_OR_PURE_CALL_P (@var{x})
位于@code{call_insn}中，表明该insn表示一个对const或者pure函数，可能是无限循环的调用。存储在@code{call}域，打印输出为@samp{/c}。只有当@code{RTL_CONST_CALL_P}或者@code{RTL_PURE_CALL_P}为真时，其才为真。

@findex INSN_ANNULLED_BRANCH_P
@cindex @code{jump_insn} and @samp{/u}
@cindex @code{call_insn} and @samp{/u}
@cindex @code{insn} and @samp{/u}
@cindex @code{unchanging}, in @code{jump_insn}, @code{call_insn} and @code{insn}
@item INSN_ANNULLED_BRANCH_P (@var{x})
位于@code{jump_insn}，@code{call_insn}或者@code{insn}中，表明该分支跳转被取消。参见下面关于@code{sequence}的讨论。存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex INSN_DELETED_P
@cindex @code{insn} and @samp{/v}
@cindex @code{call_insn} and @samp{/v}
@cindex @code{jump_insn} and @samp{/v}
@cindex @code{code_label} and @samp{/v}
@cindex @code{barrier} and @samp{/v}
@cindex @code{note} and @samp{/v}
@cindex @code{volatil}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{barrier}, and @code{note}
@item INSN_DELETED_P (@var{x})
位于@code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{barrier}或@code{note}中，如果该insn被删除掉，则非零。存储在@code{volatil}域，打印输出为@samp{/v}。

@findex INSN_FROM_TARGET_P
@cindex @code{insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn} and @code{jump_insn} and @code{call_insn}
@item INSN_FROM_TARGET_P (@var{x})
位于@code{insn}，@code{jump_insn}或者@code{call_insn}中，在分支延迟槽中，表明该insn是来自分支跳转的目标。如果分支insn设置了@code{INSN_ANNULLED_BRANCH_P}，则该insn只有当进行分支跳转的时候，才被执行。对于被取消的分支，如果是清除了@code{INSN_FROM_TARGET_P}，则insn只有当没有进行分支跳转的时候，才被执行。当@code{INSN_ANNULLED_BRANCH_P}没有被设置，该insn将总是被执行。存储在@code{in_struct}域，打印输出为@samp{/s}。

@findex LABEL_PRESERVE_P
@cindex @code{code_label} and @samp{/i}
@cindex @code{note} and @samp{/i}
@cindex @code{in_struct}, in @code{code_label} and @code{note}
@item LABEL_PRESERVE_P (@var{x})
位于@code{code_label}或者@code{note}中，表明被代码或者数据引用的该标号，对于给定的函数RTL不可见。通过非局部goto引用的标号，将设置该位。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex LABEL_REF_NONLOCAL_P
@cindex @code{label_ref} and @samp{/v}
@cindex @code{reg_label} and @samp{/v}
@cindex @code{volatil}, in @code{label_ref} and @code{reg_label}
@item LABEL_REF_NONLOCAL_P (@var{x})
位于@code{label_ref}和@code{reg_label}表达式中，如果其为对一个非局部标号的引用，则非零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex MEM_IN_STRUCT_P
@cindex @code{mem} and @samp{/s}
@cindex @code{in_struct}, in @code{mem}
@item MEM_IN_STRUCT_P (@var{x})
位于@code{mem}表达式中，对于引用一整个结构体，联合体，数组，或者是它们的一部分，则非零。如果是引用一个标量变量，或者是标量指针，则为零。如果该标记和@code{MEM_SCALAR_P}都被清除，则我们无法知道该@code{mem}是否在一个结构体中。这两个标记不要被同时设置。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex MEM_KEEP_ALIAS_SET_P
@cindex @code{mem} and @samp{/j}
@cindex @code{jump}, in @code{mem}
@item MEM_KEEP_ALIAS_SET_P (@var{x})
位于@code{mem}表达式中，如果为1，则表明当访问一个部件时，应该保持该mem的别名集合不变。例如，当在一个聚合体的不可寻址部件中的时候，将其设为1。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex MEM_SCALAR_P
@cindex @code{mem} and @samp{/i}
@cindex @code{return_val}, in @code{mem}
@item MEM_SCALAR_P (@var{x})
位于@code{mem}表达式中，如果引用的标量，被已知不是结构体，联合体或者数组的成员，则为非零。如果是这样的引用，或者通过指针的间接引用，即便是指向标量类型，则为零，如果该标记和@code{MEM_IN_STRUCT_P}都被清除，则我们无法知道该@code{mem}是否为一个结构体。这两个标记不要被同时设置。存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex MEM_VOLATILE_P
@cindex @code{mem} and @samp{/v}
@cindex @code{asm_input} and @samp{/v}
@cindex @code{asm_operands} and @samp{/v}
@cindex @code{volatil}, in @code{mem}, @code{asm_operands}, and @code{asm_input}
@item MEM_VOLATILE_P (@var{x})
位于@code{mem}, @code{asm_operands}和@code{asm_input}表达式中，对于volatile内存引用，为非零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex MEM_NOTRAP_P
@cindex @code{mem} and @samp{/c}
@cindex @code{call}, in @code{mem}
@item MEM_NOTRAP_P (@var{x})
位于@code{mem}中，对于不会产生陷阱的内存引用，为非零。存储在@code{call}域中，打印输出为@samp{/c}。

@findex MEM_POINTER
@cindex @code{mem} and @samp{/f}
@cindex @code{frame_related}, in @code{mem}
@item MEM_POINTER (@var{x})
位于@code{mem}中，如果内存引用存放了一个指针，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex REG_FUNCTION_VALUE_P
@cindex @code{reg} and @samp{/i}
@cindex @code{return_val}, in @code{reg}
@item REG_FUNCTION_VALUE_P (@var{x})
位于@code{reg}中，如果其为存放函数返回值的地方，则非零。（这只发生在硬件寄存器中。）存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex REG_POINTER
@cindex @code{reg} and @samp{/f}
@cindex @code{frame_related}, in @code{reg}
@item REG_POINTER (@var{x})
位于@code{reg}中，如果寄存器存放一个指针，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex REG_USERVAR_P
@cindex @code{reg} and @samp{/v}
@cindex @code{volatil}, in @code{reg}
@item REG_USERVAR_P (@var{x})
位于@code{reg}中，如果其对应于用户源代码中出现的一个变量，则非零。对于编译器内部生成的临时对象，则为零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex RTX_FRAME_RELATED_P
@cindex @code{insn} and @samp{/f}
@cindex @code{call_insn} and @samp{/f}
@cindex @code{jump_insn} and @samp{/f}
@cindex @code{barrier} and @samp{/f}
@cindex @code{set} and @samp{/f}
@cindex @code{frame_related}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, and @code{set}
@item RTX_FRAME_RELATED_P (@var{x})
位于@code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, 或者@code{set}中，如果其为函数序言的一部分，用来设置栈指针，帧指针，或者保存寄存器，则为非零。对于设置用于帧指针的临时寄存器的指令，该标记也应被设置。存储在@code{frame_related}域中，打印输出为@samp{/f}。

特别的，在一些RISC目标机器上，对于立即数常量的大小有限制，有时不能直接通过栈指针来到达寄存器的保存区域。这种情况下，一个足够接近寄存器保存区域的临时寄存器被使用，并且正则帧地址（Canonical Frame Address）寄存器，即DWARF2的逻辑帧指针寄存器，必须（临时的）被改成该临时寄存器。所以，设置该临时寄存器的指令必须被标记为@code{RTX_FRAME_RELATED_P}。

如果被标记的指令过于复杂（跟据@code{dwarf2out_frame_debug_expr}能否处理，而定义的术语），则你还必须要创建一个@code{REG_FRAME_RELATED_EXPR}注解，并附加在该指令上。该注解应该包含一个该指令执行计算的简单表达式，即@code{dwarf2out_frame_debug_expr}可以处理的。

在带有RTL序言的目标机器上，提供异常处理的支持时，会用到该标记。

@findex MEM_READONLY_P
@cindex @code{mem} and @samp{/u}
@cindex @code{unchanging}, in @code{mem}
@item MEM_READONLY_P (@var{x})
位于@code{mem}中，如果内存是静态分配并且只读的，则非零。 

在该上下文中只读，意味着在程序的生命周期中不会被修改，但是不必要是在ROM或者不可写的页中。对于后者，一个常见的例子，是共享库的全局偏移表。该表由运行时加载器初始化，所以内存在技术上是可写的，但是当控制从运行时加载器转移给应用程序时，该内存将不再被修改。

存储在@code{unchanging}域中，打印输出为@samp{/u}。

@findex SCHED_GROUP_P
@cindex @code{insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn}, @code{jump_insn} and @code{call_insn}
@item SCHED_GROUP_P (@var{x})
在指令调度过程中，位于@code{insn}, @code{call_insn}或者@code{jump_insn}中，表明前一个insn必须与该insn一起调度。这用来确保特定的指令组不会被指令调度过程分隔开。例如，在@code{call_insn}之前的@code{use} insn不可以从@code{call_insn}中分开。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex SET_IS_RETURN_P
@cindex @code{insn} and @samp{/j}
@cindex @code{jump}, in @code{insn}
@item SET_IS_RETURN_P (@var{x})
对于@code{set}，如果是针对一个return，则非零。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex SIBLING_CALL_P
@cindex @code{call_insn} and @samp{/j}
@cindex @code{jump}, in @code{call_insn}
@item SIBLING_CALL_P (@var{x})
对于@code{call_insn}，如果该insn为一个sibling call，则非零。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex STRING_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/f}
@cindex @code{frame_related}, in @code{symbol_ref}
@item STRING_POOL_ADDRESS_P (@var{x})
对于一个@code{symbol_ref}表达式，如果其为对该函数的字符串常量池的寻址，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex SUBREG_PROMOTED_UNSIGNED_P
@cindex @code{subreg} and @samp{/u} and @samp{/v}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_P (@var{x})
如果@code{subreg}对于@code{SUBREG_PROMOTED_VAR_P}为非零，并且被引用的对象为零扩展，则返回一个大于零的值；如果保持为符号扩展，则为零；如果是通过@code{ptr_extend}指令，进行某种其它方式的扩展，则小于零。存储在@code{unchanging}域和@code{volatil}域中，打印输出为@samp{/u}和@samp{/v}。该宏只用于获得值，不能用于修改值。使用@code{SUBREG_PROMOTED_UNSIGNED_SET}来修改值。

@findex SUBREG_PROMOTED_UNSIGNED_SET
@cindex @code{subreg} and @samp{/u}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_SET (@var{x})
设置@code{subreg}中的@code{unchanging}和@code{volatil}域，来反映零扩展，符号扩展，或其它扩展。如果@code{volatil}为零，然后如果@code{unchanging}为非零，则意味着零扩展，如果为零，则意味着符号扩展。如果@code{volatil}为非零，则通过@code{ptr_extend}指令使用了其它某种扩展。

@findex SUBREG_PROMOTED_VAR_P
@cindex @code{subreg} and @samp{/s}
@cindex @code{in_struct}, in @code{subreg}
@item SUBREG_PROMOTED_VAR_P (@var{x})
位于@code{subreg}中，如果当访问一个被提升为符合机器描述宏@code{PROMOTED_MODE}的(@zhpxref{Storage Layout})，宽机器模式的对象时，则非零。这种情况下，@code{subreg}的机器模式为对象被声明的机器模式，@code{SUBREG_REG}的机器模式为存放该对象的寄存器的机器模式。被提升的变量，在每个赋值中，总是被符号扩展或者零扩展成宽机器模式。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex SYMBOL_REF_USED
@cindex @code{used}, in @code{symbol_ref}
@item SYMBOL_REF_USED (@var{x})
位于@code{symbol_ref}中，表明@var{x}已经被使用。这通常只用于确保@var{x}只在外部被声明一次。存储在@code{used}中。

@findex SYMBOL_REF_WEAK
@cindex @code{symbol_ref} and @samp{/i}
@cindex @code{return_val}, in @code{symbol_ref}
@item SYMBOL_REF_WEAK (@var{x})
位于@code{symbol_ref}中，表明@var{x}已经被声明为weak。存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex SYMBOL_REF_FLAG
@cindex @code{symbol_ref} and @samp{/v}
@cindex @code{volatil}, in @code{symbol_ref}
@item SYMBOL_REF_FLAG (@var{x})
位于@code{symbol_ref}中，用于机器特定目的的标记。存储在@code{volatil}域中，打印输出为@samp{/v}。

大多对@code{SYMBOL_REF_FLAG}的使用，是历史性的，并且可以通过@code{SYMBOL_REF_FLAGS}来归类。当然，如果目标机器需要多于一个位的存储时，对@code{SYMBOL_REF_FLAGS}的使用是强制的。

@end table

这些是上面的宏所引用的域：

@table @code
@findex call
@cindex @samp{/c} in RTL dump
@item call
在@code{mem}中，1表示该内存引用不会有陷阱。

在@code{call}中，1表示该pure或者const调用，可能为无限循环。

在RTL转储中，该标记被表示为@samp{/c}。

@findex frame_related
@cindex @samp{/f} in RTL dump
@item frame_related
在@code{insn}或者@code{set}表达式中，1表示其为函数序言的一部分，设置栈寄存器，设置帧寄存器，保存寄存器，或者设置一个用于帧寄存器的临时寄存器。

在@code{reg}表达式中，1表示该寄存器存放一个指针。

在@code{mem}表达式中，1表示该内存引用存放一个指针。

在@code{symbol_ref}表达式中，1表示该引用是对函数的字符串常量池的寻址。

在RTL转储中，该标记被表示为@samp{/f}。

@findex in_struct
@cindex @samp{/s} in RTL dump
@item in_struct
在@code{mem}表达式中，如果所引用的内存数据为整个结构体或者数组，或者一部分，其为1；如果为（或者可能为）一个标量变量。则为0。通过C指针的引用，为0，因为指针可以指向一个标量变量。该信息允许编译器来确定别名的可能情况。

在@code{reg}表达式中，如果寄存器整个生命期都包含在某个循环的测试表达式中，则为1。

在@code{subreg}表达式中，1表示@code{subreg}在访问一个从更宽的机器模式进行提升的对象。

在@code{label_ref}表达式中，1表示被引用的标号位于包含发现@code{label_ref}的insn的最内层循环的外面。

在@code{code_label}表达式中，如果标号不能被删除，则为1。这用于其为非局部goto的目标的标号。对于已经被删除的这样的标号，使用类型为@code{NOTE_INSN_DELETED_LABEL}的@code{note}来替换。

在@code{insn}中，在死代码消除阶段，1表示该insn为死代码。

在@code{insn}或者@code{jump_insn}中，在针对分支延迟槽中insn的reorg阶段，1表示该insn来自分支跳转的目标。

在@code{insn}中，在指令调度阶段，1表示该insn必须与之前的insn一起进行调度。

在RTL转储中，该标记被表示为@samp{/s}。

@findex return_val
@cindex @samp{/i} in RTL dump
@item return_val
在@code{reg}表达式中，1表示寄存器包含了当且函数的返回值。对于在寄存器中传递参数的机器上，同一个寄存器编号也可以被用作参数，但是这种情况下，该标记不被设置。

在@code{mem}中，1表示内存引用为一个已知不为结构体，联合体，数组的成员的标量。

在@code{symbol_ref}表达式中，1表示被引用的符号为weak。

在@code{call}表达式中，1表示调用是pure。

在RTL转储中，该标记被表示为@samp{/i}。

@findex jump
@cindex @samp{/j} in RTL dump
@item jump
在@code{mem}表达式中，1表示当访问一个部件时，应该保持该mem的别名集不变。

在@code{set}中，1表示其为一个return。

在@code{call_insn}中，1表示其为一个sibling call。

在RTL转储中，该标记被表示为@samp{/j}。

@findex unchanging
@cindex @samp{/u} in RTL dump
@item unchanging
在@code{reg}和@code{mem}表达式中，1表示表达式的值不会改变。

在@code{subreg}表达式中，如果@code{subreg}引用了机器模式已经被提升为一个宽模式的无符号对象，则为1。 references an

在分支指令延迟槽中的@code{insn}或@code{jump_insn}中，1表示将使用一个被取消的分支。

在@code{symbol_ref}表达式中，1表示该符号对函数的常量池进行寻址。

在@code{call_insn}中，1表示该指令为对const函数的调用。

在RTL转储中，该标记被表示为@samp{/u}。

@findex used
@item used
该标记在函数的RTL生成阶段的结尾被直接使用（不通过访问宏），来计数表达式在insns中出现的次数。出现次数大于一的表达式，根据共享结构的规则（@zhpxref{Sharing}），被复制。

对于@code{reg}，其被叶子寄存器重编号代码直接使用（不通过访问宏），来确保每个寄存器只被重编号一次。

在@code{symbol_ref}中，其表示该符号的外部声明已经被书写了。

@findex volatil
@cindex @samp{/v} in RTL dump
@item volatil
@cindex volatile memory references
在@code{mem}, @code{asm_operands}或者@code{asm_input}表达式中，如果内存引用是volatile的，则为1。volatile的内存引用不可以被删除，重排或者合并。

在@code{symbol_ref}表达式中，其用于机器特定的目的。

在@code{reg}表达式中，如果值为用户级的变量，则为1。0表示为内部的编译器临时对象。

在@code{insn}中，1表示该insn已经被删除。

在@code{label_ref}和@code{reg_label}表达式中，1表示对非局部标号的引用。

在RTL转储中，该标记被表示为@samp{/v}。
@end table

@node 机器模式
@section 机器模式
@cindex machine modes

@findex enum machine_mode
机器模式描述数据对象的大小及其表示。在C 代码中，机器模式表示成枚举类型@code{enum machine_mode}。此类型定义在@file{machmode.def}中。每个RTL表达式都有机器模式域。一些树结构如变量定义、类型等也有机器模式域。

在调试信息及机器描述中，RTL表达式的机器模式紧跟在RTL 代码之后，其间用冒号隔开。每一种机器模式名未尾的字母省缺为@samp{mode}。例如：@code{(reg:SI 38)}是一个@code{reg}表达式，其机器模式为@code{SImode}。如果方式为@code{VOIDmode}，表达式中完全不出现此模式。

以下是一个机器模式表，这里的“字节”是指具有@code{BITS_PER_UNIT}个存储位的对象
（@zhpxref{Storage Layout}）。

@table @code
@findex BImode
@item BImode
“Bit”模式，表示一位，用于断言寄存器。

@findex QImode
@item QImode
“Quarter-Integer”模式，表示一个一字节的整数。

@findex HImode
@item HImode
“Half-Integer”模式，表示一个两字节的整数。

@findex PSImode
@item PSImode
“Partial Single Integer”模式，表示一个占有四个字节但并不真正使用全部四个字节的整数。

@findex SImode
@item SImode
“Single Integer”模式，表示一个四字节的整数。

@findex PDImode
@item PDImode
“Partial Double Integer”模式，表示一个占有八个字节但并不真正使用全部八个字节的整数。

@findex DImode
@item DImode
“Double Integer”模式，表示一个8 字节的整数。

@findex TImode
@item TImode
“Tetra Integer”模式，表示一个16 字节的整数。

@findex OImode
@item OImode
“Octa Integer” 模式，表示一个32 字节的整数。

@findex QFmode
@item QFmode
“Quarter-Floating” 模式，表示一个四分之一精度（单字节）浮点数。

@findex HFmode
@item HFmode
“Half-Floating” 模式，表示一个二分之一精度（双字节）浮点数。

@findex TQFmode
@item TQFmode
“Three-Quarter-Floating” 模式，表示一个四分之三精度（单字节）浮点数。

@findex SFmode
@item SFmode
“Single Floating”模式，表示一个单精度（4 个字节）浮点数。

@findex DFmode
@item DFmode
“Double Floating”模式，表示一个双精度（8 字节）浮点数。


@findex XFmode
@item XFmode
“Extended Floating”模式，表示一个三精度（12 字节）浮点数。本方式用来表示 IEEE 扩展浮点类型。

@findex SDmode
@item SDmode
``Single Decimal Floating''模式，表示一个四字节十进制浮点数（区别于常规的二进制浮点）。

@findex DDmode
@item DDmode
``Double Decimal Floating''模式，表示一个八字节十进制浮点数。

@findex TDmode
@item TDmode
``Tetra Decimal Floating''模式，表示一个十六字节十进制浮点数，所有128位都有含义。

@findex TFmode
@item TFmode
“Tetra Floating”模式，表示一个四精度（16 字节）浮点数。

@findex QQmode
@item QQmode
``Quarter-Fractional''模式，表示一个单字节的有符号小数。缺省格式为``s.7''。

@findex HQmode
@item HQmode
``Half-Fractional''模式，表示一个双字节的有符号小数。缺省格式为``s.15''。

@findex SQmode
@item SQmode
``Single Fractional''模式，表示一个四字节的有符号小数。缺省格式为``s.31''。

@findex DQmode
@item DQmode
``Double Fractional''模式，表示一个八字节的有符号小数。缺省格式为``s.63''。

@findex TQmode
@item TQmode
``Tetra Fractional''模式，表示一个十六字节有符号小数。缺省格式为``s.127''。

@findex UQQmode
@item UQQmode
``Unsigned Quarter-Fractional''模式，表示一个单字节的无符号小数。缺省格式为``.8''。

@findex UHQmode
@item UHQmode
``Unsigned Half-Fractional''模式，表示一个双字节的无符号小数。缺省格式为``.16''。

@findex USQmode
@item USQmode
``Unsigned Single Fractional''模式，表示一个四字节的无符号小数。缺省格式为``.32''。

@findex UDQmode
@item UDQmode
``Unsigned Double Fractional''模式，表示一个八字节的无符号小数。缺省格式为``.64''。

@findex UTQmode
@item UTQmode
``Unsigned Tetra Fractional''模式，表示一个十六字节的无符号小数。缺省格式为``.128''。

@findex HAmode
@item HAmode
``Half-Accumulator''模式，表示一个双字节的有符号累加器。缺省格式为``s8.7''。

@findex SAmode
@item SAmode
``Single Accumulator''模式，表示一个四字节的有符号累加器。缺省格式为``s16.15''。

@findex DAmode
@item DAmode
``Double Accumulator''模式，表示一个八字节的有符号累加器。缺省格式为``s32.31''。

@findex TAmode
@item TAmode
``Tetra Accumulator''模式，表示一个十六字节的有符号累加器。缺省格式为``s64.63''。

@findex UHAmode
@item UHAmode
``Unsigned Half-Accumulator''模式，表示一个双字节的无符号累加器。缺省格式为``8.8''。

@findex USAmode
@item USAmode
``Unsigned Single Accumulator''模式，表示一个四字节的无符号累加器。缺省格式为``16.16''。

@findex UDAmode
@item UDAmode
``Unsigned Double Accumulator''模式，表示一个八字节的无符号累加器。缺省格式为``32.32''。

@findex UTAmode
@item UTAmode
``Unsigned Tetra Accumulator''模式，表示一个十六字节的无符号累加器。缺省格式为``64.64''。

@findex CCmode
@item CCmode
“condition code”模式，表示条件代码的值。其中条件代码是一组与机器相关的位集合，用来表示比较的结果。在使用了 cc0 的机器上，不用CCmode。

@findex BLKmode
@item BLKmode
“Block”模式，表示其它模式都不适用的聚合值。在 RTL 中，只有内存引用才能有此方式，并且仅当出现在字符串移动指令或向量指令中时，才能有此方式。若机器没有上述指令，则@code{BLKmode}将不出现在 RTL中。

@findex VOIDmode
@item VOIDmode
意味着模式不出现或一个不确定的模式。例 如：@code{const_int}表达式的模式就是@code{VOIDmode}， 因为此类表达式可认为具有其上下文所要求的任何模式。在RTL的调试输出中，@code{VOIDmode}表示成没有任何模式出现。

@findex QCmode
@findex HCmode
@findex SCmode
@findex DCmode
@findex XCmode
@findex TCmode
@item QCmode, HCmode, SCmode, DCmode, XCmode, TCmode
这些方式模式由一对浮点数组成的复数。其中， 浮点数分别具有@code{QFmode}、@code{HFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}。

@findex CQImode
@findex CHImode
@findex CSImode
@findex CDImode
@findex CTImode
@findex COImode
@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
这些模式代表由一对整数组成的复数。整数值分别具有方式@code{QImode}, @code{HImode},@code{SImode}, @code{DImode}, @code{TImode}和@code{OImode}。

@end table

机器描述定义@code{Pmode}为一个C宏，其扩展为用于寻址的机器模式。通常这是一个在32位机器上，大小为@code{BITS_PER_WORD}, @code{SImode}模式。

机器描述唯一必须要支持的机器模式为@code{QImode}，以及对应于@code{BITS_PER_WORD}，@code{FLOAT_TYPE_SIZE}和@code{DOUBLE_TYPE_SIZE}的机器模式。编译器将尝试使用@code{DImode}，表示8字节的结构体和联合体，不过这可以通过重写@code{MAX_FIXED_MODE_SIZE}的定义来阻止。替换的，你可以让编译器使用@code{TImode}表示16字节的结构体和联合体。同样，你可以使得C类型@code{short int}避免使用@code{HImode}。

@cindex mode classes
编译器中，有很少的对机器模式显式的引用，并且这些引用将不久被移除掉。替代的，机器模式被分成机器模式类别。这些由定义在@file{machmode.h}中的枚举类型@code{enum mode_class}来表示。可能的机器类别有：

@table @code
@findex MODE_INT
@item MODE_INT
整数模式。缺省情况下，它们是@code{BImode}, @code{QImode}, @code{HImode}, @code{SImode}, @code{DImode}, @code{TImode}和@code{OImode}。

@findex MODE_PARTIAL_INT
@item MODE_PARTIAL_INT
部分整数模式，@code{PQImode}, @code{PHImode}, @code{PSImode}和@code{PDImode}。

@findex MODE_FLOAT
@item MODE_FLOAT
浮点模式。缺省情况下，这些是@code{QFmode}, @code{HFmode}, @code{TQFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}。

@findex MODE_DECIMAL_FLOAT
@item MODE_DECIMAL_FLOAT
十进制浮点模式。缺省的，这些是@code{SDmode}, @code{DDmode}和@code{TDmode}。

@findex MODE_FRACT
@item MODE_FRACT
有符号小数模式。缺省的，这些是@code{QQmode}, @code{HQmode}, @code{SQmode}, @code{DQmode}和@code{TQmode}。

@findex MODE_UFRACT
@item MODE_UFRACT
无符号小数模式。缺省的，这些是@code{UQQmode}, @code{UHQmode}, @code{USQmode}, @code{UDQmode}和@code{UTQmode}。

@findex MODE_ACCUM
@item MODE_ACCUM
有符号累加器模式。缺省的，这些@code{HAmode}, @code{SAmode}, @code{DAmode}和@code{TAmode}。

@findex MODE_UACCUM
@item MODE_UACCUM
无符号累加器模式。缺省的，这些是@code{UHAmode}, @code{USAmode}, @code{UDAmode}和@code{UTAmode}。

@findex MODE_COMPLEX_INT
@item MODE_COMPLEX_INT
复数整数模式。（当前还没有被实现。）

@findex MODE_COMPLEX_FLOAT
@item MODE_COMPLEX_FLOAT
复数浮点模式。缺省情况下，为@code{QCmode}, @code{HCmode}, @code{SCmode}, @code{DCmode}, @code{XCmode}和@code{TCmode}。

@findex MODE_FUNCTION
@item MODE_FUNCTION
Algol或者Pascal函数变量，包括一个静态链。（这些目前还没有被实现。）

@findex MODE_CC
@item MODE_CC
表示条件码的值的模式。为@code{CCmode}加上在@file{@var{machine}-modes.def}中列出的任何@code{CC_MODE}模式。@zhxref{Jump Patterns}, 同时参见@ref{Condition Code}。

@findex MODE_RANDOM
@item MODE_RANDOM
这是所有不适合上面的类别的模式。目前@code{VOIDmode}和@code{BLKmode}包括在@code{MODE_RANDOM}中。

@end table

这些是与机器模式相关的C宏：

@table @code
@findex GET_MODE
@item GET_MODE (@var{x})
返回RTX @var{x}的机器模式。

@findex PUT_MODE
@item PUT_MODE (@var{x}, @var{newmode})
将RTX @var{x}的机器模式修改为@var{newmode}。

@findex NUM_MACHINE_MODES
@item NUM_MACHINE_MODES
表示目标机器上可用的机器模式的个数。比最大的机器模式数值大1。

@findex GET_MODE_NAME
@item GET_MODE_NAME (@var{m})
返回机器模式@var{m}的字符串名字。

@findex GET_MODE_CLASS
@item GET_MODE_CLASS (@var{m})
返回机器模式@var{m}的类别。

@findex GET_MODE_WIDER_MODE
@item GET_MODE_WIDER_MODE (@var{m})
返回下一个宽的自然的机器模式。例如，表达式@code{GET_MODE_WIDER_MODE (QImode)}返回@code{HImode}。

@findex GET_MODE_SIZE
@item GET_MODE_SIZE (@var{m})
返回机器模式@var{m}的字节数。

@findex GET_MODE_BITSIZE
@item GET_MODE_BITSIZE (@var{m})
返回机器模式@var{m}位数。

@findex GET_MODE_IBIT
@item GET_MODE_IBIT (@var{m})
返回定点机器模式@var{m}的整数位数。

@findex GET_MODE_FBIT
@item GET_MODE_FBIT (@var{m})
返回定点机器模式@var{m}的小数位数。

@findex GET_MODE_MASK
@item GET_MODE_MASK (@var{m})
返回一个位掩码。该宏只能用于位长度小于或等于@code{HOST_BITS_PER_INT}的机器模式。

@findex GET_MODE_ALIGNMENT
@item GET_MODE_ALIGNMENT (@var{m})
对于模式为@var{m}的对象，返回所要求的对齐方式，以位数为单位。

@findex GET_MODE_UNIT_SIZE
@item GET_MODE_UNIT_SIZE (@var{m})
返回模式为@var{m}的数据的子单元大小，以字节为单位。这与@code{GET_MODE_SIZE}相同，除了复数模式。对于它们，单元大小为实部或者虚部的大小。

@findex GET_MODE_NUNITS
@item GET_MODE_NUNITS (@var{m})
返回在一个模式中包含的单元数目，即@code{GET_MODE_UNIT_SIZE}除以@code{GET_MODE_SIZE}。

@findex GET_CLASS_NARROWEST_MODE
@item GET_CLASS_NARROWEST_MODE (@var{c})
返回机器模式类别@var{c}中的最窄的模式。
@end table

@findex byte_mode
@findex word_mode
全局变量@code{byte_mode}和@code{word_mode}包含了类别为@code{MODE_INT}，并且位大小分别是@code{BITS_PER_UNIT}或@code{BITS_PER_WORD}的机器模式。在32位机器上，这些分别是@code{QImode}和@code{SImode}。

@node 常数
@section 常量表达式类型
@cindex RTL constants
@cindex RTL constant expression types

最简单的RTL表达式是那些对常数值的表示。

@table @code
@findex const_int
@item (const_int @var{i})
这类表达式表示整数值@var{i}。@var{i}通常通过宏@code{INTVAL}来访问，@code{INTVAL (@var{exp})}相当于@code{XWINT (@var{exp}, 0)}， 
为模式所生成的常量如果位数小于@code{HOST_WIDE_INT}，则必须符号扩展为全部宽度（例如，@code{gen_int_mode}）。

@findex const0_rtx
@findex const1_rtx
@findex const2_rtx
@findex constm1_rtx
只有一个表达式对象表示整数值0；是变量@code{const0_rtx}的值。同样的，整数值1的唯一表达式为@code{const1_rtx}，整数值2的唯一表达式为@code{const2_rtx}，负1的唯一表达式为@code{constm1_rtx}。任何试图去创建值为0，1，2或者-1的@code{const_int}都会返回相应的@code{const0_rtx}, @code{const1_rtx}, @code{const2_rtx}或者@code{constm1_rtx}。

@findex const_true_rtx
类似的，只有一个对象表示值为@code{STORE_FLAG_VALUE}的整数，其为@code{const_true_rtx}。如果@code{STORE_FLAG_VALUE}为1，则@code{const_true_rtx}和@code{const1_rtx}将会指向同一对象。如果@code{STORE_FLAG_VALUE}为-1，@code{const_true_rtx}和@code{constm1_rtx}将会指向同一对象。

@findex const_double
@item (const_double:@var{m} @var{i0} @var{i1} @dots{})
表示或者为一个模式为@var{m}的浮点常量，或者为一个超过@code{HOST_BITS_PER_WIDE_INT}位的，但是小于其两倍的位数的整数常量（GCC并没有提供表示更大的常量的机制）。对于后者，@var{m}将为@code{VOIDmode}。 

@findex CONST_DOUBLE_LOW
如果@var{m}为@code{VOIDmode}，则值的位数存储在@var{i0}和@var{i1}中。@var{i0}使用宏@code{CONST_DOUBLE_LOW}来访问，@var{i1}使用@code{CONST_DOUBLE_HIGH}。

如果常量为浮点（不管是什么精度），则用于存储值得整数数目取决于@code{REAL_VALUE_TYPE}的大小（@zhpxref{Floating
Point}）。整数表示一个浮点数，但是不如target机器的或者host机器的浮点格式那么精确。要将它们转换为target机器使用的精确的位模式，使用宏@code{REAL_VALUE_TO_TARGET_DOUBLE}等（@zhpxref{Data Output}）。

@findex const_fixed
@item (const_fixed:@var{m} @dots{})
表示一个机器模式为@var{m}定点常量。操作数是一个类型为@code{struct fixed_value}数据结构，并使用宏@code{CONST_FIXED_VALUE}来访问。数据的高部分使用@code{CONST_FIXED_VALUE_HIGH}来访问；低部分使用@code{CONST_FIXED_VALUE_LOW}来访问。

@findex const_vector
@item (const_vector:@var{m} [@var{x0} @var{x1} @dots{}])
表示一个向量常量。方括号代表向量包含的常量元素。@var{x0}，@var{x1}等等为@code{const_int}，@code{const_double}或者@code{const_fixed}元素。

在@code{const_vector}中的单元数可以通过宏@code{CONST_VECTOR_NUNITS}来获得，形如@code{CONST_VECTOR_NUNITS (@var{v})}。

在向量常量中的单个元素使用宏@code{CONST_VECTOR_ELT}来访问，形如@code{CONST_VECTOR_ELT (@var{v}, @var{n})}，其中@var{v}为向量常量，@var{n}为要访问的元素编号。

@findex const_string
@item (const_string @var{str})
表示一个具有值@var{str}的常量字符串。目前这只用于insn属性（@zhpxref{Insn Attributes}），因为C中的常量字符串存放在内存中。

@findex symbol_ref
@item (symbol_ref:@var{mode} @var{symbol})
表示引用数据的汇编标号的值。@var{symbol}为一个字符串，描述了汇编标号的名字。如果其起始于@samp{*}，则标号为@var{symbol}不包含@samp{*}的其余部分。否则，标号为@var{symbol}，通常具有前缀@samp{_}。

@code{symbol_ref}包含一个机器模式，其通常为@code{Pmode}。通常这是唯一的使得符号有效的机器模式。

@findex label_ref
@item (label_ref:@var{mode} @var{label})
表示引用代码的汇编标号的值。其包含一个操作数，一个表达式，其必须为一个@code{code_label}或者一个@code{NOTE_INSN_DELETED_LABEL}类型的@code{note}，其出现在指令序列中，来标识标号应该处于的位置。

对于代码标号引用，使用一个不同的表达式类型的原因是跳转优化可以区分它们。

@code{label_ref}包含了一个机器模式，其通常为@code{Pmode}。通常这是唯一的使得标号有效的机器模式。

@findex const
@item (const:@var{m} @var{exp})
表示一个常量，其为汇编时算术计算的结果。操作数@var{exp}，为一个表达式，只包含了@code{plus}和@code{minus}组合的常量（@code{const_int}, @code{symbol_ref} 和 @code{label_ref}表达式）。然而，并不是所有的组合都是有效的，因为汇编器不能对重定位符号做任意的算术运算。

@var{m}应该为@code{Pmode}。

@findex high
@item (high:@var{m} @var{exp})
表示@var{exp}的高位，通常为一个@code{symbol_ref}。位数是机器相关的并且通常为初始化一个寄存器的高位的指令所指定的位数。其和@code{lo_sum}一起使用来表示典型的用于RISC机器的双指令序列来引用一个全局内存位置。

@var{m}应该为@code{Pmode}。

@end table

@findex CONST0_RTX
@findex CONST1_RTX
@findex CONST2_RTX
宏@code{CONST0_RTX (@var{mode})}指定一个具有值0，机器模式为@var{mode}的表达式。如果@var{mode}为@code{MODE_INT}类别，则返回@code{const0_rtx}。如果@var{mode}为 @code{MODE_FLOAT}类别，则返回模式为@var{mode}的表达式@code{CONST_DOUBLE}。否则，其返回一个模式为@var{mode}的表达式@code{CONST_VECTOR}。类似的，宏@code{CONST1_RTX (@var{mode})}指定一个具有值1，机器模式为@var{mode}的表达式，类似的对于@code{CONST2_RTX}。宏@code{CONST1_RTX}和@code{CONST2_RTX}对于向量模式没有定义。

@node 寄存器和内存
@section 寄存器和内存
@cindex RTL register expressions
@cindex RTL memory expressions

这些是描述访问机器寄存器和内存的RTL表达式类型。

@table @code
@findex reg
@cindex hard registers
@cindex pseudo registers
@item (reg:@var{m} @var{n})
对于值小（那些小于@code{FIRST_PSEUDO_REGISTER}）的整数@var{n}，这表示对机器寄存器号为@var{n}的引用。对于值大的@var{n}，它表示一个临时的值或者伪寄存器（@dfn{pseudo register}）。编译器的策略是，在生成代码时假设有无限数目的伪寄存器，并在之后将它们转换为硬件寄存器（@dfn{hard register}）或者内存的引用。

@var{m}为引用的机器模式。指定机器模式是有必要的，因为机器通常可以使用多种机器模式来引用每个寄存器。例如，一个寄存器可以包含一个整字，但是可以有指令来作为半字或者一个单独的字节来引用，同样，也有指令可以作为不同精度的浮点来引用。

即使对于机器只能使用一种机器模式来引用的寄存器，mode也必须被指定。

符号@code{FIRST_PSEUDO_REGISTER}被机器描述定义，由于机器的硬件寄存器数目是一个不变的特征。然而要注意，并不是所有的机器寄存器都必须是通用寄存器。所有的可以用于存储数据的机器寄存器都为被给定硬件寄存器编号，即使那些只可以被用于特定指令或者只能存放特定类型数据。

一个硬件寄存器可以在整个函数中按照多种机器模式来访问，但是每个伪寄存器都被给定一个自然的机器模式并且只能按照那个机器模式来访问。当需要描述一个使用非自然机器模式来访问伪寄存器的时候，则使用一个@code{subreg}表达式。

一个@code{reg}表达式具有的机器模式，如果指定了多于一个字的数据，则实际上代表了多个连续的寄存器。如果寄存器编号还指定了一个硬件寄存器，则其实际上表示起始于指定寄存器的多个连续的硬件寄存器。

每个在函数的RTL代码中使用的伪寄存器编号，使用一个唯一的@code{reg}表达式来表示。

@findex FIRST_VIRTUAL_REGISTER
@findex LAST_VIRTUAL_REGISTER
一些伪寄存器编号，处于@code{FIRST_VIRTUAL_REGISTER}到@code{LAST_VIRTUAL_REGISTER}之间，只在RTL生成阶段出现并且在优化阶段之前被消除。这些表示在栈帧中的位置，并且直到函数的RTL生成完成后才能确定。下列虚寄存器编号被定义：

@table @code
@findex VIRTUAL_INCOMING_ARGS_REGNUM
@item VIRTUAL_INCOMING_ARGS_REGNUM
这指向栈上传递的参数的第一个字。通常这些参数由调用者存放，但是被调用者可能已经将之前在寄存器中传递的参数压入栈中。

@cindex @code{FIRST_PARM_OFFSET} and virtual registers
@cindex @code{ARG_POINTER_REGNUM} and virtual registers
当RTL生成完成时，该虚寄存器由@code{ARG_POINTER_REGNUM}给定的寄存器和@code{FIRST_PARM_OFFSET}的值的和替换。

@findex VIRTUAL_STACK_VARS_REGNUM
@cindex @code{FRAME_GROWS_DOWNWARD} and virtual registers
@item VIRTUAL_STACK_VARS_REGNUM
如果@code{FRAME_GROWS_DOWNWARD}被定义为非0的值，则该宏指向栈上第一个变量的上一个位置。否则，其指向栈上的第一个变量。

@cindex @code{STARTING_FRAME_OFFSET} and virtual registers
@cindex @code{FRAME_POINTER_REGNUM} and virtual registers
@code{VIRTUAL_STACK_VARS_REGNUM}由@code{FRAME_POINTER_REGNUM}给定的寄存器和@code{STARTING_FRAME_OFFSET}的值的和替换。

@findex VIRTUAL_STACK_DYNAMIC_REGNUM
@item VIRTUAL_STACK_DYNAMIC_REGNUM
该宏指向栈指针根据内存需要已经被调整后的栈上动态分配内存的位置。

@cindex @code{STACK_DYNAMIC_OFFSET} and virtual registers
@cindex @code{STACK_POINTER_REGNUM} and virtual registers
该虚寄存器由@code{STACK_POINTER_REGNUM}给定的寄存器和@code{STACK_DYNAMIC_OFFSET}的值的和替换。

@findex VIRTUAL_OUTGOING_ARGS_REGNUM
@item VIRTUAL_OUTGOING_ARGS_REGNUM
其指向栈中，当预先压栈时（使用push insn压栈的参数应该总是使用@code{STACK_POINTER_REGNUM}），书写输出参数的位置。

@cindex @code{STACK_POINTER_OFFSET} and virtual registers
该虚拟寄存器，被替换成由@code{STACK_POINTER_REGNUM}给定的寄存器与值@code{STACK_POINTER_OFFSET}的和。

@end table

@findex subreg
@item (subreg:@var{m1} @var{reg:m2} @var{bytenum})
@code{subreg}表达式用于按照自然的机器模式之外的，其它机器模式来引用一个寄存器，或者引用有多个寄存器组成的@code{reg}的其中一个寄存器。

每个伪寄存器都具有一个自然的机器模式。如果需要按照不同的机器模式来对其操作，则寄存器必须用@code{subreg}进行包含。

目前对于@code{subreg}的第一个操作数，有三种被支持的类型：  

@itemize
@item pseudo registers
这是最常见的情况。大多@code{subreg}将伪寄存器@code{reg}作为它们的第一个操作数。

@item mem
@code{mem}的@code{subreg}，在早期版本的GCC中比较常见，现在仍被支持。在重载过程中，这些被普通的@code{mem}替换掉。在不进行指令调度的机器上，仍然使用@code{mem}的@code{subreg}，但是不推荐这样。在重载过程之前和过程之中，这样的@code{subreg}被考虑成@code{register_operand}，而不是@code{memory_operand}。因此，调度过程无法对具有@code{mem}的@code{subreg}这样的指令进行合适的调度。所以，对于进行调度的机器，不要使用@code{mem}的@code{subreg}。为此，当@code{INSN_SCHEDULING}被定义的时候，合并过程和recog过程，具有显式的代码来禁止创建@code{mem}的@code{subreg}。

在重载过程之后使用@code{mem}的@code{subreg}，将难以理解，应该避免这样。编译器中还有一些代码支持这些，但是这些代码可能已经过时了。这种@code{subreg}的用法不被推荐，将来很可能不被支持。

@item hard registers
很少有必要在@code{subreg}中包裹硬件寄存器；这样的寄存器通常应该被缩减为一个单独的@code{reg} rtx。这种@code{subreg}的用法不被推荐，将来可能不被支持。

@end itemize

@code{subreg}的@code{subreg}不被支持。推荐使用@code{simplify_gen_subreg}来避免这种问题。

@code{subreg}有两种不同的风格，分别具有自己的用法和规则：

@table @asis
@item Paradoxical subregs
当@var{m1}严格宽于@var{m2}的时候，@code{subreg}表达式被称作反常的（@dfn{paradoxical}）。对该类别的@code{subreg}的正规测试为：

@smallexample
GET_MODE_SIZE (@var{m1}) > GET_MODE_SIZE (@var{m2})
@end smallexample

反常的@code{subreg}可以用于左值和右值。当用于左值时，源值的低位被存储在@var{reg}中，高位被丢弃。当用作右值时，@code{subreg}的低位来自@var{reg}，而高位可以被定义，也可以未被定义。

右值的高位有以下几种情况：

@itemize
@item @code{subreg}s of @code{mem}
当@var{m2}小于一个字的时候，宏@code{LOAD_EXTEND_OP}可以控制高位如何被定义。

@item @code{subreg} of @code{reg}s
当@code{SUBREG_PROMOTED_VAR_P}为真时，高位被定义。@code{SUBREG_PROMOTED_UNSIGNED_P}描述了高位的内容。这样的subreg通常表示已经被提升为更宽的机器模式的局部变量，寄存器变量以及参数伪变量。

@end itemize

对于反常的@code{subreg}，@var{bytenum}总是为零，即使在大端的目标机上。

例如反常的@code{subreg}:

@smallexample
(set (subreg:SI (reg:HI @var{x}) 0) @var{y})
@end smallexample

在@var{x}中存储了@var{y}的低位2个字节，并丢弃高位2个字节。接着：

@smallexample
(set @var{z} (subreg:SI (reg:HI @var{x}) 0))
@end smallexample

将会把@var{z}的低位2个字节设置成@var{x}，并将高位两个字节设置为未知的值，假定@code{SUBREG_PROMOTED_VAR_P}为假。

@item Normal subregs 
当@var{m1}最多跟@var{m2}一样宽的时候，@code{subreg}表达式被称作正常的（@dfn{normal}）。

正常的@code{subreg}被限定为@var{reg}的特定位。有两种情况。如果@var{m1}比一个字小，则@code{subreg}指的是一个@var{reg}字的最小有效部分。如果@var{m1}为字大小，或者更大，则@code{subreg}指的是一个或者更多个完整的字。

当用作左值时，@code{subreg}为一个基于字的访问。对@code{subreg}进行存储，会修改@var{reg}中所有与@code{subreg}重叠的字，并将@var{reg}中的其它字保持不变。

当对小于一个字的正常@code{subreg}进行存储的时候，被引用的字的其它位通常处于未定义的状态。这种松弛的方式易于对这样的指令产生高效的代码。要表示保持@code{subreg}之外的所有位的指令，在@code{subreg}周围使用@code{strict_low_part}或者@code{zero_extract}。

@var{bytenum}必须标识从@var{reg}的起始，@code{subreg}的第一个字节的偏移量，假设@var{reg}按照内存的顺序布局。字节的内存顺序通过两个目标宏定义，@code{WORDS_BIG_ENDIAN}和@code{BYTES_BIG_ENDIAN}：

@itemize
@item
@cindex @code{WORDS_BIG_ENDIAN}, effect on @code{subreg}
@code{WORDS_BIG_ENDIAN}，如果设为1，则说明第零个字节为最大有效字的部分；否则，为最小有效字的部分。

@item
@cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}
@code{BYTES_BIG_ENDIAN}，如果设为1，则说明第零个字节为字中的最高有效字节；否则，为字中的最低有效字节。

@end itemize

@cindex @code{FLOAT_WORDS_BIG_ENDIAN}, (lack of) effect on @code{subreg}
在一些目标机上，@code{FLOAT_WORDS_BIG_ENDIAN}与@code{WORDS_BIG_ENDIAN}不一致。然而，编译器的大部分地方会将浮点值看作它们与整数值具有相同的大小端。这是因为只将它们作为整数值的集合来处理，没有特定的数值。只有real.c和运行时库关心@code{FLOAT_WORDS_BIG_ENDIAN}。

因此，

@smallexample
(subreg:HI (reg:SI @var{x}) 2)
@end smallexample

在一个@code{BYTES_BIG_ENDIAN}，@samp{UNITS_PER_WORD == 4}的目标机上，等同于

@smallexample
(subreg:HI (reg:SI @var{x}) 0)
@end smallexample

在一个小端，@samp{UNITS_PER_WORD == 4}的目标机上。两个@code{subreg}都是访问寄存器@var{x}的低两个字节。

@end table

@code{MODE_PARTIAL_INT}机器模式的行为就好像其与相对应的@code{MODE_INT}机器模式一样宽，只不过其具有未知数目的未定义的位。例如： 

@smallexample
(subreg:PSI (reg:SI 0) 0)
@end smallexample

访问整个@samp{(reg:SI 0)}，但是@code{PSImode}值和@code{SImode}值的确切关系没有被定义。如果我们假设@samp{UNITS_PER_WORD <= 4}，则下面两个@code{subreg}：

@smallexample
(subreg:PSI (reg:DI 0) 0)
(subreg:PSI (reg:DI 0) 4)
@end smallexample

表示对@samp{(reg:DI 0)}的两个部分进行无关的四个字节访问。每个@code{subreg}都具有未知数目的未定义位。

如果@samp{UNITS_PER_WORD <= 2}，则这两个@code{subreg}

@smallexample
(subreg:HI (reg:PSI 0) 0)
(subreg:HI (reg:PSI 0) 2)
@end smallexample

表示无关的两个字节访问，一起贯穿整个@samp{(reg:PSI 0)}。对第一个@code{subreg}进行存储不影响第二个的值，反之亦然。@samp{(reg:PSI 0)}具有未知数目的未定义位，所以赋值：

@smallexample
(set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
@end smallexample

不保证@samp{(subreg:HI (reg:PSI 0) 0)}具有值@samp{(reg:HI 4)}。

@cindex @code{CANNOT_CHANGE_MODE_CLASS} and subreg semantics
上面的规则应用于伪寄存器@var{reg}和硬件寄存器@var{reg}。如果对于@var{m1}, @var{m2}和硬件寄存器@var{reg}的特定组合，其语义不正确，则目标机特定的代码必须确保这些组合不会被用到。例如：

@smallexample
CANNOT_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})
@end smallexample

必须为真，对于每个包含@var{reg}的类别@var{class}。

@findex SUBREG_REG
@findex SUBREG_BYTE
@code{subreg}表达式的第一个操作数通常使用@code{SUBREG_REG}宏来访问，第二个操作数通常使用@code{SUBREG_BYTE}宏来访问。

@code{BYTES_BIG_ENDIAN}不等于@code{WORDS_BIG_ENDIAN}的平台是在很多年前被测试的。对于希望在将来支持这样一个平台的人们，可能会面对一些过时的代码。

@findex scratch
@cindex scratch operands
@item (scratch:@var{m})
这表示一个scratch寄存器，其在单个指令的执行中用到，并随后不再被使用。其被局部寄存器分配或者重载过程，转换成一个@code{reg}。

@code{scratch}通常位于@code{clobber}操作中。(@zhpxref{Side Effects})。

@findex cc0
@cindex condition code register
@item (cc0)
为机器的条件代码寄存器。其没有参数，并可以没有机器模式。有两种使用它的方式：

@itemize @bullet
@item
表示一个完整的条件代码标记的集合。这在大多机器上是最好的方式，每个比较都会设置整个标记系列。

使用这种技术，@code{(cc0)}只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中）和在跟零进行比较的比较运算符中（值为零的@code{const_int}；也就是说，@code{const0_rtx}）。

@item
表示单个标记，为单个条件的结果。这用于只有一个标记位，比较指令必须指定要测试的条件的机器上。

使用这种技术，@code{(cc0)}只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中），其中源操作数为一个比较运算符，以及@code{if_then_else}的第一个参数（在条件分支中）。

@end itemize

@findex cc0_rtx
只有一个代码为@code{cc0}的表达式对象；其为变量@code{cc0_rtx}的值。任何尝试创建一个代码为@code{cc0}的表达式，将返回@code{cc0_rtx}。

指令可以隐式的设置条件代码。在许多机器上，几乎所有的指令根据它们计算或者存储的值来设置条件码。没有必要在RTL中显式的记录这些行为，因为机器描述包含一个对策，用于识别这样做的指令（通过宏@code{NOTICE_UPDATE_CC}）。@zhxref{Condition Code}. 只有目的纯粹是设置条件码的指令，以及使用条件码的指令，才需要提及@code{(cc0)}。

在一些机器上，条件码寄存器被给定一个寄存器编号，并且一个@code{reg}用于替代@code{(cc0)}。这通常为更好的方式，如果只有一个小的指令子集修改条件码。其它机器将条件码存储在通用寄存器中；这种情况下应该使用伪寄存器。

一些机器，例如SPARC和RS/6000，具有两个算术指令集合，一个设置条件码，另一个不设置。可以通常情况下生成不设置条件码的指令，并创建一个同时执行算术运算并设置条件码寄存器（这种情况下将不会是@code{(cc0)}）的指令模式。例如，搜一下@file{sparc.md}中的@samp{addcc}和@samp{andcc}。

@findex pc
@item (pc)
@cindex program counter
表示机器的程序计数器。其没有操作数并可能没有机器模式。@code{(pc)}只在跳转指令的特定上下文中使用。

@findex pc_rtx
只有一个代码为@code{pc}的表达式对象；其为变量@code{pc_rtx}的值。任何尝试创建一个代码为@code{pc}的表达式，将返回@code{pc_rtx}。

所有不进行跳转的指令会隐式的通过递增的方式改变程序计数器，但是不需要在RTL中提起这些。

@findex mem
@item (mem:@var{m} @var{addr} @var{alias})
该RTX表示对表达式@var{addr}所表示的地址的主内存进行引用。@var{m}描述了被访问的内存的单元大小。@var{alias}描述了该引用的别名集合。总得来说，两个项如果不引用相同的内存地址，则在不同的别名集合里。

结构@code{(mem:BLK (scratch))}被认为是所有其它内存的别名。因此其可以在函数尾声的栈销毁中用作内存栅栏。

@findex concat
@item (concat@var{m} @var{rtx} @var{rtx})
该RTX表示对两个其它RTX的连结。这用于复数值。其应该只出现在附加在声明中的RTL中，以及RTL生成中。不应该出现在普通的insn链上。

@findex concatn
@item (concatn@var{m} [@var{rtx} @dots{}])
该RTX表示将所有的@var{rtx}进行连结，生成一个单个的值。类似@code{concat}，其应该只出现在声明中，不应该出现在insn链上。

@end table

@node 算术运算
@section RTL算术运算表达式
@cindex arithmetic, in RTL
@cindex math, in RTL
@cindex RTL expressions for arithmetic

除非其它规定，所有算术表达式的操作数必须对模式@var{m}有效。一个操作数对模式@var{m}有效，是指当它具有模式@var{m}，或者如果它是一个@code{const_int}或者@code{const_double}，并且@var{m}是一个@code{MODE_INT}类的模式。

对于可交换的二进制操作，常量应该放到第二个操作数的位置。

@table @code
@findex plus
@findex ss_plus
@findex us_plus
@cindex RTL sum
@cindex RTL addition
@cindex RTL addition with signed saturation
@cindex RTL addition with unsigned saturation
@item (plus:@var{m} @var{x} @var{y})
@itemx (ss_plus:@var{m} @var{x} @var{y})
@itemx (us_plus:@var{m} @var{x} @var{y})
这三个表达式都表示@var{x}和@var{y}所表示的值的和，机器模式为@var{m}。它们在整数机器模式的溢出方面有所不同。@code{plus}以@var{m}的宽度求模进行环绕；@code{ss_plus}饱和为@var{m}可表示的有符号最大值；@code{us_plus}饱和为无符号最大值。

@c ??? What happens on overflow of floating point modes?

@findex lo_sum
@item (lo_sum:@var{m} @var{x} @var{y})
该表达式表示@var{x}与@var{y}低位的和。其跟@code{high} (@zhpxref{Constants})一起使用，来表示在RISC机器中通常使用的两个指令序列，来引用一个全局内存位置。

低位的位数是机器相关的，但通常为@code{Pmode}中的位数减去@code{high}所设置的位数。

@var{m}应该为@code{Pmode}。

@findex minus
@findex ss_minus
@findex us_minus
@cindex RTL difference
@cindex RTL subtraction
@cindex RTL subtraction with signed saturation
@cindex RTL subtraction with unsigned saturation
@item (minus:@var{m} @var{x} @var{y})
@itemx (ss_minus:@var{m} @var{x} @var{y})
@itemx (us_minus:@var{m} @var{x} @var{y})

这三个表达式表示从@var{x}中减去@var{y}的结果，机器模式为@var{m}。在溢出方面的行为与@code{plus}的三种版本相同（参见上面）。

@findex compare
@cindex RTL comparison
@item (compare:@var{m} @var{x} @var{y})
表示从@var{x}中减去@var{y}的结果，用于进行比较。计算结果不产生溢出，就好像是有无限的精度一样。

当然，机器不会真的进行无限精度的减法。然而，它们可以假定这样做，当只使用结果的正负符号时，这样情况下，结果被存放在条件代码中。并且，这是这种表达式唯一可以被使用的方式：作为值存储在条件代码中，或者@code{(cc0)}，或者一个寄存器。@zhxref{Comparisons}.

机器模式@var{m}与@var{x}和@var{y}的机器模式没有关联，而是条件代码值的机器模式。如果使用@code{(cc0)}，则为@code{VOIDmode}，否则为类别@code{MODE_CC}中的某个模式，通常为@code{CCmode}。@zhxref{Condition Code}. 如果@var{m}为@code{VOIDmode}或者@code{CCmode}，则运算会返回足够的信息，使得任何比较运算符可以被应用到@code{COMPARE}运算的结果上。对于类别@code{MODE_CC}中的其它机器模式，运算只返回信息的子集。

通常，@var{x}和@var{y}必须具有相同的机器模式。否则，@code{compare}只有当@var{x}的机器模式在类别@code{MODE_INT}中，并且@var{y}为一个机器模式为@code{VOIDmode}的@code{const_int}或者@code{const_double}，这时才有效。@var{x}的机器模式决定了比较按照什么机器模式进行；因此其不能为@code{VOIDmode}。

如果其中一个操作数为常量，则其应该被放在第二个操作数的位置，并且相应的调整比较代码。

指定两个@code{VOIDmode}常量的@code{compare}是无效的，因为无法知道比较要按照什么机器模式进行；比较必须或者在编译过程中被折叠，或者第一个操作数必须被加载到机器模式已知的寄存器中。

@findex neg
@findex ss_neg
@findex us_neg
@cindex negation
@cindex negation with signed saturation
@cindex negation with unsigned saturation
@item (neg:@var{m} @var{x})
@itemx (ss_neg:@var{m} @var{x})
@itemx (us_neg:@var{m} @var{x})
这两个表达式表示@var{x}所表示的值的负数（零减去该值），机器模式为@var{m}。它们在整数机器模式的溢出行为上有所不同。对于@code{neg}，操作数的负数可以为无法用机器模式@var{m}表示的数，这种情况下，其被截取为@var{m}。@code{ss_neg}和@code{us_neg}确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

@findex mult
@findex ss_mult
@findex us_mult
@cindex multiplication
@cindex product
@cindex multiplication with signed saturation
@cindex multiplication with unsigned saturation
@item (mult:@var{m} @var{x} @var{y})
@itemx (ss_mult:@var{m} @var{x} @var{y})
@itemx (us_mult:@var{m} @var{x} @var{y})
表示@var{x}和@var{y}所表示的值的有符号乘积，机器模式为@var{m}。@code{ss_mult}和@code{us_mult}确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

一些机器支持产生比操作数更宽的乘积。则指令模式可以写成

@smallexample
(mult:@var{m} (sign_extend:@var{m} @var{x}) (sign_extend:@var{m} @var{y}))
@end smallexample

其中@var{m}比@var{x}和@var{y}的机器模式更宽。

对于无符号的加宽的乘法，使用相同的语句，只不过把@code{sign_extend}替换成@code{zero_extend}。

@findex div
@findex ss_div
@cindex division
@cindex signed division
@cindex signed division with signed saturation
@cindex quotient
@item (div:@var{m} @var{x} @var{y})
@itemx (ss_div:@var{m} @var{x} @var{y})
表示@var{x}有符号除以@var{y}的商，机器模式为@var{m}。如果@var{m}为一个浮点机器模式，则表示确切的商；否则为整数化的商。@code{ss_div}确保超出边界的结果饱和为最大或者最小的有符号值。

一些机器具有的除法指令，其操作数和商的宽度不全相同；你应该使用@code{truncate}和@code{sign_extend}来表示这样的指令，

@smallexample
(truncate:@var{m1} (div:@var{m2} @var{x} (sign_extend:@var{m2} @var{y})))
@end smallexample

@findex udiv
@cindex unsigned division
@cindex unsigned division with unsigned saturation
@cindex division
@item (udiv:@var{m} @var{x} @var{y})
@itemx (us_div:@var{m} @var{x} @var{y})
类似@code{div}，不过表示无符号除法。@code{us_div}确保超出边界的结果饱和为最大或者最小的无符号值。

@findex mod
@findex umod
@cindex remainder
@cindex division
@item (mod:@var{m} @var{x} @var{y})
@itemx (umod:@var{m} @var{x} @var{y})
类似@code{div}和@code{udiv}，不过表示余数。

@findex smin
@findex smax
@cindex signed minimum
@cindex signed maximum
@item (smin:@var{m} @var{x} @var{y})
@itemx (smax:@var{m} @var{x} @var{y})
表示@var{x}和@var{y}的较小值（@code{smin}）或者较大值（@code{smax}），按照机器模式为@var{m}的有符号值解析。当用于浮点，如果两个操作数都为零，或者其中一个为@code{NaN}，则没有规定哪一个操作数被作为结果返回。

@findex umin
@findex umax
@cindex unsigned minimum and maximum
@item (umin:@var{m} @var{x} @var{y})
@itemx (umax:@var{m} @var{x} @var{y})
类似@code{smin}和@code{smax}，不过值被解析为无符号整数。

@findex not
@cindex complement, bitwise
@cindex bitwise complement
@item (not:@var{m} @var{x})
表示对@var{x}所表示的值进行按位求补，机器模式为@var{m}，且必须为一个定点机器模式。

@findex and
@cindex logical-and, bitwise
@cindex bitwise logical-and
@item (and:@var{m} @var{x} @var{y})
表示对@var{x}和@var{y}所表示的值按位进行逻辑与，机器模式为@var{m}，且必须为一个定点机器模式。

@findex ior
@cindex inclusive-or, bitwise
@cindex bitwise inclusive-or
@item (ior:@var{m} @var{x} @var{y})
表示对@var{x}和@var{y}所表示的值按位进行逻辑或，机器模式为@var{m}，且必须为一个定点机器模式。

@findex xor
@cindex exclusive-or, bitwise
@cindex bitwise exclusive-or
@item (xor:@var{m} @var{x} @var{y})
表示对@var{x}和@var{y}所表示的值按位进行逻辑异或，机器模式为@var{m}，且必须为一个定点机器模式。

@findex ashift
@findex ss_ashift
@findex us_ashift
@cindex left shift
@cindex shift
@cindex arithmetic shift
@cindex arithmetic shift with signed saturation
@cindex arithmetic shift with unsigned saturation
@item (ashift:@var{m} @var{x} @var{c})
@itemx (ss_ashift:@var{m} @var{x} @var{c})
@itemx (us_ashift:@var{m} @var{x} @var{c})
这三个表达式用来表示对@var{x}进行向左算术移位@var{c}。它们在整数机器模式的溢出方面有所不同。@code{ashift}运算是一个普通的移位，当符号位有改变时，其没有特殊的行为；@code{ss_ashift}和@code{us_ashift}，饱和为可表示的最小或者最大值，如果任何被移出的位与最终的符号位不同。

@var{x}具有机器模式@var{m}，一个定点机器模式。@var{c}为一个定点机器模式或者一个模式为@code{VOIDmode}的常量。

@findex lshiftrt
@cindex right shift
@findex ashiftrt
@item (lshiftrt:@var{m} @var{x} @var{c})
@itemx (ashiftrt:@var{m} @var{x} @var{c})
类似于@code{ashift}，不过是向右移位。不像向左移位的情况，这两种运算是有区别的。

@findex rotate
@cindex rotate
@cindex left rotate
@findex rotatert
@cindex right rotate
@item (rotate:@var{m} @var{x} @var{c})
@itemx (rotatert:@var{m} @var{x} @var{c})
类似的，只不过是表示向左和向右旋转。如果@var{c}为常量，则使用@code{rotate}。

@findex abs
@cindex absolute value
@item (abs:@var{m} @var{x})
表示@var{x}的绝对值，按照机器模式@var{m}来计算。

@findex sqrt
@cindex square root
@item (sqrt:@var{m} @var{x})
表示@var{x}的平方根，按照机器模式@var{m}来计算。@var{m}通常为浮点机器模式。

@findex ffs
@item (ffs:@var{m} @var{x})
表示在@var{x}中，最低有效，位为1的索引加上1，为一个模式@var{m}的整数。（如果@var{x}为零，则值为零。）@var{x}的机器模式不需要为@var{m}；取决于目标机器，可以有不同的机器模式的组合。

@findex clz
@item (clz:@var{m} @var{x})
表示@var{x}中，从最高有效位开始，起始处为0的位数，为一个模式@var{m}的整数。如果@var{x}为零，则值由@code{CLZ_DEFINED_VALUE_AT_ZERO}
(@zhpxref{Misc})来确定。注意，。@var{x}的机器模式通常为一个整数模式。

@findex ctz
@item (ctz:@var{m} @var{x})
表示@var{x}中，从最低有效位开始，结尾处为0的位数，为一个模式@var{m}的整数。如果@var{x}为零，则值由@code{CTZ_DEFINED_VALUE_AT_ZERO}
(@zhpxref{Misc})来确定。除此之外，@code{ctz(x)}等价于@code{ffs(@var{x}) - 1}。@var{x}的机器模式通常为一个整数模式。

@findex popcount
@item (popcount:@var{m} @var{x})
表示@var{x}中为1的位数，为一个模式@var{m}的整数。@var{x}的机器模式通常为一个整数模式。

@findex parity
@item (parity:@var{m} @var{x})
表示@var{x}中为1的位数对2进行求模，为一个模式@var{m}的整数。@var{x}的机器模式通常为一个整数模式。

@findex bswap
@item (bswap:@var{m} @var{x})
表示将@var{x}值的字节顺序进行反转，结果为@var{m}机器模式，其必须为一个定点机器模式。

@end table

@node 比较运算
@section 比较运算
@cindex RTL comparison operations

比较运算符测试两个操作数的关系，对于结果具有`MODE_INT'机器模式的比较运算，如果关系成立，则表示成机器相关的非零值，其由@code{STORE_FLAG_VALUE}
(@zhpxref{Misc})描述，但是不需要相等，如果不成立，则为零。对于结果为浮点值的比较运算，如果关系成立，则为@code{FLOAT_STORE_FLAG_VALUE}
(@zhpxref{Misc})，否则为零。对于返回向量结果的比较运算，如果关系成立，则为@code{VECTOR_STORE_FLAG_VALUE}
(@zhpxref{Misc})，否则为零向量。比较运算的机器模式独立于被比较的数据的机器模式。如果正在测试比较运算（例如，@code{if_then_else}的第一个操作数），则机器模式必须为@code{VOIDmode}。

@cindex condition codes
有两种方式可以被比较运算使用。比较运算符可以用于将条件代码@code{(cc0)}与零进行比较，型如@code{(eq (cc0) (const_int 0))}。这种结构实际上是用到了先前指令的结果，条件代码在那里被设置。设置条件代码的指令必须邻接于使用条件代码的指令；只有@code{note} insn可以分开它们。

替换的，比较运算可以直接比较两个数据对象。比较运算的机器模式由操作数来决定；它们必须对一个共同的机器模式有效。对两个操作数都为常量的比较，将是无效的，因为不能从中推导出机器模式，不过这样的比较不会出现在RTL中，因为常数折叠。

在上面的例子中，如果@code{(cc0)}最后被设置为@code{(compare @var{x} @var{y})}，则比较运算等价于@code{(eq @var{x} @var{y})}。通常，在一个特定的机器上，只支持一种风格的比较。但是，合并过程将尝试合并运算，从而产生@code{eq}。

不等式比较有两种，有符号和无符号。因此，对于有符号和无符号的大于，有两个不同的表达式代码@code{gt}和@code{gtu}。对于相同的整数值，这些可以产生不同的结果：例如，1有符号大于@minus{}1，但是并不无符号大于，因为@minus{}1被作为无符号时，实际为@code{0xffffffff}，其大于1。

有符号比较也用于浮点值。浮点比较通过操作数的机器模式来区分。

@table @code
@findex eq
@cindex equal
@item (eq:@var{m} @var{x} @var{y})
如果@var{x}和@var{y}所表示的值相等，则为@code{STORE_FLAG_VALUE}，否则为0。

@findex ne
@cindex not equal
@item (ne:@var{m} @var{x} @var{y})
如果@var{x}和@var{y}所表示的值不相等，则为@code{STORE_FLAG_VALUE}，否则为0。

@findex gt
@cindex greater than
@item (gt:@var{m} @var{x} @var{y})
如果@var{x}比@var{y}大，则为@code{STORE_FLAG_VALUE}。如果它们为定点，则按照有符号比较。

@findex gtu
@cindex greater than
@cindex unsigned greater than
@item (gtu:@var{m} @var{x} @var{y})
类似于@code{gt}，不过进行无符号比较，只用于定点数。

@findex lt
@cindex less than
@findex ltu
@cindex unsigned less than
@item (lt:@var{m} @var{x} @var{y})
@itemx (ltu:@var{m} @var{x} @var{y})
类似于@code{gt}和@code{gtu}，不过测试“小于”。

@findex ge
@cindex greater than
@findex geu
@cindex unsigned greater than
@item (ge:@var{m} @var{x} @var{y})
@itemx (geu:@var{m} @var{x} @var{y})
类似于@code{gt}和@code{gtu}，不过测试“大于或等于”。

@findex le
@cindex less than or equal
@findex leu
@cindex unsigned less than
@item (le:@var{m} @var{x} @var{y})
@itemx (leu:@var{m} @var{x} @var{y})
类似于@code{gt}和@code{gtu}，不过测试“小于或等于”。

@findex if_then_else
@item (if_then_else @var{cond} @var{then} @var{else})
这不是比较运算，但是被列在这里，因为其总是与比较运算结合使用。确切的说，@var{cond}为一个比较表达式。该表达式表示一个根据@var{cond}，在@var{then}所表示的值和@var{else}所表示的值之间的选择，

在大多数机器上，@code{if_then_else}表达式只用于表示条件跳转。

@findex cond
@item (cond [@var{test1} @var{value1} @var{test2} @var{value2} @dots{}] @var{default})
类似于@code{if_then_else}，不过更普通。每个@var{test1}，@var{test2}，@dots{}被依次执行。表达式的结果为对应于第一个非零测试的@var{value}，或者如果测试都为零，则为@var{default}。

这目前在指令模式中不可用，只在insn属性中被支持。@zhxref{Insn Attributes}.

@end table

@node 位域运算
@section 位域
@cindex bit-fields

有专门的表达式代码来表示位域指令。

@table @code
@findex sign_extract
@cindex @code{BITS_BIG_ENDIAN}, effect on @code{sign_extract}
@item (sign_extract:@var{m} @var{loc} @var{size} @var{pos})
这表示了对在@var{loc}处包含的或者起始的符号扩展位域的引用（内存或者寄存器引用）。位域为@var{size}个位数宽并且在位@var{pos}处起始。编译选项@code{BITS_BIG_ENDIAN}指明了@var{pos}从内存单元的那个端开始。 

如果@var{loc}在内存中，则它的机器模式必须为一个单个字节的整数机器模式。如果@var{loc}在寄存器中，则使用的机器模式是通过@code{insv}或者@code{extv}指令模式的操作数来指定的（@zhpxref{Standard Names}）并且通常为一个全字的整数机器模式，这当没有任何指定的时候为缺省的。

@var{pos}的机器模式为机器特定的并且总是在@code{insv}或者@code{extv}指令模式中被指定。

机器模式@var{m}与@var{loc}所使用的相同，如果它是在寄存器中。

在RTL中，@code{sign_extract}不可以作为左值或者是其中的一部分出现。

@findex zero_extract
@item (zero_extract:@var{m} @var{loc} @var{size} @var{pos})
类似@code{sign_extract}，但是指向一个无符号或者零扩展的位域。相同的位序列被抽取，但是它们被填充到一个整字中，并使用零扩展而不是符号扩展。 

不像@code{sign_extract}，该表达式的类型可以在RTL中为左值；它们可以出现在一个赋值的左边，来表明在一个指定的位域插入一个值。

@end table

@node 向量运算
@section 向量运算
@cindex vector operations

所有普通的RTL表达式都能够作为向量模式使用；它们被解析为对向量的每个部分进行独立的运算。另外，有一些新的表达式来描述特定的向量运算。

@table @code
@findex vec_merge
@item (vec_merge:@var{m} @var{vec1} @var{vec2} @var{items})
这描述了两个向量间的合并操作。结果为机器模式为@var{m}的向量；它的元素来自@var{vec1}或者@var{vec2}。那些元素被选择是通过@var{items}来描述，其为一个由@code{const_int}表示的位掩码；0位指示相应的元素在结果向量中是来自@var{vec2}，而1指示其来自@var{vec1}。 

@findex vec_select
@item (vec_select:@var{m} @var{vec1} @var{selection})
这描述了选择一个向量的一部分的操作。@var{vec1}为源向量，@var{selection}为一个@code{parallel}其包含了一个@code{const_int}，来描述结果向量的子部分，给出了源向量的子部分应该被存放进去。 

@findex vec_concat
@item (vec_concat:@var{m} @var{vec1} @var{vec2})
描述了一个向量连接操作。结果为向量@var{vec1}和@var{vec2}的连接；其长度为两个输出向量的长度之和。

@findex vec_duplicate
@item (vec_duplicate:@var{m} @var{vec})
该操作将一个小向量转换为一个大一点的，通过复制输入值。输出向量的机器模式必须和输入向量的相同，并且输出部分的编号必须为输入部分的编号的整数倍。

@end table

@node 转换运算
@section 转换
@cindex conversions
@cindex machine mode conversions

所有机器模式之间的转换都必须使用显示的转换符来表示。例如，一个表示字节和全字之和的表达式就不能写成@code{(plus:SI (reg:QI 34) (reg:SI 80))}，因为@code{plus}操作符需要两个具有相同机器模式的操作符。因此，字节长度的操作数被封装在一个转换操作中，如

@smallexample
(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))
@end smallexample

转换符并不仅仅是一个形式上的占位符，因为可能会有多种方式将给出的最初模式转换为期望的最终模式。转换符指出了如何进行这种操作。

对于所有的转换操作，@var{x}不能为@code{VOIDmode}，因为这样就无法知道如何进行转换操作。转换必须在编译时进行或者@var{x}必须被放入寄存器中。

@table @code
@findex sign_extend
@item (sign_extend:@var{m} @var{x})
表示将@var{x}的值符号扩展为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式窄的定点值。

@findex zero_extend
@item (zero_extend:@var{m} @var{x})
表示将@var{x}的值零扩展为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式窄的定点值。

@findex float_extend
@item (float_extend:@var{m} @var{x})
表示将@var{x}的值扩展为机器模式@var{m}后的结果。@var{m}必须是一个浮点模式，并且@var{x}是一个比@var{m}模式窄的浮点值。

@findex truncate
@item (truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式宽的定点值。

@findex ss_truncate
@item (ss_truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果，并且在溢出时作为有符号数处理。@var{m}和@var{x}的模式都必须是定点模式。

@findex us_truncate
@item (us_truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果，并且在溢出时作为无符号数处理。@var{m}和@var{x}的模式都必须是定点模式。

@findex float_truncate
@item (float_truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果。@var{m}必须是一个浮定点模式，并且@var{x}是一个比@var{m}模式宽的浮点值。

@findex float
@item (float:@var{m} @var{x})
表示将定点值@var{x}转换为有符号的浮点模式@var{m}后的结果。

@findex unsigned_float
@item (unsigned_float:@var{m} @var{x})
表示将定点值@var{x}转换为无符号的浮点模式@var{m}后的结果。

@findex fix
@item (fix:@var{m} @var{x})
当@var{m}是一个浮点模式时，表示将浮点值@var{x}（对模式@var{m}有效）转换为整形，仍然使用浮点模式@var{m}表示，只不过是向零方向进行舍入。

当@var{m}是一个定点模式时，表示将浮点值@var{x}转换为有符号的模式@var{m}的结果。具体如何舍入没有做出规定。所以，这个操作可能只是被用在编译C代码时的整数值的操作数。

@findex unsigned_fix
@item (unsigned_fix:@var{m} @var{x})
表示将浮点值@var{x}转换为无符号的定点模式@var{m}。具体如何舍入没有做出规定。

@findex fract_convert
@item (fract_convert:@var{m} @var{x})
表示将定点值转换成定点机器模式@var{m}，将有符号整数值@var{x}转换成定点机器模式@var{m}，将浮点值@var{x}转换成定点机器模式@var{m}，将定点值@var{x}转换成有符号整数机器模式@var{m}，或者将浮点值@var{x}转换成浮点机器模式的结果。当发生溢出或者下溢，则结果未定义。

@findex sat_fract
@item (sat_fract:@var{m} @var{x})
表示将定点值@var{x}转换为浮点模式@var{m}，将有符号整数值@var{x}转换为定点模式@var{m}，或者将浮点值@var{x}转换为定点模式@var{m}的结果。当发生溢出或者下溢，则结果被饱和为最大值或者最小值。

@findex unsigned_fract_convert
@item (unsigned_fract_convert:@var{m} @var{x})
表示将定点值@var{x}转换为无符号整数模式@var{m}，或者将无符号整数值@var{x}转换为定点模式@var{m}的结果。当发生溢出或者下溢，则结果未定义。

@findex unsigned_sat_fract
@item (unsigned_sat_fract:@var{m} @var{x})
表示将无符号整数值@var{x}转换为定点模式@var{m}的结果。当发生溢出或者下溢，则结果被饱和为最大值或者最小值。

@end table

@node RTL声明
@section 声明
@cindex RTL declarations
@cindex declarations, RTL

声明表达式代码并不表示算术运算，而是关于它们的操作数状态的断言。

@table @code
@findex strict_low_part
@cindex @code{subreg}, in @code{strict_low_part}
@item (strict_low_part (subreg:@var{m} (reg:@var{n} @var{r}) 0))
这个表达式代码只用在一种上下文中：作为@code{set}表达式的目标操作数。另外，这个表达式的操作数必须是一个non-paradoxical @code{subreg}表达式 

这里@code{strict_low_part}指出寄存器中对于模式@var{n}有意义，但对于模式@var{m}却无意义的那一部分，是不能被修改的。通常，对于这样的subreg进行赋值，当@var{m}小于一个字时，是允许对寄存器的其它部分有未定义的影响。

@end table

@node 副作用
@section 副作用表达式
@cindex RTL side effect expressions

目前为止，所描述的表达式代码都是用来表示一个值，而不是操作。但是机器指令是不会产生值的，而只是通过副作用来改变机器状态。特定的表达式代码被用来表示副作用。

一条指令的主体，总是这些副作用代码之一；上面描述的表示值的代码，只是作为操作数出现在其中。

@table @code
@findex set
@item (set @var{lval} @var{x})
表示将@var{x}的值存放到由@var{lval}表示的地方。@var{lval}必须是表示可以用来存放的地方的表达式：@code{reg}（或者@code{subreg}，@code{strict_low_part}或者@code{zero_extract}），@code{mem}，@code{pc}，@code{parallel}或者@code{cc0}。

如果@var{lval}是一个@code{reg}，@code{subreg}或者@code{mem}，其具有一个机器模式；则@var{x}必须对这种模式有效。 

如果@var{lval}是一个@code{subreg}的@code{strict_low_part}，则由@code{subreg}的机器模式所指定的寄存器的那部分被赋予值@var{x}，而寄存器的其它部分不变。 

如果@var{lval}是一个@code{zero_extract}，则由@code{zero_extract}指定的相关位域（内存或者寄存器相关的），被赋予值@var{x}，而其它位域不变。注意@code{sign_extract}不能出现在@var{lval}中。 

如果@var{lval}是@code{(cc0)}，其没有机器模式，并且@var{x}可以为一个@code{compare}表达式或者任意模式的值。后者情况表示是一个“test”指令。表达式@code{(set (cc0) (reg:@var{m} @var{n}))} 等价于@code{(set (cc0) (compare (reg:@var{m} @var{n})))}。在编译过程中可以使用前一个表达式来节省空间。 

如果@var{lval}是一个@code{parallel}，其用来表示一个函数通过多个寄存器来返回一个结构体的情况。@code{parallel}中的每一个元素是一个@code{expr_list}，其第一个操作数是一个@code{reg}，并且第二个操作数是一个@code{const_int}，表示相应寄存器的数据在结构体中的偏移量（以字节为单位）。第一个元素也可能为null，用来指示结构体也有一部分是在内存中传递的。 

@cindex jump instructions and @code{set}
@cindex @code{if_then_else} usage
如果@var{lval}是@code{(pc)}，则为一个跳转指令，并且@var{x}只有几种可能。其可能为一个@code{label_ref}表达式（无条件跳转）。可能为一个@code{if_then_else}（条件跳转），这种情况下，第二个或者第三个操作数必须是@code{(pc)}（用于不进行跳转的情况），并且另外两个必须是一个@code{label_ref}（用于进行跳转的情况）。@var{x}也可以是一个@code{mem}或者@code{(plus:SI (pc) @var{y})}, 其中y可以为一个@code{reg}或者@code{mem}；这些独特的模式用来表示通过分支表来进行跳转。 

如果@var{lval}即不是@code{(cc0)}也不是@code{(pc)},则@var{lval}的模式一定不是@code{VOIDmode}，并且@var{x}的模式必须对于@var{lval}的模式有效。 

@findex SET_DEST
@findex SET_SRC
@var{lval}通常通过@code{SET_DEST}宏来访问，@var{x}通常使用@code{SET_SRC}宏。

@findex return
@item (return)
在指令模式中作为单独的表达式，表示从当前函数的一个返回，在一些机器上，可以使用一条指令来完成，例如VAXen。在一些机器上，为了从函数中返回，包括多条指令的尾声必须被执行，则返回操作，通过跳转到一个位于尾声之前的标号来完成，并且不使用@code{return}表达式代码。

在@code{if_then_else}表达式中，表示放在@code{pc}中的，返回给调用者的值。

注意，指令模式为@code{(return)}的insn，在逻辑上等价于@code{(set (pc) (return))}，但是不使用后者的形式。

@findex call
@item (call @var{function} @var{nargs})
表示一个函数调用。@var{function}为一个@code{mem}表达式，其地址为被调用的函数的地址。@var{nargs}为一个表达式，其可以用于两个目的：在一些机器上，其表示栈参数的字节数目；在其它机器上，其表示参数寄存器的数目。

每个机器具有一个标准的，@var{function}必须具有的机器模式。机器描述定义了宏@code{FUNCTION_MODE}，来扩展为需要的模式名。在一些机器上，所允许的寻址方式取决于被寻址的机器模式，则该机器模式的用途是来描述，允许什么样的寻址。

@findex clobber
@item (clobber @var{x})
表示一个不可预期的存储或者可能的存储，将不可描述的值存储到@var{x}，其必须为一个@code{reg}，@code{scratch}, @code{parallel} 或者 @code{mem}表达式。

可以用在字符串指令中，将标准的值存储到特定的硬件寄存器中。不需要去描述被存储的值，只用来告诉编译器寄存器被修改了，以免其尝试在字符串指令中保持数据。

如果@var{x}为@code{(mem:BLK (const_int 0))}或者@code{(mem:BLK (scratch))}，则意味着所有的内存位置必须假设被破坏。如果@var{x}为一个@code{parallel}，其具有与@code{set}表达式中的@code{parallel}相同的含义。

注意，机器描述将特定的硬件寄存器归类为“call-clobbered”。所有函数调用指令都被假设为，缺省的，会破坏这些寄存器，所以不需要使用@code{clobber}表达式来表示这些。而且，每个函数调用都被假设为潜在的修改任何内存位置，除非函数被声明为@code{const}。

如果在@code{parallel}中的最后一组表达式为@code{clobber}表达式，其参数为@code{reg}或者@code{match_scratch}（@zhpxref{RTL Template}）表达式，则合并阶段可以向构建的insn中增加适当的@code{clobber}表达式，当这样可以使得指令模式被匹配。

例如，该特点可以用在，乘法和加法指令不使用MQ寄存器，但具有一个加法累加指令，而且破坏MQ寄存器的机器上。类似的，被合并的指令可能需要临时的寄存器，而成员指令则不需要。

当寄存器的@code{clobber}表达式，出现在具有其它副作用的@code{parallel}中，如果是硬件寄存器，则寄存器分配者来确保在insn之前和之后，该寄存器都不会被占用。对于伪寄存器的破坏，寄存器分配者和重载过程，不对clobber分配相同的硬件寄存器，以及输入操作数。你可以破坏一个特定的硬件寄存器，一个伪寄存器，或者一个@code{scratch}表达式；在后两种情况下，GCC将会分配一个硬件寄存器，临时使用。

对于需要临时寄存器的指令，应该使用@code{scratch}，而不是伪寄存器，因为这将使得合并阶段可以在需要的时候增加@code{clobber}。方式为(@code{clobber} (@code{match_scratch} @dots{}))。如果确实是破坏了一个伪寄存器，则使用没有出现在其它地方的伪寄存器，每次生成一个新的。否则，你可能会使CSE（公共子表达式消除）迷惑。

还有一种在@code{parallel}中破坏伪寄存器的用法：当insn的输入操作数也被insn破坏。这种情况下，使用相同的伪寄存器。

@findex use
@item (use @var{x})
表示对@var{x}值的使用。其表示@var{x}中的值在程序的这个点上是被需要的，即使可能不清楚为什么。因此，如果先前的执行的作用只是将一个值存储在@var{x}中，则编译器将不会尝试将其删除。@var{x}必须为一个@code{reg}表达式。

在一些情况下，可能会想到，在@code{parallel}中增加一个对寄存器的@code{use}，来描述特定寄存器的值将会影响指令的行为。一个假定的例子为，对于一个加法指令模式，其可以根据特定的控制寄存器的值来执行环绕或者饱和加法：

@smallexample
(parallel [(set (reg:SI 2) (unspec:SI [(reg:SI 3)
                                       (reg:SI 4)] 0))
           (use (reg:SI 1))])
@end smallexample

@noindent

这将不会工作，一些优化器将只查看局部的表达式；很可能如果你有多个具有针对@code{unspec}相同输入的insn，它们将被优化掉，即使寄存器1中间有所改变。

这意味着，@code{use}只能被用于描述寄存器是活跃的。在增加@code{use}语句时，你应该多思考一下，通常，你将会使用@code{unspec}来替代。@code{use} RTX最常用于描述一个隐式的用于insn的固定寄存器。还可以安全的用于，编译器知道整个指令模式的结果是可变的，这样的指令模式中，例如@samp{movmem@var{m}}或者@samp{call}。

在重载阶段，具有@code{use}指令模式的insn可以附带一个reg_equal注解。这些@code{use} insn将在重载阶段退出之前被删除。

在延迟分支调度阶段，@var{x}可以为一个insn。这表示@var{x}之前曾经在该位置被定位，它的数据依赖需要被考虑。这些@code{use} insn将在延迟分支调度阶段退出之前被删除。

@findex parallel
@item (parallel [@var{x0} @var{x1} @dots{}])
表示并行执行多个副作用。方括号表示一个向量；@code{parallel}的操作数为向量表达式。@var{x0}, @var{x1}等等为单独的副作用表达式，@code{set}, @code{call}, @code{return}, @code{clobber} 或 @code{use}。

“并行”意味着，首先所有在单个副作用中使用的值将被计算，然后，所有实际的副作用被执行。例如，

@smallexample
(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])
@end smallexample

@noindent

清楚的说明了，将硬件寄存器1的值与其所寻址的内存中的值进行交换。在@code{(reg:SI 1)}作为内存地址出现的两个地方，其都是使用执行insn之前，在寄存器1中的值。

从而，如果使用@code{parallel}，并且期望@code{set}的值，可以用于下一个@code{set}，则是不正确的。例如，人们有时候尝试用这种方式来表示，为零则跳转的指令：

@smallexample
(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref @dots{})
                        (pc)))])
@end smallexample

@noindent
但这是不正确的，因为其说明了跳转条件取决于，该指令之前的条件代码的值，而不是被该指令设置后的新值。

@cindex peephole optimization, RTL representation
与最后的汇编代码输出一起执行的窥孔优化，可以产生由@code{parallel}组成的insn，其元素为需要输出汇编代码的操作数，通常为@code{reg}, @code{mem}或者常量表达式。这在其它编译阶段，将不是一个好的RTL形式，但是在这里是可以的，因为已经没有其它的优化了。然而，宏@code{NOTICE_UPDATE_CC}的定义，如果存在，如果定义了窥孔优化，则需要处理这样的insn。

@findex cond_exec
@item (cond_exec [@var{cond} @var{expr}])
表示一个条件执行表达式。只有当@var{cond}为非零时，@var{expr}才被执行。@var{cond}表达式不能具有副作用，但是@var{expr}可以。

@findex sequence
@item (sequence [@var{insns} @dots{}])
表示一个insn序列。每个出现在向量中的@var{insns}，都适合出现在insn链中，所以其必须为@code{insn}, @code{jump_insn}, @code{call_insn}, @code{code_label}, @code{barrier} 或 @code{note}。

在RTL生成过程中，不会在实际的insn中放入@code{sequence} RTX。其表示@code{define_expand}产生的insn序列，用来传递给@code{emit_insn}，从而将它们插入到insn链中。当实际被插入的时候，单独的子insn将被分离出来，@code{sequence}将被忽略掉。

当延迟槽调度完成之后，insn和所有位于其延迟槽中的insn被组成一个@code{sequence}。需要延迟槽的insn为向量中的第一个insn；后续的insn为将被放在延迟槽中的insn。

@code{INSN_ANNULLED_BRANCH_P}用来表示分支insn将会有条件的取消延迟槽中的insn的效果。这种情况下，@code{INSN_FROM_TARGET_P}表示insn是来自分支的目标，并且只有当进行分支时，其才被执行；否则，insn只有当不进行分支时才被执行。@zhxref{Delay
Slots}.

@end table

这些表达式代码出现在副作用的地方，作为insn的主体，虽然严格的讲，它们并不总是描述副作用：

@table @code
@findex asm_input
@item (asm_input @var{s})
表示文字的汇编代码，通过字符串@var{s}来描述。

@findex unspec
@findex unspec_volatile
@item (unspec [@var{operands} @dots{}] @var{index})
@itemx (unspec_volatile [@var{operands} @dots{}] @var{index})
表示一个机器特定的针对@var{operands}的操作。@var{index}在多个机器特定的操作之间进行选择。@code{unspec_volatile}用于volatile操作，并且可以有陷阱；@code{unspec}用于其它操作。

这些代码可以出现在insn的@code{pattern}中，@code{parallel}中，或者表达式中。

@findex addr_vec
@item (addr_vec:@var{m} [@var{lr0} @var{lr1} @dots{}])
表示跳转地址表。向量元素@var{lr0}等等，为@code{label_ref}表达式。机器模式@var{m}描述了为每个地址给定了多少空间；通常@var{m}为@code{Pmode}。

@findex addr_diff_vec
@item (addr_diff_vec:@var{m} @var{base} [@var{lr0} @var{lr1} @dots{}] @var{min} @var{max} @var{flags})
表示一个跳转地址表，表示为@var{base}的偏移量。向量元素@var{lr0}等等，为@code{label_ref}表达式，@var{base}也是。机器模式@var{m}描述了为每个地址偏移给定的空间大小。@var{min}和@var{max}由分支缩短过程设置，分别存放了一个具有最小地址和最大地址的标号。详情参见rtl.def。

@findex prefetch
@item (prefetch:@var{m} @var{addr} @var{rw} @var{locality})
表示对地址为@var{addr}的内存进行预取。如果预取的数据将被写，则操作数为@var{rw}，否则为0；不支持写预取的目标机，应该将其作为一个普通的预取。操作数@var{locality}描述了时间局部性的数量；如果没有，则为0，否则按照时间局部性的递增级别，依次为1，2或者3；不支持局部性暗示的目标机，应该忽略该项。

该insn用于最小化cache-miss的延迟，通过在访问数据之前将其移送到cache中。其应该只用于非故障的数据预取指令。

@end table

@node Incdec
@section 地址中嵌入的副作用
@cindex RTL preincrement
@cindex RTL postincrement
@cindex RTL predecrement
@cindex RTL postdecrement

有六个特定的副作用表达式代码作为内存地址出现。

@table @code
@findex pre_dec
@item (pre_dec:@var{m} @var{x})
表示该副作用为，@var{x}递减一个标准的数量，并且还表示了递减后的@var{x}的值。@var{x}必须为一个@code{reg}或者@code{mem}，但是大多数机器只允许@code{reg}。@var{m}必须为机器所使用的指针的机器模式。@var{x}被递减的数量为，所包含的内存引用的机器模式的长度，以字节为单位。这里有一个关于用法的例子：

@smallexample
(mem:DF (pre_dec:SI (reg:SI 39)))
@end smallexample

@noindent
这说明将伪寄存器39递减一个@code{DFmode}值的长度，并将结果用来对一个@code{DFmode}值进行寻址。

@findex pre_inc
@item (pre_inc:@var{m} @var{x})
类似的，用来说明递增@var{x}。

@findex post_dec
@item (post_dec:@var{m} @var{x})
表示与@code{pre_dec}相同的副作用，但表示不同的值。这里表示的值为递减@i{之前}的@var{x}的值。

@findex post_inc
@item (post_inc:@var{m} @var{x})
类似的，用来说明递增@var{x}。

@findex post_modify
@item (post_modify:@var{m} @var{x} @var{y})
表示该副作用为，将@var{x}设置为@var{y}，并且表示@var{x}被修改之前的值。@var{x}必须为一个@code{reg}或者@code{mem}，但是大多数机器只允许@code{reg}。@var{m}必须为机器所使用的指针的机器模式。

表达式@var{y}必须为下列三种形式之一：
@code{(plus:@var{m} @var{x} @var{z})},
@code{(minus:@var{m} @var{x} @var{z})}, 或者
@code{(plus:@var{m} @var{x} @var{i})},
其中@var{z}为一个索引寄存器，@var{i}为一个常量。

这里为一个有关用法的例子：

@smallexample
(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42)
                                          (reg:SI 48))))
@end smallexample

这说明在使用了伪寄存器42曾经指向的值之后，将伪寄存器42修改为，加上其伪寄存器48的内容，

@findex pre_modify
@item (pre_modify:@var{m} @var{x} @var{expr})
类似的，表示副作用在使用之前开始有效。
@end table

这些嵌入的副作用表达式在使用时要小心。指令模式可以不使用它们。在到达编译器的@samp{flow} pass之前，它们可能只出现在用于表示压栈。@samp{flow} pass查找寄存器在一条指令中被递增或递减，并且在之前或者之后被作为地址使用的情况；这些情况然后被转换成使用前增（减）或后增（减）。

如果这些表达式中作为操作数的寄存器，在一个insn中的另一个地址中使用，则会使用寄存器的原始的值。在地址之外使用寄存器是不被允许的，因为这样的insn在不同的机器上行为是不同的，因此会有歧义。

可以被表示成具有嵌入副作用的指令，也可以被表示成使用@code{parallel}，包含一个额外的@code{set}来描述地址寄存器如何被修改。

@node 汇编
@section 作为表达式的汇编指令
@cindex assembler instructions in RTL

@cindex @code{asm_operands}, usage
RTX代码@code{asm_operands}表示由用户特定的汇编指令所产生的值。其用来表示带有参数的@code{asm}语句。一个具有单个输出操作数的@code{asm}语句，如下：

@smallexample
asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));
@end smallexample

@noindent
其通过一个单个的@code{asm_operands} RTX来表示，其表示了存储在@code{outputvar}中的值：

@smallexample
(set @var{rtx-for-outputvar}
     (asm_operands "foo %1,%2,%0" "a" 0
                   [@var{rtx-for-addition-result} @var{rtx-for-*z}]
                   [(asm_input:@var{m1} "g")
                    (asm_input:@var{m2} "di")]))
@end smallexample

@noindent
这里，@code{asm_operands} RTX的操作数为汇编模板字符串，输出操作数的约束，在指定的输出操作数中的索引编号，一个输入操作数RTX向量，以及一个输出操作数机器模式和约束的向量。机器模式@var{m1}为@code{x+y}的和的机器模式；@var{m2}为@code{*z}的机器模式。
        
当@code{asm}语句具有多个输出值时，它的insn具有多个这样的@code{set} RTX，并位于一个@code{parallel}中。每个@code{set}包括了一个@code{asm_operands}；所有这些共享相同的汇编模板和向量，但是每个包含了相应的输出操作数的约束。它们也是通过输出操作数索引编号来区分的，即0，1@dots{}连续的输出操作数。

@node Insns
@section Insns
@cindex insns

一个函数的代码的RTL表示是一个被称作@dfn{insns}对象的双向链表。insn只不过是具有特定代码的表达式。有些insn是实际的指令；有些用来表示@code{switch}语句的派遣表。有些用来表示要调转的标号或者不同类别的声明信息。

除了本身特定的数据，每个insn必须有一个唯一的id号用来区别当前函数中其它的insn（经过分支延迟调度之后，具有相同id号的一个insn 的拷贝，可能会出现在一个函数中的多个地方，但是这些拷贝总是同样的，并且只是出现在一个@code{sequence}中），以及指向前面和后面insn的链表指针。这三个域在每个insn中占有相同的位置，并且独立于insn的表达式代码。它们可以通过@code{XEXP}和@code{XINT}来访问，不过，有三个特定的宏经常会被使用：

@table @code
@findex INSN_UID
@item INSN_UID (@var{i})
访问insn @var{i}的唯一id。

@findex PREV_INSN
@item PREV_INSN (@var{i})
访问指向@var{i}之前的insn的链表指针。如果@var{i}是第一个insn，则是一个null指针。 

@findex NEXT_INSN
@item NEXT_INSN (@var{i})
访问指向@var{i}之后的insn的链表指针。如果@var{i}是最后一个insn，则是一个null指针。 

@end table

@findex get_insns
@findex get_last_insn
链表中的第一个insn可以通过调用@code{get_insns}获得；最后一个insn可以通过调用@code{get_last_insn}来获得。在由这些insn界定的链中，@code{NEXT_INSN}和@code{PREV_INSN}指针必须总是相当：如果@var{insn} 不是第一个insn，则

@smallexample
NEXT_INSN (PREV_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
总是真，并且如果@var{insn}不是最后一个insn，则

@smallexample
PREV_INSN (NEXT_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
总是真。

在延迟槽调度之后，在链中的一些insn可能为@code{sequence}表达式，其包含了一个insn向量。这个向量中除了最后一个insn之外，其它insn的@code{NEXT_INSN}的值都是向量中的下一个insn；向量中的最后一个insn的@code{NEXT_INSN}的值，等于包含@code{sequence}的insn的@code{NEXT_INSN}的值。对于@code{PREV_INSN}，也有类似的规则。

这意味着上面的恒等式，对于在@code{sequence}表达式中的insn不需要成立。特别是，如果@var{insn}为@code{sequence}中的第一个insn，则@code{NEXT_INSN (PREV_INSN (@var{insn}))}为包含@code{sequence}表达式的insn，同样如果@var{insn}为@code{sequence}中的最后一个insn，则@code{PREV_INSN (NEXT_INSN (@var{insn}))}的值也是如此。你可以使用这些表达式来查找包含@code{sequence}的insn。

每个insn都具有下列六种表达式代码中的一个：

@table @code
@findex insn
@item insn
表达式代码@code{insn}用于不进行跳转和函数调用的指令。@code{sequence}表达式总是包含在表达式代码为@code{insn}的insn中，即使它们中的一个insn是跳转或者函数调用。

表达式代码为@code{insn}的insn，除了上面列出的三个必须的域以外，还具有四个额外的域。这四个域在后面的表中有描述。

@findex jump_insn
@item jump_insn
表达式代码@code{jump_insn}用于可能执行跳转（或者，更一般的讲，指令中可能包含了@code{label_ref}表达式，并用其来设置@code{pc}）的指令。如果有一条从当前函数返回的指令，则其被记录为@code{jump_insn}。

@findex JUMP_LABEL
@code{jump_insn}具有跟@code{insn}相同的额外的域，并使用同样的方式来访问，除此之外，还包含了一个域@code{JUMP_LABEL}，其当执行完跳转优化后被定义。

对于简单的条件跳转和无条件跳转，该域包含了该insn将（可能有条件的）分支跳转到的@code{code_label}。在更复杂的跳转中，@code{JUMP_LABEL}记录了insn引用的其中一个标号；其它跳转目标标号作为@code{REG_LABEL_TARGET}注解来记录。@code{addr_vec}和@code{addr_diff_vec}是例外的情况，对此，@code{JUMP_LABEL}为@code{NULL_RTX}，而只有扫描整个insn体干才能找到标号。

返回指令insn作为跳转看待，但由于它们并不引用任何标号，所以它们的@code{JUMP_LABEL}为@code{NULL_RTX}。

@findex call_insn
@item call_insn
表达式代码@code{call_insn}用于可能执行函数调用的指令。区分这些指令是很重要的，因为它们意味着特定的寄存器和内存位置可以被不可预知的方式改变。

@findex CALL_INSN_FUNCTION_USAGE
@code{call_insn}具有与@code{insn}相同的额外的域，并使用相同的方式访问，除此之外，还包含一个域@code{CALL_INSN_FUNCTION_USAGE}，其包含了一个列表（@code{expr_list}表达式链），包含了@code{use}和@code{clobber}表达式，表示了被调用函数使用和破坏的硬件寄存器和@code{MEM}。

一个@code{MEM}通常指向一个栈槽，参数在其中按照引用方式（@zhpxref{Register
Arguments,
TARGET_PASS_BY_REFERENCE}）传递给libcall。如果参数是caller-copied（@zhpxref{Register Arguments, TARGET_CALLEE_COPIES}），则栈槽会在@code{CLOBBER}和@code{USE}中被提到；如果是callee-copied，则只会出现@code{USE}，并且@code{MEM}可能指向不是栈槽的地址。

在列表中，被@code{CLOBBER}的寄存器，增加了在@code{CALL_USED_REGISTERS}中描述的寄存器（@zhpxref{Register Basics}）。

@findex code_label
@findex CODE_LABEL_NUMBER
@item code_label
@code{code_label} insn表示一个跳转insn可以跳转到的标号。除了三个标准的域以为，其还包含两个特定的域。@code{CODE_LABEL_NUMBER}用于存放@dfn{label number}，在编译过程中，唯一标识该标号。最终，标号在汇编输出中作为汇编标号来表示，通常的形式为@samp{L@var{n}}，其中@var{n}为标号编号。

当@code{code_label}出现在RTL表达式中，其通常出现在@code{label_ref}中，其表示了标号的地址，为一个编号。

除了作为@code{code_label}以外，标号还可以作为类型为@code{NOTE_INSN_DELETED_LABEL}的@code{note}来表示。

@findex LABEL_NUSES
域@code{LABEL_NUSES}只当完成跳转优化过程后才被定义。其包含了在当前函数中，该标号被引用的次数。

@findex LABEL_KIND
@findex SET_LABEL_KIND
@findex LABEL_ALT_ENTRY_P
@cindex alternate entry points
域@code{LABEL_KIND}用来区分四种不同类型的标号：@code{LABEL_NORMAL}，@code{LABEL_STATIC_ENTRY}，@code{LABEL_GLOBAL_ENTRY}和@code{LABEL_WEAK_ENTRY}。唯一不具有类型@code{LABEL_NORMAL}的标号，为当前函数的@dfn{alternate entry points}。这些可以为static（只在当前转换单元中可见），global（对所有的转换单元可见）或者weak（全局的，但是可以被另一个具有相同名字的符号覆盖）。

编译器大多将所有四种标号同等对待。有些地方需要知道标号是否为候选入口点；为此，提供了宏@code{LABEL_ALT_ENTRY_P}。其等价于测试是否@samp{LABEL_KIND (label) == LABEL_NORMAL}。除了前端创建static，global和weak alternate entry points的代码以外，其它唯一关心它们的区别的地方是@file{final.c}文件中的函数@code{output_alternate_entry_point}。

使用宏@code{SET_LABEL_KIND}来设置标号的种类。

@findex barrier
@item barrier
栅栏被放在指令流中，控制无法经过的地方。它们被放在无条件跳转指令的后面，表示跳转是无条件的，以及对@code{volatile}函数的调用之后，表示不会返回（例如，@code{exit}）。除了三个标准的域以外，不包含其它信息。

@findex note
@findex NOTE_LINE_NUMBER
@findex NOTE_SOURCE_FILE
@item note
@code{note} insns用于表示额外的调试和说明信息。它们包含两个非标准的域，一个使用宏@code{NOTE_LINE_NUMBER}访问的整数，以及一个使用@code{NOTE_SOURCE_FILE}访问的字符串。

如果@code{NOTE_LINE_NUMBER}是正的，则注解表示源文件行号，并且@code{NOTE_SOURCE_FILE}为源文件名。这些注解控制在汇编输出中的生成行号数据。

否则，@code{NOTE_LINE_NUMBER}不是一个行号，而是一个具有下列值之一的代码（并且@code{NOTE_SOURCE_FILE}必须包含一个空指针）：

@table @code
@findex NOTE_INSN_DELETED
@item NOTE_INSN_DELETED
这样的注解被完全忽略掉。编译器的一些过程会通过将insn修改成这种类型的注解，来删除insn。

@findex NOTE_INSN_DELETED_LABEL
@item NOTE_INSN_DELETED_LABEL
标记了曾经为@code{code_label}，但现在只用于获得其地址，并且没有代码会跳转到这里。

@findex NOTE_INSN_BLOCK_BEG
@findex NOTE_INSN_BLOCK_END
@item NOTE_INSN_BLOCK_BEG
@itemx NOTE_INSN_BLOCK_END
这些类型的注解表示处于变量名作用域的起始和结束。它们控制调试信息的输出。

@findex NOTE_INSN_EH_REGION_BEG
@findex NOTE_INSN_EH_REGION_END
@item NOTE_INSN_EH_REGION_BEG
@itemx NOTE_INSN_EH_REGION_END
这些类型的注解表示处于异常处理作用域的起始和结束。@code{NOTE_BLOCK_NUMBER}标识了哪一个类型为@code{NOTE_INSN_DELETED_LABEL}的@code{CODE_LABEL}或@code{note}与给定的区域相关联。

@findex NOTE_INSN_LOOP_BEG
@findex NOTE_INSN_LOOP_END
@item NOTE_INSN_LOOP_BEG
@itemx NOTE_INSN_LOOP_END
这些类型的注解表示处于@code{while}或者@code{for}循环的起始和结束。它们使得循环优化可以快速的发现循环。

@findex NOTE_INSN_LOOP_CONT
@item NOTE_INSN_LOOP_CONT
出现在循环中@code{continue}语句跳转的地方。

@findex NOTE_INSN_LOOP_VTOP
@item NOTE_INSN_LOOP_VTOP
该注解表示循环中退出测试（exit test）起始的地方，并且退出测试在循环中被复制。当考虑循环不变量时，该位置为循环的另一个虚拟起始点。

@findex NOTE_INSN_FUNCTION_BEG
@item NOTE_INSN_FUNCTION_BEG
出现在函数序言之后，函数体的起始处。

@end table

在调试转储中，这些代码被符号化的打印。
@end table

@cindex @code{TImode}, in @code{insn}
@cindex @code{HImode}, in @code{insn}
@cindex @code{QImode}, in @code{insn}
insn的机器模式通常为@code{VOIDmode}，但有些阶段出于不同的目的而使用其它机器模式。

公共子表达式消除过程将一个insn的机器模式设为@code{QImode}，当其为已经被处理过的块中的第一个insn时。

第二次Haifa调度过程中，对于可以多发射的目标机，当insn被认为是一个发射组合中的起始指令时，将其机器模式设为@code{TImode}。也就是说，该指令不能和之前的指令同时发射。这可以在后面的过程中用到，特别是机器特定的reorg。

下面的表中列出了@code{insn}, @code{jump_insn}和@code{call_insn}的其它域：

@table @code
@findex PATTERN
@item PATTERN (@var{i})
一个表达式，为该insn执行的副作用。必须为下列代码中的一个：@code{set}, @code{call}, @code{use}, @code{clobber}, @code{return}, @code{asm_input}, @code{asm_output}, @code{addr_vec}, @code{addr_diff_vec}, @code{trap_if}, @code{unspec}, @code{unspec_volatile}, @code{parallel}, @code{cond_exec}或@code{sequence}。如果其为@code{parallel}，则@code{parallel}中的每个元素必须是这些代码中的一个，并且，@code{parallel}表达式不能被嵌套，@code{addr_vec}和@code{addr_diff_vec}不允许在@code{parallel}表达式中。

@findex INSN_CODE
@item INSN_CODE (@var{i})
一个整数，说明机器描述中的哪一个指令模式匹配该insn，或者，如果还没有进行匹配，则为@minus{}1。

对于指令模式由单个@code{use}, @code{clobber}, @code{asm_input}, @code{addr_vec} 或 @code{addr_diff_vec}表达式组成的insn，则不会进行这样的匹配，并且该域保持为@minus{}1。

@findex asm_noperands
对于来自@code{asm}语句的insn，也不会进行指令模式匹配。这些至少包含了一个@code{asm_operands}表达式。函数@code{asm_noperands}为这样的insn返回一个非负的值。

在调试输出中，该域被打印成一个数字，紧随一个符号表示，用来定位在@file{md}中的指令模式，数字表示相对命名指令模式的正的或者负的偏移量。

@findex LOG_LINKS
@item LOG_LINKS (@var{i})
一个列表（@code{insn_list}表达式链），给出了基本块中指令之间的依赖信息。相关联的insn之间不会有跳转或者标号。这些只被用于指令调度和组合。这是一个不被推荐的数据结构。现在推荐使用def-use和use-def链。

@findex REG_NOTES
@item REG_NOTES (@var{i})
一个列表（@code{expr_list}和@code{insn_list}表达式链），给出了insn的其它信息。通常为从属于该insn使用的寄存器的信息。

@end table

insn的@code{LOG_LINKS}域为@code{insn_list}表达式链。每一个都具有两个操作数：第一个为insn，第二个为另一个@code{insn_list}表达式（链中的下一个）。链中的最后一个@code{insn_list}的第二个操作数为空指针。对于表达式链，重要的是有哪些insn（@code{insn_list}表达式的第一个操作数）。它们的顺序并不重要。

该列表最初由流分析过程建立；在此之前还只是空指针。流分析只将那些可以用于指令合并的数据依赖，加入到列表中。

insn的@code{REG_NOTES}域是一个类似于@code{LOG_LINKS}域的链，不过除了@code{insn_list}表达式，其还包含@code{expr_list}表达式。有多种寄存器注解，其通过机器模式区分。注解的第一个操作数@var{op}的含义依赖注解的种类。

@findex REG_NOTE_KIND
@findex PUT_REG_NOTE_KIND
宏@code{REG_NOTE_KIND (@var{x})}返回寄存器注解的种类。宏@code{PUT_REG_NOTE_KIND (@var{x}, @var{newkind})}将@var{x}的寄存器注解类型设置为@var{newkind}。

寄存器注解有三种类别：可以用来说明insn的输入，可以用来说明insn的输出，或者可以用来创建两个insn之间的连接。还有一个值集，只用于@code{LOG_LINKS}中。

这些注解用来说明insn的输入：

@table @code
@findex REG_DEAD
@item REG_DEAD
@var{op}中的值在该insn中死掉；也就是说，紧接这个insn之后，修改该值将不会影响程序将来的行为。

这并不是说从该insn之后，寄存器@var{op}就没有有用的值了。而是说，后续的指令不会用到@var{op}的内容。

@findex REG_UNUSED
@item REG_UNUSED
被该insn设置的寄存器@var{op}，将不会在后续的insn中使用。这与@code{REG_DEAD}注解不同，后者表示输入中的值将不会被后续insn使用。这两个注解是不相关的；可能会都出现在同一个寄存器中。

@findex REG_INC
@item REG_INC
寄存器@var{op}由于insn中嵌入的副作用，而被递增（或递减）。这意味着其出现在@code{post_inc}, @code{pre_inc}, @code{post_dec}或@code{pre_dec}表达式中。

@findex REG_NONNEG
@item REG_NONNEG
寄存器@var{op}在到达该insn的时候，被已知为具有一个非负的值。对于递减并分支跳转，直到为零的指令，例如m68k dbra，可以用来进行匹配。

@code{REG_NONNEG}注解，只有当机器描述具有@samp{decrement_and_branch_until_zero}指令模式的时候，才被加到insn中。

@findex REG_LABEL_OPERAND
@item REG_LABEL_OPERAND
该insn使用@var{op}，一个类型为@code{NOTE_INSN_DELETED_LABEL}的@code{code_label}或者@code{note}，但是不为@code{jump_insn}。或者，其为一个将操作数作为普通操作数的@code{jump_insn}。标号最终也可以为跳转目标，但这是在后续insn的间接跳转中。该注解使得跳转优化知道@var{op}实际上被使用了，从而流优化可以创建一个精确的流图。

@findex REG_LABEL_TARGET
@item REG_LABEL_TARGET
该insn为一个@code{jump_insn}，但不是@code{addr_vec}和@code{addr_diff_vec}。其使用@var{op}，一个@code{code_label}，作为直接或间接跳转的目标。其用途与@code{REG_LABEL_OPERAND}类似。该注解只存在于当insn具有多个目标的时候；insn中的最后一个标号（在最高编号的insn域中），放到@code{JUMP_LABEL}域中，并且没有@code{REG_LABEL_TARGET}。@zhxref{Insns, JUMP_LABEL}.

@findex REG_CROSSING_JUMP
@item REG_CROSSING_JUMP
该insn为一个分支指令（无条件跳转或者间接跳转），其穿越了热代码段和冷代码段，并可能潜在的位于可执行程序中非常远的部分。该注解用来指示其它优化，表示该分支指令不应该被折叠为简单的分支结构。其用于当优化将基本块分成热代码段和冷代码段的时候。

@findex REG_SETJMP
@item REG_SETJMP 
附加在每个针对@code{setjmp}或者相关的函数的@code{CALL_INSN}上。

@end table

下列注解描述了有关insn的输出的属性：

@table @code
@findex REG_EQUIV
@findex REG_EQUAL
@item REG_EQUIV
@itemx REG_EQUAL
该注解只用在只设置一个寄存器的insn上，用来表示那个寄存器在运行时等价于@var{op}；该等值的作用域根据两种类型的注解而有所不同。insn显式的复制进寄存器的值可能看起来与@var{op}不同，但它们将在运行时相等。如果单个@code{set}的输出为一个@code{strict_low_part}表达式，则注解是用于@code{subreg}表达式@code{SUBREG_REG}所包含的寄存器。

对于@code{REG_EQUIV}，在整个函数中，寄存器都等价于@var{op}，并且可以在其所有出现的地方被@var{op}有效替换。（有效，这里是指程序的数据流；简单的替换可能会使得某些insn无效。）例如，当一个常量被加载到一个寄存器中，并且寄存器不再被赋予任何其它值，则会使用这种注解。

当在函数入口处，一个参数被复制到一个伪寄存器中时，这种的注解会用来记录该寄存器等价于传递参数的栈槽。虽然，这种情况下，寄存器可能被其它的insn设置，其也可以在整个函数中被栈槽来替换。

@code{REG_EQUIV}注解还用于，在函数入口处，将一个寄存器参数复制到一个伪寄存器中的指令，如果存在一个参数本来应该被存放的栈槽。虽然其它insn可以设置该伪寄存器，但编译器还是可以在整个函数中，使用栈槽来替换伪寄存器，假设编译器可以确保栈槽被适当的初始化。这被用于调用约定为寄存器参数分配栈空间的机器上。参见@ref{Stack Arguments}中的@code{REG_PARM_STACK_SPACE}。

对于@code{REG_EQUAL}的情况，被该insn设置的寄存器，将在运行时，在该insn的结尾处，但不必要是函数的其它地方，等价与@var{op}。这种情况下，@var{op}通常为一个算术表达式。例如，当一个库调用的insn序列，被用在一个算术运算上，则该类的注解将被附加在产生或者复制最终值的insn上。

这两个注解在编译器过程中，按照不同的方法来使用。@code{REG_EQUAL}用于寄存器分配之前的过程中（例如公共子表达式消除和循环优化），来告诉它们如何考虑那个值。@code{REG_EQUIV}注解用于寄存器分配，来表示存在一个可用的替换表达式（为栈上一个参数位置的常量或者@code{mem}表达式），其可以用在没有足够寄存器的地方。

除了为参数提供地方的栈以外，其它所有等值最初都是通过附加一个@code{REG_EQUAL}注解来表示。在寄存器分配的早期阶段，如果@var{op}是一个常量并且insn只表示对其目的寄存器进行设置，则@code{REG_EQUAL}被改变成@code{REG_EQUIV}注解。

因此，寄存器分配之前的编译过程，只需要检查@code{REG_EQUAL}注解，而之后的编译过程只需要检查@code{REG_EQUIV}注解。

@end table

这些注解描述了insn之间的联系。它们成对的出现：一个insn具有一对注解，其中之一用来指向第二个insn，并且第二个insn也由一个反过来指向第一个insn的注解。

@table @code
@findex REG_CC_SETTER
@findex REG_CC_USER
@item REG_CC_SETTER
@itemx REG_CC_USER
在使用@code{cc0}的机器上，设置和使用@code{cc0}的insns是相邻的。然而，当做完分支延迟槽填充之后，就不一定是这样的了。这种情况下，@code{REG_CC_USER}注解将被放在设置@code{cc0}的insn上，来指向使用@code{cc0}的insn，并且@code{REG_CC_SETTER}注解将被放在使用@code{cc0}的insn上，来指向设置@code{cc0}的insn。

@end table

这些值只用在@code{LOG_LINKS}域，用来表示每个链接表示的依赖类型。表示一个数据依赖（写后读依赖）的链接，不使用任何代码，它们只是简单的具有@code{VOIDmode}模式，并在打印输出中没有任何描述文本。

@table @code
@findex REG_DEP_TRUE
@item REG_DEP_TRUE
这表示一个真依赖（写后读依赖）。

@findex REG_DEP_OUTPUT
@item REG_DEP_OUTPUT
这表示一个输出依赖（写后写依赖）。

@findex REG_DEP_ANTI
@item REG_DEP_ANTI
这表示一个反依赖（读后写依赖）。

@end table

这些注解描述了从gcov profile数据中搜集的信息。它们作为@code{expr_list}存储在insn的@code{REG_NOTES}域中。

@table @code
@findex REG_BR_PROB
@item REG_BR_PROB
用于指定分支跳转率，根据profile数据。值位于0和REG_BR_PROB_BASE之间；较大的值表示该分支更可能会被执行。

@findex REG_BR_PRED
@item REG_BR_PRED
这些注解在JUMP insn中，并出现在延迟分支调度之后。它们表示JUMP的方向和可能性。格式为ATTR_FLAG_*值的掩码。

@findex REG_FRAME_RELATED_EXPR
@item REG_FRAME_RELATED_EXPR
用在RTX_FRAME_RELATED_P insn上，其附加的表达式被用在实际的insn模式上。这用于指令模式过于复杂或者产生误解的情况。

@end table

为方便起见，在@code{insn_list}或者@code{expr_list}中的机器模式，在调试转储中使用这些符号化的代码来打印。

@findex insn_list
@findex expr_list
表达式代码@code{insn_list}和@code{expr_list}之间的唯一区别是，@code{insn_list}的第一个操作数被假设为一个insn，并在调试转储中作为insn的唯一id来打印；而@code{expr_list}的第一个操作数作为表达式，按照普通的方式来打印。

@node 函数调用
@section 函数调用insns的RTL表示
@cindex calling functions in RTL
@cindex RTL function-call insns
@cindex function-call insns

调用子程序的Insn具有RTL表达式代码@code{call_insn}。这些insn必须满足特别的规则，并且它们的主体必须使用特定的RTL表达式代码@code{call}。

@cindex @code{call} usage
@code{call}表达式有两个操作数，如下：

@smallexample
(call (mem:@var{fm} @var{addr}) @var{nbytes})
@end smallexample

@noindent
这里@var{nbytes}操作数表示传递给子程序的参数的字节数，@var{fm}是一个机器模式（其必须与在机器描述中定义的@code{FUNCTION_MODE}相等），@var{addr}表示子程序的地址。

对于子程序没有返回值的，上面所示的@code{call}表达式是insn的整个主体，除了insn可能还会包含@code{use}或@code{clobber}表达式。

@cindex @code{BLKmode}, and function return values
对于子程序返回不是@code{BLKmode}模式的值的，值通过硬件寄存器返回。如果该寄存器号为@var{r}，则call insn的主体看起来是这样的：

@smallexample
(set (reg:@var{m} @var{r})
     (call (mem:@var{fm} @var{addr}) @var{nbytes}))
@end smallexample

@noindent
该RTL表达式很清楚的说明了（对于优化阶段），在该insn中有一个适当的寄存器用来接受一个有用的值。

当子程序返回@code{BLKmode}值时，将会通过传递给子程序用来存储返回值的地址来处理。因次，call insn本身不返回任何值，具有和没有返回值一样的RTL。

在一些机器上，调用指令本身会破坏一些寄存器，例如包含了返回地址。这些机器上的@code{call_insn}应该有一个@code{parallel}主体，包含了@code{call}表达式和@code{clobber}表达式，用来指示哪些寄存器会被破坏。类似的，如果调用指令需要栈指针之外的一些寄存器，并且没有在其RTL中显示提到的，则应该用@code{use}子表达式来指出。

被调用的函数被假设为会修改列在配置宏@code{CALL_USED_REGISTERS}（@zhpxref{Register Basics}）中的所有寄存器，并且除了const函数和库函数调用外，被假设为会修改所有的内存。

直接在@code{call_insn}之前的只是包含了@code{use}表达式的insn，用来指示哪些寄存器用来存放函数的输入。类似的，如果不在@code{CALL_USED_REGISTERS}中那些寄存器会被所调用的函数破坏，紧跟在call之后的包含了单独的@code{clobber}的insn，用来指出这些寄存器。

@node 共享
@section 结构共享假设
@cindex sharing of RTL components
@cindex RTL structure sharing assumptions

编译器假设某些类型的RTL表达式是唯一的；不会存在两个不同的对象表示相同的值。对于其它情况，有相反的假设：在被包含的结构体中，不会在多个地方出现某一类型的RTL表达式对象。

这些假设针对于一个单独的函数；除了描述全局变量和外部函数的RTL对象，一些标准对象，例如小整形常数以外，没有其它RTL对象可以在两个函数中共用。

@itemize @bullet
@cindex @code{reg}, RTL sharing
@item
每一个伪寄存器只有一个单独的@code{reg}对象来表示，因此也只有一种机器模式。

@cindex symbolic label
@cindex @code{symbol_ref}, RTL sharing
@item
对于任何标号，只有一个@code{symbol_ref}对象关联。

@cindex @code{const_int}, RTL sharing
@item
所有具有相同值的@code{const_int}表达式被共享。

@cindex @code{pc}, RTL sharing
@item
T只有一个@code{pc}表达式。

@cindex @code{cc0}, RTL sharing
@item
只有一个@code{cc0}表达式。

@cindex @code{const_double}, RTL sharing
@item
对于每一种浮点模式，只有一个@code{const_double}表达式其值为0。同样对于值1，2。

@cindex @code{const_vector}, RTL sharing
@item
对于每一种向量模式，只有一个@code{const_vector}表达式其值为0。其为整数或者双精度常量向量。

@cindex @code{label_ref}, RTL sharing
@cindex @code{scratch}, RTL sharing
@item
在RTL结构体中不会在多个地方出现@code{label_ref}或@code{scratch}；换句话说，对函数中所有insn进行树遍历时，可以认为每次遇到的@code{label_ref}或者@code{scratch}都与在其它地方遇到的不同。

@cindex @code{mem}, RTL sharing
@item
对于每个静态变量或者栈槽，通常只创建一个@code{mem}对象，所以这些对象在它们出现的所有地方被共享。然而，有时会为这些变量创建单独的，但是相等的对象。

@cindex @code{asm_operands}, RTL sharing
@item
当一个单独的@code{asm}语句具有多个输出操作数时，会为每一个输出数创建一个不同的@code{asm_operands}表达式。然后，这些表达式都共享包含着输入操作数序列的向量。这是为了之后用于测试两个@code{asm_operands}表达式是否来自同一语句，所以，所有的优化当进行复制整个向量时，必须仔细保持共享。

@item
除了上面描述的以外，在RTL结构体中没有其它RTL对象会出现多次。编译器的许多遍扫描，都是依赖于这样的假设，即它们能在一个地方修改RTL对象，并且不会对其它insn产生不需要的副作用。

@findex unshare_all_rtl
@item
在最初的RTL生成过程中，可以随意使用共享结构。当一个函数的所有RTL都被生成之后，所有的共享结构体都被@file{emit-rtl.c}中的@code{unshare_all_rtl}进行复制，之后，将保证上面的规则会被遵循。

@findex copy_rtx_if_shared
@item
在合并阶段，共享结构体可以在insn中临时存在。但是，在insn的合并完成之前，共享结构会被复制，通过调用@code{unshare_all_rtl}的子程序@code{copy_rtx_if_shared}。

@end itemize

@node 读取RTL
@section 读取RTL

若要从文件中读取RTL对象，可以调用@code{read_rtx}。
它接受一个参数，stdio标准输入输出流，并且返回一个RTL对象。
该函数在@file{read-rtl.c}中定义。
它只在通过机器描述来生成编译器后端的各种程序中使用，编译器本身并没有用到。

人们经常想到使用以文本方式存储在文件中的RTL来作为语言前端和GCC主干之间的接口。
这种想法其实是不可行的。

GCC一度被设计为只是在内部使用RTL。对于给定的程序，
RTL正确与否与特定的目标机器非常有关系。而且RTL并不包含程序的所有信息。

对于GCC和一个新语言前端接口的恰当方式，
是使用在文件@file{tree.h}和@file{tree.def}中描述的“tree”数据结构。
关于该结构的文档（参见 @ref{Trees}）不是很全面。
