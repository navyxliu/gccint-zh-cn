@c Copyright (C) 1988, 1989, 1992, 1994, 1997, 1998, 1999, 2000, 2001, 2002,
@c 2003, 2004, 2005, 2006, 2007, 2008, 2010
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@en @node RTL
@en @chapter RTL Representation
@node RTL
@chapter RTL表示
@cindex RTL representation
@cindex representation of RTL
@cindex Register Transfer Language (RTL)

@en The last part of the compiler work is done on a low-level intermediate
@en representation called Register Transfer Language.  In this language, the
@en instructions to be output are described, pretty much one by one, in an
@en algebraic form that describes what the instruction does.
编译器的大部分工作都是基于一种中间表示，叫做寄存器传送语言（register transfer language）。在该语言中，描述了将要输出的指令，并且差不多是按照字母顺序一个一个的来描述指令的行为。

@en RTL is inspired by Lisp lists.  It has both an internal form, made up of
@en structures that point at other structures, and a textual form that is used
@en in the machine description and in printed debugging dumps.  The textual
@en form uses nested parentheses to indicate the pointers in the internal form.
RTL的灵感来自Lisp列表。它同时具有一个内部形式，由指向结构体的结构体组成，以及一个文本形式，用在机器描述和打印的调试输出中。文本形式使用嵌套的括号，来表示内部形式中的指针。

@en @menu
@en * RTL Objects::       Expressions vs vectors vs strings vs integers.
@en * RTL Classes::       Categories of RTL expression objects, and their structure.
@en * Accessors::         Macros to access expression operands or vector elts.
@en * Special Accessors:: Macros to access specific annotations on RTL.
@en * Flags::             Other flags in an RTL expression.
@en * Machine Modes::     Describing the size and format of a datum.
@en * Constants::         Expressions with constant values.
@en * Regs and Memory::   Expressions representing register contents or memory.
@en * Arithmetic::        Expressions representing arithmetic on other expressions.
@en * Comparisons::       Expressions representing comparison of expressions.
@en * Bit-Fields::        Expressions representing bit-fields in memory or reg.
@en * Vector Operations:: Expressions involving vector datatypes.
@en * Conversions::       Extending, truncating, floating or fixing.
@en * RTL Declarations::  Declaring volatility, constancy, etc.
@en * Side Effects::      Expressions for storing in registers, etc.
@en * Incdec::            Embedded side-effects for autoincrement addressing.
@en * Assembler::         Representing @code{asm} with operands.
@en * Debug Information:: Expressions representing debugging information.
@en * Insns::             Expression types for entire insns.
@en * Calls::             RTL representation of function call insns.
@en * Sharing::           Some expressions are unique; others *must* be copied.
@en * Reading RTL::       Reading textual RTL from a file.
@en @end menu
@menu
* RTL Objects::		表达式、向量、字符串、整数 
* RTL Classes::		RTL表达式对象的类别，以及它们的结构 
* Accessors::		用来访问表达式操作数和向量成员的宏
* Special Accessors::	用来访问RTL中的特殊注解
* Flags::		RTL表达式中的其它标记
* Machine Modes::	描述一个数据的大小和格式
* Constants::		常数值表达式
* Regs and Memory::	表示寄存器内容或内存的表达式
* Arithmetic::		表示算术运算的表达式 
* Comparisons::		表示比较运算的表达式
* Bit-Fields::		表示内存或寄存器中位域的表达式
* Vector Operations::	关于向量数据类型的表达式
* Conversions::		扩展，截断，浮点化或者定点化
* RTL Declarations::	声明为volatile的，constant的，等等
* Side Effects::	存储到寄存器的表达式，等
* Incdec::		自动增量寻址的嵌入的副作用
* Assembler::		表示带有操作数的asm
* Debug Information::	表示调试信息的表达式
* Insns::		整个insn的表达式类型
* Calls::		函数call insn的RTL表示
* Sharing::		一些表达式是唯一的；其它的必须要被复制
* Reading RTL::		从文件中读取文本的RTL
@end menu

@en @node RTL Objects
@en @section RTL Object Types
@node RTL Objects
@section RTL对象类型
@cindex RTL object types

@cindex RTL integers
@cindex RTL strings
@cindex RTL vectors
@cindex RTL expression
@cindex RTX (See RTL)
@en RTL uses five kinds of objects: expressions, integers, wide integers,
@en strings and vectors.  Expressions are the most important ones.  An RTL
@en expression (``RTX'', for short) is a C structure, but it is usually
@en referred to with a pointer; a type that is given the typedef name
@en @code{rtx}.
RTL使用五种对象：表达式、整数、宽整数、字符串和向量。其中，最重要的是表达式。RTL 表达式（简称RTX）是一个C结构体，通常用指针来引用它。这种引用它的指针的类型定义名为@code{rtx}。

@en An integer is simply an @code{int}; their written form uses decimal
@en digits.  A wide integer is an integral object whose type is
@en @code{HOST_WIDE_INT}; their written form uses decimal digits.
整数就是C中的@code{int}，书写形式使用十进制表示。宽整数是@code{HOST_WIDE_INT}类型的一个整数对象，其书写形式也用十进制表示。

@en A string is a sequence of characters.  In core it is represented as a
@en @code{char *} in usual C fashion, and it is written in C syntax as well.
@en However, strings in RTL may never be null.  If you write an empty string in
@en a machine description, it is represented in core as a null pointer rather
@en than as a pointer to a null character.  In certain contexts, these null
@en pointers instead of strings are valid.  Within RTL code, strings are most
@en commonly found inside @code{symbol_ref} expressions, but they appear in
@en other contexts in the RTL expressions that make up machine descriptions.
字符串为一串字符，在存储器中以C的@code{char *}形式表示且按C语法规定书写。然而，RTL中的字符串决不会为空值。若机器描述中有一空字符串，它在存储器中则表示成一个空指针而不是通常意义上的指向空字符的指针。在某些上下文中，允许用这种空指针表示空字符串。在RTL代码中，字符串经常出现在@code{symbol_ref}表达式中，但也出现在某些机器描述的RTL表达式中。

@en In a machine description, strings are normally written with double
@en quotes, as you would in C@.  However, strings in machine descriptions may
@en extend over many lines, which is invalid C, and adjacent string
@en constants are not concatenated as they are in C@.  Any string constant
@en may be surrounded with a single set of parentheses.  Sometimes this
@en makes the machine description easier to read.
在机器描述中，字符串通常是双引号表示，就和C一样。但是，机器描述中的字符串可以跨越多个行，这在C中是无效的，而且邻接的字符串常量的联接方式和C中的不一样。任何字符串常量都可以使用一对括号包裹。有些时候，这样使得机器描述读起来更容易一些。

@en There is also a special syntax for strings, which can be useful when C
@en code is embedded in a machine description.  Wherever a string can
@en appear, it is also valid to write a C-style brace block.  The entire
@en brace block, including the outermost pair of braces, is considered to be
@en the string constant.  Double quote characters inside the braces are not
@en special.  Therefore, if you write string constants in the C code, you
@en need not escape each quote character with a backslash.
对于字符串，还有一种特殊的语法，用于在机器描述中嵌入C代码。只要字符串可以出现的地方，都可以书写一个C风格的大括号代码块。整个大括号代码块，包括最外面的一对括号，被作为字符串常量看待。括号里面的双引号字符不是特殊字符。因此，如果你在C代码中书写字符串常量，则不需要使用反斜杠来转义每个引号字符。

@en A vector contains an arbitrary number of pointers to expressions.  The
@en number of elements in the vector is explicitly present in the vector.
@en The written form of a vector consists of square brackets
@en (@samp{[@dots{}]}) surrounding the elements, in sequence and with
@en whitespace separating them.  Vectors of length zero are not created;
@en null pointers are used instead.
向量包含任意数目的指向表达式的指针。向量中元素的个数，在向量中显式的存在。向量的书写形式为，方括号（@samp{[@dots{}]}），里面是元素，并使用空格分隔。长度为0的向量不会被创建；而是使用空指针来替代。

@cindex expression codes
@cindex codes, RTL expression
@findex GET_CODE
@findex PUT_CODE
@en Expressions are classified by @dfn{expression codes} (also called RTX
@en codes).  The expression code is a name defined in @file{rtl.def}, which is
@en also (in uppercase) a C enumeration constant.  The possible expression
@en codes and their meanings are machine-independent.  The code of an RTX can
@en be extracted with the macro @code{GET_CODE (@var{x})} and altered with
@en @code{PUT_CODE (@var{x}, @var{newcode})}.
表达式根据@dfn{expression codes}来划分类别（也称作RTX代码）。表达式代码为在@file{rtl.def}中定义的一个名字，其也是一个（大写的）C枚举常量。合理的表达式代码以及它们的含义，是机器无关的。RTX的代码可以使用宏@code{GET_CODE (@var{x})}来抽取，以及使用@code{PUT_CODE (@var{x}, @var{newcode})}来修改。

@en The expression code determines how many operands the expression contains,
@en and what kinds of objects they are.  In RTL, unlike Lisp, you cannot tell
@en by looking at an operand what kind of object it is.  Instead, you must know
@en from its context---from the expression code of the containing expression.
@en For example, in an expression of code @code{subreg}, the first operand is
@en to be regarded as an expression and the second operand as an integer.  In
@en an expression of code @code{plus}, there are two operands, both of which
@en are to be regarded as expressions.  In a @code{symbol_ref} expression,
@en there is one operand, which is to be regarded as a string.
表达式代码决定了表达式包含了多少个操作数，以及它们都是什么对象。在RTL中，不像Lisp，你不能通过查看一个操作数来得知它是什么对象。替代的，你必须通过它的上下文来知道——通过所包含的表达式的表达式代码。例如，在一个表达式代码为@code{subreg}的表达式中，第一个操作数被作为一个表达式，第二个操作数为一个整数。在代码为@code{plus}的表达式中，有两个操作数，都作为表达式。在@code{symbol_ref}表达式中，有一个操作数，作为一个字符串。

@en Expressions are written as parentheses containing the name of the
@en expression type, its flags and machine mode if any, and then the operands
@en of the expression (separated by spaces).
表达式被书写为，一对括号，包含了表达式类型的名字，它的标记和机器模式（如果存在的话），然后是表达式的操作数（通过空格分隔）。

@en Expression code names in the @samp{md} file are written in lowercase,
@en but when they appear in C code they are written in uppercase.  In this
@en manual, they are shown as follows: @code{const_int}.
表达式代码名，在@samp{md}文件中按小写形式书写，但在C代码中出现时按大写形式书写。在这个手册里，它们按照如下形式表示：@code{const_int}。

@cindex (nil)
@cindex nil
@en In a few contexts a null pointer is valid where an expression is normally
@en wanted.  The written form of this is @code{(nil)}.
在一些上下文中，表达式通常会需要一个空指针。这种书写形式为@code{(nil)}。

@en @node RTL Classes
@en @section RTL Classes and Formats
@node RTL Classes
@section RTL类别和格式
@cindex RTL classes
@cindex classes of RTX codes
@cindex RTX codes, classes of
@findex GET_RTX_CLASS

@en The various expression codes are divided into several @dfn{classes},
@en which are represented by single characters.  You can determine the class
@en of an RTX code with the macro @code{GET_RTX_CLASS (@var{code})}.
@en Currently, @file{rtl.def} defines these classes:
不同的表达式代码被分为几个类别（@dfn{classes}），其有单个字符表示。你可以使用宏@code{GET_RTX_CLASS (@var{code})}来确定RTX代码的类别。当前，@file{rtl.def}定义了这些类别：

@en @table @code
@en @item RTX_OBJ
@en An RTX code that represents an actual object, such as a register
@en (@code{REG}) or a memory location (@code{MEM}, @code{SYMBOL_REF}).
@en @code{LO_SUM}) is also included; instead, @code{SUBREG} and
@en @code{STRICT_LOW_PART} are not in this class, but in class @code{x}.
@en 
@en @item RTX_CONST_OBJ
@en An RTX code that represents a constant object.  @code{HIGH} is also
@en included in this class.
@en 
@en @item RTX_COMPARE
@en An RTX code for a non-symmetric comparison, such as @code{GEU} or
@en @code{LT}.
@en 
@en @item RTX_COMM_COMPARE
@en An RTX code for a symmetric (commutative) comparison, such as @code{EQ}
@en or @code{ORDERED}.
@en 
@en @item RTX_UNARY
@en An RTX code for a unary arithmetic operation, such as @code{NEG},
@en @code{NOT}, or @code{ABS}.  This category also includes value extension
@en (sign or zero) and conversions between integer and floating point.
@en 
@en @item RTX_COMM_ARITH
@en An RTX code for a commutative binary operation, such as @code{PLUS} or
@en @code{AND}.  @code{NE} and @code{EQ} are comparisons, so they have class
@en @code{<}.
@en 
@en @item RTX_BIN_ARITH
@en An RTX code for a non-commutative binary operation, such as @code{MINUS},
@en @code{DIV}, or @code{ASHIFTRT}.
@en 
@en @item RTX_BITFIELD_OPS
@en An RTX code for a bit-field operation.  Currently only
@en @code{ZERO_EXTRACT} and @code{SIGN_EXTRACT}.  These have three inputs
@en and are lvalues (so they can be used for insertion as well).
@en @xref{Bit-Fields}.
@en 
@en @item RTX_TERNARY
@en An RTX code for other three input operations.  Currently only
@en @code{IF_THEN_ELSE} and @code{VEC_MERGE}.
@en 
@en @item RTX_INSN
@en An RTX code for an entire instruction:  @code{INSN}, @code{JUMP_INSN}, and
@en @code{CALL_INSN}.  @xref{Insns}.
@en 
@en @item RTX_MATCH
@en An RTX code for something that matches in insns, such as
@en @code{MATCH_DUP}.  These only occur in machine descriptions.
@en 
@en @item RTX_AUTOINC
@en An RTX code for an auto-increment addressing mode, such as
@en @code{POST_INC}.
@en 
@en @item RTX_EXTRA
@en All other RTX codes.  This category includes the remaining codes used
@en only in machine descriptions (@code{DEFINE_*}, etc.).  It also includes
@en all the codes describing side effects (@code{SET}, @code{USE},
@en @code{CLOBBER}, etc.) and the non-insns that may appear on an insn
@en chain, such as @code{NOTE}, @code{BARRIER}, and @code{CODE_LABEL}.
@en @code{SUBREG} is also part of this class.
@en @end table
@table @code
@item RTX_OBJ
一个RTX代码，表示一个实际的对象，例如一个寄存器(@code{REG})或者一个内存位置(@code{MEM}, @code{SYMBOL_REF})。也包括@code{LO_SUM})；但是，@code{SUBREG}和@code{STRICT_LOW_PART}不在这个类别中，而是在@code{x}类别中。

@item RTX_CONST_OBJ
一个RTX代码，表示一个常量对象。@code{HIGH}也包含在该类别中。

@item RTX_COMPARE
一个RTX代码，针对一个非对称的比较，例如@code{GEU}或@code{LT}。

@item RTX_COMM_COMPARE
一个RTX代码，针对一个对称（可交换）比较，例如，例如@code{EQ}或@code{ORDERED}。

@item RTX_UNARY
一个RTX代码，针对一元算术运算，例如@code{NEG}，@code{NOT}或者@code{ABS}。这个类别还包括值扩展（符号扩展或者零扩展），以及整数和浮点之间的转换。

@item RTX_COMM_ARITH
一个RTX代码，针对可交换的二元运算，例如@code{PLUS}或者@code{AND}。@code{NE}和@code{EQ}为比较运算，所以它们具有类别@code{<}。

@item RTX_BIN_ARITH
一个RTX代码，针对不可交换的二元运算，例如@code{MINUS}，@code{DIV}或者@code{ASHIFTRT}。

@item RTX_BITFIELD_OPS
一个RTX代码，针对位域运算。当前只有@code{ZERO_EXTRACT}和@code{SIGN_EXTRACT}。这些有三个输入，并且为左值。@xref{Bit-Fields}。

@item RTX_TERNARY
一个RTX代码，针对其它有三个输入的运算。当前只有@code{IF_THEN_ELSE}和@code{VEC_MERGE}。

@item RTX_INSN
一个RTX代码，针对整个指令：@code{INSN}，@code{JUMP_INSN}和@code{CALL_INSN}。@xref{Insns}。

@item RTX_MATCH
一个RTX代码，针对在insn中的一些匹配，例如@code{MATCH_DUP}。这些只出现在机器描述中。

@item RTX_AUTOINC
一个RTX代码，针对一个自动增量寻址模式，例如@code{POST_INC}。

@item RTX_EXTRA
所有其它的RTX代码。这个类别包括只在机器描述(@code{DEFINE_*}等)中使用的其它RTX代码。其还表示所有表述副作用的RTX代码（@code{SET}，@code{USE}，@code{CLOBBER}等），以及在insn链中可能出现的非insn，例如@code{NOTE}，@code{BARRIER}和@code{CODE_LABEL}。@code{SUBREG}也属于该类。

@end table

@cindex RTL format
@en For each expression code, @file{rtl.def} specifies the number of
@en contained objects and their kinds using a sequence of characters
@en called the @dfn{format} of the expression code.  For example,
@en the format of @code{subreg} is @samp{ei}.
对于每个表达式代码，@file{rtl.def}使用称作表达式代码格式（@dfn{format}）的字符序列，来说明所包含的对象数目，以及它们的种类。例如，@code{subreg}的格式为@samp{ei}。

@cindex RTL format characters
@en These are the most commonly used format characters:
这些是最常用的格式字符：

@en @table @code
@en @item e
@en An expression (actually a pointer to an expression).
@en 
@en @item i
@en An integer.
@en 
@en @item w
@en A wide integer.
@en 
@en @item s
@en A string.
@en 
@en @item E
@en A vector of expressions.
@en @end table
@table @code
@item e
一个表达式（实际是一个表达式指针）

@item i
一个整数。

@item w
一个宽整数。

@item s
一个字符串。

@item E
一个表达式向量。
@end table

@en A few other format characters are used occasionally:
还有一些其它的格式字符有时会被用到：

@en @table @code
@en @item u
@en @samp{u} is equivalent to @samp{e} except that it is printed differently
@en in debugging dumps.  It is used for pointers to insns.
@en 
@en @item n
@en @samp{n} is equivalent to @samp{i} except that it is printed differently
@en in debugging dumps.  It is used for the line number or code number of a
@en @code{note} insn.
@en 
@en @item S
@en @samp{S} indicates a string which is optional.  In the RTL objects in
@en core, @samp{S} is equivalent to @samp{s}, but when the object is read,
@en from an @samp{md} file, the string value of this operand may be omitted.
@en An omitted string is taken to be the null string.
@en 
@en @item V
@en @samp{V} indicates a vector which is optional.  In the RTL objects in
@en core, @samp{V} is equivalent to @samp{E}, but when the object is read
@en from an @samp{md} file, the vector value of this operand may be omitted.
@en An omitted vector is effectively the same as a vector of no elements.
@en 
@en @item B
@en @samp{B} indicates a pointer to basic block structure.
@en 
@en @item 0
@en @samp{0} means a slot whose contents do not fit any normal category.
@en @samp{0} slots are not printed at all in dumps, and are often used in
@en special ways by small parts of the compiler.
@en @end table
@table @code
@item u
@samp{u}等价于@samp{e}，只不过是在调试转储中的打印有所区别。其用于insn指针。

@item n
@samp{n}等价于@samp{i}， 只不过是在调试转储中的打印有所区别。其用于@code{note} insn的行号和代码号。

@item S
@samp{S}表示一个可选的字符串。在内部的RTX对象中，@samp{S}等价于@samp{s}，但当对象从@samp{md}文件中读取的时候，该操作数的字符串值可以被忽略。被忽略的字符串被当作一个空字符串。

@item V
@samp{V}表示一个可选的向量。在内部的RTX对象中，@samp{V}等价于@samp{E}，但是当对象从@samp{md}文件中读取的时候，该操作数的向量值可以被忽略。被忽略的向量被当作一个没有元素的向量。 

@item B
@samp{B}表示一个指向基本块结构体的指针。

@item 0
@samp{0}表示一个插槽，其内容不使用任何常规的类别。@samp{0}插槽根本不在转储中打印，通常在编译器中用于特定的方式。
@end table

@en There are macros to get the number of operands and the format
@en of an expression code:
这些是获得操作数数目和表达式代码格式的宏：

@en @table @code
@en @findex GET_RTX_LENGTH
@en @item GET_RTX_LENGTH (@var{code})
@en Number of operands of an RTX of code @var{code}.
@en 
@en @findex GET_RTX_FORMAT
@en @item GET_RTX_FORMAT (@var{code})
@en The format of an RTX of code @var{code}, as a C string.
@en @end table
@en 
@en Some classes of RTX codes always have the same format.  For example, it
@en is safe to assume that all comparison operations have format @code{ee}.
@en 
@en @table @code
@en @item 1
@en All codes of this class have format @code{e}.
@en 
@en @item <
@en @itemx c
@en @itemx 2
@en All codes of these classes have format @code{ee}.
@en 
@en @item b
@en @itemx 3
@en All codes of these classes have format @code{eee}.
@en 
@en @item i
@en All codes of this class have formats that begin with @code{iuueiee}.
@en @xref{Insns}.  Note that not all RTL objects linked onto an insn chain
@en are of class @code{i}.
@en 
@en @item o
@en @itemx m
@en @itemx x
@en You can make no assumptions about the format of these codes.
@en @end table
@table @code
@findex GET_RTX_LENGTH
@item GET_RTX_LENGTH (@var{code})
代码为@var{code}的RTX的操作数个数。

@findex GET_RTX_FORMAT
@item GET_RTX_FORMAT (@var{code})
代码为@var{code}的RTX的格式，为C字符串。
@end table

一些RTX代码的类别总是具有相同的格式。例如，可以安全的假设所有的比较运算都具有格式@code{ee}。

@table @code
@item 1
所有该类别的代码都具有格式@code{e}。

@item <
@itemx c
@itemx 2
所有这些类别的代码都具有格式@code{ee}。

@item b
@itemx 3
所有这些类别的代码都具有格式@code{eee}。

@item i
所有该类别的代码具有的格式都起始于@code{iuueiee}。@xref{Insns}。注意，并不是所有被链接到insn链表中的RTX对象都属于类别@code{i}。

@item o
@itemx m
@itemx x
你可以不去假设这些代码的格式。
@end table

@en @node Accessors
@en @section Access to Operands
@node Accessors
@section 访问操作数
@cindex accessors
@cindex access to operands
@cindex operand access

@findex XEXP
@findex XINT
@findex XWINT
@findex XSTR
@en Operands of expressions are accessed using the macros @code{XEXP},
@en @code{XINT}, @code{XWINT} and @code{XSTR}.  Each of these macros takes
@en two arguments: an expression-pointer (RTX) and an operand number
@en (counting from zero).  Thus,
表达式的操作数用宏@code{XEXP}、@code{XINT}、@code{XWINT}和@code{XSTR}访问。
所有这些宏都有两个参数：一个为表达式指针（RTX），
另一个为操作数序号 ( 从0 开始计算 )。如：

@smallexample
XEXP (@var{x}, 2)
@end smallexample

@noindent
@en accesses operand 2 of expression @var{x}, as an expression.
表示以表达式方式访问表达式@var{x}的第2个操作数。

@smallexample
XINT (@var{x}, 2)
@end smallexample

@noindent
@en accesses the same operand as an integer.  @code{XSTR}, used in the same
@en fashion, would access it as a string.
表示以整数方式访问@code{x}的第2个操作数。
@code{XSTR}表示以字符串方式访问。

@en Any operand can be accessed as an integer, as an expression or as a string.
@en You must choose the correct method of access for the kind of value actually
@en stored in the operand.  You would do this based on the expression code of
@en the containing expression.  That is also how you would know how many
@en operands there are.
任何一个操作数都能以整数方式、表达式方式或字符串方式来访问，
但必须根据存贮在操作数中的实际值选择正确的访问方式。
这可根据表达式的代码而获得，同样也可表达式代码获得操作数的个数。

@en For example, if @var{x} is a @code{subreg} expression, you know that it has
@en two operands which can be correctly accessed as @code{XEXP (@var{x}, 0)}
@en and @code{XINT (@var{x}, 1)}.  If you did @code{XINT (@var{x}, 0)}, you
@en would get the address of the expression operand but cast as an integer;
@en that might occasionally be useful, but it would be cleaner to write
@en @code{(int) XEXP (@var{x}, 0)}.  @code{XEXP (@var{x}, 1)} would also
@en compile without error, and would return the second, integer operand cast as
@en an expression pointer, which would probably result in a crash when
@en accessed.  Nothing stops you from writing @code{XEXP (@var{x}, 28)} either,
@en but this will access memory past the end of the expression with
@en unpredictable results.
例如：若@var{x}是@code{subreg}表达式，通过表达式代码可知它有二个操作数，
这两个操作数的访问应该是@code{XEXP (@var{x}, 0)} 和@code{XINT (@var{x}, 1)}，
若写成@code{XINT (@var{x}, 0)}，那么，你得到的表达式地址将被强制成整数，
偶尔可能会需要这样做，但在这种情况下用@code{(int) XEXP (@var{x}, 0)}表示要更好。
同样写成@code{XEXP (@var{x}, 1)} 也不会导致编译错误，
它将返回强制为表达式指针而实际为整数的1号操作数，在运行中访问该指针时，
这可能会导致出错。同样，你也可以写成@code{XEXP (@var{x}, 28)}，
但这超出了此表达式的存贮边界，所得到的将是一个预料不到的结果。

@en Access to operands which are vectors is more complicated.  You can use the
@en macro @code{XVEC} to get the vector-pointer itself, or the macros
@en @code{XVECEXP} and @code{XVECLEN} to access the elements and length of a
@en vector.
对向量操作数的访问较为复杂些，可用@code{XVEC}宏来获取向量指针本身，
@code{XVECEXP}和@code{XVECLEN}宏访问一个向量的元素和长度。

@en @table @code
@en @findex XVEC
@en @item XVEC (@var{exp}, @var{idx})
@en Access the vector-pointer which is operand number @var{idx} in @var{exp}.
@en 
@en @findex XVECLEN
@en @item XVECLEN (@var{exp}, @var{idx})
@en Access the length (number of elements) in the vector which is
@en in operand number @var{idx} in @var{exp}.  This value is an @code{int}.
@en 
@en @findex XVECEXP
@en @item XVECEXP (@var{exp}, @var{idx}, @var{eltnum})
@en Access element number @var{eltnum} in the vector which is
@en in operand number @var{idx} in @var{exp}.  This value is an RTX@.
@en 
@en It is up to you to make sure that @var{eltnum} is not negative
@en and is less than @code{XVECLEN (@var{exp}, @var{idx})}.
@en @end table
@table @code
@findex XVEC
@item XVEC (@var{exp}, @var{idx})
获得@var{exp}中第@var{idx}个操作数的向量指针。

@findex XVECLEN
@item XVECLEN (@var{exp}, @var{idx})
获得@var{exp}中第@var{idx}个操作数（为向量操作数）的向量长度（元素个数），
其值是@code{int}。

@findex XVECEXP
@item XVECEXP (@var{exp}, @var{idx}, @var{eltnum})
访问@var{exp}中第@var{idx}个操作数（为向量操作数）的第@var{eltnum}个元素，
其值是一个RTX。

需要由你来确保@var{eltnum}不为负，并且小于@code{XVECLEN (@var{exp}, @var{idx})}。
@end table

@en All the macros defined in this section expand into lvalues and therefore
@en can be used to assign the operands, lengths and vector elements as well as
@en to access them.
在本节中所定义的所有宏定义都被扩展成左值，
因而也可用于对操作数、长度和向量元素赋值。

@en @node Special Accessors
@en @section Access to Special Operands
@node Special Accessors
@section 访问特殊操作数
@cindex access to special operands

@en Some RTL nodes have special annotations associated with them.
一些RTL节点具有与它们相关联的特殊的注解。


@table @code
@item MEM
@table @code
@findex MEM_ALIAS_SET
@item MEM_ALIAS_SET (@var{x})
@en If 0, @var{x} is not in any alias set, and may alias anything.  Otherwise,
@en @var{x} can only alias @code{MEM}s in a conflicting alias set.  This value
@en is set in a language-dependent manner in the front-end, and should not be
@en altered in the back-end.  In some front-ends, these numbers may correspond
@en in some way to types, or other language-level entities, but they need not,
@en and the back-end makes no such assumptions.
@en These set numbers are tested with @code{alias_sets_conflict_p}.
如果为0，则@var{x}不在任何别名集中，并可能为任何对象的别名。否则，@var{x}只能为在冲突别名集中的@code{MEM}的别名。该值在前端使用语言相关的方式来设置，并且不能在后端修改。在一些前端中，这些可以通过某种方式对应到类型，或者其它语言级的实体，但是不要求非要这样，所以在后端不要做这样的假设。这些集合编号使用@code{alias_sets_conflict_p}来测试。

@findex MEM_EXPR
@item MEM_EXPR (@var{x})
@en If this register is known to hold the value of some user-level
@en declaration, this is that tree node.  It may also be a
@en @code{COMPONENT_REF}, in which case this is some field reference,
@en and @code{TREE_OPERAND (@var{x}, 0)} contains the declaration,
@en or another @code{COMPONENT_REF}, or null if there is no compile-time
@en object associated with the reference.
如果该寄存器被已知为存放了一些用户级的声明的值，则为那个tree节点。其也可以为@code{COMPONENT_REF}，这种情况下，其为某个域的引用，并且@code{TREE_OPERAND (@var{x}, 0)}包含了声明，或者另一个@code{COMPONENT_REF}，或者如果没有编译时对象相关引用，则为空。

@findex MEM_OFFSET
@item MEM_OFFSET (@var{x})
@en The offset from the start of @code{MEM_EXPR} as a @code{CONST_INT} rtx.
从@code{MEM_EXPR}起始的偏移量，为一个@code{CONST_INT} rtx。

@findex MEM_SIZE
@item MEM_SIZE (@var{x})
@en The size in bytes of the memory reference as a @code{CONST_INT} rtx.
@en This is mostly relevant for @code{BLKmode} references as otherwise
@en the size is implied by the mode.
以字节为单位的内存引用长度，为一个@code{CONST_INT} rtx。这主要与@code{BLKmode}引用相关，否则机器模式已经隐含了长度。

@findex MEM_ALIGN
@item MEM_ALIGN (@var{x})
@en The known alignment in bits of the memory reference.
内存引用的已知的对齐方式，以位为单位。

@findex MEM_ADDR_SPACE
@item MEM_ADDR_SPACE (@var{x})
The address space of the memory reference.  This will commonly be zero
for the generic address space.
@end table

@item REG
@table @code
@findex ORIGINAL_REGNO
@item ORIGINAL_REGNO (@var{x})
@en This field holds the number the register ``originally'' had; for a
@en pseudo register turned into a hard reg this will hold the old pseudo
@en register number.
该域存放了寄存器原先具有的编号；对于伪寄存器放入到一个硬寄存器中，其将存放旧的伪寄存器编号。

@findex REG_EXPR
@item REG_EXPR (@var{x})
@en If this register is known to hold the value of some user-level
@en declaration, this is that tree node.
如果该寄存器被已知存放了某个用户级的声明的值，则其为那个tree节点。

@findex REG_OFFSET
@item REG_OFFSET (@var{x})
@en If this register is known to hold the value of some user-level
@en declaration, this is the offset into that logical storage.
如果该寄存器被已知存放了某个用户级的声明的值，则其为相对那个逻辑存储的便宜量。

@end table

@item SYMBOL_REF
@table @code
@findex SYMBOL_REF_DECL
@item SYMBOL_REF_DECL (@var{x})
@en If the @code{symbol_ref} @var{x} was created for a @code{VAR_DECL} or
@en a @code{FUNCTION_DECL}, that tree is recorded here.  If this value is
@en null, then @var{x} was created by back end code generation routines,
@en and there is no associated front end symbol table entry.
如果是针对@code{VAR_DECL}或@code{FUNCTION_DECL}创建的@code{symbol_ref} @var{x}，则那个tree被记录在这里。如果该值为空，则@var{x}由后端代码生成例程创建，并不与前端的符号表实体相关联。

@en @code{SYMBOL_REF_DECL} may also point to a tree of class @code{'c'},
@en that is, some sort of constant.  In this case, the @code{symbol_ref}
@en is an entry in the per-file constant pool; again, there is no associated
@en front end symbol table entry.
@code{SYMBOL_REF_DECL}也可以指向@code{'c'}类别的tree，即某种常量。这种情况下，@code{symbol_ref}为每个文件的常量池中的实体；同样，不与前端的符号表实体相关联。

@findex SYMBOL_REF_CONSTANT
@item SYMBOL_REF_CONSTANT (@var{x})
@en If @samp{CONSTANT_POOL_ADDRESS_P (@var{x})} is true, this is the constant
@en pool entry for @var{x}.  It is null otherwise.
如果@samp{CONSTANT_POOL_ADDRESS_P (@var{x})}为真，则为@var{x}的常量池实体。否则为空。

@findex SYMBOL_REF_DATA
@item SYMBOL_REF_DATA (@var{x})
@en A field of opaque type used to store @code{SYMBOL_REF_DECL} or
@en @code{SYMBOL_REF_CONSTANT}.
一个不透明类型的域，用来存储@code{SYMBOL_REF_DECL}或@code{SYMBOL_REF_CONSTANT}。

@findex SYMBOL_REF_FLAGS
@item SYMBOL_REF_FLAGS (@var{x})
@en In a @code{symbol_ref}, this is used to communicate various predicates
@en about the symbol.  Some of these are common enough to be computed by
@en common code, some are specific to the target.  The common bits are:
在一个@code{symbol_ref}中，其用于传达关于符号的各种断言。它们中的一些可以使用通用的代码来计算，一些是特定于目标机器的。通用的位：

@table @code
@findex SYMBOL_REF_FUNCTION_P
@findex SYMBOL_FLAG_FUNCTION
@item SYMBOL_FLAG_FUNCTION
@en Set if the symbol refers to a function.
用来表示符号引用一个函数。

@findex SYMBOL_REF_LOCAL_P
@findex SYMBOL_FLAG_LOCAL
@item SYMBOL_FLAG_LOCAL
@en Set if the symbol is local to this ``module''.
@en See @code{TARGET_BINDS_LOCAL_P}.
用来表示符号局部于该模块。参见@code{TARGET_BINDS_LOCAL_P}。

@findex SYMBOL_REF_EXTERNAL_P
@findex SYMBOL_FLAG_EXTERNAL
@item SYMBOL_FLAG_EXTERNAL
@en Set if this symbol is not defined in this translation unit.
@en Note that this is not the inverse of @code{SYMBOL_FLAG_LOCAL}.
用来表示该符号不在该转换单元中定义。注意，其并不是@code{SYMBOL_FLAG_LOCAL}的反转。

@findex SYMBOL_REF_SMALL_P
@findex SYMBOL_FLAG_SMALL
@item SYMBOL_FLAG_SMALL
@en Set if the symbol is located in the small data section.
@en See @code{TARGET_IN_SMALL_DATA_P}.
用来表示符号位于小数据段。参见@code{TARGET_IN_SMALL_DATA_P}。

@findex SYMBOL_FLAG_TLS_SHIFT
@findex SYMBOL_REF_TLS_MODEL
@item SYMBOL_REF_TLS_MODEL (@var{x})
@en This is a multi-bit field accessor that returns the @code{tls_model}
@en to be used for a thread-local storage symbol.  It returns zero for
@en non-thread-local symbols.
这是多个位的域访问，其返回用于线程局部存储符号的@code{tls_model}。对于非线程局部符号，其返回0。

@findex SYMBOL_REF_HAS_BLOCK_INFO_P
@findex SYMBOL_FLAG_HAS_BLOCK_INFO
@item SYMBOL_FLAG_HAS_BLOCK_INFO
@en Set if the symbol has @code{SYMBOL_REF_BLOCK} and
@en @code{SYMBOL_REF_BLOCK_OFFSET} fields.
用来表示符号具有@code{SYMBOL_REF_BLOCK}和@code{SYMBOL_REF_BLOCK_OFFSET}域。

@findex SYMBOL_REF_ANCHOR_P
@findex SYMBOL_FLAG_ANCHOR
@cindex @option{-fsection-anchors}
@item SYMBOL_FLAG_ANCHOR
@en Set if the symbol is used as a section anchor.  ``Section anchors''
@en are symbols that have a known position within an @code{object_block}
@en and that can be used to access nearby members of that block.
@en They are used to implement @option{-fsection-anchors}.
用来表示符号作为section anchor。``Section anchors''为在@code{object_block}中具有一个已知位置的符号，并且可以用来访问该块中的附近成员。它们用来实现@option{-fsection-anchors}。

@en If this flag is set, then @code{SYMBOL_FLAG_HAS_BLOCK_INFO} will be too.
如果该标记被设置，则@code{SYMBOL_FLAG_HAS_BLOCK_INFO}也被设置。

@end table

@en Bits beginning with @code{SYMBOL_FLAG_MACH_DEP} are available for
@en the target's use.
起始于@code{SYMBOL_FLAG_MACH_DEP}的位，可供目标机器使用。
@end table

@findex SYMBOL_REF_BLOCK
@item SYMBOL_REF_BLOCK (@var{x})
@en If @samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}, this is the
@en @samp{object_block} structure to which the symbol belongs,
@en or @code{NULL} if it has not been assigned a block.
如果@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}，则其为该符号所属的@samp{object_block}结构体， 或者如果其没有被分配给一个块，则为@code{NULL}。

@findex SYMBOL_REF_BLOCK_OFFSET
@en If @samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}, this is the offset of @var{x}
@en from the first object in @samp{SYMBOL_REF_BLOCK (@var{x})}.  The value is
@en negative if @var{x} has not yet been assigned to a block, or it has not
@en been given an offset within that block.
@en @item SYMBOL_REF_BLOCK_OFFSET (@var{x})
如果@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}，则其为@var{x}的偏移量，从@samp{SYMBOL_REF_BLOCK (@var{x})}中的第一个对象开始。如果@var{x}还没有被分配给一个块，或者其还没有在那个块中给定一个偏移量，则值为负数。

@end table

@en @node Flags
@en @section Flags in an RTL Expression
@node Flags
@section RTL表达式中的标记
@cindex flags in RTL expression

@en RTL expressions contain several flags (one-bit bit-fields)
@en that are used in certain types of expression.  Most often they
@en are accessed with the following macros, which expand into lvalues.
RTL表达式包含几个标记（位域），用于特定类型的表达式。通常它们使用下列的宏来访问，并被扩展为左值。

@table @code
@findex CONSTANT_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/u}
@cindex @code{unchanging}, in @code{symbol_ref}
@item CONSTANT_POOL_ADDRESS_P (@var{x})
@en Nonzero in a @code{symbol_ref} if it refers to part of the current
@en function's constant pool.  For most targets these addresses are in a
@en @code{.rodata} section entirely separate from the function, but for
@en some targets the addresses are close to the beginning of the function.
@en In either case GCC assumes these addresses can be addressed directly,
@en perhaps with the help of base registers.
@en Stored in the @code{unchanging} field and printed as @samp{/u}.
位于@code{symbol_ref}中，如果其引用了当前函数的常量池中的一部分，则非零。对于大多数目标机器，这些地址在@code{.rodata}段中，与函数完全分离，但是对于有些目标机器，这些地址是靠近函数起始处。不管哪种情况，GCC都假设这些地址可以被直接寻址，或者通过基址寄存器。其被存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex RTL_CONST_CALL_P
@cindex @code{call_insn} and @samp{/u}
@cindex @code{unchanging}, in @code{call_insn}
@item RTL_CONST_CALL_P (@var{x})
@en In a @code{call_insn} indicates that the insn represents a call to a
@en const function.  Stored in the @code{unchanging} field and printed as
@en @samp{/u}.
位于@code{call_insn}中，表明该insn表示一个对const函数的调用。存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex RTL_PURE_CALL_P
@cindex @code{call_insn} and @samp{/i}
@cindex @code{return_val}, in @code{call_insn}
@item RTL_PURE_CALL_P (@var{x})
@en In a @code{call_insn} indicates that the insn represents a call to a
@en pure function.  Stored in the @code{return_val} field and printed as
@en @samp{/i}.
位于@code{call_insn}中，表明该insn表示一个对pure函数的调用。存储在@code{return_val}域，打印输出为@samp{/i}。

@findex RTL_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/u} or @samp{/i}
@item RTL_CONST_OR_PURE_CALL_P (@var{x})
@en In a @code{call_insn}, true if @code{RTL_CONST_CALL_P} or
@en @code{RTL_PURE_CALL_P} is true.
位于@code{call_insn}中，如果@code{RTL_CONST_CALL_P}或者@code{RTL_PURE_CALL_P}为真，则其为真。

@findex RTL_LOOPING_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/c}
@cindex @code{call}, in @code{call_insn}
@item RTL_LOOPING_CONST_OR_PURE_CALL_P (@var{x})
@en In a @code{call_insn} indicates that the insn represents a possibly
@en infinite looping call to a const or pure function.  Stored in the
@en @code{call} field and printed as @samp{/c}.  Only true if one of
@en @code{RTL_CONST_CALL_P} or @code{RTL_PURE_CALL_P} is true.
位于@code{call_insn}中，表明该insn表示一个对const或者pure函数，可能是无限循环的调用。存储在@code{call}域，打印输出为@samp{/c}。只有当@code{RTL_CONST_CALL_P}或者@code{RTL_PURE_CALL_P}为真时，其才为真。

@findex INSN_ANNULLED_BRANCH_P
@cindex @code{jump_insn} and @samp{/u}
@cindex @code{call_insn} and @samp{/u}
@cindex @code{insn} and @samp{/u}
@cindex @code{unchanging}, in @code{jump_insn}, @code{call_insn} and @code{insn}
@item INSN_ANNULLED_BRANCH_P (@var{x})
@en In a @code{jump_insn}, @code{call_insn}, or @code{insn} indicates
@en that the branch is an annulling one.  See the discussion under
@en @code{sequence} below.  Stored in the @code{unchanging} field and
@en printed as @samp{/u}.
位于@code{jump_insn}，@code{call_insn}或者@code{insn}中，表明该分支跳转被取消。参见下面关于@code{sequence}的讨论。存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex INSN_DELETED_P
@cindex @code{insn} and @samp{/v}
@cindex @code{call_insn} and @samp{/v}
@cindex @code{jump_insn} and @samp{/v}
@cindex @code{code_label} and @samp{/v}
@cindex @code{barrier} and @samp{/v}
@cindex @code{note} and @samp{/v}
@cindex @code{volatil}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{barrier}, and @code{note}
@item INSN_DELETED_P (@var{x})
@en In an @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label},
@en @code{barrier}, or @code{note},
@en nonzero if the insn has been deleted.  Stored in the
@en @code{volatil} field and printed as @samp{/v}.
位于@code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{barrier}或@code{note}中，如果该insn被删除掉，则非零。存储在@code{volatil}域，打印输出为@samp{/v}。

@findex INSN_FROM_TARGET_P
@cindex @code{insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn} and @code{jump_insn} and @code{call_insn}
@item INSN_FROM_TARGET_P (@var{x})
@en In an @code{insn} or @code{jump_insn} or @code{call_insn} in a delay
@en slot of a branch, indicates that the insn
@en is from the target of the branch.  If the branch insn has
@en @code{INSN_ANNULLED_BRANCH_P} set, this insn will only be executed if
@en the branch is taken.  For annulled branches with
@en @code{INSN_FROM_TARGET_P} clear, the insn will be executed only if the
@en branch is not taken.  When @code{INSN_ANNULLED_BRANCH_P} is not set,
@en this insn will always be executed.  Stored in the @code{in_struct}
@en field and printed as @samp{/s}.
位于@code{insn}，@code{jump_insn}或者@code{call_insn}中，在分支延迟槽中，表明该insn是来自分支跳转的目标。如果分支insn设置了@code{INSN_ANNULLED_BRANCH_P}，则该insn只有当进行分支跳转的时候，才被执行。对于被取消的分支，如果是清除了@code{INSN_FROM_TARGET_P}，则insn只有当没有进行分支跳转的时候，才被执行。当@code{INSN_ANNULLED_BRANCH_P}没有被设置，该insn将总是被执行。存储在@code{in_struct}域，打印输出为@samp{/s}。

@findex LABEL_PRESERVE_P
@cindex @code{code_label} and @samp{/i}
@cindex @code{note} and @samp{/i}
@cindex @code{in_struct}, in @code{code_label} and @code{note}
@item LABEL_PRESERVE_P (@var{x})
@en In a @code{code_label} or @code{note}, indicates that the label is referenced by
@en code or data not visible to the RTL of a given function.
@en Labels referenced by a non-local goto will have this bit set.  Stored
@en in the @code{in_struct} field and printed as @samp{/s}.
位于@code{code_label}或者@code{note}中，表明被代码或者数据引用的该标号，对于给定的函数RTL不可见。通过非局部goto引用的标号，将设置该位。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex LABEL_REF_NONLOCAL_P
@cindex @code{label_ref} and @samp{/v}
@cindex @code{reg_label} and @samp{/v}
@cindex @code{volatil}, in @code{label_ref} and @code{reg_label}
@item LABEL_REF_NONLOCAL_P (@var{x})
@en In @code{label_ref} and @code{reg_label} expressions, nonzero if this is
@en a reference to a non-local label.
@en Stored in the @code{volatil} field and printed as @samp{/v}.
位于@code{label_ref}和@code{reg_label}表达式中，如果其为对一个非局部标号的引用，则非零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex MEM_IN_STRUCT_P
@cindex @code{mem} and @samp{/s}
@cindex @code{in_struct}, in @code{mem}
@item MEM_IN_STRUCT_P (@var{x})
@en In @code{mem} expressions, nonzero for reference to an entire structure,
@en union or array, or to a component of one.  Zero for references to a
@en scalar variable or through a pointer to a scalar.  If both this flag and
@en @code{MEM_SCALAR_P} are clear, then we don't know whether this @code{mem}
@en is in a structure or not.  Both flags should never be simultaneously set.
@en Stored in the @code{in_struct} field and printed as @samp{/s}.
位于@code{mem}表达式中，对于引用一整个结构体，联合体，数组，或者是它们的一部分，则非零。如果是引用一个标量变量，或者是标量指针，则为零。如果该标记和@code{MEM_SCALAR_P}都被清除，则我们无法知道该@code{mem}是否在一个结构体中。这两个标记不要被同时设置。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex MEM_KEEP_ALIAS_SET_P
@cindex @code{mem} and @samp{/j}
@cindex @code{jump}, in @code{mem}
@item MEM_KEEP_ALIAS_SET_P (@var{x})
@en In @code{mem} expressions, 1 if we should keep the alias set for this
@en mem unchanged when we access a component.  Set to 1, for example, when we
@en are already in a non-addressable component of an aggregate.
@en Stored in the @code{jump} field and printed as @samp{/j}.
位于@code{mem}表达式中，如果为1，则表明当访问一个部件时，应该保持该mem的别名集合不变。例如，当在一个聚合体的不可寻址部件中的时候，将其设为1。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex MEM_SCALAR_P
@cindex @code{mem} and @samp{/i}
@cindex @code{return_val}, in @code{mem}
@item MEM_SCALAR_P (@var{x})
@en In @code{mem} expressions, nonzero for reference to a scalar known not
@en to be a member of a structure, union, or array.  Zero for such
@en references and for indirections through pointers, even pointers pointing
@en to scalar types.  If both this flag and @code{MEM_IN_STRUCT_P} are clear,
@en then we don't know whether this @code{mem} is in a structure or not.
@en Both flags should never be simultaneously set.
@en Stored in the @code{return_val} field and printed as @samp{/i}.
位于@code{mem}表达式中，如果引用的标量，被已知不是结构体，联合体或者数组的成员，则为非零。如果是这样的引用，或者通过指针的间接引用，即便是指向标量类型，则为零，如果该标记和@code{MEM_IN_STRUCT_P}都被清除，则我们无法知道该@code{mem}是否为一个结构体。这两个标记不要被同时设置。存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex MEM_VOLATILE_P
@cindex @code{mem} and @samp{/v}
@cindex @code{asm_input} and @samp{/v}
@cindex @code{asm_operands} and @samp{/v}
@cindex @code{volatil}, in @code{mem}, @code{asm_operands}, and @code{asm_input}
@item MEM_VOLATILE_P (@var{x})
@en In @code{mem}, @code{asm_operands}, and @code{asm_input} expressions,
@en nonzero for volatile memory references.
@en Stored in the @code{volatil} field and printed as @samp{/v}.
位于@code{mem}, @code{asm_operands}和@code{asm_input}表达式中，对于volatile内存引用，为非零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex MEM_NOTRAP_P
@cindex @code{mem} and @samp{/c}
@cindex @code{call}, in @code{mem}
@item MEM_NOTRAP_P (@var{x})
@en In @code{mem}, nonzero for memory references that will not trap.
@en Stored in the @code{call} field and printed as @samp{/c}.
位于@code{mem}中，对于不会产生陷阱的内存引用，为非零。存储在@code{call}域中，打印输出为@samp{/c}。

@findex MEM_POINTER
@cindex @code{mem} and @samp{/f}
@cindex @code{frame_related}, in @code{mem}
@item MEM_POINTER (@var{x})
@en Nonzero in a @code{mem} if the memory reference holds a pointer.
@en Stored in the @code{frame_related} field and printed as @samp{/f}.
位于@code{mem}中，如果内存引用存放了一个指针，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex REG_FUNCTION_VALUE_P
@cindex @code{reg} and @samp{/i}
@cindex @code{return_val}, in @code{reg}
@item REG_FUNCTION_VALUE_P (@var{x})
@en Nonzero in a @code{reg} if it is the place in which this function's
@en value is going to be returned.  (This happens only in a hard
@en register.)  Stored in the @code{return_val} field and printed as
@en @samp{/i}.
位于@code{reg}中，如果其为存放函数返回值的地方，则非零。（这只发生在硬件寄存器中。）存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex REG_POINTER
@cindex @code{reg} and @samp{/f}
@cindex @code{frame_related}, in @code{reg}
@item REG_POINTER (@var{x})
@en Nonzero in a @code{reg} if the register holds a pointer.  Stored in the
@en @code{frame_related} field and printed as @samp{/f}.
位于@code{reg}中，如果寄存器存放一个指针，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex REG_USERVAR_P
@cindex @code{reg} and @samp{/v}
@cindex @code{volatil}, in @code{reg}
@item REG_USERVAR_P (@var{x})
@en In a @code{reg}, nonzero if it corresponds to a variable present in
@en the user's source code.  Zero for temporaries generated internally by
@en the compiler.  Stored in the @code{volatil} field and printed as
@en @samp{/v}.
位于@code{reg}中，如果其对应于用户源代码中出现的一个变量，则非零。对于编译器内部生成的临时对象，则为零。存储在@code{volatil}域中，打印输出为@samp{/v}。

The same hard register may be used also for collecting the values of
functions called by this one, but @code{REG_FUNCTION_VALUE_P} is zero
in this kind of use.

@findex RTX_FRAME_RELATED_P
@cindex @code{insn} and @samp{/f}
@cindex @code{call_insn} and @samp{/f}
@cindex @code{jump_insn} and @samp{/f}
@cindex @code{barrier} and @samp{/f}
@cindex @code{set} and @samp{/f}
@cindex @code{frame_related}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, and @code{set}
@item RTX_FRAME_RELATED_P (@var{x})
@en Nonzero in an @code{insn}, @code{call_insn}, @code{jump_insn},
@en @code{barrier}, or @code{set} which is part of a function prologue
@en and sets the stack pointer, sets the frame pointer, or saves a register.
@en This flag should also be set on an instruction that sets up a temporary
@en register to use in place of the frame pointer.
@en Stored in the @code{frame_related} field and printed as @samp{/f}.
位于@code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, 或者@code{set}中，如果其为函数序言的一部分，用来设置栈指针，帧指针，或者保存寄存器，则为非零。对于设置用于帧指针的临时寄存器的指令，该标记也应被设置。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@en In particular, on RISC targets where there are limits on the sizes of
@en immediate constants, it is sometimes impossible to reach the register
@en save area directly from the stack pointer.  In that case, a temporary
@en register is used that is near enough to the register save area, and the
@en Canonical Frame Address, i.e., DWARF2's logical frame pointer, register
@en must (temporarily) be changed to be this temporary register.  So, the
@en instruction that sets this temporary register must be marked as
@en @code{RTX_FRAME_RELATED_P}.
特别的，在一些RISC目标机器上，对于立即数常量的大小有限制，有时不能直接通过栈指针来到达寄存器的保存区域。这种情况下，一个足够接近寄存器保存区域的临时寄存器被使用，并且正则帧地址（Canonical Frame Address）寄存器，即DWARF2的逻辑帧指针寄存器，必须（临时的）被改成该临时寄存器。所以，设置该临时寄存器的指令必须被标记为@code{RTX_FRAME_RELATED_P}。

@en If the marked instruction is overly complex (defined in terms of what
@en @code{dwarf2out_frame_debug_expr} can handle), you will also have to
@en create a @code{REG_FRAME_RELATED_EXPR} note and attach it to the
@en instruction.  This note should contain a simple expression of the
@en computation performed by this instruction, i.e., one that
@en @code{dwarf2out_frame_debug_expr} can handle.
如果被标记的指令过于复杂（跟据@code{dwarf2out_frame_debug_expr}能否处理，而定义的术语），则你还必须要创建一个@code{REG_FRAME_RELATED_EXPR}注解，并附加在该指令上。该注解应该包含一个该指令执行计算的简单表达式，即@code{dwarf2out_frame_debug_expr}可以处理的。

@en This flag is required for exception handling support on targets with RTL
@en prologues.
在带有RTL序言的目标机器上，提供异常处理的支持时，会用到该标记。

@findex MEM_READONLY_P
@cindex @code{mem} and @samp{/u}
@cindex @code{unchanging}, in @code{mem}
@item MEM_READONLY_P (@var{x})
@en Nonzero in a @code{mem}, if the memory is statically allocated and read-only.
位于@code{mem}中，如果内存是静态分配并且只读的，则非零。 

@en Read-only in this context means never modified during the lifetime of the
@en program, not necessarily in ROM or in write-disabled pages.  A common
@en example of the later is a shared library's global offset table.  This
@en table is initialized by the runtime loader, so the memory is technically
@en writable, but after control is transfered from the runtime loader to the
@en application, this memory will never be subsequently modified.
在该上下文中只读，意味着在程序的生命周期中不会被修改，但是不必要是在ROM或者不可写的页中。对于后者，一个常见的例子，是共享库的全局偏移表。该表由运行时加载器初始化，所以内存在技术上是可写的，但是当控制从运行时加载器转移给应用程序时，该内存将不再被修改。

@en Stored in the @code{unchanging} field and printed as @samp{/u}.
存储在@code{unchanging}域中，打印输出为@samp{/u}。

@findex SCHED_GROUP_P
@cindex @code{insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn}, @code{jump_insn} and @code{call_insn}
@item SCHED_GROUP_P (@var{x})
@en During instruction scheduling, in an @code{insn}, @code{call_insn} or
@en @code{jump_insn}, indicates that the
@en previous insn must be scheduled together with this insn.  This is used to
@en ensure that certain groups of instructions will not be split up by the
@en instruction scheduling pass, for example, @code{use} insns before
@en a @code{call_insn} may not be separated from the @code{call_insn}.
@en Stored in the @code{in_struct} field and printed as @samp{/s}.
在指令调度过程中，位于@code{insn}, @code{call_insn}或者@code{jump_insn}中，表明前一个insn必须与该insn一起调度。这用来确保特定的指令组不会被指令调度过程分隔开。例如，在@code{call_insn}之前的@code{use} insn不可以从@code{call_insn}中分开。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex SET_IS_RETURN_P
@cindex @code{insn} and @samp{/j}
@cindex @code{jump}, in @code{insn}
@item SET_IS_RETURN_P (@var{x})
@en For a @code{set}, nonzero if it is for a return.
@en Stored in the @code{jump} field and printed as @samp{/j}.
对于@code{set}，如果是针对一个return，则非零。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex SIBLING_CALL_P
@cindex @code{call_insn} and @samp{/j}
@cindex @code{jump}, in @code{call_insn}
@item SIBLING_CALL_P (@var{x})
@en For a @code{call_insn}, nonzero if the insn is a sibling call.
@en Stored in the @code{jump} field and printed as @samp{/j}.
对于@code{call_insn}，如果该insn为一个sibling call，则非零。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex STRING_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/f}
@cindex @code{frame_related}, in @code{symbol_ref}
@item STRING_POOL_ADDRESS_P (@var{x})
@en For a @code{symbol_ref} expression, nonzero if it addresses this function's
@en string constant pool.
@en Stored in the @code{frame_related} field and printed as @samp{/f}.
对于一个@code{symbol_ref}表达式，如果其为对该函数的字符串常量池的寻址，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex SUBREG_PROMOTED_UNSIGNED_P
@cindex @code{subreg} and @samp{/u} and @samp{/v}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_P (@var{x})
@en Returns a value greater then zero for a @code{subreg} that has
@en @code{SUBREG_PROMOTED_VAR_P} nonzero if the object being referenced is kept
@en zero-extended, zero if it is kept sign-extended, and less then zero if it is
@en extended some other way via the @code{ptr_extend} instruction.
@en Stored in the @code{unchanging}
@en field and @code{volatil} field, printed as @samp{/u} and @samp{/v}.
@en This macro may only be used to get the value it may not be used to change
@en the value.  Use @code{SUBREG_PROMOTED_UNSIGNED_SET} to change the value.
如果@code{subreg}对于@code{SUBREG_PROMOTED_VAR_P}为非零，并且被引用的对象为零扩展，则返回一个大于零的值；如果保持为符号扩展，则为零；如果是通过@code{ptr_extend}指令，进行某种其它方式的扩展，则小于零。存储在@code{unchanging}域和@code{volatil}域中，打印输出为@samp{/u}和@samp{/v}。该宏只用于获得值，不能用于修改值。使用@code{SUBREG_PROMOTED_UNSIGNED_SET}来修改值。

@findex SUBREG_PROMOTED_UNSIGNED_SET
@cindex @code{subreg} and @samp{/u}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_SET (@var{x})
@en Set the @code{unchanging} and @code{volatil} fields in a @code{subreg}
@en to reflect zero, sign, or other extension.  If @code{volatil} is
@en zero, then @code{unchanging} as nonzero means zero extension and as
@en zero means sign extension.  If @code{volatil} is nonzero then some
@en other type of extension was done via the @code{ptr_extend} instruction.
设置@code{subreg}中的@code{unchanging}和@code{volatil}域，来反映零扩展，符号扩展，或其它扩展。如果@code{volatil}为零，然后如果@code{unchanging}为非零，则意味着零扩展，如果为零，则意味着符号扩展。如果@code{volatil}为非零，则通过@code{ptr_extend}指令使用了其它某种扩展。

@findex SUBREG_PROMOTED_VAR_P
@cindex @code{subreg} and @samp{/s}
@cindex @code{in_struct}, in @code{subreg}
@item SUBREG_PROMOTED_VAR_P (@var{x})
@en Nonzero in a @code{subreg} if it was made when accessing an object that
@en was promoted to a wider mode in accord with the @code{PROMOTED_MODE} machine
@en description macro (@pxref{Storage Layout}).  In this case, the mode of
@en the @code{subreg} is the declared mode of the object and the mode of
@en @code{SUBREG_REG} is the mode of the register that holds the object.
@en Promoted variables are always either sign- or zero-extended to the wider
@en mode on every assignment.  Stored in the @code{in_struct} field and
@en printed as @samp{/s}.
位于@code{subreg}中，如果当访问一个被提升为符合机器描述宏@code{PROMOTED_MODE}的(@pxref{Storage Layout})，宽机器模式的对象时，则非零。这种情况下，@code{subreg}的机器模式为对象被声明的机器模式，@code{SUBREG_REG}的机器模式为存放该对象的寄存器的机器模式。被提升的变量，在每个赋值中，总是被符号扩展或者零扩展成宽机器模式。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex SYMBOL_REF_USED
@cindex @code{used}, in @code{symbol_ref}
@item SYMBOL_REF_USED (@var{x})
@en In a @code{symbol_ref}, indicates that @var{x} has been used.  This is
@en normally only used to ensure that @var{x} is only declared external
@en once.  Stored in the @code{used} field.
位于@code{symbol_ref}中，表明@var{x}已经被使用。这通常只用于确保@var{x}只在外部被声明一次。存储在@code{used}中。

@findex SYMBOL_REF_WEAK
@cindex @code{symbol_ref} and @samp{/i}
@cindex @code{return_val}, in @code{symbol_ref}
@item SYMBOL_REF_WEAK (@var{x})
@en In a @code{symbol_ref}, indicates that @var{x} has been declared weak.
@en Stored in the @code{return_val} field and printed as @samp{/i}.
位于@code{symbol_ref}中，表明@var{x}已经被声明为weak。存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex SYMBOL_REF_FLAG
@cindex @code{symbol_ref} and @samp{/v}
@cindex @code{volatil}, in @code{symbol_ref}
@item SYMBOL_REF_FLAG (@var{x})
@en In a @code{symbol_ref}, this is used as a flag for machine-specific purposes.
@en Stored in the @code{volatil} field and printed as @samp{/v}.
位于@code{symbol_ref}中，用于机器特定目的的标记。存储在@code{volatil}域中，打印输出为@samp{/v}。

@en Most uses of @code{SYMBOL_REF_FLAG} are historic and may be subsumed
@en by @code{SYMBOL_REF_FLAGS}.  Certainly use of @code{SYMBOL_REF_FLAGS}
@en is mandatory if the target requires more than one bit of storage.
大多对@code{SYMBOL_REF_FLAG}的使用，是历史性的，并且可以通过@code{SYMBOL_REF_FLAGS}来归类。当然，如果目标机器需要多于一个位的存储时，对@code{SYMBOL_REF_FLAGS}的使用是强制的。

@findex PREFETCH_SCHEDULE_BARRIER_P
@cindex @code{prefetch} and @samp{/v}
@cindex @code{volatile}, in @code{prefetch}
@item PREFETCH_SCHEDULE_BARRIER_P (@var{x})
@en In a @code{prefetch}, indicates that the prefetch is a scheduling barrier.
@en No other INSNs will be moved over it.
@en Stored in the @code{volatil} field and printed as @samp{/v}.
@end table

@en These are the fields to which the above macros refer:
这些是上面的宏所引用的域：

@table @code
@findex call
@cindex @samp{/c} in RTL dump
@item call
@en In a @code{mem}, 1 means that the memory reference will not trap.
在@code{mem}中，1表示该内存引用不会有陷阱。

@en In a @code{call}, 1 means that this pure or const call may possibly
@en infinite loop.
在@code{call}中，1表示该pure或者const调用，可能为无限循环。

@en In an RTL dump, this flag is represented as @samp{/c}.
在RTL转储中，该标记被表示为@samp{/c}。

@findex frame_related
@cindex @samp{/f} in RTL dump
@item frame_related
@en In an @code{insn} or @code{set} expression, 1 means that it is part of
@en a function prologue and sets the stack pointer, sets the frame pointer,
@en saves a register, or sets up a temporary register to use in place of the
@en frame pointer.
在@code{insn}或者@code{set}表达式中，1表示其为函数序言的一部分，设置栈寄存器，设置帧寄存器，保存寄存器，或者设置一个用于帧寄存器的临时寄存器。

@en In @code{reg} expressions, 1 means that the register holds a pointer.
在@code{reg}表达式中，1表示该寄存器存放一个指针。

@en In @code{mem} expressions, 1 means that the memory reference holds a pointer.
在@code{mem}表达式中，1表示该内存引用存放一个指针。

@en In @code{symbol_ref} expressions, 1 means that the reference addresses
@en this function's string constant pool.
在@code{symbol_ref}表达式中，1表示该引用是对函数的字符串常量池的寻址。

@en In an RTL dump, this flag is represented as @samp{/f}.
在RTL转储中，该标记被表示为@samp{/f}。

@findex in_struct
@cindex @samp{/s} in RTL dump
@item in_struct
@en In @code{mem} expressions, it is 1 if the memory datum referred to is
@en all or part of a structure or array; 0 if it is (or might be) a scalar
@en variable.  A reference through a C pointer has 0 because the pointer
@en might point to a scalar variable.  This information allows the compiler
@en to determine something about possible cases of aliasing.
在@code{mem}表达式中，如果所引用的内存数据为整个结构体或者数组，或者一部分，其为1；如果为（或者可能为）一个标量变量。则为0。通过C指针的引用，为0，因为指针可以指向一个标量变量。该信息允许编译器来确定别名的可能情况。

@en In @code{reg} expressions, it is 1 if the register has its entire life
@en contained within the test expression of some loop.
在@code{reg}表达式中，如果寄存器整个生命期都包含在某个循环的测试表达式中，则为1。

@en In @code{subreg} expressions, 1 means that the @code{subreg} is accessing
@en an object that has had its mode promoted from a wider mode.
在@code{subreg}表达式中，1表示@code{subreg}在访问一个从更宽的机器模式进行提升的对象。

@en In @code{label_ref} expressions, 1 means that the referenced label is
@en outside the innermost loop containing the insn in which the @code{label_ref}
@en was found.
在@code{label_ref}表达式中，1表示被引用的标号位于包含发现@code{label_ref}的insn的最内层循环的外面。

@en In @code{code_label} expressions, it is 1 if the label may never be deleted.
@en This is used for labels which are the target of non-local gotos.  Such a
@en label that would have been deleted is replaced with a @code{note} of type
@en @code{NOTE_INSN_DELETED_LABEL}.
在@code{code_label}表达式中，如果标号不能被删除，则为1。这用于其为非局部goto的目标的标号。对于已经被删除的这样的标号，使用类型为@code{NOTE_INSN_DELETED_LABEL}的@code{note}来替换。

@en In an @code{insn} during dead-code elimination, 1 means that the insn is
@en dead code.
在@code{insn}中，在死代码消除阶段，1表示该insn为死代码。

@en In an @code{insn} or @code{jump_insn} during reorg for an insn in the
@en delay slot of a branch,
@en 1 means that this insn is from the target of the branch.
在@code{insn}或者@code{jump_insn}中，在针对分支延迟槽中insn的reorg阶段，1表示该insn来自分支跳转的目标。

@en In an @code{insn} during instruction scheduling, 1 means that this insn
@en must be scheduled as part of a group together with the previous insn.
在@code{insn}中，在指令调度阶段，1表示该insn必须与之前的insn一起进行调度。

@en In an RTL dump, this flag is represented as @samp{/s}.
在RTL转储中，该标记被表示为@samp{/s}。

@findex return_val
@cindex @samp{/i} in RTL dump
@item return_val
@en In @code{reg} expressions, 1 means the register contains
@en the value to be returned by the current function.  On
@en machines that pass parameters in registers, the same register number
@en may be used for parameters as well, but this flag is not set on such
@en uses.
在@code{reg}表达式中，1表示寄存器包含了当且函数的返回值。对于在寄存器中传递参数的机器上，同一个寄存器编号也可以被用作参数，但是这种情况下，该标记不被设置。

@en In @code{mem} expressions, 1 means the memory reference is to a scalar
@en known not to be a member of a structure, union, or array.
在@code{mem}中，1表示内存引用为一个已知不为结构体，联合体，数组的成员的标量。

@en In @code{symbol_ref} expressions, 1 means the referenced symbol is weak.
在@code{symbol_ref}表达式中，1表示被引用的符号为weak。

@en In @code{call} expressions, 1 means the call is pure.
在@code{call}表达式中，1表示调用是pure。

@en In an RTL dump, this flag is represented as @samp{/i}.
在RTL转储中，该标记被表示为@samp{/i}。

@findex jump
@cindex @samp{/j} in RTL dump
@item jump
@en In a @code{mem} expression, 1 means we should keep the alias set for this
@en mem unchanged when we access a component.
在@code{mem}表达式中，1表示当访问一个部件时，应该保持该mem的别名集不变。

@en In a @code{set}, 1 means it is for a return.
在@code{set}中，1表示其为一个return。

@en In a @code{call_insn}, 1 means it is a sibling call.
在@code{call_insn}中，1表示其为一个sibling call。

@en In an RTL dump, this flag is represented as @samp{/j}.
在RTL转储中，该标记被表示为@samp{/j}。

@findex unchanging
@cindex @samp{/u} in RTL dump
@item unchanging
@en In @code{reg} and @code{mem} expressions, 1 means
@en that the value of the expression never changes.
在@code{reg}和@code{mem}表达式中，1表示表达式的值不会改变。

@en In @code{subreg} expressions, it is 1 if the @code{subreg} references an
@en unsigned object whose mode has been promoted to a wider mode.
在@code{subreg}表达式中，如果@code{subreg}引用了机器模式已经被提升为一个宽模式的无符号对象，则为1。 

@en In an @code{insn} or @code{jump_insn} in the delay slot of a branch
@en instruction, 1 means an annulling branch should be used.
在分支指令延迟槽中的@code{insn}或@code{jump_insn}中，1表示将使用一个被取消的分支。

@en In a @code{symbol_ref} expression, 1 means that this symbol addresses
@en something in the per-function constant pool.
在@code{symbol_ref}表达式中，1表示该符号对函数的常量池进行寻址。

@en In a @code{call_insn} 1 means that this instruction is a call to a const
@en function.
在@code{call_insn}中，1表示该指令为对const函数的调用。

@en In an RTL dump, this flag is represented as @samp{/u}.
在RTL转储中，该标记被表示为@samp{/u}。

@findex used
@item used
@en This flag is used directly (without an access macro) at the end of RTL
@en generation for a function, to count the number of times an expression
@en appears in insns.  Expressions that appear more than once are copied,
@en according to the rules for shared structure (@pxref{Sharing}).
该标记在函数的RTL生成阶段的结尾被直接使用（不通过访问宏），来计数表达式在insns中出现的次数。出现次数大于一的表达式，根据共享结构的规则（@pxref{Sharing}），被复制。

@en For a @code{reg}, it is used directly (without an access macro) by the
@en leaf register renumbering code to ensure that each register is only
@en renumbered once.
对于@code{reg}，其被叶子寄存器重编号代码直接使用（不通过访问宏），来确保每个寄存器只被重编号一次。

@en In a @code{symbol_ref}, it indicates that an external declaration for
@en the symbol has already been written.
在@code{symbol_ref}中，其表示该符号的外部声明已经被书写了。

@findex volatil
@cindex @samp{/v} in RTL dump
@item volatil
@cindex volatile memory references
@en In a @code{mem}, @code{asm_operands}, or @code{asm_input}
@en expression, it is 1 if the memory
@en reference is volatile.  Volatile memory references may not be deleted,
@en reordered or combined.
在@code{mem}, @code{asm_operands}或者@code{asm_input}表达式中，如果内存引用是volatile的，则为1。volatile的内存引用不可以被删除，重排或者合并。

@en In a @code{symbol_ref} expression, it is used for machine-specific
@en purposes.
在@code{symbol_ref}表达式中，其用于机器特定的目的。

@en In a @code{reg} expression, it is 1 if the value is a user-level variable.
@en 0 indicates an internal compiler temporary.
在@code{reg}表达式中，如果值为用户级的变量，则为1。0表示为内部的编译器临时对象。

@en In an @code{insn}, 1 means the insn has been deleted.
在@code{insn}中，1表示该insn已经被删除。

@en In @code{label_ref} and @code{reg_label} expressions, 1 means a reference
@en to a non-local label.
在@code{label_ref}和@code{reg_label}表达式中，1表示对非局部标号的引用。

In @code{prefetch} expressions, 1 means that the containing insn is a
scheduling barrier.

@en In an RTL dump, this flag is represented as @samp{/v}.
在RTL转储中，该标记被表示为@samp{/v}。
@end table

@en @node Machine Modes
@en @section Machine Modes
@node Machine Modes
@section 机器模式
@cindex machine modes

@findex enum machine_mode
@en A machine mode describes a size of data object and the representation used
@en for it.  In the C code, machine modes are represented by an enumeration
@en type, @code{enum machine_mode}, defined in @file{machmode.def}.  Each RTL
@en expression has room for a machine mode and so do certain kinds of tree
@en expressions (declarations and types, to be precise).
机器模式描述数据对象的大小及其表示。在C 代码中，机器模式表示成枚举类型@code{enum machine_mode}。此类型定义在@file{machmode.def}中。每个RTL表达式都有机器模式域。一些树结构如变量定义、类型等也有机器模式域。

@en In debugging dumps and machine descriptions, the machine mode of an RTL
@en expression is written after the expression code with a colon to separate
@en them.  The letters @samp{mode} which appear at the end of each machine mode
@en name are omitted.  For example, @code{(reg:SI 38)} is a @code{reg}
@en expression with machine mode @code{SImode}.  If the mode is
@en @code{VOIDmode}, it is not written at all.
在调试信息及机器描述中，RTL表达式的机器模式紧跟在RTL 代码之后，其间用冒号隔开。每一种机器模式名未尾的字母省缺为@samp{mode}。例如：@code{(reg:SI 38)}是一个@code{reg}表达式，其机器模式为@code{SImode}。如果方式为@code{VOIDmode}，表达式中完全不出现此模式。

@en Here is a table of machine modes.  The term ``byte'' below refers to an
@en object of @code{BITS_PER_UNIT} bits (@pxref{Storage Layout}).
以下是一个机器模式表，这里的“字节”是指具有@code{BITS_PER_UNIT}个存储位的对象
（@pxref{Storage Layout}）。

@table @code
@findex BImode
@item BImode
@en ``Bit'' mode represents a single bit, for predicate registers.
“Bit”模式，表示一位，用于断言寄存器。

@findex QImode
@item QImode
@en ``Quarter-Integer'' mode represents a single byte treated as an integer.
“Quarter-Integer”模式，表示一个一字节的整数。

@findex HImode
@item HImode
@en ``Half-Integer'' mode represents a two-byte integer.
“Half-Integer”模式，表示一个两字节的整数。

@findex PSImode
@item PSImode
@en ``Partial Single Integer'' mode represents an integer which occupies
@en four bytes but which doesn't really use all four.  On some machines,
@en this is the right mode to use for pointers.
“Partial Single Integer”模式，表示一个占有四个字节但并不真正使用全部四个字节的整数。

@findex SImode
@item SImode
@en ``Single Integer'' mode represents a four-byte integer.
“Single Integer”模式，表示一个四字节的整数。

@findex PDImode
@item PDImode
@en ``Partial Double Integer'' mode represents an integer which occupies
@en eight bytes but which doesn't really use all eight.  On some machines,
@en this is the right mode to use for certain pointers.
“Partial Double Integer”模式，表示一个占有八个字节但并不真正使用全部八个字节的整数。

@findex DImode
@item DImode
@en ``Double Integer'' mode represents an eight-byte integer.
“Double Integer”模式，表示一个8 字节的整数。

@findex TImode
@item TImode
@en ``Tetra Integer'' (?) mode represents a sixteen-byte integer.
“Tetra Integer”模式，表示一个16 字节的整数。

@findex OImode
@item OImode
@en ``Octa Integer'' (?) mode represents a thirty-two-byte integer.
“Octa Integer” 模式，表示一个32 字节的整数。

@findex QFmode
@item QFmode
@en ``Quarter-Floating'' mode represents a quarter-precision (single byte)
@en floating point number.
“Quarter-Floating” 模式，表示一个四分之一精度（单字节）浮点数。

@findex HFmode
@item HFmode
@en ``Half-Floating'' mode represents a half-precision (two byte) floating
@en point number.
“Half-Floating” 模式，表示一个二分之一精度（双字节）浮点数。

@findex TQFmode
@item TQFmode
@en ``Three-Quarter-Floating'' (?) mode represents a three-quarter-precision
@en (three byte) floating point number.
“Three-Quarter-Floating” 模式，表示一个四分之三精度（单字节）浮点数。

@findex SFmode
@item SFmode
@en ``Single Floating'' mode represents a four byte floating point number.
@en In the common case, of a processor with IEEE arithmetic and 8-bit bytes,
@en this is a single-precision IEEE floating point number; it can also be
@en used for double-precision (on processors with 16-bit bytes) and
@en single-precision VAX and IBM types.
“Single Floating”模式，表示一个单精度（4 个字节）浮点数。

@findex DFmode
@item DFmode
@en ``Double Floating'' mode represents an eight byte floating point number.
@en In the common case, of a processor with IEEE arithmetic and 8-bit bytes,
@en this is a double-precision IEEE floating point number.
“Double Floating”模式，表示一个双精度（8 字节）浮点数。


@findex XFmode
@item XFmode
@en ``Extended Floating'' mode represents an IEEE extended floating point
@en number.  This mode only has 80 meaningful bits (ten bytes).  Some
@en processors require such numbers to be padded to twelve bytes, others
@en to sixteen; this mode is used for either.
“Extended Floating”模式，表示一个三精度（12 字节）浮点数。本方式用来表示 IEEE 扩展浮点类型。

@findex SDmode
@item SDmode
@en ``Single Decimal Floating'' mode represents a four byte decimal
@en floating point number (as distinct from conventional binary floating
@en point).
``Single Decimal Floating''模式，表示一个四字节十进制浮点数（区别于常规的二进制浮点）。

@findex DDmode
@item DDmode
@en ``Double Decimal Floating'' mode represents an eight byte decimal
@en floating point number.
``Double Decimal Floating''模式，表示一个八字节十进制浮点数。

@findex TDmode
@item TDmode
@en ``Tetra Decimal Floating'' mode represents a sixteen byte decimal
@en floating point number all 128 of whose bits are meaningful.
``Tetra Decimal Floating''模式，表示一个十六字节十进制浮点数，所有128位都有含义。

@findex TFmode
@item TFmode
@en ``Tetra Floating'' mode represents a sixteen byte floating point number
@en all 128 of whose bits are meaningful.  One common use is the
@en IEEE quad-precision format.
“Tetra Floating”模式，表示一个四精度（16 字节）浮点数。

@findex QQmode
@item QQmode
@en ``Quarter-Fractional'' mode represents a single byte treated as a signed
@en fractional number.  The default format is ``s.7''.
``Quarter-Fractional''模式，表示一个单字节的有符号小数。缺省格式为``s.7''。

@findex HQmode
@item HQmode
@en ``Half-Fractional'' mode represents a two-byte signed fractional number.
@en The default format is ``s.15''.
``Half-Fractional''模式，表示一个双字节的有符号小数。缺省格式为``s.15''。

@findex SQmode
@item SQmode
@en ``Single Fractional'' mode represents a four-byte signed fractional number.
@en The default format is ``s.31''.
``Single Fractional''模式，表示一个四字节的有符号小数。缺省格式为``s.31''。

@findex DQmode
@item DQmode
@en ``Double Fractional'' mode represents an eight-byte signed fractional number.
@en The default format is ``s.63''.
``Double Fractional''模式，表示一个八字节的有符号小数。缺省格式为``s.63''。

@findex TQmode
@item TQmode
@en ``Tetra Fractional'' mode represents a sixteen-byte signed fractional number.
@en The default format is ``s.127''.
``Tetra Fractional''模式，表示一个十六字节有符号小数。缺省格式为``s.127''。

@findex UQQmode
@item UQQmode
@en ``Unsigned Quarter-Fractional'' mode represents a single byte treated as an
@en unsigned fractional number.  The default format is ``.8''.
``Unsigned Quarter-Fractional''模式，表示一个单字节的无符号小数。缺省格式为``.8''。

@findex UHQmode
@item UHQmode
@en ``Unsigned Half-Fractional'' mode represents a two-byte unsigned fractional
@en number.  The default format is ``.16''.
``Unsigned Half-Fractional''模式，表示一个双字节的无符号小数。缺省格式为``.16''。

@findex USQmode
@item USQmode
@en ``Unsigned Single Fractional'' mode represents a four-byte unsigned fractional
@en number.  The default format is ``.32''.
``Unsigned Single Fractional''模式，表示一个四字节的无符号小数。缺省格式为``.32''。

@findex UDQmode
@item UDQmode
@en ``Unsigned Double Fractional'' mode represents an eight-byte unsigned
@en fractional number.  The default format is ``.64''.
``Unsigned Double Fractional''模式，表示一个八字节的无符号小数。缺省格式为``.64''。

@findex UTQmode
@item UTQmode
@en ``Unsigned Tetra Fractional'' mode represents a sixteen-byte unsigned
@en fractional number.  The default format is ``.128''.
``Unsigned Tetra Fractional''模式，表示一个十六字节的无符号小数。缺省格式为``.128''。

@findex HAmode
@item HAmode
@en ``Half-Accumulator'' mode represents a two-byte signed accumulator.
@en The default format is ``s8.7''.
``Half-Accumulator''模式，表示一个双字节的有符号累加器。缺省格式为``s8.7''。

@findex SAmode
@item SAmode
@en ``Single Accumulator'' mode represents a four-byte signed accumulator.
@en The default format is ``s16.15''.
``Single Accumulator''模式，表示一个四字节的有符号累加器。缺省格式为``s16.15''。

@findex DAmode
@item DAmode
@en ``Double Accumulator'' mode represents an eight-byte signed accumulator.
@en The default format is ``s32.31''.
``Double Accumulator''模式，表示一个八字节的有符号累加器。缺省格式为``s32.31''。

@findex TAmode
@item TAmode
@en ``Tetra Accumulator'' mode represents a sixteen-byte signed accumulator.
@en The default format is ``s64.63''.
``Tetra Accumulator''模式，表示一个十六字节的有符号累加器。缺省格式为``s64.63''。

@findex UHAmode
@item UHAmode
@en ``Unsigned Half-Accumulator'' mode represents a two-byte unsigned accumulator.
@en The default format is ``8.8''.
``Unsigned Half-Accumulator''模式，表示一个双字节的无符号累加器。缺省格式为``8.8''。

@findex USAmode
@item USAmode
@en ``Unsigned Single Accumulator'' mode represents a four-byte unsigned
@en accumulator.  The default format is ``16.16''.
``Unsigned Single Accumulator''模式，表示一个四字节的无符号累加器。缺省格式为``16.16''。

@findex UDAmode
@item UDAmode
@en ``Unsigned Double Accumulator'' mode represents an eight-byte unsigned
@en accumulator.  The default format is ``32.32''.
``Unsigned Double Accumulator''模式，表示一个八字节的无符号累加器。缺省格式为``32.32''。

@findex UTAmode
@item UTAmode
@en ``Unsigned Tetra Accumulator'' mode represents a sixteen-byte unsigned
@en accumulator.  The default format is ``64.64''.
``Unsigned Tetra Accumulator''模式，表示一个十六字节的无符号累加器。缺省格式为``64.64''。

@findex CCmode
@item CCmode
@en ``Condition Code'' mode represents the value of a condition code, which
@en is a machine-specific set of bits used to represent the result of a
@en comparison operation.  Other machine-specific modes may also be used for
@en the condition code.  These modes are not used on machines that use
@en @code{cc0} (see @pxref{Condition Code}).
“condition code”模式，表示条件代码的值。其中条件代码是一组与机器相关的位集合，用来表示比较的结果。在使用了 cc0 的机器上，不用CCmode。

@findex BLKmode
@item BLKmode
@en ``Block'' mode represents values that are aggregates to which none of
@en the other modes apply.  In RTL, only memory references can have this mode,
@en and only if they appear in string-move or vector instructions.  On machines
@en which have no such instructions, @code{BLKmode} will not appear in RTL@.
“Block”模式，表示其它模式都不适用的聚合值。在 RTL 中，只有内存引用才能有此方式，并且仅当出现在字符串移动指令或向量指令中时，才能有此方式。若机器没有上述指令，则@code{BLKmode}将不出现在 RTL中。

@findex VOIDmode
@item VOIDmode
@en Void mode means the absence of a mode or an unspecified mode.
@en For example, RTL expressions of code @code{const_int} have mode
@en @code{VOIDmode} because they can be taken to have whatever mode the context
@en requires.  In debugging dumps of RTL, @code{VOIDmode} is expressed by
@en the absence of any mode.
意味着模式不出现或一个不确定的模式。例 如：@code{const_int}表达式的模式就是@code{VOIDmode}， 因为此类表达式可认为具有其上下文所要求的任何模式。在RTL的调试输出中，@code{VOIDmode}表示成没有任何模式出现。

@findex QCmode
@findex HCmode
@findex SCmode
@findex DCmode
@findex XCmode
@findex TCmode
@item QCmode, HCmode, SCmode, DCmode, XCmode, TCmode
@en These modes stand for a complex number represented as a pair of floating
@en point values.  The floating point values are in @code{QFmode},
@en @code{HFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}, and
@en @code{TFmode}, respectively.
这些方式模式由一对浮点数组成的复数。其中， 浮点数分别具有@code{QFmode}、@code{HFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}。

@findex CQImode
@findex CHImode
@findex CSImode
@findex CDImode
@findex CTImode
@findex COImode
@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
@en These modes stand for a complex number represented as a pair of integer
@en values.  The integer values are in @code{QImode}, @code{HImode},
@en @code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},
@en respectively.
这些模式代表由一对整数组成的复数。整数值分别具有方式@code{QImode}, @code{HImode},@code{SImode}, @code{DImode}, @code{TImode}和@code{OImode}。

@end table

@en The machine description defines @code{Pmode} as a C macro which expands
@en into the machine mode used for addresses.  Normally this is the mode
@en whose size is @code{BITS_PER_WORD}, @code{SImode} on 32-bit machines.
机器描述定义@code{Pmode}为一个C宏，其扩展为用于寻址的机器模式。通常这是一个在32位机器上，大小为@code{BITS_PER_WORD}, @code{SImode}模式。

@en The only modes which a machine description @i{must} support are
@en @code{QImode}, and the modes corresponding to @code{BITS_PER_WORD},
@en @code{FLOAT_TYPE_SIZE} and @code{DOUBLE_TYPE_SIZE}.
@en The compiler will attempt to use @code{DImode} for 8-byte structures and
@en unions, but this can be prevented by overriding the definition of
@en @code{MAX_FIXED_MODE_SIZE}.  Alternatively, you can have the compiler
@en use @code{TImode} for 16-byte structures and unions.  Likewise, you can
@en arrange for the C type @code{short int} to avoid using @code{HImode}.
机器描述唯一必须要支持的机器模式为@code{QImode}，以及对应于@code{BITS_PER_WORD}，@code{FLOAT_TYPE_SIZE}和@code{DOUBLE_TYPE_SIZE}的机器模式。编译器将尝试使用@code{DImode}，表示8字节的结构体和联合体，不过这可以通过重写@code{MAX_FIXED_MODE_SIZE}的定义来阻止。替换的，你可以让编译器使用@code{TImode}表示16字节的结构体和联合体。同样，你可以使得C类型@code{short int}避免使用@code{HImode}。

@cindex mode classes
@en Very few explicit references to machine modes remain in the compiler and
@en these few references will soon be removed.  Instead, the machine modes
@en are divided into mode classes.  These are represented by the enumeration
@en type @code{enum mode_class} defined in @file{machmode.h}.  The possible
@en mode classes are:
编译器中，有很少的对机器模式显式的引用，并且这些引用将不久被移除掉。替代的，机器模式被分成机器模式类别。这些由定义在@file{machmode.h}中的枚举类型@code{enum mode_class}来表示。可能的机器类别有：

@table @code
@findex MODE_INT
@item MODE_INT
@en Integer modes.  By default these are @code{BImode}, @code{QImode},
@en @code{HImode}, @code{SImode}, @code{DImode}, @code{TImode}, and
@en @code{OImode}.
整数模式。缺省情况下，它们是@code{BImode}, @code{QImode}, @code{HImode}, @code{SImode}, @code{DImode}, @code{TImode}和@code{OImode}。

@findex MODE_PARTIAL_INT
@item MODE_PARTIAL_INT
@en The ``partial integer'' modes, @code{PQImode}, @code{PHImode},
@en @code{PSImode} and @code{PDImode}.
部分整数模式，@code{PQImode}, @code{PHImode}, @code{PSImode}和@code{PDImode}。

@findex MODE_FLOAT
@item MODE_FLOAT
@en Floating point modes.  By default these are @code{QFmode},
@en @code{HFmode}, @code{TQFmode}, @code{SFmode}, @code{DFmode},
@en @code{XFmode} and @code{TFmode}.
浮点模式。缺省情况下，这些是@code{QFmode}, @code{HFmode}, @code{TQFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}。

@findex MODE_DECIMAL_FLOAT
@item MODE_DECIMAL_FLOAT
@en Decimal floating point modes.  By default these are @code{SDmode},
@en @code{DDmode} and @code{TDmode}.
十进制浮点模式。缺省的，这些是@code{SDmode}, @code{DDmode}和@code{TDmode}。

@findex MODE_FRACT
@item MODE_FRACT
@en Signed fractional modes.  By default these are @code{QQmode}, @code{HQmode},
@en @code{SQmode}, @code{DQmode} and @code{TQmode}.
有符号小数模式。缺省的，这些是@code{QQmode}, @code{HQmode}, @code{SQmode}, @code{DQmode}和@code{TQmode}。

@findex MODE_UFRACT
@item MODE_UFRACT
@en Unsigned fractional modes.  By default these are @code{UQQmode}, @code{UHQmode},
@en @code{USQmode}, @code{UDQmode} and @code{UTQmode}.
无符号小数模式。缺省的，这些是@code{UQQmode}, @code{UHQmode}, @code{USQmode}, @code{UDQmode}和@code{UTQmode}。

@findex MODE_ACCUM
@item MODE_ACCUM
@en Signed accumulator modes.  By default these are @code{HAmode},
@en @code{SAmode}, @code{DAmode} and @code{TAmode}.
有符号累加器模式。缺省的，这些@code{HAmode}, @code{SAmode}, @code{DAmode}和@code{TAmode}。

@findex MODE_UACCUM
@item MODE_UACCUM
@en Unsigned accumulator modes.  By default these are @code{UHAmode},
@en @code{USAmode}, @code{UDAmode} and @code{UTAmode}.
无符号累加器模式。缺省的，这些是@code{UHAmode}, @code{USAmode}, @code{UDAmode}和@code{UTAmode}。

@findex MODE_COMPLEX_INT
@item MODE_COMPLEX_INT
@en Complex integer modes.  (These are not currently implemented).
复数整数模式。（当前还没有被实现。）

@findex MODE_COMPLEX_FLOAT
@item MODE_COMPLEX_FLOAT
@en Complex floating point modes.  By default these are @code{QCmode},
@en @code{HCmode}, @code{SCmode}, @code{DCmode}, @code{XCmode}, and
@en @code{TCmode}.
复数浮点模式。缺省情况下，为@code{QCmode}, @code{HCmode}, @code{SCmode}, @code{DCmode}, @code{XCmode}和@code{TCmode}。

@findex MODE_FUNCTION
@item MODE_FUNCTION
@en Algol or Pascal function variables including a static chain.
@en (These are not currently implemented).
Algol或者Pascal函数变量，包括一个静态链。（这些目前还没有被实现。）

@findex MODE_CC
@item MODE_CC
@en Modes representing condition code values.  These are @code{CCmode} plus
@en any @code{CC_MODE} modes listed in the @file{@var{machine}-modes.def}.  
@en @xref{Jump Patterns},
@en also see @ref{Condition Code}.
表示条件码的值的模式。为@code{CCmode}加上在@file{@var{machine}-modes.def}中列出的任何@code{CC_MODE}模式。@xref{Jump Patterns}, 同时参见@ref{Condition Code}。

@findex MODE_RANDOM
@item MODE_RANDOM
@en This is a catchall mode class for modes which don't fit into the above
@en classes.  Currently @code{VOIDmode} and @code{BLKmode} are in
@en @code{MODE_RANDOM}.
这是所有不适合上面的类别的模式。目前@code{VOIDmode}和@code{BLKmode}包括在@code{MODE_RANDOM}中。

@end table

@en Here are some C macros that relate to machine modes:
这些是与机器模式相关的C宏：

@table @code
@findex GET_MODE
@item GET_MODE (@var{x})
@en Returns the machine mode of the RTX @var{x}.
返回RTX @var{x}的机器模式。

@findex PUT_MODE
@item PUT_MODE (@var{x}, @var{newmode})
@en Alters the machine mode of the RTX @var{x} to be @var{newmode}.
将RTX @var{x}的机器模式修改为@var{newmode}。

@findex NUM_MACHINE_MODES
@item NUM_MACHINE_MODES
@en Stands for the number of machine modes available on the target
@en machine.  This is one greater than the largest numeric value of any
@en machine mode.
表示目标机器上可用的机器模式的个数。比最大的机器模式数值大1。

@findex GET_MODE_NAME
@item GET_MODE_NAME (@var{m})
@en Returns the name of mode @var{m} as a string.
返回机器模式@var{m}的字符串名字。

@findex GET_MODE_CLASS
@item GET_MODE_CLASS (@var{m})
@en Returns the mode class of mode @var{m}.
返回机器模式@var{m}的类别。

@findex GET_MODE_WIDER_MODE
@item GET_MODE_WIDER_MODE (@var{m})
@en Returns the next wider natural mode.  For example, the expression
@code{GET_MODE_WIDER_MODE (QImode)} returns @code{HImode}.
返回下一个宽的自然的机器模式。例如，表达式@code{GET_MODE_WIDER_MODE (QImode)}返回@code{HImode}。

@findex GET_MODE_SIZE
@item GET_MODE_SIZE (@var{m})
@en Returns the size in bytes of a datum of mode @var{m}.
返回机器模式@var{m}的字节数。

@findex GET_MODE_BITSIZE
@item GET_MODE_BITSIZE (@var{m})
@en Returns the size in bits of a datum of mode @var{m}.
返回机器模式@var{m}位数。

@findex GET_MODE_IBIT
@item GET_MODE_IBIT (@var{m})
@en Returns the number of integral bits of a datum of fixed-point mode @var{m}.
返回定点机器模式@var{m}的整数位数。

@findex GET_MODE_FBIT
@item GET_MODE_FBIT (@var{m})
@en Returns the number of fractional bits of a datum of fixed-point mode @var{m}.
返回定点机器模式@var{m}的小数位数。

@findex GET_MODE_MASK
@item GET_MODE_MASK (@var{m})
@en Returns a bitmask containing 1 for all bits in a word that fit within
@en mode @var{m}.  This macro can only be used for modes whose bitsize is
@en less than or equal to @code{HOST_BITS_PER_INT}.
返回一个位掩码。该宏只能用于位长度小于或等于@code{HOST_BITS_PER_INT}的机器模式。

@findex GET_MODE_ALIGNMENT
@item GET_MODE_ALIGNMENT (@var{m})
@en Return the required alignment, in bits, for an object of mode @var{m}.
对于模式为@var{m}的对象，返回所要求的对齐方式，以位数为单位。

@findex GET_MODE_UNIT_SIZE
@item GET_MODE_UNIT_SIZE (@var{m})
@en Returns the size in bytes of the subunits of a datum of mode @var{m}.
@en This is the same as @code{GET_MODE_SIZE} except in the case of complex
@en modes.  For them, the unit size is the size of the real or imaginary
@en part.
返回模式为@var{m}的数据的子单元大小，以字节为单位。这与@code{GET_MODE_SIZE}相同，除了复数模式。对于它们，单元大小为实部或者虚部的大小。

@findex GET_MODE_NUNITS
@item GET_MODE_NUNITS (@var{m})
@en Returns the number of units contained in a mode, i.e.,
@en @code{GET_MODE_SIZE} divided by @code{GET_MODE_UNIT_SIZE}.
返回在一个模式中包含的单元数目，即@code{GET_MODE_UNIT_SIZE}除以@code{GET_MODE_SIZE}。

@findex GET_CLASS_NARROWEST_MODE
@item GET_CLASS_NARROWEST_MODE (@var{c})
@en Returns the narrowest mode in mode class @var{c}.
返回机器模式类别@var{c}中的最窄的模式。
@end table

@findex byte_mode
@findex word_mode
@en The global variables @code{byte_mode} and @code{word_mode} contain modes
@en whose classes are @code{MODE_INT} and whose bitsizes are either
@en @code{BITS_PER_UNIT} or @code{BITS_PER_WORD}, respectively.  On 32-bit
@en machines, these are @code{QImode} and @code{SImode}, respectively.
全局变量@code{byte_mode}和@code{word_mode}包含了类别为@code{MODE_INT}，并且位大小分别是@code{BITS_PER_UNIT}或@code{BITS_PER_WORD}的机器模式。在32位机器上，这些分别是@code{QImode}和@code{SImode}。

@en @node Constants
@en @section Constant Expression Types
@node Constants
@section 常量表达式类型
@cindex RTL constants
@cindex RTL constant expression types

@en The simplest RTL expressions are those that represent constant values.
最简单的RTL表达式是那些对常数值的表示。

@table @code
@findex const_int
@item (const_int @var{i})
@en This type of expression represents the integer value @var{i}.  @var{i}
@en is customarily accessed with the macro @code{INTVAL} as in
@en @code{INTVAL (@var{exp})}, which is equivalent to @code{XWINT (@var{exp}, 0)}.
这类表达式表示整数值@var{i}。@var{i}通常通过宏@code{INTVAL}来访问，@code{INTVAL (@var{exp})}相当于@code{XWINT (@var{exp}, 0)}。

@en Constants generated for modes with fewer bits than @code{HOST_WIDE_INT}
@en must be sign extended to full width (e.g., with @code{gen_int_mode}).
为模式所生成的常量如果位数小于@code{HOST_WIDE_INT}，则必须符号扩展为全部宽度（例如，@code{gen_int_mode}）。

@findex const0_rtx
@findex const1_rtx
@findex const2_rtx
@findex constm1_rtx
@en There is only one expression object for the integer value zero; it is
@en the value of the variable @code{const0_rtx}.  Likewise, the only
@en expression for integer value one is found in @code{const1_rtx}, the only
@en expression for integer value two is found in @code{const2_rtx}, and the
@en only expression for integer value negative one is found in
@en @code{constm1_rtx}.  Any attempt to create an expression of code
@en @code{const_int} and value zero, one, two or negative one will return
@en @code{const0_rtx}, @code{const1_rtx}, @code{const2_rtx} or
@en @code{constm1_rtx} as appropriate.
只有一个表达式对象表示整数值0；是变量@code{const0_rtx}的值。同样的，整数值1的唯一表达式为@code{const1_rtx}，整数值2的唯一表达式为@code{const2_rtx}，负1的唯一表达式为@code{constm1_rtx}。任何试图去创建值为0，1，2或者-1的@code{const_int}都会返回相应的@code{const0_rtx}, @code{const1_rtx}, @code{const2_rtx}或者@code{constm1_rtx}。

@findex const_true_rtx
@en Similarly, there is only one object for the integer whose value is
@en @code{STORE_FLAG_VALUE}.  It is found in @code{const_true_rtx}.  If
@en @code{STORE_FLAG_VALUE} is one, @code{const_true_rtx} and
@en @code{const1_rtx} will point to the same object.  If
@en @code{STORE_FLAG_VALUE} is @minus{}1, @code{const_true_rtx} and
@en @code{constm1_rtx} will point to the same object.
类似的，只有一个对象表示值为@code{STORE_FLAG_VALUE}的整数，其为@code{const_true_rtx}。如果@code{STORE_FLAG_VALUE}为1，则@code{const_true_rtx}和@code{const1_rtx}将会指向同一对象。如果@code{STORE_FLAG_VALUE}为-1，@code{const_true_rtx}和@code{constm1_rtx}将会指向同一对象。

@findex const_double
@item (const_double:@var{m} @var{i0} @var{i1} @dots{})
@en Represents either a floating-point constant of mode @var{m} or an
@en integer constant too large to fit into @code{HOST_BITS_PER_WIDE_INT}
@en bits but small enough to fit within twice that number of bits (GCC
@en does not provide a mechanism to represent even larger constants).  In
@en the latter case, @var{m} will be @code{VOIDmode}.
表示或者为一个模式为@var{m}的浮点常量，或者为一个超过@code{HOST_BITS_PER_WIDE_INT}位的，但是小于其两倍的位数的整数常量（GCC并没有提供表示更大的常量的机制）。对于后者，@var{m}将为@code{VOIDmode}。 

@findex CONST_DOUBLE_LOW
@en If @var{m} is @code{VOIDmode}, the bits of the value are stored in
@en @var{i0} and @var{i1}.  @var{i0} is customarily accessed with the macro
@en @code{CONST_DOUBLE_LOW} and @var{i1} with @code{CONST_DOUBLE_HIGH}.
如果@var{m}为@code{VOIDmode}，则值的位数存储在@var{i0}和@var{i1}中。@var{i0}使用宏@code{CONST_DOUBLE_LOW}来访问，@var{i1}使用@code{CONST_DOUBLE_HIGH}。

@en If the constant is floating point (regardless of its precision), then
@en the number of integers used to store the value depends on the size of
@en @code{REAL_VALUE_TYPE} (@pxref{Floating Point}).  The integers
@en represent a floating point number, but not precisely in the target
@en machine's or host machine's floating point format.  To convert them to
@en the precise bit pattern used by the target machine, use the macro
@en @code{REAL_VALUE_TO_TARGET_DOUBLE} and friends (@pxref{Data Output}).
如果常量为浮点（不管是什么精度），则用于存储值得整数数目取决于@code{REAL_VALUE_TYPE}的大小（@pxref{Floating Point}）。整数表示一个浮点数，但是不如target机器的或者host机器的浮点格式那么精确。要将它们转换为target机器使用的精确的位模式，使用宏@code{REAL_VALUE_TO_TARGET_DOUBLE}等（@pxref{Data Output}）。

@findex const_fixed
@item (const_fixed:@var{m} @dots{})
@en Represents a fixed-point constant of mode @var{m}.
@en The operand is a data structure of type @code{struct fixed_value} and
@en is accessed with the macro @code{CONST_FIXED_VALUE}.  The high part of
@en data is accessed with @code{CONST_FIXED_VALUE_HIGH}; the low part is
@en accessed with @code{CONST_FIXED_VALUE_LOW}.
表示一个机器模式为@var{m}定点常量。操作数是一个类型为@code{struct fixed_value}数据结构，并使用宏@code{CONST_FIXED_VALUE}来访问。数据的高部分使用@code{CONST_FIXED_VALUE_HIGH}来访问；低部分使用@code{CONST_FIXED_VALUE_LOW}来访问。

@findex const_vector
@item (const_vector:@var{m} [@var{x0} @var{x1} @dots{}])
@en Represents a vector constant.  The square brackets stand for the vector
@en containing the constant elements.  @var{x0}, @var{x1} and so on are
@en the @code{const_int}, @code{const_double} or @code{const_fixed} elements.
表示一个向量常量。方括号代表向量包含的常量元素。@var{x0}，@var{x1}等等为@code{const_int}，@code{const_double}或者@code{const_fixed}元素。

@en The number of units in a @code{const_vector} is obtained with the macro
@en @code{CONST_VECTOR_NUNITS} as in @code{CONST_VECTOR_NUNITS (@var{v})}.
在@code{const_vector}中的单元数可以通过宏@code{CONST_VECTOR_NUNITS}来获得，形如@code{CONST_VECTOR_NUNITS (@var{v})}。

@en Individual elements in a vector constant are accessed with the macro
@en @code{CONST_VECTOR_ELT} as in @code{CONST_VECTOR_ELT (@var{v}, @var{n})}
@en where @var{v} is the vector constant and @var{n} is the element
@en desired.
在向量常量中的单个元素使用宏@code{CONST_VECTOR_ELT}来访问，形如@code{CONST_VECTOR_ELT (@var{v}, @var{n})}，其中@var{v}为向量常量，@var{n}为要访问的元素编号。

@findex const_string
@item (const_string @var{str})
@en Represents a constant string with value @var{str}.  Currently this is
@en used only for insn attributes (@pxref{Insn Attributes}) since constant
@en strings in C are placed in memory.
表示一个具有值@var{str}的常量字符串。目前这只用于insn属性（@pxref{Insn Attributes}），因为C中的常量字符串存放在内存中。

@findex symbol_ref
@item (symbol_ref:@var{mode} @var{symbol})
@en Represents the value of an assembler label for data.  @var{symbol} is
@en a string that describes the name of the assembler label.  If it starts
@en with a @samp{*}, the label is the rest of @var{symbol} not including
@en the @samp{*}.  Otherwise, the label is @var{symbol}, usually prefixed
@en with @samp{_}.
表示引用数据的汇编标号的值。@var{symbol}为一个字符串，描述了汇编标号的名字。如果其起始于@samp{*}，则标号为@var{symbol}不包含@samp{*}的其余部分。否则，标号为@var{symbol}，通常具有前缀@samp{_}。

@en The @code{symbol_ref} contains a mode, which is usually @code{Pmode}.
@en Usually that is the only mode for which a symbol is directly valid.
@code{symbol_ref}包含一个机器模式，其通常为@code{Pmode}。通常这是唯一的使得符号有效的机器模式。

@findex label_ref
@item (label_ref:@var{mode} @var{label})
@en Represents the value of an assembler label for code.  It contains one
@en operand, an expression, which must be a @code{code_label} or a @code{note}
@en of type @code{NOTE_INSN_DELETED_LABEL} that appears in the instruction
@en sequence to identify the place where the label should go.
表示引用代码的汇编标号的值。其包含一个操作数，一个表达式，其必须为一个@code{code_label}或者一个@code{NOTE_INSN_DELETED_LABEL}类型的@code{note}，其出现在指令序列中，来标识标号应该处于的位置。

@en The reason for using a distinct expression type for code label
@en references is so that jump optimization can distinguish them.
对于代码标号引用，使用一个不同的表达式类型的原因是跳转优化可以区分它们。

@en The @code{label_ref} contains a mode, which is usually @code{Pmode}.
@en Usually that is the only mode for which a label is directly valid.
@code{label_ref}包含了一个机器模式，其通常为@code{Pmode}。通常这是唯一的使得标号有效的机器模式。

@findex const
@item (const:@var{m} @var{exp})
@en Represents a constant that is the result of an assembly-time
@en arithmetic computation.  The operand, @var{exp}, is an expression that
@en contains only constants (@code{const_int}, @code{symbol_ref} and
@en @code{label_ref} expressions) combined with @code{plus} and
@en @code{minus}.  However, not all combinations are valid, since the
@en assembler cannot do arbitrary arithmetic on relocatable symbols.
表示一个常量，其为汇编时算术计算的结果。操作数@var{exp}，为一个表达式，只包含了@code{plus}和@code{minus}组合的常量（@code{const_int}, @code{symbol_ref} 和 @code{label_ref}表达式）。然而，并不是所有的组合都是有效的，因为汇编器不能对重定位符号做任意的算术运算。

@var{m} should be @code{Pmode}.
@var{m}应该为@code{Pmode}。

@findex high
@item (high:@var{m} @var{exp})
@en Represents the high-order bits of @var{exp}, usually a
@en @code{symbol_ref}.  The number of bits is machine-dependent and is
@en normally the number of bits specified in an instruction that initializes
@en the high order bits of a register.  It is used with @code{lo_sum} to
@en represent the typical two-instruction sequence used in RISC machines to
@en reference a global memory location.
表示@var{exp}的高位，通常为一个@code{symbol_ref}。位数是机器相关的并且通常为初始化一个寄存器的高位的指令所指定的位数。其和@code{lo_sum}一起使用来表示典型的用于RISC机器的双指令序列来引用一个全局内存位置。

@en @var{m} should be @code{Pmode}.
@var{m}应该为@code{Pmode}。

@end table

@findex CONST0_RTX
@findex CONST1_RTX
@findex CONST2_RTX
@en The macro @code{CONST0_RTX (@var{mode})} refers to an expression with
@en value 0 in mode @var{mode}.  If mode @var{mode} is of mode class
@en @code{MODE_INT}, it returns @code{const0_rtx}.  If mode @var{mode} is of
@en mode class @code{MODE_FLOAT}, it returns a @code{CONST_DOUBLE}
@en expression in mode @var{mode}.  Otherwise, it returns a
@en @code{CONST_VECTOR} expression in mode @var{mode}.  Similarly, the macro
@en @code{CONST1_RTX (@var{mode})} refers to an expression with value 1 in
@en mode @var{mode} and similarly for @code{CONST2_RTX}.  The
@en @code{CONST1_RTX} and @code{CONST2_RTX} macros are undefined
@en for vector modes.
宏@code{CONST0_RTX (@var{mode})}指定一个具有值0，机器模式为@var{mode}的表达式。如果@var{mode}为@code{MODE_INT}类别，则返回@code{const0_rtx}。如果@var{mode}为 @code{MODE_FLOAT}类别，则返回模式为@var{mode}的表达式@code{CONST_DOUBLE}。否则，其返回一个模式为@var{mode}的表达式@code{CONST_VECTOR}。类似的，宏@code{CONST1_RTX (@var{mode})}指定一个具有值1，机器模式为@var{mode}的表达式，类似的对于@code{CONST2_RTX}。宏@code{CONST1_RTX}和@code{CONST2_RTX}对于向量模式没有定义。

@en @node Regs and Memory
@en @section Registers and Memory
@node Regs and Memory
@section 寄存器和内存
@cindex RTL register expressions
@cindex RTL memory expressions

@en Here are the RTL expression types for describing access to machine
@en registers and to main memory.
这些是描述访问机器寄存器和内存的RTL表达式类型。

@table @code
@findex reg
@cindex hard registers
@cindex pseudo registers
@item (reg:@var{m} @var{n})
@en For small values of the integer @var{n} (those that are less than
@en @code{FIRST_PSEUDO_REGISTER}), this stands for a reference to machine
@en register number @var{n}: a @dfn{hard register}.  For larger values of
@en @var{n}, it stands for a temporary value or @dfn{pseudo register}.
@en The compiler's strategy is to generate code assuming an unlimited
@en number of such pseudo registers, and later convert them into hard
@en registers or into memory references.
对于值小（那些小于@code{FIRST_PSEUDO_REGISTER}）的整数@var{n}，这表示对机器寄存器号为@var{n}的引用。对于值大的@var{n}，它表示一个临时的值或者伪寄存器（@dfn{pseudo register}）。编译器的策略是，在生成代码时假设有无限数目的伪寄存器，并在之后将它们转换为硬件寄存器（@dfn{hard register}）或者内存的引用。

@en @var{m} is the machine mode of the reference.  It is necessary because
@en machines can generally refer to each register in more than one mode.
@en For example, a register may contain a full word but there may be
@en instructions to refer to it as a half word or as a single byte, as
@en well as instructions to refer to it as a floating point number of
@en various precisions.
@var{m}为引用的机器模式。指定机器模式是有必要的，因为机器通常可以使用多种机器模式来引用每个寄存器。例如，一个寄存器可以包含一个整字，但是可以有指令来作为半字或者一个单独的字节来引用，同样，也有指令可以作为不同精度的浮点来引用。

@en Even for a register that the machine can access in only one mode,
@en the mode must always be specified.
即使对于机器只能使用一种机器模式来引用的寄存器，mode也必须被指定。

@en The symbol @code{FIRST_PSEUDO_REGISTER} is defined by the machine
@en description, since the number of hard registers on the machine is an
@en invariant characteristic of the machine.  Note, however, that not
@en all of the machine registers must be general registers.  All the
@en machine registers that can be used for storage of data are given
@en hard register numbers, even those that can be used only in certain
@en instructions or can hold only certain types of data.
符号@code{FIRST_PSEUDO_REGISTER}被机器描述定义，由于机器的硬件寄存器数目是一个不变的特征。然而要注意，并不是所有的机器寄存器都必须是通用寄存器。所有的可以用于存储数据的机器寄存器都为被给定硬件寄存器编号，即使那些只可以被用于特定指令或者只能存放特定类型数据。

@en A hard register may be accessed in various modes throughout one
@en function, but each pseudo register is given a natural mode
@en and is accessed only in that mode.  When it is necessary to describe
@en an access to a pseudo register using a nonnatural mode, a @code{subreg}
@en expression is used.
一个硬件寄存器可以在整个函数中按照多种机器模式来访问，但是每个伪寄存器都被给定一个自然的机器模式并且只能按照那个机器模式来访问。当需要描述一个使用非自然机器模式来访问伪寄存器的时候，则使用一个@code{subreg}表达式。

@en A @code{reg} expression with a machine mode that specifies more than
@en one word of data may actually stand for several consecutive registers.
@en If in addition the register number specifies a hardware register, then
@en it actually represents several consecutive hardware registers starting
@en with the specified one.
一个@code{reg}表达式具有的机器模式，如果指定了多于一个字的数据，则实际上代表了多个连续的寄存器。如果寄存器编号还指定了一个硬件寄存器，则其实际上表示起始于指定寄存器的多个连续的硬件寄存器。

@en Each pseudo register number used in a function's RTL code is
@en represented by a unique @code{reg} expression.
每个在函数的RTL代码中使用的伪寄存器编号，使用一个唯一的@code{reg}表达式来表示。

@findex FIRST_VIRTUAL_REGISTER
@findex LAST_VIRTUAL_REGISTER
@en Some pseudo register numbers, those within the range of
@en @code{FIRST_VIRTUAL_REGISTER} to @code{LAST_VIRTUAL_REGISTER} only
@en appear during the RTL generation phase and are eliminated before the
@en optimization phases.  These represent locations in the stack frame that
@en cannot be determined until RTL generation for the function has been
@en completed.  The following virtual register numbers are defined:
一些伪寄存器编号，处于@code{FIRST_VIRTUAL_REGISTER}到@code{LAST_VIRTUAL_REGISTER}之间，只在RTL生成阶段出现并且在优化阶段之前被消除。这些表示在栈帧中的位置，并且直到函数的RTL生成完成后才能确定。下列虚寄存器编号被定义：

@table @code
@findex VIRTUAL_INCOMING_ARGS_REGNUM
@item VIRTUAL_INCOMING_ARGS_REGNUM
@en This points to the first word of the incoming arguments passed on the
@en stack.  Normally these arguments are placed there by the caller, but the
@en callee may have pushed some arguments that were previously passed in
@en registers.
这指向栈上传递的参数的第一个字。通常这些参数由调用者存放，但是被调用者可能已经将之前在寄存器中传递的参数压入栈中。

@cindex @code{FIRST_PARM_OFFSET} and virtual registers
@cindex @code{ARG_POINTER_REGNUM} and virtual registers
@en When RTL generation is complete, this virtual register is replaced
@en by the sum of the register given by @code{ARG_POINTER_REGNUM} and the
@en value of @code{FIRST_PARM_OFFSET}.
当RTL生成完成时，该虚寄存器由@code{ARG_POINTER_REGNUM}给定的寄存器和@code{FIRST_PARM_OFFSET}的值的和替换。

@findex VIRTUAL_STACK_VARS_REGNUM
@cindex @code{FRAME_GROWS_DOWNWARD} and virtual registers
@item VIRTUAL_STACK_VARS_REGNUM
@en If @code{FRAME_GROWS_DOWNWARD} is defined to a nonzero value, this points
@en to immediately above the first variable on the stack.  Otherwise, it points
@en to the first variable on the stack.
如果@code{FRAME_GROWS_DOWNWARD}被定义为非0的值，则该宏指向栈上第一个变量的上一个位置。否则，其指向栈上的第一个变量。

@cindex @code{STARTING_FRAME_OFFSET} and virtual registers
@cindex @code{FRAME_POINTER_REGNUM} and virtual registers
@code{VIRTUAL_STACK_VARS_REGNUM} is replaced with the sum of the
@en register given by @code{FRAME_POINTER_REGNUM} and the value
@en @code{STARTING_FRAME_OFFSET}.
@code{VIRTUAL_STACK_VARS_REGNUM}由@code{FRAME_POINTER_REGNUM}给定的寄存器和@code{STARTING_FRAME_OFFSET}的值的和替换。

@findex VIRTUAL_STACK_DYNAMIC_REGNUM
@item VIRTUAL_STACK_DYNAMIC_REGNUM
@en This points to the location of dynamically allocated memory on the stack
@en immediately after the stack pointer has been adjusted by the amount of
@en memory desired.
该宏指向栈指针根据内存需要已经被调整后的栈上动态分配内存的位置。

@cindex @code{STACK_DYNAMIC_OFFSET} and virtual registers
@cindex @code{STACK_POINTER_REGNUM} and virtual registers
@en This virtual register is replaced by the sum of the register given by
@en @code{STACK_POINTER_REGNUM} and the value @code{STACK_DYNAMIC_OFFSET}.
该虚寄存器由@code{STACK_POINTER_REGNUM}给定的寄存器和@code{STACK_DYNAMIC_OFFSET}的值的和替换。

@findex VIRTUAL_OUTGOING_ARGS_REGNUM
@item VIRTUAL_OUTGOING_ARGS_REGNUM
@en This points to the location in the stack at which outgoing arguments
@en should be written when the stack is pre-pushed (arguments pushed using
@en push insns should always use @code{STACK_POINTER_REGNUM}).
其指向栈中，当预先压栈时（使用push insn压栈的参数应该总是使用@code{STACK_POINTER_REGNUM}），书写输出参数的位置。

@cindex @code{STACK_POINTER_OFFSET} and virtual registers
@en This virtual register is replaced by the sum of the register given by
@en @code{STACK_POINTER_REGNUM} and the value @code{STACK_POINTER_OFFSET}.
该虚拟寄存器，被替换成由@code{STACK_POINTER_REGNUM}给定的寄存器与值@code{STACK_POINTER_OFFSET}的和。

@end table

@findex subreg
@item (subreg:@var{m1} @var{reg:m2} @var{bytenum})
@en @code{subreg} expressions are used to refer to a register in a machine
@en mode other than its natural one, or to refer to one register of
@en a multi-part @code{reg} that actually refers to several registers.
@code{subreg}表达式用于按照自然的机器模式之外的，其它机器模式来引用一个寄存器，或者引用有多个寄存器组成的@code{reg}的其中一个寄存器。

@en Each pseudo register has a natural mode.  If it is necessary to
@en operate on it in a different mode, the register must be
@en enclosed in a @code{subreg}.  
每个伪寄存器都具有一个自然的机器模式。如果需要按照不同的机器模式来对其操作，则寄存器必须用@code{subreg}进行包含。

@en There are currently three supported types for the first operand of a
@en @code{subreg}:
目前对于@code{subreg}的第一个操作数，有三种被支持的类型：  

@itemize
@item pseudo registers
@en This is the most common case.  Most @code{subreg}s have pseudo
@en @code{reg}s as their first operand.
这是最常见的情况。大多@code{subreg}将伪寄存器@code{reg}作为它们的第一个操作数。

@item mem
@en @code{subreg}s of @code{mem} were common in earlier versions of GCC and
@en are still supported.  During the reload pass these are replaced by plain
@en @code{mem}s.  On machines that do not do instruction scheduling, use of
@en @code{subreg}s of @code{mem} are still used, but this is no longer
@en recommended.  Such @code{subreg}s are considered to be
@en @code{register_operand}s rather than @code{memory_operand}s before and
@en during reload.  Because of this, the scheduling passes cannot properly
@en schedule instructions with @code{subreg}s of @code{mem}, so for machines
@en that do scheduling, @code{subreg}s of @code{mem} should never be used.
@en To support this, the combine and recog passes have explicit code to
@en inhibit the creation of @code{subreg}s of @code{mem} when
@en @code{INSN_SCHEDULING} is defined.
@code{mem}的@code{subreg}，在早期版本的GCC中比较常见，现在仍被支持。在重载过程中，这些被普通的@code{mem}替换掉。在不进行指令调度的机器上，仍然使用@code{mem}的@code{subreg}，但是不推荐这样。在重载过程之前和过程之中，这样的@code{subreg}被考虑成@code{register_operand}，而不是@code{memory_operand}。因此，调度过程无法对具有@code{mem}的@code{subreg}这样的指令进行合适的调度。所以，对于进行调度的机器，不要使用@code{mem}的@code{subreg}。为此，当@code{INSN_SCHEDULING}被定义的时候，合并过程和recog过程，具有显式的代码来禁止创建@code{mem}的@code{subreg}。

@en The use of @code{subreg}s of @code{mem} after the reload pass is an area
@en that is not well understood and should be avoided.  There is still some
@en code in the compiler to support this, but this code has possibly rotted.
@en This use of @code{subreg}s is discouraged and will most likely not be
@en supported in the future.
在重载过程之后使用@code{mem}的@code{subreg}，将难以理解，应该避免这样。编译器中还有一些代码支持这些，但是这些代码可能已经过时了。这种@code{subreg}的用法不被推荐，将来很可能不被支持。

@item hard registers
@en It is seldom necessary to wrap hard registers in @code{subreg}s; such
@en registers would normally reduce to a single @code{reg} rtx.  This use of
@en @code{subreg}s is discouraged and may not be supported in the future.
很少有必要在@code{subreg}中包裹硬件寄存器；这样的寄存器通常应该被缩减为一个单独的@code{reg} rtx。这种@code{subreg}的用法不被推荐，将来可能不被支持。

@end itemize

@en @code{subreg}s of @code{subreg}s are not supported.  Using
@en @code{simplify_gen_subreg} is the recommended way to avoid this problem.
@code{subreg}的@code{subreg}不被支持。推荐使用@code{simplify_gen_subreg}来避免这种问题。

@en @code{subreg}s come in two distinct flavors, each having its own
@en usage and rules:
@code{subreg}有两种不同的风格，分别具有自己的用法和规则：

@table @asis
@item Paradoxical subregs
@en When @var{m1} is strictly wider than @var{m2}, the @code{subreg}
@en expression is called @dfn{paradoxical}.  The canonical test for this
@en class of @code{subreg} is:
当@var{m1}严格宽于@var{m2}的时候，@code{subreg}表达式被称作反常的（@dfn{paradoxical}）。对该类别的@code{subreg}的正规测试为：

@smallexample
GET_MODE_SIZE (@var{m1}) > GET_MODE_SIZE (@var{m2})
@end smallexample

@en Paradoxical @code{subreg}s can be used as both lvalues and rvalues.
@en When used as an lvalue, the low-order bits of the source value
@en are stored in @var{reg} and the high-order bits are discarded.
@en When used as an rvalue, the low-order bits of the @code{subreg} are
@en taken from @var{reg} while the high-order bits may or may not be
@en defined.  
反常的@code{subreg}可以用于左值和右值。当用于左值时，源值的低位被存储在@var{reg}中，高位被丢弃。当用作右值时，@code{subreg}的低位来自@var{reg}，而高位可以被定义，也可以未被定义。

@en The high-order bits of rvalues are in the following circumstances:
右值的高位有以下几种情况：

@itemize
@item @code{subreg}s of @code{mem}
@en When @var{m2} is smaller than a word, the macro @code{LOAD_EXTEND_OP},
@en can control how the high-order bits are defined.
当@var{m2}小于一个字的时候，宏@code{LOAD_EXTEND_OP}可以控制高位如何被定义。

@item @code{subreg} of @code{reg}s
@en The upper bits are defined when @code{SUBREG_PROMOTED_VAR_P} is true.
@en @code{SUBREG_PROMOTED_UNSIGNED_P} describes what the upper bits hold.
@en Such subregs usually represent local variables, register variables
@en and parameter pseudo variables that have been promoted to a wider mode.
当@code{SUBREG_PROMOTED_VAR_P}为真时，高位被定义。@code{SUBREG_PROMOTED_UNSIGNED_P}描述了高位的内容。这样的subreg通常表示已经被提升为更宽的机器模式的局部变量，寄存器变量以及参数伪变量。

@end itemize

@en @var{bytenum} is always zero for a paradoxical @code{subreg}, even on
@en big-endian targets.
对于反常的@code{subreg}，@var{bytenum}总是为零，即使在大端的目标机上。

@en For example, the paradoxical @code{subreg}:
例如反常的@code{subreg}:

@smallexample
(set (subreg:SI (reg:HI @var{x}) 0) @var{y})
@end smallexample

@en stores the lower 2 bytes of @var{y} in @var{x} and discards the upper
@en 2 bytes.  A subsequent:
在@var{x}中存储了@var{y}的低位2个字节，并丢弃高位2个字节。接着：

@smallexample
(set @var{z} (subreg:SI (reg:HI @var{x}) 0))
@end smallexample

@en would set the lower two bytes of @var{z} to @var{y} and set the upper
@en two bytes to an unknown value assuming @code{SUBREG_PROMOTED_VAR_P} is
@en false.
将会把@var{z}的低位2个字节设置成@var{x}，并将高位两个字节设置为未知的值，假定@code{SUBREG_PROMOTED_VAR_P}为假。

@item Normal subregs 
@en When @var{m1} is at least as narrow as @var{m2} the @code{subreg}
@en expression is called @dfn{normal}.
当@var{m1}最多跟@var{m2}一样宽的时候，@code{subreg}表达式被称作正常的（@dfn{normal}）。

@en Normal @code{subreg}s restrict consideration to certain bits of
@en @var{reg}.  There are two cases.  If @var{m1} is smaller than a word,
@en the @code{subreg} refers to the least-significant part (or
@en @dfn{lowpart}) of one word of @var{reg}.  If @var{m1} is word-sized or
@en greater, the @code{subreg} refers to one or more complete words.
正常的@code{subreg}被限定为@var{reg}的特定位。有两种情况。如果@var{m1}比一个字小，则@code{subreg}指的是一个@var{reg}字的最小有效部分。如果@var{m1}为字大小，或者更大，则@code{subreg}指的是一个或者更多个完整的字。

@en When used as an lvalue, @code{subreg} is a word-based accessor.
@en Storing to a @code{subreg} modifies all the words of @var{reg} that
@en overlap the @code{subreg}, but it leaves the other words of @var{reg}
@en alone.
当用作左值时，@code{subreg}为一个基于字的访问。对@code{subreg}进行存储，会修改@var{reg}中所有与@code{subreg}重叠的字，并将@var{reg}中的其它字保持不变。

@en When storing to a normal @code{subreg} that is smaller than a word,
@en the other bits of the referenced word are usually left in an undefined
@en state.  This laxity makes it easier to generate efficient code for
@en such instructions.  To represent an instruction that preserves all the
@en bits outside of those in the @code{subreg}, use @code{strict_low_part}
@en or @code{zero_extract} around the @code{subreg}.
当对小于一个字的正常@code{subreg}进行存储的时候，被引用的字的其它位通常处于未定义的状态。这种松弛的方式易于对这样的指令产生高效的代码。要表示保持@code{subreg}之外的所有位的指令，在@code{subreg}周围使用@code{strict_low_part}或者@code{zero_extract}。

@en @var{bytenum} must identify the offset of the first byte of the
@en @code{subreg} from the start of @var{reg}, assuming that @var{reg} is
@en laid out in memory order.  The memory order of bytes is defined by
@en two target macros, @code{WORDS_BIG_ENDIAN} and @code{BYTES_BIG_ENDIAN}:
@var{bytenum}必须标识从@var{reg}的起始，@code{subreg}的第一个字节的偏移量，假设@var{reg}按照内存的顺序布局。字节的内存顺序通过两个目标宏定义，@code{WORDS_BIG_ENDIAN}和@code{BYTES_BIG_ENDIAN}：

@itemize
@item
@cindex @code{WORDS_BIG_ENDIAN}, effect on @code{subreg}
@en @code{WORDS_BIG_ENDIAN}, if set to 1, says that byte number zero is
@en part of the most significant word; otherwise, it is part of the least
@en significant word.
@code{WORDS_BIG_ENDIAN}，如果设为1，则说明第零个字节为最大有效字的部分；否则，为最小有效字的部分。

@item
@cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}
@cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}
@en @code{BYTES_BIG_ENDIAN}, if set to 1, says that byte number zero is
@en the most significant byte within a word; otherwise, it is the least
@en significant byte within a word.
@code{BYTES_BIG_ENDIAN}，如果设为1，则说明第零个字节为字中的最高有效字节；否则，为字中的最低有效字节。

@end itemize

@cindex @code{FLOAT_WORDS_BIG_ENDIAN}, (lack of) effect on @code{subreg}
@en On a few targets, @code{FLOAT_WORDS_BIG_ENDIAN} disagrees with
@en @code{WORDS_BIG_ENDIAN}.  However, most parts of the compiler treat
@en floating point values as if they had the same endianness as integer
@en values.  This works because they handle them solely as a collection of
@en integer values, with no particular numerical value.  Only real.c and
@en the runtime libraries care about @code{FLOAT_WORDS_BIG_ENDIAN}.
在一些目标机上，@code{FLOAT_WORDS_BIG_ENDIAN}与@code{WORDS_BIG_ENDIAN}不一致。然而，编译器的大部分地方会将浮点值看作它们与整数值具有相同的大小端。这是因为只将它们作为整数值的集合来处理，没有特定的数值。只有real.c和运行时库关心@code{FLOAT_WORDS_BIG_ENDIAN}。

@en Thus, 
因此，

@smallexample
(subreg:HI (reg:SI @var{x}) 2)
@end smallexample

@en on a @code{BYTES_BIG_ENDIAN}, @samp{UNITS_PER_WORD == 4} target is the same as
在一个@code{BYTES_BIG_ENDIAN}，@samp{UNITS_PER_WORD == 4}的目标机上，等同于

@smallexample
(subreg:HI (reg:SI @var{x}) 0)
@end smallexample

@en on a little-endian, @samp{UNITS_PER_WORD == 4} target.  Both
@en @code{subreg}s access the lower two bytes of register @var{x}.
在一个小端，@samp{UNITS_PER_WORD == 4}的目标机上。两个@code{subreg}都是访问寄存器@var{x}的低两个字节。

@end table

@en A @code{MODE_PARTIAL_INT} mode behaves as if it were as wide as the
@en corresponding @code{MODE_INT} mode, except that it has an unknown
@en number of undefined bits.  For example:
@code{MODE_PARTIAL_INT}机器模式的行为就好像其与相对应的@code{MODE_INT}机器模式一样宽，只不过其具有未知数目的未定义的位。例如： 

@smallexample
(subreg:PSI (reg:SI 0) 0)
@end smallexample

@en accesses the whole of @samp{(reg:SI 0)}, but the exact relationship
@en between the @code{PSImode} value and the @code{SImode} value is not
@en defined.  If we assume @samp{UNITS_PER_WORD <= 4}, then the following
@en two @code{subreg}s:
访问整个@samp{(reg:SI 0)}，但是@code{PSImode}值和@code{SImode}值的确切关系没有被定义。如果我们假设@samp{UNITS_PER_WORD <= 4}，则下面两个@code{subreg}：

@smallexample
(subreg:PSI (reg:DI 0) 0)
(subreg:PSI (reg:DI 0) 4)
@end smallexample

@en represent independent 4-byte accesses to the two halves of
@en @samp{(reg:DI 0)}.  Both @code{subreg}s have an unknown number
@en of undefined bits.
表示对@samp{(reg:DI 0)}的两个部分进行无关的四个字节访问。每个@code{subreg}都具有未知数目的未定义位。

@en If @samp{UNITS_PER_WORD <= 2} then these two @code{subreg}s:
如果@samp{UNITS_PER_WORD <= 2}，则这两个@code{subreg}

@smallexample
(subreg:HI (reg:PSI 0) 0)
(subreg:HI (reg:PSI 0) 2)
@end smallexample

@en represent independent 2-byte accesses that together span the whole
@en of @samp{(reg:PSI 0)}.  Storing to the first @code{subreg} does not
@en affect the value of the second, and vice versa.  @samp{(reg:PSI 0)}
@en has an unknown number of undefined bits, so the assignment:
表示无关的两个字节访问，一起贯穿整个@samp{(reg:PSI 0)}。对第一个@code{subreg}进行存储不影响第二个的值，反之亦然。@samp{(reg:PSI 0)}具有未知数目的未定义位，所以赋值：

@smallexample
(set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
@end smallexample

@en does not guarantee that @samp{(subreg:HI (reg:PSI 0) 0)} has the
@en value @samp{(reg:HI 4)}.
不保证@samp{(subreg:HI (reg:PSI 0) 0)}具有值@samp{(reg:HI 4)}。

@cindex @code{CANNOT_CHANGE_MODE_CLASS} and subreg semantics
@en The rules above apply to both pseudo @var{reg}s and hard @var{reg}s.
@en If the semantics are not correct for particular combinations of
@en @var{m1}, @var{m2} and hard @var{reg}, the target-specific code
@en must ensure that those combinations are never used.  For example:
上面的规则应用于伪寄存器@var{reg}和硬件寄存器@var{reg}。如果对于@var{m1}, @var{m2}和硬件寄存器@var{reg}的特定组合，其语义不正确，则目标机特定的代码必须确保这些组合不会被用到。例如：

@smallexample
CANNOT_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})
@end smallexample

@en must be true for every class @var{class} that includes @var{reg}.
必须为真，对于每个包含@var{reg}的类别@var{class}。

@findex SUBREG_REG
@findex SUBREG_BYTE
@en The first operand of a @code{subreg} expression is customarily accessed
@en with the @code{SUBREG_REG} macro and the second operand is customarily
@en accessed with the @code{SUBREG_BYTE} macro.
@code{subreg}表达式的第一个操作数通常使用@code{SUBREG_REG}宏来访问，第二个操作数通常使用@code{SUBREG_BYTE}宏来访问。

@en It has been several years since a platform in which
@en @code{BYTES_BIG_ENDIAN} not equal to @code{WORDS_BIG_ENDIAN} has
@en been tested.  Anyone wishing to support such a platform in the future
@en may be confronted with code rot.
@code{BYTES_BIG_ENDIAN}不等于@code{WORDS_BIG_ENDIAN}的平台是在很多年前被测试的。对于希望在将来支持这样一个平台的人们，可能会面对一些过时的代码。

@findex scratch
@cindex scratch operands
@item (scratch:@var{m})
@en This represents a scratch register that will be required for the
@en execution of a single instruction and not used subsequently.  It is
@en converted into a @code{reg} by either the local register allocator or
@en the reload pass.
这表示一个scratch寄存器，其在单个指令的执行中用到，并随后不再被使用。其被局部寄存器分配或者重载过程，转换成一个@code{reg}。

@en @code{scratch} is usually present inside a @code{clobber} operation
@en (@pxref{Side Effects}).
@code{scratch}通常位于@code{clobber}操作中。(@pxref{Side Effects})。

@findex cc0
@cindex condition code register
@item (cc0)
@en This refers to the machine's condition code register.  It has no
@en operands and may not have a machine mode.  There are two ways to use it:
为机器的条件代码寄存器。其没有参数，并可以没有机器模式。有两种使用它的方式：

@itemize @bullet
@item
@en To stand for a complete set of condition code flags.  This is best on
@en most machines, where each comparison sets the entire series of flags.
表示一个完整的条件代码标记的集合。这在大多机器上是最好的方式，每个比较都会设置整个标记系列。

@en With this technique, @code{(cc0)} may be validly used in only two
@en contexts: as the destination of an assignment (in test and compare
@en instructions) and in comparison operators comparing against zero
@en (@code{const_int} with value zero; that is to say, @code{const0_rtx}).
使用这种技术，@code{(cc0)}只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中）和在跟零进行比较的比较运算符中（值为零的@code{const_int}；也就是说，@code{const0_rtx}）。

@item
@en To stand for a single flag that is the result of a single condition.
@en This is useful on machines that have only a single flag bit, and in
@en which comparison instructions must specify the condition to test.
表示单个标记，为单个条件的结果。这用于只有一个标记位，比较指令必须指定要测试的条件的机器上。

@en With this technique, @code{(cc0)} may be validly used in only two
@en contexts: as the destination of an assignment (in test and compare
@en instructions) where the source is a comparison operator, and as the
@en first operand of @code{if_then_else} (in a conditional branch).
使用这种技术，@code{(cc0)}只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中），其中源操作数为一个比较运算符，以及@code{if_then_else}的第一个参数（在条件分支中）。

@end itemize

@findex cc0_rtx
@en There is only one expression object of code @code{cc0}; it is the
@en value of the variable @code{cc0_rtx}.  Any attempt to create an
@en expression of code @code{cc0} will return @code{cc0_rtx}.
只有一个代码为@code{cc0}的表达式对象；其为变量@code{cc0_rtx}的值。任何尝试创建一个代码为@code{cc0}的表达式，将返回@code{cc0_rtx}。

@en Instructions can set the condition code implicitly.  On many machines,
@en nearly all instructions set the condition code based on the value that
@en they compute or store.  It is not necessary to record these actions
@en explicitly in the RTL because the machine description includes a
@en prescription for recognizing the instructions that do so (by means of
@en the macro @code{NOTICE_UPDATE_CC}).  @xref{Condition Code}.  Only
@en instructions whose sole purpose is to set the condition code, and
@en instructions that use the condition code, need mention @code{(cc0)}.
指令可以隐式的设置条件代码。在许多机器上，几乎所有的指令根据它们计算或者存储的值来设置条件码。没有必要在RTL中显式的记录这些行为，因为机器描述包含一个对策，用于识别这样做的指令（通过宏@code{NOTICE_UPDATE_CC}）。@xref{Condition Code}. 只有目的纯粹是设置条件码的指令，以及使用条件码的指令，才需要提及@code{(cc0)}。

@en On some machines, the condition code register is given a register number
@en and a @code{reg} is used instead of @code{(cc0)}.  This is usually the
@en preferable approach if only a small subset of instructions modify the
@en condition code.  Other machines store condition codes in general
@en registers; in such cases a pseudo register should be used.
在一些机器上，条件码寄存器被给定一个寄存器编号，并且一个@code{reg}用于替代@code{(cc0)}。这通常为更好的方式，如果只有一个小的指令子集修改条件码。其它机器将条件码存储在通用寄存器中；这种情况下应该使用伪寄存器。

@en Some machines, such as the SPARC and RS/6000, have two sets of
@en arithmetic instructions, one that sets and one that does not set the
@en condition code.  This is best handled by normally generating the
@en instruction that does not set the condition code, and making a pattern
@en that both performs the arithmetic and sets the condition code register
@en (which would not be @code{(cc0)} in this case).  For examples, search
@en for @samp{addcc} and @samp{andcc} in @file{sparc.md}.
一些机器，例如SPARC和RS/6000，具有两个算术指令集合，一个设置条件码，另一个不设置。可以通常情况下生成不设置条件码的指令，并创建一个同时执行算术运算并设置条件码寄存器（这种情况下将不会是@code{(cc0)}）的指令模式。例如，搜一下@file{sparc.md}中的@samp{addcc}和@samp{andcc}。

@findex pc
@item (pc)
@cindex program counter
@en This represents the machine's program counter.  It has no operands and
@en may not have a machine mode.  @code{(pc)} may be validly used only in
@en certain specific contexts in jump instructions.
表示机器的程序计数器。其没有操作数并可能没有机器模式。@code{(pc)}只在跳转指令的特定上下文中使用。

@findex pc_rtx
@en There is only one expression object of code @code{pc}; it is the value
@en of the variable @code{pc_rtx}.  Any attempt to create an expression of
@en code @code{pc} will return @code{pc_rtx}.
只有一个代码为@code{pc}的表达式对象；其为变量@code{pc_rtx}的值。任何尝试创建一个代码为@code{pc}的表达式，将返回@code{pc_rtx}。

@en All instructions that do not jump alter the program counter implicitly
@en by incrementing it, but there is no need to mention this in the RTL@.
所有不进行跳转的指令会隐式的通过递增的方式改变程序计数器，但是不需要在RTL中提起这些。

@findex mem
@item (mem:@var{m} @var{addr} @var{alias})
@en This RTX represents a reference to main memory at an address
@en represented by the expression @var{addr}.  @var{m} specifies how large
@en a unit of memory is accessed.  @var{alias} specifies an alias set for the
@en reference.  In general two items are in different alias sets if they cannot
@en reference the same memory address.
该RTX表示对表达式@var{addr}所表示的地址的主内存进行引用。@var{m}描述了被访问的内存的单元大小。@var{alias}描述了该引用的别名集合。总得来说，两个项如果不引用相同的内存地址，则在不同的别名集合里。

@en The construct @code{(mem:BLK (scratch))} is considered to alias all
@en other memories.  Thus it may be used as a memory barrier in epilogue
@en stack deallocation patterns.
结构@code{(mem:BLK (scratch))}被认为是所有其它内存的别名。因此其可以在函数尾声的栈销毁中用作内存栅栏。

@findex concat
@item (concat@var{m} @var{rtx} @var{rtx})
@en This RTX represents the concatenation of two other RTXs.  This is used
@en for complex values.  It should only appear in the RTL attached to
@en declarations and during RTL generation.  It should not appear in the
@en ordinary insn chain.
该RTX表示对两个其它RTX的连结。这用于复数值。其应该只出现在附加在声明中的RTL中，以及RTL生成中。不应该出现在普通的insn链上。

@findex concatn
@item (concatn@var{m} [@var{rtx} @dots{}])
@en This RTX represents the concatenation of all the @var{rtx} to make a
@en single value.  Like @code{concat}, this should only appear in
@en declarations, and not in the insn chain.
该RTX表示将所有的@var{rtx}进行连结，生成一个单个的值。类似@code{concat}，其应该只出现在声明中，不应该出现在insn链上。

@end table

@en @node Arithmetic
@en @section RTL Expressions for Arithmetic
@node Arithmetic
@section RTL算术运算表达式
@cindex arithmetic, in RTL
@cindex math, in RTL
@cindex RTL expressions for arithmetic

@en Unless otherwise specified, all the operands of arithmetic expressions
@en must be valid for mode @var{m}.  An operand is valid for mode @var{m}
@en if it has mode @var{m}, or if it is a @code{const_int} or
@en @code{const_double} and @var{m} is a mode of class @code{MODE_INT}.
除非其它规定，所有算术表达式的操作数必须对模式@var{m}有效。一个操作数对模式@var{m}有效，是指当它具有模式@var{m}，或者如果它是一个@code{const_int}或者@code{const_double}，并且@var{m}是一个@code{MODE_INT}类的模式。

@en For commutative binary operations, constants should be placed in the
@en second operand.
对于可交换的二进制操作，常量应该放到第二个操作数的位置。

@table @code
@findex plus
@findex ss_plus
@findex us_plus
@cindex RTL sum
@cindex RTL addition
@cindex RTL addition with signed saturation
@cindex RTL addition with unsigned saturation
@item (plus:@var{m} @var{x} @var{y})
@itemx (ss_plus:@var{m} @var{x} @var{y})
@itemx (us_plus:@var{m} @var{x} @var{y})
@en These three expressions all represent the sum of the values
@en represented by @var{x} and @var{y} carried out in machine mode
@en @var{m}.  They differ in their behavior on overflow of integer modes.
@en @code{plus} wraps round modulo the width of @var{m}; @code{ss_plus}
@en saturates at the maximum signed value representable in @var{m};
@en @code{us_plus} saturates at the maximum unsigned value.
这三个表达式都表示@var{x}和@var{y}所表示的值的和，机器模式为@var{m}。它们在整数机器模式的溢出方面有所不同。@code{plus}以@var{m}的宽度求模进行环绕；@code{ss_plus}饱和为@var{m}可表示的有符号最大值；@code{us_plus}饱和为无符号最大值。

@c ??? What happens on overflow of floating point modes?

@findex lo_sum
@item (lo_sum:@var{m} @var{x} @var{y})
@en This expression represents the sum of @var{x} and the low-order bits
@en of @var{y}.  It is used with @code{high} (@pxref{Constants}) to
@en represent the typical two-instruction sequence used in RISC machines
@en to reference a global memory location.
该表达式表示@var{x}与@var{y}低位的和。其跟@code{high} (@pxref{Constants})一起使用，来表示在RISC机器中通常使用的两个指令序列，来引用一个全局内存位置。

@en The number of low order bits is machine-dependent but is
@en normally the number of bits in a @code{Pmode} item minus the number of
@en bits set by @code{high}.
低位的位数是机器相关的，但通常为@code{Pmode}中的位数减去@code{high}所设置的位数。

@en @var{m} should be @code{Pmode}.
@var{m}应该为@code{Pmode}。

@findex minus
@findex ss_minus
@findex us_minus
@cindex RTL difference
@cindex RTL subtraction
@cindex RTL subtraction with signed saturation
@cindex RTL subtraction with unsigned saturation
@item (minus:@var{m} @var{x} @var{y})
@itemx (ss_minus:@var{m} @var{x} @var{y})
@itemx (us_minus:@var{m} @var{x} @var{y})

@en These three expressions represent the result of subtracting @var{y}
@en from @var{x}, carried out in mode @var{M}.  Behavior on overflow is
@en the same as for the three variants of @code{plus} (see above).
这三个表达式表示从@var{x}中减去@var{y}的结果，机器模式为@var{m}。在溢出方面的行为与@code{plus}的三种版本相同（参见上面）。

@findex compare
@cindex RTL comparison
@item (compare:@var{m} @var{x} @var{y})
@en Represents the result of subtracting @var{y} from @var{x} for purposes
@en of comparison.  The result is computed without overflow, as if with
@en infinite precision.
表示从@var{x}中减去@var{y}的结果，用于进行比较。计算结果不产生溢出，就好像是有无限的精度一样。

@en Of course, machines can't really subtract with infinite precision.
@en However, they can pretend to do so when only the sign of the result will
@en be used, which is the case when the result is stored in the condition
@en code.  And that is the @emph{only} way this kind of expression may
@en validly be used: as a value to be stored in the condition codes, either
@en @code{(cc0)} or a register.  @xref{Comparisons}.
当然，机器不会真的进行无限精度的减法。然而，它们可以假定这样做，当只使用结果的正负符号时，这样情况下，结果被存放在条件代码中。并且，这是这种表达式唯一可以被使用的方式：作为值存储在条件代码中，或者@code{(cc0)}，或者一个寄存器。@xref{Comparisons}.

@en The mode @var{m} is not related to the modes of @var{x} and @var{y}, but
@en instead is the mode of the condition code value.  If @code{(cc0)} is
@en used, it is @code{VOIDmode}.  Otherwise it is some mode in class
@en @code{MODE_CC}, often @code{CCmode}.  @xref{Condition Code}.  If @var{m}
@en is @code{VOIDmode} or @code{CCmode}, the operation returns sufficient
@en information (in an unspecified format) so that any comparison operator
@en can be applied to the result of the @code{COMPARE} operation.  For other
@en modes in class @code{MODE_CC}, the operation only returns a subset of
@en this information.
机器模式@var{m}与@var{x}和@var{y}的机器模式没有关联，而是条件代码值的机器模式。如果使用@code{(cc0)}，则为@code{VOIDmode}，否则为类别@code{MODE_CC}中的某个模式，通常为@code{CCmode}。@xref{Condition Code}. 如果@var{m}为@code{VOIDmode}或者@code{CCmode}，则运算会返回足够的信息，使得任何比较运算符可以被应用到@code{COMPARE}运算的结果上。对于类别@code{MODE_CC}中的其它机器模式，运算只返回信息的子集。

@en Normally, @var{x} and @var{y} must have the same mode.  Otherwise,
@en @code{compare} is valid only if the mode of @var{x} is in class
@en @code{MODE_INT} and @var{y} is a @code{const_int} or
@en @code{const_double} with mode @code{VOIDmode}.  The mode of @var{x}
@en determines what mode the comparison is to be done in; thus it must not
@en be @code{VOIDmode}.
通常，@var{x}和@var{y}必须具有相同的机器模式。否则，@code{compare}只有当@var{x}的机器模式在类别@code{MODE_INT}中，并且@var{y}为一个机器模式为@code{VOIDmode}的@code{const_int}或者@code{const_double}，这时才有效。@var{x}的机器模式决定了比较按照什么机器模式进行；因此其不能为@code{VOIDmode}。

@en If one of the operands is a constant, it should be placed in the
@en second operand and the comparison code adjusted as appropriate.
如果其中一个操作数为常量，则其应该被放在第二个操作数的位置，并且相应的调整比较代码。

@en A @code{compare} specifying two @code{VOIDmode} constants is not valid
@en since there is no way to know in what mode the comparison is to be
@en performed; the comparison must either be folded during the compilation
@en or the first operand must be loaded into a register while its mode is
@en still known.
指定两个@code{VOIDmode}常量的@code{compare}是无效的，因为无法知道比较要按照什么机器模式进行；比较必须或者在编译过程中被折叠，或者第一个操作数必须被加载到机器模式已知的寄存器中。

@findex neg
@findex ss_neg
@findex us_neg
@cindex negation
@cindex negation with signed saturation
@cindex negation with unsigned saturation
@item (neg:@var{m} @var{x})
@itemx (ss_neg:@var{m} @var{x})
@itemx (us_neg:@var{m} @var{x})
@en These two expressions represent the negation (subtraction from zero) of
@en the value represented by @var{x}, carried out in mode @var{m}.  They
@en differ in the behavior on overflow of integer modes.  In the case of
@en @code{neg}, the negation of the operand may be a number not representable
@en in mode @var{m}, in which case it is truncated to @var{m}.  @code{ss_neg}
@en and @code{us_neg} ensure that an out-of-bounds result saturates to the
@en maximum or minimum signed or unsigned value.
这两个表达式表示@var{x}所表示的值的负数（零减去该值），机器模式为@var{m}。它们在整数机器模式的溢出行为上有所不同。对于@code{neg}，操作数的负数可以为无法用机器模式@var{m}表示的数，这种情况下，其被截取为@var{m}。@code{ss_neg}和@code{us_neg}确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

@findex mult
@findex ss_mult
@findex us_mult
@cindex multiplication
@cindex product
@cindex multiplication with signed saturation
@cindex multiplication with unsigned saturation
@item (mult:@var{m} @var{x} @var{y})
@itemx (ss_mult:@var{m} @var{x} @var{y})
@itemx (us_mult:@var{m} @var{x} @var{y})
@en Represents the signed product of the values represented by @var{x} and
@en @var{y} carried out in machine mode @var{m}.
@en @code{ss_mult} and @code{us_mult} ensure that an out-of-bounds result
@en saturates to the maximum or minimum signed or unsigned value.
表示@var{x}和@var{y}所表示的值的有符号乘积，机器模式为@var{m}。@code{ss_mult}和@code{us_mult}确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

@en Some machines support a multiplication that generates a product wider
@en than the operands.  Write the pattern for this as
一些机器支持产生比操作数更宽的乘积。则指令模式可以写成

@smallexample
(mult:@var{m} (sign_extend:@var{m} @var{x}) (sign_extend:@var{m} @var{y}))
@end smallexample

@en where @var{m} is wider than the modes of @var{x} and @var{y}, which need
@en not be the same.
其中@var{m}比@var{x}和@var{y}的机器模式更宽。

@en For unsigned widening multiplication, use the same idiom, but with
@en @code{zero_extend} instead of @code{sign_extend}.
对于无符号的加宽的乘法，使用相同的语句，只不过把@code{sign_extend}替换成@code{zero_extend}。

@findex div
@findex ss_div
@cindex division
@cindex signed division
@cindex signed division with signed saturation
@cindex quotient
@item (div:@var{m} @var{x} @var{y})
@itemx (ss_div:@var{m} @var{x} @var{y})
@en Represents the quotient in signed division of @var{x} by @var{y},
@en carried out in machine mode @var{m}.  If @var{m} is a floating point
@en mode, it represents the exact quotient; otherwise, the integerized
@en quotient.
@en @code{ss_div} ensures that an out-of-bounds result saturates to the maximum
@en or minimum signed value.
表示@var{x}有符号除以@var{y}的商，机器模式为@var{m}。如果@var{m}为一个浮点机器模式，则表示确切的商；否则为整数化的商。@code{ss_div}确保超出边界的结果饱和为最大或者最小的有符号值。

@en Some machines have division instructions in which the operands and
@en quotient widths are not all the same; you should represent
@en such instructions using @code{truncate} and @code{sign_extend} as in,
一些机器具有的除法指令，其操作数和商的宽度不全相同；你应该使用@code{truncate}和@code{sign_extend}来表示这样的指令，

@smallexample
(truncate:@var{m1} (div:@var{m2} @var{x} (sign_extend:@var{m2} @var{y})))
@end smallexample

@findex udiv
@cindex unsigned division
@cindex unsigned division with unsigned saturation
@cindex division
@item (udiv:@var{m} @var{x} @var{y})
@itemx (us_div:@var{m} @var{x} @var{y})
@en Like @code{div} but represents unsigned division.
@en @code{us_div} ensures that an out-of-bounds result saturates to the maximum
@en or minimum unsigned value.
类似@code{div}，不过表示无符号除法。@code{us_div}确保超出边界的结果饱和为最大或者最小的无符号值。

@findex mod
@findex umod
@cindex remainder
@cindex division
@item (mod:@var{m} @var{x} @var{y})
@itemx (umod:@var{m} @var{x} @var{y})
@en Like @code{div} and @code{udiv} but represent the remainder instead of
@en the quotient.
类似@code{div}和@code{udiv}，不过表示余数。

@findex smin
@findex smax
@cindex signed minimum
@cindex signed maximum
@item (smin:@var{m} @var{x} @var{y})
@itemx (smax:@var{m} @var{x} @var{y})
@en Represents the smaller (for @code{smin}) or larger (for @code{smax}) of
@en @var{x} and @var{y}, interpreted as signed values in mode @var{m}.
@en When used with floating point, if both operands are zeros, or if either
@en operand is @code{NaN}, then it is unspecified which of the two operands
@en is returned as the result.
表示@var{x}和@var{y}的较小值（@code{smin}）或者较大值（@code{smax}），按照机器模式为@var{m}的有符号值解析。当用于浮点，如果两个操作数都为零，或者其中一个为@code{NaN}，则没有规定哪一个操作数被作为结果返回。

@findex umin
@findex umax
@cindex unsigned minimum and maximum
@item (umin:@var{m} @var{x} @var{y})
@itemx (umax:@var{m} @var{x} @var{y})
@en Like @code{smin} and @code{smax}, but the values are interpreted as unsigned
@en integers.
类似@code{smin}和@code{smax}，不过值被解析为无符号整数。

@findex not
@cindex complement, bitwise
@cindex bitwise complement
@item (not:@var{m} @var{x})
@en Represents the bitwise complement of the value represented by @var{x},
@en carried out in mode @var{m}, which must be a fixed-point machine mode.
表示对@var{x}所表示的值进行按位求补，机器模式为@var{m}，且必须为一个定点机器模式。

@findex and
@cindex logical-and, bitwise
@cindex bitwise logical-and
@item (and:@var{m} @var{x} @var{y})
@en Represents the bitwise logical-and of the values represented by
@en @var{x} and @var{y}, carried out in machine mode @var{m}, which must be
@en a fixed-point machine mode.
表示对@var{x}和@var{y}所表示的值按位进行逻辑与，机器模式为@var{m}，且必须为一个定点机器模式。

@findex ior
@cindex inclusive-or, bitwise
@cindex bitwise inclusive-or
@item (ior:@var{m} @var{x} @var{y})
@en Represents the bitwise inclusive-or of the values represented by @var{x}
@en and @var{y}, carried out in machine mode @var{m}, which must be a
@en fixed-point mode.
表示对@var{x}和@var{y}所表示的值按位进行逻辑或，机器模式为@var{m}，且必须为一个定点机器模式。

@findex xor
@cindex exclusive-or, bitwise
@cindex bitwise exclusive-or
@item (xor:@var{m} @var{x} @var{y})
@en Represents the bitwise exclusive-or of the values represented by @var{x}
@en and @var{y}, carried out in machine mode @var{m}, which must be a
@en fixed-point mode.
表示对@var{x}和@var{y}所表示的值按位进行逻辑异或，机器模式为@var{m}，且必须为一个定点机器模式。

@findex ashift
@findex ss_ashift
@findex us_ashift
@cindex left shift
@cindex shift
@cindex arithmetic shift
@cindex arithmetic shift with signed saturation
@cindex arithmetic shift with unsigned saturation
@item (ashift:@var{m} @var{x} @var{c})
@itemx (ss_ashift:@var{m} @var{x} @var{c})
@itemx (us_ashift:@var{m} @var{x} @var{c})
@en These three expressions represent the result of arithmetically shifting @var{x}
@en left by @var{c} places.  They differ in their behavior on overflow of integer
@en modes.  An @code{ashift} operation is a plain shift with no special behavior
@en in case of a change in the sign bit; @code{ss_ashift} and @code{us_ashift}
@en saturates to the minimum or maximum representable value if any of the bits
@en shifted out differs from the final sign bit.
这三个表达式用来表示对@var{x}进行向左算术移位@var{c}。它们在整数机器模式的溢出方面有所不同。@code{ashift}运算是一个普通的移位，当符号位有改变时，其没有特殊的行为；@code{ss_ashift}和@code{us_ashift}，饱和为可表示的最小或者最大值，如果任何被移出的位与最终的符号位不同。

@en @var{x} have mode @var{m}, a fixed-point machine mode.  @var{c}
@en be a fixed-point mode or be a constant with mode @code{VOIDmode}; which
@en mode is determined by the mode called for in the machine description
@en entry for the left-shift instruction.  For example, on the VAX, the mode
@en of @var{c} is @code{QImode} regardless of @var{m}.
@var{x}具有机器模式@var{m}，一个定点机器模式。@var{c}为一个定点机器模式或者一个模式为@code{VOIDmode}的常量。

@findex lshiftrt
@cindex right shift
@findex ashiftrt
@item (lshiftrt:@var{m} @var{x} @var{c})
@itemx (ashiftrt:@var{m} @var{x} @var{c})
@en Like @code{ashift} but for right shift.  Unlike the case for left shift,
@en these two operations are distinct.
类似于@code{ashift}，不过是向右移位。不像向左移位的情况，这两种运算是有区别的。

@findex rotate
@cindex rotate
@cindex left rotate
@findex rotatert
@cindex right rotate
@item (rotate:@var{m} @var{x} @var{c})
@itemx (rotatert:@var{m} @var{x} @var{c})
@en Similar but represent left and right rotate.  If @var{c} is a constant,
@en use @code{rotate}.
类似的，只不过是表示向左和向右旋转。如果@var{c}为常量，则使用@code{rotate}。

@findex abs
@cindex absolute value
@item (abs:@var{m} @var{x})
@en Represents the absolute value of @var{x}, computed in mode @var{m}.
@en @code{ss_abs} ensures that an out-of-bounds result saturates to the
@en maximum signed value.
表示@var{x}的绝对值，按照机器模式@var{m}来计算。

@findex sqrt
@cindex square root
@item (sqrt:@var{m} @var{x})
@en Represents the square root of @var{x}, computed in mode @var{m}.
@en Most often @var{m} will be a floating point mode.
表示@var{x}的平方根，按照机器模式@var{m}来计算。@var{m}通常为浮点机器模式。

@findex ffs
@item (ffs:@var{m} @var{x})
@en Represents one plus the index of the least significant 1-bit in
@en @var{x}, represented as an integer of mode @var{m}.  (The value is
@en zero if @var{x} is zero.)  The mode of @var{x} need not be @var{m};
@en depending on the target machine, various mode combinations may be
@en valid.
表示在@var{x}中，最低有效，位为1的索引加上1，为一个模式@var{m}的整数。（如果@var{x}为零，则值为零。）@var{x}的机器模式不需要为@var{m}；取决于目标机器，可以有不同的机器模式的组合。

@findex clz
@item (clz:@var{m} @var{x})
@en Represents the number of leading 0-bits in @var{x}, represented as an
@en integer of mode @var{m}, starting at the most significant bit position.
@en If @var{x} is zero, the value is determined by
@code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}).  Note that this is one of
@en the few expressions that is not invariant under widening.  The mode of
@en @var{x} will usually be an integer mode.
表示@var{x}中，从最高有效位开始，起始处为0的位数，为一个模式@var{m}的整数。如果@var{x}为零，则值由@code{CLZ_DEFINED_VALUE_AT_ZERO}
(@pxref{Misc})来确定。注意，。@var{x}的机器模式通常为一个整数模式。

@findex ctz
@item (ctz:@var{m} @var{x})
@en Represents the number of trailing 0-bits in @var{x}, represented as an
@en integer of mode @var{m}, starting at the least significant bit position.
@en If @var{x} is zero, the value is determined by
@en @code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}).  Except for this case,
@en @code{ctz(x)} is equivalent to @code{ffs(@var{x}) - 1}.  The mode of
@en @var{x} will usually be an integer mode.
表示@var{x}中，从最低有效位开始，结尾处为0的位数，为一个模式@var{m}的整数。如果@var{x}为零，则值由@code{CTZ_DEFINED_VALUE_AT_ZERO}
(@pxref{Misc})来确定。除此之外，@code{ctz(x)}等价于@code{ffs(@var{x}) - 1}。@var{x}的机器模式通常为一个整数模式。

@findex popcount
@item (popcount:@var{m} @var{x})
@en Represents the number of 1-bits in @var{x}, represented as an integer of
@en mode @var{m}.  The mode of @var{x} will usually be an integer mode.
表示@var{x}中为1的位数，为一个模式@var{m}的整数。@var{x}的机器模式通常为一个整数模式。

@findex parity
@item (parity:@var{m} @var{x})
@en Represents the number of 1-bits modulo 2 in @var{x}, represented as an
@en integer of mode @var{m}.  The mode of @var{x} will usually be an integer
@en mode.
表示@var{x}中为1的位数对2进行求模，为一个模式@var{m}的整数。@var{x}的机器模式通常为一个整数模式。

@findex bswap
@item (bswap:@var{m} @var{x})
@en Represents the value @var{x} with the order of bytes reversed, carried out
@en in mode @var{m}, which must be a fixed-point machine mode.
表示将@var{x}值的字节顺序进行反转，结果为@var{m}机器模式，其必须为一个定点机器模式。
@end table

@en @node Comparisons
@en @section Comparison Operations
@node Comparisons
@section 比较运算
@cindex RTL comparison operations

@en Comparison operators test a relation on two operands and are considered
@en to represent a machine-dependent nonzero value described by, but not
@en necessarily equal to, @code{STORE_FLAG_VALUE} (@pxref{Misc})
@en if the relation holds, or zero if it does not, for comparison operators
@en whose results have a `MODE_INT' mode,
@en @code{FLOAT_STORE_FLAG_VALUE} (@pxref{Misc}) if the relation holds, or
@en zero if it does not, for comparison operators that return floating-point
@en values, and a vector of either @code{VECTOR_STORE_FLAG_VALUE} (@pxref{Misc})
@en if the relation holds, or of zeros if it does not, for comparison operators
@en that return vector results.
@en The mode of the comparison operation is independent of the mode
@en of the data being compared.  If the comparison operation is being tested
@en (e.g., the first operand of an @code{if_then_else}), the mode must be
@en @code{VOIDmode}.
比较运算符测试两个操作数的关系，对于结果具有`MODE_INT'机器模式的比较运算，如果关系成立，则表示成机器相关的非零值，其由@code{STORE_FLAG_VALUE}
(@pxref{Misc})描述，但是不需要相等，如果不成立，则为零。对于结果为浮点值的比较运算，如果关系成立，则为@code{FLOAT_STORE_FLAG_VALUE}
(@pxref{Misc})，否则为零。对于返回向量结果的比较运算，如果关系成立，则为@code{VECTOR_STORE_FLAG_VALUE}
(@pxref{Misc})，否则为零向量。比较运算的机器模式独立于被比较的数据的机器模式。如果正在测试比较运算（例如，@code{if_then_else}的第一个操作数），则机器模式必须为@code{VOIDmode}。

@cindex condition codes
@en There are two ways that comparison operations may be used.  The
@en comparison operators may be used to compare the condition codes
@en @code{(cc0)} against zero, as in @code{(eq (cc0) (const_int 0))}.  Such
@en a construct actually refers to the result of the preceding instruction
@en in which the condition codes were set.  The instruction setting the
@en condition code must be adjacent to the instruction using the condition
@en code; only @code{note} insns may separate them.
有两种方式可以被比较运算使用。比较运算符可以用于将条件代码@code{(cc0)}与零进行比较，型如@code{(eq (cc0) (const_int 0))}。这种结构实际上是用到了先前指令的结果，条件代码在那里被设置。设置条件代码的指令必须邻接于使用条件代码的指令；只有@code{note} insn可以分开它们。

@en Alternatively, a comparison operation may directly compare two data
@en objects.  The mode of the comparison is determined by the operands; they
@en must both be valid for a common machine mode.  A comparison with both
@en operands constant would be invalid as the machine mode could not be
@en deduced from it, but such a comparison should never exist in RTL due to
@en constant folding.
替换的，比较运算可以直接比较两个数据对象。比较运算的机器模式由操作数来决定；它们必须对一个共同的机器模式有效。对两个操作数都为常量的比较，将是无效的，因为不能从中推导出机器模式，不过这样的比较不会出现在RTL中，因为常数折叠。

@en In the example above, if @code{(cc0)} were last set to
@en @code{(compare @var{x} @var{y})}, the comparison operation is
@en identical to @code{(eq @var{x} @var{y})}.  Usually only one style
@en of comparisons is supported on a particular machine, but the combine
@en pass will try to merge the operations to produce the @code{eq} shown
@en in case it exists in the context of the particular insn involved.
在上面的例子中，如果@code{(cc0)}最后被设置为@code{(compare @var{x} @var{y})}，则比较运算等价于@code{(eq @var{x} @var{y})}。通常，在一个特定的机器上，只支持一种风格的比较。但是，合并过程将尝试合并运算，从而产生@code{eq}。

@en Inequality comparisons come in two flavors, signed and unsigned.  Thus,
@en there are distinct expression codes @code{gt} and @code{gtu} for signed and
@en unsigned greater-than.  These can produce different results for the same
@en pair of integer values: for example, 1 is signed greater-than @minus{}1 but not
@en unsigned greater-than, because @minus{}1 when regarded as unsigned is actually
@en @code{0xffffffff} which is greater than 1.
不等式比较有两种，有符号和无符号。因此，对于有符号和无符号的大于，有两个不同的表达式代码@code{gt}和@code{gtu}。对于相同的整数值，这些可以产生不同的结果：例如，1有符号大于@minus{}1，但是并不无符号大于，因为@minus{}1被作为无符号时，实际为@code{0xffffffff}，其大于1。

@en The signed comparisons are also used for floating point values.  Floating
@en point comparisons are distinguished by the machine modes of the operands.
有符号比较也用于浮点值。浮点比较通过操作数的机器模式来区分。

@table @code
@findex eq
@cindex equal
@item (eq:@var{m} @var{x} @var{y})
@en @code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
@en are equal, otherwise 0.
如果@var{x}和@var{y}所表示的值相等，则为@code{STORE_FLAG_VALUE}，否则为0。

@findex ne
@cindex not equal
@item (ne:@var{m} @var{x} @var{y})
@en @code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
@en are not equal, otherwise 0.
如果@var{x}和@var{y}所表示的值不相等，则为@code{STORE_FLAG_VALUE}，否则为0。

@findex gt
@cindex greater than
@item (gt:@var{m} @var{x} @var{y})
@en @code{STORE_FLAG_VALUE} if the @var{x} is greater than @var{y}.  If they
@en are fixed-point, the comparison is done in a signed sense.
如果@var{x}比@var{y}大，则为@code{STORE_FLAG_VALUE}。如果它们为定点，则按照有符号比较。

@findex gtu
@cindex greater than
@cindex unsigned greater than
@item (gtu:@var{m} @var{x} @var{y})
@en Like @code{gt} but does unsigned comparison, on fixed-point numbers only.
类似于@code{gt}，不过进行无符号比较，只用于定点数。

@findex lt
@cindex less than
@findex ltu
@cindex unsigned less than
@item (lt:@var{m} @var{x} @var{y})
@itemx (ltu:@var{m} @var{x} @var{y})
@en Like @code{gt} and @code{gtu} but test for ``less than''.
类似于@code{gt}和@code{gtu}，不过测试“小于”。

@findex ge
@cindex greater than
@findex geu
@cindex unsigned greater than
@item (ge:@var{m} @var{x} @var{y})
@itemx (geu:@var{m} @var{x} @var{y})
@en Like @code{gt} and @code{gtu} but test for ``greater than or equal''.
类似于@code{gt}和@code{gtu}，不过测试“大于或等于”。

@findex le
@cindex less than or equal
@findex leu
@cindex unsigned less than
@item (le:@var{m} @var{x} @var{y})
@itemx (leu:@var{m} @var{x} @var{y})
@en Like @code{gt} and @code{gtu} but test for ``less than or equal''.
类似于@code{gt}和@code{gtu}，不过测试“小于或等于”。

@findex if_then_else
@item (if_then_else @var{cond} @var{then} @var{else})
@en This is not a comparison operation but is listed here because it is
@en always used in conjunction with a comparison operation.  To be
@en precise, @var{cond} is a comparison expression.  This expression
@en represents a choice, according to @var{cond}, between the value
@en represented by @var{then} and the one represented by @var{else}.
这不是比较运算，但是被列在这里，因为其总是与比较运算结合使用。确切的说，@var{cond}为一个比较表达式。该表达式表示一个根据@var{cond}，在@var{then}所表示的值和@var{else}所表示的值之间的选择，

@en On most machines, @code{if_then_else} expressions are valid only
@en to express conditional jumps.
在大多数机器上，@code{if_then_else}表达式只用于表示条件跳转。

@findex cond
@item (cond [@var{test1} @var{value1} @var{test2} @var{value2} @dots{}] @var{default})
@en Similar to @code{if_then_else}, but more general.  Each of @var{test1},
@en @var{test2}, @dots{} is performed in turn.  The result of this expression is
@en the @var{value} corresponding to the first nonzero test, or @var{default} if
@en none of the tests are nonzero expressions.
类似于@code{if_then_else}，不过更普通。每个@var{test1}，@var{test2}，@dots{}被依次执行。表达式的结果为对应于第一个非零测试的@var{value}，或者如果测试都为零，则为@var{default}。

@en This is currently not valid for instruction patterns and is supported only
@en for insn attributes.  @xref{Insn Attributes}.
这目前在指令模式中不可用，只在insn属性中被支持。@xref{Insn Attributes}.

@end table

@en @node Bit-Fields
@en @section Bit-Fields
@node Bit-Fields
@section 位域
@cindex bit-fields

@en Special expression codes exist to represent bit-field instructions.
有专门的表达式代码来表示位域指令。

@table @code
@findex sign_extract
@cindex @code{BITS_BIG_ENDIAN}, effect on @code{sign_extract}
@item (sign_extract:@var{m} @var{loc} @var{size} @var{pos})
@en This represents a reference to a sign-extended bit-field contained or
@en starting in @var{loc} (a memory or register reference).  The bit-field
@en is @var{size} bits wide and starts at bit @var{pos}.  The compilation
@en option @code{BITS_BIG_ENDIAN} says which end of the memory unit
@en @var{pos} counts from.
这表示了对在@var{loc}处包含的或者起始的符号扩展位域的引用（内存或者寄存器引用）。位域为@var{size}个位数宽并且在位@var{pos}处起始。编译选项@code{BITS_BIG_ENDIAN}指明了@var{pos}从内存单元的那个端开始。 

@en If @var{loc} is in memory, its mode must be a single-byte integer mode.
@en If @var{loc} is in a register, the mode to use is specified by the
@en operand of the @code{insv} or @code{extv} pattern
@en (@pxref{Standard Names}) and is usually a full-word integer mode,
@en which is the default if none is specified.
如果@var{loc}在内存中，则它的机器模式必须为一个单个字节的整数机器模式。如果@var{loc}在寄存器中，则使用的机器模式是通过@code{insv}或者@code{extv}指令模式的操作数来指定的（@pxref{Standard Names}）并且通常为一个全字的整数机器模式，这当没有任何指定的时候为缺省的。

@en The mode of @var{pos} is machine-specific and is also specified
@en in the @code{insv} or @code{extv} pattern.
@var{pos}的机器模式为机器特定的并且总是在@code{insv}或者@code{extv}指令模式中被指定。

@en The mode @var{m} is the same as the mode that would be used for
@en @var{loc} if it were a register.
机器模式@var{m}与@var{loc}所使用的相同，如果它是在寄存器中。

@en A @code{sign_extract} can not appear as an lvalue, or part thereof,
@en in RTL.
在RTL中，@code{sign_extract}不可以作为左值或者是其中的一部分出现。

@findex zero_extract
@item (zero_extract:@var{m} @var{loc} @var{size} @var{pos})
@en Like @code{sign_extract} but refers to an unsigned or zero-extended
@en bit-field.  The same sequence of bits are extracted, but they
@en are filled to an entire word with zeros instead of by sign-extension.
类似@code{sign_extract}，但是指向一个无符号或者零扩展的位域。相同的位序列被抽取，但是它们被填充到一个整字中，并使用零扩展而不是符号扩展。 

@en Unlike @code{sign_extract}, this type of expressions can be lvalues
@en in RTL; they may appear on the left side of an assignment, indicating
@en insertion of a value into the specified bit-field.
不像@code{sign_extract}，该表达式的类型可以在RTL中为左值；它们可以出现在一个赋值的左边，来表明在一个指定的位域插入一个值。

@end table

@en @node Vector Operations
@en @section Vector Operations
@node Vector Operations
@section 向量运算
@cindex vector operations

@en All normal RTL expressions can be used with vector modes; they are
@en interpreted as operating on each part of the vector independently.
@en Additionally, there are a few new expressions to describe specific vector
@en operations.
所有普通的RTL表达式都能够作为向量模式使用；它们被解析为对向量的每个部分进行独立的运算。另外，有一些新的表达式来描述特定的向量运算。

@table @code
@findex vec_merge
@item (vec_merge:@var{m} @var{vec1} @var{vec2} @var{items})
@en This describes a merge operation between two vectors.  The result is a vector
@en of mode @var{m}; its elements are selected from either @var{vec1} or
@en @var{vec2}.  Which elements are selected is described by @var{items}, which
@en is a bit mask represented by a @code{const_int}; a zero bit indicates the
@en corresponding element in the result vector is taken from @var{vec2} while
@en a set bit indicates it is taken from @var{vec1}.
这描述了两个向量间的合并操作。结果为机器模式为@var{m}的向量；它的元素来自@var{vec1}或者@var{vec2}。那些元素被选择是通过@var{items}来描述，其为一个由@code{const_int}表示的位掩码；0位指示相应的元素在结果向量中是来自@var{vec2}，而1指示其来自@var{vec1}。 

@findex vec_select
@item (vec_select:@var{m} @var{vec1} @var{selection})
@en This describes an operation that selects parts of a vector.  @var{vec1} is
@en the source vector, and @var{selection} is a @code{parallel} that contains a
@en @code{const_int} for each of the subparts of the result vector, giving the
@en number of the source subpart that should be stored into it.  
@en The result mode @var{m} is either the submode for a single element of
@en @var{vec1} (if only one subpart is selected), or another vector mode 
@en with that element submode (if multiple subparts are selected).
这描述了选择一个向量的一部分的操作。@var{vec1}为源向量，@var{selection}为一个@code{parallel}其包含了一个@code{const_int}，来描述结果向量的子部分，给出了源向量的子部分应该被存放进去。 

@findex vec_concat
@item (vec_concat:@var{m} @var{vec1} @var{vec2})
@en Describes a vector concat operation.  The result is a concatenation of the
@en vectors @var{vec1} and @var{vec2}; its length is the sum of the lengths of
@en the two inputs.
描述了一个向量连接操作。结果为向量@var{vec1}和@var{vec2}的连接；其长度为两个输出向量的长度之和。

@findex vec_duplicate
@item (vec_duplicate:@var{m} @var{vec})
@en This operation converts a small vector into a larger one by duplicating the
@en input values.  The output vector mode must have the same submodes as the
@en input vector mode, and the number of output parts must be an integer multiple
@en of the number of input parts.
该操作将一个小向量转换为一个大一点的，通过复制输入值。输出向量的机器模式必须和输入向量的相同，并且输出部分的编号必须为输入部分的编号的整数倍。

@end table

@en @node Conversions
@en @section Conversions
@node Conversions
@section 转换
@cindex conversions
@cindex machine mode conversions

@en All conversions between machine modes must be represented by
@en explicit conversion operations.  For example, an expression
@en which is the sum of a byte and a full word cannot be written as
@en @code{(plus:SI (reg:QI 34) (reg:SI 80))} because the @code{plus}
@en operation requires two operands of the same machine mode.
@en Therefore, the byte-sized operand is enclosed in a conversion
@en operation, as in
所有机器模式之间的转换都必须使用显示的转换符来表示。例如，一个表示字节和全字之和的表达式就不能写成@code{(plus:SI (reg:QI 34) (reg:SI 80))}，因为@code{plus}操作符需要两个具有相同机器模式的操作符。因此，字节长度的操作数被封装在一个转换操作中，如

@smallexample
(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))
@end smallexample

@en The conversion operation is not a mere placeholder, because there
@en may be more than one way of converting from a given starting mode
@en to the desired final mode.  The conversion operation code says how
@en to do it.
转换符并不仅仅是一个形式上的占位符，因为可能会有多种方式将给出的最初模式转换为期望的最终模式。转换符指出了如何进行这种操作。

@en For all conversion operations, @var{x} must not be @code{VOIDmode}
@en because the mode in which to do the conversion would not be known.
@en The conversion must either be done at compile-time or @var{x}
@en must be placed into a register.
对于所有的转换操作，@var{x}不能为@code{VOIDmode}，因为这样就无法知道如何进行转换操作。转换必须在编译时进行或者@var{x}必须被放入寄存器中。

@table @code
@findex sign_extend
@item (sign_extend:@var{m} @var{x})
@en Represents the result of sign-extending the value @var{x}
@en to machine mode @var{m}.  @var{m} must be a fixed-point mode
@en and @var{x} a fixed-point value of a mode narrower than @var{m}.
表示将@var{x}的值符号扩展为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式窄的定点值。

@findex zero_extend
@item (zero_extend:@var{m} @var{x})
@en Represents the result of zero-extending the value @var{x}
@en to machine mode @var{m}.  @var{m} must be a fixed-point mode
@en and @var{x} a fixed-point value of a mode narrower than @var{m}.
表示将@var{x}的值零扩展为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式窄的定点值。

@findex float_extend
@item (float_extend:@var{m} @var{x})
@en Represents the result of extending the value @var{x}
@en to machine mode @var{m}.  @var{m} must be a floating point mode
@en and @var{x} a floating point value of a mode narrower than @var{m}.
表示将@var{x}的值扩展为机器模式@var{m}后的结果。@var{m}必须是一个浮点模式，并且@var{x}是一个比@var{m}模式窄的浮点值。

@findex truncate
@item (truncate:@var{m} @var{x})
@en Represents the result of truncating the value @var{x}
@en to machine mode @var{m}.  @var{m} must be a fixed-point mode
@en and @var{x} a fixed-point value of a mode wider than @var{m}.
表示将@var{x}的值截短为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式宽的定点值。

@findex ss_truncate
@item (ss_truncate:@var{m} @var{x})
@en Represents the result of truncating the value @var{x}
@en to machine mode @var{m}, using signed saturation in the case of
@en overflow.  Both @var{m} and the mode of @var{x} must be fixed-point
@en modes.
表示将@var{x}的值截短为机器模式@var{m}后的结果，并且在溢出时作为有符号数处理。@var{m}和@var{x}的模式都必须是定点模式。

@findex us_truncate
@item (us_truncate:@var{m} @var{x})
@en Represents the result of truncating the value @var{x}
@en to machine mode @var{m}, using unsigned saturation in the case of
@en overflow.  Both @var{m} and the mode of @var{x} must be fixed-point
@en modes.
表示将@var{x}的值截短为机器模式@var{m}后的结果，并且在溢出时作为无符号数处理。@var{m}和@var{x}的模式都必须是定点模式。

@findex float_truncate
@item (float_truncate:@var{m} @var{x})
@en Represents the result of truncating the value @var{x}
@en to machine mode @var{m}.  @var{m} must be a floating point mode
@en and @var{x} a floating point value of a mode wider than @var{m}.
表示将@var{x}的值截短为机器模式@var{m}后的结果。@var{m}必须是一个浮定点模式，并且@var{x}是一个比@var{m}模式宽的浮点值。

@findex float
@item (float:@var{m} @var{x})
@en Represents the result of converting fixed point value @var{x},
@en regarded as signed, to floating point mode @var{m}.
表示将定点值@var{x}转换为有符号的浮点模式@var{m}后的结果。

@findex unsigned_float
@item (unsigned_float:@var{m} @var{x})
@en Represents the result of converting fixed point value @var{x},
@en regarded as unsigned, to floating point mode @var{m}.
表示将定点值@var{x}转换为无符号的浮点模式@var{m}后的结果。

@findex fix
@item (fix:@var{m} @var{x})
@en When @var{m} is a floating-point mode, represents the result of
@en converting floating point value @var{x} (valid for mode @var{m}) to an
@en integer, still represented in floating point mode @var{m}, by rounding
@en towards zero.
当@var{m}是一个浮点模式时，表示将浮点值@var{x}（对模式@var{m}有效）转换为整形，仍然使用浮点模式@var{m}表示，只不过是向零方向进行舍入。

@en When @var{m} is a fixed-point mode, represents the result of
@en converting floating point value @var{x} to mode @var{m}, regarded as
@en signed.  How rounding is done is not specified, so this operation may
@en be used validly in compiling C code only for integer-valued operands.
当@var{m}是一个定点模式时，表示将浮点值@var{x}转换为有符号的模式@var{m}的结果。具体如何舍入没有做出规定。所以，这个操作可能只是被用在编译C代码时的整数值的操作数。

@findex unsigned_fix
@item (unsigned_fix:@var{m} @var{x})
@en Represents the result of converting floating point value @var{x} to
@en fixed point mode @var{m}, regarded as unsigned.  How rounding is done
@en is not specified.
表示将浮点值@var{x}转换为无符号的定点模式@var{m}。具体如何舍入没有做出规定。

@findex fract_convert
@item (fract_convert:@var{m} @var{x})
@en Represents the result of converting fixed-point value @var{x} to
@en fixed-point mode @var{m}, signed integer value @var{x} to
@en fixed-point mode @var{m}, floating-point value @var{x} to
@en fixed-point mode @var{m}, fixed-point value @var{x} to integer mode @var{m}
@en regarded as signed, or fixed-point value @var{x} to floating-point mode @var{m}.
@en When overflows or underflows happen, the results are undefined.
表示将定点值转换成定点机器模式@var{m}，将有符号整数值@var{x}转换成定点机器模式@var{m}，将浮点值@var{x}转换成定点机器模式@var{m}，将定点值@var{x}转换成有符号整数机器模式@var{m}，或者将浮点值@var{x}转换成浮点机器模式的结果。当发生溢出或者下溢，则结果未定义。

@findex sat_fract
@item (sat_fract:@var{m} @var{x})
@en Represents the result of converting fixed-point value @var{x} to
@en fixed-point mode @var{m}, signed integer value @var{x} to
@en fixed-point mode @var{m}, or floating-point value @var{x} to
@en fixed-point mode @var{m}.
@en When overflows or underflows happen, the results are saturated to the
@en maximum or the minimum.
表示将定点值@var{x}转换为浮点模式@var{m}，将有符号整数值@var{x}转换为定点模式@var{m}，或者将浮点值@var{x}转换为定点模式@var{m}的结果。当发生溢出或者下溢，则结果被饱和为最大值或者最小值。

@findex unsigned_fract_convert
@item (unsigned_fract_convert:@var{m} @var{x})
@en Represents the result of converting fixed-point value @var{x} to
@en integer mode @var{m} regarded as unsigned, or unsigned integer value @var{x} to
@en fixed-point mode @var{m}.
@en When overflows or underflows happen, the results are undefined.
表示将定点值@var{x}转换为无符号整数模式@var{m}，或者将无符号整数值@var{x}转换为定点模式@var{m}的结果。当发生溢出或者下溢，则结果未定义。

@findex unsigned_sat_fract
@item (unsigned_sat_fract:@var{m} @var{x})
@en Represents the result of converting unsigned integer value @var{x} to
@en fixed-point mode @var{m}.
@en When overflows or underflows happen, the results are saturated to the
@en maximum or the minimum.
表示将无符号整数值@var{x}转换为定点模式@var{m}的结果。当发生溢出或者下溢，则结果被饱和为最大值或者最小值。

@end table

@en @node RTL Declarations
@en @section Declarations
@node RTL Declarations
@section 声明
@cindex RTL declarations
@cindex declarations, RTL

@en Declaration expression codes do not represent arithmetic operations
@en but rather state assertions about their operands.
声明表达式代码并不表示算术运算，而是关于它们的操作数状态的断言。

@table @code
@findex strict_low_part
@cindex @code{subreg}, in @code{strict_low_part}
@item (strict_low_part (subreg:@var{m} (reg:@var{n} @var{r}) 0))
@en This expression code is used in only one context: as the destination operand of a
@en @code{set} expression.  In addition, the operand of this expression
@en must be a non-paradoxical @code{subreg} expression.
这个表达式代码只用在一种上下文中：作为@code{set}表达式的目标操作数。另外，这个表达式的操作数必须是一个non-paradoxical @code{subreg}表达式 

@en The presence of @code{strict_low_part} says that the part of the
@en register which is meaningful in mode @var{n}, but is not part of
@en mode @var{m}, is not to be altered.  Normally, an assignment to such
@en a subreg is allowed to have undefined effects on the rest of the
@en register when @var{m} is less than a word.
这里@code{strict_low_part}指出寄存器中对于模式@var{n}有意义，但对于模式@var{m}却无意义的那一部分，是不能被修改的。通常，对于这样的subreg进行赋值，当@var{m}小于一个字时，是允许对寄存器的其它部分有未定义的影响。

@end table

@en @node Side Effects
@en @section Side Effect Expressions
@node Side Effects
@section 副作用表达式
@cindex RTL side effect expressions

@en The expression codes described so far represent values, not actions.
@en But machine instructions never produce values; they are meaningful
@en only for their side effects on the state of the machine.  Special
@en expression codes are used to represent side effects.
目前为止，所描述的表达式代码都是用来表示一个值，而不是操作。但是机器指令是不会产生值的，而只是通过副作用来改变机器状态。特定的表达式代码被用来表示副作用。

@en The body of an instruction is always one of these side effect codes;
@en the codes described above, which represent values, appear only as
@en the operands of these.
一条指令的主体，总是这些副作用代码之一；上面描述的表示值的代码，只是作为操作数出现在其中。

@table @code
@findex set
@item (set @var{lval} @var{x})
@en Represents the action of storing the value of @var{x} into the place
@en represented by @var{lval}.  @var{lval} must be an expression
@en representing a place that can be stored in: @code{reg} (or @code{subreg},
@en @code{strict_low_part} or @code{zero_extract}), @code{mem}, @code{pc},
@en @code{parallel}, or @code{cc0}.
表示将@var{x}的值存放到由@var{lval}表示的地方。@var{lval}必须是表示可以用来存放的地方的表达式：@code{reg}（或者@code{subreg}，@code{strict_low_part}或者@code{zero_extract}），@code{mem}，@code{pc}，@code{parallel}或者@code{cc0}。

@en If @var{lval} is a @code{reg}, @code{subreg} or @code{mem}, it has a
@en machine mode; then @var{x} must be valid for that mode.
如果@var{lval}是一个@code{reg}，@code{subreg}或者@code{mem}，其具有一个机器模式；则@var{x}必须对这种模式有效。 

If @var{lval} is a @code{reg} whose machine mode is less than the full
width of the register, then it means that the part of the register
specified by the machine mode is given the specified value and the
rest of the register receives an undefined value.  Likewise, if
@var{lval} is a @code{subreg} whose machine mode is narrower than
the mode of the register, the rest of the register can be changed in
an undefined way.

@en If @var{lval} is a @code{strict_low_part} of a subreg, then the part
@en of the register specified by the machine mode of the @code{subreg} is
@en given the value @var{x} and the rest of the register is not changed.
如果@var{lval}是一个@code{subreg}的@code{strict_low_part}，则由@code{subreg}的机器模式所指定的寄存器的那部分被赋予值@var{x}，而寄存器的其它部分不变。 

@en If @var{lval} is a @code{zero_extract}, then the referenced part of
@en the bit-field (a memory or register reference) specified by the
@en @code{zero_extract} is given the value @var{x} and the rest of the
@en bit-field is not changed.  Note that @code{sign_extract} can not
@en appear in @var{lval}.
如果@var{lval}是一个@code{zero_extract}，则由@code{zero_extract}指定的相关位域（内存或者寄存器相关的），被赋予值@var{x}，而其它位域不变。注意@code{sign_extract}不能出现在@var{lval}中。 

@en If @var{lval} is @code{(cc0)}, it has no machine mode, and @var{x} may
@en be either a @code{compare} expression or a value that may have any mode.
@en The latter case represents a ``test'' instruction.  The expression
@en @code{(set (cc0) (reg:@var{m} @var{n}))} is equivalent to
@en @code{(set (cc0) (compare (reg:@var{m} @var{n}) (const_int 0)))}.
@en Use the former expression to save space during the compilation.
如果@var{lval}是@code{(cc0)}，其没有机器模式，并且@var{x}可以为一个@code{compare}表达式或者任意模式的值。后者情况表示是一个“test”指令。表达式@code{(set (cc0) (reg:@var{m} @var{n}))} 等价于@code{(set (cc0) (compare (reg:@var{m} @var{n})))}。在编译过程中可以使用前一个表达式来节省空间。 

@en If @var{lval} is a @code{parallel}, it is used to represent the case of
@en a function returning a structure in multiple registers.  Each element
@en of the @code{parallel} is an @code{expr_list} whose first operand is a
@en @code{reg} and whose second operand is a @code{const_int} representing the
@en offset (in bytes) into the structure at which the data in that register
@en corresponds.  The first element may be null to indicate that the structure
@en is also passed partly in memory.
如果@var{lval}是一个@code{parallel}，其用来表示一个函数通过多个寄存器来返回一个结构体的情况。@code{parallel}中的每一个元素是一个@code{expr_list}，其第一个操作数是一个@code{reg}，并且第二个操作数是一个@code{const_int}，表示相应寄存器的数据在结构体中的偏移量（以字节为单位）。第一个元素也可能为null，用来指示结构体也有一部分是在内存中传递的。 

@cindex jump instructions and @code{set}
@cindex @code{if_then_else} usage
@en If @var{lval} is @code{(pc)}, we have a jump instruction, and the
@en possibilities for @var{x} are very limited.  It may be a
@en @code{label_ref} expression (unconditional jump).  It may be an
@en @code{if_then_else} (conditional jump), in which case either the
@en second or the third operand must be @code{(pc)} (for the case which
@en does not jump) and the other of the two must be a @code{label_ref}
@en (for the case which does jump).  @var{x} may also be a @code{mem} or
@en @code{(plus:SI (pc) @var{y})}, where @var{y} may be a @code{reg} or a
@en @code{mem}; these unusual patterns are used to represent jumps through
@en branch tables.
如果@var{lval}是@code{(pc)}，则为一个跳转指令，并且@var{x}只有几种可能。其可能为一个@code{label_ref}表达式（无条件跳转）。可能为一个@code{if_then_else}（条件跳转），这种情况下，第二个或者第三个操作数必须是@code{(pc)}（用于不进行跳转的情况），并且另外两个必须是一个@code{label_ref}（用于进行跳转的情况）。@var{x}也可以是一个@code{mem}或者@code{(plus:SI (pc) @var{y})}, 其中y可以为一个@code{reg}或者@code{mem}；这些独特的模式用来表示通过分支表来进行跳转。 

@en If @var{lval} is neither @code{(cc0)} nor @code{(pc)}, the mode of
@en @var{lval} must not be @code{VOIDmode} and the mode of @var{x} must be
@en valid for the mode of @var{lval}.
如果@var{lval}即不是@code{(cc0)}也不是@code{(pc)},则@var{lval}的模式一定不是@code{VOIDmode}，并且@var{x}的模式必须对于@var{lval}的模式有效。 

@findex SET_DEST
@findex SET_SRC
@en @var{lval} is customarily accessed with the @code{SET_DEST} macro and
@en @var{x} with the @code{SET_SRC} macro.
@var{lval}通常通过@code{SET_DEST}宏来访问，@var{x}通常使用@code{SET_SRC}宏。

@findex return
@item (return)
@en As the sole expression in a pattern, represents a return from the
@en current function, on machines where this can be done with one
@en instruction, such as VAXen.  On machines where a multi-instruction
@en ``epilogue'' must be executed in order to return from the function,
@en returning is done by jumping to a label which precedes the epilogue, and
@en the @code{return} expression code is never used.
在指令模式中作为单独的表达式，表示从当前函数的一个返回，在一些机器上，可以使用一条指令来完成，例如VAXen。在一些机器上，为了从函数中返回，包括多条指令的尾声必须被执行，则返回操作，通过跳转到一个位于尾声之前的标号来完成，并且不使用@code{return}表达式代码。

@en Inside an @code{if_then_else} expression, represents the value to be
@en placed in @code{pc} to return to the caller.
在@code{if_then_else}表达式中，表示放在@code{pc}中的，返回给调用者的值。

@en Note that an insn pattern of @code{(return)} is logically equivalent to
@en @code{(set (pc) (return))}, but the latter form is never used.
注意，指令模式为@code{(return)}的insn，在逻辑上等价于@code{(set (pc) (return))}，但是不使用后者的形式。

@findex call
@item (call @var{function} @var{nargs})
@en Represents a function call.  @var{function} is a @code{mem} expression
@en whose address is the address of the function to be called.
@en @var{nargs} is an expression which can be used for two purposes: on
@en some machines it represents the number of bytes of stack argument; on
@en others, it represents the number of argument registers.
表示一个函数调用。@var{function}为一个@code{mem}表达式，其地址为被调用的函数的地址。@var{nargs}为一个表达式，其可以用于两个目的：在一些机器上，其表示栈参数的字节数目；在其它机器上，其表示参数寄存器的数目。

@en Each machine has a standard machine mode which @var{function} must
@en have.  The machine description defines macro @code{FUNCTION_MODE} to
@en expand into the requisite mode name.  The purpose of this mode is to
@en specify what kind of addressing is allowed, on machines where the
@en allowed kinds of addressing depend on the machine mode being
@en addressed.
每个机器具有一个标准的，@var{function}必须具有的机器模式。机器描述定义了宏@code{FUNCTION_MODE}，来扩展为需要的模式名。在一些机器上，所允许的寻址方式取决于被寻址的机器模式，则该机器模式的用途是来描述，允许什么样的寻址。

@findex clobber
@item (clobber @var{x})
@en Represents the storing or possible storing of an unpredictable,
@en undescribed value into @var{x}, which must be a @code{reg},
@en @code{scratch}, @code{parallel} or @code{mem} expression.
表示一个不可预期的存储或者可能的存储，将不可描述的值存储到@var{x}，其必须为一个@code{reg}，@code{scratch}, @code{parallel} 或者 @code{mem}表达式。

@en One place this is used is in string instructions that store standard
@en values into particular hard registers.  It may not be worth the
@en trouble to describe the values that are stored, but it is essential to
@en inform the compiler that the registers will be altered, lest it
@en attempt to keep data in them across the string instruction.
可以用在字符串指令中，将标准的值存储到特定的硬件寄存器中。不需要去描述被存储的值，只用来告诉编译器寄存器被修改了，以免其尝试在字符串指令中保持数据。

@en If @var{x} is @code{(mem:BLK (const_int 0))} or
@en @code{(mem:BLK (scratch))}, it means that all memory
@en locations must be presumed clobbered.  If @var{x} is a @code{parallel},
@en it has the same meaning as a @code{parallel} in a @code{set} expression.
如果@var{x}为@code{(mem:BLK (const_int 0))}或者@code{(mem:BLK (scratch))}，则意味着所有的内存位置必须假设被破坏。如果@var{x}为一个@code{parallel}，其具有与@code{set}表达式中的@code{parallel}相同的含义。

@en Note that the machine description classifies certain hard registers as
@en ``call-clobbered''.  All function call instructions are assumed by
@en default to clobber these registers, so there is no need to use
@en @code{clobber} expressions to indicate this fact.  Also, each function
@en call is assumed to have the potential to alter any memory location,
@en unless the function is declared @code{const}.
注意，机器描述将特定的硬件寄存器归类为“call-clobbered”。所有函数调用指令都被假设为，缺省的，会破坏这些寄存器，所以不需要使用@code{clobber}表达式来表示这些。而且，每个函数调用都被假设为潜在的修改任何内存位置，除非函数被声明为@code{const}。

@en If the last group of expressions in a @code{parallel} are each a
@en @code{clobber} expression whose arguments are @code{reg} or
@en @code{match_scratch} (@pxref{RTL Template}) expressions, the combiner
@en phase can add the appropriate @code{clobber} expressions to an insn it
@en has constructed when doing so will cause a pattern to be matched.
如果在@code{parallel}中的最后一组表达式为@code{clobber}表达式，其参数为@code{reg}或者@code{match_scratch}（@pxref{RTL Template}）表达式，则合并阶段可以向构建的insn中增加适当的@code{clobber}表达式，当这样可以使得指令模式被匹配。

@en This feature can be used, for example, on a machine that whose multiply
@en and add instructions don't use an MQ register but which has an
@en add-accumulate instruction that does clobber the MQ register.  Similarly,
@en a combined instruction might require a temporary register while the
@en constituent instructions might not.
例如，该特点可以用在，乘法和加法指令不使用MQ寄存器，但具有一个加法累加指令，而且破坏MQ寄存器的机器上。类似的，被合并的指令可能需要临时的寄存器，而成员指令则不需要。

@en When a @code{clobber} expression for a register appears inside a
@en @code{parallel} with other side effects, the register allocator
@en guarantees that the register is unoccupied both before and after that
@en insn if it is a hard register clobber.  For pseudo-register clobber,
@en the register allocator and the reload pass do not assign the same hard
@en register to the clobber and the input operands if there is an insn
@en alternative containing the @samp{&} constraint (@pxref{Modifiers}) for
@en the clobber and the hard register is in register classes of the
@en clobber in the alternative.  You can clobber either a specific hard
@en register, a pseudo register, or a @code{scratch} expression; in the
@en latter two cases, GCC will allocate a hard register that is available
@en there for use as a temporary.
当寄存器的@code{clobber}表达式，出现在具有其它副作用的@code{parallel}中，如果是硬件寄存器，则寄存器分配者来确保在insn之前和之后，该寄存器都不会被占用。对于伪寄存器的破坏，寄存器分配者和重载过程，不对clobber分配相同的硬件寄存器，以及输入操作数。你可以破坏一个特定的硬件寄存器，一个伪寄存器，或者一个@code{scratch}表达式；在后两种情况下，GCC将会分配一个硬件寄存器，临时使用。

@en For instructions that require a temporary register, you should use
@en @code{scratch} instead of a pseudo-register because this will allow the
@en combiner phase to add the @code{clobber} when required.  You do this by
@en coding (@code{clobber} (@code{match_scratch} @dots{})).  If you do
@en clobber a pseudo register, use one which appears nowhere else---generate
@en a new one each time.  Otherwise, you may confuse CSE@.
对于需要临时寄存器的指令，应该使用@code{scratch}，而不是伪寄存器，因为这将使得合并阶段可以在需要的时候增加@code{clobber}。方式为(@code{clobber} (@code{match_scratch} @dots{}))。如果确实是破坏了一个伪寄存器，则使用没有出现在其它地方的伪寄存器，每次生成一个新的。否则，你可能会使CSE（公共子表达式消除）迷惑。

@en There is one other known use for clobbering a pseudo register in a
@en @code{parallel}: when one of the input operands of the insn is also
@en clobbered by the insn.  In this case, using the same pseudo register in
@en the clobber and elsewhere in the insn produces the expected results.
还有一种在@code{parallel}中破坏伪寄存器的用法：当insn的输入操作数也被insn破坏。这种情况下，使用相同的伪寄存器。

@findex use
@item (use @var{x})
@en Represents the use of the value of @var{x}.  It indicates that the
@en value in @var{x} at this point in the program is needed, even though
@en it may not be apparent why this is so.  Therefore, the compiler will
@en not attempt to delete previous instructions whose only effect is to
@en store a value in @var{x}.  @var{x} must be a @code{reg} expression.
表示对@var{x}值的使用。其表示@var{x}中的值在程序的这个点上是被需要的，即使可能不清楚为什么。因此，如果先前的执行的作用只是将一个值存储在@var{x}中，则编译器将不会尝试将其删除。@var{x}必须为一个@code{reg}表达式。

@en In some situations, it may be tempting to add a @code{use} of a
@en register in a @code{parallel} to describe a situation where the value
@en of a special register will modify the behavior of the instruction.
@en A hypothetical example might be a pattern for an addition that can
@en either wrap around or use saturating addition depending on the value
@en of a special control register:
在一些情况下，可能会想到，在@code{parallel}中增加一个对寄存器的@code{use}，来描述特定寄存器的值将会影响指令的行为。一个假定的例子为，对于一个加法指令模式，其可以根据特定的控制寄存器的值来执行环绕或者饱和加法：

@smallexample
(parallel [(set (reg:SI 2) (unspec:SI [(reg:SI 3)
                                       (reg:SI 4)] 0))
           (use (reg:SI 1))])
@end smallexample

@noindent

@en This will not work, several of the optimizers only look at expressions
@en locally; it is very likely that if you have multiple insns with
@en identical inputs to the @code{unspec}, they will be optimized away even
@en if register 1 changes in between.
这将不会工作，一些优化器将只查看局部的表达式；很可能如果你有多个具有针对@code{unspec}相同输入的insn，它们将被优化掉，即使寄存器1中间有所改变。

@en This means that @code{use} can @emph{only} be used to describe
@en that the register is live.  You should think twice before adding
@en @code{use} statements, more often you will want to use @code{unspec}
@en instead.  The @code{use} RTX is most commonly useful to describe that
@en a fixed register is implicitly used in an insn.  It is also safe to use
@en in patterns where the compiler knows for other reasons that the result
@en of the whole pattern is variable, such as @samp{movmem@var{m}} or
@en @samp{call} patterns.
这意味着，@code{use}只能被用于描述寄存器是活跃的。在增加@code{use}语句时，你应该多思考一下，通常，你将会使用@code{unspec}来替代。@code{use} RTX最常用于描述一个隐式的用于insn的固定寄存器。还可以安全的用于，编译器知道整个指令模式的结果是可变的，这样的指令模式中，例如@samp{movmem@var{m}}或者@samp{call}。

@en During the reload phase, an insn that has a @code{use} as pattern
@en can carry a reg_equal note.  These @code{use} insns will be deleted
@en before the reload phase exits.
在重载阶段，具有@code{use}指令模式的insn可以附带一个reg_equal注解。这些@code{use} insn将在重载阶段退出之前被删除。

@en During the delayed branch scheduling phase, @var{x} may be an insn.
@en This indicates that @var{x} previously was located at this place in the
@en code and its data dependencies need to be taken into account.  These
@en @code{use} insns will be deleted before the delayed branch scheduling
@en phase exits.
在延迟分支调度阶段，@var{x}可以为一个insn。这表示@var{x}之前曾经在该位置被定位，它的数据依赖需要被考虑。这些@code{use} insn将在延迟分支调度阶段退出之前被删除。

@findex parallel
@item (parallel [@var{x0} @var{x1} @dots{}])
@en Represents several side effects performed in parallel.  The square
@en brackets stand for a vector; the operand of @code{parallel} is a
@en vector of expressions.  @var{x0}, @var{x1} and so on are individual
@en side effect expressions---expressions of code @code{set}, @code{call},
@en @code{return}, @code{clobber} or @code{use}.
表示并行执行多个副作用。方括号表示一个向量；@code{parallel}的操作数为向量表达式。@var{x0}, @var{x1}等等为单独的副作用表达式，@code{set}, @code{call}, @code{return}, @code{clobber} 或 @code{use}。

@en ``In parallel'' means that first all the values used in the individual
@en side-effects are computed, and second all the actual side-effects are
@en performed.  For example,
“并行”意味着，首先所有在单个副作用中使用的值将被计算，然后，所有实际的副作用被执行。例如，

@smallexample
(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])
@end smallexample

@noindent

@en says unambiguously that the values of hard register 1 and the memory
@en location addressed by it are interchanged.  In both places where
@en @code{(reg:SI 1)} appears as a memory address it refers to the value
@en in register 1 @emph{before} the execution of the insn.
清楚的说明了，将硬件寄存器1的值与其所寻址的内存中的值进行交换。在@code{(reg:SI 1)}作为内存地址出现的两个地方，其都是使用执行insn之前，在寄存器1中的值。

@en It follows that it is @emph{incorrect} to use @code{parallel} and
@en expect the result of one @code{set} to be available for the next one.
@en For example, people sometimes attempt to represent a jump-if-zero
@en instruction this way:
从而，如果使用@code{parallel}，并且期望@code{set}的值，可以用于下一个@code{set}，则是不正确的。例如，人们有时候尝试用这种方式来表示，为零则跳转的指令：

@smallexample
(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref @dots{})
                        (pc)))])
@end smallexample

@noindent
@en But this is incorrect, because it says that the jump condition depends
@en on the condition code value @emph{before} this instruction, not on the
@en new value that is set by this instruction.
但这是不正确的，因为其说明了跳转条件取决于，该指令之前的条件代码的值，而不是被该指令设置后的新值。

@cindex peephole optimization, RTL representation
@en Peephole optimization, which takes place together with final assembly
@en code output, can produce insns whose patterns consist of a @code{parallel}
@en whose elements are the operands needed to output the resulting
@en assembler code---often @code{reg}, @code{mem} or constant expressions.
@en This would not be well-formed RTL at any other stage in compilation,
@en but it is ok then because no further optimization remains to be done.
@en However, the definition of the macro @code{NOTICE_UPDATE_CC}, if
@en any, must deal with such insns if you define any peephole optimizations.
与最后的汇编代码输出一起执行的窥孔优化，可以产生由@code{parallel}组成的insn，其元素为需要输出汇编代码的操作数，通常为@code{reg}, @code{mem}或者常量表达式。这在其它编译阶段，将不是一个好的RTL形式，但是在这里是可以的，因为已经没有其它的优化了。然而，宏@code{NOTICE_UPDATE_CC}的定义，如果存在，如果定义了窥孔优化，则需要处理这样的insn。

@findex cond_exec
@item (cond_exec [@var{cond} @var{expr}])
@en Represents a conditionally executed expression.  The @var{expr} is
@en executed only if the @var{cond} is nonzero.  The @var{cond} expression
@en must not have side-effects, but the @var{expr} may very well have
@en side-effects.
表示一个条件执行表达式。只有当@var{cond}为非零时，@var{expr}才被执行。@var{cond}表达式不能具有副作用，但是@var{expr}可以。

@findex sequence
@item (sequence [@var{insns} @dots{}])
@en Represents a sequence of insns.  Each of the @var{insns} that appears
@en in the vector is suitable for appearing in the chain of insns, so it
@en must be an @code{insn}, @code{jump_insn}, @code{call_insn},
@en @code{code_label}, @code{barrier} or @code{note}.
表示一个insn序列。每个出现在向量中的@var{insns}，都适合出现在insn链中，所以其必须为@code{insn}, @code{jump_insn}, @code{call_insn}, @code{code_label}, @code{barrier} 或 @code{note}。

@en A @code{sequence} RTX is never placed in an actual insn during RTL
@en generation.  It represents the sequence of insns that result from a
@en @code{define_expand} @emph{before} those insns are passed to
@en @code{emit_insn} to insert them in the chain of insns.  When actually
@en inserted, the individual sub-insns are separated out and the
@en @code{sequence} is forgotten.
在RTL生成过程中，不会在实际的insn中放入@code{sequence} RTX。其表示@code{define_expand}产生的insn序列，用来传递给@code{emit_insn}，从而将它们插入到insn链中。当实际被插入的时候，单独的子insn将被分离出来，@code{sequence}将被忽略掉。

@en After delay-slot scheduling is completed, an insn and all the insns that
@en reside in its delay slots are grouped together into a @code{sequence}.
@en The insn requiring the delay slot is the first insn in the vector;
@en subsequent insns are to be placed in the delay slot.
当延迟槽调度完成之后，insn和所有位于其延迟槽中的insn被组成一个@code{sequence}。需要延迟槽的insn为向量中的第一个insn；后续的insn为将被放在延迟槽中的insn。

@en @code{INSN_ANNULLED_BRANCH_P} is set on an insn in a delay slot to
@en indicate that a branch insn should be used that will conditionally annul
@en the effect of the insns in the delay slots.  In such a case,
@en @code{INSN_FROM_TARGET_P} indicates that the insn is from the target of
@en the branch and should be executed only if the branch is taken; otherwise
@en the insn should be executed only if the branch is not taken.
@en @xref{Delay Slots}.
@code{INSN_ANNULLED_BRANCH_P}用来表示分支insn将会有条件的取消延迟槽中的insn的效果。这种情况下，@code{INSN_FROM_TARGET_P}表示insn是来自分支的目标，并且只有当进行分支时，其才被执行；否则，insn只有当不进行分支时才被执行。@xref{Delay Slots}.

@end table

@en These expression codes appear in place of a side effect, as the body of
@en an insn, though strictly speaking they do not always describe side
@en effects as such:
这些表达式代码出现在副作用的地方，作为insn的主体，虽然严格的讲，它们并不总是描述副作用：

@table @code
@findex asm_input
@item (asm_input @var{s})
@en Represents literal assembler code as described by the string @var{s}.
表示文字的汇编代码，通过字符串@var{s}来描述。

@findex unspec
@findex unspec_volatile
@item (unspec [@var{operands} @dots{}] @var{index})
@itemx (unspec_volatile [@var{operands} @dots{}] @var{index})
@en Represents a machine-specific operation on @var{operands}.  @var{index}
@en selects between multiple machine-specific operations.
@en @code{unspec_volatile} is used for volatile operations and operations
@en that may trap; @code{unspec} is used for other operations.
表示一个机器特定的针对@var{operands}的操作。@var{index}在多个机器特定的操作之间进行选择。@code{unspec_volatile}用于volatile操作，并且可以有陷阱；@code{unspec}用于其它操作。

@en These codes may appear inside a @code{pattern} of an
@en insn, inside a @code{parallel}, or inside an expression.
这些代码可以出现在insn的@code{pattern}中，@code{parallel}中，或者表达式中。

@findex addr_vec
@item (addr_vec:@var{m} [@var{lr0} @var{lr1} @dots{}])
@en Represents a table of jump addresses.  The vector elements @var{lr0},
@en etc., are @code{label_ref} expressions.  The mode @var{m} specifies
@en how much space is given to each address; normally @var{m} would be
@en @code{Pmode}.
表示跳转地址表。向量元素@var{lr0}等等，为@code{label_ref}表达式。机器模式@var{m}描述了为每个地址给定了多少空间；通常@var{m}为@code{Pmode}。

@findex addr_diff_vec
@item (addr_diff_vec:@var{m} @var{base} [@var{lr0} @var{lr1} @dots{}] @var{min} @var{max} @var{flags})
@en Represents a table of jump addresses expressed as offsets from
@en @var{base}.  The vector elements @var{lr0}, etc., are @code{label_ref}
@en expressions and so is @var{base}.  The mode @var{m} specifies how much
@en space is given to each address-difference.  @var{min} and @var{max}
@en are set up by branch shortening and hold a label with a minimum and a
@en maximum address, respectively.  @var{flags} indicates the relative
@en position of @var{base}, @var{min} and @var{max} to the containing insn
@en and of @var{min} and @var{max} to @var{base}.  See rtl.def for details.
表示一个跳转地址表，表示为@var{base}的偏移量。向量元素@var{lr0}等等，为@code{label_ref}表达式，@var{base}也是。机器模式@var{m}描述了为每个地址偏移给定的空间大小。@var{min}和@var{max}由分支缩短过程设置，分别存放了一个具有最小地址和最大地址的标号。详情参见rtl.def。

@findex prefetch
@item (prefetch:@var{m} @var{addr} @var{rw} @var{locality})
@en Represents prefetch of memory at address @var{addr}.
@en Operand @var{rw} is 1 if the prefetch is for data to be written, 0 otherwise;
@en targets that do not support write prefetches should treat this as a normal
@en prefetch.
@en Operand @var{locality} specifies the amount of temporal locality; 0 if there
@en is none or 1, 2, or 3 for increasing levels of temporal locality;
@en targets that do not support locality hints should ignore this.
表示对地址为@var{addr}的内存进行预取。如果预取的数据将被写，则操作数为@var{rw}，否则为0；不支持写预取的目标机，应该将其作为一个普通的预取。操作数@var{locality}描述了时间局部性的数量；如果没有，则为0，否则按照时间局部性的递增级别，依次为1，2或者3；不支持局部性暗示的目标机，应该忽略该项。

@en This insn is used to minimize cache-miss latency by moving data into a
@en cache before it is accessed.  It should use only non-faulting data prefetch
@en instructions.
该insn用于最小化cache-miss的延迟，通过在访问数据之前将其移送到cache中。其应该只用于非故障的数据预取指令。

@end table

@en @node Incdec
@en @section Embedded Side-Effects on Addresses
@node Incdec
@section 地址中嵌入的副作用
@cindex RTL preincrement
@cindex RTL postincrement
@cindex RTL predecrement
@cindex RTL postdecrement

@en Six special side-effect expression codes appear as memory addresses.
有六个特定的副作用表达式代码作为内存地址出现。

@table @code
@findex pre_dec
@item (pre_dec:@var{m} @var{x})
@en Represents the side effect of decrementing @var{x} by a standard
@en amount and represents also the value that @var{x} has after being
@en decremented.  @var{x} must be a @code{reg} or @code{mem}, but most
@en machines allow only a @code{reg}.  @var{m} must be the machine mode
@en for pointers on the machine in use.  The amount @var{x} is decremented
@en by is the length in bytes of the machine mode of the containing memory
@en reference of which this expression serves as the address.  Here is an
@en example of its use:
表示该副作用为，@var{x}递减一个标准的数量，并且还表示了递减后的@var{x}的值。@var{x}必须为一个@code{reg}或者@code{mem}，但是大多数机器只允许@code{reg}。@var{m}必须为机器所使用的指针的机器模式。@var{x}被递减的数量为，所包含的内存引用的机器模式的长度，以字节为单位。这里有一个关于用法的例子：

@smallexample
(mem:DF (pre_dec:SI (reg:SI 39)))
@end smallexample

@noindent
@en This says to decrement pseudo register 39 by the length of a @code{DFmode}
@en value and use the result to address a @code{DFmode} value.
这说明将伪寄存器39递减一个@code{DFmode}值的长度，并将结果用来对一个@code{DFmode}值进行寻址。

@findex pre_inc
@item (pre_inc:@var{m} @var{x})
@en Similar, but specifies incrementing @var{x} instead of decrementing it.
类似的，用来说明递增@var{x}。

@findex post_dec
@item (post_dec:@var{m} @var{x})
@en Represents the same side effect as @code{pre_dec} but a different
@en value.  The value represented here is the value @var{x} has @i{before}
@en being decremented.
表示与@code{pre_dec}相同的副作用，但表示不同的值。这里表示的值为递减@i{之前}的@var{x}的值。

@findex post_inc
@item (post_inc:@var{m} @var{x})
@en Similar, but specifies incrementing @var{x} instead of decrementing it.
类似的，用来说明递增@var{x}。

@findex post_modify
@item (post_modify:@var{m} @var{x} @var{y})
@en Represents the side effect of setting @var{x} to @var{y} and
@en represents @var{x} before @var{x} is modified.  @var{x} must be a
@en @code{reg} or @code{mem}, but most machines allow only a @code{reg}.
@en @var{m} must be the machine mode for pointers on the machine in use.
表示该副作用为，将@var{x}设置为@var{y}，并且表示@var{x}被修改之前的值。@var{x}必须为一个@code{reg}或者@code{mem}，但是大多数机器只允许@code{reg}。@var{m}必须为机器所使用的指针的机器模式。

@en The expression @var{y} must be one of three forms:
@en @code{(plus:@var{m} @var{x} @var{z})},
@en @code{(minus:@var{m} @var{x} @var{z})}, or
@en @code{(plus:@var{m} @var{x} @var{i})},
@en where @var{z} is an index register and @var{i} is a constant.
表达式@var{y}必须为下列三种形式之一：
@code{(plus:@var{m} @var{x} @var{z})},
@code{(minus:@var{m} @var{x} @var{z})}, 或者
@code{(plus:@var{m} @var{x} @var{i})},
其中@var{z}为一个索引寄存器，@var{i}为一个常量。

@en Here is an example of its use:
这里为一个有关用法的例子：

@smallexample
(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42)
                                          (reg:SI 48))))
@end smallexample

@en This says to modify pseudo register 42 by adding the contents of pseudo
@en register 48 to it, after the use of what ever 42 points to.
这说明在使用了伪寄存器42曾经指向的值之后，将伪寄存器42修改为，加上其伪寄存器48的内容，

@findex pre_modify
@item (pre_modify:@var{m} @var{x} @var{expr})
@en Similar except side effects happen before the use.
类似的，表示副作用在使用之前开始有效。
@end table

@en These embedded side effect expressions must be used with care.  Instruction
@en patterns may not use them.  Until the @samp{flow} pass of the compiler,
@en they may occur only to represent pushes onto the stack.  The @samp{flow}
@en pass finds cases where registers are incremented or decremented in one
@en instruction and used as an address shortly before or after; these cases are
@en then transformed to use pre- or post-increment or -decrement.
这些嵌入的副作用表达式在使用时要小心。指令模式可以不使用它们。在到达编译器的@samp{flow} pass之前，它们可能只出现在用于表示压栈。@samp{flow} pass查找寄存器在一条指令中被递增或递减，并且在之前或者之后被作为地址使用的情况；这些情况然后被转换成使用前增（减）或后增（减）。

@en If a register used as the operand of these expressions is used in
@en another address in an insn, the original value of the register is used.
@en Uses of the register outside of an address are not permitted within the
@en same insn as a use in an embedded side effect expression because such
@en insns behave differently on different machines and hence must be treated
@en as ambiguous and disallowed.
如果这些表达式中作为操作数的寄存器，在一个insn中的另一个地址中使用，则会使用寄存器的原始的值。在地址之外使用寄存器是不被允许的，因为这样的insn在不同的机器上行为是不同的，因此会有歧义。

@en An instruction that can be represented with an embedded side effect
@en could also be represented using @code{parallel} containing an additional
@en @code{set} to describe how the address register is altered.  This is not
@en done because machines that allow these operations at all typically
@en allow them wherever a memory address is called for.  Describing them as
@en additional parallel stores would require doubling the number of entries
@en in the machine description.
可以被表示成具有嵌入副作用的指令，也可以被表示成使用@code{parallel}，包含一个额外的@code{set}来描述地址寄存器如何被修改。

@en @node Assembler
@en @section Assembler Instructions as Expressions
@node Assembler
@section 作为表达式的汇编指令
@cindex assembler instructions in RTL

@cindex @code{asm_operands}, usage
@en The RTX code @code{asm_operands} represents a value produced by a
@en user-specified assembler instruction.  It is used to represent
@en an @code{asm} statement with arguments.  An @code{asm} statement with
@en a single output operand, like this:
RTX代码@code{asm_operands}表示由用户特定的汇编指令所产生的值。其用来表示带有参数的@code{asm}语句。一个具有单个输出操作数的@code{asm}语句，如下：

@smallexample
asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));
@end smallexample

@noindent
@en is represented using a single @code{asm_operands} RTX which represents
@en the value that is stored in @code{outputvar}:
其通过一个单个的@code{asm_operands} RTX来表示，其表示了存储在@code{outputvar}中的值：

@smallexample
(set @var{rtx-for-outputvar}
     (asm_operands "foo %1,%2,%0" "a" 0
                   [@var{rtx-for-addition-result} @var{rtx-for-*z}]
                   [(asm_input:@var{m1} "g")
                    (asm_input:@var{m2} "di")]))
@end smallexample

@noindent
@en Here the operands of the @code{asm_operands} RTX are the assembler
@en template string, the output-operand's constraint, the index-number of the
@en output operand among the output operands specified, a vector of input
@en operand RTX's, and a vector of input-operand modes and constraints.  The
@en mode @var{m1} is the mode of the sum @code{x+y}; @var{m2} is that of
@en @code{*z}.
这里，@code{asm_operands} RTX的操作数为汇编模板字符串，输出操作数的约束，在指定的输出操作数中的索引编号，一个输入操作数RTX向量，以及一个输出操作数机器模式和约束的向量。机器模式@var{m1}为@code{x+y}的和的机器模式；@var{m2}为@code{*z}的机器模式。
        
@en When an @code{asm} statement has multiple output values, its insn has
@en several such @code{set} RTX's inside of a @code{parallel}.  Each @code{set}
@en contains an @code{asm_operands}; all of these share the same assembler
@en template and vectors, but each contains the constraint for the respective
@en output operand.  They are also distinguished by the output-operand index
@en number, which is 0, 1, @dots{} for successive output operands.
当@code{asm}语句具有多个输出值时，它的insn具有多个这样的@code{set} RTX，并位于一个@code{parallel}中。每个@code{set}包括了一个@code{asm_operands}；所有这些共享相同的汇编模板和向量，但是每个包含了相应的输出操作数的约束。它们也是通过输出操作数索引编号来区分的，即0，1@dots{}连续的输出操作数。

@en @node Debug Information
@en @section Variable Location Debug Information in RTL
@node Debug Information
@section RTL中的变量位置调试信息
@cindex Variable Location Debug Information in RTL

@en Variable tracking relies on @code{MEM_EXPR} and @code{REG_EXPR}
@en annotations to determine what user variables memory and register
@en references refer to.
变量跟踪（Variable tracking）依靠@code{MEM_EXPR}和@code{REG_EXPR}注解来确定所引用的用户变量内存和寄存器。

@en Variable tracking at assignments uses these notes only when they refer
@en to variables that live at fixed locations (e.g., addressable
@en variables, global non-automatic variables).  For variables whose
@en location may vary, it relies on the following types of notes.
赋值语句中的变量跟踪只有当它们引用了在固定点活跃的变量（例如，可寻址变量，全局非自动变量）时，才使用这些注解。对于位置有变化的变量，其依靠下列类型的注解。

@table @code
@findex var_location
@item (var_location:@var{mode} @var{var} @var{exp} @var{stat})
@en Binds variable @code{var}, a tree, to value @var{exp}, an RTL
@en expression.  It appears only in @code{NOTE_INSN_VAR_LOCATION} and
@en @code{DEBUG_INSN}s, with slightly different meanings.  @var{mode}, if
@en present, represents the mode of @var{exp}, which is useful if it is a
@en modeless expression.  @var{stat} is only meaningful in notes,
@en indicating whether the variable is known to be initialized or
@en uninitialized.
绑定变量@code{var}，一个tree，到值@var{exp}，一个RTL表达式。其只出现在@code{NOTE_INSN_VAR_LOCATION}和@code{DEBUG_INSN}中，并且含义有些细微的差别。@var{mode}，如果存在，则表示@var{exp}的机器模式，这用于当其为一个无机器模式的表达式时。@var{stat}只在注解中有含义，表示变量是否已知为被初始化或者未被初始化。

@findex debug_expr
@item (debug_expr:@var{mode} @var{decl})
@en Stands for the value bound to the @code{DEBUG_EXPR_DECL} @var{decl},
@en that points back to it, within value expressions in
@en @code{VAR_LOCATION} nodes.
表示绑定到@code{DEBUG_EXPR_DECL} @var{decl}上的值。

@end table

@node Insns
@section Insns
@cindex insns

@en The RTL representation of the code for a function is a doubly-linked
@en chain of objects called @dfn{insns}.  Insns are expressions with
@en special codes that are used for no other purpose.  Some insns are
@en actual instructions; others represent dispatch tables for @code{switch}
@en statements; others represent labels to jump to or various sorts of
@en declarative information.
一个函数的代码的RTL表示是一个被称作@dfn{insns}对象的双向链表。insn只不过是具有特定代码的表达式。有些insn是实际的指令；有些用来表示@code{switch}语句的派遣表。有些用来表示要调转的标号或者不同类别的声明信息。

@en In addition to its own specific data, each insn must have a unique
@en id-number that distinguishes it from all other insns in the current
@en function (after delayed branch scheduling, copies of an insn with the
@en same id-number may be present in multiple places in a function, but
@en these copies will always be identical and will only appear inside a
@en @code{sequence}), and chain pointers to the preceding and following
@en insns.  These three fields occupy the same position in every insn,
@en independent of the expression code of the insn.  They could be accessed
@en with @code{XEXP} and @code{XINT}, but instead three special macros are
@en always used:
除了本身特定的数据，每个insn必须有一个唯一的id号用来区别当前函数中其它的insn（经过分支延迟调度之后，具有相同id号的一个insn 的拷贝，可能会出现在一个函数中的多个地方，但是这些拷贝总是同样的，并且只是出现在一个@code{sequence}中），以及指向前面和后面insn的链表指针。这三个域在每个insn中占有相同的位置，并且独立于insn的表达式代码。它们可以通过@code{XEXP}和@code{XINT}来访问，不过，有三个特定的宏经常会被使用：

@table @code
@findex INSN_UID
@item INSN_UID (@var{i})
@en Accesses the unique id of insn @var{i}.
访问insn @var{i}的唯一id。

@findex PREV_INSN
@item PREV_INSN (@var{i})
@en Accesses the chain pointer to the insn preceding @var{i}.
@en If @var{i} is the first insn, this is a null pointer.
访问指向@var{i}之前的insn的链表指针。如果@var{i}是第一个insn，则是一个null指针。 

@findex NEXT_INSN
@item NEXT_INSN (@var{i})
@en Accesses the chain pointer to the insn following @var{i}.
@en If @var{i} is the last insn, this is a null pointer.
访问指向@var{i}之后的insn的链表指针。如果@var{i}是最后一个insn，则是一个null指针。 

@end table

@findex get_insns
@findex get_last_insn
@en The first insn in the chain is obtained by calling @code{get_insns}; the
@en last insn is the result of calling @code{get_last_insn}.  Within the
@en chain delimited by these insns, the @code{NEXT_INSN} and
@en @code{PREV_INSN} pointers must always correspond: if @var{insn} is not
@en the first insn,
链表中的第一个insn可以通过调用@code{get_insns}获得；最后一个insn可以通过调用@code{get_last_insn}来获得。在由这些insn界定的链中，@code{NEXT_INSN}和@code{PREV_INSN}指针必须总是相当：如果@var{insn} 不是第一个insn，则

@smallexample
NEXT_INSN (PREV_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
@en is always true and if @var{insn} is not the last insn,
总是真，并且如果@var{insn}不是最后一个insn，则

@smallexample
PREV_INSN (NEXT_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
@en is always true.
总是真。

@en After delay slot scheduling, some of the insns in the chain might be
@en @code{sequence} expressions, which contain a vector of insns.  The value
@en of @code{NEXT_INSN} in all but the last of these insns is the next insn
@en in the vector; the value of @code{NEXT_INSN} of the last insn in the vector
@en is the same as the value of @code{NEXT_INSN} for the @code{sequence} in
@en which it is contained.  Similar rules apply for @code{PREV_INSN}.
在延迟槽调度之后，在链中的一些insn可能为@code{sequence}表达式，其包含了一个insn向量。这个向量中除了最后一个insn之外，其它insn的@code{NEXT_INSN}的值都是向量中的下一个insn；向量中的最后一个insn的@code{NEXT_INSN}的值，等于包含@code{sequence}的insn的@code{NEXT_INSN}的值。对于@code{PREV_INSN}，也有类似的规则。

@en This means that the above invariants are not necessarily true for insns
@en inside @code{sequence} expressions.  Specifically, if @var{insn} is the
@en first insn in a @code{sequence}, @code{NEXT_INSN (PREV_INSN (@var{insn}))}
@en is the insn containing the @code{sequence} expression, as is the value
@en of @code{PREV_INSN (NEXT_INSN (@var{insn}))} if @var{insn} is the last
@en insn in the @code{sequence} expression.  You can use these expressions
@en to find the containing @code{sequence} expression.
这意味着上面的恒等式，对于在@code{sequence}表达式中的insn不需要成立。特别是，如果@var{insn}为@code{sequence}中的第一个insn，则@code{NEXT_INSN (PREV_INSN (@var{insn}))}为包含@code{sequence}表达式的insn，同样如果@var{insn}为@code{sequence}中的最后一个insn，则@code{PREV_INSN (NEXT_INSN (@var{insn}))}的值也是如此。你可以使用这些表达式来查找包含@code{sequence}的insn。

@en Every insn has one of the following expression codes:
每个insn都具有下列六种表达式代码中的一个：

@table @code
@findex insn
@item insn
@en The expression code @code{insn} is used for instructions that do not jump
@en and do not do function calls.  @code{sequence} expressions are always
@en contained in insns with code @code{insn} even if one of those insns
@en should jump or do function calls.
表达式代码@code{insn}用于不进行跳转和函数调用的指令。@code{sequence}表达式总是包含在表达式代码为@code{insn}的insn中，即使它们中的一个insn是跳转或者函数调用。

@en Insns with code @code{insn} have four additional fields beyond the three
@en mandatory ones listed above.  These four are described in a table below.
表达式代码为@code{insn}的insn，除了上面列出的三个必须的域以外，还具有四个额外的域。这四个域在后面的表中有描述。

@findex jump_insn
@item jump_insn
@en The expression code @code{jump_insn} is used for instructions that may
@en jump (or, more generally, may contain @code{label_ref} expressions to
@en which @code{pc} can be set in that instruction).  If there is an
@en instruction to return from the current function, it is recorded as a
@en @code{jump_insn}.
表达式代码@code{jump_insn}用于可能执行跳转（或者，更一般的讲，指令中可能包含了@code{label_ref}表达式，并用其来设置@code{pc}）的指令。如果有一条从当前函数返回的指令，则其被记录为@code{jump_insn}。

@findex JUMP_LABEL
@en @code{jump_insn} insns have the same extra fields as @code{insn} insns,
@en accessed in the same way and in addition contain a field
@en @code{JUMP_LABEL} which is defined once jump optimization has completed.
@code{jump_insn}具有跟@code{insn}相同的额外的域，并使用同样的方式来访问，除此之外，还包含了一个域@code{JUMP_LABEL}，其当执行完跳转优化后被定义。

@en For simple conditional and unconditional jumps, this field contains
@en the @code{code_label} to which this insn will (possibly conditionally)
@en branch.  In a more complex jump, @code{JUMP_LABEL} records one of the
@en labels that the insn refers to; other jump target labels are recorded
@en as @code{REG_LABEL_TARGET} notes.  The exception is @code{addr_vec}
@en and @code{addr_diff_vec}, where @code{JUMP_LABEL} is @code{NULL_RTX}
@en and the only way to find the labels is to scan the entire body of the
@en insn.
对于简单的条件跳转和无条件跳转，该域包含了该insn将（可能有条件的）分支跳转到的@code{code_label}。在更复杂的跳转中，@code{JUMP_LABEL}记录了insn引用的其中一个标号；其它跳转目标标号作为@code{REG_LABEL_TARGET}注解来记录。@code{addr_vec}和@code{addr_diff_vec}是例外的情况，对此，@code{JUMP_LABEL}为@code{NULL_RTX}，而只有扫描整个insn体干才能找到标号。

@en Return insns count as jumps, but since they do not refer to any
@en labels, their @code{JUMP_LABEL} is @code{NULL_RTX}.
返回指令insn作为跳转看待，但由于它们并不引用任何标号，所以它们的@code{JUMP_LABEL}为@code{NULL_RTX}。

@findex call_insn
@item call_insn
@en The expression code @code{call_insn} is used for instructions that may do
@en function calls.  It is important to distinguish these instructions because
@en they imply that certain registers and memory locations may be altered
@en unpredictably.
表达式代码@code{call_insn}用于可能执行函数调用的指令。区分这些指令是很重要的，因为它们意味着特定的寄存器和内存位置可以被不可预知的方式改变。

@findex CALL_INSN_FUNCTION_USAGE
@en @code{call_insn} insns have the same extra fields as @code{insn} insns,
@en accessed in the same way and in addition contain a field
@en @code{CALL_INSN_FUNCTION_USAGE}, which contains a list (chain of
@en @code{expr_list} expressions) containing @code{use} and @code{clobber}
@en expressions that denote hard registers and @code{MEM}s used or
@en clobbered by the called function.
@code{call_insn}具有与@code{insn}相同的额外的域，并使用相同的方式访问，除此之外，还包含一个域@code{CALL_INSN_FUNCTION_USAGE}，其包含了一个列表（@code{expr_list}表达式链），包含了@code{use}和@code{clobber}表达式，表示了被调用函数使用和破坏的硬件寄存器和@code{MEM}。

@en A @code{MEM} generally points to a stack slots in which arguments passed
@en to the libcall by reference (@pxref{Register Arguments,
@en TARGET_PASS_BY_REFERENCE}) are stored.  If the argument is
@en caller-copied (@pxref{Register Arguments, TARGET_CALLEE_COPIES}),
@en the stack slot will be mentioned in @code{CLOBBER} and @code{USE}
@en entries; if it's callee-copied, only a @code{USE} will appear, and the
@en @code{MEM} may point to addresses that are not stack slots.
一个@code{MEM}通常指向一个栈槽，参数在其中按照引用方式（@pxref{Register Arguments, TARGET_PASS_BY_REFERENCE}）传递给libcall。如果参数是caller-copied（@pxref{Register Arguments, TARGET_CALLEE_COPIES}），则栈槽会在@code{CLOBBER}和@code{USE}中被提到；如果是callee-copied，则只会出现@code{USE}，并且@code{MEM}可能指向不是栈槽的地址。

@en @code{CLOBBER}ed registers in this list augment registers specified in
@en @code{CALL_USED_REGISTERS} (@pxref{Register Basics}).
在列表中，被@code{CLOBBER}的寄存器，增加了在@code{CALL_USED_REGISTERS}中描述的寄存器（@pxref{Register Basics}）。

@findex code_label
@findex CODE_LABEL_NUMBER
@item code_label
@en A @code{code_label} insn represents a label that a jump insn can jump
@en to.  It contains two special fields of data in addition to the three
@en standard ones.  @code{CODE_LABEL_NUMBER} is used to hold the @dfn{label
@en number}, a number that identifies this label uniquely among all the
@en labels in the compilation (not just in the current function).
@en Ultimately, the label is represented in the assembler output as an
@en assembler label, usually of the form @samp{L@var{n}} where @var{n} is
@en the label number.
@code{code_label} insn表示一个跳转insn可以跳转到的标号。除了三个标准的域以为，其还包含两个特定的域。@code{CODE_LABEL_NUMBER}用于存放@dfn{label number}，在编译过程中，唯一标识该标号。最终，标号在汇编输出中作为汇编标号来表示，通常的形式为@samp{L@var{n}}，其中@var{n}为标号编号。

@en When a @code{code_label} appears in an RTL expression, it normally
@en appears within a @code{label_ref} which represents the address of
@en the label, as a number.
当@code{code_label}出现在RTL表达式中，其通常出现在@code{label_ref}中，其表示了标号的地址，为一个编号。

@en Besides as a @code{code_label}, a label can also be represented as a
@en @code{note} of type @code{NOTE_INSN_DELETED_LABEL}.
除了作为@code{code_label}以外，标号还可以作为类型为@code{NOTE_INSN_DELETED_LABEL}的@code{note}来表示。

@findex LABEL_NUSES
@en The field @code{LABEL_NUSES} is only defined once the jump optimization
@en phase is completed.  It contains the number of times this label is
@en referenced in the current function.
域@code{LABEL_NUSES}只当完成跳转优化过程后才被定义。其包含了在当前函数中，该标号被引用的次数。

@findex LABEL_KIND
@findex SET_LABEL_KIND
@findex LABEL_ALT_ENTRY_P
@cindex alternate entry points
@en The field @code{LABEL_KIND} differentiates four different types of
@en labels: @code{LABEL_NORMAL}, @code{LABEL_STATIC_ENTRY},
@en @code{LABEL_GLOBAL_ENTRY}, and @code{LABEL_WEAK_ENTRY}.  The only labels
@en that do not have type @code{LABEL_NORMAL} are @dfn{alternate entry
@en points} to the current function.  These may be static (visible only in
@en the containing translation unit), global (exposed to all translation
@en units), or weak (global, but can be overridden by another symbol with the
@en same name).
域@code{LABEL_KIND}用来区分四种不同类型的标号：@code{LABEL_NORMAL}，@code{LABEL_STATIC_ENTRY}，@code{LABEL_GLOBAL_ENTRY}和@code{LABEL_WEAK_ENTRY}。唯一不具有类型@code{LABEL_NORMAL}的标号，为当前函数的@dfn{alternate entry points}。这些可以为static（只在当前转换单元中可见），global（对所有的转换单元可见）或者weak（全局的，但是可以被另一个具有相同名字的符号覆盖）。

@en Much of the compiler treats all four kinds of label identically.  Some
@en of it needs to know whether or not a label is an alternate entry point;
@en for this purpose, the macro @code{LABEL_ALT_ENTRY_P} is provided.  It is
@en equivalent to testing whether @samp{LABEL_KIND (label) == LABEL_NORMAL}.
@en The only place that cares about the distinction between static, global,
@en and weak alternate entry points, besides the front-end code that creates
@en them, is the function @code{output_alternate_entry_point}, in
@en @file{final.c}.
编译器大多将所有四种标号同等对待。有些地方需要知道标号是否为候选入口点；为此，提供了宏@code{LABEL_ALT_ENTRY_P}。其等价于测试是否@samp{LABEL_KIND (label) == LABEL_NORMAL}。除了前端创建static，global和weak alternate entry points的代码以外，其它唯一关心它们的区别的地方是@file{final.c}文件中的函数@code{output_alternate_entry_point}。

@en To set the kind of a label, use the @code{SET_LABEL_KIND} macro.
使用宏@code{SET_LABEL_KIND}来设置标号的种类。

@findex barrier
@item barrier
@en Barriers are placed in the instruction stream when control cannot flow
@en past them.  They are placed after unconditional jump instructions to
@en indicate that the jumps are unconditional and after calls to
@en @code{volatile} functions, which do not return (e.g., @code{exit}).
@en They contain no information beyond the three standard fields.
栅栏被放在指令流中，控制无法经过的地方。它们被放在无条件跳转指令的后面，表示跳转是无条件的，以及对@code{volatile}函数的调用之后，表示不会返回（例如，@code{exit}）。除了三个标准的域以外，不包含其它信息。

@findex note
@findex NOTE_LINE_NUMBER
@findex NOTE_SOURCE_FILE
@item note
@en @code{note} insns are used to represent additional debugging and
@en declarative information.  They contain two nonstandard fields, an
@en integer which is accessed with the macro @code{NOTE_LINE_NUMBER} and a
@en string accessed with @code{NOTE_SOURCE_FILE}.
@code{note} insns用于表示额外的调试和说明信息。它们包含两个非标准的域，一个使用宏@code{NOTE_LINE_NUMBER}访问的整数，以及一个使用@code{NOTE_SOURCE_FILE}访问的字符串。

@en If @code{NOTE_LINE_NUMBER} is positive, the note represents the
@en position of a source line and @code{NOTE_SOURCE_FILE} is the source file name
@en that the line came from.  These notes control generation of line
@en number data in the assembler output.
如果@code{NOTE_LINE_NUMBER}是正的，则注解表示源文件行号，并且@code{NOTE_SOURCE_FILE}为源文件名。这些注解控制在汇编输出中的生成行号数据。

@en Otherwise, @code{NOTE_LINE_NUMBER} is not really a line number but a
@en code with one of the following values (and @code{NOTE_SOURCE_FILE}
@en must contain a null pointer):
否则，@code{NOTE_LINE_NUMBER}不是一个行号，而是一个具有下列值之一的代码（并且@code{NOTE_SOURCE_FILE}必须包含一个空指针）：

@table @code
@findex NOTE_INSN_DELETED
@item NOTE_INSN_DELETED
@en Such a note is completely ignorable.  Some passes of the compiler
@en delete insns by altering them into notes of this kind.
这样的注解被完全忽略掉。编译器的一些过程会通过将insn修改成这种类型的注解，来删除insn。

@findex NOTE_INSN_DELETED_LABEL
@item NOTE_INSN_DELETED_LABEL
@en This marks what used to be a @code{code_label}, but was not used for other
@en purposes than taking its address and was transformed to mark that no
@en code jumps to it.
标记了曾经为@code{code_label}，但现在只用于获得其地址，并且没有代码会跳转到这里。

@findex NOTE_INSN_BLOCK_BEG
@findex NOTE_INSN_BLOCK_END
@item NOTE_INSN_BLOCK_BEG
@itemx NOTE_INSN_BLOCK_END
@en These types of notes indicate the position of the beginning and end
@en of a level of scoping of variable names.  They control the output
@en of debugging information.
这些类型的注解表示处于变量名作用域的起始和结束。它们控制调试信息的输出。

@findex NOTE_INSN_EH_REGION_BEG
@findex NOTE_INSN_EH_REGION_END
@item NOTE_INSN_EH_REGION_BEG
@itemx NOTE_INSN_EH_REGION_END
@en These types of notes indicate the position of the beginning and end of a
@en level of scoping for exception handling.  @code{NOTE_BLOCK_NUMBER}
@en identifies which @code{CODE_LABEL} or @code{note} of type
@en @code{NOTE_INSN_DELETED_LABEL} is associated with the given region.
这些类型的注解表示处于异常处理作用域的起始和结束。@code{NOTE_BLOCK_NUMBER}标识了哪一个类型为@code{NOTE_INSN_DELETED_LABEL}的@code{CODE_LABEL}或@code{note}与给定的区域相关联。

@findex NOTE_INSN_LOOP_BEG
@findex NOTE_INSN_LOOP_END
@item NOTE_INSN_LOOP_BEG
@itemx NOTE_INSN_LOOP_END
@en These types of notes indicate the position of the beginning and end
@en of a @code{while} or @code{for} loop.  They enable the loop optimizer
@en to find loops quickly.
这些类型的注解表示处于@code{while}或者@code{for}循环的起始和结束。它们使得循环优化可以快速的发现循环。

@findex NOTE_INSN_LOOP_CONT
@item NOTE_INSN_LOOP_CONT
@en Appears at the place in a loop that @code{continue} statements jump to.
出现在循环中@code{continue}语句跳转的地方。

@findex NOTE_INSN_LOOP_VTOP
@item NOTE_INSN_LOOP_VTOP
@en This note indicates the place in a loop where the exit test begins for
@en those loops in which the exit test has been duplicated.  This position
@en becomes another virtual start of the loop when considering loop
@en invariants.
该注解表示循环中退出测试（exit test）起始的地方，并且退出测试在循环中被复制。当考虑循环不变量时，该位置为循环的另一个虚拟起始点。

@findex NOTE_INSN_FUNCTION_BEG
@item NOTE_INSN_FUNCTION_BEG
@en Appears at the start of the function body, after the function
@en prologue.
出现在函数序言之后，函数体的起始处。

@findex NOTE_INSN_VAR_LOCATION
@findex NOTE_VAR_LOCATION
@item NOTE_INSN_VAR_LOCATION
@en This note is used to generate variable location debugging information.
@en It indicates that the user variable in its @code{VAR_LOCATION} operand
@en is at the location given in the RTL expression, or holds a value that
@en can be computed by evaluating the RTL expression from that static
@en point in the program up to the next such note for the same user
@en variable.
@end table

@en These codes are printed symbolically when they appear in debugging dumps.
在调试转储中，这些代码被符号化的打印。

@findex debug_insn
@findex INSN_VAR_LOCATION
@item debug_insn
@en The expression code @code{debug_insn} is used for pseudo-instructions
@en that hold debugging information for variable tracking at assignments
@en (see @option{-fvar-tracking-assignments} option).  They are the RTL
@en representation of @code{GIMPLE_DEBUG} statements
@en (@ref{@code{GIMPLE_DEBUG}}), with a @code{VAR_LOCATION} operand that
@en binds a user variable tree to an RTL representation of the
@en @code{value} in the corresponding statement.  A @code{DEBUG_EXPR} in
@en it stands for the value bound to the corresponding
@en @code{DEBUG_EXPR_DECL}.
表达式代码@code{debug_insn}用于存放赋值中变量跟踪（variable tracking）调试信息的伪指令（参见@option{-fvar-tracking-assignments}选项）。它们是@code{GIMPLE_DEBUG}语句的RTL表示（@ref{@code{GIMPLE_DEBUG}}），使用@code{VAR_LOCATION}操作数将用户变量tree与相应语句中@code{value}的RTL表示绑定在一起。其中的@code{DEBUG_EXPR}表示绑定到相应@code{DEBUG_EXPR_DECL}的值。

@en Throughout optimization passes, binding information is kept in
@en pseudo-instruction form, so that, unlike notes, it gets the same
@en treatment and adjustments that regular instructions would.  It is the
@en variable tracking pass that turns these pseudo-instructions into var
@en location notes, analyzing control flow, value equivalences and changes
@en to registers and memory referenced in value expressions, propagating
@en the values of debug temporaries and determining expressions that can
@en be used to compute the value of each user variable at as many points
@en (ranges, actually) in the program as possible.
在整个优化passes中，绑定信息是按照伪指令的形式进行保存，所以，不像注解（notes），它与常规指令具有相同的待遇。变量跟踪pass会将这些伪指令转换为变量位置注解，会分析控制流，分析值等价信息和值表达式中引用的寄存器和内存的变化，传播调试临时变量的值，并确定可以用来计算程序中尽可能多的点（实际上是域）上的每个用户变量的值的表达式。

@en Unlike @code{NOTE_INSN_VAR_LOCATION}, the value expression in an
@en @code{INSN_VAR_LOCATION} denotes a value at that specific point in the
@en program, rather than an expression that can be evaluated at any later
@en point before an overriding @code{VAR_LOCATION} is encountered.  E.g.,
@en if a user variable is bound to a @code{REG} and then a subsequent insn
@en modifies the @code{REG}, the note location would keep mapping the user
@en variable to the register across the insn, whereas the insn location
@en would keep the variable bound to the value, so that the variable
@en tracking pass would emit another location note for the variable at the
@en point in which the register is modified.
不像@code{NOTE_INSN_VAR_LOCATION}，@code{INSN_VAR_LOCATION}中的值表达式是表示程序中指定点的值，不可以在该点之后，@code{VAR_LOCATION}之前的任意点上进行求值。例如，如果一个用户变量绑定到一个@code{REG}，然后后续的insn修改了@code{REG}，则注解位置会继续将用户变量映射到寄存器，而insn位置则会继续将变量绑定到值上，所以，变量跟踪pass会为变量产成另一个位置注解，指定寄存器被修改的点。
@end table

@cindex @code{TImode}, in @code{insn}
@cindex @code{HImode}, in @code{insn}
@cindex @code{QImode}, in @code{insn}
@en The machine mode of an insn is normally @code{VOIDmode}, but some
@en phases use the mode for various purposes.
insn的机器模式通常为@code{VOIDmode}，但有些阶段出于不同的目的而使用其它机器模式。

@en The common subexpression elimination pass sets the mode of an insn to
@en @code{QImode} when it is the first insn in a block that has already
@en been processed.
公共子表达式消除过程将一个insn的机器模式设为@code{QImode}，当其为已经被处理过的块中的第一个insn时。

@en The second Haifa scheduling pass, for targets that can multiple issue,
@en sets the mode of an insn to @code{TImode} when it is believed that the
@en instruction begins an issue group.  That is, when the instruction
@en cannot issue simultaneously with the previous.  This may be relied on
@en by later passes, in particular machine-dependent reorg.
第二次Haifa调度过程中，对于可以多发射的目标机，当insn被认为是一个发射组合中的起始指令时，将其机器模式设为@code{TImode}。也就是说，该指令不能和之前的指令同时发射。这可以在后面的过程中用到，特别是机器特定的reorg。

@en Here is a table of the extra fields of @code{insn}, @code{jump_insn}
@en and @code{call_insn} insns:
下面的表中列出了@code{insn}, @code{jump_insn}和@code{call_insn}的其它域：

@table @code
@findex PATTERN
@item PATTERN (@var{i})
@en An expression for the side effect performed by this insn.  This must be
@en one of the following codes: @code{set}, @code{call}, @code{use},
@en @code{clobber}, @code{return}, @code{asm_input}, @code{asm_output},
@en @code{addr_vec}, @code{addr_diff_vec}, @code{trap_if}, @code{unspec},
@en @code{unspec_volatile}, @code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a @code{parallel},
@en each element of the @code{parallel} must be one these codes, except that
@en @code{parallel} expressions cannot be nested and @code{addr_vec} and
@en @code{addr_diff_vec} are not permitted inside a @code{parallel} expression.
一个表达式，为该insn执行的副作用。必须为下列代码中的一个：@code{set}, @code{call}, @code{use}, @code{clobber}, @code{return}, @code{asm_input}, @code{asm_output}, @code{addr_vec}, @code{addr_diff_vec}, @code{trap_if}, @code{unspec}, @code{unspec_volatile}, @code{parallel}, @code{cond_exec}或@code{sequence}。如果其为@code{parallel}，则@code{parallel}中的每个元素必须是这些代码中的一个，并且，@code{parallel}表达式不能被嵌套，@code{addr_vec}和@code{addr_diff_vec}不允许在@code{parallel}表达式中。

@findex INSN_CODE
@item INSN_CODE (@var{i})
@en An integer that says which pattern in the machine description matches
@en this insn, or @minus{}1 if the matching has not yet been attempted.
一个整数，说明机器描述中的哪一个指令模式匹配该insn，或者，如果还没有进行匹配，则为@minus{}1。

@en Such matching is never attempted and this field remains @minus{}1 on an insn
@en whose pattern consists of a single @code{use}, @code{clobber},
@en @code{asm_input}, @code{addr_vec} or @code{addr_diff_vec} expression.
对于指令模式由单个@code{use}, @code{clobber}, @code{asm_input}, @code{addr_vec} 或 @code{addr_diff_vec}表达式组成的insn，则不会进行这样的匹配，并且该域保持为@minus{}1。

@findex asm_noperands
@en Matching is also never attempted on insns that result from an @code{asm}
@en statement.  These contain at least one @code{asm_operands} expression.
@en The function @code{asm_noperands} returns a non-negative value for
@en such insns.
对于来自@code{asm}语句的insn，也不会进行指令模式匹配。这些至少包含了一个@code{asm_operands}表达式。函数@code{asm_noperands}为这样的insn返回一个非负的值。

@en In the debugging output, this field is printed as a number followed by
@en a symbolic representation that locates the pattern in the @file{md}
@en file as some small positive or negative offset from a named pattern.
在调试输出中，该域被打印成一个数字，紧随一个符号表示，用来定位在@file{md}中的指令模式，数字表示相对命名指令模式的正的或者负的偏移量。

@findex LOG_LINKS
@item LOG_LINKS (@var{i})
@en A list (chain of @code{insn_list} expressions) giving information about
@en dependencies between instructions within a basic block.  Neither a jump
@en nor a label may come between the related insns.  These are only used by
@en the schedulers and by combine.  This is a deprecated data structure.
@en Def-use and use-def chains are now preferred. 
一个列表（@code{insn_list}表达式链），给出了基本块中指令之间的依赖信息。相关联的insn之间不会有跳转或者标号。这些只被用于指令调度和组合。这是一个不被推荐的数据结构。现在推荐使用def-use和use-def链。

@findex REG_NOTES
@item REG_NOTES (@var{i})
@en A list (chain of @code{expr_list} and @code{insn_list} expressions)
@en giving miscellaneous information about the insn.  It is often
@en information pertaining to the registers used in this insn.
一个列表（@code{expr_list}和@code{insn_list}表达式链），给出了insn的其它信息。通常为从属于该insn使用的寄存器的信息。
@end table

@en The @code{LOG_LINKS} field of an insn is a chain of @code{insn_list}
@en expressions.  Each of these has two operands: the first is an insn,
@en and the second is another @code{insn_list} expression (the next one in
@en the chain).  The last @code{insn_list} in the chain has a null pointer
@en as second operand.  The significant thing about the chain is which
@en insns appear in it (as first operands of @code{insn_list}
@en expressions).  Their order is not significant.
insn的@code{LOG_LINKS}域为@code{insn_list}表达式链。每一个都具有两个操作数：第一个为insn，第二个为另一个@code{insn_list}表达式（链中的下一个）。链中的最后一个@code{insn_list}的第二个操作数为空指针。对于表达式链，重要的是有哪些insn（@code{insn_list}表达式的第一个操作数）。它们的顺序并不重要。

@en This list is originally set up by the flow analysis pass; it is a null
@en pointer until then.  Flow only adds links for those data dependencies
@en which can be used for instruction combination.  For each insn, the flow
@en analysis pass adds a link to insns which store into registers values
@en that are used for the first time in this insn.
该列表最初由流分析过程建立；在此之前还只是空指针。流分析只将那些可以用于指令合并的数据依赖，加入到列表中。

@en The @code{REG_NOTES} field of an insn is a chain similar to the
@en @code{LOG_LINKS} field but it includes @code{expr_list} expressions in
@en addition to @code{insn_list} expressions.  There are several kinds of
@en register notes, which are distinguished by the machine mode, which in a
@en register note is really understood as being an @code{enum reg_note}.
@en The first operand @var{op} of the note is data whose meaning depends on
@en the kind of note.
insn的@code{REG_NOTES}域是一个类似于@code{LOG_LINKS}域的链，不过除了@code{insn_list}表达式，其还包含@code{expr_list}表达式。有多种寄存器注解，其通过机器模式区分。注解的第一个操作数@var{op}的含义依赖注解的种类。

@findex REG_NOTE_KIND
@findex PUT_REG_NOTE_KIND
@en The macro @code{REG_NOTE_KIND (@var{x})} returns the kind of
@en register note.  Its counterpart, the macro @code{PUT_REG_NOTE_KIND
@en (@var{x}, @var{newkind})} sets the register note type of @var{x} to be
@en @var{newkind}.
宏@code{REG_NOTE_KIND (@var{x})}返回寄存器注解的种类。宏@code{PUT_REG_NOTE_KIND (@var{x}, @var{newkind})}将@var{x}的寄存器注解类型设置为@var{newkind}。

@en Register notes are of three classes: They may say something about an
@en input to an insn, they may say something about an output of an insn, or
@en they may create a linkage between two insns.  There are also a set
@en of values that are only used in @code{LOG_LINKS}.
寄存器注解有三种类别：可以用来说明insn的输入，可以用来说明insn的输出，或者可以用来创建两个insn之间的连接。还有一个值集，只用于@code{LOG_LINKS}中。

@en These register notes annotate inputs to an insn:
这些注解用来说明insn的输入：

@table @code
@findex REG_DEAD
@item REG_DEAD
@en The value in @var{op} dies in this insn; that is to say, altering the
@en value immediately after this insn would not affect the future behavior
@en of the program.
@var{op}中的值在该insn中死掉；也就是说，紧接这个insn之后，修改该值将不会影响程序将来的行为。

@en It does not follow that the register @var{op} has no useful value after
@en this insn since @var{op} is not necessarily modified by this insn.
@en Rather, no subsequent instruction uses the contents of @var{op}.
这并不是说从该insn之后，寄存器@var{op}就没有有用的值了。而是说，后续的指令不会用到@var{op}的内容。

@findex REG_UNUSED
@item REG_UNUSED
@en The register @var{op} being set by this insn will not be used in a
@en subsequent insn.  This differs from a @code{REG_DEAD} note, which
@en indicates that the value in an input will not be used subsequently.
@en These two notes are independent; both may be present for the same
@en register.
被该insn设置的寄存器@var{op}，将不会在后续的insn中使用。这与@code{REG_DEAD}注解不同，后者表示输入中的值将不会被后续insn使用。这两个注解是不相关的；可能会都出现在同一个寄存器中。

@findex REG_INC
@item REG_INC
@en The register @var{op} is incremented (or decremented; at this level
@en there is no distinction) by an embedded side effect inside this insn.
@en This means it appears in a @code{post_inc}, @code{pre_inc},
@en @code{post_dec} or @code{pre_dec} expression.
寄存器@var{op}由于insn中嵌入的副作用，而被递增（或递减）。这意味着其出现在@code{post_inc}, @code{pre_inc}, @code{post_dec}或@code{pre_dec}表达式中。

@findex REG_NONNEG
@item REG_NONNEG
@en The register @var{op} is known to have a nonnegative value when this
@en insn is reached.  This is used so that decrement and branch until zero
@en instructions, such as the m68k dbra, can be matched.
寄存器@var{op}在到达该insn的时候，被已知为具有一个非负的值。对于递减并分支跳转，直到为零的指令，例如m68k dbra，可以用来进行匹配。

@en The @code{REG_NONNEG} note is added to insns only if the machine
@en description has a @samp{decrement_and_branch_until_zero} pattern.
@code{REG_NONNEG}注解，只有当机器描述具有@samp{decrement_and_branch_until_zero}指令模式的时候，才被加到insn中。

@findex REG_LABEL_OPERAND
@item REG_LABEL_OPERAND
@en This insn uses @var{op}, a @code{code_label} or a @code{note} of type
@en @code{NOTE_INSN_DELETED_LABEL}, but is not a @code{jump_insn}, or it
@en is a @code{jump_insn} that refers to the operand as an ordinary
@en operand.  The label may still eventually be a jump target, but if so
@en in an indirect jump in a subsequent insn.  The presence of this note
@en allows jump optimization to be aware that @var{op} is, in fact, being
@en used, and flow optimization to build an accurate flow graph.
该insn使用@var{op}，一个类型为@code{NOTE_INSN_DELETED_LABEL}的@code{code_label}或者@code{note}，但是不为@code{jump_insn}。或者，其为一个将操作数作为普通操作数的@code{jump_insn}。标号最终也可以为跳转目标，但这是在后续insn的间接跳转中。该注解使得跳转优化知道@var{op}实际上被使用了，从而流优化可以创建一个精确的流图。

@findex REG_LABEL_TARGET
@item REG_LABEL_TARGET
@en This insn is a @code{jump_insn} but not an @code{addr_vec} or
@en @code{addr_diff_vec}.  It uses @var{op}, a @code{code_label} as a
@en direct or indirect jump target.  Its purpose is similar to that of
@en @code{REG_LABEL_OPERAND}.  This note is only present if the insn has
@en multiple targets; the last label in the insn (in the highest numbered
@en insn-field) goes into the @code{JUMP_LABEL} field and does not have a
@en @code{REG_LABEL_TARGET} note.  @xref{Insns, JUMP_LABEL}.
该insn为一个@code{jump_insn}，但不是@code{addr_vec}和@code{addr_diff_vec}。其使用@var{op}，一个@code{code_label}，作为直接或间接跳转的目标。其用途与@code{REG_LABEL_OPERAND}类似。该注解只存在于当insn具有多个目标的时候；insn中的最后一个标号（在最高编号的insn域中），放到@code{JUMP_LABEL}域中，并且没有@code{REG_LABEL_TARGET}。@xref{Insns, JUMP_LABEL}.

@findex REG_CROSSING_JUMP
@item REG_CROSSING_JUMP
@en This insn is a branching instruction (either an unconditional jump or
@en an indirect jump) which crosses between hot and cold sections, which
@en could potentially be very far apart in the executable.  The presence
@en of this note indicates to other optimizations that this branching
@en instruction should not be ``collapsed'' into a simpler branching
@en construct.  It is used when the optimization to partition basic blocks
@en into hot and cold sections is turned on.
该insn为一个分支指令（无条件跳转或者间接跳转），其穿越了热代码段和冷代码段，并可能潜在的位于可执行程序中非常远的部分。该注解用来指示其它优化，表示该分支指令不应该被折叠为简单的分支结构。其用于当优化将基本块分成热代码段和冷代码段的时候。

@findex REG_SETJMP
@item REG_SETJMP 
@en Appears attached to each @code{CALL_INSN} to @code{setjmp} or a 
@en related function.
附加在每个针对@code{setjmp}或者相关的函数的@code{CALL_INSN}上。

@end table

@en The following notes describe attributes of outputs of an insn:
下列注解描述了有关insn的输出的属性：

@table @code
@findex REG_EQUIV
@findex REG_EQUAL
@item REG_EQUIV
@itemx REG_EQUAL
@en This note is only valid on an insn that sets only one register and
@en indicates that that register will be equal to @var{op} at run time; the
@en scope of this equivalence differs between the two types of notes.  The
@en value which the insn explicitly copies into the register may look
@en different from @var{op}, but they will be equal at run time.  If the
@en output of the single @code{set} is a @code{strict_low_part} expression,
@en the note refers to the register that is contained in @code{SUBREG_REG}
@en of the @code{subreg} expression.
该注解只用在只设置一个寄存器的insn上，用来表示那个寄存器在运行时等价于@var{op}；该等值的作用域根据两种类型的注解而有所不同。insn显式的复制进寄存器的值可能看起来与@var{op}不同，但它们将在运行时相等。如果单个@code{set}的输出为一个@code{strict_low_part}表达式，则注解是用于@code{subreg}表达式@code{SUBREG_REG}所包含的寄存器。

@en For @code{REG_EQUIV}, the register is equivalent to @var{op} throughout
@en the entire function, and could validly be replaced in all its
@en occurrences by @var{op}.  (``Validly'' here refers to the data flow of
@en the program; simple replacement may make some insns invalid.)  For
@en example, when a constant is loaded into a register that is never
@en assigned any other value, this kind of note is used.
对于@code{REG_EQUIV}，在整个函数中，寄存器都等价于@var{op}，并且可以在其所有出现的地方被@var{op}有效替换。（有效，这里是指程序的数据流；简单的替换可能会使得某些insn无效。）例如，当一个常量被加载到一个寄存器中，并且寄存器不再被赋予任何其它值，则会使用这种注解。

@en When a parameter is copied into a pseudo-register at entry to a function,
@en a note of this kind records that the register is equivalent to the stack
@en slot where the parameter was passed.  Although in this case the register
@en may be set by other insns, it is still valid to replace the register
@en by the stack slot throughout the function.
当在函数入口处，一个参数被复制到一个伪寄存器中时，这种的注解会用来记录该寄存器等价于传递参数的栈槽。虽然，这种情况下，寄存器可能被其它的insn设置，其也可以在整个函数中被栈槽来替换。

@en A @code{REG_EQUIV} note is also used on an instruction which copies a
@en register parameter into a pseudo-register at entry to a function, if
@en there is a stack slot where that parameter could be stored.  Although
@en other insns may set the pseudo-register, it is valid for the compiler to
@en replace the pseudo-register by stack slot throughout the function,
@en provided the compiler ensures that the stack slot is properly
@en initialized by making the replacement in the initial copy instruction as
@en well.  This is used on machines for which the calling convention
@en allocates stack space for register parameters.  See
@en @code{REG_PARM_STACK_SPACE} in @ref{Stack Arguments}.
@code{REG_EQUIV}注解还用于，在函数入口处，将一个寄存器参数复制到一个伪寄存器中的指令，如果存在一个参数本来应该被存放的栈槽。虽然其它insn可以设置该伪寄存器，但编译器还是可以在整个函数中，使用栈槽来替换伪寄存器，假设编译器可以确保栈槽被适当的初始化。这被用于调用约定为寄存器参数分配栈空间的机器上。参见@ref{Stack Arguments}中的@code{REG_PARM_STACK_SPACE}。

@en In the case of @code{REG_EQUAL}, the register that is set by this insn
@en will be equal to @var{op} at run time at the end of this insn but not
@en necessarily elsewhere in the function.  In this case, @var{op}
@en is typically an arithmetic expression.  For example, when a sequence of
@en insns such as a library call is used to perform an arithmetic operation,
@en this kind of note is attached to the insn that produces or copies the
@en final value.
对于@code{REG_EQUAL}的情况，被该insn设置的寄存器，将在运行时，在该insn的结尾处，但不必要是函数的其它地方，等价与@var{op}。这种情况下，@var{op}通常为一个算术表达式。例如，当一个库调用的insn序列，被用在一个算术运算上，则该类的注解将被附加在产生或者复制最终值的insn上。

@en These two notes are used in different ways by the compiler passes.
@en @code{REG_EQUAL} is used by passes prior to register allocation (such as
@en common subexpression elimination and loop optimization) to tell them how
@en to think of that value.  @code{REG_EQUIV} notes are used by register
@en allocation to indicate that there is an available substitute expression
@en (either a constant or a @code{mem} expression for the location of a
@en parameter on the stack) that may be used in place of a register if
@en insufficient registers are available.
这两个注解在编译器过程中，按照不同的方法来使用。@code{REG_EQUAL}用于寄存器分配之前的过程中（例如公共子表达式消除和循环优化），来告诉它们如何考虑那个值。@code{REG_EQUIV}注解用于寄存器分配，来表示存在一个可用的替换表达式（为栈上一个参数位置的常量或者@code{mem}表达式），其可以用在没有足够寄存器的地方。

@en Except for stack homes for parameters, which are indicated by a
@en @code{REG_EQUIV} note and are not useful to the early optimization
@en passes and pseudo registers that are equivalent to a memory location
@en throughout their entire life, which is not detected until later in
@en the compilation, all equivalences are initially indicated by an attached
@en @code{REG_EQUAL} note.  In the early stages of register allocation, a
@en @code{REG_EQUAL} note is changed into a @code{REG_EQUIV} note if
@en @var{op} is a constant and the insn represents the only set of its
@en destination register.
除了为参数提供地方的栈以外，其它所有等值最初都是通过附加一个@code{REG_EQUAL}注解来表示。在寄存器分配的早期阶段，如果@var{op}是一个常量并且insn只表示对其目的寄存器进行设置，则@code{REG_EQUAL}被改变成@code{REG_EQUIV}注解。

@en Thus, compiler passes prior to register allocation need only check for
@en @code{REG_EQUAL} notes and passes subsequent to register allocation
@en need only check for @code{REG_EQUIV} notes.
因此，寄存器分配之前的编译过程，只需要检查@code{REG_EQUAL}注解，而之后的编译过程只需要检查@code{REG_EQUIV}注解。
@end table

@en These notes describe linkages between insns.  They occur in pairs: one
@en insn has one of a pair of notes that points to a second insn, which has
@en the inverse note pointing back to the first insn.
这些注解描述了insn之间的联系。它们成对的出现：一个insn具有一对注解，其中之一用来指向第二个insn，并且第二个insn也由一个反过来指向第一个insn的注解。

@table @code
@findex REG_CC_SETTER
@findex REG_CC_USER
@item REG_CC_SETTER
@itemx REG_CC_USER
@en On machines that use @code{cc0}, the insns which set and use @code{cc0}
@en set and use @code{cc0} are adjacent.  However, when branch delay slot
@en filling is done, this may no longer be true.  In this case a
@en @code{REG_CC_USER} note will be placed on the insn setting @code{cc0} to
@en point to the insn using @code{cc0} and a @code{REG_CC_SETTER} note will
@en be placed on the insn using @code{cc0} to point to the insn setting
@en @code{cc0}.
在使用@code{cc0}的机器上，设置和使用@code{cc0}的insns是相邻的。然而，当做完分支延迟槽填充之后，就不一定是这样的了。这种情况下，@code{REG_CC_USER}注解将被放在设置@code{cc0}的insn上，来指向使用@code{cc0}的insn，并且@code{REG_CC_SETTER}注解将被放在使用@code{cc0}的insn上，来指向设置@code{cc0}的insn。
@end table

@en These values are only used in the @code{LOG_LINKS} field, and indicate
@en the type of dependency that each link represents.  Links which indicate
@en a data dependence (a read after write dependence) do not use any code,
@en they simply have mode @code{VOIDmode}, and are printed without any
@en descriptive text.
这些值只用在@code{LOG_LINKS}域，用来表示每个链接表示的依赖类型。表示一个数据依赖（写后读依赖）的链接，不使用任何代码，它们只是简单的具有@code{VOIDmode}模式，并在打印输出中没有任何描述文本。

@table @code
@findex REG_DEP_TRUE
@item REG_DEP_TRUE
@en This indicates a true dependence (a read after write dependence).
这表示一个真依赖（写后读依赖）。

@findex REG_DEP_OUTPUT
@item REG_DEP_OUTPUT
@en This indicates an output dependence (a write after write dependence).
这表示一个输出依赖（写后写依赖）。

@findex REG_DEP_ANTI
@item REG_DEP_ANTI
@en This indicates an anti dependence (a write after read dependence).
这表示一个反依赖（读后写依赖）。

@end table

@en These notes describe information gathered from gcov profile data.  They
@en are stored in the @code{REG_NOTES} field of an insn as an
@en @code{expr_list}.
这些注解描述了从gcov profile数据中搜集的信息。它们作为@code{expr_list}存储在insn的@code{REG_NOTES}域中。

@table @code
@findex REG_BR_PROB
@item REG_BR_PROB
@en This is used to specify the ratio of branches to non-branches of a
@en branch insn according to the profile data.  The value is stored as a
@en value between 0 and REG_BR_PROB_BASE; larger values indicate a higher
@en probability that the branch will be taken.
用于指定分支跳转率，根据profile数据。值位于0和REG_BR_PROB_BASE之间；较大的值表示该分支更可能会被执行。

@findex REG_BR_PRED
@item REG_BR_PRED
@en These notes are found in JUMP insns after delayed branch scheduling
@en has taken place.  They indicate both the direction and the likelihood
@en of the JUMP@.  The format is a bitmask of ATTR_FLAG_* values.
这些注解在JUMP insn中，并出现在延迟分支调度之后。它们表示JUMP的方向和可能性。格式为ATTR_FLAG_*值的掩码。

@findex REG_FRAME_RELATED_EXPR
@item REG_FRAME_RELATED_EXPR
@en This is used on an RTX_FRAME_RELATED_P insn wherein the attached expression
@en is used in place of the actual insn pattern.  This is done in cases where
@en the pattern is either complex or misleading.
用在RTX_FRAME_RELATED_P insn上，其附加的表达式被用在实际的insn模式上。这用于指令模式过于复杂或者产生误解的情况。

@end table

@en For convenience, the machine mode in an @code{insn_list} or
@en @code{expr_list} is printed using these symbolic codes in debugging dumps.
为方便起见，在@code{insn_list}或者@code{expr_list}中的机器模式，在调试转储中使用这些符号化的代码来打印。

@findex insn_list
@findex expr_list
@en The only difference between the expression codes @code{insn_list} and
@en @code{expr_list} is that the first operand of an @code{insn_list} is
@en assumed to be an insn and is printed in debugging dumps as the insn's
@en unique id; the first operand of an @code{expr_list} is printed in the
@en ordinary way as an expression.
表达式代码@code{insn_list}和@code{expr_list}之间的唯一区别是，@code{insn_list}的第一个操作数被假设为一个insn，并在调试转储中作为insn的唯一id来打印；而@code{expr_list}的第一个操作数作为表达式，按照普通的方式来打印。

@en @node Calls
@en @section RTL Representation of Function-Call Insns
@node Calls
@section 函数调用insns的RTL表示
@cindex calling functions in RTL
@cindex RTL function-call insns
@cindex function-call insns

@en Insns that call subroutines have the RTL expression code @code{call_insn}.
@en These insns must satisfy special rules, and their bodies must use a special
@en RTL expression code, @code{call}.
调用子程序的Insn具有RTL表达式代码@code{call_insn}。这些insn必须满足特别的规则，并且它们的主体必须使用特定的RTL表达式代码@code{call}。

@cindex @code{call} usage
@en A @code{call} expression has two operands, as follows:
@code{call}表达式有两个操作数，如下：

@smallexample
(call (mem:@var{fm} @var{addr}) @var{nbytes})
@end smallexample

@noindent
@en Here @var{nbytes} is an operand that represents the number of bytes of
@en argument data being passed to the subroutine, @var{fm} is a machine mode
@en (which must equal as the definition of the @code{FUNCTION_MODE} macro in
@en the machine description) and @var{addr} represents the address of the
@en subroutine.
这里@var{nbytes}操作数表示传递给子程序的参数的字节数，@var{fm}是一个机器模式（其必须与在机器描述中定义的@code{FUNCTION_MODE}相等），@var{addr}表示子程序的地址。

@en For a subroutine that returns no value, the @code{call} expression as
@en shown above is the entire body of the insn, except that the insn might
@en also contain @code{use} or @code{clobber} expressions.
对于子程序没有返回值的，上面所示的@code{call}表达式是insn的整个主体，除了insn可能还会包含@code{use}或@code{clobber}表达式。

@cindex @code{BLKmode}, and function return values
@en For a subroutine that returns a value whose mode is not @code{BLKmode},
@en the value is returned in a hard register.  If this register's number is
@en @var{r}, then the body of the call insn looks like this:
对于子程序返回不是@code{BLKmode}模式的值的，值通过硬件寄存器返回。如果该寄存器号为@var{r}，则call insn的主体看起来是这样的：

@smallexample
(set (reg:@var{m} @var{r})
     (call (mem:@var{fm} @var{addr}) @var{nbytes}))
@end smallexample

@noindent
@en This RTL expression makes it clear (to the optimizer passes) that the
@en appropriate register receives a useful value in this insn.
该RTL表达式很清楚的说明了（对于优化阶段），在该insn中有一个适当的寄存器用来接受一个有用的值。

@en When a subroutine returns a @code{BLKmode} value, it is handled by
@en passing to the subroutine the address of a place to store the value.
@en So the call insn itself does not ``return'' any value, and it has the
@en same RTL form as a call that returns nothing.
当子程序返回@code{BLKmode}值时，将会通过传递给子程序用来存储返回值的地址来处理。因次，call insn本身不返回任何值，具有和没有返回值一样的RTL。

@en On some machines, the call instruction itself clobbers some register,
@en for example to contain the return address.  @code{call_insn} insns
@en on these machines should have a body which is a @code{parallel}
@en that contains both the @code{call} expression and @code{clobber}
@en expressions that indicate which registers are destroyed.  Similarly,
@en if the call instruction requires some register other than the stack
@en pointer that is not explicitly mentioned in its RTL, a @code{use}
@en subexpression should mention that register.
在一些机器上，调用指令本身会破坏一些寄存器，例如包含了返回地址。这些机器上的@code{call_insn}应该有一个@code{parallel}主体，包含了@code{call}表达式和@code{clobber}表达式，用来指示哪些寄存器会被破坏。类似的，如果调用指令需要栈指针之外的一些寄存器，并且没有在其RTL中显示提到的，则应该用@code{use}子表达式来指出。

@en Functions that are called are assumed to modify all registers listed in
@en the configuration macro @code{CALL_USED_REGISTERS} (@pxref{Register
@en Basics}) and, with the exception of @code{const} functions and library
@en calls, to modify all of memory.
被调用的函数被假设为会修改列在配置宏@code{CALL_USED_REGISTERS}（@pxref{Register Basics}）中的所有寄存器，并且除了const函数和库函数调用外，被假设为会修改所有的内存。

@en Insns containing just @code{use} expressions directly precede the
@en @code{call_insn} insn to indicate which registers contain inputs to the
@en function.  Similarly, if registers other than those in
@en @code{CALL_USED_REGISTERS} are clobbered by the called function, insns
@en containing a single @code{clobber} follow immediately after the call to
@en indicate which registers.
直接在@code{call_insn}之前的只是包含了@code{use}表达式的insn，用来指示哪些寄存器用来存放函数的输入。类似的，如果不在@code{CALL_USED_REGISTERS}中那些寄存器会被所调用的函数破坏，紧跟在call之后的包含了单独的@code{clobber}的insn，用来指出这些寄存器。

@en @node Sharing
@en @section Structure Sharing Assumptions
@node Sharing
@section 结构共享假设
@cindex sharing of RTL components
@cindex RTL structure sharing assumptions

@en The compiler assumes that certain kinds of RTL expressions are unique;
@en there do not exist two distinct objects representing the same value.
@en In other cases, it makes an opposite assumption: that no RTL expression
@en object of a certain kind appears in more than one place in the
@en containing structure.
编译器假设某些类型的RTL表达式是唯一的；不会存在两个不同的对象表示相同的值。对于其它情况，有相反的假设：在被包含的结构体中，不会在多个地方出现某一类型的RTL表达式对象。

@en These assumptions refer to a single function; except for the RTL
@en objects that describe global variables and external functions,
@en and a few standard objects such as small integer constants,
@en no RTL objects are common to two functions.
这些假设针对于一个单独的函数；除了描述全局变量和外部函数的RTL对象，一些标准对象，例如小整形常数以外，没有其它RTL对象可以在两个函数中共用。

@itemize @bullet
@cindex @code{reg}, RTL sharing
@item
@en Each pseudo-register has only a single @code{reg} object to represent it,
@en and therefore only a single machine mode.
每一个伪寄存器只有一个单独的@code{reg}对象来表示，因此也只有一种机器模式。

@cindex symbolic label
@cindex @code{symbol_ref}, RTL sharing
@item
@en For any symbolic label, there is only one @code{symbol_ref} object
@en referring to it.
对于任何标号，只有一个@code{symbol_ref}对象关联。

@cindex @code{const_int}, RTL sharing
@item
@en All @code{const_int} expressions with equal values are shared.
所有具有相同值的@code{const_int}表达式被共享。

@cindex @code{pc}, RTL sharing
@item
@en There is only one @code{pc} expression.
T只有一个@code{pc}表达式。

@cindex @code{cc0}, RTL sharing
@item
@en There is only one @code{cc0} expression.
只有一个@code{cc0}表达式。

@cindex @code{const_double}, RTL sharing
@item
@en There is only one @code{const_double} expression with value 0 for
@en each floating point mode.  Likewise for values 1 and 2.
对于每一种浮点模式，只有一个@code{const_double}表达式其值为0。同样对于值1，2。

@cindex @code{const_vector}, RTL sharing
@item
@en There is only one @code{const_vector} expression with value 0 for
@en each vector mode, be it an integer or a double constant vector.
对于每一种向量模式，只有一个@code{const_vector}表达式其值为0。其为整数或者双精度常量向量。

@cindex @code{label_ref}, RTL sharing
@cindex @code{scratch}, RTL sharing
@item
@en No @code{label_ref} or @code{scratch} appears in more than one place in
@en the RTL structure; in other words, it is safe to do a tree-walk of all
@en the insns in the function and assume that each time a @code{label_ref}
@en or @code{scratch} is seen it is distinct from all others that are seen.
在RTL结构体中不会在多个地方出现@code{label_ref}或@code{scratch}；换句话说，对函数中所有insn进行树遍历时，可以认为每次遇到的@code{label_ref}或者@code{scratch}都与在其它地方遇到的不同。

@cindex @code{mem}, RTL sharing
@item
@en Only one @code{mem} object is normally created for each static
@en variable or stack slot, so these objects are frequently shared in all
@en the places they appear.  However, separate but equal objects for these
@en variables are occasionally made.
对于每个静态变量或者栈槽，通常只创建一个@code{mem}对象，所以这些对象在它们出现的所有地方被共享。然而，有时会为这些变量创建单独的，但是相等的对象。

@cindex @code{asm_operands}, RTL sharing
@item
@en When a single @code{asm} statement has multiple output operands, a
@en distinct @code{asm_operands} expression is made for each output operand.
@en However, these all share the vector which contains the sequence of input
@en operands.  This sharing is used later on to test whether two
@en @code{asm_operands} expressions come from the same statement, so all
@en optimizations must carefully preserve the sharing if they copy the
@en vector at all.
当一个单独的@code{asm}语句具有多个输出操作数时，会为每一个输出数创建一个不同的@code{asm_operands}表达式。然后，这些表达式都共享包含着输入操作数序列的向量。这是为了之后用于测试两个@code{asm_operands}表达式是否来自同一语句，所以，所有的优化当进行复制整个向量时，必须仔细保持共享。

@item
@en No RTL object appears in more than one place in the RTL structure
@en except as described above.  Many passes of the compiler rely on this
@en by assuming that they can modify RTL objects in place without unwanted
@en side-effects on other insns.
除了上面描述的以外，在RTL结构体中没有其它RTL对象会出现多次。编译器的许多遍扫描，都是依赖于这样的假设，即它们能在一个地方修改RTL对象，并且不会对其它insn产生不需要的副作用。

@findex unshare_all_rtl
@item
@en During initial RTL generation, shared structure is freely introduced.
@en After all the RTL for a function has been generated, all shared
@en structure is copied by @code{unshare_all_rtl} in @file{emit-rtl.c},
@en after which the above rules are guaranteed to be followed.
在最初的RTL生成过程中，可以随意使用共享结构。当一个函数的所有RTL都被生成之后，所有的共享结构体都被@file{emit-rtl.c}中的@code{unshare_all_rtl}进行复制，之后，将保证上面的规则会被遵循。

@findex copy_rtx_if_shared
@item
@en During the combiner pass, shared structure within an insn can exist
@en temporarily.  However, the shared structure is copied before the
@en combiner is finished with the insn.  This is done by calling
@en @code{copy_rtx_if_shared}, which is a subroutine of
@en @code{unshare_all_rtl}.
在合并阶段，共享结构体可以在insn中临时存在。但是，在insn的合并完成之前，共享结构会被复制，通过调用@code{unshare_all_rtl}的子程序@code{copy_rtx_if_shared}。

@end itemize

@en @node Reading RTL
@en @section Reading RTL
@node Reading RTL
@section 读取RTL

@en To read an RTL object from a file, call @code{read_rtx}.  It takes one
@en argument, a stdio stream, and returns a single RTL object.  This routine
@en is defined in @file{read-rtl.c}.  It is not available in the compiler
@en itself, only the various programs that generate the compiler back end
@en from the machine description.
若要从文件中读取RTL对象，可以调用@code{read_rtx}。
它接受一个参数，stdio标准输入输出流，并且返回一个RTL对象。
该函数在@file{read-rtl.c}中定义。
它只在通过机器描述来生成编译器后端的各种程序中使用，编译器本身并没有用到。

@en People frequently have the idea of using RTL stored as text in a file as
@en an interface between a language front end and the bulk of GCC@.  This
@en idea is not feasible.
人们经常想到使用以文本方式存储在文件中的RTL来作为语言前端和GCC主干之间的接口。
这种想法其实是不可行的。

@en GCC was designed to use RTL internally only.  Correct RTL for a given
@en program is very dependent on the particular target machine.  And the RTL
@en does not contain all the information about the program.
GCC一度被设计为只是在内部使用RTL。对于给定的程序，
RTL正确与否与特定的目标机器非常有关系。而且RTL并不包含程序的所有信息。

@en The proper way to interface GCC to a new language front end is with
@en the ``tree'' data structure, described in the files @file{tree.h} and
@en @file{tree.def}.  The documentation for this structure (@pxref{GENERIC})
@en is incomplete.
对于GCC和一个新语言前端接口的恰当方式，
是使用在文件@file{tree.h}和@file{tree.def}中描述的“tree”数据结构。
关于该结构的文档（@pxref{GENERIC}）不是很全面。
