@c Copyright (C) 1988, 1989, 1992, 1994, 1997, 1998, 1999, 2000, 2001, 2002,
@c 2003, 2004, 2005, 2006, 2007, 2008
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node RTL
@chapter RTL表示
@cindex RTL representation
@cindex representation of RTL
@cindex Register Transfer Language (RTL)

编译器的大部分工作都是基于一种中间表示，叫做寄存器传送语言（register transfer language）。在该语言中，描述了将要输出的指令，并且差不多是按照字母顺序一个一个的来描述指令的行为。

RTL的灵感来自Lisp列表。它同时具有一个内部形式，由指向结构体的结构体组成，以及一个文本形式，用在机器描述和打印的调试输出中。文本形式使用嵌套的括号，来表示内部形式中的指针。

@menu
* RTL对象::       表达式、向量、字符串、整数 
* RTL类别::       RTL表达式对象的类别，以及它们的结构 
* 访问方式::      用来访问表达式操作数和向量成员的宏
* 访问特殊操作数::  用来访问RTL中的特殊注解
* 标记::          RTL表达式中的其它标记
* 机器模式::      描述一个数据的大小和格式
* 常数::          常数值表达式
* 寄存器和内存::  表示寄存器内容或内存的表达式
* 算术运算::      表示算术运算的表达式 
* 比较运算::      表示比较运算的表达式
* 位域运算::      表示内存或寄存器中位域的表达式
* 向量运算::      关于向量数据类型的表达式
* 转换运算::      扩展，截断，浮点化或者定点化
* RTL声明::       声明为volatile的，constant的，等等
* 副作用::        存储到寄存器的表达式，等
* Incdec::        自动增量寻址的嵌入的副作用
* 汇编::          表示带有操作数的asm
* Insns::         整个insn的表达式类型
* 函数调用::      函数call insn的RTL表示
* 共享::          一些表达式是唯一的；其它的必须要被复制
* 读取RTL::       从文件中读取文本的RTL
@end menu

@node RTL对象
@section RTL对象类型
@cindex RTL object types

@cindex RTL integers
@cindex RTL strings
@cindex RTL vectors
@cindex RTL expression
@cindex RTX (See RTL)
RTL使用五种对象：表达式、整数、宽整数、字符串和向量。其中，最重要的是表达式。RTL 表达式（简称RTX）是一个C结构体，通常用指针来引用它。这种引用它的指针的类型定义名为@code{rtx}。

整数就是C中的@code{int}，书写形式使用十进制表示。宽整数是@code{HOST_WIDE_INT}类型的一个整数对象，其书写形式也用十进制表示。

字符串为一串字符，在存储器中以C的@code{char *}形式表示且按C语法规定书写。然而，RTL中的字符串决不会为空值。若机器描述中有一空字符串，它在存储器中则表示成一个空指针而不是通常意义上的指向空字符的指针。在某些上下文中，允许用这种空指针表示空字符串。在RTL代码中，字符串经常出现在@code{symbol_ref}表达式中，但也出现在某些机器描述的RTL表达式中。

对于字符串，还有一种特殊的语法，用于在机器描述中嵌入C代码。只要字符串可以出现的地方，都可以书写一个C风格的大括号代码块。整个大括号代码块，包括最外面的一对括号，被作为字符串常量看待。括号里面的双引号字符不是特殊字符。因此，如果你在C代码中书写字符串常量，则不需要使用反斜杠来转义每个引号字符。

向量包含任意数目的指向表达式的指针。向量中元素的个数，在向量中显式的存在。向量的书写形式为，方括号（@samp{[@dots{}]}），里面是元素，并使用空格分隔。长度为0的向量不会被创建；而是使用空指针来替代。

@cindex expression codes
@cindex codes, RTL expression
@findex GET_CODE
@findex PUT_CODE
表达式根据@dfn{expression codes}来划分类别（也称作RTX代码）。表达式代码为在@file{rtl.def}中定义的一个名字，其也是一个（大写的）C枚举常量。合理的表达式代码以及它们的含义，是机器无关的。RTX的代码可以使用宏@code{GET_CODE (@var{x})}来抽取，以及使用@code{PUT_CODE (@var{x}, @var{newcode})}来修改。

表达式代码决定了表达式包含了多少个操作数，以及它们都是什么对象。在RTL中，不像Lisp，你不能通过查看一个操作数来得知它是什么对象。替代的，你必须通过它的上下文来知道——通过所包含的表达式的表达式代码。例如，在一个表达式代码为@code{subreg}的表达式中，第一个操作数被作为一个表达式，第二个操作数为一个整数。在代码为@code{plus}的表达式中，有两个操作数，都作为表达式。在@code{symbol_ref}表达式中，有一个操作数，作为一个字符串。

表达式被书写为，一对括号，包含了表达式类型的名字，它的标记和机器模式（如果存在的话），然后是表达式的操作数（通过空格分隔）。

表达式代码名，在@samp{md}文件中按小写形式书写，但在C代码中出现时按大写形式书写。在这个手册里，它们按照如下形式表示：@code{const_int}。

@cindex (nil)
@cindex nil
在一些上下文中，表达式通常会需要一个空指针。这种书写形式为@code{(nil)}。

@node RTL类别
@section RTL类别和格式
@cindex RTL classes
@cindex classes of RTX codes
@cindex RTX codes, classes of
@findex GET_RTX_CLASS

不同的表达式代码被分为几个类别（@dfn{classes}），其有单个字符表示。你可以使用宏@code{GET_RTX_CLASS (@var{code})}来确定RTX代码的类别。当前，@file{rtl.def}定义了这些类别：

@table @code
@item RTX_OBJ
一个RTX代码，表示一个实际的对象，例如一个寄存器(@code{REG})或者一个内存位置(@code{MEM}, @code{SYMBOL_REF})。也包括@code{LO_SUM})；但是，@code{SUBREG}和@code{STRICT_LOW_PART}不在这个类别中，而是在@code{x}类别中。

@item RTX_CONST_OBJ
一个RTX代码，表示一个常量对象。@code{HIGH}也包含在该类别中。

@item RTX_COMPARE
一个RTX代码，针对一个非对称的比较，例如@code{GEU}或@code{LT}。

@item RTX_COMM_COMPARE
一个RTX代码，针对一个对称（可交换）比较，例如，例如@code{EQ}或@code{ORDERED}。

@item RTX_UNARY
一个RTX代码，针对一元算术运算，例如@code{NEG}，@code{NOT}或者@code{ABS}。这个类别还包括值扩展（符号扩展或者零扩展），以及整数和浮点之间的转换。

@item RTX_COMM_ARITH
一个RTX代码，针对可交换的二元运算，例如@code{PLUS}或者@code{AND}。@code{NE}和@code{EQ}为比较运算，所以它们具有类别@code{<}。

@item RTX_BIN_ARITH
一个RTX代码，针对不可交换的二元运算，例如@code{MINUS}，@code{DIV}或者@code{ASHIFTRT}。

@item RTX_BITFIELD_OPS
一个RTX代码，针对位域运算。当前只有@code{ZERO_EXTRACT}和@code{SIGN_EXTRACT}。这些有三个输入，并且为左值。@xref{Bit-Fields}。

@item RTX_TERNARY
一个RTX代码，针对其它有三个输入的运算。当前只有@code{IF_THEN_ELSE}和@code{VEC_MERGE}。

@item RTX_INSN
一个RTX代码，针对整个指令：@code{INSN}，@code{JUMP_INSN}和@code{CALL_INSN}。@xref{Insns}。

@item RTX_MATCH
一个RTX代码，针对在insn中的一些匹配，例如@code{MATCH_DUP}。这些只出现在机器描述中。

@item RTX_AUTOINC
一个RTX代码，针对一个自动增量寻址模式，例如@code{POST_INC}。

@item RTX_EXTRA
所有其它的RTX代码。这个类别包括只在机器描述(@code{DEFINE_*}等)中使用的其它RTX代码。其还表示所有表述副作用的RTX代码（@code{SET}，@code{USE}，@code{CLOBBER}等），以及在insn链中可能出现的非insn，例如@code{NOTE}，@code{BARRIER}和@code{CODE_LABEL}。@code{SUBREG}也属于该类。

@end table

@cindex RTL format
对于每个表达式代码，@file{rtl.def}使用称作表达式代码格式（@dfn{format}）的字符序列，来说明所包含的对象数目，以及它们的种类。例如，@code{subreg}的格式为@samp{ei}。

@cindex RTL format characters
这些是最常用的格式字符：

@table @code
@item e
一个表达式（实际是一个表达式指针）

@item i
一个整数。

@item w
一个宽整数。

@item s
一个字符串。

@item E
一个表达式向量。
@end table

还有一些其它的格式字符有时会被用到：

@table @code
@item u
@samp{u}等价于@samp{e}，只不过是在调试转储中的打印有所区别。其用于insn指针。

@item n
@samp{n}等价于@samp{i}， 只不过是在调试转储中的打印有所区别。其用于@code{note} insn的行号和代码号。

@item S
@samp{S}表示一个可选的字符串。在内部的RTX对象中，@samp{S}等价于@samp{s}，但当对象从@samp{md}文件中读取的时候，该操作数的字符串值可以被忽略。被忽略的字符串被当作一个空字符串。

@item V
@samp{V}表示一个可选的向量。在内部的RTX对象中，@samp{V}等价于@samp{E}，但是当对象从@samp{md}文件中读取的时候，该操作数的向量值可以被忽略。被忽略的向量被当作一个没有元素的向量。 

@item B
@samp{B}表示一个指向基本块结构体的指针。

@item 0
@samp{0}表示一个插槽，其内容不使用任何常规的类别。@samp{0}插槽根本不在转储中打印，通常在编译器中用于特定的方式。
@end table

这些是获得操作数数目和表达式代码格式的宏：

@table @code
@findex GET_RTX_LENGTH
@item GET_RTX_LENGTH (@var{code})
代码为@var{code}的RTX的操作数个数。

@findex GET_RTX_FORMAT
@item GET_RTX_FORMAT (@var{code})
代码为@var{code}的RTX的格式，为C字符串。
@end table

一些RTX代码的类别总是具有相同的格式。例如，可以安全的假设所有的比较运算都具有格式@code{ee}。

@table @code
@item 1
所有该类别的代码都具有格式@code{e}。

@item <
@itemx c
@itemx 2
所有这些类别的代码都具有格式@code{ee}。

@item b
@itemx 3
所有这些类别的代码都具有格式@code{eee}。

@item i
所有该类别的代码具有的格式都起始于@code{iuueiee}。@xref{Insns}。注意，并不是所有被链接到insn链表中的RTX对象都属于类别@code{i}。

@item o
@itemx m
@itemx x
你可以不去假设这些代码的格式。
@end table

@node 访问方式
@section 访问操作数
@cindex accessors
@cindex access to operands
@cindex operand access

@findex XEXP
@findex XINT
@findex XWINT
@findex XSTR
表达式的操作数用宏@code{XEXP}、@code{XINT}、@code{XWINT}和@code{XSTR}访问。
所有这些宏都有两个参数：一个为表达式指针（RTX），
另一个为操作数序号 ( 从0 开始计算 )。如：

@smallexample
XEXP (@var{x}, 2)
@end smallexample

@noindent
表示以表达式方式访问表达式@var{x}的第2个操作数。

@smallexample
XINT (@var{x}, 2)
@end smallexample

@noindent
表示以整数方式访问@code{x}的第2个操作数。
@code{XSTR}表示以字符串方式访问。

任何一个操作数都能以整数方式、表达式方式或字符串方式来访问，
但必须根据存贮在操作数中的实际值选择正确的访问方式。
这可根据表达式的代码而获得，同样也可表达式代码获得操作数的个数。

例如：若@var{x}是@code{subreg}表达式，通过表达式代码可知它有二个操作数，
这两个操作数的访问应该是@code{XEXP (@var{x}, 0)} 和@code{XINT (@var{x}, 1)}，
若写成@code{XINT (@var{x}, 0)}，那么，你得到的表达式地址将被强制成整数，
偶尔可能会需要这样做，但在这种情况下用@code{(int) XEXP (@var{x}, 0)}表示要更好。
同样写成@code{XEXP (@var{x}, 1)} 也不会导致编译错误，
它将返回强制为表达式指针而实际为整数的1号操作数，在运行中访问该指针时，
这可能会导致出错。同样，你也可以写成@code{XEXP (@var{x}, 28)}，
但这超出了此表达式的存贮边界，所得到的将是一个预料不到的结果。

对向量操作数的访问较为复杂些，可用@code{XVEC}宏来获取向量指针本身，
@code{XVECEXP}和@code{XVECLEN}宏访问一个向量的元素和长度。

@table @code
@findex XVEC
@item XVEC (@var{exp}, @var{idx})
获得@var{exp}中第@var{idx}个操作数的向量指针。

@findex XVECLEN
@item XVECLEN (@var{exp}, @var{idx})
获得@var{exp}中第@var{idx}个操作数（为向量操作数）的向量长度（元素个数），
其值是@code{int}。

@findex XVECEXP
@item XVECEXP (@var{exp}, @var{idx}, @var{eltnum})
访问@var{exp}中第@var{idx}个操作数（为向量操作数）的第@var{eltnum}个元素，
其值是一个RTX。

需要由你来确保@var{eltnum}不为负，并且小于@code{XVECLEN (@var{exp}, @var{idx})}。
@end table

在本节中所定义的所有宏定义都被扩展成左值，
因而也可用于对操作数、长度和向量元素赋值。

@node 访问特殊操作数
@section 访问特殊操作数
@cindex access to special operands

一些RTL节点具有与它们相关联的特殊的注解。

@table @code
@item MEM
@table @code
@findex MEM_ALIAS_SET
@item MEM_ALIAS_SET (@var{x})
如果为0，则@var{x}不在任何别名集中，并可能为任何对象的别名。否则，@var{x}只能为在冲突别名集中的@code{MEM}的别名。该值在前端使用语言相关的方式来设置，并且不能在后端修改。在一些前端中，这些可以通过某种方式对应到类型，或者其它语言级的实体，但是不要求非要这样，所以在后端不要做这样的假设。这些集合编号使用@code{alias_sets_conflict_p}来测试。

@findex MEM_EXPR
@item MEM_EXPR (@var{x})
如果该寄存器被已知为存放了一些用户级的声明的值，则为那个tree节点。其也可以为@code{COMPONENT_REF}，这种情况下，其为某个域的引用，并且@code{TREE_OPERAND (@var{x}, 0)}包含了声明，或者另一个@code{COMPONENT_REF}，或者如果没有编译时对象相关引用，则为空。

@findex MEM_OFFSET
@item MEM_OFFSET (@var{x})
从@code{MEM_EXPR}起始的偏移量，为一个@code{CONST_INT} rtx。

@findex MEM_SIZE
@item MEM_SIZE (@var{x})
以字节为单位的内存引用长度，为一个@code{CONST_INT} rtx。这主要与@code{BLKmode}引用相关，否则机器模式已经隐含了长度。

@findex MEM_ALIGN
@item MEM_ALIGN (@var{x})
内存引用的已知的对齐方式，以位为单位。
@end table

@item REG
@table @code
@findex ORIGINAL_REGNO
@item ORIGINAL_REGNO (@var{x})
该域存放了寄存器原先具有的编号；对于伪寄存器放入到一个硬寄存器中，其将存放旧的伪寄存器编号。

@findex REG_EXPR
@item REG_EXPR (@var{x})
如果该寄存器被已知存放了某个用户级的声明的值，则其为那个tree节点。

@findex REG_OFFSET
@item REG_OFFSET (@var{x})
如果该寄存器被已知存放了某个用户级的声明的值，则其为相对那个逻辑存储的便宜量。

@end table

@item SYMBOL_REF
@table @code
@findex SYMBOL_REF_DECL
@item SYMBOL_REF_DECL (@var{x})
如果是针对@code{VAR_DECL}或@code{FUNCTION_DECL}创建的@code{symbol_ref} @var{x}，则那个tree被记录在这里。如果该值为空，则@var{x}由后端代码生成例程创建，并不与前端的符号表实体相关联。

@code{SYMBOL_REF_DECL}也可以指向@code{'c'}类别的tree，即某种常量。这种情况下，@code{symbol_ref}为每个文件的常量池中的实体；同样，不与前端的符号表实体相关联。

@findex SYMBOL_REF_CONSTANT
@item SYMBOL_REF_CONSTANT (@var{x})
如果@samp{CONSTANT_POOL_ADDRESS_P (@var{x})}为真，则为@var{x}的常量池实体。否则为空。

@findex SYMBOL_REF_DATA
@item SYMBOL_REF_DATA (@var{x})
一个不透明类型的域，用来存储@code{SYMBOL_REF_DECL}或@code{SYMBOL_REF_CONSTANT}。

@findex SYMBOL_REF_FLAGS
@item SYMBOL_REF_FLAGS (@var{x})
在一个@code{symbol_ref}中，其用于传达关于符号的各种断言。它们中的一些可以使用通用的代码来计算，一些是特定于目标机器的。通用的位：

@table @code
@findex SYMBOL_REF_FUNCTION_P
@findex SYMBOL_FLAG_FUNCTION
@item SYMBOL_FLAG_FUNCTION
用来表示符号引用一个函数。

@findex SYMBOL_REF_LOCAL_P
@findex SYMBOL_FLAG_LOCAL
@item SYMBOL_FLAG_LOCAL
用来表示符号局部于该模块。参见@code{TARGET_BINDS_LOCAL_P}。

@findex SYMBOL_REF_EXTERNAL_P
@findex SYMBOL_FLAG_EXTERNAL
@item SYMBOL_FLAG_EXTERNAL
用来表示该符号不在该转换单元中定义。注意，其并不是@code{SYMBOL_FLAG_LOCAL}的反转。

@findex SYMBOL_REF_SMALL_P
@findex SYMBOL_FLAG_SMALL
@item SYMBOL_FLAG_SMALL
用来表示符号位于小数据段。参见@code{TARGET_IN_SMALL_DATA_P}。

@findex SYMBOL_FLAG_TLS_SHIFT
@findex SYMBOL_REF_TLS_MODEL
@item SYMBOL_REF_TLS_MODEL (@var{x})
这是多个位的域访问，其返回用于线程局部存储符号的@code{tls_model}。对于非线程局部符号，其返回0。

@findex SYMBOL_REF_HAS_BLOCK_INFO_P
@findex SYMBOL_FLAG_HAS_BLOCK_INFO
@item SYMBOL_FLAG_HAS_BLOCK_INFO
用来表示符号具有@code{SYMBOL_REF_BLOCK}和@code{SYMBOL_REF_BLOCK_OFFSET}域。

@findex SYMBOL_REF_ANCHOR_P
@findex SYMBOL_FLAG_ANCHOR
@cindex @option{-fsection-anchors}
@item SYMBOL_FLAG_ANCHOR
用来表示符号作为section anchor。``Section anchors''为在@code{object_block}中具有一个已知位置的符号，并且可以用来访问该块中的附近成员。它们用来实现@option{-fsection-anchors}。

如果该标记被设置，则@code{SYMBOL_FLAG_HAS_BLOCK_INFO}也被设置。

@end table

起始于@code{SYMBOL_FLAG_MACH_DEP}的位，可供目标机器使用。
@end table

@findex SYMBOL_REF_BLOCK
@item SYMBOL_REF_BLOCK (@var{x})
如果@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}，则其为该符号所属的@samp{object_block}结构体， 或者如果其没有被分配给一个块，则为@code{NULL}。

@findex SYMBOL_REF_BLOCK_OFFSET
@item SYMBOL_REF_BLOCK_OFFSET (@var{x})
如果@samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}，则其为@var{x}的偏移量，从@samp{SYMBOL_REF_BLOCK (@var{x})}中的第一个对象开始。如果@var{x}还没有被分配给一个块，或者其还没有在那个块中给定一个偏移量，则值为负数。

@end table

@node 标记
@section RTL表达式中的标记
@cindex flags in RTL expression

RTL表达式包含几个标记（位域），用于特定类型的表达式。通常它们使用下列的宏来访问，并被扩展为左值。

@table @code
@findex CONSTANT_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/u}
@cindex @code{unchanging}, in @code{symbol_ref}
@item CONSTANT_POOL_ADDRESS_P (@var{x})
位于@code{symbol_ref}中，如果其引用了当前函数的常量池中的一部分，则非零。对于大多数目标机器，这些地址在@code{.rodata}段中，与函数完全分离，但是对于有些目标机器，这些地址是靠近函数起始处。不管哪种情况，GCC都假设这些地址可以被直接寻址，或者通过基址寄存器。其被存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex RTL_CONST_CALL_P
@cindex @code{call_insn} and @samp{/u}
@cindex @code{unchanging}, in @code{call_insn}
@item RTL_CONST_CALL_P (@var{x})
位于@code{call_insn}中，表明该insn表示一个对const函数的调用。存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex RTL_PURE_CALL_P
@cindex @code{call_insn} and @samp{/i}
@cindex @code{return_val}, in @code{call_insn}
@item RTL_PURE_CALL_P (@var{x})
位于@code{call_insn}中，表明该insn表示一个对pure函数的调用。存储在@code{return_val}域，打印输出为@samp{/i}。

@findex RTL_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/u} or @samp{/i}
@item RTL_CONST_OR_PURE_CALL_P (@var{x})
位于@code{call_insn}中，如果@code{RTL_CONST_CALL_P}或者@code{RTL_PURE_CALL_P}为真，则其为真。

@findex RTL_LOOPING_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/c}
@cindex @code{call}, in @code{call_insn}
@item RTL_LOOPING_CONST_OR_PURE_CALL_P (@var{x})
位于@code{call_insn}中，表明该insn表示一个对const或者pure函数，可能是无限循环的调用。存储在@code{call}域，打印输出为@samp{/c}。只有当@code{RTL_CONST_CALL_P}或者@code{RTL_PURE_CALL_P}为真时，其才为真。

@findex INSN_ANNULLED_BRANCH_P
@cindex @code{jump_insn} and @samp{/u}
@cindex @code{call_insn} and @samp{/u}
@cindex @code{insn} and @samp{/u}
@cindex @code{unchanging}, in @code{jump_insn}, @code{call_insn} and @code{insn}
@item INSN_ANNULLED_BRANCH_P (@var{x})
位于@code{jump_insn}，@code{call_insn}或者@code{insn}中，表明该分支跳转被取消。参见下面关于@code{sequence}的讨论。存储在@code{unchanging}域，打印输出为@samp{/u}。

@findex INSN_DELETED_P
@cindex @code{insn} and @samp{/v}
@cindex @code{call_insn} and @samp{/v}
@cindex @code{jump_insn} and @samp{/v}
@cindex @code{code_label} and @samp{/v}
@cindex @code{barrier} and @samp{/v}
@cindex @code{note} and @samp{/v}
@cindex @code{volatil}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{barrier}, and @code{note}
@item INSN_DELETED_P (@var{x})
位于@code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{barrier}或@code{note}中，如果该insn被删除掉，则非零。存储在@code{volatil}域，打印输出为@samp{/v}。

@findex INSN_FROM_TARGET_P
@cindex @code{insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn} and @code{jump_insn} and @code{call_insn}
@item INSN_FROM_TARGET_P (@var{x})
位于@code{insn}，@code{jump_insn}或者@code{call_insn}中，在分支延迟槽中，表明该insn是来自分支跳转的目标。如果分支insn设置了@code{INSN_ANNULLED_BRANCH_P}，则该insn只有当进行分支跳转的时候，才被执行。对于被取消的分支，如果是清除了@code{INSN_FROM_TARGET_P}，则insn只有当没有进行分支跳转的时候，才被执行。当@code{INSN_ANNULLED_BRANCH_P}没有被设置，该insn将总是被执行。存储在@code{in_struct}域，打印输出为@samp{/s}。

@findex LABEL_PRESERVE_P
@cindex @code{code_label} and @samp{/i}
@cindex @code{note} and @samp{/i}
@cindex @code{in_struct}, in @code{code_label} and @code{note}
@item LABEL_PRESERVE_P (@var{x})
位于@code{code_label}或者@code{note}中，表明被代码或者数据引用的该标号，对于给定的函数RTL不可见。通过非局部goto引用的标号，将设置该位。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex LABEL_REF_NONLOCAL_P
@cindex @code{label_ref} and @samp{/v}
@cindex @code{reg_label} and @samp{/v}
@cindex @code{volatil}, in @code{label_ref} and @code{reg_label}
@item LABEL_REF_NONLOCAL_P (@var{x})
位于@code{label_ref}和@code{reg_label}表达式中，如果其为对一个非局部标号的引用，则非零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex MEM_IN_STRUCT_P
@cindex @code{mem} and @samp{/s}
@cindex @code{in_struct}, in @code{mem}
@item MEM_IN_STRUCT_P (@var{x})
位于@code{mem}表达式中，对于引用一整个结构体，联合体，数组，或者是它们的一部分，则非零。如果是引用一个标量变量，或者是标量指针，则为零。如果该标记和@code{MEM_SCALAR_P}都被清除，则我们无法知道该@code{mem}是否在一个结构体中。这两个标记不要被同时设置。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex MEM_KEEP_ALIAS_SET_P
@cindex @code{mem} and @samp{/j}
@cindex @code{jump}, in @code{mem}
@item MEM_KEEP_ALIAS_SET_P (@var{x})
位于@code{mem}表达式中，如果为1，则表明当访问一个部件时，应该保持该mem的别名集合不变。例如，当在一个聚合体的不可寻址部件中的时候，将其设为1。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex MEM_SCALAR_P
@cindex @code{mem} and @samp{/i}
@cindex @code{return_val}, in @code{mem}
@item MEM_SCALAR_P (@var{x})
位于@code{mem}表达式中，如果引用的标量，被已知不是结构体，联合体或者数组的成员，则为非零。如果是这样的引用，或者通过指针的间接引用，即便是指向标量类型，则为零，如果该标记和@code{MEM_IN_STRUCT_P}都被清除，则我们无法知道该@code{mem}是否为一个结构体。这两个标记不要被同时设置。存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex MEM_VOLATILE_P
@cindex @code{mem} and @samp{/v}
@cindex @code{asm_input} and @samp{/v}
@cindex @code{asm_operands} and @samp{/v}
@cindex @code{volatil}, in @code{mem}, @code{asm_operands}, and @code{asm_input}
@item MEM_VOLATILE_P (@var{x})
位于@code{mem}, @code{asm_operands}和@code{asm_input}表达式中，对于volatile内存引用，为非零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex MEM_NOTRAP_P
@cindex @code{mem} and @samp{/c}
@cindex @code{call}, in @code{mem}
@item MEM_NOTRAP_P (@var{x})
位于@code{mem}中，对于不会产生陷阱的内存引用，为非零。存储在@code{call}域中，打印输出为@samp{/c}。

@findex MEM_POINTER
@cindex @code{mem} and @samp{/f}
@cindex @code{frame_related}, in @code{mem}
@item MEM_POINTER (@var{x})
位于@code{mem}中，如果内存引用存放了一个指针，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex REG_FUNCTION_VALUE_P
@cindex @code{reg} and @samp{/i}
@cindex @code{return_val}, in @code{reg}
@item REG_FUNCTION_VALUE_P (@var{x})
位于@code{reg}中，如果其为存放函数返回值的地方，则非零。（这只发生在硬件寄存器中。）存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex REG_POINTER
@cindex @code{reg} and @samp{/f}
@cindex @code{frame_related}, in @code{reg}
@item REG_POINTER (@var{x})
位于@code{reg}中，如果寄存器存放一个指针，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex REG_USERVAR_P
@cindex @code{reg} and @samp{/v}
@cindex @code{volatil}, in @code{reg}
@item REG_USERVAR_P (@var{x})
位于@code{reg}中，如果其对应于用户源代码中出现的一个变量，则非零。对于编译器内部生成的临时对象，则为零。存储在@code{volatil}域中，打印输出为@samp{/v}。

@findex RTX_FRAME_RELATED_P
@cindex @code{insn} and @samp{/f}
@cindex @code{call_insn} and @samp{/f}
@cindex @code{jump_insn} and @samp{/f}
@cindex @code{barrier} and @samp{/f}
@cindex @code{set} and @samp{/f}
@cindex @code{frame_related}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, and @code{set}
@item RTX_FRAME_RELATED_P (@var{x})
位于@code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, 或者@code{set}中，如果其为函数序言的一部分，用来设置栈指针，帧指针，或者保存寄存器，则为非零。对于设置用于帧指针的临时寄存器的指令，该标记也应被设置。存储在@code{frame_related}域中，打印输出为@samp{/f}。

特别的，在一些RISC目标机器上，对于立即数常量的大小有限制，有时不能直接通过栈指针来到达寄存器的保存区域。这种情况下，一个足够接近寄存器保存区域的临时寄存器被使用，并且正则帧地址（Canonical Frame Address）寄存器，即DWARF2的逻辑帧指针寄存器，必须（临时的）被改成该临时寄存器。所以，设置该临时寄存器的指令必须被标记为@code{RTX_FRAME_RELATED_P}。

如果被标记的指令过于复杂（跟据@code{dwarf2out_frame_debug_expr}能否处理，而定义的术语），则你还必须要创建一个@code{REG_FRAME_RELATED_EXPR}注解，并附加在该指令上。该注解应该包含一个该指令执行计算的简单表达式，即@code{dwarf2out_frame_debug_expr}可以处理的。

在带有RTL序言的目标机器上，提供异常处理的支持时，会用到该标记。

@findex MEM_READONLY_P
@cindex @code{mem} and @samp{/u}
@cindex @code{unchanging}, in @code{mem}
@item MEM_READONLY_P (@var{x})
位于@code{mem}中，如果内存是静态分配并且只读的，则非零。 

在该上下文中只读，意味着在程序的生命周期中不会被修改，但是不必要是在ROM或者不可写的页中。对于后者，一个常见的例子，是共享库的全局偏移表。该表由运行时加载器初始化，所以内存在技术上是可写的，但是当控制从运行时加载器转移给应用程序时，该内存将不再被修改。

存储在@code{unchanging}域中，打印输出为@samp{/u}。

@findex SCHED_GROUP_P
@cindex @code{insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn}, @code{jump_insn} and @code{call_insn}
@item SCHED_GROUP_P (@var{x})
在指令调度过程中，位于@code{insn}, @code{call_insn}或者@code{jump_insn}中，表明前一个insn必须与该insn一起调度。这用来确保特定的指令组不会被指令调度过程分隔开。例如，在@code{call_insn}之前的@code{use} insn不可以从@code{call_insn}中分开。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex SET_IS_RETURN_P
@cindex @code{insn} and @samp{/j}
@cindex @code{jump}, in @code{insn}
@item SET_IS_RETURN_P (@var{x})
对于@code{set}，如果是针对一个return，则非零。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex SIBLING_CALL_P
@cindex @code{call_insn} and @samp{/j}
@cindex @code{jump}, in @code{call_insn}
@item SIBLING_CALL_P (@var{x})
对于@code{call_insn}，如果该insn为一个sibling call，则非零。存储在@code{jump}域中，打印输出为@samp{/j}。

@findex STRING_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/f}
@cindex @code{frame_related}, in @code{symbol_ref}
@item STRING_POOL_ADDRESS_P (@var{x})
对于一个@code{symbol_ref}表达式，如果其为对该函数的字符串常量池的寻址，则非零。存储在@code{frame_related}域中，打印输出为@samp{/f}。

@findex SUBREG_PROMOTED_UNSIGNED_P
@cindex @code{subreg} and @samp{/u} and @samp{/v}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_P (@var{x})
如果@code{subreg}对于@code{SUBREG_PROMOTED_VAR_P}为非零，并且被引用的对象为零扩展，则返回一个大于零的值；如果保持为符号扩展，则为零；如果是通过@code{ptr_extend}指令，进行某种其它方式的扩展，则小于零。存储在@code{unchanging}域和@code{volatil}域中，打印输出为@samp{/u}和@samp{/v}。该宏只用于获得值，不能用于修改值。使用@code{SUBREG_PROMOTED_UNSIGNED_SET}来修改值。

@findex SUBREG_PROMOTED_UNSIGNED_SET
@cindex @code{subreg} and @samp{/u}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_SET (@var{x})
设置@code{subreg}中的@code{unchanging}和@code{volatil}域，来反映零扩展，符号扩展，或其它扩展。如果@code{volatil}为零，然后如果@code{unchanging}为非零，则意味着零扩展，如果为零，则意味着符号扩展。如果@code{volatil}为非零，则通过@code{ptr_extend}指令使用了其它某种扩展。

@findex SUBREG_PROMOTED_VAR_P
@cindex @code{subreg} and @samp{/s}
@cindex @code{in_struct}, in @code{subreg}
@item SUBREG_PROMOTED_VAR_P (@var{x})
位于@code{subreg}中，如果当访问一个被提升为符合机器描述宏@code{PROMOTED_MODE}的(@pxref{Storage Layout})，宽机器模式的对象时，则非零。这种情况下，@code{subreg}的机器模式为对象被声明的机器模式，@code{SUBREG_REG}的机器模式为存放该对象的寄存器的机器模式。被提升的变量，在每个赋值中，总是被符号扩展或者零扩展成宽机器模式。存储在@code{in_struct}域中，打印输出为@samp{/s}。

@findex SYMBOL_REF_USED
@cindex @code{used}, in @code{symbol_ref}
@item SYMBOL_REF_USED (@var{x})
位于@code{symbol_ref}中，表明@var{x}已经被使用。这通常只用于确保@var{x}只在外部被声明一次。存储在@code{used}中。

@findex SYMBOL_REF_WEAK
@cindex @code{symbol_ref} and @samp{/i}
@cindex @code{return_val}, in @code{symbol_ref}
@item SYMBOL_REF_WEAK (@var{x})
位于@code{symbol_ref}中，表明@var{x}已经被声明为weak。存储在@code{return_val}域中，打印输出为@samp{/i}。

@findex SYMBOL_REF_FLAG
@cindex @code{symbol_ref} and @samp{/v}
@cindex @code{volatil}, in @code{symbol_ref}
@item SYMBOL_REF_FLAG (@var{x})
位于@code{symbol_ref}中，用于机器特定目的的标记。存储在@code{volatil}域中，打印输出为@samp{/v}。

大多对@code{SYMBOL_REF_FLAG}的使用，是历史性的，并且可以通过@code{SYMBOL_REF_FLAGS}来归类。当然，如果目标机器需要多于一个位的存储时，对@code{SYMBOL_REF_FLAGS}的使用是强制的。

@end table

这些是上面的宏所引用的域：

@table @code
@findex call
@cindex @samp{/c} in RTL dump
@item call
在@code{mem}中，1表示该内存引用不会有陷阱。

在@code{call}中，1表示该pure或者const调用，可能为无限循环。

在RTL转储中，该标记被表示为@samp{/c}。

@findex frame_related
@cindex @samp{/f} in RTL dump
@item frame_related
在@code{insn}或者@code{set}表达式中，1表示其为函数序言的一部分，设置栈寄存器，设置帧寄存器，保存寄存器，或者设置一个用于帧寄存器的临时寄存器。

在@code{reg}表达式中，1表示该寄存器存放一个指针。

在@code{mem}表达式中，1表示该内存引用存放一个指针。

在@code{symbol_ref}表达式中，1表示该引用是对函数的字符串常量池的寻址。

在RTL转储中，该标记被表示为@samp{/f}。

@findex in_struct
@cindex @samp{/s} in RTL dump
@item in_struct
在@code{mem}表达式中，如果所引用的内存数据为整个结构体或者数组，或者一部分，其为1；如果为（或者可能为）一个标量变量。则为0。通过C指针的引用，为0，因为指针可以指向一个标量变量。该信息允许编译器来确定别名的可能情况。

在@code{reg}表达式中，如果寄存器整个生命期都包含在某个循环的测试表达式中，则为1。

在@code{subreg}表达式中，1表示@code{subreg}在访问一个从更宽的机器模式进行提升的对象。

在@code{label_ref}表达式中，1表示被引用的标号位于包含发现@code{label_ref}的insn的最内层循环的外面。

在@code{code_label}表达式中，如果标号不能被删除，则为1。这用于其为非局部goto的目标的标号。对于已经被删除的这样的标号，使用类型为@code{NOTE_INSN_DELETED_LABEL}的@code{note}来替换。

在@code{insn}中，在死代码消除阶段，1表示该insn为死代码。

在@code{insn}或者@code{jump_insn}中，在针对分支延迟槽中insn的reorg阶段，1表示该insn来自分支跳转的目标。

在@code{insn}中，在指令调度阶段，1表示该insn必须与之前的insn一起进行调度。

在RTL转储中，该标记被表示为@samp{/s}。

@findex return_val
@cindex @samp{/i} in RTL dump
@item return_val
在@code{reg}表达式中，1表示寄存器包含了当且函数的返回值。对于在寄存器中传递参数的机器上，同一个寄存器编号也可以被用作参数，但是这种情况下，该标记不被设置。

在@code{mem}中，1表示内存引用为一个已知不为结构体，联合体，数组的成员的标量。

在@code{symbol_ref}表达式中，1表示被引用的符号为weak。

在@code{call}表达式中，1表示调用是pure。

在RTL转储中，该标记被表示为@samp{/i}。

@findex jump
@cindex @samp{/j} in RTL dump
@item jump
在@code{mem}表达式中，1表示当访问一个部件时，应该保持该mem的别名集不变。

在@code{set}中，1表示其为一个return。

在@code{call_insn}中，1表示其为一个sibling call。

在RTL转储中，该标记被表示为@samp{/j}。

@findex unchanging
@cindex @samp{/u} in RTL dump
@item unchanging
在@code{reg}和@code{mem}表达式中，1表示表达式的值不会改变。

在@code{subreg}表达式中，如果@code{subreg}引用了机器模式已经被提升为一个宽模式的无符号对象，则为1。 references an

在分支指令延迟槽中的@code{insn}或@code{jump_insn}中，1表示将使用一个被取消的分支。

在@code{symbol_ref}表达式中，1表示该符号对函数的常量池进行寻址。

在@code{call_insn}中，1表示该指令为对const函数的调用。

在RTL转储中，该标记被表示为@samp{/u}。

@findex used
@item used
该标记在函数的RTL生成阶段的结尾被直接使用（不通过访问宏），来计数表达式在insns中出现的次数。出现次数大于一的表达式，根据共享结构的规则（@pxref{Sharing}），被复制。

对于@code{reg}，其被叶子寄存器重编号代码直接使用（不通过访问宏），来确保每个寄存器只被重编号一次。

在@code{symbol_ref}中，其表示该符号的外部声明已经被书写了。

@findex volatil
@cindex @samp{/v} in RTL dump
@item volatil
@cindex volatile memory references
在@code{mem}, @code{asm_operands}或者@code{asm_input}表达式中，如果内存引用是volatile的，则为1。volatile的内存引用不可以被删除，重排或者合并。

在@code{symbol_ref}表达式中，其用于机器特定的目的。

在@code{reg}表达式中，如果值为用户级的变量，则为1。0表示为内部的编译器临时对象。

在@code{insn}中，1表示该insn已经被删除。

在@code{label_ref}和@code{reg_label}表达式中，1表示对非局部标号的引用。

在RTL转储中，该标记被表示为@samp{/v}。
@end table

@node 机器模式
@section 机器模式
@cindex machine modes

@findex enum machine_mode
机器模式描述数据对象的大小及其表示。在C 代码中，机器模式表示成枚举类型@code{enum machine_mode}。此类型定义在@file{machmode.def}中。每个RTL表达式都有机器模式域。一些树结构如变量定义、类型等也有机器模式域。

在调试信息及机器描述中，RTL表达式的机器模式紧跟在RTL 代码之后，其间用冒号隔开。每一种机器模式名未尾的字母省缺为@samp{mode}。例如：@code{(reg:SI 38)}是一个@code{reg}表达式，其机器模式为@code{SImode}。如果方式为@code{VOIDmode}，表达式中完全不出现此模式。

以下是一个机器模式表，这里的“字节”是指具有@code{BITS_PER_UNIT}个存储位的对象
（@pxref{Storage Layout}）。

@table @code
@findex BImode
@item BImode
“Bit”模式，表示一位，用于断言寄存器。

@findex QImode
@item QImode
“Quarter-Integer”模式，表示一个一字节的整数。

@findex HImode
@item HImode
“Half-Integer”模式，表示一个两字节的整数。

@findex PSImode
@item PSImode
“Partial Single Integer”模式，表示一个占有四个字节但并不真正使用全部四个字节的整数。

@findex SImode
@item SImode
“Single Integer”模式，表示一个四字节的整数。

@findex PDImode
@item PDImode
“Partial Double Integer”模式，表示一个占有八个字节但并不真正使用全部八个字节的整数。

@findex DImode
@item DImode
“Double Integer”模式，表示一个8 字节的整数。

@findex TImode
@item TImode
“Tetra Integer”模式，表示一个16 字节的整数。

@findex OImode
@item OImode
“Octa Integer” 模式，表示一个32 字节的整数。

@findex QFmode
@item QFmode
“Quarter-Floating” 模式，表示一个四分之一精度（单字节）浮点数。

@findex HFmode
@item HFmode
“Half-Floating” 模式，表示一个二分之一精度（双字节）浮点数。

@findex TQFmode
@item TQFmode
“Three-Quarter-Floating” 模式，表示一个四分之三精度（单字节）浮点数。

@findex SFmode
@item SFmode
“Single Floating”模式，表示一个单精度（4 个字节）浮点数。

@findex DFmode
@item DFmode
“Double Floating”模式，表示一个双精度（8 字节）浮点数。


@findex XFmode
@item XFmode
“Extended Floating”模式，表示一个三精度（12 字节）浮点数。本方式用来表示 IEEE 扩展浮点类型。

@findex SDmode
@item SDmode
``Single Decimal Floating''模式，表示一个四字节十进制浮点数（区别于常规的二进制浮点）。

@findex DDmode
@item DDmode
``Double Decimal Floating''模式，表示一个八字节十进制浮点数。

@findex TDmode
@item TDmode
``Tetra Decimal Floating''模式，表示一个十六字节十进制浮点数，所有128位都有含义。

@findex TFmode
@item TFmode
“Tetra Floating”模式，表示一个四精度（16 字节）浮点数。

@findex QQmode
@item QQmode
``Quarter-Fractional''模式，表示一个单字节的有符号小数。缺省格式为``s.7''。

@findex HQmode
@item HQmode
``Half-Fractional''模式，表示一个双字节的有符号小数。缺省格式为``s.15''。

@findex SQmode
@item SQmode
``Single Fractional''模式，表示一个四字节的有符号小数。缺省格式为``s.31''。

@findex DQmode
@item DQmode
``Double Fractional''模式，表示一个八字节的有符号小数。缺省格式为``s.63''。

@findex TQmode
@item TQmode
``Tetra Fractional''模式，表示一个十六字节有符号小数。缺省格式为``s.127''。

@findex UQQmode
@item UQQmode
``Unsigned Quarter-Fractional''模式，表示一个单字节的无符号小数。缺省格式为``.8''。

@findex UHQmode
@item UHQmode
``Unsigned Half-Fractional''模式，表示一个双字节的无符号小数。缺省格式为``.16''。

@findex USQmode
@item USQmode
``Unsigned Single Fractional''模式，表示一个四字节的无符号小数。缺省格式为``.32''。

@findex UDQmode
@item UDQmode
``Unsigned Double Fractional''模式，表示一个八字节的无符号小数。缺省格式为``.64''。

@findex UTQmode
@item UTQmode
``Unsigned Tetra Fractional''模式，表示一个十六字节的无符号小数。缺省格式为``.128''。

@findex HAmode
@item HAmode
``Half-Accumulator''模式，表示一个双字节的有符号累加器。缺省格式为``s8.7''。

@findex SAmode
@item SAmode
``Single Accumulator''模式，表示一个四字节的有符号累加器。缺省格式为``s16.15''。

@findex DAmode
@item DAmode
``Double Accumulator''模式，表示一个八字节的有符号累加器。缺省格式为``s32.31''。

@findex TAmode
@item TAmode
``Tetra Accumulator''模式，表示一个十六字节的有符号累加器。缺省格式为``s64.63''。

@findex UHAmode
@item UHAmode
``Unsigned Half-Accumulator''模式，表示一个双字节的无符号累加器。缺省格式为``8.8''。

@findex USAmode
@item USAmode
``Unsigned Single Accumulator''模式，表示一个四字节的无符号累加器。缺省格式为``16.16''。

@findex UDAmode
@item UDAmode
``Unsigned Double Accumulator''模式，表示一个八字节的无符号累加器。缺省格式为``32.32''。

@findex UTAmode
@item UTAmode
``Unsigned Tetra Accumulator''模式，表示一个十六字节的无符号累加器。缺省格式为``64.64''。

@findex CCmode
@item CCmode
“condition code”模式，表示条件代码的值。其中条件代码是一组与机器相关的位集合，用来表示比较的结果。在使用了 cc0 的机器上，不用CCmode。

@findex BLKmode
@item BLKmode
“Block”模式，表示其它模式都不适用的聚合值。在 RTL 中，只有内存引用才能有此方式，并且仅当出现在字符串移动指令或向量指令中时，才能有此方式。若机器没有上述指令，则@code{BLKmode}将不出现在 RTL中。

@findex VOIDmode
@item VOIDmode
意味着模式不出现或一个不确定的模式。例 如：@code{const_int}表达式的模式就是@code{VOIDmode}， 因为此类表达式可认为具有其上下文所要求的任何模式。在RTL的调试输出中，@code{VOIDmode}表示成没有任何模式出现。

@findex QCmode
@findex HCmode
@findex SCmode
@findex DCmode
@findex XCmode
@findex TCmode
@item QCmode, HCmode, SCmode, DCmode, XCmode, TCmode
这些方式模式由一对浮点数组成的复数。其中， 浮点数分别具有@code{QFmode}、@code{HFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}。

@findex CQImode
@findex CHImode
@findex CSImode
@findex CDImode
@findex CTImode
@findex COImode
@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
这些模式代表由一对整数组成的复数。整数值分别具有方式@code{QImode}, @code{HImode},@code{SImode}, @code{DImode}, @code{TImode}和@code{OImode}。

@end table

机器描述定义@code{Pmode}为一个C宏，其扩展为用于寻址的机器模式。通常这是一个在32位机器上，大小为@code{BITS_PER_WORD}, @code{SImode}模式。

机器描述唯一必须要支持的机器模式为@code{QImode}，以及对应于@code{BITS_PER_WORD}，@code{FLOAT_TYPE_SIZE}和@code{DOUBLE_TYPE_SIZE}的机器模式。编译器将尝试使用@code{DImode}，表示8字节的结构体和联合体，不过这可以通过重写@code{MAX_FIXED_MODE_SIZE}的定义来阻止。替换的，你可以让编译器使用@code{TImode}表示16字节的结构体和联合体。同样，你可以使得C类型@code{short int}避免使用@code{HImode}。

@cindex mode classes
编译器中，有很少的对机器模式显式的引用，并且这些引用将不久被移除掉。替代的，机器模式被分成机器模式类别。这些由定义在@file{machmode.h}中的枚举类型@code{enum mode_class}来表示。可能的机器类别有：

@table @code
@findex MODE_INT
@item MODE_INT
整数模式。缺省情况下，它们是@code{BImode}, @code{QImode}, @code{HImode}, @code{SImode}, @code{DImode}, @code{TImode}和@code{OImode}。

@findex MODE_PARTIAL_INT
@item MODE_PARTIAL_INT
部分整数模式，@code{PQImode}, @code{PHImode}, @code{PSImode}和@code{PDImode}。

@findex MODE_FLOAT
@item MODE_FLOAT
浮点模式。缺省情况下，这些是@code{QFmode}, @code{HFmode}, @code{TQFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}和@code{TFmode}。

@findex MODE_DECIMAL_FLOAT
@item MODE_DECIMAL_FLOAT
十进制浮点模式。缺省的，这些是@code{SDmode}, @code{DDmode}和@code{TDmode}。

@findex MODE_FRACT
@item MODE_FRACT
有符号小数模式。缺省的，这些是@code{QQmode}, @code{HQmode}, @code{SQmode}, @code{DQmode}和@code{TQmode}。

@findex MODE_UFRACT
@item MODE_UFRACT
无符号小数模式。缺省的，这些是@code{UQQmode}, @code{UHQmode}, @code{USQmode}, @code{UDQmode}和@code{UTQmode}。

@findex MODE_ACCUM
@item MODE_ACCUM
有符号累加器模式。缺省的，这些@code{HAmode}, @code{SAmode}, @code{DAmode}和@code{TAmode}。

@findex MODE_UACCUM
@item MODE_UACCUM
无符号累加器模式。缺省的，这些是@code{UHAmode}, @code{USAmode}, @code{UDAmode}和@code{UTAmode}。

@findex MODE_COMPLEX_INT
@item MODE_COMPLEX_INT
复数整数模式。（当前还没有被实现。）

@findex MODE_COMPLEX_FLOAT
@item MODE_COMPLEX_FLOAT
复数浮点模式。缺省情况下，为@code{QCmode}, @code{HCmode}, @code{SCmode}, @code{DCmode}, @code{XCmode}和@code{TCmode}。

@findex MODE_FUNCTION
@item MODE_FUNCTION
Algol或者Pascal函数变量，包括一个静态链。（这些目前还没有被实现。）

@findex MODE_CC
@item MODE_CC
表示条件码的值的模式。为@code{CCmode}加上在@file{@var{machine}-modes.def}中列出的任何@code{CC_MODE}模式。@xref{Jump Patterns}，同时参见@ref{Condition Code}。

@findex MODE_RANDOM
@item MODE_RANDOM
这是所有不适合上面的类别的模式。目前@code{VOIDmode}和@code{BLKmode}包括在@code{MODE_RANDOM}中。

@end table

这些是与机器模式相关的C宏：

@table @code
@findex GET_MODE
@item GET_MODE (@var{x})
返回RTX @var{x}的机器模式。

@findex PUT_MODE
@item PUT_MODE (@var{x}, @var{newmode})
将RTX @var{x}的机器模式修改为@var{newmode}。

@findex NUM_MACHINE_MODES
@item NUM_MACHINE_MODES
表示目标机器上可用的机器模式的个数。比最大的机器模式数值大1。

@findex GET_MODE_NAME
@item GET_MODE_NAME (@var{m})
返回机器模式@var{m}的字符串名字。

@findex GET_MODE_CLASS
@item GET_MODE_CLASS (@var{m})
返回机器模式@var{m}的类别。

@findex GET_MODE_WIDER_MODE
@item GET_MODE_WIDER_MODE (@var{m})
返回下一个宽的自然的机器模式。例如，表达式@code{GET_MODE_WIDER_MODE (QImode)}返回@code{HImode}。

@findex GET_MODE_SIZE
@item GET_MODE_SIZE (@var{m})
返回机器模式@var{m}的字节数。

@findex GET_MODE_BITSIZE
@item GET_MODE_BITSIZE (@var{m})
返回机器模式@var{m}位数。

@findex GET_MODE_IBIT
@item GET_MODE_IBIT (@var{m})
返回定点机器模式@var{m}的整数位数。

@findex GET_MODE_FBIT
@item GET_MODE_FBIT (@var{m})
返回定点机器模式@var{m}的小数位数。

@findex GET_MODE_MASK
@item GET_MODE_MASK (@var{m})
返回一个位掩码。该宏只能用于位长度小于或等于@code{HOST_BITS_PER_INT}的机器模式。

@findex GET_MODE_ALIGNMENT
@item GET_MODE_ALIGNMENT (@var{m})
对于模式为@var{m}的对象，返回所要求的对齐方式，以位数为单位。

@findex GET_MODE_UNIT_SIZE
@item GET_MODE_UNIT_SIZE (@var{m})
返回模式为@var{m}的数据的子单元大小，以字节为单位。这与@code{GET_MODE_SIZE}相同，除了复数模式。对于它们，单元大小为实部或者虚部的大小。

@findex GET_MODE_NUNITS
@item GET_MODE_NUNITS (@var{m})
返回在一个模式中包含的单元数目，即@code{GET_MODE_UNIT_SIZE}除以@code{GET_MODE_SIZE}。

@findex GET_CLASS_NARROWEST_MODE
@item GET_CLASS_NARROWEST_MODE (@var{c})
返回机器模式类别@var{c}中的最窄的模式。
@end table

@findex byte_mode
@findex word_mode
全局变量@code{byte_mode}和@code{word_mode}包含了类别为@code{MODE_INT}，并且位大小分别是@code{BITS_PER_UNIT}或@code{BITS_PER_WORD}的机器模式。在32位机器上，这些分别是@code{QImode}和@code{SImode}。

@node 常数
@section 常量表达式类型
@cindex RTL constants
@cindex RTL constant expression types

最简单的RTL表达式是那些对常数值的表示。

@table @code
@findex const_int
@item (const_int @var{i})
这类表达式表示整数值@var{i}。@var{i}通常通过宏@code{INTVAL}来访问，@code{INTVAL (@var{exp})}相当于@code{XWINT (@var{exp}, 0)}， 
为模式所生成的常量如果位数小于@code{HOST_WIDE_INT}，则必须符号扩展为全部宽度（例如，@code{gen_int_mode}）。

@findex const0_rtx
@findex const1_rtx
@findex const2_rtx
@findex constm1_rtx
只有一个表达式对象表示整数值0；是变量@code{const0_rtx}的值。同样的，整数值1的唯一表达式为@code{const1_rtx}，整数值2的唯一表达式为@code{const2_rtx}，负1的唯一表达式为@code{constm1_rtx}。任何试图去创建值为0，1，2或者-1的@code{const_int}都会返回相应的@code{const0_rtx}, @code{const1_rtx}, @code{const2_rtx}或者@code{constm1_rtx}。

@findex const_true_rtx
类似的，只有一个对象表示值为@code{STORE_FLAG_VALUE}的整数，其为@code{const_true_rtx}。如果@code{STORE_FLAG_VALUE}为1，则@code{const_true_rtx}和@code{const1_rtx}将会指向同一对象。如果@code{STORE_FLAG_VALUE}为-1，@code{const_true_rtx}和@code{constm1_rtx}将会指向同一对象。

@findex const_double
@item (const_double:@var{m} @var{i0} @var{i1} @dots{})
表示或者为一个模式为@var{m}的浮点常量，或者为一个超过@code{HOST_BITS_PER_WIDE_INT}位的，但是小于其两倍的位数的整数常量（GCC并没有提供表示更大的常量的机制）。对于后者，@var{m}将为@code{VOIDmode}。 

@findex CONST_DOUBLE_LOW
如果@var{m}为@code{VOIDmode}，则值的位数存储在@var{i0}和@var{i1}中。@var{i0}使用宏@code{CONST_DOUBLE_LOW}来访问，@var{i1}使用@code{CONST_DOUBLE_HIGH}。

如果常量为浮点（不管是什么精度），则用于存储值得整数数目取决于@code{REAL_VALUE_TYPE}的大小（@pxref{Floating Point}）。整数表示一个浮点数，但是不如target机器的或者host机器的浮点格式那么精确。要将它们转换为target机器使用的精确的位模式，使用宏@code{REAL_VALUE_TO_TARGET_DOUBLE}等（@pxref{Data Output}）。

@findex const_fixed
@item (const_fixed:@var{m} @dots{})
表示一个机器模式为@var{m}定点常量。操作数是一个类型为@code{struct fixed_value}数据结构，并使用宏@code{CONST_FIXED_VALUE}来访问。数据的高部分使用@code{CONST_FIXED_VALUE_HIGH}来访问；低部分使用@code{CONST_FIXED_VALUE_LOW}来访问。

@findex const_vector
@item (const_vector:@var{m} [@var{x0} @var{x1} @dots{}])
表示一个向量常量。方括号代表向量包含的常量元素。@var{x0}，@var{x1}等等为@code{const_int}，@code{const_double}或者@code{const_fixed}元素。

在@code{const_vector}中的单元数可以通过宏@code{CONST_VECTOR_NUNITS}来获得，形如@code{CONST_VECTOR_NUNITS (@var{v})}。

在向量常量中的单个元素使用宏@code{CONST_VECTOR_ELT}来访问，形如@code{CONST_VECTOR_ELT (@var{v}, @var{n})}，其中@var{v}为向量常量，@var{n}为要访问的元素编号。

@findex const_string
@item (const_string @var{str})
表示一个具有值@var{str}的常量字符串。目前这只用于insn属性（@pxref{Insn Attributes}），因为C中的常量字符串存放在内存中。

@findex symbol_ref
@item (symbol_ref:@var{mode} @var{symbol})
表示引用数据的汇编标号的值。@var{symbol}为一个字符串，描述了汇编标号的名字。如果其起始于@samp{*}，则标号为@var{symbol}不包含@samp{*}的其余部分。否则，标号为@var{symbol}，通常具有前缀@samp{_}。

@code{symbol_ref}包含一个机器模式，其通常为@code{Pmode}。通常这是唯一的使得符号有效的机器模式。

@findex label_ref
@item (label_ref:@var{mode} @var{label})
表示引用代码的汇编标号的值。其包含一个操作数，一个表达式，其必须为一个@code{code_label}或者一个@code{NOTE_INSN_DELETED_LABEL}类型的@code{note}，其出现在指令序列中，来标识标号应该处于的位置。

对于代码标号引用，使用一个不同的表达式类型的原因是跳转优化可以区分它们。

@code{label_ref}包含了一个机器模式，其通常为@code{Pmode}。通常这是唯一的使得标号有效的机器模式。

@findex const
@item (const:@var{m} @var{exp})
表示一个常量，其为汇编时算术计算的结果。操作数@var{exp}，为一个表达式，只包含了@code{plus}和@code{minus}组合的常量（@code{const_int}, @code{symbol_ref} 和 @code{label_ref}表达式）。然而，并不是所有的组合都是有效的，因为汇编器不能对重定位符号做任意的算术运算。

@var{m}应该为@code{Pmode}。

@findex high
@item (high:@var{m} @var{exp})
表示@var{exp}的高位，通常为一个@code{symbol_ref}。位数是机器相关的并且通常为初始化一个寄存器的高位的指令所指定的位数。其和@code{lo_sum}一起使用来表示典型的用于RISC机器的双指令序列来引用一个全局内存位置。

@var{m}应该为@code{Pmode}。

@end table

@findex CONST0_RTX
@findex CONST1_RTX
@findex CONST2_RTX
宏@code{CONST0_RTX (@var{mode})}指定一个具有值0，机器模式为@var{mode}的表达式。如果@var{mode}为@code{MODE_INT}类别，则返回@code{const0_rtx}。如果@var{mode}为 @code{MODE_FLOAT}类别，则返回模式为@var{mode}的表达式@code{CONST_DOUBLE}。否则，其返回一个模式为@var{mode}的表达式@code{CONST_VECTOR}。类似的，宏@code{CONST1_RTX (@var{mode})}指定一个具有值1，机器模式为@var{mode}的表达式，类似的对于@code{CONST2_RTX}。宏@code{CONST1_RTX}和@code{CONST2_RTX}对于向量模式没有定义。

@node 寄存器和内存
@section 寄存器和内存
@cindex RTL register expressions
@cindex RTL memory expressions

这些是描述访问机器寄存器和内存的RTL表达式类型。

@table @code
@findex reg
@cindex hard registers
@cindex pseudo registers
@item (reg:@var{m} @var{n})
对于值小（那些小于@code{FIRST_PSEUDO_REGISTER}）的整数@var{n}，这表示对机器寄存器号为@var{n}的引用。对于值大的@var{n}，它表示一个临时的值或者伪寄存器（@dfn{pseudo register}）。编译器的策略是，在生成代码时假设有无限数目的伪寄存器，并在之后将它们转换为硬件寄存器（@dfn{hard register}）或者内存的引用。

@var{m}为引用的机器模式。指定机器模式是有必要的，因为机器通常可以使用多种机器模式来引用每个寄存器。例如，一个寄存器可以包含一个整字，但是可以有指令来作为半字或者一个单独的字节来引用，同样，也有指令可以作为不同精度的浮点来引用。

即使对于机器只能使用一种机器模式来引用的寄存器，mode也必须被指定。

符号@code{FIRST_PSEUDO_REGISTER}被机器描述定义，由于机器的硬件寄存器数目是一个不变的特征。然而要注意，并不是所有的机器寄存器都必须是通用寄存器。所有的可以用于存储数据的机器寄存器都为被给定硬件寄存器编号，即使那些只可以被用于特定指令或者只能存放特定类型数据。

一个硬件寄存器可以在整个函数中按照多种机器模式来访问，但是每个伪寄存器都被给定一个自然的机器模式并且只能按照那个机器模式来访问。当需要描述一个使用非自然机器模式来访问伪寄存器的时候，则使用一个@code{subreg}表达式。

一个@code{reg}表达式具有的机器模式，如果指定了多于一个字的数据，则实际上代表了多个连续的寄存器。如果寄存器编号还指定了一个硬件寄存器，则其实际上表示起始于指定寄存器的多个连续的硬件寄存器。

每个在函数的RTL代码中使用的伪寄存器编号，使用一个唯一的@code{reg}表达式来表示。

@findex FIRST_VIRTUAL_REGISTER
@findex LAST_VIRTUAL_REGISTER
一些伪寄存器编号，处于@code{FIRST_VIRTUAL_REGISTER}到@code{LAST_VIRTUAL_REGISTER}之间，只在RTL生成阶段出现并且在优化阶段之前被消除。这些表示在栈帧中的位置，并且直到函数的RTL生成完成后才能确定。下列虚寄存器编号被定义：

@table @code
@findex VIRTUAL_INCOMING_ARGS_REGNUM
@item VIRTUAL_INCOMING_ARGS_REGNUM
这指向栈上传递的参数的第一个字。通常这些参数由调用者存放，但是被调用者可能已经将之前在寄存器中传递的参数压入栈中。

@cindex @code{FIRST_PARM_OFFSET} and virtual registers
@cindex @code{ARG_POINTER_REGNUM} and virtual registers
当RTL生成完成时，该虚寄存器由@code{ARG_POINTER_REGNUM}给定的寄存器和@code{FIRST_PARM_OFFSET}的值的和替换。

@findex VIRTUAL_STACK_VARS_REGNUM
@cindex @code{FRAME_GROWS_DOWNWARD} and virtual registers
@item VIRTUAL_STACK_VARS_REGNUM
如果@code{FRAME_GROWS_DOWNWARD}被定义为非0的值，则该宏指向栈上第一个变量的上一个位置。否则，其指向栈上的第一个变量。

@cindex @code{STARTING_FRAME_OFFSET} and virtual registers
@cindex @code{FRAME_POINTER_REGNUM} and virtual registers
@code{VIRTUAL_STACK_VARS_REGNUM}由@code{FRAME_POINTER_REGNUM}给定的寄存器和@code{STARTING_FRAME_OFFSET}的值的和替换。

@findex VIRTUAL_STACK_DYNAMIC_REGNUM
@item VIRTUAL_STACK_DYNAMIC_REGNUM
该宏指向栈指针根据内存需要已经被调整后的栈上动态分配内存的位置。

@cindex @code{STACK_DYNAMIC_OFFSET} and virtual registers
@cindex @code{STACK_POINTER_REGNUM} and virtual registers
该虚寄存器由@code{STACK_POINTER_REGNUM}给定的寄存器和@code{STACK_DYNAMIC_OFFSET}的值的和替换。

@findex VIRTUAL_OUTGOING_ARGS_REGNUM
@item VIRTUAL_OUTGOING_ARGS_REGNUM
其指向栈中，当输出参数的位置，
This points to the location in the stack at which outgoing arguments
should be written when the stack is pre-pushed (arguments pushed using
push insns should always use @code{STACK_POINTER_REGNUM}).

@cindex @code{STACK_POINTER_OFFSET} and virtual registers
This virtual register is replaced by the sum of the register given by
@code{STACK_POINTER_REGNUM} and the value @code{STACK_POINTER_OFFSET}.
@end table

@findex subreg
@item (subreg:@var{m1} @var{reg:m2} @var{bytenum})

@code{subreg} expressions are used to refer to a register in a machine
mode other than its natural one, or to refer to one register of
a multi-part @code{reg} that actually refers to several registers.

Each pseudo register has a natural mode.  If it is necessary to
operate on it in a different mode, the register must be
enclosed in a @code{subreg}.  

There are currently three supported types for the first operand of a
@code{subreg}:
@itemize
@item pseudo registers
This is the most common case.  Most @code{subreg}s have pseudo
@code{reg}s as their first operand.

@item mem
@code{subreg}s of @code{mem} were common in earlier versions of GCC and
are still supported.  During the reload pass these are replaced by plain
@code{mem}s.  On machines that do not do instruction scheduling, use of
@code{subreg}s of @code{mem} are still used, but this is no longer
recommended.  Such @code{subreg}s are considered to be
@code{register_operand}s rather than @code{memory_operand}s before and
during reload.  Because of this, the scheduling passes cannot properly
schedule instructions with @code{subreg}s of @code{mem}, so for machines
that do scheduling, @code{subreg}s of @code{mem} should never be used.
To support this, the combine and recog passes have explicit code to
inhibit the creation of @code{subreg}s of @code{mem} when
@code{INSN_SCHEDULING} is defined.

The use of @code{subreg}s of @code{mem} after the reload pass is an area
that is not well understood and should be avoided.  There is still some
code in the compiler to support this, but this code has possibly rotted.
This use of @code{subreg}s is discouraged and will most likely not be
supported in the future.

@item hard registers
It is seldom necessary to wrap hard registers in @code{subreg}s; such
registers would normally reduce to a single @code{reg} rtx.  This use of
@code{subreg}s is discouraged and may not be supported in the future.

@end itemize

@code{subreg}s of @code{subreg}s are not supported.  Using
@code{simplify_gen_subreg} is the recommended way to avoid this problem.

@code{subreg}s come in two distinct flavors, each having its own
usage and rules:

@table @asis
@item Paradoxical subregs
When @var{m1} is strictly wider than @var{m2}, the @code{subreg}
expression is called @dfn{paradoxical}.  The canonical test for this
class of @code{subreg} is:

@smallexample
GET_MODE_SIZE (@var{m1}) > GET_MODE_SIZE (@var{m2})
@end smallexample

Paradoxical @code{subreg}s can be used as both lvalues and rvalues.
When used as an lvalue, the low-order bits of the source value
are stored in @var{reg} and the high-order bits are discarded.
When used as an rvalue, the low-order bits of the @code{subreg} are
taken from @var{reg} while the high-order bits may or may not be
defined.  

The high-order bits of rvalues are in the following circumstances:

@itemize
@item @code{subreg}s of @code{mem}
When @var{m2} is smaller than a word, the macro @code{LOAD_EXTEND_OP},
can control how the high-order bits are defined.

@item @code{subreg} of @code{reg}s
The upper bits are defined when @code{SUBREG_PROMOTED_VAR_P} is true.
@code{SUBREG_PROMOTED_UNSIGNED_P} describes what the upper bits hold.
Such subregs usually represent local variables, register variables
and parameter pseudo variables that have been promoted to a wider mode.

@end itemize

@var{bytenum} is always zero for a paradoxical @code{subreg}, even on
big-endian targets.

For example, the paradoxical @code{subreg}:

@smallexample
(set (subreg:SI (reg:HI @var{x}) 0) @var{y})
@end smallexample

stores the lower 2 bytes of @var{y} in @var{x} and discards the upper
2 bytes.  A subsequent:

@smallexample
(set @var{z} (subreg:SI (reg:HI @var{x}) 0))
@end smallexample

would set the lower two bytes of @var{z} to @var{y} and set the upper
two bytes to an unknown value assuming @code{SUBREG_PROMOTED_VAR_P} is
false.

@item Normal subregs 
When @var{m1} is at least as narrow as @var{m2} the @code{subreg}
expression is called @dfn{normal}.

Normal @code{subreg}s restrict consideration to certain bits of
@var{reg}.  There are two cases.  If @var{m1} is smaller than a word,
the @code{subreg} refers to the least-significant part (or
@dfn{lowpart}) of one word of @var{reg}.  If @var{m1} is word-sized or
greater, the @code{subreg} refers to one or more complete words.

When used as an lvalue, @code{subreg} is a word-based accessor.
Storing to a @code{subreg} modifies all the words of @var{reg} that
overlap the @code{subreg}, but it leaves the other words of @var{reg}
alone.

When storing to a normal @code{subreg} that is smaller than a word,
the other bits of the referenced word are usually left in an undefined
state.  This laxity makes it easier to generate efficient code for
such instructions.  To represent an instruction that preserves all the
bits outside of those in the @code{subreg}, use @code{strict_low_part}
or @code{zero_extract} around the @code{subreg}.

@var{bytenum} must identify the offset of the first byte of the
@code{subreg} from the start of @var{reg}, assuming that @var{reg} is
laid out in memory order.  The memory order of bytes is defined by
two target macros, @code{WORDS_BIG_ENDIAN} and @code{BYTES_BIG_ENDIAN}:

@itemize
@item
@cindex @code{WORDS_BIG_ENDIAN}, effect on @code{subreg}
@code{WORDS_BIG_ENDIAN}, if set to 1, says that byte number zero is
part of the most significant word; otherwise, it is part of the least
significant word.

@item
@cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}
@code{BYTES_BIG_ENDIAN}, if set to 1, says that byte number zero is
the most significant byte within a word; otherwise, it is the least
significant byte within a word.
@end itemize

@cindex @code{FLOAT_WORDS_BIG_ENDIAN}, (lack of) effect on @code{subreg}
On a few targets, @code{FLOAT_WORDS_BIG_ENDIAN} disagrees with
@code{WORDS_BIG_ENDIAN}.  However, most parts of the compiler treat
floating point values as if they had the same endianness as integer
values.  This works because they handle them solely as a collection of
integer values, with no particular numerical value.  Only real.c and
the runtime libraries care about @code{FLOAT_WORDS_BIG_ENDIAN}.

Thus, 

@smallexample
(subreg:HI (reg:SI @var{x}) 2)
@end smallexample

on a @code{BYTES_BIG_ENDIAN}, @samp{UNITS_PER_WORD == 4} target is the same as

@smallexample
(subreg:HI (reg:SI @var{x}) 0)
@end smallexample

on a little-endian, @samp{UNITS_PER_WORD == 4} target.  Both
@code{subreg}s access the lower two bytes of register @var{x}.

@end table

A @code{MODE_PARTIAL_INT} mode behaves as if it were as wide as the
corresponding @code{MODE_INT} mode, except that it has an unknown
number of undefined bits.  For example:

@smallexample
(subreg:PSI (reg:SI 0) 0)
@end smallexample

accesses the whole of @samp{(reg:SI 0)}, but the exact relationship
between the @code{PSImode} value and the @code{SImode} value is not
defined.  If we assume @samp{UNITS_PER_WORD <= 4}, then the following
two @code{subreg}s:

@smallexample
(subreg:PSI (reg:DI 0) 0)
(subreg:PSI (reg:DI 0) 4)
@end smallexample

represent independent 4-byte accesses to the two halves of
@samp{(reg:DI 0)}.  Both @code{subreg}s have an unknown number
of undefined bits.

If @samp{UNITS_PER_WORD <= 2} then these two @code{subreg}s:

@smallexample
(subreg:HI (reg:PSI 0) 0)
(subreg:HI (reg:PSI 0) 2)
@end smallexample

represent independent 2-byte accesses that together span the whole
of @samp{(reg:PSI 0)}.  Storing to the first @code{subreg} does not
affect the value of the second, and vice versa.  @samp{(reg:PSI 0)}
has an unknown number of undefined bits, so the assignment:

@smallexample
(set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
@end smallexample

does not guarantee that @samp{(subreg:HI (reg:PSI 0) 0)} has the
value @samp{(reg:HI 4)}.

@cindex @code{CANNOT_CHANGE_MODE_CLASS} and subreg semantics
The rules above apply to both pseudo @var{reg}s and hard @var{reg}s.
If the semantics are not correct for particular combinations of
@var{m1}, @var{m2} and hard @var{reg}, the target-specific code
must ensure that those combinations are never used.  For example:

@smallexample
CANNOT_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})
@end smallexample

must be true for every class @var{class} that includes @var{reg}.

@findex SUBREG_REG
@findex SUBREG_BYTE
The first operand of a @code{subreg} expression is customarily accessed
with the @code{SUBREG_REG} macro and the second operand is customarily
accessed with the @code{SUBREG_BYTE} macro.

It has been several years since a platform in which
@code{BYTES_BIG_ENDIAN} not equal to @code{WORDS_BIG_ENDIAN} has
been tested.  Anyone wishing to support such a platform in the future
may be confronted with code rot.

@findex scratch
@cindex scratch operands
@item (scratch:@var{m})
This represents a scratch register that will be required for the
execution of a single instruction and not used subsequently.  It is
converted into a @code{reg} by either the local register allocator or
the reload pass.

@code{scratch} is usually present inside a @code{clobber} operation
(@pxref{Side Effects}).

@findex cc0
@cindex condition code register
@item (cc0)
This refers to the machine's condition code register.  It has no
operands and may not have a machine mode.  There are two ways to use it:

@itemize @bullet
@item
To stand for a complete set of condition code flags.  This is best on
most machines, where each comparison sets the entire series of flags.

With this technique, @code{(cc0)} may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) and in comparison operators comparing against zero
(@code{const_int} with value zero; that is to say, @code{const0_rtx}).

@item
To stand for a single flag that is the result of a single condition.
This is useful on machines that have only a single flag bit, and in
which comparison instructions must specify the condition to test.

With this technique, @code{(cc0)} may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) where the source is a comparison operator, and as the
first operand of @code{if_then_else} (in a conditional branch).
@end itemize

@findex cc0_rtx
There is only one expression object of code @code{cc0}; it is the
value of the variable @code{cc0_rtx}.  Any attempt to create an
expression of code @code{cc0} will return @code{cc0_rtx}.

Instructions can set the condition code implicitly.  On many machines,
nearly all instructions set the condition code based on the value that
they compute or store.  It is not necessary to record these actions
explicitly in the RTL because the machine description includes a
prescription for recognizing the instructions that do so (by means of
the macro @code{NOTICE_UPDATE_CC}).  @xref{Condition Code}.  Only
instructions whose sole purpose is to set the condition code, and
instructions that use the condition code, need mention @code{(cc0)}.

On some machines, the condition code register is given a register number
and a @code{reg} is used instead of @code{(cc0)}.  This is usually the
preferable approach if only a small subset of instructions modify the
condition code.  Other machines store condition codes in general
registers; in such cases a pseudo register should be used.

Some machines, such as the SPARC and RS/6000, have two sets of
arithmetic instructions, one that sets and one that does not set the
condition code.  This is best handled by normally generating the
instruction that does not set the condition code, and making a pattern
that both performs the arithmetic and sets the condition code register
(which would not be @code{(cc0)} in this case).  For examples, search
for @samp{addcc} and @samp{andcc} in @file{sparc.md}.

@findex pc
@item (pc)
@cindex program counter
This represents the machine's program counter.  It has no operands and
may not have a machine mode.  @code{(pc)} may be validly used only in
certain specific contexts in jump instructions.

@findex pc_rtx
There is only one expression object of code @code{pc}; it is the value
of the variable @code{pc_rtx}.  Any attempt to create an expression of
code @code{pc} will return @code{pc_rtx}.

All instructions that do not jump alter the program counter implicitly
by incrementing it, but there is no need to mention this in the RTL@.

@findex mem
@item (mem:@var{m} @var{addr} @var{alias})
This RTX represents a reference to main memory at an address
represented by the expression @var{addr}.  @var{m} specifies how large
a unit of memory is accessed.  @var{alias} specifies an alias set for the
reference.  In general two items are in different alias sets if they cannot
reference the same memory address.

The construct @code{(mem:BLK (scratch))} is considered to alias all
other memories.  Thus it may be used as a memory barrier in epilogue
stack deallocation patterns.

@findex concat
@item (concat@var{m} @var{rtx} @var{rtx})
This RTX represents the concatenation of two other RTXs.  This is used
for complex values.  It should only appear in the RTL attached to
declarations and during RTL generation.  It should not appear in the
ordinary insn chain.

@findex concatn
@item (concatn@var{m} [@var{rtx} @dots{}])
This RTX represents the concatenation of all the @var{rtx} to make a
single value.  Like @code{concat}, this should only appear in
declarations, and not in the insn chain.
@end table

@node 算术运算
@section RTL算术运算表达式
@cindex arithmetic, in RTL
@cindex math, in RTL
@cindex RTL expressions for arithmetic

除非其它规定，所有算术表达式的操作数必须对模式@var{m}有效。一个操作数对模式@var{m}有效，是指当它具有模式@var{m}，或者如果它是一个@code{const_int}或者@code{const_double}，并且@var{m}是一个@code{MODE_INT}类的模式。

对于可交换的二进制操作，常量应该放到第二个操作数的位置。

@table @code
@findex plus
@findex ss_plus
@findex us_plus
@cindex RTL sum
@cindex RTL addition
@cindex RTL addition with signed saturation
@cindex RTL addition with unsigned saturation
@item (plus:@var{m} @var{x} @var{y})
@itemx (ss_plus:@var{m} @var{x} @var{y})
@itemx (us_plus:@var{m} @var{x} @var{y})

These three expressions all represent the sum of the values
represented by @var{x} and @var{y} carried out in machine mode
@var{m}.  They differ in their behavior on overflow of integer modes.
@code{plus} wraps round modulo the width of @var{m}; @code{ss_plus}
saturates at the maximum signed value representable in @var{m};
@code{us_plus} saturates at the maximum unsigned value.

@c ??? What happens on overflow of floating point modes?

@findex lo_sum
@item (lo_sum:@var{m} @var{x} @var{y})

This expression represents the sum of @var{x} and the low-order bits
of @var{y}.  It is used with @code{high} (@pxref{Constants}) to
represent the typical two-instruction sequence used in RISC machines
to reference a global memory location.

The number of low order bits is machine-dependent but is
normally the number of bits in a @code{Pmode} item minus the number of
bits set by @code{high}.

@var{m} should be @code{Pmode}.

@findex minus
@findex ss_minus
@findex us_minus
@cindex RTL difference
@cindex RTL subtraction
@cindex RTL subtraction with signed saturation
@cindex RTL subtraction with unsigned saturation
@item (minus:@var{m} @var{x} @var{y})
@itemx (ss_minus:@var{m} @var{x} @var{y})
@itemx (us_minus:@var{m} @var{x} @var{y})

These three expressions represent the result of subtracting @var{y}
from @var{x}, carried out in mode @var{M}.  Behavior on overflow is
the same as for the three variants of @code{plus} (see above).

@findex compare
@cindex RTL comparison
@item (compare:@var{m} @var{x} @var{y})
Represents the result of subtracting @var{y} from @var{x} for purposes
of comparison.  The result is computed without overflow, as if with
infinite precision.

Of course, machines can't really subtract with infinite precision.
However, they can pretend to do so when only the sign of the result will
be used, which is the case when the result is stored in the condition
code.  And that is the @emph{only} way this kind of expression may
validly be used: as a value to be stored in the condition codes, either
@code{(cc0)} or a register.  @xref{Comparisons}.

The mode @var{m} is not related to the modes of @var{x} and @var{y}, but
instead is the mode of the condition code value.  If @code{(cc0)} is
used, it is @code{VOIDmode}.  Otherwise it is some mode in class
@code{MODE_CC}, often @code{CCmode}.  @xref{Condition Code}.  If @var{m}
is @code{VOIDmode} or @code{CCmode}, the operation returns sufficient
information (in an unspecified format) so that any comparison operator
can be applied to the result of the @code{COMPARE} operation.  For other
modes in class @code{MODE_CC}, the operation only returns a subset of
this information.

Normally, @var{x} and @var{y} must have the same mode.  Otherwise,
@code{compare} is valid only if the mode of @var{x} is in class
@code{MODE_INT} and @var{y} is a @code{const_int} or
@code{const_double} with mode @code{VOIDmode}.  The mode of @var{x}
determines what mode the comparison is to be done in; thus it must not
be @code{VOIDmode}.

If one of the operands is a constant, it should be placed in the
second operand and the comparison code adjusted as appropriate.

A @code{compare} specifying two @code{VOIDmode} constants is not valid
since there is no way to know in what mode the comparison is to be
performed; the comparison must either be folded during the compilation
or the first operand must be loaded into a register while its mode is
still known.

@findex neg
@findex ss_neg
@findex us_neg
@cindex negation
@cindex negation with signed saturation
@cindex negation with unsigned saturation
@item (neg:@var{m} @var{x})
@itemx (ss_neg:@var{m} @var{x})
@itemx (us_neg:@var{m} @var{x})
These two expressions represent the negation (subtraction from zero) of
the value represented by @var{x}, carried out in mode @var{m}.  They
differ in the behavior on overflow of integer modes.  In the case of
@code{neg}, the negation of the operand may be a number not representable
in mode @var{m}, in which case it is truncated to @var{m}.  @code{ss_neg}
and @code{us_neg} ensure that an out-of-bounds result saturates to the
maximum or minimum signed or unsigned value.

@findex mult
@findex ss_mult
@findex us_mult
@cindex multiplication
@cindex product
@cindex multiplication with signed saturation
@cindex multiplication with unsigned saturation
@item (mult:@var{m} @var{x} @var{y})
@itemx (ss_mult:@var{m} @var{x} @var{y})
@itemx (us_mult:@var{m} @var{x} @var{y})
Represents the signed product of the values represented by @var{x} and
@var{y} carried out in machine mode @var{m}.
@code{ss_mult} and @code{us_mult} ensure that an out-of-bounds result
saturates to the maximum or minimum signed or unsigned value.

Some machines support a multiplication that generates a product wider
than the operands.  Write the pattern for this as

@smallexample
(mult:@var{m} (sign_extend:@var{m} @var{x}) (sign_extend:@var{m} @var{y}))
@end smallexample

where @var{m} is wider than the modes of @var{x} and @var{y}, which need
not be the same.

For unsigned widening multiplication, use the same idiom, but with
@code{zero_extend} instead of @code{sign_extend}.

@findex div
@findex ss_div
@cindex division
@cindex signed division
@cindex signed division with signed saturation
@cindex quotient
@item (div:@var{m} @var{x} @var{y})
@itemx (ss_div:@var{m} @var{x} @var{y})
Represents the quotient in signed division of @var{x} by @var{y},
carried out in machine mode @var{m}.  If @var{m} is a floating point
mode, it represents the exact quotient; otherwise, the integerized
quotient.
@code{ss_div} ensures that an out-of-bounds result saturates to the maximum
or minimum signed value.

Some machines have division instructions in which the operands and
quotient widths are not all the same; you should represent
such instructions using @code{truncate} and @code{sign_extend} as in,

@smallexample
(truncate:@var{m1} (div:@var{m2} @var{x} (sign_extend:@var{m2} @var{y})))
@end smallexample

@findex udiv
@cindex unsigned division
@cindex unsigned division with unsigned saturation
@cindex division
@item (udiv:@var{m} @var{x} @var{y})
@itemx (us_div:@var{m} @var{x} @var{y})
Like @code{div} but represents unsigned division.
@code{us_div} ensures that an out-of-bounds result saturates to the maximum
or minimum unsigned value.

@findex mod
@findex umod
@cindex remainder
@cindex division
@item (mod:@var{m} @var{x} @var{y})
@itemx (umod:@var{m} @var{x} @var{y})
Like @code{div} and @code{udiv} but represent the remainder instead of
the quotient.

@findex smin
@findex smax
@cindex signed minimum
@cindex signed maximum
@item (smin:@var{m} @var{x} @var{y})
@itemx (smax:@var{m} @var{x} @var{y})
Represents the smaller (for @code{smin}) or larger (for @code{smax}) of
@var{x} and @var{y}, interpreted as signed values in mode @var{m}.
When used with floating point, if both operands are zeros, or if either
operand is @code{NaN}, then it is unspecified which of the two operands
is returned as the result.

@findex umin
@findex umax
@cindex unsigned minimum and maximum
@item (umin:@var{m} @var{x} @var{y})
@itemx (umax:@var{m} @var{x} @var{y})
Like @code{smin} and @code{smax}, but the values are interpreted as unsigned
integers.

@findex not
@cindex complement, bitwise
@cindex bitwise complement
@item (not:@var{m} @var{x})
Represents the bitwise complement of the value represented by @var{x},
carried out in mode @var{m}, which must be a fixed-point machine mode.

@findex and
@cindex logical-and, bitwise
@cindex bitwise logical-and
@item (and:@var{m} @var{x} @var{y})
Represents the bitwise logical-and of the values represented by
@var{x} and @var{y}, carried out in machine mode @var{m}, which must be
a fixed-point machine mode.

@findex ior
@cindex inclusive-or, bitwise
@cindex bitwise inclusive-or
@item (ior:@var{m} @var{x} @var{y})
Represents the bitwise inclusive-or of the values represented by @var{x}
and @var{y}, carried out in machine mode @var{m}, which must be a
fixed-point mode.

@findex xor
@cindex exclusive-or, bitwise
@cindex bitwise exclusive-or
@item (xor:@var{m} @var{x} @var{y})
Represents the bitwise exclusive-or of the values represented by @var{x}
and @var{y}, carried out in machine mode @var{m}, which must be a
fixed-point mode.

@findex ashift
@findex ss_ashift
@findex us_ashift
@cindex left shift
@cindex shift
@cindex arithmetic shift
@cindex arithmetic shift with signed saturation
@cindex arithmetic shift with unsigned saturation
@item (ashift:@var{m} @var{x} @var{c})
@itemx (ss_ashift:@var{m} @var{x} @var{c})
@itemx (us_ashift:@var{m} @var{x} @var{c})
These three expressions represent the result of arithmetically shifting @var{x}
left by @var{c} places.  They differ in their behavior on overflow of integer
modes.  An @code{ashift} operation is a plain shift with no special behavior
in case of a change in the sign bit; @code{ss_ashift} and @code{us_ashift}
saturates to the minimum or maximum representable value if any of the bits
shifted out differs from the final sign bit.

@var{x} have mode @var{m}, a fixed-point machine mode.  @var{c}
be a fixed-point mode or be a constant with mode @code{VOIDmode}; which
mode is determined by the mode called for in the machine description
entry for the left-shift instruction.  For example, on the VAX, the mode
of @var{c} is @code{QImode} regardless of @var{m}.

@findex lshiftrt
@cindex right shift
@findex ashiftrt
@item (lshiftrt:@var{m} @var{x} @var{c})
@itemx (ashiftrt:@var{m} @var{x} @var{c})
Like @code{ashift} but for right shift.  Unlike the case for left shift,
these two operations are distinct.

@findex rotate
@cindex rotate
@cindex left rotate
@findex rotatert
@cindex right rotate
@item (rotate:@var{m} @var{x} @var{c})
@itemx (rotatert:@var{m} @var{x} @var{c})
Similar but represent left and right rotate.  If @var{c} is a constant,
use @code{rotate}.

@findex abs
@cindex absolute value
@item (abs:@var{m} @var{x})
Represents the absolute value of @var{x}, computed in mode @var{m}.

@findex sqrt
@cindex square root
@item (sqrt:@var{m} @var{x})
Represents the square root of @var{x}, computed in mode @var{m}.
Most often @var{m} will be a floating point mode.

@findex ffs
@item (ffs:@var{m} @var{x})
Represents one plus the index of the least significant 1-bit in
@var{x}, represented as an integer of mode @var{m}.  (The value is
zero if @var{x} is zero.)  The mode of @var{x} need not be @var{m};
depending on the target machine, various mode combinations may be
valid.

@findex clz
@item (clz:@var{m} @var{x})
Represents the number of leading 0-bits in @var{x}, represented as an
integer of mode @var{m}, starting at the most significant bit position.
If @var{x} is zero, the value is determined by
@code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}).  Note that this is one of
the few expressions that is not invariant under widening.  The mode of
@var{x} will usually be an integer mode.

@findex ctz
@item (ctz:@var{m} @var{x})
Represents the number of trailing 0-bits in @var{x}, represented as an
integer of mode @var{m}, starting at the least significant bit position.
If @var{x} is zero, the value is determined by
@code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}).  Except for this case,
@code{ctz(x)} is equivalent to @code{ffs(@var{x}) - 1}.  The mode of
@var{x} will usually be an integer mode.

@findex popcount
@item (popcount:@var{m} @var{x})
Represents the number of 1-bits in @var{x}, represented as an integer of
mode @var{m}.  The mode of @var{x} will usually be an integer mode.

@findex parity
@item (parity:@var{m} @var{x})
Represents the number of 1-bits modulo 2 in @var{x}, represented as an
integer of mode @var{m}.  The mode of @var{x} will usually be an integer
mode.

@findex bswap
@item (bswap:@var{m} @var{x})
Represents the value @var{x} with the order of bytes reversed, carried out
in mode @var{m}, which must be a fixed-point machine mode.
@end table

@node 比较运算
@section 比较运算
@cindex RTL comparison operations

Comparison operators test a relation on two operands and are considered
to represent a machine-dependent nonzero value described by, but not
necessarily equal to, @code{STORE_FLAG_VALUE} (@pxref{Misc})
if the relation holds, or zero if it does not, for comparison operators
whose results have a `MODE_INT' mode,
@code{FLOAT_STORE_FLAG_VALUE} (@pxref{Misc}) if the relation holds, or
zero if it does not, for comparison operators that return floating-point
values, and a vector of either @code{VECTOR_STORE_FLAG_VALUE} (@pxref{Misc})
if the relation holds, or of zeros if it does not, for comparison operators
that return vector results.
The mode of the comparison operation is independent of the mode
of the data being compared.  If the comparison operation is being tested
(e.g., the first operand of an @code{if_then_else}), the mode must be
@code{VOIDmode}.

@cindex condition codes
There are two ways that comparison operations may be used.  The
comparison operators may be used to compare the condition codes
@code{(cc0)} against zero, as in @code{(eq (cc0) (const_int 0))}.  Such
a construct actually refers to the result of the preceding instruction
in which the condition codes were set.  The instruction setting the
condition code must be adjacent to the instruction using the condition
code; only @code{note} insns may separate them.

Alternatively, a comparison operation may directly compare two data
objects.  The mode of the comparison is determined by the operands; they
must both be valid for a common machine mode.  A comparison with both
operands constant would be invalid as the machine mode could not be
deduced from it, but such a comparison should never exist in RTL due to
constant folding.

In the example above, if @code{(cc0)} were last set to
@code{(compare @var{x} @var{y})}, the comparison operation is
identical to @code{(eq @var{x} @var{y})}.  Usually only one style
of comparisons is supported on a particular machine, but the combine
pass will try to merge the operations to produce the @code{eq} shown
in case it exists in the context of the particular insn involved.

Inequality comparisons come in two flavors, signed and unsigned.  Thus,
there are distinct expression codes @code{gt} and @code{gtu} for signed and
unsigned greater-than.  These can produce different results for the same
pair of integer values: for example, 1 is signed greater-than @minus{}1 but not
unsigned greater-than, because @minus{}1 when regarded as unsigned is actually
@code{0xffffffff} which is greater than 1.

The signed comparisons are also used for floating point values.  Floating
point comparisons are distinguished by the machine modes of the operands.

@table @code
@findex eq
@cindex equal
@item (eq:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
are equal, otherwise 0.

@findex ne
@cindex not equal
@item (ne:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
are not equal, otherwise 0.

@findex gt
@cindex greater than
@item (gt:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the @var{x} is greater than @var{y}.  If they
are fixed-point, the comparison is done in a signed sense.

@findex gtu
@cindex greater than
@cindex unsigned greater than
@item (gtu:@var{m} @var{x} @var{y})
Like @code{gt} but does unsigned comparison, on fixed-point numbers only.

@findex lt
@cindex less than
@findex ltu
@cindex unsigned less than
@item (lt:@var{m} @var{x} @var{y})
@itemx (ltu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``less than''.

@findex ge
@cindex greater than
@findex geu
@cindex unsigned greater than
@item (ge:@var{m} @var{x} @var{y})
@itemx (geu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``greater than or equal''.

@findex le
@cindex less than or equal
@findex leu
@cindex unsigned less than
@item (le:@var{m} @var{x} @var{y})
@itemx (leu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``less than or equal''.

@findex if_then_else
@item (if_then_else @var{cond} @var{then} @var{else})
This is not a comparison operation but is listed here because it is
always used in conjunction with a comparison operation.  To be
precise, @var{cond} is a comparison expression.  This expression
represents a choice, according to @var{cond}, between the value
represented by @var{then} and the one represented by @var{else}.

On most machines, @code{if_then_else} expressions are valid only
to express conditional jumps.

@findex cond
@item (cond [@var{test1} @var{value1} @var{test2} @var{value2} @dots{}] @var{default})
Similar to @code{if_then_else}, but more general.  Each of @var{test1},
@var{test2}, @dots{} is performed in turn.  The result of this expression is
the @var{value} corresponding to the first nonzero test, or @var{default} if
none of the tests are nonzero expressions.

This is currently not valid for instruction patterns and is supported only
for insn attributes.  @xref{Insn Attributes}.
@end table

@node 位域运算
@section 位域
@cindex bit-fields

有专门的表达式代码来表示位域指令。

@table @code
@findex sign_extract
@cindex @code{BITS_BIG_ENDIAN}, effect on @code{sign_extract}
@item (sign_extract:@var{m} @var{loc} @var{size} @var{pos})
这表示了对在@var{loc}处包含的或者起始的符号扩展位域的引用（内存或者寄存器引用）。位域为@var{size}个位数宽并且在位@var{pos}处起始。编译选项@code{BITS_BIG_ENDIAN}指明了@var{pos}从内存单元的那个端开始。 

如果@var{loc}在内存中，则它的机器模式必须为一个单个字节的整数机器模式。如果@var{loc}在寄存器中，则使用的机器模式是通过@code{insv}或者@code{extv}指令模式的操作数来指定的（@pxref{Standard Names}）并且通常为一个全字的整数机器模式，这当没有任何指定的时候为缺省的。

@var{pos}的机器模式为机器特定的并且总是在@code{insv}或者@code{extv}指令模式中被指定。

机器模式@var{m}与@var{loc}所使用的相同，如果它是在寄存器中。

在RTL中，@code{sign_extract}不可以作为左值或者是其中的一部分出现。

@findex zero_extract
@item (zero_extract:@var{m} @var{loc} @var{size} @var{pos})
类似@code{sign_extract}，但是指向一个无符号或者0扩展的位域。相同的位序列被抽取，但是它们被填充到一个整字中，并使用0扩展而不是符号扩展。 

不像@code{sign_extract}，该表达式的类型可以在RTL中为左值；它们可以出现在一个赋值的左边，来表明在一个指定的位域插入一个值。

@end table

@node 向量运算
@section 向量运算
@cindex vector operations

所有普通的RTL表达式都能够作为向量模式使用；它们被解析为对向量的每个部分进行独立的运算。另外，有一些新的表达式来描述特定的向量运算。

@table @code
@findex vec_merge
@item (vec_merge:@var{m} @var{vec1} @var{vec2} @var{items})
这描述了两个向量间的合并操作。结果为机器模式为@var{m}的向量；它的元素来自@var{vec1}或者@var{vec2}。那些元素被选择是通过@var{items}来描述，其为一个由@code{const_int}表示的位掩码；0位指示相应的元素在结果向量中是来自@var{vec2}，而1指示其来自@var{vec1}。 

@findex vec_select
@item (vec_select:@var{m} @var{vec1} @var{selection})
这描述了选择一个向量的一部分的操作。@var{vec1}为源向量，@var{selection}为一个@code{parallel}其包含了一个@code{const_int}，来描述结果向量的子部分，给出了源向量的子部分应该被存放进去。 

@findex vec_concat
@item (vec_concat:@var{m} @var{vec1} @var{vec2})
描述了一个向量连接操作。结果为向量@var{vec1}和@var{vec2}的连接；其长度为两个输出向量的长度之和。

@findex vec_duplicate
@item (vec_duplicate:@var{m} @var{vec})
该操作将一个小向量转换为一个大一点的，通过复制输入值。输出向量的机器模式必须和输入向量的相同，并且输出部分的编号必须为输入部分的编号的整数倍。

@end table

@node 转换运算
@section 转换
@cindex conversions
@cindex machine mode conversions

所有机器模式之间的转换都必须使用显示的转换符来表示。例如，一个表示字节和全字之和的表达式就不能写成@code{(plus:SI (reg:QI 34) (reg:SI 80))}，因为@code{plus}操作符需要两个具有相同机器模式的操作符。因此，字节长度的操作数被封装在一个转换操作中，如

@smallexample
(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))
@end smallexample

转换符并不仅仅是一个形式上的占位符，因为可能会有多种方式将给出的最初模式转换为期望的最终模式。转换符指出了如何进行这种操作。

对于所有的转换操作，@var{x}不能为@code{VOIDmode}，因为这样就无法知道如何进行转换操作。转换必须在编译时进行或者@var{x}必须被放入寄存器中。

@table @code
@findex sign_extend
@item (sign_extend:@var{m} @var{x})
表示将@var{x}的值符号扩展为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式窄的定点值。

@findex zero_extend
@item (zero_extend:@var{m} @var{x})
表示将@var{x}的值零扩展为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式窄的定点值。

@findex float_extend
@item (float_extend:@var{m} @var{x})
表示将@var{x}的值扩展为机器模式@var{m}后的结果。@var{m}必须是一个浮点模式，并且@var{x}是一个比@var{m}模式窄的浮点值。

@findex truncate
@item (truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果。@var{m}必须是一个定点模式，并且@var{x}是一个比@var{m}模式宽的定点值。

@findex ss_truncate
@item (ss_truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果，并且在溢出时作为有符号数处理。@var{m}和@var{x}的模式都必须是定点模式。

@findex us_truncate
@item (us_truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果，并且在溢出时作为无符号数处理。@var{m}和@var{x}的模式都必须是定点模式。

@findex float_truncate
@item (float_truncate:@var{m} @var{x})
表示将@var{x}的值截短为机器模式@var{m}后的结果。@var{m}必须是一个浮定点模式，并且@var{x}是一个比@var{m}模式宽的浮点值。

@findex float
@item (float:@var{m} @var{x})
表示将定点值@var{x}转换为有符号的浮点模式@var{m}后的结果。

@findex unsigned_float
@item (unsigned_float:@var{m} @var{x})
表示将定点值@var{x}转换为无符号的浮点模式@var{m}后的结果。

@findex fix
@item (fix:@var{m} @var{x})
当@var{m}是一个浮点模式时，表示将浮点值@var{x}（对模式@var{m}有效）转换为整形，仍然使用浮点模式@var{m}表示，只不过是向零方向进行舍入。

当@var{m}是一个定点模式时，表示将浮点值@var{x}转换为有符号的模式@var{m}的结果。具体如何舍入没有做出规定。所以，这个操作可能只是被用在编译C代码时的整数值的操作数。

@findex unsigned_fix
@item (unsigned_fix:@var{m} @var{x})
表示将浮点值@var{x}转换为无符号的定点模式@var{m}。具体如何舍入没有做出规定。

@findex fract_convert
@item (fract_convert:@var{m} @var{x})
Represents the result of converting fixed-point value @var{x} to
fixed-point mode @var{m}, signed integer value @var{x} to
fixed-point mode @var{m}, floating-point value @var{x} to
fixed-point mode @var{m}, fixed-point value @var{x} to integer mode @var{m}
regarded as signed, or fixed-point value @var{x} to floating-point mode @var{m}.
When overflows or underflows happen, the results are undefined.

@findex sat_fract
@item (sat_fract:@var{m} @var{x})
Represents the result of converting fixed-point value @var{x} to
fixed-point mode @var{m}, signed integer value @var{x} to
fixed-point mode @var{m}, or floating-point value @var{x} to
fixed-point mode @var{m}.
When overflows or underflows happen, the results are saturated to the
maximum or the minimum.

@findex unsigned_fract_convert
@item (unsigned_fract_convert:@var{m} @var{x})
Represents the result of converting fixed-point value @var{x} to
integer mode @var{m} regarded as unsigned, or unsigned integer value @var{x} to
fixed-point mode @var{m}.
When overflows or underflows happen, the results are undefined.

@findex unsigned_sat_fract
@item (unsigned_sat_fract:@var{m} @var{x})
Represents the result of converting unsigned integer value @var{x} to
fixed-point mode @var{m}.
When overflows or underflows happen, the results are saturated to the
maximum or the minimum.
@end table

@node RTL声明
@section 声明
@cindex RTL declarations
@cindex declarations, RTL

声明表达式代码并不表示算术运算，而是关于它们的操作数状态的断言。

@table @code
@findex strict_low_part
@cindex @code{subreg}, in @code{strict_low_part}
@item (strict_low_part (subreg:@var{m} (reg:@var{n} @var{r}) 0))
这个表达式代码只用在一种上下文中：作为@code{set}表达式的目标操作数。另外，这个表达式的操作数必须是一个non-paradoxical @code{subreg}表达式 

这里@code{strict_low_part}指出寄存器中对于模式@var{n}有意义，但对于模式@var{m}却无意义的那一部分，是不能被修改的。通常，对于这样的subreg进行赋值，当@var{m}小于一个字时，是允许对寄存器的其它部分有未定义的影响。

@end table

@node 副作用
@section 副作用表达式
@cindex RTL side effect expressions

目前为止，所描述的表达式代码都是用来表示一个值，而不是操作。但是机器指令是不会产生值的，而只是通过副作用来改变机器状态。特定的表达式代码被用来表示副作用。

一条指令的主体，总是这些副作用代码之一；上面描述的表示值的代码，只是作为操作数出现在其中。

@table @code
@findex set
@item (set @var{lval} @var{x})
表示将@var{x}的值存放到由@var{lval}表示的地方。@var{lval}必须是表示可以用来存放的地方的表达式：@code{reg}（或者@code{subreg}，@code{strict_low_part}或者@code{zero_extract}），@code{mem}，@code{pc}，@code{parallel}或者@code{cc0}。

如果@var{lval}是一个@code{reg}，@code{subreg}或者@code{mem}，其具有一个机器模式；则@var{x}必须对这种模式有效。 

如果@var{lval}是一个@code{subreg}的@code{strict_low_part}，则由@code{subreg}的机器模式所指定的寄存器的那部分被赋予值@var{x}，而寄存器的其它部分不变。 

如果@var{lval}是一个@code{zero_extract}，则由@code{zero_extract}指定的相关位域（内存或者寄存器相关的），被赋予值@var{x}，而其它位域不变。注意@code{sign_extract}不能出现在@var{lval}中。 

如果@var{lval}是@code{(cc0)}，其没有机器模式，并且@var{x}可以为一个@code{compare}表达式或者任意模式的值。后者情况表示是一个“test”指令。表达式@code{(set (cc0) (reg:@var{m} @var{n}))} 等价于 @code{(set (cc0) (compare (reg:@var{m} @var{n})。在编译过程中可以使用前一个表达式来节省空间。 

如果@var{lval}是一个@code{parallel}，其用来表示一个函数通过多个寄存器来返回一个结构体的情况。@code{parallel}中的每一个元素是一个@code{expr_list}，其第一个操作数是一个@code{reg}，并且第二个操作数是一个@code{const_int}，表示相应寄存器的数据在结构体中的偏移量（以字节为单位）。第一个元素也可能为null，用来指示结构体也有一部分是在内存中传递的。 

@cindex jump instructions and @code{set}
@cindex @code{if_then_else} usage
如果@var{lval}是@code{(pc)}，则为一个跳转指令，并且@var{x}只有几种可能。其可能为一个@code{label_ref}表达式（无条件跳转）。可能为一个@code{if_then_else}（条件跳转），这种情况下，第二个或者第三个操作数必须是@code{(pc)}（用于不进行跳转的情况），并且另外两个必须是一个@code{label_ref}（用于进行跳转的情况）。@var{x}也可以是一个@code{mem}或者@code{(plus:SI (pc) @var{y}, 其中y可以为一个@code{reg}或者@code{mem}；这些独特的模式用来表示通过分支表来进行跳转。 

如果@var{lval}即不是@code{(cc0)}也不是@code{(pc)},则@var{lval}的模式一定不是@code{VOIDmode}，并且@var{x}的模式必须对于@var{lval}的模式有效。 

@findex SET_DEST
@findex SET_SRC
@var{lval}通常通过@code{SET_DEST}宏来访问，@var{x}通常使用@code{SET_SRC}宏。

@findex return
@item (return)
在指令模式中作为单独的表达式，表示从当前函数的一个返回，在一些机器上，可以使用一条指令来完成，例如VAXen。
As the sole expression in a pattern, represents a return from the
current function, on machines where this can be done with one
instruction, such as VAXen.  On machines where a multi-instruction
``epilogue'' must be executed in order to return from the function,
returning is done by jumping to a label which precedes the epilogue, and
the @code{return} expression code is never used.

Inside an @code{if_then_else} expression, represents the value to be
placed in @code{pc} to return to the caller.

Note that an insn pattern of @code{(return)} is logically equivalent to
@code{(set (pc) (return))}, but the latter form is never used.

@findex call
@item (call @var{function} @var{nargs})
Represents a function call.  @var{function} is a @code{mem} expression
whose address is the address of the function to be called.
@var{nargs} is an expression which can be used for two purposes: on
some machines it represents the number of bytes of stack argument; on
others, it represents the number of argument registers.

Each machine has a standard machine mode which @var{function} must
have.  The machine description defines macro @code{FUNCTION_MODE} to
expand into the requisite mode name.  The purpose of this mode is to
specify what kind of addressing is allowed, on machines where the
allowed kinds of addressing depend on the machine mode being
addressed.

@findex clobber
@item (clobber @var{x})
Represents the storing or possible storing of an unpredictable,
undescribed value into @var{x}, which must be a @code{reg},
@code{scratch}, @code{parallel} or @code{mem} expression.

One place this is used is in string instructions that store standard
values into particular hard registers.  It may not be worth the
trouble to describe the values that are stored, but it is essential to
inform the compiler that the registers will be altered, lest it
attempt to keep data in them across the string instruction.

If @var{x} is @code{(mem:BLK (const_int 0))} or
@code{(mem:BLK (scratch))}, it means that all memory
locations must be presumed clobbered.  If @var{x} is a @code{parallel},
it has the same meaning as a @code{parallel} in a @code{set} expression.

Note that the machine description classifies certain hard registers as
``call-clobbered''.  All function call instructions are assumed by
default to clobber these registers, so there is no need to use
@code{clobber} expressions to indicate this fact.  Also, each function
call is assumed to have the potential to alter any memory location,
unless the function is declared @code{const}.

If the last group of expressions in a @code{parallel} are each a
@code{clobber} expression whose arguments are @code{reg} or
@code{match_scratch} (@pxref{RTL Template}) expressions, the combiner
phase can add the appropriate @code{clobber} expressions to an insn it
has constructed when doing so will cause a pattern to be matched.

This feature can be used, for example, on a machine that whose multiply
and add instructions don't use an MQ register but which has an
add-accumulate instruction that does clobber the MQ register.  Similarly,
a combined instruction might require a temporary register while the
constituent instructions might not.

When a @code{clobber} expression for a register appears inside a
@code{parallel} with other side effects, the register allocator
guarantees that the register is unoccupied both before and after that
insn if it is a hard register clobber.  For pseudo-register clobber,
the register allocator and the reload pass do not assign the same hard
register to the clobber and the input operands if there is an insn
alternative containing the @samp{&} constraint (@pxref{Modifiers}) for
the clobber and the hard register is in register classes of the
clobber in the alternative.  You can clobber either a specific hard
register, a pseudo register, or a @code{scratch} expression; in the
latter two cases, GCC will allocate a hard register that is available
there for use as a temporary.

For instructions that require a temporary register, you should use
@code{scratch} instead of a pseudo-register because this will allow the
combiner phase to add the @code{clobber} when required.  You do this by
coding (@code{clobber} (@code{match_scratch} @dots{})).  If you do
clobber a pseudo register, use one which appears nowhere else---generate
a new one each time.  Otherwise, you may confuse CSE@.

There is one other known use for clobbering a pseudo register in a
@code{parallel}: when one of the input operands of the insn is also
clobbered by the insn.  In this case, using the same pseudo register in
the clobber and elsewhere in the insn produces the expected results.

@findex use
@item (use @var{x})
Represents the use of the value of @var{x}.  It indicates that the
value in @var{x} at this point in the program is needed, even though
it may not be apparent why this is so.  Therefore, the compiler will
not attempt to delete previous instructions whose only effect is to
store a value in @var{x}.  @var{x} must be a @code{reg} expression.

In some situations, it may be tempting to add a @code{use} of a
register in a @code{parallel} to describe a situation where the value
of a special register will modify the behavior of the instruction.
An hypothetical example might be a pattern for an addition that can
either wrap around or use saturating addition depending on the value
of a special control register:

@smallexample
(parallel [(set (reg:SI 2) (unspec:SI [(reg:SI 3)
                                       (reg:SI 4)] 0))
           (use (reg:SI 1))])
@end smallexample

@noindent

This will not work, several of the optimizers only look at expressions
locally; it is very likely that if you have multiple insns with
identical inputs to the @code{unspec}, they will be optimized away even
if register 1 changes in between.

This means that @code{use} can @emph{only} be used to describe
that the register is live.  You should think twice before adding
@code{use} statements, more often you will want to use @code{unspec}
instead.  The @code{use} RTX is most commonly useful to describe that
a fixed register is implicitly used in an insn.  It is also safe to use
in patterns where the compiler knows for other reasons that the result
of the whole pattern is variable, such as @samp{movmem@var{m}} or
@samp{call} patterns.

During the reload phase, an insn that has a @code{use} as pattern
can carry a reg_equal note.  These @code{use} insns will be deleted
before the reload phase exits.

During the delayed branch scheduling phase, @var{x} may be an insn.
This indicates that @var{x} previously was located at this place in the
code and its data dependencies need to be taken into account.  These
@code{use} insns will be deleted before the delayed branch scheduling
phase exits.

@findex parallel
@item (parallel [@var{x0} @var{x1} @dots{}])
Represents several side effects performed in parallel.  The square
brackets stand for a vector; the operand of @code{parallel} is a
vector of expressions.  @var{x0}, @var{x1} and so on are individual
side effect expressions---expressions of code @code{set}, @code{call},
@code{return}, @code{clobber} or @code{use}.

``In parallel'' means that first all the values used in the individual
side-effects are computed, and second all the actual side-effects are
performed.  For example,

@smallexample
(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])
@end smallexample

@noindent
says unambiguously that the values of hard register 1 and the memory
location addressed by it are interchanged.  In both places where
@code{(reg:SI 1)} appears as a memory address it refers to the value
in register 1 @emph{before} the execution of the insn.

It follows that it is @emph{incorrect} to use @code{parallel} and
expect the result of one @code{set} to be available for the next one.
For example, people sometimes attempt to represent a jump-if-zero
instruction this way:

@smallexample
(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref @dots{})
                        (pc)))])
@end smallexample

@noindent
But this is incorrect, because it says that the jump condition depends
on the condition code value @emph{before} this instruction, not on the
new value that is set by this instruction.

@cindex peephole optimization, RTL representation
Peephole optimization, which takes place together with final assembly
code output, can produce insns whose patterns consist of a @code{parallel}
whose elements are the operands needed to output the resulting
assembler code---often @code{reg}, @code{mem} or constant expressions.
This would not be well-formed RTL at any other stage in compilation,
but it is ok then because no further optimization remains to be done.
However, the definition of the macro @code{NOTICE_UPDATE_CC}, if
any, must deal with such insns if you define any peephole optimizations.

@findex cond_exec
@item (cond_exec [@var{cond} @var{expr}])
Represents a conditionally executed expression.  The @var{expr} is
executed only if the @var{cond} is nonzero.  The @var{cond} expression
must not have side-effects, but the @var{expr} may very well have
side-effects.

@findex sequence
@item (sequence [@var{insns} @dots{}])
Represents a sequence of insns.  Each of the @var{insns} that appears
in the vector is suitable for appearing in the chain of insns, so it
must be an @code{insn}, @code{jump_insn}, @code{call_insn},
@code{code_label}, @code{barrier} or @code{note}.

A @code{sequence} RTX is never placed in an actual insn during RTL
generation.  It represents the sequence of insns that result from a
@code{define_expand} @emph{before} those insns are passed to
@code{emit_insn} to insert them in the chain of insns.  When actually
inserted, the individual sub-insns are separated out and the
@code{sequence} is forgotten.

After delay-slot scheduling is completed, an insn and all the insns that
reside in its delay slots are grouped together into a @code{sequence}.
The insn requiring the delay slot is the first insn in the vector;
subsequent insns are to be placed in the delay slot.

@code{INSN_ANNULLED_BRANCH_P} is set on an insn in a delay slot to
indicate that a branch insn should be used that will conditionally annul
the effect of the insns in the delay slots.  In such a case,
@code{INSN_FROM_TARGET_P} indicates that the insn is from the target of
the branch and should be executed only if the branch is taken; otherwise
the insn should be executed only if the branch is not taken.
@xref{Delay Slots}.
@end table

These expression codes appear in place of a side effect, as the body of
an insn, though strictly speaking they do not always describe side
effects as such:

@table @code
@findex asm_input
@item (asm_input @var{s})
Represents literal assembler code as described by the string @var{s}.

@findex unspec
@findex unspec_volatile
@item (unspec [@var{operands} @dots{}] @var{index})
@itemx (unspec_volatile [@var{operands} @dots{}] @var{index})
Represents a machine-specific operation on @var{operands}.  @var{index}
selects between multiple machine-specific operations.
@code{unspec_volatile} is used for volatile operations and operations
that may trap; @code{unspec} is used for other operations.

These codes may appear inside a @code{pattern} of an
insn, inside a @code{parallel}, or inside an expression.

@findex addr_vec
@item (addr_vec:@var{m} [@var{lr0} @var{lr1} @dots{}])
Represents a table of jump addresses.  The vector elements @var{lr0},
etc., are @code{label_ref} expressions.  The mode @var{m} specifies
how much space is given to each address; normally @var{m} would be
@code{Pmode}.

@findex addr_diff_vec
@item (addr_diff_vec:@var{m} @var{base} [@var{lr0} @var{lr1} @dots{}] @var{min} @var{max} @var{flags})
Represents a table of jump addresses expressed as offsets from
@var{base}.  The vector elements @var{lr0}, etc., are @code{label_ref}
expressions and so is @var{base}.  The mode @var{m} specifies how much
space is given to each address-difference.  @var{min} and @var{max}
are set up by branch shortening and hold a label with a minimum and a
maximum address, respectively.  @var{flags} indicates the relative
position of @var{base}, @var{min} and @var{max} to the containing insn
and of @var{min} and @var{max} to @var{base}.  See rtl.def for details.

@findex prefetch
@item (prefetch:@var{m} @var{addr} @var{rw} @var{locality})
Represents prefetch of memory at address @var{addr}.
Operand @var{rw} is 1 if the prefetch is for data to be written, 0 otherwise;
targets that do not support write prefetches should treat this as a normal
prefetch.
Operand @var{locality} specifies the amount of temporal locality; 0 if there
is none or 1, 2, or 3 for increasing levels of temporal locality;
targets that do not support locality hints should ignore this.

This insn is used to minimize cache-miss latency by moving data into a
cache before it is accessed.  It should use only non-faulting data prefetch
instructions.
@end table

@node Incdec
@section 地址中嵌入的副作用
@cindex RTL preincrement
@cindex RTL postincrement
@cindex RTL predecrement
@cindex RTL postdecrement

Six special side-effect expression codes appear as memory addresses.

@table @code
@findex pre_dec
@item (pre_dec:@var{m} @var{x})
Represents the side effect of decrementing @var{x} by a standard
amount and represents also the value that @var{x} has after being
decremented.  @var{x} must be a @code{reg} or @code{mem}, but most
machines allow only a @code{reg}.  @var{m} must be the machine mode
for pointers on the machine in use.  The amount @var{x} is decremented
by is the length in bytes of the machine mode of the containing memory
reference of which this expression serves as the address.  Here is an
example of its use:

@smallexample
(mem:DF (pre_dec:SI (reg:SI 39)))
@end smallexample

@noindent
This says to decrement pseudo register 39 by the length of a @code{DFmode}
value and use the result to address a @code{DFmode} value.

@findex pre_inc
@item (pre_inc:@var{m} @var{x})
Similar, but specifies incrementing @var{x} instead of decrementing it.

@findex post_dec
@item (post_dec:@var{m} @var{x})
Represents the same side effect as @code{pre_dec} but a different
value.  The value represented here is the value @var{x} has @i{before}
being decremented.

@findex post_inc
@item (post_inc:@var{m} @var{x})
Similar, but specifies incrementing @var{x} instead of decrementing it.

@findex post_modify
@item (post_modify:@var{m} @var{x} @var{y})

Represents the side effect of setting @var{x} to @var{y} and
represents @var{x} before @var{x} is modified.  @var{x} must be a
@code{reg} or @code{mem}, but most machines allow only a @code{reg}.
@var{m} must be the machine mode for pointers on the machine in use.

The expression @var{y} must be one of three forms:
@code{(plus:@var{m} @var{x} @var{z})},
@code{(minus:@var{m} @var{x} @var{z})}, or
@code{(plus:@var{m} @var{x} @var{i})},
where @var{z} is an index register and @var{i} is a constant.

Here is an example of its use:

@smallexample
(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42)
                                          (reg:SI 48))))
@end smallexample

This says to modify pseudo register 42 by adding the contents of pseudo
register 48 to it, after the use of what ever 42 points to.

@findex pre_modify
@item (pre_modify:@var{m} @var{x} @var{expr})
Similar except side effects happen before the use.
@end table

These embedded side effect expressions must be used with care.  Instruction
patterns may not use them.  Until the @samp{flow} pass of the compiler,
they may occur only to represent pushes onto the stack.  The @samp{flow}
pass finds cases where registers are incremented or decremented in one
instruction and used as an address shortly before or after; these cases are
then transformed to use pre- or post-increment or -decrement.

If a register used as the operand of these expressions is used in
another address in an insn, the original value of the register is used.
Uses of the register outside of an address are not permitted within the
same insn as a use in an embedded side effect expression because such
insns behave differently on different machines and hence must be treated
as ambiguous and disallowed.

An instruction that can be represented with an embedded side effect
could also be represented using @code{parallel} containing an additional
@code{set} to describe how the address register is altered.  This is not
done because machines that allow these operations at all typically
allow them wherever a memory address is called for.  Describing them as
additional parallel stores would require doubling the number of entries
in the machine description.

@node 汇编
@section 作为表达式的汇编指令
@cindex assembler instructions in RTL

@cindex @code{asm_operands}, usage
RTX代码@code{asm_operands}表示由用户特定的汇编指令所产生的值。其用来表示带有参数的@code{asm}语句。一个具有单个输出操作数的@code{asm}语句，如下：

@smallexample
asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));
@end smallexample

@noindent
其通过一个单个的@code{asm_operands} RTX来表示，其表示了存储在@code{outputvar}中的值：

@smallexample
(set @var{rtx-for-outputvar}
     (asm_operands "foo %1,%2,%0" "a" 0
                   [@var{rtx-for-addition-result} @var{rtx-for-*z}]
                   [(asm_input:@var{m1} "g")
                    (asm_input:@var{m2} "di")]))
@end smallexample

@noindent
这里，@code{asm_operands} RTX的操作数为汇编模板字符串，输出操作数的约束，在指定的输出操作数中的索引编号，一个输入操作数RTX向量，以及一个输出操作数机器模式和约束的向量。机器模式@var{m1}为@code{x+y}的和的机器模式；@var{m2}为@code{*z}的机器模式。
        
当@code{asm}语句具有多个输出值时，它的insn具有多个这样的@code{set} RTX，并位于一个@code{parallel}中。每个@code{set}包括了一个@code{asm_operands}；所有这些共享相同的汇编模板和向量，但是每个包含了相应的输出操作数的约束。它们也是通过输出操作数索引编号来区分的，即0，1@dots{}连续的输出操作数。

@node Insns
@section Insns
@cindex insns

The RTL representation of the code for a function is a doubly-linked
chain of objects called @dfn{insns}.  Insns are expressions with
special codes that are used for no other purpose.  Some insns are
actual instructions; others represent dispatch tables for @code{switch}
statements; others represent labels to jump to or various sorts of
declarative information.

In addition to its own specific data, each insn must have a unique
id-number that distinguishes it from all other insns in the current
function (after delayed branch scheduling, copies of an insn with the
same id-number may be present in multiple places in a function, but
these copies will always be identical and will only appear inside a
@code{sequence}), and chain pointers to the preceding and following
insns.  These three fields occupy the same position in every insn,
independent of the expression code of the insn.  They could be accessed
with @code{XEXP} and @code{XINT}, but instead three special macros are
always used:

@table @code
@findex INSN_UID
@item INSN_UID (@var{i})
Accesses the unique id of insn @var{i}.

@findex PREV_INSN
@item PREV_INSN (@var{i})
Accesses the chain pointer to the insn preceding @var{i}.
If @var{i} is the first insn, this is a null pointer.

@findex NEXT_INSN
@item NEXT_INSN (@var{i})
Accesses the chain pointer to the insn following @var{i}.
If @var{i} is the last insn, this is a null pointer.
@end table

@findex get_insns
@findex get_last_insn
The first insn in the chain is obtained by calling @code{get_insns}; the
last insn is the result of calling @code{get_last_insn}.  Within the
chain delimited by these insns, the @code{NEXT_INSN} and
@code{PREV_INSN} pointers must always correspond: if @var{insn} is not
the first insn,

@smallexample
NEXT_INSN (PREV_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
is always true and if @var{insn} is not the last insn,

@smallexample
PREV_INSN (NEXT_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
is always true.

After delay slot scheduling, some of the insns in the chain might be
@code{sequence} expressions, which contain a vector of insns.  The value
of @code{NEXT_INSN} in all but the last of these insns is the next insn
in the vector; the value of @code{NEXT_INSN} of the last insn in the vector
is the same as the value of @code{NEXT_INSN} for the @code{sequence} in
which it is contained.  Similar rules apply for @code{PREV_INSN}.

This means that the above invariants are not necessarily true for insns
inside @code{sequence} expressions.  Specifically, if @var{insn} is the
first insn in a @code{sequence}, @code{NEXT_INSN (PREV_INSN (@var{insn}))}
is the insn containing the @code{sequence} expression, as is the value
of @code{PREV_INSN (NEXT_INSN (@var{insn}))} if @var{insn} is the last
insn in the @code{sequence} expression.  You can use these expressions
to find the containing @code{sequence} expression.

Every insn has one of the following six expression codes:

@table @code
@findex insn
@item insn
The expression code @code{insn} is used for instructions that do not jump
and do not do function calls.  @code{sequence} expressions are always
contained in insns with code @code{insn} even if one of those insns
should jump or do function calls.

Insns with code @code{insn} have four additional fields beyond the three
mandatory ones listed above.  These four are described in a table below.

@findex jump_insn
@item jump_insn
The expression code @code{jump_insn} is used for instructions that may
jump (or, more generally, may contain @code{label_ref} expressions to
which @code{pc} can be set in that instruction).  If there is an
instruction to return from the current function, it is recorded as a
@code{jump_insn}.

@findex JUMP_LABEL
@code{jump_insn} insns have the same extra fields as @code{insn} insns,
accessed in the same way and in addition contain a field
@code{JUMP_LABEL} which is defined once jump optimization has completed.

For simple conditional and unconditional jumps, this field contains
the @code{code_label} to which this insn will (possibly conditionally)
branch.  In a more complex jump, @code{JUMP_LABEL} records one of the
labels that the insn refers to; other jump target labels are recorded
as @code{REG_LABEL_TARGET} notes.  The exception is @code{addr_vec}
and @code{addr_diff_vec}, where @code{JUMP_LABEL} is @code{NULL_RTX}
and the only way to find the labels is to scan the entire body of the
insn.

Return insns count as jumps, but since they do not refer to any
labels, their @code{JUMP_LABEL} is @code{NULL_RTX}.

@findex call_insn
@item call_insn
The expression code @code{call_insn} is used for instructions that may do
function calls.  It is important to distinguish these instructions because
they imply that certain registers and memory locations may be altered
unpredictably.

@findex CALL_INSN_FUNCTION_USAGE
@code{call_insn} insns have the same extra fields as @code{insn} insns,
accessed in the same way and in addition contain a field
@code{CALL_INSN_FUNCTION_USAGE}, which contains a list (chain of
@code{expr_list} expressions) containing @code{use} and @code{clobber}
expressions that denote hard registers and @code{MEM}s used or
clobbered by the called function.

A @code{MEM} generally points to a stack slots in which arguments passed
to the libcall by reference (@pxref{Register Arguments,
TARGET_PASS_BY_REFERENCE}) are stored.  If the argument is
caller-copied (@pxref{Register Arguments, TARGET_CALLEE_COPIES}),
the stack slot will be mentioned in @code{CLOBBER} and @code{USE}
entries; if it's callee-copied, only a @code{USE} will appear, and the
@code{MEM} may point to addresses that are not stack slots.

@code{CLOBBER}ed registers in this list augment registers specified in
@code{CALL_USED_REGISTERS} (@pxref{Register Basics}).

@findex code_label
@findex CODE_LABEL_NUMBER
@item code_label
A @code{code_label} insn represents a label that a jump insn can jump
to.  It contains two special fields of data in addition to the three
standard ones.  @code{CODE_LABEL_NUMBER} is used to hold the @dfn{label
number}, a number that identifies this label uniquely among all the
labels in the compilation (not just in the current function).
Ultimately, the label is represented in the assembler output as an
assembler label, usually of the form @samp{L@var{n}} where @var{n} is
the label number.

When a @code{code_label} appears in an RTL expression, it normally
appears within a @code{label_ref} which represents the address of
the label, as a number.

Besides as a @code{code_label}, a label can also be represented as a
@code{note} of type @code{NOTE_INSN_DELETED_LABEL}.

@findex LABEL_NUSES
The field @code{LABEL_NUSES} is only defined once the jump optimization
phase is completed.  It contains the number of times this label is
referenced in the current function.

@findex LABEL_KIND
@findex SET_LABEL_KIND
@findex LABEL_ALT_ENTRY_P
@cindex alternate entry points
The field @code{LABEL_KIND} differentiates four different types of
labels: @code{LABEL_NORMAL}, @code{LABEL_STATIC_ENTRY},
@code{LABEL_GLOBAL_ENTRY}, and @code{LABEL_WEAK_ENTRY}.  The only labels
that do not have type @code{LABEL_NORMAL} are @dfn{alternate entry
points} to the current function.  These may be static (visible only in
the containing translation unit), global (exposed to all translation
units), or weak (global, but can be overridden by another symbol with the
same name).

Much of the compiler treats all four kinds of label identically.  Some
of it needs to know whether or not a label is an alternate entry point;
for this purpose, the macro @code{LABEL_ALT_ENTRY_P} is provided.  It is
equivalent to testing whether @samp{LABEL_KIND (label) == LABEL_NORMAL}.
The only place that cares about the distinction between static, global,
and weak alternate entry points, besides the front-end code that creates
them, is the function @code{output_alternate_entry_point}, in
@file{final.c}.

To set the kind of a label, use the @code{SET_LABEL_KIND} macro.

@findex barrier
@item barrier
Barriers are placed in the instruction stream when control cannot flow
past them.  They are placed after unconditional jump instructions to
indicate that the jumps are unconditional and after calls to
@code{volatile} functions, which do not return (e.g., @code{exit}).
They contain no information beyond the three standard fields.

@findex note
@findex NOTE_LINE_NUMBER
@findex NOTE_SOURCE_FILE
@item note
@code{note} insns are used to represent additional debugging and
declarative information.  They contain two nonstandard fields, an
integer which is accessed with the macro @code{NOTE_LINE_NUMBER} and a
string accessed with @code{NOTE_SOURCE_FILE}.

If @code{NOTE_LINE_NUMBER} is positive, the note represents the
position of a source line and @code{NOTE_SOURCE_FILE} is the source file name
that the line came from.  These notes control generation of line
number data in the assembler output.

Otherwise, @code{NOTE_LINE_NUMBER} is not really a line number but a
code with one of the following values (and @code{NOTE_SOURCE_FILE}
must contain a null pointer):

@table @code
@findex NOTE_INSN_DELETED
@item NOTE_INSN_DELETED
Such a note is completely ignorable.  Some passes of the compiler
delete insns by altering them into notes of this kind.

@findex NOTE_INSN_DELETED_LABEL
@item NOTE_INSN_DELETED_LABEL
This marks what used to be a @code{code_label}, but was not used for other
purposes than taking its address and was transformed to mark that no
code jumps to it.

@findex NOTE_INSN_BLOCK_BEG
@findex NOTE_INSN_BLOCK_END
@item NOTE_INSN_BLOCK_BEG
@itemx NOTE_INSN_BLOCK_END
These types of notes indicate the position of the beginning and end
of a level of scoping of variable names.  They control the output
of debugging information.

@findex NOTE_INSN_EH_REGION_BEG
@findex NOTE_INSN_EH_REGION_END
@item NOTE_INSN_EH_REGION_BEG
@itemx NOTE_INSN_EH_REGION_END
These types of notes indicate the position of the beginning and end of a
level of scoping for exception handling.  @code{NOTE_BLOCK_NUMBER}
identifies which @code{CODE_LABEL} or @code{note} of type
@code{NOTE_INSN_DELETED_LABEL} is associated with the given region.

@findex NOTE_INSN_LOOP_BEG
@findex NOTE_INSN_LOOP_END
@item NOTE_INSN_LOOP_BEG
@itemx NOTE_INSN_LOOP_END
These types of notes indicate the position of the beginning and end
of a @code{while} or @code{for} loop.  They enable the loop optimizer
to find loops quickly.

@findex NOTE_INSN_LOOP_CONT
@item NOTE_INSN_LOOP_CONT
Appears at the place in a loop that @code{continue} statements jump to.

@findex NOTE_INSN_LOOP_VTOP
@item NOTE_INSN_LOOP_VTOP
This note indicates the place in a loop where the exit test begins for
those loops in which the exit test has been duplicated.  This position
becomes another virtual start of the loop when considering loop
invariants.

@findex NOTE_INSN_FUNCTION_BEG
@item NOTE_INSN_FUNCTION_BEG
Appears at the start of the function body, after the function
prologue.

@end table

These codes are printed symbolically when they appear in debugging dumps.
@end table

@cindex @code{TImode}, in @code{insn}
@cindex @code{HImode}, in @code{insn}
@cindex @code{QImode}, in @code{insn}
The machine mode of an insn is normally @code{VOIDmode}, but some
phases use the mode for various purposes.

The common subexpression elimination pass sets the mode of an insn to
@code{QImode} when it is the first insn in a block that has already
been processed.

The second Haifa scheduling pass, for targets that can multiple issue,
sets the mode of an insn to @code{TImode} when it is believed that the
instruction begins an issue group.  That is, when the instruction
cannot issue simultaneously with the previous.  This may be relied on
by later passes, in particular machine-dependent reorg.

Here is a table of the extra fields of @code{insn}, @code{jump_insn}
and @code{call_insn} insns:

@table @code
@findex PATTERN
@item PATTERN (@var{i})
An expression for the side effect performed by this insn.  This must be
one of the following codes: @code{set}, @code{call}, @code{use},
@code{clobber}, @code{return}, @code{asm_input}, @code{asm_output},
@code{addr_vec}, @code{addr_diff_vec}, @code{trap_if}, @code{unspec},
@code{unspec_volatile}, @code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a @code{parallel},
each element of the @code{parallel} must be one these codes, except that
@code{parallel} expressions cannot be nested and @code{addr_vec} and
@code{addr_diff_vec} are not permitted inside a @code{parallel} expression.

@findex INSN_CODE
@item INSN_CODE (@var{i})
An integer that says which pattern in the machine description matches
this insn, or @minus{}1 if the matching has not yet been attempted.

Such matching is never attempted and this field remains @minus{}1 on an insn
whose pattern consists of a single @code{use}, @code{clobber},
@code{asm_input}, @code{addr_vec} or @code{addr_diff_vec} expression.

@findex asm_noperands
Matching is also never attempted on insns that result from an @code{asm}
statement.  These contain at least one @code{asm_operands} expression.
The function @code{asm_noperands} returns a non-negative value for
such insns.

In the debugging output, this field is printed as a number followed by
a symbolic representation that locates the pattern in the @file{md}
file as some small positive or negative offset from a named pattern.

@findex LOG_LINKS
@item LOG_LINKS (@var{i})
A list (chain of @code{insn_list} expressions) giving information about
dependencies between instructions within a basic block.  Neither a jump
nor a label may come between the related insns.  These are only used by
the schedulers and by combine.  This is a deprecated data structure.
Def-use and use-def chains are now preferred. 

@findex REG_NOTES
@item REG_NOTES (@var{i})
A list (chain of @code{expr_list} and @code{insn_list} expressions)
giving miscellaneous information about the insn.  It is often
information pertaining to the registers used in this insn.
@end table

The @code{LOG_LINKS} field of an insn is a chain of @code{insn_list}
expressions.  Each of these has two operands: the first is an insn,
and the second is another @code{insn_list} expression (the next one in
the chain).  The last @code{insn_list} in the chain has a null pointer
as second operand.  The significant thing about the chain is which
insns appear in it (as first operands of @code{insn_list}
expressions).  Their order is not significant.

This list is originally set up by the flow analysis pass; it is a null
pointer until then.  Flow only adds links for those data dependencies
which can be used for instruction combination.  For each insn, the flow
analysis pass adds a link to insns which store into registers values
that are used for the first time in this insn.

The @code{REG_NOTES} field of an insn is a chain similar to the
@code{LOG_LINKS} field but it includes @code{expr_list} expressions in
addition to @code{insn_list} expressions.  There are several kinds of
register notes, which are distinguished by the machine mode, which in a
register note is really understood as being an @code{enum reg_note}.
The first operand @var{op} of the note is data whose meaning depends on
the kind of note.

@findex REG_NOTE_KIND
@findex PUT_REG_NOTE_KIND
The macro @code{REG_NOTE_KIND (@var{x})} returns the kind of
register note.  Its counterpart, the macro @code{PUT_REG_NOTE_KIND
(@var{x}, @var{newkind})} sets the register note type of @var{x} to be
@var{newkind}.

Register notes are of three classes: They may say something about an
input to an insn, they may say something about an output of an insn, or
they may create a linkage between two insns.  There are also a set
of values that are only used in @code{LOG_LINKS}.

These register notes annotate inputs to an insn:

@table @code
@findex REG_DEAD
@item REG_DEAD
The value in @var{op} dies in this insn; that is to say, altering the
value immediately after this insn would not affect the future behavior
of the program.

It does not follow that the register @var{op} has no useful value after
this insn since @var{op} is not necessarily modified by this insn.
Rather, no subsequent instruction uses the contents of @var{op}.

@findex REG_UNUSED
@item REG_UNUSED
The register @var{op} being set by this insn will not be used in a
subsequent insn.  This differs from a @code{REG_DEAD} note, which
indicates that the value in an input will not be used subsequently.
These two notes are independent; both may be present for the same
register.

@findex REG_INC
@item REG_INC
The register @var{op} is incremented (or decremented; at this level
there is no distinction) by an embedded side effect inside this insn.
This means it appears in a @code{post_inc}, @code{pre_inc},
@code{post_dec} or @code{pre_dec} expression.

@findex REG_NONNEG
@item REG_NONNEG
The register @var{op} is known to have a nonnegative value when this
insn is reached.  This is used so that decrement and branch until zero
instructions, such as the m68k dbra, can be matched.

The @code{REG_NONNEG} note is added to insns only if the machine
description has a @samp{decrement_and_branch_until_zero} pattern.

@findex REG_LABEL_OPERAND
@item REG_LABEL_OPERAND
This insn uses @var{op}, a @code{code_label} or a @code{note} of type
@code{NOTE_INSN_DELETED_LABEL}, but is not a @code{jump_insn}, or it
is a @code{jump_insn} that refers to the operand as an ordinary
operand.  The label may still eventually be a jump target, but if so
in an indirect jump in a subsequent insn.  The presence of this note
allows jump optimization to be aware that @var{op} is, in fact, being
used, and flow optimization to build an accurate flow graph.

@findex REG_LABEL_TARGET
@item REG_LABEL_TARGET
This insn is a @code{jump_insn} but not a @code{addr_vec} or
@code{addr_diff_vec}.  It uses @var{op}, a @code{code_label} as a
direct or indirect jump target.  Its purpose is similar to that of
@code{REG_LABEL_OPERAND}.  This note is only present if the insn has
multiple targets; the last label in the insn (in the highest numbered
insn-field) goes into the @code{JUMP_LABEL} field and does not have a
@code{REG_LABEL_TARGET} note.  @xref{Insns, JUMP_LABEL}.

@findex REG_CROSSING_JUMP
@item REG_CROSSING_JUMP
This insn is an branching instruction (either an unconditional jump or
an indirect jump) which crosses between hot and cold sections, which
could potentially be very far apart in the executable.  The presence
of this note indicates to other optimizations that this branching
instruction should not be ``collapsed'' into a simpler branching
construct.  It is used when the optimization to partition basic blocks
into hot and cold sections is turned on.

@findex REG_SETJMP
@item REG_SETJMP 
Appears attached to each @code{CALL_INSN} to @code{setjmp} or a 
related function.
@end table

The following notes describe attributes of outputs of an insn:

@table @code
@findex REG_EQUIV
@findex REG_EQUAL
@item REG_EQUIV
@itemx REG_EQUAL
This note is only valid on an insn that sets only one register and
indicates that that register will be equal to @var{op} at run time; the
scope of this equivalence differs between the two types of notes.  The
value which the insn explicitly copies into the register may look
different from @var{op}, but they will be equal at run time.  If the
output of the single @code{set} is a @code{strict_low_part} expression,
the note refers to the register that is contained in @code{SUBREG_REG}
of the @code{subreg} expression.

For @code{REG_EQUIV}, the register is equivalent to @var{op} throughout
the entire function, and could validly be replaced in all its
occurrences by @var{op}.  (``Validly'' here refers to the data flow of
the program; simple replacement may make some insns invalid.)  For
example, when a constant is loaded into a register that is never
assigned any other value, this kind of note is used.

When a parameter is copied into a pseudo-register at entry to a function,
a note of this kind records that the register is equivalent to the stack
slot where the parameter was passed.  Although in this case the register
may be set by other insns, it is still valid to replace the register
by the stack slot throughout the function.

A @code{REG_EQUIV} note is also used on an instruction which copies a
register parameter into a pseudo-register at entry to a function, if
there is a stack slot where that parameter could be stored.  Although
other insns may set the pseudo-register, it is valid for the compiler to
replace the pseudo-register by stack slot throughout the function,
provided the compiler ensures that the stack slot is properly
initialized by making the replacement in the initial copy instruction as
well.  This is used on machines for which the calling convention
allocates stack space for register parameters.  See
@code{REG_PARM_STACK_SPACE} in @ref{Stack Arguments}.

In the case of @code{REG_EQUAL}, the register that is set by this insn
will be equal to @var{op} at run time at the end of this insn but not
necessarily elsewhere in the function.  In this case, @var{op}
is typically an arithmetic expression.  For example, when a sequence of
insns such as a library call is used to perform an arithmetic operation,
this kind of note is attached to the insn that produces or copies the
final value.

These two notes are used in different ways by the compiler passes.
@code{REG_EQUAL} is used by passes prior to register allocation (such as
common subexpression elimination and loop optimization) to tell them how
to think of that value.  @code{REG_EQUIV} notes are used by register
allocation to indicate that there is an available substitute expression
(either a constant or a @code{mem} expression for the location of a
parameter on the stack) that may be used in place of a register if
insufficient registers are available.

Except for stack homes for parameters, which are indicated by a
@code{REG_EQUIV} note and are not useful to the early optimization
passes and pseudo registers that are equivalent to a memory location
throughout their entire life, which is not detected until later in
the compilation, all equivalences are initially indicated by an attached
@code{REG_EQUAL} note.  In the early stages of register allocation, a
@code{REG_EQUAL} note is changed into a @code{REG_EQUIV} note if
@var{op} is a constant and the insn represents the only set of its
destination register.

Thus, compiler passes prior to register allocation need only check for
@code{REG_EQUAL} notes and passes subsequent to register allocation
need only check for @code{REG_EQUIV} notes.
@end table

These notes describe linkages between insns.  They occur in pairs: one
insn has one of a pair of notes that points to a second insn, which has
the inverse note pointing back to the first insn.

@table @code
@findex REG_CC_SETTER
@findex REG_CC_USER
@item REG_CC_SETTER
@itemx REG_CC_USER
On machines that use @code{cc0}, the insns which set and use @code{cc0}
set and use @code{cc0} are adjacent.  However, when branch delay slot
filling is done, this may no longer be true.  In this case a
@code{REG_CC_USER} note will be placed on the insn setting @code{cc0} to
point to the insn using @code{cc0} and a @code{REG_CC_SETTER} note will
be placed on the insn using @code{cc0} to point to the insn setting
@code{cc0}.
@end table

These values are only used in the @code{LOG_LINKS} field, and indicate
the type of dependency that each link represents.  Links which indicate
a data dependence (a read after write dependence) do not use any code,
they simply have mode @code{VOIDmode}, and are printed without any
descriptive text.

@table @code
@findex REG_DEP_TRUE
@item REG_DEP_TRUE
This indicates a true dependence (a read after write dependence).

@findex REG_DEP_OUTPUT
@item REG_DEP_OUTPUT
This indicates an output dependence (a write after write dependence).

@findex REG_DEP_ANTI
@item REG_DEP_ANTI
This indicates an anti dependence (a write after read dependence).

@end table

These notes describe information gathered from gcov profile data.  They
are stored in the @code{REG_NOTES} field of an insn as an
@code{expr_list}.

@table @code
@findex REG_BR_PROB
@item REG_BR_PROB
This is used to specify the ratio of branches to non-branches of a
branch insn according to the profile data.  The value is stored as a
value between 0 and REG_BR_PROB_BASE; larger values indicate a higher
probability that the branch will be taken.

@findex REG_BR_PRED
@item REG_BR_PRED
These notes are found in JUMP insns after delayed branch scheduling
has taken place.  They indicate both the direction and the likelihood
of the JUMP@.  The format is a bitmask of ATTR_FLAG_* values.

@findex REG_FRAME_RELATED_EXPR
@item REG_FRAME_RELATED_EXPR
This is used on an RTX_FRAME_RELATED_P insn wherein the attached expression
is used in place of the actual insn pattern.  This is done in cases where
the pattern is either complex or misleading.
@end table

For convenience, the machine mode in an @code{insn_list} or
@code{expr_list} is printed using these symbolic codes in debugging dumps.

@findex insn_list
@findex expr_list
The only difference between the expression codes @code{insn_list} and
@code{expr_list} is that the first operand of an @code{insn_list} is
assumed to be an insn and is printed in debugging dumps as the insn's
unique id; the first operand of an @code{expr_list} is printed in the
ordinary way as an expression.

@node 函数调用
@section 函数调用insns的RTL表示
@cindex calling functions in RTL
@cindex RTL function-call insns
@cindex function-call insns

调用子程序的Insn具有RTL表达式代码@code{call_insn}。这些insn必须满足特别的规则，并且它们的主体必须使用特定的RTL表达式代码@code{call}。

@cindex @code{call} usage
@code{call}表达式有两个操作数，如下：

@smallexample
(call (mem:@var{fm} @var{addr}) @var{nbytes})
@end smallexample

@noindent
这里@var{nbytes}操作数表示传递给子程序的参数的字节数，@var{fm}是一个机器模式（其必须与在机器描述中定义的@code{FUNCTION_MODE}相等），@var{addr}表示子程序的地址。

对于子程序没有返回值的，上面所示的@code{call}表达式是insn的整个主体，除了insn可能还会包含@code{use}或@code{clobber}表达式。

@cindex @code{BLKmode}, and function return values
对于子程序返回不是@code{BLKmode}模式的值的，值通过硬件寄存器返回。如果该寄存器号为@var{r}，则call insn的主体看起来是这样的：

@smallexample
(set (reg:@var{m} @var{r})
     (call (mem:@var{fm} @var{addr}) @var{nbytes}))
@end smallexample

@noindent
该RTL表达式很清楚的说明了（对于优化阶段），在该insn中有一个适当的寄存器用来接受一个有用的值。

当子程序返回@code{BLKmode}值时，将会通过传递给子程序用来存储返回值的地址来处理。因次，call insn本身不返回任何值，具有和没有返回值一样的RTL。

在一些机器上，调用指令本身会破坏一些寄存器，例如包含了返回地址。这些机器上的@code{call_insn}应该有一个@code{parallel}主体，包含了@code{call}表达式和@code{clobber}表达式，用来指示哪些寄存器会被破坏。类似的，如果调用指令需要栈指针之外的一些寄存器，并且没有在其RTL中显示提到的，则应该用@code{use}子表达式来指出。

被调用的函数被假设为会修改列在配置宏@code{CALL_USED_REGISTERS}（@pxref{Register Basics}）中的所有寄存器，并且除了const函数和库函数调用外，被假设为会修改所有的内存。

直接在@code{call_insn}之前的只是包含了@code{use}表达式的insn，用来指示哪些寄存器用来存放函数的输入。类似的，如果不在@code{CALL_USED_REGISTERS}中那些寄存器会被所调用的函数破坏，紧跟在call之后的包含了单独的@code{clobber}的insn，用来指出这些寄存器。

@node 共享
@section 结构共享假设
@cindex sharing of RTL components
@cindex RTL structure sharing assumptions

编译器假设某些类型的RTL表达式是唯一的；不会存在两个不同的对象表示相同的值。对于其它情况，有相反的假设：在被包含的结构体中，不会在多个地方出现某一类型的RTL表达式对象。

这些假设针对于一个单独的函数；除了描述全局变量和外部函数的RTL对象，一些标准对象，例如小整形常数以外，没有其它RTL对象可以在两个函数中共用。

@itemize @bullet
@cindex @code{reg}, RTL sharing
@item
每一个伪寄存器只有一个单独的@code{reg}对象来表示，因此也只有一种机器模式。

@cindex symbolic label
@cindex @code{symbol_ref}, RTL sharing
@item
对于任何标号，只有一个@code{symbol_ref}对象关联。

@cindex @code{const_int}, RTL sharing
@item
所有具有相同值的@code{const_int}表达式被共享。

@cindex @code{pc}, RTL sharing
@item
T只有一个@code{pc}表达式。

@cindex @code{cc0}, RTL sharing
@item
只有一个@code{cc0}表达式。

@cindex @code{const_double}, RTL sharing
@item
对于每一种浮点模式，只有一个@code{const_double}表达式其值为0。同样对于值1，2。

@cindex @code{const_vector}, RTL sharing
@item
对于每一种向量模式，只有一个@code{const_vector}表达式其值为0。其为整数或者双精度常量向量。

@cindex @code{label_ref}, RTL sharing
@cindex @code{scratch}, RTL sharing
@item
在RTL结构体中不会在多个地方出现@code{label_ref}或@code{scratch}；换句话说，对函数中所有insn进行树遍历时，可以认为每次遇到的@code{label_ref}或者@code{scratch}都与在其它地方遇到的不同。

@cindex @code{mem}, RTL sharing
@item
Only one @code{mem} object is normally created for each static
variable or stack slot, so these objects are frequently shared in all
the places they appear.  However, separate but equal objects for these
variables are occasionally made.

@cindex @code{asm_operands}, RTL sharing
@item
当一个单独的@code{asm}语句具有多个输出操作数时，会为每一个输出数创建一个不同的@code{asm_operands}表达式。然后，这些表达式都共享包含着输入操作数序列的向量。这是为了之后用于测试两个@code{asm_operands}表达式是否来自同一语句，所以，所有的优化当进行复制整个向量时，必须仔细保持共享。

@item
除了上面描述的以外，在RTL结构体中没有其它RTL对象会出现多次。编译器的许多遍扫描，都是依赖于这样的假设，即它们能在一个地方修改RTL对象，并且不会对其它insn产生不需要的副作用。

@findex unshare_all_rtl
@item
在最初的RTL生成过程中，可以随意使用共享结构。当一个函数的所有RTL都被生成之后，所有的共享结构体都被@file{emit-rtl.c}中的@code{unshare_all_rtl}进行复制，之后，将保证上面的规则会被遵循。

@findex copy_rtx_if_shared
@item
在合并阶段，共享结构体可以在insn中临时存在。但是，在insn的合并完成之前，共享结构会被复制，通过调用@code{unshare_all_rtl}的子程序@code{copy_rtx_if_shared}。

@end itemize

@node 读取RTL
@section 读取RTL

若要从文件中读取RTL对象，可以调用@code{read_rtx}。
它接受一个参数，stdio标准输入输出流，并且返回一个RTL对象。
该函数在@file{read-rtl.c}中定义。
它只在通过机器描述来生成编译器后端的各种程序中使用，编译器本身并没有用到。

人们经常想到使用以文本方式存储在文件中的RTL来作为语言前端和GCC主干之间的接口。
这种想法其实是不可行的。

GCC一度被设计为只是在内部使用RTL。对于给定的程序，
RTL正确与否与特定的目标机器非常有关系。而且RTL并不包含程序的所有信息。

对于GCC和一个新语言前端接口的恰当方式，
是使用在文件@file{tree.h}和@file{tree.def}中描述的“tree”数据结构。
关于该结构的文档（参见 @ref{Trees}）不是很全面。
