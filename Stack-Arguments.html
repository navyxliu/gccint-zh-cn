<html lang="zh">
<head>
<title>Stack Arguments - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="prev" href="Elimination.html#Elimination" title="Elimination">
<link rel="next" href="Register-Arguments.html#Register-Arguments" title="Register Arguments">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Stack-Arguments"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Register-Arguments.html#Register-Arguments">Register Arguments</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Elimination.html#Elimination">Elimination</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>
<hr>
</div>

<h4 class="subsection">17.10.6 在栈上传递函数参数</h4>

<p><a name="index-arguments-on-stack-4120"></a><a name="index-stack-arguments-4121"></a>
<!-- The macros in this section control how arguments are passed -->
<!-- on the stack.  See the following section for other macros that -->
<!-- control passing certain arguments in registers. -->
该节的宏控制如何在栈上传递参数。关于控制在寄存器中传递特定参数的其它宏，参见后续的章节。

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_PROMOTE_PROTOTYPES</b> (<var>const_tree fntype</var>)<var><a name="index-TARGET_005fPROMOTE_005fPROTOTYPES-4122"></a></var><br>
<blockquote><!-- This target hook returns @code{true} if an argument declared in a -->
     <!-- prototype as an integral type smaller than @code{int} should actually be -->
     <!-- passed as an @code{int}.  In addition to avoiding errors in certain -->
     <!-- cases of mismatch, it also makes for better code on certain machines. -->
     <!-- The default is to not promote prototypes. -->
      <p>该target钩子返回<code>true</code>，如果在函数原型中声明的一个参数，为整型的并且比<code>int</code>小，应该作为<code>int</code>来传递。除了能够避免一些不匹配的错误以外，其还能在特定机器上生成更好的代码。缺省为不提升原型。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PUSH_ARGS</b><var><a name="index-PUSH_005fARGS-4123"></a></var><br>
<blockquote><!-- A C expression.  If nonzero, push insns will be used to pass -->
     <!-- outgoing arguments. -->
     <!-- If the target machine does not have a push instruction, set it to zero. -->
     <!-- That directs GCC to use an alternate strategy: to -->
     <!-- allocate the entire argument block and then store the arguments into -->
     <!-- it.  When @code{PUSH_ARGS} is nonzero, @code{PUSH_ROUNDING} must be defined too. -->
      <p>一个C表达式。如果非0，则将使用push insn来传递输出参数。如果target机器不具有push指令，则设置其为0。这将指示GCC使用替代的策略：分配整个参数块然后将参数存进去。当<code>PUSH_ARGS</code>为非0时，
<code>PUSH_ROUNDING</code>也必须被定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PUSH_ARGS_REVERSED</b><var><a name="index-PUSH_005fARGS_005fREVERSED-4124"></a></var><br>
<blockquote><!-- A C expression.  If nonzero, function arguments will be evaluated from -->
     <!-- last to first, rather than from first to last.  If this macro is not -->
     <!-- defined, it defaults to @code{PUSH_ARGS} on targets where the stack -->
     <!-- and args grow in opposite directions, and 0 otherwise. -->
      <p>一个C表达式。如果非0，则函数参数将按照从最后一个到第一个的顺序来求值，而不是从第一个到最后一个。如果该宏没被定义，其缺省为<code>PUSH_ARGS</code>，在栈和args按照相反的顺序进行增长的target上，否则为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PUSH_ROUNDING</b> (<var>npushed</var>)<var><a name="index-PUSH_005fROUNDING-4125"></a></var><br>
<blockquote><!-- A C expression that is the number of bytes actually pushed onto the -->
     <!-- stack when an instruction attempts to push @var{npushed} bytes. -->
      <p>一个C表达式，其为当一个指令试图压入<var>npushed</var>个字节时，实际压入栈中的字节数。

     <!-- On some machines, the definition -->
      <p>在一些机器上，定义

     <pre class="smallexample">          #define PUSH_ROUNDING(BYTES) (BYTES)
</pre>
      <p class="noindent"><!-- will suffice.  But on other machines, instructions that appear -->
<!-- to push one byte actually push two bytes in an attempt to maintain -->
<!-- alignment.  Then the definition should be -->
便可以满足。但是在其它机器上，指令压入一个字节时，而为了保持对齐实际压入了两个字节。则定义应该为

     <pre class="smallexample">          #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) &amp; ~1)
</pre>
      <p>If the value of this macro has a type, it should be an unsigned type. 
</p></blockquote></div>

 <p><a name="index-current_005ffunction_005foutgoing_005fargs_005fsize-4126"></a>

<div class="defun">
&mdash; Macro: <b>ACCUMULATE_OUTGOING_ARGS</b><var><a name="index-ACCUMULATE_005fOUTGOING_005fARGS-4127"></a></var><br>
<blockquote><!-- A C expression.  If nonzero, the maximum amount of space required for outgoing arguments -->
     <!-- will be computed and placed into the variable -->
     <!-- @code{current_function_outgoing_args_size}.  No space will be pushed -->
     <!-- onto the stack for each call; instead, the function prologue should -->
     <!-- increase the stack frame size by this amount. -->
      <p>一个C表达式。如果非0，则为输出参数中将被计算并放进变量<code>current_function_outgoing_args_size</code>所需要的空间最大数目。对于每个调用，将不会有空间被压入栈中；替代的，函数序言应该增加栈帧的大小。

     <!-- Setting both @code{PUSH_ARGS} and @code{ACCUMULATE_OUTGOING_ARGS} -->
     <!-- is not proper. -->
      <p>同时设置<code>PUSH_ARGS</code>和<code>ACCUMULATE_OUTGOING_ARGS</code>是不合适的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REG_PARM_STACK_SPACE</b> (<var>fndecl</var>)<var><a name="index-REG_005fPARM_005fSTACK_005fSPACE-4128"></a></var><br>
<blockquote><!-- Define this macro if functions should assume that stack space has been -->
     <!-- allocated for arguments even when their values are passed in -->
     <!-- registers. -->
      <p>定义该宏，如果函数应该假设参数的栈空间已经被分配，即使它们的值是在寄存器中被传递的。

     <!-- The value of this macro is the size, in bytes, of the area reserved for -->
     <!-- arguments passed in registers for the function represented by @var{fndecl}, -->
     <!-- which can be zero if GCC is calling a library function. -->
     <!-- The argument @var{fndecl} can be the FUNCTION_DECL, or the type itself -->
     <!-- of the function. -->
      <p>该宏的值是一个<var>fndecl</var>表示的函数在寄存器中传递的参数的保留空间的大小，字节为单位，其可以为0如果GCC在调用一个库函数。

     <!-- This space can be allocated by the caller, or be a part of the -->
     <!-- machine-dependent stack frame: @code{OUTGOING_REG_PARM_STACK_SPACE} says -->
     <!-- which. -->
      <p>该空间可以被调用者分配，或者为机器相关的栈帧的一部分：这由<code>OUTGOING_REG_PARM_STACK_SPACE</code>决定。
</p></blockquote></div>
 <!-- above is overfull.  not sure what to do.  -mew 5feb93  did -->
<!-- something, not sure if it looks good.  -mew 10feb93 -->

<div class="defun">
&mdash; Macro: <b>OUTGOING_REG_PARM_STACK_SPACE</b> (<var>fntype</var>)<var><a name="index-OUTGOING_005fREG_005fPARM_005fSTACK_005fSPACE-4129"></a></var><br>
<blockquote><!-- Define this to a nonzero value if it is the responsibility of the -->
     <!-- caller to allocate the area reserved for arguments passed in registers -->
     <!-- when calling a function of @var{fntype}.  @var{fntype} may be NULL -->
     <!-- if the function called is a library function. -->
      <p>定义该宏为一个非0值，如果分配在寄存器中传递的参数的保留空间，是由调用者负责。

     <!-- If @code{ACCUMULATE_OUTGOING_ARGS} is defined, this macro controls -->
     <!-- whether the space for these arguments counts in the value of -->
     <!-- @code{current_function_outgoing_args_size}. -->
      <p>如果<code>ACCUMULATE_OUTGOING_ARGS</code>被定义，
则该宏控制这些参数的空间是否算在<code>current_function_outgoing_args_size</code>中。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_PARMS_IN_REG_PARM_AREA</b><var><a name="index-STACK_005fPARMS_005fIN_005fREG_005fPARM_005fAREA-4130"></a></var><br>
<blockquote><!-- Define this macro if @code{REG_PARM_STACK_SPACE} is defined, but the -->
     <!-- stack parameters don't skip the area specified by it. -->
     <!-- i changed this, makes more sens and it should have taken care of the -->
     <!-- overfull.. not as specific, tho.  -mew 5feb93 -->
      <p>定义该宏，如果<code>REG_PARM_STACK_SPACE</code>被定义，但是栈参数不跳过其所指定的区域。

     <!-- Normally, when a parameter is not passed in registers, it is placed on the -->
     <!-- stack beyond the @code{REG_PARM_STACK_SPACE} area.  Defining this macro -->
     <!-- suppresses this behavior and causes the parameter to be passed on the -->
     <!-- stack in its natural location. -->
      <p>通常，当一个参数没有在寄存器中传递时，其被放在<code>REG_PARM_STACK_SPACE</code>区域之外的栈上。定义该宏来抑制这种行为并使得在栈上传递的参数按照它的自然位置。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_RETURN_POPS_ARGS</b> (<var>tree fundecl, tree funtype, int size</var>)<var><a name="index-TARGET_005fRETURN_005fPOPS_005fARGS-4131"></a></var><br>
<blockquote><p>This target hook returns the number of bytes of its own arguments that
a function pops on returning, or 0 if the function pops no arguments
and the caller must therefore pop them all after the function returns.

      <p><var>fundecl</var> is a C variable whose value is a tree node that describes
the function in question.  Normally it is a node of type
<code>FUNCTION_DECL</code> that describes the declaration of the function. 
From this you can obtain the <code>DECL_ATTRIBUTES</code> of the function.

      <p><var>funtype</var> is a C variable whose value is a tree node that
describes the function in question.  Normally it is a node of type
<code>FUNCTION_TYPE</code> that describes the data type of the function. 
From this it is possible to obtain the data types of the value and
arguments (if known).

      <p>When a call to a library function is being considered, <var>fundecl</var>
will contain an identifier node for the library function.  Thus, if
you need to distinguish among various library functions, you can do so
by their names.  Note that &ldquo;library function&rdquo; in this context means
a function used to perform arithmetic, whose name is known specially
in the compiler and was not mentioned in the C code being compiled.

      <p><var>size</var> is the number of bytes of arguments passed on the
stack.  If a variable number of bytes is passed, it is zero, and
argument popping will always be the responsibility of the calling function.

      <p>On the VAX, all functions always pop their arguments, so the definition
of this macro is <var>size</var>.  On the 68000, using the standard
calling convention, no functions pop their arguments, so the value of
the macro is always 0 in this case.  But an alternative calling
convention is available in which functions that take a fixed number of
arguments pop them but other functions (such as <code>printf</code>) pop
nothing (the caller pops all).  When this convention is in use,
<var>funtype</var> is examined to determine whether a function takes a fixed
number of arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CALL_POPS_ARGS</b> (<var>cum</var>)<var><a name="index-CALL_005fPOPS_005fARGS-4132"></a></var><br>
<blockquote><!-- A C expression that should indicate the number of bytes a call sequence -->
     <!-- pops off the stack.  It is added to the value of @code{RETURN_POPS_ARGS} -->
     <!-- when compiling a function call. -->
      <p>一个C表达式，指示一个调用序列从栈中弹出的字节数目。其被加到<code>RETURN_POPS_ARGS</code>的值中，当编译一个函数调用时。

     <!-- @var{cum} is the variable in which all arguments to the called function -->
     <!-- have been accumulated. -->
      <p><var>cum</var>为一个变量，为被调用函数的所有参数的累积。

     <!-- On certain architectures, such as the SH5, a call trampoline is used -->
     <!-- that pops certain registers off the stack, depending on the arguments -->
     <!-- that have been passed to the function.  Since this is a property of the -->
     <!-- call site, not of the called function, @code{RETURN_POPS_ARGS} is not -->
     <!-- appropriate. -->
      <p>在特定的体系结构上，例如SH5，一个调用蹦床被用于弹出栈上特定的寄存器，根据被传递给函数的参数。因为这是调用方的属性，而不是被调用函数的，所以<code>RETURN_POPS_ARGS</code>不太适合。
</p></blockquote></div>

<!-- @node Register Arguments -->
<!-- @subsection Passing Arguments in Registers -->
 </body></html>

