<html lang="zh">
<head>
<title>SSA - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tree-SSA.html#Tree-SSA" title="Tree SSA">
<link rel="prev" href="SSA-Operands.html#SSA-Operands" title="SSA Operands">
<link rel="next" href="Alias-analysis.html#Alias-analysis" title="Alias analysis">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="SSA"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Alias-analysis.html#Alias-analysis">Alias analysis</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="SSA-Operands.html#SSA-Operands">SSA Operands</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tree-SSA.html#Tree-SSA">Tree SSA</a>
<hr>
</div>

<h3 class="section">13.3 静态单赋值</h3>

<p><a name="index-SSA-3100"></a><a name="index-static-single-assignment-3101"></a>
<!-- Most of the tree optimizers rely on the data flow information provided -->
<!-- by the Static Single Assignment (SSA) form.  We implement the SSA form -->
<!-- as described in @cite{R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and -->
<!-- K. Zadeck.  Efficiently Computing Static Single Assignment Form and the -->
<!-- Control Dependence Graph.  ACM Transactions on Programming Languages -->
<!-- and Systems, 13(4):451-490, October 1991}. -->
大多数树优化器都依赖于静态单赋值（SSA）形式所提供的数据流信息。
我们是按照<cite>R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and
K. Zadeck.  Efficiently Computing Static Single Assignment Form and the
Control Dependence Graph.  ACM Transactions on Programming Languages
and Systems, 13(4):451-490, October 1991</cite>中的描述来实现SSA形式的。

<!-- The SSA form is based on the premise that program variables are -->
<!-- assigned in exactly one location in the program.  Multiple assignments -->
<!-- to the same variable create new versions of that variable.  Naturally, -->
<!-- actual programs are seldom in SSA form initially because variables -->
<!-- tend to be assigned multiple times.  The compiler modifies the program -->
<!-- representation so that every time a variable is assigned in the code, -->
<!-- a new version of the variable is created.  Different versions of the -->
<!-- same variable are distinguished by subscripting the variable name with -->
<!-- its version number.  Variables used in the right-hand side of -->
<!-- expressions are renamed so that their version number matches that of -->
<!-- the most recent assignment. -->
 <p>SSA形式基于的前提是程序变量只在程序中的一个位置被赋值。
对同一变量的多次赋值将创建那个变量的新的版本。
实际的程序最初自然很少是SSA形式的，因为变量一般会被赋值多次。
编译器修改程序表示，使得代码中每次变量被赋值的时候，便会创建一个新版本的变量。
不同版本的同一变量通过变量名字的版本号作为下标来区分开。
在表达式右端使用的变量被重命名，使得它们的版本号匹配最近的赋值。

<!-- We represent variable versions using @code{SSA_NAME} nodes.  The -->
<!-- renaming process in @file{tree-ssa.c} wraps every real and -->
<!-- virtual operand with an @code{SSA_NAME} node which contains -->
<!-- the version number and the statement that created the -->
<!-- @code{SSA_NAME}.  Only definitions and virtual definitions may -->
<!-- create new @code{SSA_NAME} nodes. -->
 <p>我们使用<code>SSA_NAME</code>节点来表示变量版本。
<samp><span class="file">tree-ssa.c</span></samp>中的重命名程序将每个实操作数和虚操作数，
用包含了版本号和创建<code>SSA_NAME</code>的语句的<code>SSA_NAME</code>节点包裹起来。
只有定义和虚定义可能会创建新的<code>SSA_NAME</code>节点。

 <p><a name="index-PHI-nodes-3102"></a><!-- Sometimes, flow of control makes it impossible to determine the -->
<!-- most recent version of a variable.  In these cases, the compiler -->
<!-- inserts an artificial definition for that variable called -->
<!-- @dfn{PHI function} or @dfn{PHI node}.  This new definition merges -->
<!-- all the incoming versions of the variable to create a new name -->
<!-- for it.  For instance, -->
有时，控制流使得无法确定变量的最近版本是多少。这种情况下，
编译器插入一个那个变量的人造定义，称作<dfn>PHI function</dfn>或者<dfn>PHI node</dfn>。
这个新的定义将变量的所有可能引入的版本合并一起，以创建一个新的名字。例如，

<pre class="smallexample">     if (...)
       a_1 = 5;
     else if (...)
       a_2 = 2;
     else
       a_3 = 13;
     
     # a_4 = PHI &lt;a_1, a_2, a_3&gt;
     return a_4;
</pre>
 <!-- Since it is not possible to determine which of the three branches -->
<!-- will be taken at runtime, we don't know which of @code{a_1}, -->
<!-- @code{a_2} or @code{a_3} to use at the return statement.  So, the -->
<!-- SSA renamer creates a new version @code{a_4} which is assigned -->
<!-- the result of ``merging'' @code{a_1}, @code{a_2} and @code{a_3}. -->
<!-- Hence, PHI nodes mean ``one of these operands.  I don't know -->
<!-- which''. -->
 <p>由于不可能确定在运行时，将运行三个分支中的哪一个，
所以我们不知道在return语句中要使用<code>a_1</code>,<code>a_2</code>或<code>a_3</code>中的哪一个。
因此，SSA重命名将会创建一个新的版本a_4，其被赋值为“合并”a_1, a_2和a_3的结果。
因此，PHI节点意味着“这些操作数中的一个，我不知道是哪一个”。

<!-- The following macros can be used to examine PHI nodes -->
 <p>下面的宏可以用来检查PHI节点。

<div class="defun">
&mdash; Macro: <b>PHI_RESULT</b> (<var>phi</var>)<var><a name="index-PHI_005fRESULT-3103"></a></var><br>
<blockquote><!-- Returns the @code{SSA_NAME} created by PHI node @var{phi} (i.e., -->
     <!-- @var{phi}'s LHS)@. -->
      <p>返回由PHI节点<var>phi</var>(即, <var>phi</var>'s LHS)创建的<code>SSA_NAME</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_NUM_ARGS</b> (<var>phi</var>)<var><a name="index-PHI_005fNUM_005fARGS-3104"></a></var><br>
<blockquote><!-- Returns the number of arguments in @var{phi}.  This number is exactly -->
     <!-- the number of incoming edges to the basic block holding @var{phi}@. -->
      <p>返回<var>phi</var>中的参数个数。这个数目就是持有<var>phi</var>的基本块所引入的边的数目。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_ARG_ELT</b> (<var>phi, i</var>)<var><a name="index-PHI_005fARG_005fELT-3105"></a></var><br>
<blockquote><!-- Returns a tuple representing the @var{i}th argument of @var{phi}@. -->
     <!-- Each element of this tuple contains an @code{SSA_NAME} @var{var} and -->
     <!-- the incoming edge through which @var{var} flows. -->
      <p>返回<var>phi</var>的第<var>i</var>个参数的tuple表示。
tuple中的每个元素包含了一个<code>SSA_NAME</code> <var>var</var>和<var>var</var>借以流向的引入边。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_ARG_EDGE</b> (<var>phi, i</var>)<var><a name="index-PHI_005fARG_005fEDGE-3106"></a></var><br>
<blockquote><!-- Returns the incoming edge for the @var{i}th argument of @var{phi}. -->
      <p>返回<var>phi</var>的第<var>i</var>个参数对应的引入边。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_ARG_DEF</b> (<var>phi, i</var>)<var><a name="index-PHI_005fARG_005fDEF-3107"></a></var><br>
<blockquote><!-- Returns the @code{SSA_NAME} for the @var{i}th argument of @var{phi}. -->
      <p>返回<var>phi</var>的第<var>i</var>个参数的<code>SSA_NAME</code>。
</p></blockquote></div>

<!-- @subsection Preserving the SSA form -->
<h4 class="subsection">13.3.1 保持SSA形式</h4>

<p><a name="index-update_005fssa-3108"></a><a name="index-preserving-SSA-form-3109"></a><!-- Some optimization passes make changes to the function that -->
<!-- invalidate the SSA property.  This can happen when a pass has -->
<!-- added new symbols or changed the program so that variables that -->
<!-- were previously aliased aren't anymore.  Whenever something like this -->
<!-- happens, the affected symbols must be renamed into SSA form again. -->
<!-- Transformations that emit new code or replicate existing statements -->
<!-- will also need to update the SSA form@. -->
一些优化过程会改变函数并使得不再具有SSA特性。
这可能会发生在当一个过程增加了新的符号或者改变了程序使得变量不再被别名的时候。
不管什么时候发生类似的情况，受到影响的符号必须被再次重命名为SSA形式。
产生新代码或者替代存在的语句的转换也需要更新SSA形式。

<!-- Since GCC implements two different SSA forms for register and virtual -->
<!-- variables, keeping the SSA form up to date depends on whether you are -->
<!-- updating register or virtual names.  In both cases, the general idea -->
<!-- behind incremental SSA updates is similar: when new SSA names are -->
<!-- created, they typically are meant to replace other existing names in -->
<!-- the program@. -->
 <p>由于GCC为寄存器和虚变量实现了两种不同的SSA形式，
所有保持SSA形式的更新取决于你是否正在更新寄存器或者虚名字。
这两种情况对于不断的SSA更新的背后思想是类似的：当新的SSA名字被创建时，
它们通常意味着要替换程序中的其它存在的名字。

<!-- For instance, given the following code: -->
 <p>例如，给定下列代码：

<pre class="smallexample">          1  L0:
          2  x_1 = PHI (0, x_5)
          3  if (x_1 &lt; 10)
          4    if (x_1 &gt; 7)
          5      y_2 = 0
          6    else
          7      y_3 = x_1 + x_7
          8    endif
          9    x_5 = x_1 + 1
          10   goto L0;
          11 endif
</pre>
 <!-- Suppose that we insert new names @code{x_10} and @code{x_11} (lines -->
<!-- @code{4} and @code{8})@. -->
 <p>假设我们插入了新的名字<code>x_10</code>和<code>x_11</code>（第<code>4</code>行和第<code>8</code>行）。

<pre class="smallexample">          1  L0:
          2  x_1 = PHI (0, x_5)
          3  if (x_1 &lt; 10)
          4    x_10 = ...
          5    if (x_1 &gt; 7)
          6      y_2 = 0
          7    else
          8      x_11 = ...
          9      y_3 = x_1 + x_7
          10   endif
          11   x_5 = x_1 + 1
          12   goto L0;
          13 endif
</pre>
 <!-- We want to replace all the uses of @code{x_1} with the new definitions -->
<!-- of @code{x_10} and @code{x_11}.  Note that the only uses that should -->
<!-- be replaced are those at lines @code{5}, @code{9} and @code{11}. -->
<!-- Also, the use of @code{x_7} at line @code{9} should @emph{not} be -->
<!-- replaced (this is why we cannot just mark symbol @code{x} for -->
<!-- renaming)@. -->
 <p>我们想使用<code>x_10</code>和<code>x_11</code>的新的定义来替换<code>x_1</code>的所有使用。
注意将要被替换的使用只在行<code>5</code>, <code>9</code>和<code>11</code>中。而且，
第<code>9</code>行<code>x_7</code>的使用不应被替换
（这就是为什么我们不能仅仅标记符号<code>x</code>为重命名）。

<!-- Additionally, we may need to insert a PHI node at line @code{11} -->
<!-- because that is a merge point for @code{x_10} and @code{x_11}.  So the -->
<!-- use of @code{x_1} at line @code{11} will be replaced with the new PHI -->
<!-- node.  The insertion of PHI nodes is optional.  They are not strictly -->
<!-- necessary to preserve the SSA form, and depending on what the caller -->
<!-- inserted, they may not even be useful for the optimizers@. -->
 <p>另外，我们可能需要在第<code>11</code>行插入一个PHI节点，
因为有一个<code>x_10</code>和<code>x_11</code>的合并点。
所以<code>x_1</code>在第<code>11</code>行的使用将用新的PHI节点来替换。
PHI节点的插入是可选的。它们并不完全必要用于保持SSA形式，
并且取决于调用者的插入内容，它们可能对优化器没有用处。

<!-- Updating the SSA form is a two step process.  First, the pass has to -->
<!-- identify which names need to be updated and/or which symbols need to -->
<!-- be renamed into SSA form for the first time.  When new names are -->
<!-- introduced to replace existing names in the program, the mapping -->
<!-- between the old and the new names are registered by calling -->
<!-- @code{register_new_name_mapping} (note that if your pass creates new -->
<!-- code by duplicating basic blocks, the call to @code{tree_duplicate_bb} -->
<!-- will set up the necessary mappings automatically).  On the other hand, -->
<!-- if your pass exposes a new symbol that should be put in SSA form for -->
<!-- the first time, the new symbol should be registered with -->
<!-- @code{mark_sym_for_renaming}. -->
 <p>更新SSA形式分为两步。首先，过程必须分别出哪些名字需要被更新，
以及哪些符号需要被重命名为SSA形式。当新的名字被引入以替换程序中现存的名字时，
新旧名字之间的映射通过调用<code>register_new_name_mapping</code>来注册
（注意如果你的过程通过复制基本块创建了新的代码，
对<code>tree_duplicate_bb</code>的调用将会自动建立所需的映射）。另一方面，
如果你的过程使得一个新的符号需要为SSA形式，
则新符号需要使用<code>mark_sym_for_renaming</code>来注册。

<!-- After the replacement mappings have been registered and new symbols -->
<!-- marked for renaming, a call to @code{update_ssa} makes the registered -->
<!-- changes.  This can be done with an explicit call or by creating -->
<!-- @code{TODO} flags in the @code{tree_opt_pass} structure for your pass. -->
<!-- There are several @code{TODO} flags that control the behavior of -->
<!-- @code{update_ssa}: -->
 <p>在替换映射被注册完，并且新符号被标记了要重命名后，
将会调用<code>update_ssa</code>来按照注册的进行改变。
这可以通过显示的调用或者为你的过程在<code>tree_opt_pass</code>结构体中创建
<code>TODO</code>标记来完成。
这里有几个<code>TODO</code>标记用于控制<code>update_ssa</code>的行为：

     <ul>
<!-- @item @code{TODO_update_ssa}.  Update the SSA form inserting PHI nodes -->
<!-- for newly exposed symbols and virtual names marked for updating. -->
<!-- When updating real names, only insert PHI nodes for a real name -->
<!-- @code{O_j} in blocks reached by all the new and old definitions for -->
<!-- @code{O_j}.  If the iterated dominance frontier for @code{O_j} -->
<!-- is not pruned, we may end up inserting PHI nodes in blocks that -->
<!-- have one or more edges with no incoming definition for -->
<!-- @code{O_j}.  This would lead to uninitialized warnings for -->
<!-- @code{O_j}'s symbol@. -->
<li><code>TODO_update_ssa</code>. 
采用为新出现的符号插入PHI节点，以及虚名字进行标记的方式更新SSA形式。
当更新实名字时，只为<code>O_j</code>的所有新旧定义所到达的块中的实名字<code>O_j</code>
插入PHI节点。如果<code>O_j</code>的迭代的dominance边界没有被截枝，
我们可以在块中危机具有一个或多个没有即来定义的<code>O_j</code>结束插入PHI节点。
这将导致对<code>O_j</code>符号的未初始化警告。

     <!-- @item @code{TODO_update_ssa_no_phi}.  Update the SSA form without -->
     <!-- inserting any new PHI nodes at all.  This is used by passes that -->
     <!-- have either inserted all the PHI nodes themselves or passes that -->
     <!-- need only to patch use-def and def-def chains for virtuals -->
     <!-- (e.g., DCE)@. -->
     <li><code>TODO_update_ssa_no_phi</code>. 
不使用插入任何新PHI节点的方式来更新SSA形式。这被用于要自己插入所有PHI节点的
过程或者只需要更新use-def和def-def链的虚名字的过程（例如，DCE）。

     <!-- @item @code{TODO_update_ssa_full_phi}.  Insert PHI nodes everywhere -->
     <!-- they are needed.  No pruning of the IDF is done.  This is used -->
     <!-- by passes that need the PHI nodes for @code{O_j} even if it -->
     <!-- means that some arguments will come from the default definition -->
     <!-- of @code{O_j}'s symbol (e.g., @code{pass_linear_transform})@. -->
     <li><code>TODO_update_ssa_full_phi</code>. 
在任何需要的地方都插入PHI节点。不进行IDF的截枝。
这被过程用于需要<code>O_j</code>的PHI节点的情况
（例如，<code>pass_linear_transform</code>）。

     <!-- WARNING: If you need to use this flag, chances are that your -->
     <!-- pass may be doing something wrong.  Inserting PHI nodes for an -->
     <!-- old name where not all edges carry a new replacement may lead to -->
     <!-- silent codegen errors or spurious uninitialized warnings@. -->
     <p>警告: 如果你需要使用这个标记，则有可能你的过程是在做一些错误的事情。
为一个旧名字插入PHI节点可能会导致沉默的codegen错误或者虚假的未初始化警告。

     <!-- @item @code{TODO_update_ssa_only_virtuals}.  Passes that update the -->
     <!-- SSA form on their own may want to delegate the updating of -->
     <!-- virtual names to the generic updater.  Since FUD chains are -->
     <!-- easier to maintain, this simplifies the work they need to do. -->
     <!-- NOTE: If this flag is used, any OLD->NEW mappings for real names -->
     <!-- are explicitly destroyed and only the symbols marked for -->
     <!-- renaming are processed@. -->
     <li><code>TODO_update_ssa_only_virtuals</code>. 
自己更新SSA的过程可能想要使用虚名字更新来代表通用的更新。因为FUD链易于维护，
所有这简化了他们所需的工作。注意：如果使用了该标记，
则任何实名字OLD-&gt;NEW的映射将被显式的破坏，只有标记为重命名的符合被处理。
</ul>

<!-- @subsection Preserving the virtual SSA form -->
<h4 class="subsection">13.3.2 保持虚SSA形式</h4>

<p><a name="index-preserving-virtual-SSA-form-3110"></a>
<!-- The virtual SSA form is harder to preserve than the non-virtual SSA form -->
<!-- mainly because the set of virtual operands for a statement may change at -->
<!-- what some would consider unexpected times.  In general, statement -->
<!-- modifications should be bracketed between calls to -->
<!-- @code{push_stmt_changes} and @code{pop_stmt_changes}.  For example, -->
虚SSA形式比非虚SSA形式要难以保持，主要是因为语句的虚操作数集可能会意外的改变。
通常，语句修改应该被对<code>push_stmt_changes</code>和<code>pop_stmt_changes</code>的调用
所包裹。例如，

<pre class="smallexample">         munge_stmt (tree stmt)
         {
            push_stmt_changes (&amp;stmt);
            ... rewrite STMT ...
            pop_stmt_changes (&amp;stmt);
         }
</pre>
 <!-- The call to @code{push_stmt_changes} saves the current state of the -->
<!-- statement operands and the call to @code{pop_stmt_changes} compares -->
<!-- the saved state with the current one and does the appropriate symbol -->
<!-- marking for the SSA renamer. -->
 <p>对<code>push_stmt_changes</code>的调用保存了语句操作数的当前状态，
对<code>pop_stmt_changes</code>的调用比较保存的状态和现在的，
并对适当的符号标记为SSA重命名。

<!-- It is possible to modify several statements at a time, provided that -->
<!-- @code{push_stmt_changes} and @code{pop_stmt_changes} are called in -->
<!-- LIFO order, as when processing a stack of statements. -->
 <p>当处理一个语句栈时，通过使用LIFO顺序来调用<code>push_stmt_changes</code>和
<code>pop_stmt_changes</code>，可以一次修改多条语句。

<!-- Additionally, if the pass discovers that it did not need to make -->
<!-- changes to the statement after calling @code{push_stmt_changes}, it -->
<!-- can simply discard the topmost change buffer by calling -->
<!-- @code{discard_stmt_changes}.  This will avoid the expensive operand -->
<!-- re-scan operation and the buffer comparison that determines if symbols -->
<!-- need to be marked for renaming. -->
 <p>另外，如果过程在调用<code>push_stmt_changes</code>后发现它不需要改变语句，
它可以通过调用<code>discard_stmt_changes</code>来简单的丢弃最顶层的缓存。
这将避免用来确定是否符合需要被标记为重命名所需的昂贵的操作数重扫描操作和缓存比较。

<!-- @subsection Examining @code{SSA_NAME} nodes -->
<h4 class="subsection">13.3.3 检验<code>SSA_NAME</code>节点</h4>

<p><a name="index-examining-SSA_005fNAMEs-3111"></a>
<!-- The following macros can be used to examine @code{SSA_NAME} nodes -->
下面的宏可以用来检查<code>SSA_NAME</code>节点

<div class="defun">
&mdash; Macro: <b>SSA_NAME_DEF_STMT</b> (<var>var</var>)<var><a name="index-SSA_005fNAME_005fDEF_005fSTMT-3112"></a></var><br>
<blockquote><!-- Returns the statement @var{s} that creates the @code{SSA_NAME} -->
     <!-- @var{var}.  If @var{s} is an empty statement (i.e., @code{IS_EMPTY_STMT -->
     <!-- (@var{s})} returns @code{true}), it means that the first reference to -->
     <!-- this variable is a USE or a VUSE@. -->
      <p>返回创建<code>SSA_NAME</code> <var>var</var>的语句<var>s</var>。
如过<var>s</var>是空语句（即，<code>IS_EMPTY_STMT (</code><var>s</var><code>)</code>返回<code>true</code>），
则意味着对该变量的第一个引用是一个USE或者VUSE。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SSA_NAME_VERSION</b> (<var>var</var>)<var><a name="index-SSA_005fNAME_005fVERSION-3113"></a></var><br>
<blockquote><!-- Returns the version number of the @code{SSA_NAME} object @var{var}. -->
      <p>返回<code>SSA_NAME</code>对象<var>var</var>的版本号。
</p></blockquote></div>

<!-- @subsection Walking use-def chains -->
<h4 class="subsection">13.3.4 遍历use-def链</h4>

<div class="defun">
&mdash; Tree SSA function: void <b>walk_use_def_chains</b> (<var>var, fn, data</var>)<var><a name="index-walk_005fuse_005fdef_005fchains-3114"></a></var><br>
<blockquote>
     <!-- Walks use-def chains starting at the @code{SSA_NAME} node @var{var}. -->
     <!-- Calls function @var{fn} at each reaching definition found.  Function -->
     <!-- @var{FN} takes three arguments: @var{var}, its defining statement -->
     <!-- (@var{def_stmt}) and a generic pointer to whatever state information -->
     <!-- that @var{fn} may want to maintain (@var{data}).  Function @var{fn} is -->
     <!-- able to stop the walk by returning @code{true}, otherwise in order to -->
     <!-- continue the walk, @var{fn} should return @code{false}. -->
      <p>对use-def链的遍历起始于<code>SSA_NAME</code>节点<var>var</var>。
对每一个发现的可达定义调用函数<var>fn</var>。函数<var>fn</var>接受三个参数：<var>var</var>，
它的定义语句（<var>def_stmt</var>）和一个通用指针指向<var>fn</var>可能想要维护的任何状态
信息（数据）。函数<var>fn</var>可以通过返回<code>true</code>来停止遍历，否则要继续遍历，
<var>fn</var>应该返回<code>false</code>。

     <!-- Note, that if @var{def_stmt} is a @code{PHI} node, the semantics are -->
     <!-- slightly different.  For each argument @var{arg} of the PHI node, this -->
     <!-- function will: -->
      <p>注意，如果<var>def_stmt</var>是一个<code>PHI</code>节点，则语法有点不同。
对PHI节点的每个参数<var>arg</var>，该函数将：

          <ol type=1 start=1>
<!-- @item Walk the use-def chains for @var{arg}. -->
<li>为<var>arg</var>遍历use-def链
<!-- @item Call @code{FN (@var{arg}, @var{phi}, @var{data})}. -->
<li>调用<code>FN (</code><var>arg</var><code>, </code><var>phi</var><code>, </code><var>data</var><code>)</code>.
           </ol>

     <!-- Note how the first argument to @var{fn} is no longer the original -->
     <!-- variable @var{var}, but the PHI argument currently being examined. -->
     <!-- If @var{fn} wants to get at @var{var}, it should call -->
     <!-- @code{PHI_RESULT} (@var{phi}). -->
      <p>注意不管<var>fn</var>的第一个是否还是最初的变量<var>var</var>，目前都会检测PHI的参数。
如果<var>fn</var>想获得<var>var</var>，则应该调用<code>PHI_RESULT</code> (<var>phi</var>)。
</p></blockquote></div>

<!-- @subsection Walking the dominator tree -->
<h4 class="subsection">13.3.5 遍历支配树</h4>

<div class="defun">
&mdash; Tree SSA function: void <b>walk_dominator_tree</b> (<var>walk_data, bb</var>)<var><a name="index-walk_005fdominator_005ftree-3115"></a></var><br>
<blockquote>
     <!-- This function walks the dominator tree for the current CFG calling a -->
     <!-- set of callback functions defined in @var{struct dom_walk_data} in -->
     <!-- @file{domwalk.h}.  The call back functions you need to define give you -->
     <!-- hooks to execute custom code at various points during traversal: -->
      <p>该函数遍历当前CFG的支配树，
并调用在<samp><span class="file">domwalk.h</span></samp>中<var>struct dom_walk_data</var>里定义的一系列回调函数。
你所需要定义的回调函数可以用于在遍历过程中的不同点执行自定义的代码：

          <ol type=1 start=1>
<!-- @item Once to initialize any local data needed while processing -->
<!-- @var{bb} and its children.  This local data is pushed into an -->
<!-- internal stack which is automatically pushed and popped as the -->
<!-- walker traverses the dominator tree. -->
<li>当处理<var>bb</var>和它的孩子（children）时，在初始化所需要的任何局部数据的时候。
该局部数据被压入一个内部的栈中，该栈在遍历支配树时会被自动的压入和弹出。

          <!-- @item Once before traversing all the statements in the @var{bb}. -->
          <li>在遍历<var>bb</var>中的所有语句之前。

          <!-- @item Once for every statement inside @var{bb}. -->
          <li>对于<var>bb</var>中的每条语句。

          <!-- @item Once after traversing all the statements and before recursing -->
          <!-- into @var{bb}'s dominator children. -->
          <li>当遍历过所有语句之后，并在递归到<var>bb</var>的支配孩子之前。

          <!-- @item It then recurses into all the dominator children of @var{bb}. -->
          <li>然后递归到<var>bb</var>的所有支配孩子。

          <!-- @item After recursing into all the dominator children of @var{bb} it -->
          <!-- can, optionally, traverse every statement in @var{bb} again -->
          <!-- (i.e., repeating steps 2 and 3). -->
          <li>在递归到<var>bb</var>的所有支配孩子之后，可选的，
重新遍历<var>bb</var>中的每条语句（即，重复步骤2和3）。

          <!-- @item Once after walking the statements in @var{bb} and @var{bb}'s -->
          <!-- dominator children.  At this stage, the block local data stack -->
          <!-- is popped. -->
          <li>当遍历完<var>bb</var>和<var>bb</var>的支配孩子中的所有语句之后。这时，块局部数据栈被弹出。
           </ol>
</p></blockquote></div>

<!-- @node Alias analysis -->
<!-- @section Alias analysis -->
 </body></html>

