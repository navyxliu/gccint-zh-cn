<html lang="zh">
<head>
<title>Arithmetic - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="Regs-and-Memory.html#Regs-and-Memory" title="Regs and Memory">
<link rel="next" href="Comparisons.html#Comparisons" title="Comparisons">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Arithmetic"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Comparisons.html#Comparisons">Comparisons</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Regs-and-Memory.html#Regs-and-Memory">Regs and Memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.9 RTL算术运算表达式</h3>

<p><a name="index-arithmetic_002c-in-RTL-2033"></a><a name="index-math_002c-in-RTL-2034"></a><a name="index-RTL-expressions-for-arithmetic-2035"></a>
<!-- Unless otherwise specified, all the operands of arithmetic expressions -->
<!-- must be valid for mode @var{m}.  An operand is valid for mode @var{m} -->
<!-- if it has mode @var{m}, or if it is a @code{const_int} or -->
<!-- @code{const_double} and @var{m} is a mode of class @code{MODE_INT}. -->
除非其它规定，所有算术表达式的操作数必须对模式<var>m</var>有效。一个操作数对模式<var>m</var>有效，是指当它具有模式<var>m</var>，或者如果它是一个<code>const_int</code>或者<code>const_double</code>，并且<var>m</var>是一个<code>MODE_INT</code>类的模式。

<!-- For commutative binary operations, constants should be placed in the -->
<!-- second operand. -->
 <p>对于可交换的二进制操作，常量应该放到第二个操作数的位置。

     
<a name="index-plus-2036"></a>
<a name="index-ss_005fplus-2037"></a>
<a name="index-us_005fplus-2038"></a>
<a name="index-RTL-sum-2039"></a>
<a name="index-RTL-addition-2040"></a>
<a name="index-RTL-addition-with-signed-saturation-2041"></a>
<a name="index-RTL-addition-with-unsigned-saturation-2042"></a>
<dl><dt><code>(plus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_plus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_plus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- These three expressions all represent the sum of the values -->
<!-- represented by @var{x} and @var{y} carried out in machine mode -->
<!-- @var{m}.  They differ in their behavior on overflow of integer modes. -->
<!-- @code{plus} wraps round modulo the width of @var{m}; @code{ss_plus} -->
<!-- saturates at the maximum signed value representable in @var{m}; -->
<!-- @code{us_plus} saturates at the maximum unsigned value. -->
这三个表达式都表示<var>x</var>和<var>y</var>所表示的值的和，机器模式为<var>m</var>。它们在整数机器模式的溢出方面有所不同。<code>plus</code>以<var>m</var>的宽度求模进行环绕；<code>ss_plus</code>饱和为<var>m</var>可表示的有符号最大值；<code>us_plus</code>饱和为无符号最大值。

     <!-- ??? What happens on overflow of floating point modes? -->
     <p><a name="index-lo_005fsum-2043"></a><br><dt><code>(lo_sum:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- This expression represents the sum of @var{x} and the low-order bits -->
<!-- of @var{y}.  It is used with @code{high} (@pxref{Constants}) to -->
<!-- represent the typical two-instruction sequence used in RISC machines -->
<!-- to reference a global memory location. -->
该表达式表示<var>x</var>与<var>y</var>低位的和。其跟<code>high</code> (参见<a href="Constants.html#Constants">Constants</a>)一起使用，来表示在RISC机器中通常使用的两个指令序列，来引用一个全局内存位置。

     <!-- The number of low order bits is machine-dependent but is -->
     <!-- normally the number of bits in a @code{Pmode} item minus the number of -->
     <!-- bits set by @code{high}. -->
     <p>低位的位数是机器相关的，但通常为<code>Pmode</code>中的位数减去<code>high</code>所设置的位数。

     <!-- @var{m} should be @code{Pmode}. -->
     <p><var>m</var>应该为<code>Pmode</code>。

     <p><a name="index-minus-2044"></a><a name="index-ss_005fminus-2045"></a><a name="index-us_005fminus-2046"></a><a name="index-RTL-difference-2047"></a><a name="index-RTL-subtraction-2048"></a><a name="index-RTL-subtraction-with-signed-saturation-2049"></a><a name="index-RTL-subtraction-with-unsigned-saturation-2050"></a><br><dt><code>(minus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_minus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_minus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>
<!-- These three expressions represent the result of subtracting @var{y} -->
<!-- from @var{x}, carried out in mode @var{M}.  Behavior on overflow is -->
<!-- the same as for the three variants of @code{plus} (see above). -->
这三个表达式表示从<var>x</var>中减去<var>y</var>的结果，机器模式为<var>m</var>。在溢出方面的行为与<code>plus</code>的三种版本相同（参见上面）。

     <p><a name="index-compare-2051"></a><a name="index-RTL-comparison-2052"></a><br><dt><code>(compare:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Represents the result of subtracting @var{y} from @var{x} for purposes -->
<!-- of comparison.  The result is computed without overflow, as if with -->
<!-- infinite precision. -->
表示从<var>x</var>中减去<var>y</var>的结果，用于进行比较。计算结果不产生溢出，就好像是有无限的精度一样。

     <!-- Of course, machines can't really subtract with infinite precision. -->
     <!-- However, they can pretend to do so when only the sign of the result will -->
     <!-- be used, which is the case when the result is stored in the condition -->
     <!-- code.  And that is the @emph{only} way this kind of expression may -->
     <!-- validly be used: as a value to be stored in the condition codes, either -->
     <!-- @code{(cc0)} or a register.  @xref{Comparisons}. -->
     <p>当然，机器不会真的进行无限精度的减法。然而，它们可以假定这样做，当只使用结果的正负符号时，这样情况下，结果被存放在条件代码中。并且，这是这种表达式唯一可以被使用的方式：作为值存储在条件代码中，或者<code>(cc0)</code>，或者一个寄存器。参见<a href="Comparisons.html#Comparisons">Comparisons</a>.

     <!-- The mode @var{m} is not related to the modes of @var{x} and @var{y}, but -->
     <!-- instead is the mode of the condition code value.  If @code{(cc0)} is -->
     <!-- used, it is @code{VOIDmode}.  Otherwise it is some mode in class -->
     <!-- @code{MODE_CC}, often @code{CCmode}.  @xref{Condition Code}.  If @var{m} -->
     <!-- is @code{VOIDmode} or @code{CCmode}, the operation returns sufficient -->
     <!-- information (in an unspecified format) so that any comparison operator -->
     <!-- can be applied to the result of the @code{COMPARE} operation.  For other -->
     <!-- modes in class @code{MODE_CC}, the operation only returns a subset of -->
     <!-- this information. -->
     <p>机器模式<var>m</var>与<var>x</var>和<var>y</var>的机器模式没有关联，而是条件代码值的机器模式。如果使用<code>(cc0)</code>，则为<code>VOIDmode</code>，否则为类别<code>MODE_CC</code>中的某个模式，通常为<code>CCmode</code>。参见<a href="Condition-Code.html#Condition-Code">Condition Code</a>. 如果<var>m</var>为<code>VOIDmode</code>或者<code>CCmode</code>，则运算会返回足够的信息，使得任何比较运算符可以被应用到<code>COMPARE</code>运算的结果上。对于类别<code>MODE_CC</code>中的其它机器模式，运算只返回信息的子集。

     <!-- Normally, @var{x} and @var{y} must have the same mode.  Otherwise, -->
     <!-- @code{compare} is valid only if the mode of @var{x} is in class -->
     <!-- @code{MODE_INT} and @var{y} is a @code{const_int} or -->
     <!-- @code{const_double} with mode @code{VOIDmode}.  The mode of @var{x} -->
     <!-- determines what mode the comparison is to be done in; thus it must not -->
     <!-- be @code{VOIDmode}. -->
     <p>通常，<var>x</var>和<var>y</var>必须具有相同的机器模式。否则，<code>compare</code>只有当<var>x</var>的机器模式在类别<code>MODE_INT</code>中，并且<var>y</var>为一个机器模式为<code>VOIDmode</code>的<code>const_int</code>或者<code>const_double</code>，这时才有效。<var>x</var>的机器模式决定了比较按照什么机器模式进行；因此其不能为<code>VOIDmode</code>。

     <!-- If one of the operands is a constant, it should be placed in the -->
     <!-- second operand and the comparison code adjusted as appropriate. -->
     <p>如果其中一个操作数为常量，则其应该被放在第二个操作数的位置，并且相应的调整比较代码。

     <!-- A @code{compare} specifying two @code{VOIDmode} constants is not valid -->
     <!-- since there is no way to know in what mode the comparison is to be -->
     <!-- performed; the comparison must either be folded during the compilation -->
     <!-- or the first operand must be loaded into a register while its mode is -->
     <!-- still known. -->
     <p>指定两个<code>VOIDmode</code>常量的<code>compare</code>是无效的，因为无法知道比较要按照什么机器模式进行；比较必须或者在编译过程中被折叠，或者第一个操作数必须被加载到机器模式已知的寄存器中。

     <p><a name="index-neg-2053"></a><a name="index-ss_005fneg-2054"></a><a name="index-us_005fneg-2055"></a><a name="index-negation-2056"></a><a name="index-negation-with-signed-saturation-2057"></a><a name="index-negation-with-unsigned-saturation-2058"></a><br><dt><code>(neg:</code><var>m</var> <var>x</var><code>)</code><dt><code>(ss_neg:</code><var>m</var> <var>x</var><code>)</code><dt><code>(us_neg:</code><var>m</var> <var>x</var><code>)</code><dd><!-- These two expressions represent the negation (subtraction from zero) of -->
<!-- the value represented by @var{x}, carried out in mode @var{m}.  They -->
<!-- differ in the behavior on overflow of integer modes.  In the case of -->
<!-- @code{neg}, the negation of the operand may be a number not representable -->
<!-- in mode @var{m}, in which case it is truncated to @var{m}.  @code{ss_neg} -->
<!-- and @code{us_neg} ensure that an out-of-bounds result saturates to the -->
<!-- maximum or minimum signed or unsigned value. -->
这两个表达式表示<var>x</var>所表示的值的负数（零减去该值），机器模式为<var>m</var>。它们在整数机器模式的溢出行为上有所不同。对于<code>neg</code>，操作数的负数可以为无法用机器模式<var>m</var>表示的数，这种情况下，其被截取为<var>m</var>。<code>ss_neg</code>和<code>us_neg</code>确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

     <p><a name="index-mult-2059"></a><a name="index-ss_005fmult-2060"></a><a name="index-us_005fmult-2061"></a><a name="index-multiplication-2062"></a><a name="index-product-2063"></a><a name="index-multiplication-with-signed-saturation-2064"></a><a name="index-multiplication-with-unsigned-saturation-2065"></a><br><dt><code>(mult:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_mult:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_mult:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Represents the signed product of the values represented by @var{x} and -->
<!-- @var{y} carried out in machine mode @var{m}. -->
<!-- @code{ss_mult} and @code{us_mult} ensure that an out-of-bounds result -->
<!-- saturates to the maximum or minimum signed or unsigned value. -->
表示<var>x</var>和<var>y</var>所表示的值的有符号乘积，机器模式为<var>m</var>。<code>ss_mult</code>和<code>us_mult</code>确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

     <!-- Some machines support a multiplication that generates a product wider -->
     <!-- than the operands.  Write the pattern for this as -->
     <p>一些机器支持产生比操作数更宽的乘积。则指令模式可以写成

     <pre class="smallexample">          (mult:<var>m</var> (sign_extend:<var>m</var> <var>x</var>) (sign_extend:<var>m</var> <var>y</var>))
</pre>
     <!-- where @var{m} is wider than the modes of @var{x} and @var{y}, which need -->
     <!-- not be the same. -->
     <p>其中<var>m</var>比<var>x</var>和<var>y</var>的机器模式更宽。

     <!-- For unsigned widening multiplication, use the same idiom, but with -->
     <!-- @code{zero_extend} instead of @code{sign_extend}. -->
     <p>对于无符号的加宽的乘法，使用相同的语句，只不过把<code>sign_extend</code>替换成<code>zero_extend</code>。

     <p><a name="index-fma-2066"></a><br><dt><code>(fma:</code><var>m</var> <var>x</var> <var>y</var> <var>z</var><code>)</code><dd>Represents the <code>fma</code>, <code>fmaf</code>, and <code>fmal</code> builtin
functions that do a combined multiply of <var>x</var> and <var>y</var> and then
adding to<var>z</var> without doing an intermediate rounding step.

     <p><a name="index-div-2067"></a><a name="index-ss_005fdiv-2068"></a><a name="index-division-2069"></a><a name="index-signed-division-2070"></a><a name="index-signed-division-with-signed-saturation-2071"></a><a name="index-quotient-2072"></a><br><dt><code>(div:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_div:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Represents the quotient in signed division of @var{x} by @var{y}, -->
<!-- carried out in machine mode @var{m}.  If @var{m} is a floating point -->
<!-- mode, it represents the exact quotient; otherwise, the integerized -->
<!-- quotient. -->
<!-- @code{ss_div} ensures that an out-of-bounds result saturates to the maximum -->
<!-- or minimum signed value. -->
表示<var>x</var>有符号除以<var>y</var>的商，机器模式为<var>m</var>。如果<var>m</var>为一个浮点机器模式，则表示确切的商；否则为整数化的商。<code>ss_div</code>确保超出边界的结果饱和为最大或者最小的有符号值。

     <!-- Some machines have division instructions in which the operands and -->
     <!-- quotient widths are not all the same; you should represent -->
     <!-- such instructions using @code{truncate} and @code{sign_extend} as in, -->
     <p>一些机器具有的除法指令，其操作数和商的宽度不全相同；你应该使用<code>truncate</code>和<code>sign_extend</code>来表示这样的指令，

     <pre class="smallexample">          (truncate:<var>m1</var> (div:<var>m2</var> <var>x</var> (sign_extend:<var>m2</var> <var>y</var>)))
</pre>
     <p><a name="index-udiv-2073"></a><a name="index-unsigned-division-2074"></a><a name="index-unsigned-division-with-unsigned-saturation-2075"></a><a name="index-division-2076"></a><br><dt><code>(udiv:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_div:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Like @code{div} but represents unsigned division. -->
<!-- @code{us_div} ensures that an out-of-bounds result saturates to the maximum -->
<!-- or minimum unsigned value. -->
类似<code>div</code>，不过表示无符号除法。<code>us_div</code>确保超出边界的结果饱和为最大或者最小的无符号值。

     <p><a name="index-mod-2077"></a><a name="index-umod-2078"></a><a name="index-remainder-2079"></a><a name="index-division-2080"></a><br><dt><code>(mod:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(umod:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Like @code{div} and @code{udiv} but represent the remainder instead of -->
<!-- the quotient. -->
类似<code>div</code>和<code>udiv</code>，不过表示余数。

     <p><a name="index-smin-2081"></a><a name="index-smax-2082"></a><a name="index-signed-minimum-2083"></a><a name="index-signed-maximum-2084"></a><br><dt><code>(smin:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(smax:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Represents the smaller (for @code{smin}) or larger (for @code{smax}) of -->
<!-- @var{x} and @var{y}, interpreted as signed values in mode @var{m}. -->
<!-- When used with floating point, if both operands are zeros, or if either -->
<!-- operand is @code{NaN}, then it is unspecified which of the two operands -->
<!-- is returned as the result. -->
表示<var>x</var>和<var>y</var>的较小值（<code>smin</code>）或者较大值（<code>smax</code>），按照机器模式为<var>m</var>的有符号值解析。当用于浮点，如果两个操作数都为零，或者其中一个为<code>NaN</code>，则没有规定哪一个操作数被作为结果返回。

     <p><a name="index-umin-2085"></a><a name="index-umax-2086"></a><a name="index-unsigned-minimum-and-maximum-2087"></a><br><dt><code>(umin:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(umax:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Like @code{smin} and @code{smax}, but the values are interpreted as unsigned -->
<!-- integers. -->
类似<code>smin</code>和<code>smax</code>，不过值被解析为无符号整数。

     <p><a name="index-not-2088"></a><a name="index-complement_002c-bitwise-2089"></a><a name="index-bitwise-complement-2090"></a><br><dt><code>(not:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the bitwise complement of the value represented by @var{x}, -->
<!-- carried out in mode @var{m}, which must be a fixed-point machine mode. -->
表示对<var>x</var>所表示的值进行按位求补，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-and-2091"></a><a name="index-logical_002dand_002c-bitwise-2092"></a><a name="index-bitwise-logical_002dand-2093"></a><br><dt><code>(and:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Represents the bitwise logical-and of the values represented by -->
<!-- @var{x} and @var{y}, carried out in machine mode @var{m}, which must be -->
<!-- a fixed-point machine mode. -->
表示对<var>x</var>和<var>y</var>所表示的值按位进行逻辑与，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-ior-2094"></a><a name="index-inclusive_002dor_002c-bitwise-2095"></a><a name="index-bitwise-inclusive_002dor-2096"></a><br><dt><code>(ior:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Represents the bitwise inclusive-or of the values represented by @var{x} -->
<!-- and @var{y}, carried out in machine mode @var{m}, which must be a -->
<!-- fixed-point mode. -->
表示对<var>x</var>和<var>y</var>所表示的值按位进行逻辑或，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-xor-2097"></a><a name="index-exclusive_002dor_002c-bitwise-2098"></a><a name="index-bitwise-exclusive_002dor-2099"></a><br><dt><code>(xor:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Represents the bitwise exclusive-or of the values represented by @var{x} -->
<!-- and @var{y}, carried out in machine mode @var{m}, which must be a -->
<!-- fixed-point mode. -->
表示对<var>x</var>和<var>y</var>所表示的值按位进行逻辑异或，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-ashift-2100"></a><a name="index-ss_005fashift-2101"></a><a name="index-us_005fashift-2102"></a><a name="index-left-shift-2103"></a><a name="index-shift-2104"></a><a name="index-arithmetic-shift-2105"></a><a name="index-arithmetic-shift-with-signed-saturation-2106"></a><a name="index-arithmetic-shift-with-unsigned-saturation-2107"></a><br><dt><code>(ashift:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(ss_ashift:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(us_ashift:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dd><!-- These three expressions represent the result of arithmetically shifting @var{x} -->
<!-- left by @var{c} places.  They differ in their behavior on overflow of integer -->
<!-- modes.  An @code{ashift} operation is a plain shift with no special behavior -->
<!-- in case of a change in the sign bit; @code{ss_ashift} and @code{us_ashift} -->
<!-- saturates to the minimum or maximum representable value if any of the bits -->
<!-- shifted out differs from the final sign bit. -->
这三个表达式用来表示对<var>x</var>进行向左算术移位<var>c</var>。它们在整数机器模式的溢出方面有所不同。<code>ashift</code>运算是一个普通的移位，当符号位有改变时，其没有特殊的行为；<code>ss_ashift</code>和<code>us_ashift</code>，饱和为可表示的最小或者最大值，如果任何被移出的位与最终的符号位不同。

     <!-- @var{x} have mode @var{m}, a fixed-point machine mode.  @var{c} -->
     <!-- be a fixed-point mode or be a constant with mode @code{VOIDmode}; which -->
     <!-- mode is determined by the mode called for in the machine description -->
     <!-- entry for the left-shift instruction.  For example, on the VAX, the mode -->
     <!-- of @var{c} is @code{QImode} regardless of @var{m}. -->
     <p><var>x</var>具有机器模式<var>m</var>，一个定点机器模式。<var>c</var>为一个定点机器模式或者一个模式为<code>VOIDmode</code>的常量。

     <p><a name="index-lshiftrt-2108"></a><a name="index-right-shift-2109"></a><a name="index-ashiftrt-2110"></a><br><dt><code>(lshiftrt:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(ashiftrt:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dd><!-- Like @code{ashift} but for right shift.  Unlike the case for left shift, -->
<!-- these two operations are distinct. -->
类似于<code>ashift</code>，不过是向右移位。不像向左移位的情况，这两种运算是有区别的。

     <p><a name="index-rotate-2111"></a><a name="index-rotate-2112"></a><a name="index-left-rotate-2113"></a><a name="index-rotatert-2114"></a><a name="index-right-rotate-2115"></a><br><dt><code>(rotate:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(rotatert:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dd><!-- Similar but represent left and right rotate.  If @var{c} is a constant, -->
<!-- use @code{rotate}. -->
类似的，只不过是表示向左和向右旋转。如果<var>c</var>为常量，则使用<code>rotate</code>。

     <p><a name="index-abs-2116"></a><a name="index-ss_005fabs-2117"></a><a name="index-absolute-value-2118"></a><br><dt><code>(abs:</code><var>m</var> <var>x</var><code>)</code><br><dt><code>(ss_abs:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the absolute value of @var{x}, computed in mode @var{m}. -->
<!-- @code{ss_abs} ensures that an out-of-bounds result saturates to the -->
<!-- maximum signed value. -->
表示<var>x</var>的绝对值，按照机器模式<var>m</var>来计算。

     <p><a name="index-sqrt-2119"></a><a name="index-square-root-2120"></a><br><dt><code>(sqrt:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the square root of @var{x}, computed in mode @var{m}. -->
<!-- Most often @var{m} will be a floating point mode. -->
表示<var>x</var>的平方根，按照机器模式<var>m</var>来计算。<var>m</var>通常为浮点机器模式。

     <p><a name="index-ffs-2121"></a><br><dt><code>(ffs:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents one plus the index of the least significant 1-bit in -->
<!-- @var{x}, represented as an integer of mode @var{m}.  (The value is -->
<!-- zero if @var{x} is zero.)  The mode of @var{x} must be @var{m} -->
<!-- or @code{VOIDmode}. -->
表示在<var>x</var>中，最低有效，位为1的索引加上1，为一个模式<var>m</var>的整数。（如果<var>x</var>为零，则值为零。）<var>x</var>的机器模式一定为<var>m</var>或者 <code>VOIDmode</code>。

     <p><a name="index-clrsb-2122"></a><br><dt><code>(clrsb:</code><var>m</var> <var>x</var><code>)</code><dd>Represents the number of redundant leading sign bits in <var>x</var>,
represented as an integer of mode <var>m</var>, starting at the most
significant bit position.  This is one less than the number of leading
sign bits (either 0 or 1), with no special cases.  The mode of <var>x</var>
must be <var>m</var> or <code>VOIDmode</code>.

     <p><a name="index-clz-2123"></a><br><dt><code>(clz:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the number of leading 0-bits in @var{x}, represented as an -->
<!-- integer of mode @var{m}, starting at the most significant bit position. -->
<!-- If @var{x} is zero, the value is determined by -->
<code>CLZ_DEFINED_VALUE_AT_ZERO</code> (参见<a href="Misc.html#Misc">Misc</a>).  Note that this is one of
<!-- the few expressions that is not invariant under widening.  The mode of -->
<!-- @var{x} must be @var{m} or @code{VOIDmode}. -->
表示<var>x</var>中，从最高有效位开始，起始处为0的位数，为一个模式<var>m</var>的整数。如果<var>x</var>为零，则值由<code>CLZ_DEFINED_VALUE_AT_ZERO</code>
(参见<a href="Misc.html#Misc">Misc</a>)来确定。注意，。<var>x</var>的机器模式通常为<var>m</var> 或者 <code>VOIDmode</code>。

     <p><a name="index-ctz-2124"></a><br><dt><code>(ctz:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the number of trailing 0-bits in @var{x}, represented as an -->
<!-- integer of mode @var{m}, starting at the least significant bit position. -->
<!-- If @var{x} is zero, the value is determined by -->
<!-- @code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}).  Except for this case, -->
<!-- @code{ctz(x)} is equivalent to @code{ffs(@var{x}) - 1}.  The mode of -->
<!-- @var{x} must be @var{m} or @code{VOIDmode}. -->
表示<var>x</var>中，从最低有效位开始，结尾处为0的位数，为一个模式<var>m</var>的整数。如果<var>x</var>为零，则值由<code>CTZ_DEFINED_VALUE_AT_ZERO</code>
(参见<a href="Misc.html#Misc">Misc</a>)来确定。除此之外，<code>ctz(x)</code>等价于<code>ffs(</code><var>x</var><code>) - 1</code>。<var>x</var>的机器模式一定是<var>m</var> 或者 <code>VOIDmode</code>。

     <p><a name="index-popcount-2125"></a><br><dt><code>(popcount:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the number of 1-bits in @var{x}, represented as an integer of -->
<!-- mode @var{m}.  The mode of @var{x} must be @var{m} or @code{VOIDmode}. -->
表示<var>x</var>中为1的位数，为一个模式<var>m</var>的整数。<var>x</var>的机器模式一定是<var>m</var> 或者 <code>VOIDmode</code>。

     <p><a name="index-parity-2126"></a><br><dt><code>(parity:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the number of 1-bits modulo 2 in @var{x}, represented as an -->
<!-- integer of mode @var{m}.  The mode of @var{x} must be @var{m} or @code{VOIDmode}. -->
表示<var>x</var>中为1的位数对2进行求模，为一个模式<var>m</var>的整数。<var>x</var>的机器模式一定是<var>m</var> 或者 <code>VOIDmode</code>。

     <p><a name="index-bswap-2127"></a><br><dt><code>(bswap:</code><var>m</var> <var>x</var><code>)</code><dd><!-- Represents the value @var{x} with the order of bytes reversed, carried out -->
<!-- in mode @var{m}, which must be a fixed-point machine mode. -->
<!-- The mode of @var{x} must be @var{m} or @code{VOIDmode}. -->
表示将<var>x</var>值的字节顺序进行反转，结果为<var>m</var>机器模式，其必须为一个定点机器模式。。<var>x</var>的机器模式一定是<var>m</var> 或者 <code>VOIDmode</code>。
</dl>

<!-- @node Comparisons -->
<!-- @section Comparison Operations -->
 </body></html>

