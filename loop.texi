@c Copyright (c) 2006, 2007, 2008 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Loop Representation
@c ---------------------------------------------------------------------

@node 循环分析和表示
@chapter 循环分析和表示

GCC提供了大量的基础结构，用来处理普通的循环结构，
也就是CFG中只有一个入口块的强连通部分。
这章描述了GCC中对于循环的GIMPLE和RTL表示，
以及循环相关的分析的接口（归纳变量分析和迭代次数分析）。

@menu
* 循环表示::   循环的表示和分析。
* 循环查询::   获得循环的信息。    
* 循环操作::   循环操作函数。      
* LCSSA::      闭环SSA形式。       
* 标量演化::   GIMPLE级的归约变量。
* loop-iv::    RTL级的归约变量。  
* 迭代次数::   迭代次数分析。     
* 依赖分析::   数据依赖分析。     
* Lambda::     线性循环转换框架。  
* Omega::      线性编程问题的解决。
@end menu

@node 循环表示
@section 循环表示
@cindex Loop representation
@cindex Loop analysis

这章描述了GCC中循环的表示，以及可以用来构建，修改和分析这些表示的函数。
大多数接口和数据结构都在@file{cfgloop.h}中声明。目前，
只是由处理循环的优化过程来分析这些循环结构和更新这些信息，
不过正在做一些努力，使得其在大多数优化过程中都可用。

通常，一个自然的循环会具有一个入口块（header），
以及可能多个的从循环内部通向header的回边（latch）。
如果多个循环共享单个 header，或者在循环中间有个分支跳转，
则可能会出现带有多个latch的循环。然而GCC中对循环的表示只允许具有单个latch。
在循环分析过程中，为了消除循环结构的歧义，这样的循环的header会被拆分，
并创建前向的块。基于profile信息的heuristic，
以及循环中的归纳变量的结构被用来判定latches是否与子循环相关，
还是与单个循环中的控制流相关。这意味着分析有时候会改变CFG，
并且如果你在一个优化过程的中间运行了该分析，则必须能够处理新的块。
可以通过传递@code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES}标记来避免CFG改变，
但是要注意，对于具有多个latch边的循环，
大多其它的循环操作函数将无法正确工作
（只有查询块成员与循环和子循环关系的，或者枚举和测试循环出口的函数能够工作）。

循环体是由header支配的一组基本块，并且可以通过回边沿着CFG中边的方向达到。
循环使用树的层次结构来组织，直接包含在循环L中的所有循环在树中都为L的子节点。
该树由@code{struct loops}结构体表示。该树的根是一个假循环，包含了函数中的所有块。
每个循环都由@code{struct loop}结构体表示。
每个循环都被赋予一个索引（@code{struct loop}结构体的@code{num}域），
并且指向循环的指针被存在@code{struct loops}结构体中的@code{larray}向量的对应域里。
索引不必是连续的，@code{larray}中可能会有空项（@code{NULL}），是由删除循环产生的。
而且不保证索引的数字与循环和子循环有关系。循环的索引不会改变。

不要直接访问@code{larray}域中的项。函数@code{get_loop}返回给定索引的循环描述。
@code{number_of_loops}函数返回函数中的循环数目。要遍历所有的循环，
使用@code{FOR_EACH_LOOP}宏。宏的标记参数用来决定遍历的方向和要访问的循环集。
不管循环树是否变化，以及在遍历过程中循环是否被移除，每个循环都保证只被访问一次。
新创建的循环将不会被访问到，如果需要访问，这必须在它们创建之后单独进行。
@code{FOR_EACH_LOOP}宏会分配临时变量，如果使用break或者goto终止了@code{FOR_EACH_LOOP}，
它们将不会被释放；因此必须使用@code{FOR_EACH_LOOP_BREAK}宏。

每个基本块包含了对其所属的最内层循环的引用（@code{loop_father}）。
基于这个原因，对每个CFG只可能有一个@code{struct loops}结构体在同一时间被初始化。
全局变量@code{current_loops}包含了@code{struct loops}结构体。
许多循环操作函数都假设dominance信息是最新的。

通过@code{loop_optimizer_init}函数来分析循环。
该函数的参数是一个标记集，使用整数位掩码表示。
这些标记指定了循环结构体的其它哪些属性将在之后被计算/赋予，并且保留：

@itemize
@item @code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES}: 
如果设置了该标记，循环分析将不会改变CFG，特别的，
具有多个回边的循环将不会被消除歧义。如果循环具有多个回边，
它的回边块被设为NULL。对于这种形式，大多循环操作函数将无法工作。
@item @code{LOOPS_HAVE_PREHEADERS}: 
创建前驱块的方法为，每个循环只有一个入口边，另外，这个入口边的源块只有一个后继。
这就创建了一个自然的位置，使得代码能够被移出循环，
并且保证循环的入口边由它的直接外循环进来。
@item @code{LOOPS_HAVE_SIMPLE_LATCHES}: 
创建前驱块，从而使得每个循环的回边块只有一个后继。
这就保证了循环的回边不属于任何子循环，并且使得对循环的操作变得非常容易。
许多循环操作函数都假设循环是处于这种形式的。注意使用该标记时，
其中没有任何控制流，且只有一个出口的“正常”循环，将包括两个基本块。
@item @code{LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS}: 
强连通组件中的基本块和边，如果不是自然循环（具有多个入口块），
将被@code{BB_IRREDUCIBLE_LOOP}和@code{EDGE_IRREDUCIBLE_LOOP}标记。
在这样的不可消减区域中的块和边，如果属于自然循环的，
则不被标记（但是会为进入和离开该区域的入口边和出口边做标记）。
@item @code{LOOPS_HAVE_RECORDED_EXITS}: 
为每个循环记录并更新出口列表。
这使得一些函数（如@code{get_loop_exit_edges}）更加有效。
一些函数（如@code{single_exit}）只有在出口列表被记录的情况下才能用。
@end itemize

这些属性也可以在之后使用函数@code{create_preheaders}, 
@code{force_single_succ_latches},@code{mark_irreducible_loops} 和
@code{record_loop_exits}来求得/赋予。

循环结构体占用的内存应该在@code{loop_optimizer_finalize}函数中被释放。

CFG操作函数通常不更新循环结构体。在GIMPLE上，如果设置了@code{current_loops}，
则@code{cleanup_tree_cfg_loop}可以被用来在清除CFG的同时，更新循环结构体。

@node 循环查询
@section 循环查询
@cindex Loop querying

查询循环信息的函数声明在@file{cfgloop.h}中。一些信息可以直接从结构体中获得。
每个基本块的@code{loop_father}域都包含了它所属的最内层的循环。
最有用的（总是保持更新的）循环结构有：

@itemize
@item @code{header}, @code{latch}: 循环的Header和latch基本块。
@item @code{num_nodes}: 循环中的基本块数目（包括子循环的基本块）。
@item @code{depth}: 该循环在循环树中的深度，也就是，外层循环的数目。
@item @code{outer}, @code{inner}, @code{next}: 外部循环，第一个子循环，以及循环树中的下一个循环。
@end itemize

在循环结构体中还有其它一些域，它们有许多是只被一些过程使用，
或者在改变CFG时并没有被更新；总之，它们应该不要去直接访问。

用来查询循环结构体的最重要的函数有：

@itemize
@item @code{flow_loops_dump}: 将循环的信息转储到文件中。
@item @code{verify_loop_structure}: 检查循环结构体的一致性。
@item @code{loop_latch_edge}: 返回循环的latch边。
@item @code{loop_preheader_edge}: 
如果循环有preheaders, 则返回循环的preheader边。
@item @code{flow_loop_nested_p}: 测试循环是否为另一个循环的子循环。
@item @code{flow_bb_inside_loop_p}: 
测试基本块是否属于一个循环（包括它的子循环）。
@item @code{find_common_loop}: 找到两个循环的公共外循环。
@item @code{superloop_at_depth}: 返回给定深度的外循环。
@item @code{tree_num_loop_insns}, @code{num_loop_insns}: 
分别在GIMPLE和RTL之上，评估循环中的insn数目。
@item @code{loop_exit_edge_p}: 测试是否为循环的出口边。
@item @code{mark_loop_exit_edges}: 
使用@code{EDGE_LOOP_EXIT}来标记所有循环的出口边。
@item @code{get_loop_body}, @code{get_loop_body_in_dom_order},
@code{get_loop_body_in_bfs_order}: 
分别为，在反向的CFG中使用深度优先顺序，dominance顺序，以及宽度优先顺序，
来列举基本块。
@item @code{single_exit}: 
或者返回循环的单一出口边，或者当循环具有多个出口时返回@code{NULL}。
只有在使用了LOOPS_HAVE_MARKED_SINGLE_EXITS属性时，才能使用这个函数。
@item @code{get_loop_exit_edges}: 列举循环的出口边。
@item @code{just_once_each_iteration_p}: 
如果基本块在循环的每次迭代中都只被执行一次，返回true
（也就是，其不属于一个子循环，并且dominate循环的latch）。
@end itemize

@node 循环操作
@section 循环操作
@cindex Loop manipulation

可以使用下列函数来操作循环树：

@itemize
@item @code{flow_loop_tree_node_add}: 向树中增加一个节点。
@item @code{flow_loop_tree_node_remove}: 从树中移除一个节点。
@item @code{add_bb_to_loop}: 向循环增加一个基本块。
@item @code{remove_bb_from_loops}: 从循环中移除一个基本块。
@end itemize

大多数低级别的CFG函数会自动更新循环。下列函数用来处理一些比较复杂的CFG操作情况：

@itemize
@item @code{remove_path}: 移除一个边，以及它支配的所有块。 
@item @code{split_loop_exit_edge}: 
拆分循环的出口边，以确保PHI节点参数保留在循环中（确保使用了循环封闭SSA形式）。
只用于GIMPLE。
@end itemize

最后，有一些高层的循环转换被实现。虽然其中一些能够工作于非最内层循环，
但是大多数并没有对这种情况进行过测试，目前，它们只对最内层循环可靠：

@itemize
@item @code{create_iv}: 
创建一个新的归约变量。只工作在GIMPLE上。
@code{standard_iv_increment_position}能够被用来为iv增量找到合适的位置。
@item @code{duplicate_loop_to_header_edge},
@code{tree_duplicate_loop_to_header_edge}: 
这些函数（在RTL和GIMPLE之上）在进入循环头的边上对循环体复制规定的次数，
从而执行了循环展开或loop peeling。对于复制的循环，
@code{can_duplicate_loop_p}（GIMPLE之上为@code{can_unroll_loop_p}）必须为真。
@item @code{loop_version}, @code{tree_ssa_loop_version}: 
这些函数创建一个循环的复本，以及在它们之前的一个分支跳转，
从而可以根据规定的条件来选择它们。这对需要在运行时检验一些假设的优化很有帮助
（循环的一个复本通常不做变换，而另一个通过某种方式进行转换）。
@item @code{tree_unroll_loop}: 
展开循环，包括剥离额外的迭代，从而使得迭代次数可以由展开因子划分，
更新出口条件，以及移除不会经过的出口。只在GIMPLE上工作。
@end itemize

@node LCSSA
@section 循环封闭的SSA形式
@cindex LCSSA
@cindex Loop-closed SSA form

在整个树级的循环优化过程中，SSA形式需要有一个额外的加强条件：
没有SSA名字在它所定义的循环之外被使用。
满足这样条件的SSA形式称作“循环封闭的SSA形式”-LCSSA。
为了形成LCSSA，对于在循环外使用SSA名字的，必须在循环的出口创建PHI节点。
为了节省内存，在LCSSA中只支持实际的操作数（不包括虚拟SSA名）。

LCSSA有许多好处：

@itemize
@item 
许多优化（值范围分析，最终值替换）都对在循环中定义的而在循环外使用的值感兴趣，
即，对那些我们创建的新PHI节点。
@item 
在归约变量分析中，
没有必要指定将要执行分析的循环——标量演化分析总是返回SSA名字被定义的循环。
@item 
它使得循环转换中更新SSA形式变得更简单。没有LCSSA的话，
像循环展开这样的操作可能会强迫创建距离循环任意远的PHI节点，然而使用LCSSA的话，
SSA形式能够被局部更新。不过，由于我们只是在LCSSA中保持真实的操作书，
所以我们不能使用这个好处（我们本来能够局部更新真实操作数，
但是这样并不比使用通用SSA形式更新更有效；对SSA的改动是相同的）。
@end itemize

不管怎样，这还意味着LCSSA必须被更新。这通常是很直白的，
除非你在循环中创建了一个新值，并在外面使用，
或者除非你操作了循环出口边（有函数被提供使得这些操作变得简单）。
@code{rewrite_into_loop_closed_ssa}用来将SSA形式重写为 LCSSA，
@code{verify_loop_closed_ssa}用来检查LCSSA所保持的不变性。

@node 标量演化
@section 标量演化
@cindex Scalar evolutions
@cindex IV analysis on GIMPLE

标量演化（SCEV）用来表示在GIMPLE之上的归纳变量分析结果。
它使得我们能够通过简单一致的方式来表示具有复杂性为的变量（我们只使用它来表示多项
式归纳变量的值，但是是可以进一步扩展的）。
SCEV分析的接口声明在@file{tree-scalar-evolution.h}中。要使用标量演化分析，
则必须使用@code{scev_initialize}。要停止使用SCEV，则使用@code{scev_finalize}。
为了节省时间和内存，SCEV分析会缓存结果。但是这些缓存会被大多数循环转换变为无效，
包括代码移除。如果执行了这样的转换，则必须调用@code{scev_reset}来清除缓存。

给定一个SSA名字，
能够使用@code{analyze_scalar_evolution}函数来分析它在循环中的行为。
然而返回的SCEV不需要被完全分析，
并且它可以包含对其它定义在循环中的SSA名字的引用。
必须使用@code{instantiate_parameters}或者@code{resolve_mixers}函数来解决这些
（潜在的递归）引用。当你将SCEV的结果只用于某种分析时，
并且一次工作于整个循环嵌套时，@code{instantiate_parameters}会很有用。
它将尝试替换所有的SSA名字，用它们在所有循环中的SCEV，包括当前循环的外层循环，
因此提供了在循环嵌套中的变量行为的完全信息。当你一次只工作于一个循环，
并且可能需要根据归约变量的值来创建代码时，@code{resolve_mixers}会很有用。
它会只解决定义在当前循环中的SSA名字，而保留外面定义的SSA名字不变，
即使它们在外循环中的演化是已知的。

SCEV是一个标准的树表达式，除去实际上它可以包含多个特定的树节点。
@code{SCEV_NOT_KNOWN}为其中之一，用于值无法被表示的SSA名字。
另一个是@code{POLYNOMIAL_CHREC}。多项式chrec有三个参数—— base，step和loop
（base和step都可以进一步包含多项式chrecs）。表达式，base和step的类型必须相同。
在下面的例子中，如果变量（在特定的循环中）等于@code{x_1}，
则具有演化@code{POLYNOMIAL_CHREC(base, step, loop)}。

@smallexample
while (@dots{})
  @{
    x_1 = phi (base, x_2);
    x_2 = x_1 + step;
  @}
@end smallexample

注意这包括操作数上的语言限制。例如，如果我们编译C代码，
并且@code{x}具有有符号类型，那么加法溢出将会产生未定义行为，
并且我们可以假设这并没有发生。因此，SCEV的值不能溢出。

许多情况下，只是想放射归约变量。这时，额外的SCEV的表达式幂就没有用处，
并且可能会使优化变得复杂。这时，
可以使用@code{simple_iv}函数来分析一个值——结果为循环不变量base和step。

@node loop-iv
@section RTL上的IV分析
@cindex IV analysis on RTL

RTL之上的归约变量很简单，并且只允许一次在一个循环中，仿射归约变量的分析。
接口在@file{cfgloop.h}中声明。在循环L中分析归约变量之前，
必须在L上调用@code{iv_analysis_loop_init}函数。
分析完成之后（可能会为多个循环调用@code{iv_analysis_loop_init}），
应该调用@code{iv_analysis_done}。下面的函数能够被用来访问分析结果：

@itemize
@item @code{iv_analyze}: 
分析在给定insn中的单个寄存器。如果在该insn中没有使用寄存器，则扫描下一个insn，
因此该函数能够在通过get_condition返回的insn上被调用。
@item @code{iv_analyze_result}: 
分析给定insn的赋值结果。
@item @code{iv_analyze_expr}: 
分析一个更加复杂的表达式。其所有操作数都通过@code{iv_analyze}来分析，
因此它们必须用在特定insn中，或者后面insn的其中之一。
@end itemize

归约变量的描述在@code{struct rtx_iv}中。为了处理子寄存器，该表示有些复杂；
如果@code{extend}域的值不是@code{UNKNOWN}，则归约变量在第i次迭代时的值为

@smallexample
delta + mult * extend_@{extend_mode@} (subreg_@{mode@} (base + i * step)),
@end smallexample

不过下面的情况例外：如果@code{first_special}为真，
则在首次迭代时（当@code{i}为0时），值为@code{delta + mult * base}。
然而，如果@code{extend}等于@code{UNKNOWN}，则@code{first_special}必须为假，
@code{delta}为0，@code{mult}为1，并且在第i次迭代时的值为

@smallexample
subreg_@{mode@} (base + i * step)
@end smallexample

函数@code{get_iv_value}可以用来执行这些计算。

@node 迭代次数
@section 迭代次数分析
@cindex Number of iterations analysis

在GIMPLE和RTL之上，都有函数可以用来判定循环的迭代次数，并且具有相似的接口。
在GCC中，循环的迭代次数被定义为循环latch的执行次数。许多情况下，
是不可能无条件的判定出迭代次数——判定的迭代次数只有在满足一些假设时才正确。
分析尝试使用包含在程序中的信息来检验这些条件；如果失败了，
则条件和结果一起被返回。下面的信息和条件由分析提供：

@itemize
@item @code{assumptions}: 
如果条件为假，则其余的信息无效。
@item RTL上的@code{noloop_assumptions}, GIMPLE上的@code{may_be_zero}: 
如果该条件为真，则循环在第一次迭代中便退出。
@item @code{infinite}: 
If this condition is true, the loop is infinite.
This condition is only available on RTL@.  On GIMPLE, conditions for
finiteness of the loop are included in @code{assumptions}.
@item RTL上的@code{niter_expr} , GIMPLE上的@code{niter}: 
该表达式给出迭代次数。迭代次数被定义为循环latch的执行次数。
@end itemize

在GIMPLE和RTL之上，都需要初始化归约变量分析框架（GIMPLE上为SCEV，
RTL上为loop-iv）。在GIMPLE上，结果存储在@code{struct tree_niter_desc}中。
可以通过@code{number_of_iterations_exit}函数来判定循环在通过给定出口退出之前的
迭代次数。在RTL上，结果返回在@code{struct niter_desc}结构体中，
相应的函数名为@code{check_simple_exit}。还有一些函数遍历循环的所有出口，
并尝试找到容易判定迭代次数的一个——它们是GIMPLE上的@code{find_loop_niter}和
RTL上的@code{find_simple_exit}。最后，还有一些函数提供相同的信息，
只不过还额外的对其进行缓存，
使得反复调用迭代次数的代价不会很高——它们是GIMPLE上的
@code{number_of_latch_executions}和RTL上的@code{get_simple_loop_desc}。

注意这些函数中的一些可能与其它的在行为上有些不同——有些只返回迭代次数的表达式。
函数@code{number_of_latch_executions}只工作于单个出口的循环。
函数@code{number_of_cond_exit_executions}能被用来判定一个单出口循环在退出条件下
的执行次数。（即，@code{number_of_latch_executions}加1）。

@node 依赖分析
@section 数据依赖分析
@cindex Data Dependency Analysis

用于数据相关性分析的代码可以在@file{tree-data-ref.c}中找到，
接口和数据结构在@file{tree-data-ref.h}中描述。
用来计算对于给定循环的所有数组和指针引用的数据相关性的函数为
@code{compute_data_dependences_for_loop}。
该函数目前被用于线性循环转换和向量化过程。在调用该函数之前，必须分配两个向量：
第一个向量将会包含在被分析的循环体中的数据引用集，
第二个将会包含数据引用之间的依赖关系。因此，如果数据引用向量的大小为@code{n}，
则包含依赖关系的向量将包含@code{n*n}个元素。但是，如果被分析的循环包含副作用，
例如对数据引用有潜在干扰的调用，则分析会在扫描循环体中的数据引用时停住，
并在依赖关系数组中插入一个@code{chrec_dont_know}。

数据相关性是在扫描循环体时，按照特定顺序发现的：循环体按照执行顺序分析，
每条语句的数据引用被压入数据引用数组的尾部。两个数据相关性在程序中的语法位置，
和在数据相关性数组具有相同的顺序。这种语法顺序在一些经典数据相关性测试中很重要，
并且将这中顺序映射到数组的元素可以避免对循环体表示的昂贵查询开销。

目前处理了三种类型的数据相关性：ARRAY_REF, INDIRECT_REF和COMPONENT_REF。
数据相关性的数据结构体为@code{data_reference}，
其中@code{data_reference_p}为指向数据相关性结构体的指针名。
结构体包含了以下元素：

@itemize
@item @code{base_object_info}: 
提供了关于数据引用的基本对象的信息，
以及访问函数代表了数据引用在循环中相对于它的基的演变。这些访问函数。例如，
对于一个引用@code{a.b[i][j]}，基本对象为@code{a.b}，
其中一个针对每个数组下标的访问函数为：
@code{@{i_init, + i_step@}_1, @{j_init, +, j_step@}_2}。

@item @code{first_location_in_loop}: 
提供了循环中由数据引用访问的第一个位置，
以及用来表示相对于该位置的演化的访问函数。该数据用来支持指针，
而不是数组（具有基对象的）。
指针访问被表示为从循环中的第一个位置开始的一维访问。例如:

@smallexample
      for1 i
         for2 j
          *((int *)p + i + j) = a[i][j];
@end smallexample

对于@code{p + i}，指针访问的访问函数是@code{@{0, + 4B@}_for2}。
对于@code{a}，数组的访问函数是@code{@{i_init, + i_step@}_for1}和
@code{@{j_init, +, j_step@}_for2}。

通常，指针指向的对象或者是不可知的，
或者是我们不能证明访问被限制在这些对象的边界中。

两个数据引用只有在最起码有一个表示的所有域都适合于这两个数据引用时，
才能够进行比较。

目前测试数据相关性的策略为：如果@code{a}和@code{b}都由数组来表示，
则比较@code{a.base_object}和@code{b.base_object}；如果它们相等，
则应用相关性测试（使用基于base_objects的访问函数）。
如果@code{a}和@code{b}都由指针表示，
则比较@code{a.first_location}和@code{b.first_location}；
如果它们相等，则应用相关性测试（使用基于第一位置的访问函数）。
但是，如果@code{a}和@code{b}的表示不同，只能尝试去证明它们的基肯定不相同。

@item 别名信息。
@item 对齐信息。
@end itemize

描述两个数据引用之间关系的结构体是@code{data_dependence_relation}，
指向这种结构体的指针的简短名字为@code{ddr_p}。该结构体包含：

@itemize
@item 每个数据引用的指针，
@item 
一个树节点@code{are_dependent}，如果分析证明了两个数据引用之间没有相关性，
则设置为@code{chrec_known}；如果分析不能判定任何有用的结果，
并且这些数据引用可能存在相关性，则设为@code{chrec_dont_know}；
如果数据引用间存在相关性，则设置为@code{NULL_TREE}，
并且该相关性的描述在@code{dir_vects}和@code{dist_vects}数组的下标中给出。
@item 一个布尔值，用来判定依赖关系是否能被表示为经典的距离向量， 
@item 
一个数组@code{subscripts}，包含了数据引用的每个下标的描述。给出两个数组访问，
下标为对于给定维数的访问组合。例如，
给定@code{A[f1][f2][f3]}和@code{B[g1][g2][g3]}，
则有三个下标：@code{(f1, g1), (f2, g2), (f3, g3)}。
@item 
两个数组@code{dir_vects}和@code{dist_vects}，
包含了使用方向和距离依赖向量的数据相关典型表示。
@item 循环数组@code{loop_nest}，包含了距离和方向向量指向的循环。 
@end itemize

有一些函数可以很好的打印由数据相关分析抽出的信息：
@code{dump_ddrs}打印最详尽的数据依赖关系数组，
@code{dump_dist_dir_vectors}只打印数据依赖关系数组的典型的距离和方向向量，
@code{dump_data_references}打印数据引用数组中的详细的数据引用。

@node Lambda
@section 线性循环转换框架
@cindex Linear loop transformations framework

Lambda是一个允许循环转换使用基于迭代空间和循环边界的非退化矩阵的框架。
这允许组合使用skewing，scaling，interchange，和reversal转换。
这些转换常用来提高cache行为，
或者移除内部循环依赖使得可以进行并行化或者向量化。

为了执行这些转换，Lambda需要loopnest转化为可以被很容易的进行矩阵转换的内部形式。
函数@code{gcc_loopnest_to_lambda_loopnest}用来做这种转换。
如果循环不能够使用lambda转换，这个函数将返回NULL。

一旦通过转换函数获得lambda_loopnest，
便可以使用@code{lambda_loopnest_transform}来进行各种转换处理，
其接受一个转换矩阵。
注意这是由调用者来检验转换矩阵是否合法，即可以应用到循环上的。
Lambda只是简单的应用提供给它的矩阵。可以扩展为使用任何非退化矩阵之外的矩阵，
不过现在还没有实现。
可以使用@code{lambda_transform_legal_p}来检验给定loopnest的矩阵的合法性。

给定一个转换过的loopnest，
可以通过@code{lambda_loopnest_to_gcc_loopnest}来将其转化回到gcc IR。
该函数会修改循环使得它们匹配转换过的loopnest。

@node Omega
@section Omega 一种对线性规划问题的求解
@cindex Omega a solver for linear programming problems

数据相关性分析包含多个求解器，从不太复杂的到比较复杂的。
为了确保这些求解器的结果的一致性，
实现了一个基于不同求解器的数据相关性检查过程。
已经被集成到GCC中的第二种方法是基于Omega相关求解器，
由William Pugh和David Wonnacott在1990年编写。
数据相关性测试能够通过使用Presburger算法的子集来公式化，
从而可以转化为线性约束系统。然后这些线性约束系统能够使用Omega求解器求解。

Omega求解器使用Fourier-Motzkin算法进行变量消除：
一个包含@code{n}个变量的线性约束系统被消减为包含@code{n-1}个变量的线性约束系统。
Omega求解器还能够用来解决其它能被表示为线性等式和不等式系统形式的问题。
Omega求解器有一个公认的指数最坏情况，即文献上称之的“omega 恶梦”，
不过实际上，众所周知omega测试对于公用数据相关性测试是有效的。

Omega求解器所使用的描述线性规划问题接口在@file{omega.h}中，
求解器为@code{omega_solve_problem}。
