@c Copyright (c) 2006, 2007, 2008 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Loop Representation
@c ---------------------------------------------------------------------

@en @node Loop Analysis and Representation
@en @chapter Analysis and Representation of Loops
@node 循环分析和表示
@chapter 循环分析和表示

@en GCC provides extensive infrastructure for work with natural loops, i.e.,
@en strongly connected components of CFG with only one entry block.  This
@en chapter describes representation of loops in GCC, both on GIMPLE and in
@en RTL, as well as the interfaces to loop-related analyses (induction
@en variable analysis and number of iterations analysis).
GCC提供了大量的基础结构，用来处理普通的循环结构，也就是CFG中只有一个入口块的强连通部分。这章描述了GCC中对于循环的GIMPLE和RTL表示，以及循环相关的分析的接口（归纳变量分析和迭代次数分析）。

@en @menu
@en * Loop representation::         Representation and analysis of loops.
@en * Loop querying::               Getting information about loops.
@en * Loop manipulation::           Loop manipulation functions.
@en * LCSSA::                       Loop-closed SSA form.
@en * Scalar evolutions::           Induction variables on GIMPLE.
@en * loop-iv::                     Induction variables on RTL.
@en * Number of iterations::        Number of iterations analysis.
@en * Dependency analysis::         Data dependency analysis.
@en * Lambda::                      Linear loop transformations framework.
@en * Omega::                       A solver for linear programming problems.
@en @end menu
@menu
* 循环表示::   循环的表示和分析。
* 循环查询::   获得循环的信息。    
* 循环操作::   循环操作函数。      
* LCSSA::      闭环SSA形式。       
* 标量演化::   GIMPLE级的归约变量。
* loop-iv::    RTL级的归约变量。  
* 迭代次数::   迭代次数分析。     
* 依赖分析::   数据依赖分析。     
* Lambda::     线性循环转换框架。  
* Omega::      线性编程问题的解决。
@end menu

@en @node Loop representation
@en @section Loop representation
@node 循环表示
@section 循环表示
@cindex Loop representation
@cindex Loop analysis

@en This chapter describes the representation of loops in GCC, and functions
@en that can be used to build, modify and analyze this representation.  Most
@en of the interfaces and data structures are declared in @file{cfgloop.h}.
@en At the moment, loop structures are analyzed and this information is
@en updated only by the optimization passes that deal with loops, but some
@en efforts are being made to make it available throughout most of the
@en optimization passes.
这章描述了GCC中循环的表示，以及可以用来构建，修改和分析这些表示的函数。大多数接口和数据结构都在@file{cfgloop.h}中声明。目前，只是由处理循环的优化过程来分析这些循环结构和更新这些信息，不过正在做一些努力，使得其在大多数优化过程中都可用。

@en In general, a natural loop has one entry block (header) and possibly
@en several back edges (latches) leading to the header from the inside of
@en the loop.  Loops with several latches may appear if several loops share
@en a single header, or if there is a branching in the middle of the loop.
@en The representation of loops in GCC however allows only loops with a
@en single latch.  During loop analysis, headers of such loops are split and
@en forwarder blocks are created in order to disambiguate their structures.
@en Heuristic based on profile information and structure of the induction
@en variables in the loops is used to determine whether the latches
@en correspond to sub-loops or to control flow in a single loop.  This means
@en that the analysis sometimes changes the CFG, and if you run it in the
@en middle of an optimization pass, you must be able to deal with the new
@en blocks.  You may avoid CFG changes by passing
@en @code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES} flag to the loop discovery,
@en note however that most other loop manipulation functions will not work
@en correctly for loops with multiple latch edges (the functions that only
@en query membership of blocks to loops and subloop relationships, or
@en enumerate and test loop exits, can be expected to work).
通常，一个自然的循环会具有一个入口块（header），以及可能多个的从循环内部通向header的回边（latch）。如果多个循环共享单个 header，或者在循环中间有个分支跳转，则可能会出现带有多个latch的循环。然而GCC中对循环的表示只允许具有单个latch。在循环分析过程中，为了消除循环结构的歧义，这样的循环的header会被拆分，并创建前向的块。基于profile信息的heuristic，以及循环中的归纳变量的结构被用来判定latches是否与子循环相关，还是与单个循环中的控制流相关。这意味着分析有时候会改变CFG，并且如果你在一个优化过程的中间运行了该分析，则必须能够处理新的块。可以通过传递@code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES}标记来避免CFG改变，但是要注意，对于具有多个latch边的循环，大多其它的循环操作函数将无法正确工作（只有查询块成员与循环和子循环关系的，或者枚举和测试循环出口的函数能够工作）。

@en Body of the loop is the set of blocks that are dominated by its header,
@en and reachable from its latch against the direction of edges in CFG@.  The
@en loops are organized in a containment hierarchy (tree) such that all the
@en loops immediately contained inside loop L are the children of L in the
@en tree.  This tree is represented by the @code{struct loops} structure.
@en The root of this tree is a fake loop that contains all blocks in the
@en function.  Each of the loops is represented in a @code{struct loop}
@en structure.  Each loop is assigned an index (@code{num} field of the
@en @code{struct loop} structure), and the pointer to the loop is stored in
@en the corresponding field of the @code{larray} vector in the loops
@en structure.  The indices do not have to be continuous, there may be
@en empty (@code{NULL}) entries in the @code{larray} created by deleting
@en loops.  Also, there is no guarantee on the relative order of a loop
@en and its subloops in the numbering.  The index of a loop never changes.
循环体是由header支配的一组基本块，并且可以通过回边沿着CFG中边的方向达到。循环使用树的层次结构来组织，直接包含在循环L中的所有循环在树中都为L的子节点。该树由@code{struct loops}结构体表示。该树的根是一个假循环，包含了函数中的所有块。每个循环都由@code{struct loop}结构体表示。每个循环都被赋予一个索引（@code{struct loop}结构体的@code{num}域），并且指向循环的指针被存在@code{struct loops}结构体中的@code{larray}向量的对应域里。索引不必是连续的，@code{larray}中可能会有空项（@code{NULL}），是由删除循环产生的。而且不保证索引的数字与循环和子循环有关系。循环的索引不会改变。

@en The entries of the @code{larray} field should not be accessed directly.
@en The function @code{get_loop} returns the loop description for a loop with
@en the given index.  @code{number_of_loops} function returns number of
@en loops in the function.  To traverse all loops, use @code{FOR_EACH_LOOP}
@en macro.  The @code{flags} argument of the macro is used to determine
@en the direction of traversal and the set of loops visited.  Each loop is
@en guaranteed to be visited exactly once, regardless of the changes to the
@en loop tree, and the loops may be removed during the traversal.  The newly
@en created loops are never traversed, if they need to be visited, this
@en must be done separately after their creation.  The @code{FOR_EACH_LOOP}
@en macro allocates temporary variables.  If the @code{FOR_EACH_LOOP} loop
@en were ended using break or goto, they would not be released;
@en @code{FOR_EACH_LOOP_BREAK} macro must be used instead.
不要直接访问@code{larray}域中的项。函数@code{get_loop}返回给定索引的循环描述。@code{number_of_loops}函数返回函数中的循环数目。要遍历所有的循环，使用@code{FOR_EACH_LOOP}宏。宏的标记参数用来决定遍历的方向和要访问的循环集。不管循环树是否变化，以及在遍历过程中循环是否被移除，每个循环都保证只被访问一次。新创建的循环将不会被访问到，如果需要访问，这必须在它们创建之后单独进行。@code{FOR_EACH_LOOP}宏会分配临时变量，如果使用break或者goto终止了@code{FOR_EACH_LOOP}，它们将不会被释放；因此必须使用@code{FOR_EACH_LOOP_BREAK}宏。

@en Each basic block contains the reference to the innermost loop it belongs
@en to (@code{loop_father}).  For this reason, it is only possible to have
@en one @code{struct loops} structure initialized at the same time for each
@en CFG@.  The global variable @code{current_loops} contains the
@en @code{struct loops} structure.  Many of the loop manipulation functions
@en assume that dominance information is up-to-date.
每个基本块包含了对其所属的最内层循环的引用（@code{loop_father}）。基于这个原因，对每个CFG只可能有一个@code{struct loops}结构体在同一时间被初始化。全局变量@code{current_loops}包含了@code{struct loops}结构体。许多循环操作函数都假设dominance信息是最新的。

@en The loops are analyzed through @code{loop_optimizer_init} function.  The
@en argument of this function is a set of flags represented in an integer
@en bitmask.  These flags specify what other properties of the loop
@en structures should be calculated/enforced and preserved later:
通过@code{loop_optimizer_init}函数来分析循环。该函数的参数是一个标记集，使用整数位掩码表示。这些标记指定了循环结构体的其它哪些属性将在之后被计算/赋予，并且保留：

@itemize
@en @item @code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES}: If this flag is set, no
@en changes to CFG will be performed in the loop analysis, in particular,
@en loops with multiple latch edges will not be disambiguated.  If a loop
@en has multiple latches, its latch block is set to NULL@.  Most of
@en the loop manipulation functions will not work for loops in this shape.
@en No other flags that require CFG changes can be passed to
@en loop_optimizer_init.
@item @code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES}: 如果设置了该标记，循环分析将不会改变CFG，特别的，具有多个回边的循环将不会被消除歧义。如果循环具有多个回边，它的回边块被设为NULL。对于这种形式，大多循环操作函数将无法工作。
@en @item @code{LOOPS_HAVE_PREHEADERS}: Forwarder blocks are created in such
@en a way that each loop has only one entry edge, and additionally, the
@en source block of this entry edge has only one successor.  This creates a
@en natural place where the code can be moved out of the loop, and ensures
@en that the entry edge of the loop leads from its immediate super-loop.
@item @code{LOOPS_HAVE_PREHEADERS}: 创建前驱块的方法为，每个循环只有一个入口边，另外，这个入口边的源块只有一个后继。这就创建了一个自然的位置，使得代码能够被移出循环，并且保证循环的入口边由它的直接外循环进来。
@en @item @code{LOOPS_HAVE_SIMPLE_LATCHES}: Forwarder blocks are created to
@en force the latch block of each loop to have only one successor.  This
@en ensures that the latch of the loop does not belong to any of its
@en sub-loops, and makes manipulation with the loops significantly easier.
@en Most of the loop manipulation functions assume that the loops are in
@en this shape.  Note that with this flag, the ``normal'' loop without any
@en control flow inside and with one exit consists of two basic blocks.
@item @code{LOOPS_HAVE_SIMPLE_LATCHES}: 创建前驱块，从而使得每个循环的回边块只有一个后继。这就保证了循环的回边不属于任何子循环，并且使得对循环的操作变得非常容易。许多循环操作函数都假设循环是处于这种形式的。注意使用该标记时，其中没有任何控制流，且只有一个出口的“正常”循环，将包括两个基本块。
@en @item @code{LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS}: Basic blocks and
@en edges in the strongly connected components that are not natural loops
@en (have more than one entry block) are marked with
@en @code{BB_IRREDUCIBLE_LOOP} and @code{EDGE_IRREDUCIBLE_LOOP} flags.  The
@en flag is not set for blocks and edges that belong to natural loops that
@en are in such an irreducible region (but it is set for the entry and exit
@en edges of such a loop, if they lead to/from this region).
@item @code{LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS}: 强连通组件中的基本块和边，如果不是自然循环（具有多个入口块），将被@code{BB_IRREDUCIBLE_LOOP}和@code{EDGE_IRREDUCIBLE_LOOP}标记。在这样的不可消减区域中的块和边，如果属于自然循环的，则不被标记（但是会为进入和离开该区域的入口边和出口边做标记）。
@en @item @code{LOOPS_HAVE_RECORDED_EXITS}: The lists of exits are recorded
@en and updated for each loop.  This makes some functions (e.g.,
@en @code{get_loop_exit_edges}) more efficient.  Some functions (e.g.,
@en @code{single_exit}) can be used only if the lists of exits are
@en recorded.
@item @code{LOOPS_HAVE_RECORDED_EXITS}: 为每个循环记录并更新出口列表。这使得一些函数（如@code{get_loop_exit_edges}）更加有效。一些函数（如@code{single_exit}）只有在出口列表被记录的情况下才能用。
@end itemize

@en These properties may also be computed/enforced later, using functions
@en @code{create_preheaders}, @code{force_single_succ_latches},
@en @code{mark_irreducible_loops} and @code{record_loop_exits}.
这些属性也可以在之后使用函数@code{create_preheaders}, @code{force_single_succ_latches},@code{mark_irreducible_loops}和@code{record_loop_exits}来求得/赋予。

@en The memory occupied by the loops structures should be freed with
@en @code{loop_optimizer_finalize} function.
循环结构体占用的内存应该在@code{loop_optimizer_finalize}函数中被释放。

@en The CFG manipulation functions in general do not update loop structures.
@en Specialized versions that additionally do so are provided for the most
@en common tasks.  On GIMPLE, @code{cleanup_tree_cfg_loop} function can be
@en used to cleanup CFG while updating the loops structures if
@en @code{current_loops} is set.
CFG操作函数通常不更新循环结构体。在GIMPLE上，如果设置了@code{current_loops}，则@code{cleanup_tree_cfg_loop}可以被用来在清除CFG的同时，更新循环结构体。

@en @node Loop querying
@en @section Loop querying
@node 循环查询
@section 循环查询
@cindex Loop querying

@en The functions to query the information about loops are declared in
@en @file{cfgloop.h}.  Some of the information can be taken directly from
@en the structures.  @code{loop_father} field of each basic block contains
@en the innermost loop to that the block belongs.  The most useful fields of
@en loop structure (that are kept up-to-date at all times) are:
查询循环信息的函数声明在@file{cfgloop.h}中。一些信息可以直接从结构体中获得。每个基本块的@code{loop_father}域都包含了它所属的最内层的循环。最有用的（总是保持更新的）循环结构有：

@en @itemize
@en @item @code{header}, @code{latch}: Header and latch basic blocks of the
@en loop.
@en @item @code{num_nodes}: Number of basic blocks in the loop (including
@en the basic blocks of the sub-loops).
@en @item @code{depth}: The depth of the loop in the loops tree, i.e., the
@en number of super-loops of the loop.
@en @item @code{outer}, @code{inner}, @code{next}: The super-loop, the first
@en sub-loop, and the sibling of the loop in the loops tree.
@en @end itemize
@itemize
@item @code{header}, @code{latch}: 循环的Header和latch基本块。
@item @code{num_nodes}: 循环中的基本块数目（包括子循环的基本块）。
@item @code{depth}: 该循环在循环树中的深度，也就是，外层循环的数目。
@item @code{outer}, @code{inner}, @code{next}: 外部循环，第一个子循环，以及循环树中的下一个循环。
@end itemize

@en There are other fields in the loop structures, many of them used only by
@en some of the passes, or not updated during CFG changes; in general, they
@en should not be accessed directly.
在循环结构体中还有其它一些域，它们有许多是只被一些过程使用，或者在改变CFG时并没有被更新；总之，它们应该不要去直接访问。

@en The most important functions to query loop structures are:
用来查询循环结构体的最重要的函数有：

@en @itemize
@en @item @code{flow_loops_dump}: Dumps the information about loops to a
@en file.
@en @item @code{verify_loop_structure}: Checks consistency of the loop
@en structures.
@en @item @code{loop_latch_edge}: Returns the latch edge of a loop.
@en @item @code{loop_preheader_edge}: If loops have preheaders, returns
@en the preheader edge of a loop.
@en @item @code{flow_loop_nested_p}: Tests whether loop is a sub-loop of
@en another loop.
@en @item @code{flow_bb_inside_loop_p}: Tests whether a basic block belongs
@en to a loop (including its sub-loops).
@en @item @code{find_common_loop}: Finds the common super-loop of two loops.
@en @item @code{superloop_at_depth}: Returns the super-loop of a loop with
@en the given depth.
@en @item @code{tree_num_loop_insns}, @code{num_loop_insns}: Estimates the
@en number of insns in the loop, on GIMPLE and on RTL.
@en @item @code{loop_exit_edge_p}: Tests whether edge is an exit from a
@en loop.
@en @item @code{mark_loop_exit_edges}: Marks all exit edges of all loops
@en with @code{EDGE_LOOP_EXIT} flag.
@en @item @code{get_loop_body}, @code{get_loop_body_in_dom_order},
@en @code{get_loop_body_in_bfs_order}: Enumerates the basic blocks in the
@en loop in depth-first search order in reversed CFG, ordered by dominance
@en relation, and breath-first search order, respectively.
@en @item @code{single_exit}: Returns the single exit edge of the loop, or
@en @code{NULL} if the loop has more than one exit.  You can only use this
@en function if LOOPS_HAVE_MARKED_SINGLE_EXITS property is used.
@en @item @code{get_loop_exit_edges}: Enumerates the exit edges of a loop.
@en @item @code{just_once_each_iteration_p}: Returns true if the basic block
@en is executed exactly once during each iteration of a loop (that is, it
@en does not belong to a sub-loop, and it dominates the latch of the loop).
@en @end itemize
@itemize
@item @code{flow_loops_dump}: 将循环的信息转储到文件中。
@item @code{verify_loop_structure}: 检查循环结构体的一致性。
@item @code{loop_latch_edge}: 返回循环的latch边。
@item @code{loop_preheader_edge}: 
如果循环有preheaders, 则返回循环的preheader边。
@item @code{flow_loop_nested_p}: 测试循环是否为另一个循环的子循环。
@item @code{flow_bb_inside_loop_p}: 
测试基本块是否属于一个循环（包括它的子循环）。
@item @code{find_common_loop}: 找到两个循环的公共外循环。
@item @code{superloop_at_depth}: 返回给定深度的外循环。
@item @code{tree_num_loop_insns}, @code{num_loop_insns}: 
分别在GIMPLE和RTL之上，评估循环中的insn数目。
@item @code{loop_exit_edge_p}: 测试是否为循环的出口边。
@item @code{mark_loop_exit_edges}: 
使用@code{EDGE_LOOP_EXIT}来标记所有循环的出口边。
@item @code{get_loop_body}, @code{get_loop_body_in_dom_order},
@code{get_loop_body_in_bfs_order}: 
分别为，在反向的CFG中使用深度优先顺序，dominance顺序，以及宽度优先顺序，来列举基本块。
@item @code{single_exit}: 
或者返回循环的单一出口边，或者当循环具有多个出口时返回@code{NULL}。只有在使用了LOOPS_HAVE_MARKED_SINGLE_EXITS属性时，才能使用这个函数。
@item @code{get_loop_exit_edges}: 列举循环的出口边。
@item @code{just_once_each_iteration_p}: 
如果基本块在循环的每次迭代中都只被执行一次，返回true（也就是，其不属于一个子循环，并且dominate循环的latch）。
@end itemize

@en @node Loop manipulation
@en @section Loop manipulation
@node 循环操作
@section 循环操作
@cindex Loop manipulation

@en The loops tree can be manipulated using the following functions:
可以使用下列函数来操作循环树：

@en @itemize
@en @item @code{flow_loop_tree_node_add}: Adds a node to the tree.
@en @item @code{flow_loop_tree_node_remove}: Removes a node from the tree.
@en @item @code{add_bb_to_loop}: Adds a basic block to a loop.
@en @item @code{remove_bb_from_loops}: Removes a basic block from loops.
@en @end itemize
@itemize
@item @code{flow_loop_tree_node_add}: 向树中增加一个节点。
@item @code{flow_loop_tree_node_remove}: 从树中移除一个节点。
@item @code{add_bb_to_loop}: 向循环增加一个基本块。
@item @code{remove_bb_from_loops}: 从循环中移除一个基本块。
@end itemize

@en Most low-level CFG functions update loops automatically.  The following
@en functions handle some more complicated cases of CFG manipulations:
大多数低级别的CFG函数会自动更新循环。下列函数用来处理一些比较复杂的CFG操作情况：

@en @itemize
@en @item @code{remove_path}: Removes an edge and all blocks it dominates.
@en @item @code{split_loop_exit_edge}: Splits exit edge of the loop,
@en ensuring that PHI node arguments remain in the loop (this ensures that
@en loop-closed SSA form is preserved).  Only useful on GIMPLE.
@en @end itemize
@itemize
@item @code{remove_path}: 移除一个边，以及它支配的所有块。 
@item @code{split_loop_exit_edge}: 
拆分循环的出口边，以确保PHI节点参数保留在循环中（确保使用了循环封闭SSA形式）。只用于GIMPLE。
@end itemize

@en Finally, there are some higher-level loop transformations implemented.
@en While some of them are written so that they should work on non-innermost
@en loops, they are mostly untested in that case, and at the moment, they
@en are only reliable for the innermost loops:
最后，有一些高层的循环转换被实现。虽然其中一些能够工作于非最内层循环，但是大多数并没有对这种情况进行过测试，目前，它们只对最内层循环可靠：

@en @itemize
@en @item @code{create_iv}: Creates a new induction variable.  Only works on
@en GIMPLE@.  @code{standard_iv_increment_position} can be used to find a
@en suitable place for the iv increment.
@en @item @code{duplicate_loop_to_header_edge},
@en @code{tree_duplicate_loop_to_header_edge}: These functions (on RTL and
@en on GIMPLE) duplicate the body of the loop prescribed number of times on
@en one of the edges entering loop header, thus performing either loop
@en unrolling or loop peeling.  @code{can_duplicate_loop_p}
@en (@code{can_unroll_loop_p} on GIMPLE) must be true for the duplicated
@en loop.
@en @item @code{loop_version}, @code{tree_ssa_loop_version}: These function
@en create a copy of a loop, and a branch before them that selects one of
@en them depending on the prescribed condition.  This is useful for
@en optimizations that need to verify some assumptions in runtime (one of
@en the copies of the loop is usually left unchanged, while the other one is
@en transformed in some way).
@en @item @code{tree_unroll_loop}: Unrolls the loop, including peeling the
@en extra iterations to make the number of iterations divisible by unroll
@en factor, updating the exit condition, and removing the exits that now
@en cannot be taken.  Works only on GIMPLE.
@en @end itemize
@itemize
@item @code{create_iv}: 
创建一个新的归约变量。只工作在GIMPLE上。
@code{standard_iv_increment_position}能够被用来为iv增量找到合适的位置。
@item @code{duplicate_loop_to_header_edge},
@code{tree_duplicate_loop_to_header_edge}: 
这些函数（在RTL和GIMPLE之上）在进入循环头的边上对循环体复制规定的次数，
从而执行了循环展开或loop peeling。对于复制的循环，
@code{can_duplicate_loop_p}（GIMPLE之上为@code{can_unroll_loop_p}）必须为真。
@item @code{loop_version}, @code{tree_ssa_loop_version}: 
这些函数创建一个循环的复本，以及在它们之前的一个分支跳转，
从而可以根据规定的条件来选择它们。这对需要在运行时检验一些假设的优化很有帮助
（循环的一个复本通常不做变换，而另一个通过某种方式进行转换）。
@item @code{tree_unroll_loop}: 
展开循环，包括剥离额外的迭代，从而使得迭代次数可以由展开因子划分，
更新出口条件，以及移除不会经过的出口。只在GIMPLE上工作。
@end itemize


@en @node LCSSA
@en @section Loop-closed SSA form
@node LCSSA
@section 循环封闭的SSA形式
@cindex LCSSA
@cindex Loop-closed SSA form

@en Throughout the loop optimizations on tree level, one extra condition is
@en enforced on the SSA form:  No SSA name is used outside of the loop in
@en that it is defined.  The SSA form satisfying this condition is called
@en ``loop-closed SSA form'' -- LCSSA@.  To enforce LCSSA, PHI nodes must be
@en created at the exits of the loops for the SSA names that are used
@en outside of them.  Only the real operands (not virtual SSA names) are
@en held in LCSSA, in order to save memory.
在整个树级的循环优化过程中，SSA形式需要有一个额外的加强条件：没有SSA名字在它所定义的循环之外被使用。满足这样条件的SSA形式称作“循环封闭的SSA形式”-LCSSA。为了形成LCSSA，对于在循环外使用SSA名字的，必须在循环的出口创建PHI节点。为了节省内存，在LCSSA中只支持实际的操作数（不包括虚拟SSA名）。

@en There are various benefits of LCSSA:
LCSSA有许多好处：

@en @itemize
@en @item Many optimizations (value range analysis, final value
@en replacement) are interested in the values that are defined in the loop
@en and used outside of it, i.e., exactly those for that we create new PHI
@en nodes.
@en @item In induction variable analysis, it is not necessary to specify the
@en loop in that the analysis should be performed -- the scalar evolution
@en analysis always returns the results with respect to the loop in that the
@en SSA name is defined.
@en @item It makes updating of SSA form during loop transformations simpler.
@en Without LCSSA, operations like loop unrolling may force creation of PHI
@en nodes arbitrarily far from the loop, while in LCSSA, the SSA form can be
@en updated locally.  However, since we only keep real operands in LCSSA, we
@en cannot use this advantage (we could have local updating of real
@en operands, but it is not much more efficient than to use generic SSA form
@en updating for it as well; the amount of changes to SSA is the same).
@en @end itemize
@itemize
@item 
许多优化（值范围分析，最终值替换）都对在循环中定义的而在循环外使用的值感兴趣，即，对那些我们创建的新PHI节点。
@item 
在归约变量分析中，没有必要指定将要执行分析的循环——标量演化分析总是返回SSA名字被定义的循环。
@item 
它使得循环转换中更新SSA形式变得更简单。没有LCSSA的话，像循环展开这样的操作可能会强迫创建距离循环任意远的PHI节点，然而使用LCSSA的话，SSA形式能够被局部更新。不过，由于我们只是在LCSSA中保持真实的操作书，所以我们不能使用这个好处（我们本来能够局部更新真实操作数，但是这样并不比使用通用SSA形式更新更有效；对SSA的改动是相同的）。
@end itemize

@en However, it also means LCSSA must be updated.  This is usually
@en straightforward, unless you create a new value in loop and use it
@en outside, or unless you manipulate loop exit edges (functions are
@en provided to make these manipulations simple).
@en @code{rewrite_into_loop_closed_ssa} is used to rewrite SSA form to
@en LCSSA, and @code{verify_loop_closed_ssa} to check that the invariant of
@en LCSSA is preserved.
不管怎样，这还意味着LCSSA必须被更新。这通常是很直白的，除非你在循环中创建了一个新值，并在外面使用，或者除非你操作了循环出口边（有函数被提供使得这些操作变得简单）。@code{rewrite_into_loop_closed_ssa}用来将SSA形式重写为 LCSSA，@code{verify_loop_closed_ssa}用来检查LCSSA所保持的不变性。

@en @node Scalar evolutions
@en @section Scalar evolutions
@node 标量演化
@section 标量演化
@cindex Scalar evolutions
@cindex IV analysis on GIMPLE

@en Scalar evolutions (SCEV) are used to represent results of induction
@en variable analysis on GIMPLE@.  They enable us to represent variables with
@en complicated behavior in a simple and consistent way (we only use it to
@en express values of polynomial induction variables, but it is possible to
@en extend it).  The interfaces to SCEV analysis are declared in
@en @file{tree-scalar-evolution.h}.  To use scalar evolutions analysis,
@en @code{scev_initialize} must be used.  To stop using SCEV,
@en @code{scev_finalize} should be used.  SCEV analysis caches results in
@en order to save time and memory.  This cache however is made invalid by
@en most of the loop transformations, including removal of code.  If such a
@en transformation is performed, @code{scev_reset} must be called to clean
@en the caches.
标量演化（SCEV）用来表示在GIMPLE之上的归纳变量分析结果。它使得我们能够通过简单一致的方式来表示具有复杂性为的变量（我们只使用它来表示多项式归纳变量的值，但是是可以进一步扩展的）。SCEV分析的接口声明在@file{tree-scalar-evolution.h}中。要使用标量演化分析，则必须使用@code{scev_initialize}。要停止使用SCEV，则使用@code{scev_finalize}。为了节省时间和内存，SCEV分析会缓存结果。但是这些缓存会被大多数循环转换变为无效，包括代码移除。如果执行了这样的转换，则必须调用@code{scev_reset}来清除缓存。

@en Given an SSA name, its behavior in loops can be analyzed using the
@en @code{analyze_scalar_evolution} function.  The returned SCEV however
@en does not have to be fully analyzed and it may contain references to
@en other SSA names defined in the loop.  To resolve these (potentially
@en recursive) references, @code{instantiate_parameters} or
@en @code{resolve_mixers} functions must be used.
@en @code{instantiate_parameters} is useful when you use the results of SCEV
@en only for some analysis, and when you work with whole nest of loops at
@en once.  It will try replacing all SSA names by their SCEV in all loops,
@en including the super-loops of the current loop, thus providing a complete
@en information about the behavior of the variable in the loop nest.
@en @code{resolve_mixers} is useful if you work with only one loop at a
@en time, and if you possibly need to create code based on the value of the
@en induction variable.  It will only resolve the SSA names defined in the
@en current loop, leaving the SSA names defined outside unchanged, even if
@en their evolution in the outer loops is known.
给定一个SSA名字，
能够使用@code{analyze_scalar_evolution}函数来分析它在循环中的行为。然而返回的SCEV不需要被完全分析，并且它可以包含对其它定义在循环中的SSA名字的引用。必须使用@code{instantiate_parameters}或者@code{resolve_mixers}函数来解决这些（潜在的递归）引用。当你将SCEV的结果只用于某种分析时，并且一次工作于整个循环嵌套时，@code{instantiate_parameters}会很有用。它将尝试替换所有的SSA名字，用它们在所有循环中的SCEV，包括当前循环的外层循环，因此提供了在循环嵌套中的变量行为的完全信息。当你一次只工作于一个循环，并且可能需要根据归约变量的值来创建代码时，@code{resolve_mixers}会很有用。它会只解决定义在当前循环中的SSA名字，而保留外面定义的SSA名字不变，即使它们在外循环中的演化是已知的。

@en The SCEV is a normal tree expression, except for the fact that it may
@en contain several special tree nodes.  One of them is
@en @code{SCEV_NOT_KNOWN}, used for SSA names whose value cannot be
@en expressed.  The other one is @code{POLYNOMIAL_CHREC}.  Polynomial chrec
@en has three arguments -- base, step and loop (both base and step may
@en contain further polynomial chrecs).  Type of the expression and of base
@en and step must be the same.  A variable has evolution
@en @code{POLYNOMIAL_CHREC(base, step, loop)} if it is (in the specified
@en loop) equivalent to @code{x_1} in the following example
SCEV是一个标准的树表达式，除去实际上它可以包含多个特定的树节点。@code{SCEV_NOT_KNOWN}为其中之一，用于值无法被表示的SSA名字。另一个是@code{POLYNOMIAL_CHREC}。多项式chrec有三个参数—— base，step和loop（base和step都可以进一步包含多项式chrecs）。表达式，base和step的类型必须相同。在下面的例子中，如果变量（在特定的循环中）等于@code{x_1}，则具有演化@code{POLYNOMIAL_CHREC(base, step, loop)}。

@smallexample
while (@dots{})
  @{
    x_1 = phi (base, x_2);
    x_2 = x_1 + step;
  @}
@end smallexample

@en Note that this includes the language restrictions on the operations.
@en For example, if we compile C code and @code{x} has signed type, then the
@en overflow in addition would cause undefined behavior, and we may assume
@en that this does not happen.  Hence, the value with this SCEV cannot
@en overflow (which restricts the number of iterations of such a loop).
注意这包括操作数上的语言限制。例如，如果我们编译C代码，并且@code{x}具有有符号类型，那么加法溢出将会产生未定义行为，并且我们可以假设这并没有发生。因此，SCEV的值不能溢出。

@en In many cases, one wants to restrict the attention just to affine
@en induction variables.  In this case, the extra expressive power of SCEV
@en is not useful, and may complicate the optimizations.  In this case,
@en @code{simple_iv} function may be used to analyze a value -- the result
@en is a loop-invariant base and step.
许多情况下，只是想放射归约变量。这时，额外的SCEV的表达式幂就没有用处，并且可能会使优化变得复杂。这时，可以使用@code{simple_iv}函数来分析一个值——结果为循环不变量base和step。

@en @node loop-iv
@en @section IV analysis on RTL
@node loop-iv
@section RTL上的IV分析
@cindex IV analysis on RTL

@en The induction variable on RTL is simple and only allows analysis of
@en affine induction variables, and only in one loop at once.  The interface
@en is declared in @file{cfgloop.h}.  Before analyzing induction variables
@en in a loop L, @code{iv_analysis_loop_init} function must be called on L.
@en After the analysis (possibly calling @code{iv_analysis_loop_init} for
@en several loops) is finished, @code{iv_analysis_done} should be called.
@en The following functions can be used to access the results of the
@en analysis:
RTL之上的归约变量很简单，并且只允许一次在一个循环中，仿射归约变量的分析。接口在@file{cfgloop.h}中声明。在循环L中分析归约变量之前，必须在L上调用@code{iv_analysis_loop_init}函数。分析完成之后（可能会为多个循环调用@code{iv_analysis_loop_init}），应该调用@code{iv_analysis_done}。下面的函数能够被用来访问分析结果：

@en @itemize
@en @item @code{iv_analyze}: Analyzes a single register used in the given
@en insn.  If no use of the register in this insn is found, the following
@en insns are scanned, so that this function can be called on the insn
@en returned by get_condition.
@en @item @code{iv_analyze_result}: Analyzes result of the assignment in the
@en given insn.
@en @item @code{iv_analyze_expr}: Analyzes a more complicated expression.
@en All its operands are analyzed by @code{iv_analyze}, and hence they must
@en be used in the specified insn or one of the following insns.
@en @end itemize
@itemize
@item @code{iv_analyze}: 
分析在给定insn中的单个寄存器。如果在该insn中没有使用寄存器，则扫描下一个insn，因此该函数能够在通过get_condition返回的insn上被调用。
@item @code{iv_analyze_result}: 
分析给定insn的赋值结果。
@item @code{iv_analyze_expr}: 
分析一个更加复杂的表达式。其所有操作数都通过@code{iv_analyze}来分析，因此它们必须用在特定insn中，或者后面insn的其中之一。
@end itemize

@en The description of the induction variable is provided in @code{struct
@en rtx_iv}.  In order to handle subregs, the representation is a bit
@en complicated; if the value of the @code{extend} field is not
@en @code{UNKNOWN}, the value of the induction variable in the i-th
@en iteration is
归约变量的描述在@code{struct rtx_iv}中。为了处理子寄存器，该表示有些复杂；如果@code{extend}域的值不是@code{UNKNOWN}，则归约变量在第i次迭代时的值为

@smallexample
delta + mult * extend_@{extend_mode@} (subreg_@{mode@} (base + i * step)),
@end smallexample

@en with the following exception:  if @code{first_special} is true, then the
@en value in the first iteration (when @code{i} is zero) is @code{delta +
@en mult * base}.  However, if @code{extend} is equal to @code{UNKNOWN},
@en then @code{first_special} must be false, @code{delta} 0, @code{mult} 1
@en and the value in the i-th iteration is
不过下面的情况例外：如果@code{first_special}为真，则在首次迭代时（当@code{i}为0时），值为@code{delta + mult * base}。然而，如果@code{extend}等于@code{UNKNOWN}，则@code{first_special}必须为假，@code{delta}为0，@code{mult}为1，并且在第i次迭代时的值为

@smallexample
subreg_@{mode@} (base + i * step)
@end smallexample

@en The function @code{get_iv_value} can be used to perform these
@en calculations.
函数@code{get_iv_value}可以用来执行这些计算。

@en @node Number of iterations
@en @section Number of iterations analysis
@node 迭代次数
@section 迭代次数分析
@cindex Number of iterations analysis

@en Both on GIMPLE and on RTL, there are functions available to determine
@en the number of iterations of a loop, with a similar interface.  The
@en number of iterations of a loop in GCC is defined as the number of
@en executions of the loop latch.  In many cases, it is not possible to
@en determine the number of iterations unconditionally -- the determined
@en number is correct only if some assumptions are satisfied.  The analysis
@en tries to verify these conditions using the information contained in the
@en program; if it fails, the conditions are returned together with the
@en result.  The following information and conditions are provided by the
@en analysis:
在GIMPLE和RTL之上，都有函数可以用来判定循环的迭代次数，并且具有相似的接口。在GCC中，循环的迭代次数被定义为循环latch的执行次数。许多情况下，是不可能无条件的判定出迭代次数——判定的迭代次数只有在满足一些假设时才正确。分析尝试使用包含在程序中的信息来检验这些条件；如果失败了，则条件和结果一起被返回。下面的信息和条件由分析提供：

@en @itemize
@en @item @code{assumptions}: If this condition is false, the rest of
@en the information is invalid.
@en @item @code{noloop_assumptions} on RTL, @code{may_be_zero} on GIMPLE: If
@en this condition is true, the loop exits in the first iteration.
@en @item @code{infinite}: If this condition is true, the loop is infinite.
@en This condition is only available on RTL@.  On GIMPLE, conditions for
@en finiteness of the loop are included in @code{assumptions}.
@en @item @code{niter_expr} on RTL, @code{niter} on GIMPLE: The expression
@en that gives number of iterations.  The number of iterations is defined as
@en the number of executions of the loop latch.
@en @end itemize
@itemize
@item @code{assumptions}: 
如果条件为假，则其余的信息无效。
@item RTL上的@code{noloop_assumptions}, GIMPLE上的@code{may_be_zero}: 
如果该条件为真，则循环在第一次迭代中便退出。
@item @code{infinite}: 
If this condition is true, the loop is infinite.
This condition is only available on RTL@.  On GIMPLE, conditions for
finiteness of the loop are included in @code{assumptions}.
@item RTL上的@code{niter_expr} , GIMPLE上的@code{niter}: 
该表达式给出迭代次数。迭代次数被定义为循环latch的执行次数。
@end itemize

@en Both on GIMPLE and on RTL, it necessary for the induction variable
@en analysis framework to be initialized (SCEV on GIMPLE, loop-iv on RTL).
@en On GIMPLE, the results are stored to @code{struct tree_niter_desc}
@en structure.  Number of iterations before the loop is exited through a
@en given exit can be determined using @code{number_of_iterations_exit}
@en function.  On RTL, the results are returned in @code{struct niter_desc}
@en structure.  The corresponding function is named
@en @code{check_simple_exit}.  There are also functions that pass through
@en all the exits of a loop and try to find one with easy to determine
@en number of iterations -- @code{find_loop_niter} on GIMPLE and
@en @code{find_simple_exit} on RTL@.  Finally, there are functions that
@en provide the same information, but additionally cache it, so that
@en repeated calls to number of iterations are not so costly --
@en @code{number_of_latch_executions} on GIMPLE and @code{get_simple_loop_desc}
@en on RTL.
在GIMPLE和RTL之上，都需要初始化归约变量分析框架（GIMPLE上为SCEV，RTL上为loop-iv）。在GIMPLE上，结果存储在@code{struct tree_niter_desc}中。可以通过@code{number_of_iterations_exit}函数来判定循环在通过给定出口退出之前的迭代次数。在RTL上，结果返回在@code{struct niter_desc}结构体中，相应的函数名为@code{check_simple_exit}。还有一些函数遍历循环的所有出口，并尝试找到容易判定迭代次数的一个——它们是GIMPLE上的@code{find_loop_niter}和RTL上的@code{find_simple_exit}。最后，还有一些函数提供相同的信息，只不过还额外的对其进行缓存，使得反复调用迭代次数的代价不会很高——它们是GIMPLE上的@code{number_of_latch_executions}和RTL上的@code{get_simple_loop_desc}。

@en Note that some of these functions may behave slightly differently than
@en others -- some of them return only the expression for the number of
@en iterations, and fail if there are some assumptions.  The function
@en @code{number_of_latch_executions} works only for single-exit loops.
@en The function @code{number_of_cond_exit_executions} can be used to
@en determine number of executions of the exit condition of a single-exit
@en loop (i.e., the @code{number_of_latch_executions} increased by one).
注意这些函数中的一些可能与其它的在行为上有些不同——有些只返回迭代次数的表达式。函数@code{number_of_latch_executions}只工作于单个出口的循环。函数@code{number_of_cond_exit_executions}能被用来判定一个单出口循环在退出条件下的执行次数。（即，@code{number_of_latch_executions}加1）。

@en @node Dependency analysis
@en @section Data Dependency Analysis
@node 依赖分析
@section 数据依赖分析
@cindex Data Dependency Analysis

@en The code for the data dependence analysis can be found in
@en @file{tree-data-ref.c} and its interface and data structures are
@en described in @file{tree-data-ref.h}.  The function that computes the
@en data dependences for all the array and pointer references for a given
@en loop is @code{compute_data_dependences_for_loop}.  This function is
@en currently used by the linear loop transform and the vectorization
@en passes.  Before calling this function, one has to allocate two vectors:
@en a first vector will contain the set of data references that are
@en contained in the analyzed loop body, and the second vector will contain
@en the dependence relations between the data references.  Thus if the
@en vector of data references is of size @code{n}, the vector containing the
@en dependence relations will contain @code{n*n} elements.  However if the
@en analyzed loop contains side effects, such as calls that potentially can
@en interfere with the data references in the current analyzed loop, the
@en analysis stops while scanning the loop body for data references, and
@en inserts a single @code{chrec_dont_know} in the dependence relation
@en array.
用于数据相关性分析的代码可以在@file{tree-data-ref.c}中找到，接口和数据结构在@file{tree-data-ref.h}中描述。用来计算对于给定循环的所有数组和指针引用的数据相关性的函数为@code{compute_data_dependences_for_loop}。该函数目前被用于线性循环转换和向量化过程。在调用该函数之前，必须分配两个向量：第一个向量将会包含在被分析的循环体中的数据引用集，第二个将会包含数据引用之间的依赖关系。因此，如果数据引用向量的大小为@code{n}，则包含依赖关系的向量将包含@code{n*n}个元素。但是，如果被分析的循环包含副作用，例如对数据引用有潜在干扰的调用，则分析会在扫描循环体中的数据引用时停住，并在依赖关系数组中插入一个@code{chrec_dont_know}。

@en The data references are discovered in a particular order during the
@en scanning of the loop body: the loop body is analyzed in execution order,
@en and the data references of each statement are pushed at the end of the
@en data reference array.  Two data references syntactically occur in the
@en program in the same order as in the array of data references.  This
@en syntactic order is important in some classical data dependence tests,
@en and mapping this order to the elements of this array avoids costly
@en queries to the loop body representation.
数据相关性是在扫描循环体时，按照特定顺序发现的：循环体按照执行顺序分析，每条语句的数据引用被压入数据引用数组的尾部。两个数据相关性在程序中的语法位置，和在数据相关性数组具有相同的顺序。这种语法顺序在一些经典数据相关性测试中很重要，并且将这中顺序映射到数组的元素可以避免对循环体表示的昂贵查询开销。

@en Three types of data references are currently handled: ARRAY_REF, 
@en INDIRECT_REF and COMPONENT_REF@. The data structure for the data reference 
@en is @code{data_reference}, where @code{data_reference_p} is a name of a 
@en pointer to the data reference structure. The structure contains the 
@en following elements:
目前处理了三种类型的数据相关性：ARRAY_REF, INDIRECT_REF和COMPONENT_REF。数据相关性的数据结构体为@code{data_reference}，其中@code{data_reference_p}为指向数据相关性结构体的指针名。结构体包含了以下元素：

@itemize
@en @item @code{base_object_info}: Provides information about the base object 
@en of the data reference and its access functions. These access functions 
@en represent the evolution of the data reference in the loop relative to 
@en its base, in keeping with the classical meaning of the data reference 
@en access function for the support of arrays. For example, for a reference 
@en @code{a.b[i][j]}, the base object is @code{a.b} and the access functions, 
@en one for each array subscript, are: 
@en @code{@{i_init, + i_step@}_1, @{j_init, +, j_step@}_2}.
@item @code{base_object_info}: 
提供了关于数据引用的基本对象的信息，以及访问函数代表了数据引用在循环中相对于它的基的演变。这些访问函数。例如，对于一个引用@code{a.b[i][j]}，基本对象为@code{a.b}，其中一个针对每个数组下标的访问函数为：@code{@{i_init, + i_step@}_1, @{j_init, +, j_step@}_2}。

@en @item @code{first_location_in_loop}: Provides information about the first 
@en location accessed by the data reference in the loop and about the access 
@en function used to represent evolution relative to this location. This data 
@en is used to support pointers, and is not used for arrays (for which we 
@en have base objects). Pointer accesses are represented as a one-dimensional
@en access that starts from the first location accessed in the loop. For 
@en example:
@item @code{first_location_in_loop}: 提供了循环中由数据引用访问的第一个位置，以及用来表示相对于该位置的演化的访问函数。该数据用来支持指针，而不是数组（具有基对象的）。指针访问被表示为从循环中的第一个位置开始的一维访问。例如:

@smallexample
      for1 i
         for2 j
          *((int *)p + i + j) = a[i][j];
@end smallexample

@en The access function of the pointer access is @code{@{0, + 4B@}_for2} 
@en relative to @code{p + i}. The access functions of the array are 
@en @code{@{i_init, + i_step@}_for1} and @code{@{j_init, +, j_step@}_for2} 
@en relative to @code{a}.
对于@code{p + i}，指针访问的访问函数是@code{@{0, + 4B@}_for2}。对于@code{a}，数组的访问函数是@code{@{i_init, + i_step@}_for1}和@code{@{j_init, +, j_step@}_for2}。

@en Usually, the object the pointer refers to is either unknown, or we can't 
@en prove that the access is confined to the boundaries of a certain object. 
通常，指针指向的对象或者是不可知的，或者是我们不能证明访问被限制在这些对象的边界中。

@en Two data references can be compared only if at least one of these two 
@en representations has all its fields filled for both data references. 
两个数据引用只有在最起码有一个表示的所有域都适合于这两个数据引用时，才能够进行比较。

@en The current strategy for data dependence tests is as follows: 
@en If both @code{a} and @code{b} are represented as arrays, compare 
@en @code{a.base_object} and @code{b.base_object};
@en if they are equal, apply dependence tests (use access functions based on 
@en base_objects).
@en Else if both @code{a} and @code{b} are represented as pointers, compare 
@en @code{a.first_location} and @code{b.first_location}; 
@en if they are equal, apply dependence tests (use access functions based on 
@en first location).
@en However, if @code{a} and @code{b} are represented differently, only try 
@en to prove that the bases are definitely different.
目前测试数据相关性的策略为：如果@code{a}和@code{b}都由数组来表示，则比较@code{a.base_object}和@code{b.base_object}；如果它们相等，则应用相关性测试（使用基于base_objects的访问函数）。如果@code{a}和@code{b}都由指针表示，则比较@code{a.first_location}和@code{b.first_location}；如果它们相等，则应用相关性测试（使用基于第一位置的访问函数）。但是，如果@code{a}和@code{b}的表示不同，只能尝试去证明它们的基肯定不相同。

@en @item Aliasing information.
@en @item Alignment information.
@item 别名信息。
@item 对齐信息。
@end itemize

@en The structure describing the relation between two data references is
@en @code{data_dependence_relation} and the shorter name for a pointer to
@en such a structure is @code{ddr_p}.  This structure contains:
描述两个数据引用之间关系的结构体是@code{data_dependence_relation}，指向这种结构体的指针的简短名字为@code{ddr_p}。该结构体包含：

@en @itemize
@en @item a pointer to each data reference,
@en @item a tree node @code{are_dependent} that is set to @code{chrec_known}
@en if the analysis has proved that there is no dependence between these two
@en data references, @code{chrec_dont_know} if the analysis was not able to
@en determine any useful result and potentially there could exist a
@en dependence between these data references, and @code{are_dependent} is
@en set to @code{NULL_TREE} if there exist a dependence relation between the
@en data references, and the description of this dependence relation is
@en given in the @code{subscripts}, @code{dir_vects}, and @code{dist_vects}
@en arrays,
@en @item a boolean that determines whether the dependence relation can be
@en represented by a classical distance vector, 
@en @item an array @code{subscripts} that contains a description of each
@en subscript of the data references.  Given two array accesses a
@en subscript is the tuple composed of the access functions for a given
@en dimension.  For example, given @code{A[f1][f2][f3]} and
@en @code{B[g1][g2][g3]}, there are three subscripts: @code{(f1, g1), (f2,
@en g2), (f3, g3)}.
@en @item two arrays @code{dir_vects} and @code{dist_vects} that contain
@en classical representations of the data dependences under the form of
@en direction and distance dependence vectors,
@en @item an array of loops @code{loop_nest} that contains the loops to
@en which the distance and direction vectors refer to.
@en @end itemize
@itemize
@item 每个数据引用的指针，
@item 
一个树节点@code{are_dependent}，如果分析证明了两个数据引用之间没有相关性，则设置为@code{chrec_known}；如果分析不能判定任何有用的结果，并且这些数据引用可能存在相关性，则设为@code{chrec_dont_know}；如果数据引用间存在相关性，则设置为@code{NULL_TREE}，并且该相关性的描述在@code{dir_vects}和@code{dist_vects}数组的下标中给出。
@item 一个布尔值，用来判定依赖关系是否能被表示为经典的距离向量， 
@item 
一个数组@code{subscripts}，包含了数据引用的每个下标的描述。给出两个数组访问，下标为对于给定维数的访问组合。例如，给定@code{A[f1][f2][f3]}和@code{B[g1][g2][g3]}，则有三个下标：@code{(f1, g1), (f2, g2), (f3, g3)}。
@item 
两个数组@code{dir_vects}和@code{dist_vects}，包含了使用方向和距离依赖向量的数据相关典型表示。@item 循环数组@code{loop_nest}，包含了距离和方向向量指向的循环。 
@end itemize

@en Several functions for pretty printing the information extracted by the
@en data dependence analysis are available: @code{dump_ddrs} prints with a
@en maximum verbosity the details of a data dependence relations array,
@en @code{dump_dist_dir_vectors} prints only the classical distance and
@en direction vectors for a data dependence relations array, and
@en @code{dump_data_references} prints the details of the data references
@en contained in a data reference array.
有一些函数可以很好的打印由数据相关分析抽出的信息：@code{dump_ddrs}打印最详尽的数据依赖关系数组，@code{dump_dist_dir_vectors}只打印数据依赖关系数组的典型的距离和方向向量，@code{dump_data_references}打印数据引用数组中的详细的数据引用。

@en @node Lambda
@en @section Linear loop transformations framework
@node Lambda
@section 线性循环转换框架
@cindex Linear loop transformations framework

@en Lambda is a framework that allows transformations of loops using
@en non-singular matrix based transformations of the iteration space and
@en loop bounds. This allows compositions of skewing, scaling, interchange,
@en and reversal transformations.  These transformations are often used to
@en improve cache behavior or remove inner loop dependencies to allow
@en parallelization and vectorization to take place.
Lambda是一个允许循环转换使用基于迭代空间和循环边界的非退化矩阵的框架。这允许组合使用skewing，scaling，interchange，和reversal转换。这些转换常用来提高cache行为，或者移除内部循环依赖使得可以进行并行化或者向量化。

@en To perform these transformations, Lambda requires that the loopnest be
@en converted into an internal form that can be matrix transformed easily.
@en To do this conversion, the function
@en @code{gcc_loopnest_to_lambda_loopnest} is provided.  If the loop cannot
@en be transformed using lambda, this function will return NULL.
为了执行这些转换，Lambda需要loopnest转化为可以被很容易的进行矩阵转换的内部形式。函数@code{gcc_loopnest_to_lambda_loopnest}用来做这种转换。如果循环不能够使用lambda转换，这个函数将返回NULL。

@en Once a @code{lambda_loopnest} is obtained from the conversion function,
@en it can be transformed by using @code{lambda_loopnest_transform}, which
@en takes a transformation matrix to apply.  Note that it is up to the
@en caller to verify that the transformation matrix is legal to apply to the
@en loop (dependence respecting, etc).  Lambda simply applies whatever
@en matrix it is told to provide.  It can be extended to make legal matrices
@en out of any non-singular matrix, but this is not currently implemented.
@en Legality of a matrix for a given loopnest can be verified using
@en @code{lambda_transform_legal_p}.
一旦通过转换函数获得lambda_loopnest，便可以使用@code{lambda_loopnest_transform}来进行各种转换处理，其接受一个转换矩阵。注意这是由调用者来检验转换矩阵是否合法，即可以应用到循环上的。Lambda只是简单的应用提供给它的矩阵。可以扩展为使用任何非退化矩阵之外的矩阵，不过现在还没有实现。可以使用@code{lambda_transform_legal_p}来检验给定loopnest的矩阵的合法性。

@en Given a transformed loopnest, conversion back into gcc IR is done by
@en @code{lambda_loopnest_to_gcc_loopnest}.  This function will modify the
@en loops so that they match the transformed loopnest.
给定一个转换过的loopnest，可以通过@code{lambda_loopnest_to_gcc_loopnest}来将其转化回到gcc IR。该函数会修改循环使得它们匹配转换过的loopnest。

@en @node Omega
@en @section Omega a solver for linear programming problems
@node Omega
@section Omega 一种对线性规划问题的求解
@cindex Omega a solver for linear programming problems

@en The data dependence analysis contains several solvers triggered
@en sequentially from the less complex ones to the more sophisticated.
@en For ensuring the consistency of the results of these solvers, a data
@en dependence check pass has been implemented based on two different
@en solvers.  The second method that has been integrated to GCC is based
@en on the Omega dependence solver, written in the 1990's by William Pugh
@en and David Wonnacott.  Data dependence tests can be formulated using a
@en subset of the Presburger arithmetics that can be translated to linear
@en constraint systems.  These linear constraint systems can then be
@en solved using the Omega solver.
数据相关性分析包含多个求解器，从不太复杂的到比较复杂的。为了确保这些求解器的结果的一致性，实现了一个基于不同求解器的数据相关性检查过程。已经被集成到GCC中的第二种方法是基于Omega相关求解器，由William Pugh和David Wonnacott在1990年编写。数据相关性测试能够通过使用Presburger算法的子集来公式化，从而可以转化为线性约束系统。然后这些线性约束系统能够使用Omega求解器求解。

@en The Omega solver is using Fourier-Motzkin's algorithm for variable
@en elimination: a linear constraint system containing @code{n} variables
@en is reduced to a linear constraint system with @code{n-1} variables.
@en The Omega solver can also be used for solving other problems that can
@en be expressed under the form of a system of linear equalities and
@en inequalities.  The Omega solver is known to have an exponential worst
@en case, also known under the name of ``omega nightmare'' in the
@en literature, but in practice, the omega test is known to be efficient
@en for the common data dependence tests.
Omega求解器使用Fourier-Motzkin算法进行变量消除：一个包含@code{n}个变量的线性约束系统被消减为包含@code{n-1}个变量的线性约束系统。Omega求解器还能够用来解决其它能被表示为线性等式和不等式系统形式的问题。Omega求解器有一个公认的指数最坏情况，即文献上称之的“omega 恶梦”，不过实际上，众所周知omega测试对于公用数据相关性测试是有效的。

@en The interface used by the Omega solver for describing the linear
@en programming problems is described in @file{omega.h}, and the solver is
@en @code{omega_solve_problem}.  
Omega求解器所使用的描述线性规划问题接口在@file{omega.h}中，求解器为@code{omega_solve_problem}。
