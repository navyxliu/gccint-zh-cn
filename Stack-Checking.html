<html lang="zh">
<head>
<title>Stack Checking - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="prev" href="Exception-Handling.html#Exception-Handling" title="Exception Handling">
<link rel="next" href="Frame-Registers.html#Frame-Registers" title="Frame Registers">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Stack-Checking"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Frame-Registers.html#Frame-Registers">Frame Registers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Exception-Handling.html#Exception-Handling">Exception Handling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>
<hr>
</div>

<h4 class="subsection">17.10.3 指定如何进行栈检查</h4>

<!-- GCC will check that stack references are within the boundaries of the -->
<!-- stack, if the option @option{-fstack-check} is specified, in one of -->
<!-- three ways: -->
<p>GCC将检查栈引用是否位于栈的边界里，如果指定了<samp><span class="option">-fstack-check</span></samp>，使用三种方式的之一：

     <ol type=1 start=1>
<li><!-- If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC -->
<!-- will assume that you have arranged for full stack checking to be done -->
<!-- at appropriate places in the configuration files.  GCC will not do -->
<!-- other special processing. -->
如果<code>STACK_CHECK_BUILTIN</code>宏的值为非0，则GCC将假设你已经安排了在配置文件的合适的地方进行栈检查，例如，在TARGET_ASM_FUNCTION_PROLOGUE中。GCC将不再做其它特殊的处理。

     <li>If <code>STACK_CHECK_BUILTIN</code> is zero and the value of the
<code>STACK_CHECK_STATIC_BUILTIN</code> macro is nonzero, GCC will assume
that you have arranged for static stack checking (checking of the
static stack frame of functions) to be done at appropriate places
in the configuration files.  GCC will only emit code to do dynamic
stack checking (checking on dynamic stack allocations) using the third
approach below.

     <li><!-- If neither of the above are true, GCC will generate code to periodically -->
<!-- ``probe'' the stack pointer using the values of the macros defined below. -->
如果上面两种方式都不是，则GCC将生成代码来周期的“探测”栈指针，使用下面定义的宏的值。
      </ol>

 <p>If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is defined,
GCC will change its allocation strategy for large objects if the option
<samp><span class="option">-fstack-check</span></samp> is specified: they will always be allocated
dynamically if their size exceeds <code>STACK_CHECK_MAX_VAR_SIZE</code> bytes.

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_BUILTIN</b><var><a name="index-STACK_005fCHECK_005fBUILTIN-4086"></a></var><br>
<blockquote><p>A nonzero value if stack checking is done by the configuration files in a
machine-dependent manner.  You should define this macro if stack checking
is required by the ABI of your machine or if you would like to do stack
checking in some more efficient way than the generic approach.  The default
value of this macro is zero. 
一个非0值，如果栈检查按照机器相关的方式通过配置文件来完成。你应该定义该宏，如果栈检查被你的机器的ABI要求，或者你想让栈检查使用比GCC可移植方式更有效的方法。该宏的缺省值为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_STATIC_BUILTIN</b><var><a name="index-STACK_005fCHECK_005fSTATIC_005fBUILTIN-4087"></a></var><br>
<blockquote><p>A nonzero value if static stack checking is done by the configuration files
in a machine-dependent manner.  You should define this macro if you would
like to do static stack checking in some more efficient way than the generic
approach.  The default value of this macro is zero. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_PROBE_INTERVAL_EXP</b><var><a name="index-STACK_005fCHECK_005fPROBE_005fINTERVAL_005fEXP-4088"></a></var><br>
<blockquote><p>An integer specifying the interval at which GCC must generate stack probe
instructions, defined as 2 raised to this integer.  You will normally
define this macro so that the interval be no larger than the size of
the &ldquo;guard pages&rdquo; at the end of a stack area.  The default value
of 12 (4096-byte interval) is suitable for most systems. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_MOVING_SP</b><var><a name="index-STACK_005fCHECK_005fMOVING_005fSP-4089"></a></var><br>
<blockquote><p>An integer which is nonzero if GCC should move the stack pointer page by page
when doing probes.  This can be necessary on systems where the stack pointer
contains the bottom address of the memory area accessible to the executing
thread at any point in time.  In this situation an alternate signal stack
is required in order to be able to recover from a stack overflow.  The
default value of this macro is zero. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_PROTECT</b><var><a name="index-STACK_005fCHECK_005fPROTECT-4090"></a></var><br>
<blockquote><p>The number of bytes of stack needed to recover from a stack overflow, for
languages where such a recovery is supported.  The default value of 75 words
with the <code>setjmp</code>/<code>longjmp</code>-based exception handling mechanism and
8192 bytes with other exception handling mechanisms should be adequate for
most machines. 
</p></blockquote></div>

 <p>The following macros are relevant only if neither STACK_CHECK_BUILTIN
nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether
in the opposite case.

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_MAX_FRAME_SIZE</b><var><a name="index-STACK_005fCHECK_005fMAX_005fFRAME_005fSIZE-4091"></a></var><br>
<blockquote><!-- The maximum size of a stack frame, in bytes.  GCC will generate probe -->
     <!-- instructions in non-leaf functions to ensure at least this many bytes of -->
     <!-- stack are available.  If a stack frame is larger than this size, stack -->
     <!-- checking will not be reliable and GCC will issue a warning.  The -->
     <!-- default is chosen so that GCC only generates one instruction on most -->
     <!-- systems.  You should normally not change the default value of this macro. -->
      <p>一个栈帧的最大大小，以字节为单位。GCC将生成探测指令在非叶子函数来确保栈中至少这么多大小的字节是可用的。如果一个栈帧大于该大小，则栈检查将不可靠并且GCC将产生一个警告。缺省值被选择，使得GCC只生成一条指令，在大多数系统上。你通常不应该修改该宏的缺省值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_FIXED_FRAME_SIZE</b><var><a name="index-STACK_005fCHECK_005fFIXED_005fFRAME_005fSIZE-4092"></a></var><br>
<blockquote><!-- GCC uses this value to generate the above warning message.  It -->
     <!-- represents the amount of fixed frame used by a function, not including -->
     <!-- space for any callee-saved registers, temporaries and user variables. -->
     <!-- You need only specify an upper bound for this amount and will normally -->
     <!-- use the default of four words. -->
      <p>GCC使用该值来生成上面的警告消息。其表示函数使用的固定的帧数量，不包括用于任何被调用者保存的寄存器，临时变量和用户变量的空间。你只需要指定该数量的上界并且通常使用缺省值，4个字。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_MAX_VAR_SIZE</b><var><a name="index-STACK_005fCHECK_005fMAX_005fVAR_005fSIZE-4093"></a></var><br>
<blockquote><!-- The maximum size, in bytes, of an object that GCC will place in the -->
     <!-- fixed area of the stack frame when the user specifies -->
     <!-- @option{-fstack-check}. -->
     <!-- GCC computed the default from the values of the above macros and you will -->
     <!-- normally not need to override that default. -->
      <p>为当用户指定<samp><span class="option">-fstack-check</span></samp>时，GCC将在栈帧的固定域放入的对象的最大大小，以字节为单位。GCC根据上面的宏来计算缺省值并且你通常不需要覆盖缺省值。
</p></blockquote></div>

<!-- @node Frame Registers -->
<!-- @subsection Registers That Address the Stack Frame -->
 </body></html>

