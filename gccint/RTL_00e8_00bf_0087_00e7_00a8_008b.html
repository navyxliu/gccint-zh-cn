<html lang="zh">
<head>
<title>RTL过程 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Passes.html#Passes" title="Passes">
<link rel="prev" href="Tree_002dSSA_00e8_00bf_0087_00e7_00a8_008b.html#Tree_002dSSA_00e8_00bf_0087_00e7_00a8_008b" title="Tree-SSA过程">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="RTL%e8%bf%87%e7%a8%8b"></a>
<a name="RTL_00e8_00bf_0087_00e7_00a8_008b"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Tree_002dSSA_00e8_00bf_0087_00e7_00a8_008b.html#Tree_002dSSA_00e8_00bf_0087_00e7_00a8_008b">Tree-SSA过程</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Passes.html#Passes">Passes</a>
<hr>
</div>

<h3 class="section">8.5 RTL过程</h3>

<p>下面简要描述了tree优化之后所运行的rtl生成和优化过程。

     <ul>
<li>RTL生成

     <p>实现RTL生成的源文件包括
<samp><span class="file">stmt.c</span></samp>,
<samp><span class="file">calls.c</span></samp>,
<samp><span class="file">expr.c</span></samp>,
<samp><span class="file">explow.c</span></samp>,
<samp><span class="file">expmed.c</span></samp>,
<samp><span class="file">function.c</span></samp>,
<samp><span class="file">optabs.c</span></samp>和<samp><span class="file">emit-rtl.c</span></samp>。
该过程还用到了由<code>genemit</code>程序通过机器描述生成的<samp><span class="file">insn-emit.c</span></samp>文件。
该过程使用头文件<samp><span class="file">expr.h</span></samp>来交互信息。

     <p><a name="index-genflags-1684"></a><a name="index-gencodes-1685"></a>由程序<code>genflags</code>和<code>gencodes</code>通过机器描述来生成的头文件
<samp><span class="file">insn-flags.h</span></samp>和<samp><span class="file">insn-codes.h</span></samp>，告诉了该过程哪些标准名字可用，
以及哪些模式与它们对应。

     <li>生成异常处理着陆架（Generate exception handling landing pads）

     <p>该过程生成用来管理异常处理库程序和函数中的异常处理器之间通讯的粘合机制（glue）。
由异常处理库调用的函数的入口点，被称作着陆架（<dfn>landing pads</dfn>）。
该过程的代码位于<samp><span class="file">except.c</span></samp>中。

     <li>清除控制流图（Cleanup control flow graph）

     <p>该过程去除不可达代码，对跳转到下一条指令（jumps to next），
连续跳转（jumps to jump），交叉跳转（jumps across jumps）等情况进行简化。
该过程被运行多次。出于历史原因，该过程有时被称为“跳转优化过程”。
该过程的主要代码在<samp><span class="file">cfgcleanup.c</span></samp>中，
还有一些辅助程序在<samp><span class="file">cfgrtl.c</span></samp>和<samp><span class="file">jump.c</span></samp>中。

     <li>单定义值的向前传播（Forward propagation of single-def values）

     <p>该过程尝试通过替换来自单一定义的变量，并观察结果是否能够被简化的方式，
来去除冗余计算。它执行了复制传播和寻址模式选择。该过程运行两次，
并只在第二次的时候将值传播到循环中。它位于<samp><span class="file">fwprop.c</span></samp>中。

     <li>公共子表达式消除（Common subexpression elimination）

     <p>该过程去除基本块中的冗余计算，并且根据代价来优化寻址模式。该过程运行两次。
源代码位于<samp><span class="file">cse.c</span></samp>中。

     <li>全局公共子表达式消除（Global common subexpression elimination）

     <p>该过程执行两种不同类型的GCSE，取决于你是否在优化代码大小（基于LCM的GCSE趋向于通
过增加代码大小来获得速度，而基于Morel- Renvoise的GCSE则不是）。当优化代码大小时
，使用Morel-Renvoise Partial Redundancy Elimination（部分冗余消除）来做GCSE，
并不尝试将不变量移到循环之外——这留到循环优化过程。如果进行MR PRE，
则还会进行代码提升（code hoisting），（也称为code unification），
还有加载移动（load motion）。如果你在优化速度，则会进行基于LCM
（lazy code motion）的GCSE。LCM是基于Knoop, Ruthing和Steffen的工作。
基于LCM的GCSE也会进行循环不变量代码移动。当优化速度时，
我们还执行加载和存储移动。不管使用哪一种类型的GCSE，
该过程都还执行全局常量传播和复制传播。该过程的源代码为<samp><span class="file">gcse.c</span></samp>，
LCM程序在<samp><span class="file">lcm.c</span></samp>中。

     <li>循环优化（Loop optimization）

     <p>该过程执行几个循环相关的优化。源文件<samp><span class="file">cfgloopanal.c</span></samp>和<samp><span class="file">cfgloopmanip.c</span></samp>
包含了通用的循环分析和操作代码。循环结构体的初始化和完成（finalization）
由<samp><span class="file">loop-init.c</span></samp>处理。循环不变量移动过程在<samp><span class="file">loop-invariant.c</span></samp>中实现。
基本块级的优化—— unrolling,peeling和unswitching——在<samp><span class="file">loop-unswitch.c</span></samp>和
<samp><span class="file">loop-unroll.c</span></samp>中实现。<samp><span class="file">loop-doloop.c</span></samp>是关于使用特定的机器相关结构来
替代循环退出条件的处理。

     <li>跳转迂回（Jump bypassing）

     <p>该过程是GCSE的激进形式，通过传播常数到条件分支指令中来转换函数的控制流图。
该过程的源文件为<samp><span class="file">gcse.c</span></samp>。

     <li>If转换（If conversion）
该过程尝试使用产生比较指令和条件移送指令的算术的布尔值，来替换条件分支和附近的赋值。在重载之后最近的调用中，当目标机支持的时候，其将生成断言指令。该过程位于<samp><span class="file">ifcvt.c</span></samp>。

     <li>Web构造（Web construction）

     <p>该过程拆分为独立的使用每个伪寄存器。这能够提高其它转换过程的效率，
例如CSE或者寄存器分配。源文件为<samp><span class="file">web.c</span></samp>。

     <li>生命期分析（Life analysis）

     <p>该过程计算在程序的每个点上哪些伪寄存器是活跃的，
并且使第一条指令使用一个值来指向计算值的指令。
然后它删除结果从来不会被使用的计算，
并且将内存引用和加减指令组合为自动增量或者自动减量寻址。
该过程位于<samp><span class="file">flow.c</span></samp>中。

     <li>指令合并（Instruction combination）

     <p>该过程尝试去将数据流相关的两条或者三条指令组合并为单一指令。它通过替代，
使用代数简化结果的方式来为指令合并RTL表达式，然后尝试去将结果跟机器描述匹配。
该过程位于<samp><span class="file">combine.c</span></samp>。

     <li>寄存器移动（Register movement）

     <p>该过程寻找这样的情况，即当匹配约束条件时会迫使指令需要重载，
并且这个重载为一个寄存器到寄存器的move操作。
然后它尝试改变指令使用的寄存器来避免move指令。该过程位于<samp><span class="file">regmove.c</span></samp>中。

     <li>优化模式转换（Optimize mode switching）

     <p>该过程寻找这样的指令，即需要处理器处于特定的模式（mode），
然后将模式改变的数目减到最少。这些模式是什么以及应用于什么完全是目标机特定的。
源代码位于<samp><span class="file">mode-switching.c</span></samp>中。

     <p><a name="index-modulo-scheduling-1686"></a><a name="index-sms_002c-swing_002c-software-pipelining-1687"></a><li>模调度（Modulo scheduling）

     <p>该过程查看内部循环并且通过复合不同的迭代来重排它们的指令。
模调度在指令调度之后立即被执行。该过程位于<samp><span class="file">modulo-sched.c</span></samp>。

     <li>指令调度（Instruction scheduling）

     <p>该过程寻找这样的指令，其输出在后来的指令中不会用到。在RISC机器上，
内存加载和浮点指令经常会有这样的特征。
它重新排序基本块中的指令以尝试将定义和使用分开，从而避免引起流水线阻塞。
该过程执行两次，分别在寄存器分配之前和之后。
该过程位于<samp><span class="file">haifa-sched.c</span></samp>, <samp><span class="file">sched-deps.c</span></samp>, <samp><span class="file">sched-ebb.c</span></samp>,
<samp><span class="file">sched-rgn.c</span></samp>和<samp><span class="file">sched-vis.c</span></samp>中。

     <li>寄存器分配（Register allocation）

     <p>这些过程确保所有伪寄存器都被去除，或者通过给它们分配硬件寄存器，
或者使用等价表达式来替换（例如常数），或者将它们放在栈中。这由几个子过程来完成：

          <ul>
<li>寄存器移送优化。该过程进行一些简单的RTL代码转换，来改进后续的寄存器分配。源文件为<samp><span class="file">regmove.c</span></samp>。

          <li>集成寄存器分配(<acronym>IRA</acronym>)。其被称作集成的，是因为合并，寄存器活跃范围拆分，以及硬件寄存器优先选定，都在图着色中被执行。其还更好的与重载过程集合在一起。寄存器分配或者重载所溢出的伪寄存器还有机会来获得硬件寄存器，如果重载从硬件寄存器中赶出了一些伪寄存器。寄存器分配可以帮助选择更好的伪寄存器来溢出，基于它们的活跃返回，并且合并为溢出的伪寄存器所分配的栈槽。IRA为一个区域的寄存器分配，如果只有一个区域，则其被转换成Chaitin-Briggs寄存器分配。缺省的IRA使用寄存器压力来选择区域，不过用户可以强制其使用一个区域或者对应于所有循环的多个区域。

          <p>寄存器分配的源文件为<samp><span class="file">ira.c</span></samp>, <samp><span class="file">ira-build.c</span></samp>,
<samp><span class="file">ira-costs.c</span></samp>, <samp><span class="file">ira-conflicts.c</span></samp>, <samp><span class="file">ira-color.c</span></samp>,
<samp><span class="file">ira-emit.c</span></samp>, <samp><span class="file">ira-lives</span></samp>，以及头文件<samp><span class="file">ira.h</span></samp>和<samp><span class="file">ira-int.h</span></samp>，用于在分配器和编译器其它部分，以及IRA文件之间的交互。

          <p><a name="index-reloading-1688"></a><li>重载（reloading）。该过程使用分配的硬件寄存器编号来重新为伪寄存器编号。
没有获得硬件寄存器的伪寄存器被分配到栈槽中。然后寻找那些由于无法放入寄存器，
或者放入错误类型寄存器所引起的无效指令。
通过将有问题的值临时重载到寄存器中来修复这些指令，并生成辅助的指令进行复制。

          <p>重载过程还可选的消除帧指针，
以及插入指令来保存和恢复调用破坏掉的（call-clobbered）寄存器。

          <p>源文件为<samp><span class="file">reload.c</span></samp>和<samp><span class="file">reload1.c</span></samp>，
还有用于信息交互的头文件<samp><span class="file">reload.h</span></samp>。
</ul>

     <li>基本块重新排序（Basic block reordering）

     <p>该过程实现了profile指导的代码安置（code positioning）。如果profile信息不可用，
便会执行不同类型的静态分析来作出通常通过profile反馈（IE执行频率，分支可能性等）
而得出的预测。其在<samp><span class="file">bb-reorder.c</span></samp>中实现，不同的预测程序在<samp><span class="file">predict.c</span></samp>中。

     <li>变量跟踪（Variable tracking）

     <p>该过程计算变量在代码中的每个位置（position）所被存储的到的地方，
并生成注解到RTL代码中来描述变量位置(location)。
如果调试信息格式支持位置列表(location lists)的话，
便会根据这些注解来生成位置列表到调试信息中。

     <li>延迟分支调度（Delayed branch scheduling）

     <p>该可选的过程尝试去找到能够放在其它指令，通常是跳转或者调用指令，
的延迟槽中的指令。源文件名为<samp><span class="file">reorg.c</span></samp>。

     <li>分支缩短（Branch shortening）

     <p>许多RISC机器上，分支指令有一个限制范围。因此，较长的指令序列必须用于长分支。
在这个过程中，编译器计算出指令间的距离有多长，
并且对于每个分支是否使用普通指令或者交长的指令序列。

     <li>寄存器到栈的转换（Register-to-stack conversion）

     <p>将一些硬件寄存器的使用转换为一个寄存器栈的使用可以在这里完成。目前，
该过程只支持Intel 80387协处理器的浮点寄存器。源文件名为<samp><span class="file">reg-stack.c</span></samp>。

     <li>Final过程

     <p>该过程输出函数的汇编代码。源文件为<samp><span class="file">final.c</span></samp>和<samp><span class="file">insn-output.c</span></samp>，
后者由工具<samp><span class="file">genoutput</span></samp>通过机器描述自动生成。
头文件<samp><span class="file">conditions.h</span></samp>用于这些文件间的信息交互。如果启用了mudflap，
延迟声明和可寻址常量（如字符串文字）的队列将由<code>mudflap_finish_file</code>处理
成一个调用mudflap运行时的综合构造器函数。

     <li>调试信息输出

     <p>该过程在Final过程之后运行，
是因为它必须为没有获得硬件寄存器的伪寄存器输出栈槽偏移量。源文件包括，
用于DBX符号表格式的<samp><span class="file">dbxout.c</span></samp>，用于SDB符号表格式的<samp><span class="file">sdbout.c</span></samp>，
用于DWARF符号表格式的<samp><span class="file">dwarfout.c</span></samp>，
用于DWARF2符号表格式的<samp><span class="file">dwarf2out.c</span></samp>和<samp><span class="file">dwarf2asm.c</span></samp>，
以及用于VMS调试符号表格式的<samp><span class="file">vmsdbgout.c</span></samp>。
</ul>

<!-- Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, -->
<!-- 2009  Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gcc.texi. -->
<!--  -->
<!-- Trees -->
<!--  -->
 </body></html>

