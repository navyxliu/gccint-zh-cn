<html lang="zh">
<head>
<title>寄存器中的值 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8" title="寄存器">
<link rel="prev" href="_00e5_0088_0086_00e9_0085_008d_00e9_00a1_00ba_00e5_00ba_008f.html#g_t_00e5_0088_0086_00e9_0085_008d_00e9_00a1_00ba_00e5_00ba_008f" title="分配顺序">
<link rel="next" href="_00e5_008f_00b6_00e5_00ad_0090_00e5_0087_00bd_00e6_0095_00b0.html#g_t_00e5_008f_00b6_00e5_00ad_0090_00e5_0087_00bd_00e6_0095_00b0" title="叶子函数">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%af%84%e5%ad%98%e5%99%a8%e4%b8%ad%e7%9a%84%e5%80%bc"></a>
<a name="g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e4_00b8_00ad_00e7_009a_0084_00e5_0080_00bc"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_008f_00b6_00e5_00ad_0090_00e5_0087_00bd_00e6_0095_00b0.html#g_t_00e5_008f_00b6_00e5_00ad_0090_00e5_0087_00bd_00e6_0095_00b0">叶子函数</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_0088_0086_00e9_0085_008d_00e9_00a1_00ba_00e5_00ba_008f.html#g_t_00e5_0088_0086_00e9_0085_008d_00e9_00a1_00ba_00e5_00ba_008f">分配顺序</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8">寄存器</a>
<hr>
</div>

<h4 class="subsection">17.7.3 如何使值适合寄存器</h4>

<p>这节讨论的宏，描述了每个寄存器可以存放哪类的值（明确的说，
是哪些机器模式的），以及对于给定的机器模式需要多少个连续的寄存器。

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_NREGS</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fNREGS-3888"></a></var><br>
<blockquote><p>一个C表达式，为存放模式<var>mode</var>的值所需要的连续的硬件寄存器，
起始于寄存器编号<var>regno</var>。该宏不要返回0，
即使寄存器不能存放指定的mode —— 替代的，
使用HARD_REGNO_MODE_OK 和/或 CANNOT_CHANGE_MODE_CLASS。

      <p>在所有寄存器都是一个字大小的机器上，该宏的一个合适的定义为

     <pre class="smallexample">          #define HARD_REGNO_NREGS(REGNO, MODE)            \
             ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
              / UNITS_PER_WORD)
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_NREGS_HAS_PADDING</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fNREGS_005fHAS_005fPADDING-3889"></a></var><br>
<blockquote><p>一个C表达式，为非0，如果模式为<var>mode</var>的值，存储在内存中，
并由padding结尾，这使得其占有更多的空间，
比在起始于寄存器编号<var>regno</var>的寄存器中。缺省的为0。

      <p>例如，如果浮点值存储在三个32位寄存器中，但是在内存中占有128位，则该宏应该为非0。

      <p>该宏只有当<code>subreg_get_info</code>会错误的确定一个<code>subreg</code>可以通过寄存器编号的偏移量来表示，
而实际上这样的<code>subreg</code>将会保存一些不应该被表示的padding时，
才需要被定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_NREGS_WITH_PADDING</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fNREGS_005fWITH_005fPADDING-3890"></a></var><br>
<blockquote><p>对于<code>HARD_REGNO_NREGS_HAS_PADDING</code>会返回非0的<var>regno</var>和<var>mode</var>的值，
其为一个C表达式，返回保存包括任何padding的值所需要的寄存器的最大数。
在上面的例子中，值将为4。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGMODE_NATURAL_SIZE</b> (<var>mode</var>)<var><a name="index-REGMODE_005fNATURAL_005fSIZE-3891"></a></var><br>
<blockquote><p>定义该宏，如果存放模式<var>mode</var>的值的寄存器的自然大小，不是word大小。
其为一个C表达式，对于指定的mode给出以字节为单位的自然的大小。
其被寄存器分配用于尝试优化它的结果。
例如这出现在SPARC 64位机器上，其浮点寄存器的自然大小仍然是32位。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_MODE_OK</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fMODE_005fOK-3892"></a></var><br>
<blockquote><p>一个C表达式，其为非0，
如果允许将一个<var>mode</var>模式的值存储在硬件寄存器编号<var>regno</var>
（或者起始于它的多个寄存器）中。对于所有寄存器都是等价的机器上，
一个合适的定义为

     <pre class="smallexample">          #define HARD_REGNO_MODE_OK(REGNO, MODE) 1
</pre>
      <p>你不需要包含检查固定寄存器编号的代码，
因为分配机制总是认为它们已经被占用了。

      <p><a name="index-register-pairs-3893"></a>在一些机器上，双精度值必须放在偶/奇寄存器对。
你可以通过定义该宏来拒绝这样模式的奇数寄存器编号。

      <p>对于一个模式可以放在寄存器中的最小需求为，
&lsquo;<samp><span class="samp">mov</span><var>mode</var></samp>&rsquo;指令模式支持在寄存器和同一类别的其它硬件寄存器之间的移动，
并且将一个值移动到寄存器中并移动回来，而不会改变。

      <p>由于用于move <code>word_mode</code>的同一指令，也可以用于所有更窄的整数模式，
所以<code>HARD_REGNO_MODE_OK</code>不必要在任何机器上对于这些模式都不同，
假定你定义了指令模式&lsquo;<samp><span class="samp">movhi</span></samp>&rsquo;等。

      <p>许多机器对于浮点算术具有特定的寄存器。
通常人们假设浮点机器模式只在浮点寄存器中被允许。这并不真实。
任何可以存放整数的寄存器都可以安全的存放一个浮点机器模式，
而不管是否可以在这些寄存器上进行浮点算术。
整数move指令可以用于移动这些值。

      <p>然而在一些机器上，定点机器模式不可以放在浮点寄存器中。
比如如果浮点寄存器对任何存储的值进行标准化，
因为存储一个非浮点值将会使值变得混淆。这种情况下，
<code>HARD_REGNO_MODE_OK</code>应该拒绝定点机器模式放在浮点寄存器中。
但是，如果浮点寄存器不自动标准化，
如果你可以存储任何位的指令模式并无需改动的获得它，
则任何机器模式都可以放在浮点寄存器中，这样你可以定义该宏来表明可以这么做。

      <p>当然，特定的浮点寄存器的主要意义是它们在浮点算术指令中可以使用。
但是，这根<code>HARD_REGNO_MODE_OK</code>没有关系。
你可以通过对那些执行写合适的约束来处理。

      <p>在一些机器上，浮点寄存器访问起来特别慢，所以如果浮点算术没有完成前，
最好将值存在栈帧中，而不是在这样的寄存器中。
只要浮点寄存器不在<code>GENERAL_REGS</code>类别中，它们将不会被使用，
除非某个指令模式的约束要求这样。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_RENAME_OK</b> (<var>from, to</var>)<var><a name="index-HARD_005fREGNO_005fRENAME_005fOK-3894"></a></var><br>
<blockquote><p>一个C表达式，为非0，
如果可以将一个硬件寄存器<var>from</var>重命名为另一个寄存器<var>to</var>。

      <p>该宏的一个通用的用法是防止将一个寄存器重命名为另一个寄存器，
而其在中断处理函数的序言中没有被保存。

      <p>缺省总是为非0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MODES_TIEABLE_P</b> (<var>mode1, mode2</var>)<var><a name="index-MODES_005fTIEABLE_005fP-3895"></a></var><br>
<blockquote><p>一个C表达式，其为非0，如果一个模式<var>mode1</var>的值，
不需要复制便可以按照模式<var>mode2</var>来访问。

      <p>如果<code>HARD_REGNO_MODE_OK (</code><var>r</var><code>, </code><var>mode1</var><code>)</code>和
<code>HARD_REGNO_MODE_OK (</code><var>r</var><code>, </code><var>mode2</var><code>)</code>对于任何<var>r</var>总是相同，
则<code>MODES_TIEABLE_P (</code><var>mode1</var><code>, </code><var>mode2</var><code>)</code>应该为非0。
如果它们对于任何<var>r</var>都不同，则你应该定义该宏来返回0，
除非某个其它机制能够确保值可以按照更窄的模式来访问。

      <p>你应该定义该宏来尽可能情况的返回非0，
因为这样会使得GCC执行更好的寄存器分配。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_HARD_REGNO_SCRATCH_OK</b> (<var>unsigned int regno</var>)<var><a name="index-TARGET_005fHARD_005fREGNO_005fSCRATCH_005fOK-3896"></a></var><br>
<blockquote><p>This target hook should return <code>true</code> if it is OK to use a hard register
<var>regno</var> as scratch reg in peephole2.

      <p>One common use of this macro is to prevent using of a register that
is not saved by a prologue in an interrupt handler.

      <p>The default version of this hook always returns <code>true</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>AVOID_CCMODE_COPIES</b><var><a name="index-AVOID_005fCCMODE_005fCOPIES-3897"></a></var><br>
<blockquote><p>定义该宏，如果编译器应该避免复制从/到<code>CCmode</code>寄存器。
你应该只当对复制从/到<code>CCmode</code>寄存器的支持不完善的时候定义该宏。
</p></blockquote></div>

 </body></html>

