<html lang="zh">
<head>
<title>SSA操作数 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tree-SSA.html#Tree-SSA" title="Tree SSA">
<link rel="prev" href="Annotations.html#Annotations" title="Annotations">
<link rel="next" href="SSA.html#SSA" title="SSA">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="SSA%e6%93%8d%e4%bd%9c%e6%95%b0"></a>
<a name="SSA_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="SSA.html#SSA">SSA</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Annotations.html#Annotations">Annotations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tree-SSA.html#Tree-SSA">Tree SSA</a>
<hr>
</div>

<h3 class="section">13.2 SSA操作数</h3>

<p><a name="index-operands-3045"></a><a name="index-virtual-operands-3046"></a><a name="index-real-operands-3047"></a><a name="index-update_005fstmt-3048"></a>
几乎每条GIMPLE语句都会包含对变量或者内存地址的引用。由于语句的形状和大小不同，
它们的操作数也将会位于语句树中的不同点。为了便于访问语句的操作数，
它们被组织到与语句的注解（annotation）相关联的一个列表中。
操作数列表中的每个元素都是一个指向<code>VAR_DECL</code>, <code>PARM_DECL</code>
或<code>SSA_NAME</code>树结点的指针。这就为检查和替换操作数提供了一种非常方便的方法。

 <p>数据流分析和优化是在所有表示变量的树结点上完成的。扫描语句操作数时，
将会考虑任何<code>SSA_VAR_P</code>返回非零的节点。但是，
并不是所有的<code>SSA_VAR_P</code>变量都使用同一种方式来处理。出于优化的目的，
我们需要区分对局部标量的引用和对全局，静态，结构体，数组，别名变量的引用，等等。
原因很简单，一方面是因为编译器能够为局部标量搜集完整的数据流信息；而另一方面，
是因为全局变量可能会被函数调用所修改，
并且也可能无法追踪数组或结构体的所有元素或域的信息，等等。

 <p>操作数扫描器搜集两类操作数：实的（<dfn>real</dfn>）和虚的（<dfn>virtual</dfn>）。
<code>is_gimple_reg</code>返回真的操作数被认为是实操作数，否则为一个虚操作数。
我们还区分了它们的使用和定义。如果操作数的值被语句加载（例如，在赋值的右边），
则为使用。如果语句给操作数赋于了一个新的值（例如，在赋值的左边），则为定义。

 <p>虚操作数和实操作数还具有不同的数据流属性。
实操作数是对它们表示的完整对象的明确引用。例如，给定

<pre class="smallexample">     {
       int a, b;
       a = b
     }
</pre>
 <p>由于<code>a</code>和<code>b</code>为非别名的局部变量，
语句<code>a = b</code>将具有一个实定义和一个实使用，
因为变量<code>a</code>完全被变量<code>b</code>的内容修改了。
实定义还被称作为<dfn>killing definition</dfn>（杀死定义）。
类似的，对<code>b</code>的使用是读取了它的所有位。

 <p>与此相反，虚操作数用于部分或者不明确的引用。这包括结构体，数组，全局和别名变量。
这些情况下，我们具有两种类型的定义。对于全局变量，结构体和数组，
我们能够从语句中确定这些类型的变量是否具有一个killing definition。如果变量具有，
则语句被标记为具有那个变量的必然定义（<dfn>must definition</dfn>）。但是，
如果语句只是定义了变量的一部分（即，结构体中的一个域），
或者如果我们知道语句可能会定义变量，但是不确定，
则我们将那条语句标记为具有一个可能定义（<dfn>may definition</dfn>）。例如，给定

<pre class="smallexample">     {
       int a, b, *p;
     
       if (...)
         p = &amp;a;
       else
         p = &amp;b;
       *p = 5;
       return *p;
     }
</pre>
 <p>赋值<code>*p = 5</code>可能为<code>a</code>或者<code>b</code>的定义。
如果我们不能静态地确定在存储操作的时候<code>p</code>的指向，
我们便创建一个虚定义来标记那条语句为一个<code>a</code>和<code>b</code>的潜在的定义。
内存加载也类似的使用虚操作数进行标记。
虚操作数在树转储（dump）中显示在包含它们的语句前面。
要获得带有虚操作数的树转储，使用<samp><span class="option">-fdump-tree</span></samp>的<samp><span class="option">-vops</span></samp>选项：

<pre class="smallexample">     {
       int a, b, *p;
     
       if (...)
         p = &amp;a;
       else
         p = &amp;b;
       # a = VDEF &lt;a&gt;
       # b = VDEF &lt;b&gt;
       *p = 5;
     
       # VUSE &lt;a&gt;
       # VUSE &lt;b&gt;
       return *p;
     }
</pre>
 <p>注意<code>VDEF</code>操作数具有被引用变量的两个副本。
这表明不是一个那个变量的killing definition。在这种情况下，
我们称它为一个可能定义（<dfn>may definition</dfn>）或者
别名存储（<dfn>aliased store</dfn>）。
当函数被转换为SSA形式的时候，<code>VDEF</code>操作数的第二个变量副本将会变得很重要。
其将用于链接所有的non-killing definition，用来防止优化对它们做错误的假设。

 <p>当语句完成时，便会立刻通过调用<code>update_stmt</code>来更新操作数。
如果语句元素通过<code>SET_USE</code>或<code>SET_DEF</code>被改变，
则不需要进一步的动作（即，那些宏会处理好语句更新）。
如果改变是通过直接操作语句的树，则必须在完成时调用<code>update_stmt</code>。
调用<code>bsi_insert</code>程序中的任何一个，或者<code>bsi_replace</code>，
都会隐式的调用<code>update_stmt</code>。

<h4 class="subsection">13.2.1 操作数迭代器和访问例程</h4>

<p><a name="index-Operand-Iterators-3049"></a><a name="index-Operand-Access-Routines-3050"></a>
与操作数相关的代码都在<samp><span class="file">tree-ssa-operands.c</span></samp>中。
操作数被存储在每条语句的注解中并且可以通过操作数迭代器或者访问程序来访问。

 <p>下列访问程序可以用来检查操作数：

     <ol type=1 start=1>
<li><code>SINGLE_SSA_{USE,DEF,TREE}_OPERAND</code>:
这些访问程序将会返回NULL，除非确实有一个操作数匹配指定的标记。
如果确实存在一个操作数，则操作数被作为<code>tree</code>,<code>def_operand_p</code>或者
<code>use_operand_p</code>返回。

     <pre class="smallexample">          tree t = SINGLE_SSA_TREE_OPERAND (stmt, flags);
          use_operand_p u = SINGLE_SSA_USE_OPERAND (stmt, SSA_ALL_VIRTUAL_USES);
          def_operand_p d = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_ALL_DEFS);
</pre>
     <li><code>ZERO_SSA_OPERANDS</code>: 该宏返回真，如果没有操作数匹配指定的标记。

     <pre class="smallexample">          if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))
            return;
</pre>
     <li><code>NUM_SSA_OPERANDS</code>:
该宏返回匹配'flags'的操作数数目。其实际上是执行了一个循环来进行统计，
所以最好只有在真正需要的时候才使用它。

     <pre class="smallexample">          int count = NUM_SSA_OPERANDS (stmt, flags)
</pre>
     </ol>

 <p>如果你想迭代一些或者所有操作数，
使用<code>FOR_EACH_SSA_{USE,DEF,TREE}_OPERAND</code>迭代器。
例如，要打印语句的所有操作数：

<pre class="smallexample">     void
     print_ops (tree stmt)
     {
       ssa_op_iter;
       tree var;
     
       FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)
         print_generic_expr (stderr, var, TDF_SLIM);
     }
</pre>
 <p>如何选择合适的迭代器：

     <ol type=1 start=1>
<li>确定你是否需要看到操作数指针，或者只是树，并选择合适的宏

     <pre class="smallexample">          Need            Macro:
          ----            -------
          use_operand_p   FOR_EACH_SSA_USE_OPERAND
          def_operand_p   FOR_EACH_SSA_DEF_OPERAND
          tree            FOR_EACH_SSA_TREE_OPERAND
</pre>
     <li>你需要声明一个你感兴趣的类型的变量，和一个用作循环控制变量的ssa_op_iter结构体

     <li>确定你想使用哪些操作数，并指定你所感兴趣的那些操作书的标记。
它们在<samp><span class="file">tree-ssa-operands.h</span></samp>中有所记载：

     <pre class="smallexample">          #define SSA_OP_USE              0x01    /* <span class="roman">Real USE operands.</span>  */
          #define SSA_OP_DEF              0x02    /* <span class="roman">Real DEF operands.</span>  */
          #define SSA_OP_VUSE             0x04    /* <span class="roman">VUSE operands.</span>  */
          #define SSA_OP_VMAYUSE          0x08    /* <span class="roman">USE portion of VDEFS.</span>  */
          #define SSA_OP_VDEF             0x10    /* <span class="roman">DEF portion of VDEFS.</span>  */
          
          /* <span class="roman">These are commonly grouped operand flags.</span>  */
          #define SSA_OP_VIRTUAL_USES     (SSA_OP_VUSE | SSA_OP_VMAYUSE)
          #define SSA_OP_VIRTUAL_DEFS     (SSA_OP_VDEF)
          #define SSA_OP_ALL_USES         (SSA_OP_VIRTUAL_USES | SSA_OP_USE)
          #define SSA_OP_ALL_DEFS         (SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)
          #define SSA_OP_ALL_OPERANDS     (SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)
</pre>
     </ol>

 <p>所以，如果你想查看所有<code>USE</code>和<code>VUSE</code>操作数的use指针，
则可以使用类似下面的方法：

<pre class="smallexample">       use_operand_p use_p;
       ssa_op_iter iter;
     
       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, (SSA_OP_USE | SSA_OP_VUSE))
         {
           process_use_ptr (use_p);
         }
</pre>
 <p>宏<code>TREE</code>基本上与宏<code>USE</code>和<code>DEF</code>相同，
除了通过<code>USE_FROM_PTR (use_p)</code>和<code>DEF_FROM_PTR (def_p)</code>进行的
use或def dereference。因为我们不会使用操作数指针，所以可以混合use和def标记。

<pre class="smallexample">       tree var;
       ssa_op_iter iter;
     
       FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE)
         {
            print_generic_expr (stderr, var, TDF_SLIM);
         }
</pre>
 <p><code>VDEF</code>被分解为两个标记，一个是<code>DEF</code>部分（<code>SSA_OP_VDEF</code>），
一个是USE部分（<code>SSA_OP_VMAYUSE</code>）。
如果你只是想要查看合在一起的<code>VDEF</code>，则可以使用第四个迭代器，
其返回语句中每个<code>VDEF</code>的 def_operand_p和use_operand_p。
注意该宏不需要任何标记。

<pre class="smallexample">       use_operand_p use_p;
       def_operand_p def_p;
       ssa_op_iter iter;
     
       FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)
         {
           my_code;
         }
</pre>
 <p>代码中也有很多例子，同时在<samp><span class="file">tree-ssa-operands.h</span></samp>中也有记载。

 <p>还有一些stmt迭代器是用于关注PHI节点的。

 <p><code>FOR_EACH_PHI_ARG</code>跟<code>FOR_EACH_SSA_USE_OPERAND</code>非常类似，
只不过它是工作于<code>PHI</code>参数，而不是语句操作数。

<pre class="smallexample">     /* Look at every virtual PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_VIRTUAL_USES)
     {
        my_code;
     }
     
     /* Look at every real PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_USES)
       my_code;
     
     /* Look at every PHI use.  */
     FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_ALL_USES)
       my_code;
</pre>
 <p><code>FOR_EACH_PHI_OR_STMT_{USE,DEF}</code>与
<code>FOR_EACH_SSA_{USE,DEF}_OPERAND</code>非常类似，
只不过它是作用于语句或者<code>PHI</code>节点。
这些应该在使用单独的<code>FOR_EACH_PHI</code>和
<code>FOR_EACH_SSA</code>程序效率低的时候再使用。

<pre class="smallexample">     FOR_EACH_PHI_OR_STMT_USE (use_operand_p, stmt, iter, flags)
       {
          my_code;
       }
     
     FOR_EACH_PHI_OR_STMT_DEF (def_operand_p, phi, iter, flags)
       {
          my_code;
       }
</pre>
 <h4 class="subsection">13.2.2 立即使用</h4>

<p><a name="index-Immediate-Uses-3051"></a>
现在immediate use（这个短语咋翻译？）信息总是可以被获得。
使用immediate use迭代器，你可以检查任意<code>SSA_NAME</code>的每个使用。
例如，要将<code>ssa_var</code>的每个使用改为<code>ssa_var2</code>的，
并且之后在每个stmt上调用fold_stmt：

<pre class="smallexample">       use_operand_p imm_use_p;
       imm_use_iterator iterator;
       tree ssa_var, stmt;
     
     
       FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
         {
           FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
             SET_USE (imm_use_p, ssa_var_2);
           fold_stmt (stmt);
         }
</pre>
 <p>这里有两个可以使用的迭代器。
<code>FOR_EACH_IMM_USE_FAST</code>用于当immediate use没有被改变的情况下，即，
只是进行查看use，但不设置它们。

 <p>如果确实要做改变，则必须要考虑到迭代器下没有被改变的事物，这时，
可以使用<code>FOR_EACH_IMM_USE_STMT</code>和<code>FOR_EACH_IMM_USE_ON_STMT</code>迭代器。
它们试图通过将语句的所有使用移动到一个被控制的位置并对它们进行迭代的方式，
来保存使用列表的健全。然后优化就能够在所有的使用被处理完后来操作stmt。
这比FAST版本的有点慢，因为它增加了一个占位元素并且必须对每条语句的列表进行排序。
如果循环被提前终止，则该占位元素还必须被移除。
宏<code>BREAK_FROM_IMM_USE_SAFE</code>用于做这个：

<pre class="smallexample">       FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
         {
           if (stmt == last_stmt)
             BREAK_FROM_SAFE_IMM_USE (iter);
     
           FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
             SET_USE (imm_use_p, ssa_var_2);
           fold_stmt (stmt);
         }
</pre>
 <p>在<code>verify_ssa</code>中有一些检测用来验证immediate use列表是最新的，
同时还检测一个优化是否没有使用该宏而中断循环。
在<code>FOR_EACH_IMM_USE_FAST</code>遍历中，直接使用'break'语句是安全的。

 <p>一些有用的函数和宏：
     <ol type=1 start=1>
<li><code>has_zero_uses (ssa_var)</code> : 如果没有<code>ssa_var</code>的使用，则返回真。
<li><code>has_single_use (ssa_var)</code> :
如果只有<code>ssa_var</code>的单个使用，则返回真。
<li><code>single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)</code> :
如果只有<code>ssa_var</code>的单个使用，则返回真，
并且还在第二和第三个参数中返回使用指针和所在的语句。
<li><code>num_imm_uses (ssa_var)</code> :
返回<code>ssa_var</code>的immediate use的数目。最好不要使用该宏，
因为它只是简单的使用循环来统计use。
<li><code>PHI_ARG_INDEX_FROM_USE (use_p)</code> :
给定一个在<code>PHI</code>节点中的use，返回use的索引数。
如果use不位于<code>PHI</code>节点中，则会触发一个断言。
<li><code>USE_STMT (use_p)</code> : 返回use所在的语句。
      </ol>

 <p>注意在语句通过<code>bsi_*</code>程序被实际插入指令流中之前，
use是不被放入immediate use列表中的。

 <p>还可以使用懒散的语句更新方式，不过这应该在确实需要的时候才使用。
别名分析和dominator优化目前都采用了这种方式。

 <p>当使用懒散更新（lazy updating）时，immediate use信息是过时的，不能被信赖。
懒散更新简单的调用<code>mark_stmt_modified</code>来标记语句被修改了，
而不使用<code>update_stmt</code>。当不再需要进行懒散更新时，
所有修改的语句都必须调用<code>update_stmt</code>来保持更新。
这必须在优化完成之前进行，否则<code>verify_ssa</code>将触发abort 异常中断。

 <p>这是通过对指令流进行简单的循环来实现的：

<pre class="smallexample">       block_stmt_iterator bsi;
       basic_block bb;
       FOR_EACH_BB (bb)
         {
           for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&amp;bsi))
             update_stmt_if_modified (bsi_stmt (bsi));
         }
</pre>
 </body></html>

