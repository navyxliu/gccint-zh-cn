<html lang="zh">
<head>
<title>简单的constraint - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Constraints.html#Constraints" title="Constraints">
<link rel="next" href="_00e5_00a4_009a_00e4_00b8_00aa_00e5_008f_00af_00e9_0080_0089_00e9_00a1_00b9.html#g_t_00e5_00a4_009a_00e4_00b8_00aa_00e5_008f_00af_00e9_0080_0089_00e9_00a1_00b9" title="多个可选项">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e7%ae%80%e5%8d%95%e7%9a%84constraint"></a>
<a name="g_t_00e7_00ae_0080_00e5_008d_0095_00e7_009a_0084constraint"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_00a4_009a_00e4_00b8_00aa_00e5_008f_00af_00e9_0080_0089_00e9_00a1_00b9.html#g_t_00e5_00a4_009a_00e4_00b8_00aa_00e5_008f_00af_00e9_0080_0089_00e9_00a1_00b9">多个可选项</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Constraints.html#Constraints">Constraints</a>
<hr>
</div>

<h4 class="subsection">16.8.1 简单的constraint</h4>

<p><a name="index-simple-constraints-3219"></a>
最简单的constraint种类是一个由字母组成的字符串，
每个字母描述一种所允许的操作数。这里是所允许的字母：

     <dl>
<dt>whitespace<dd>空格字符将被忽略，并且可以插到除了起始处的任何地方。这使得机器描述中，
不同操作数的每个可选项可以被可视化的对齐，即使它们具有不同数目的约束和修饰符。

     <p><a name="index-g_t_0040samp_007bm_007d-in-constraint-3220"></a><a name="index-memory-references-in-constraints-3221"></a><br><dt>&lsquo;<samp><span class="samp">m</span></samp>&rsquo;<dd>内存操作数将被允许，包括机器支持的任何寻址方式。

     <p><a name="index-offsettable-address-3222"></a><a name="index-g_t_0040samp_007bo_007d-in-constraint-3223"></a><br><dt>&lsquo;<samp><span class="samp">o</span></samp>&rsquo;<dd>内存操作数将被允许，但只有当地址为偏移表的时候。
这意味着可以对地址加上一个小的整数(实际上,是为操作数的数个字节宽度,
这由它的机器模式决定),其结果也为一个有效的内存地址。

     <p><a name="index-autoincrement_002fdecrement-addressing-3224"></a>例如，地址为常数的为一个偏移表；所以地址为一个寄存器和常数（只要常数在机器所支持
的地址偏移范围）的和；但是递增或者递减地址不是偏移表。更加复杂的间接/索引地址可
能是或者可能不是偏移表，这取决于机器支持的其它寻址模式。

     <p><a name="index-g_t_0040samp_007bV_007d-in-constraint-3225"></a><br><dt>&lsquo;<samp><span class="samp">V</span></samp>&rsquo;<dd>一个不是offsettable的内存操作数。换句话说，
任何适合&lsquo;<samp><span class="samp">m</span></samp>&rsquo;约束但不是&lsquo;<samp><span class="samp">o</span></samp>&rsquo;约束的。

     <p><a name="index-g_t_0040samp_007b_003c_007d-in-constraint-3226"></a><br><dt>&lsquo;<samp><span class="samp">&lt;</span></samp>&rsquo;<dd>允许具有自动减量寻址（先减或者后减）的内存操作数。

     <p><a name="index-g_t_0040samp_007b_003e_007d-in-constraint-3227"></a><br><dt>&lsquo;<samp><span class="samp">&gt;</span></samp>&rsquo;<dd>允许具有自动增量寻址（先增或者后增）的内存操作数。

     <p><a name="index-g_t_0040samp_007br_007d-in-constraint-3228"></a><a name="index-registers-in-constraints-3229"></a><br><dt>&lsquo;<samp><span class="samp">r</span></samp>&rsquo;<dd>允许为通用寄存器的寄存器操作数。

     <p><a name="index-constants-in-constraints-3230"></a><a name="index-g_t_0040samp_007bi_007d-in-constraint-3231"></a><br><dt>&lsquo;<samp><span class="samp">i</span></samp>&rsquo;<dd>立即数（具有常数值）将被允许。这包括符号常量，
其值将在汇编时候或者更晚的时候才被知道。

     <p><a name="index-g_t_0040samp_007bn_007d-in-constraint-3232"></a><br><dt>&lsquo;<samp><span class="samp">n</span></samp>&rsquo;<dd>立即数，其具有已知的数值。
许多系统不支持汇编时间常量作为小于一个字的宽度的操作数。
这些操作数的约束应该为&lsquo;<samp><span class="samp">n</span></samp>&rsquo;而不是&lsquo;<samp><span class="samp">i</span></samp>&rsquo;。

     <p><a name="index-g_t_0040samp_007bI_007d-in-constraint-3233"></a><br><dt>&lsquo;<samp><span class="samp">I</span></samp>&rsquo;, &lsquo;<samp><span class="samp">J</span></samp>&rsquo;, &lsquo;<samp><span class="samp">K</span></samp>&rsquo;, <small class="dots">...</small> &lsquo;<samp><span class="samp">P</span></samp>&rsquo;<dd>从&lsquo;<samp><span class="samp">I</span></samp>&rsquo;到&lsquo;<samp><span class="samp">P</span></samp>&rsquo;的其它字母可以被定义为机器特定的，
用来运行立即数具有显示指定范围的整数值。例如，在68000上，
&lsquo;<samp><span class="samp">I</span></samp>&rsquo;被定义为代表1到8的值。这是在移位指令中被允许作为移位数的范围。

     <p><a name="index-g_t_0040samp_007bE_007d-in-constraint-3234"></a><br><dt>&lsquo;<samp><span class="samp">E</span></samp>&rsquo;<dd>浮点立即数（表达式代码为<code>const_double</code>），
但是必须target浮点格式与host机器（编译器运行的机器）的相同才行。

     <p><a name="index-g_t_0040samp_007bF_007d-in-constraint-3235"></a><br><dt>&lsquo;<samp><span class="samp">F</span></samp>&rsquo;<dd>浮点立即数（表达式代码为<code>const_double</code>或者<code>const_vector</code>）。

     <p><a name="index-g_t_0040samp_007bG_007d-in-constraint-3236"></a><a name="index-g_t_0040samp_007bH_007d-in-constraint-3237"></a><br><dt>&lsquo;<samp><span class="samp">G</span></samp>&rsquo;, &lsquo;<samp><span class="samp">H</span></samp>&rsquo;<dd>&lsquo;<samp><span class="samp">G</span></samp>&rsquo;和&lsquo;<samp><span class="samp">H</span></samp>&rsquo;可以被定义为机器特定的方式来允许浮点立即数具有特定范围的值。

     <p><a name="index-g_t_0040samp_007bs_007d-in-constraint-3238"></a><br><dt>&lsquo;<samp><span class="samp">s</span></samp>&rsquo;<dd>整数立即数，其值不是一个显式的整数。

     <p>这可能有点奇怪；如果insn允许常量操作数具有在编译时不可知的值，
它当然必须允许任何可知的值。所以为什么用&lsquo;<samp><span class="samp">s</span></samp>&rsquo;，而不是&lsquo;<samp><span class="samp">i</span></samp>&rsquo;能？有时候，
它会允许生成更好的代码。

     <p>例如，在68000上的全字指令，有可能使用一个立即数操作数；
但是如果立即数的值是处于-128和127之间，更好的代码是将值加载到寄存器中，
使用寄存器。这是因为加载到寄存器中可以由&lsquo;<samp><span class="samp">moveq</span></samp>&rsquo;指令来完成。
我们对此通过定义字母&lsquo;<samp><span class="samp">K</span></samp>&rsquo;来表示任意范围超出-128和127的整数，
然后在操作数约束中指定&lsquo;<samp><span class="samp">Ks</span></samp>&rsquo;。

     <p><a name="index-g_t_0040samp_007bg_007d-in-constraint-3239"></a><br><dt>&lsquo;<samp><span class="samp">g</span></samp>&rsquo;<dd>任何寄存器，内存或整数立即数，除了不是通用寄存器的寄存器。

     <p><a name="index-g_t_0040samp_007bX_007d-in-constraint-3240"></a><br><dt>&lsquo;<samp><span class="samp">X</span></samp>&rsquo;<dd>任何操作数都被允许，即使其不满足<code>general_operand</code>。
这通常用于<code>match_scratch</code>的约束中，
当一些的可选项实际上不需要scratch寄存器的时候。

     <p><a name="index-g_t_0040samp_007b0_007d-in-constraint-3241"></a><a name="index-digits-in-constraint-3242"></a><br><dt>&lsquo;<samp><span class="samp">0</span></samp>&rsquo;, &lsquo;<samp><span class="samp">1</span></samp>&rsquo;, &lsquo;<samp><span class="samp">2</span></samp>&rsquo;, <small class="dots">...</small> &lsquo;<samp><span class="samp">9</span></samp>&rsquo;<dd>匹配指定操作数编号的操作数。如果数字与字母一起使用，则数字应该放在最后。

     <p>该编号允许多于单个数字。如果多个数字连续的在一起，
则它们被解析为一个单独的十进制整数。很少会因此产生不明确，因为到目前为止，
还没有想要将&lsquo;<samp><span class="samp">10</span></samp>&rsquo;解析为匹配操作数1或者0的。如果有这样的需要，
则可以使用多个可选项来替代。

     <p><a name="index-matching-constraint-3243"></a><a name="index-constraint_002c-matching-3244"></a>这被称为匹配约束，其实际上是指汇编器只有一个单独的操作数，
却在RTL insn中扮演两个角色。例如，
add insn在RTL中具有两个输入操作数和一个输出操作数，
但是多数CISC机器上，add指令实际上只有两个操作数，其中一个为输入输出操作数：

     <pre class="smallexample">          addl #35,r12
</pre>
     <p>匹配约束被用于这些情况。更确切的说，
匹配的两个操作数必须包括一个只作输入的操作数和一个只作输出的操作数。

     <p><a name="index-load-address-instruction-3245"></a><a name="index-push-address-instruction-3246"></a><a name="index-address-constraints-3247"></a><a name="index-g_t_0040samp_007bp_007d-in-constraint-3248"></a><br><dt>&lsquo;<samp><span class="samp">p</span></samp>&rsquo;<dd>允许一个为有效内存地址的操作数。这用于“加载地址”和“地址压栈”指令。

     <p><a name="index-address_005foperand-3249"></a>约束中的&lsquo;<samp><span class="samp">p</span></samp>&rsquo;必须由<code>match_operand</code>中的作为断言的<code>address_operand</code>协同工作。该断言将<code>match_operand</code>中指定的机器模式解析为地址有效的内存引用的机器模式。

     <p><a name="index-other-register-constraints-3250"></a><a name="index-extensible-constraints-3251"></a><br><dt><var>other-letters</var><dd>其它字母可以采用机器相关的方式被定义，用于代表寄存器的特定类别或者其它任意的操作数类型。&lsquo;<samp><span class="samp">d</span></samp>&rsquo;, &lsquo;<samp><span class="samp">a</span></samp>&rsquo;和&lsquo;<samp><span class="samp">f</span></samp>&rsquo;在68000/68020被定义用来代表数据，地址和浮点寄存器。

 </dl>

 <p>为了具有有效的汇编代码，每个操作数必须满足它的约束。但是如果不满足的话，也不会阻止将该指令模式应用到insn上。替代的，它会指示编译器去修改代码以至于约束将被满足。通常，这是通过将一个操作数复制到寄存器中来完成的。

 <p>因此，对比下面的两条指令模式：

<pre class="smallexample">     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r")
             (plus:SI (match_dup 0)
                      (match_operand:SI 1 "general_operand" "r")))]
       ""
       "...")
</pre>
 <p class="noindent">其具有两个操作数，其中一个必须出现在两个位置，

<pre class="smallexample">     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r")
             (plus:SI (match_operand:SI 1 "general_operand" "0")
                      (match_operand:SI 2 "general_operand" "r")))]
       ""
       "...")
</pre>
 <p class="noindent">其具有三个操作数，其中两个通过约束被要求为是相同的。如果我们考虑如下形式的一条insn

<pre class="smallexample">     (insn <var>n</var> <var>prev</var> <var>next</var>
       (set (reg:SI 3)
            (plus:SI (reg:SI 6) (reg:SI 109)))
       ...)
</pre>
 <p class="noindent">第一个指令模式将根本不会被应用，因为该insn不在合适的地方包含两个相同的子表达式。指令模式会说“这看起来不像是一条加法指令；试一下其它模式”。第二个指令模式将会说，“是的，这是一条加法指令，但是有些问题”。它将指使编译器的重载过程生成额外的insn，使得约束为真。结果可能看起来像：

<pre class="smallexample">     (insn <var>n2</var> <var>prev</var> <var>n</var>
       (set (reg:SI 3) (reg:SI 6))
       ...)
     
     (insn <var>n</var> <var>n2</var> <var>next</var>
       (set (reg:SI 3)
            (plus:SI (reg:SI 3) (reg:SI 109)))
       ...)
</pre>
 <p>你必须确保每个操作数，在每个指令模式中，具有能够处理可能会出现的任何RTL表达式的约束。（当使用多个可选项时，每个指令模式，对于每个可能的操作数表达式组合，必须至少具有一个可选项可以处理该操作数的组合。）约束不需要允许任何可能的操作数——如果是这种情况，它们就不做约束了——但是它们必须至少指出可以加载任何可能操作数，使得适合约束的方法。

     <ul>
<li>如果约束接受断言允许的任何操作数，则没有问题：重载对于该操作数将没有必要。

     <p>例如，操作数对于它的约束允许除了寄存器以外的任何事物，如果它的断言不接受寄存器的话，这样是安全的。

     <p>操作数对于断言只接受常量时，如果它的约束包含字母&lsquo;<samp><span class="samp">i</span></samp>&rsquo;，则是安全的。如果任何可能的常量都被接受，则可以使用&lsquo;<samp><span class="samp">i</span></samp>&rsquo;；如果断言具有更多的选择性，则约束也可以具有更多的选择性。

     <li>任何操作数表达式可以通过复制到寄存器中来进行重载。所以如果一个操作数的约束允许某种寄存器，其当然是安全的。它不需要允许所有类型的寄存器；编译器知道为了使指令有效，如何将一个寄存器复制到另一个合适类别的寄存器中。

     <p><a name="index-nonoffsettable-memory-reference-3252"></a><a name="index-memory-reference_002c-nonoffsettable-3253"></a><li>非偏移表的内存引用可以通过将地址复制到寄存器中来重载。所以如果约束使用字母&lsquo;<samp><span class="samp">o</span></samp>&rsquo;，则所有内存引用将被照顾到。

     <li>常量操作数可以通过在内存中分配空间作为预先被初始化的数据来重载。然后可以使用内存引用。所以如果约束使用字母&lsquo;<samp><span class="samp">o</span></samp>&rsquo;或者&lsquo;<samp><span class="samp">m</span></samp>&rsquo;，则常量操作数不是问题。

     <li>如果约束允许的常量和伪寄存器没有被分配到硬件寄存器中，并且等价于一个常量，则寄存器将被常量替换。如果断言不允许常量并且insn出于某种原因被识别了，则编译器将会崩溃。因此断言必须总是能够识别任何被约束允许的对象。

 </ul>

 <p>如果操作数的断言能够识别寄存器，但是约束不允许它们，则能够使编译器崩溃。当该操作数正好是寄存器时，重载过程将被打乱，因为它不知道如何将寄存器临时复制到内存中。

 <p>如果断言接受一元操作符，约束将被应用到操作数上。例如，MIPS处理器在ISA3级时，支持一条指令，其将两个<code>SImode</code>的寄存器相加产生一个 <code>DImode</code>的结果，但是必须寄存器能够被正确的符号扩展。该断言对于输入操作数接受一个<code>SImode</code>寄存器的<code>sign_extend</code>。将约束写成指示寄存器的类型需要为<code>sign_extend</code>的操作数。

 </body></html>

