<html lang="zh">
<head>
<title>定义predicate - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Predicates.html#Predicates" title="Predicates">
<link rel="prev" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_0097_00a0_00e5_0085_00b3_00e7_009a_0084predicate.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_0097_00a0_00e5_0085_00b3_00e7_009a_0084predicate" title="机器无关的predicate">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%ae%9a%e4%b9%89predicate"></a>
<a name="g_t_00e5_00ae_009a_00e4_00b9_0089predicate"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_0097_00a0_00e5_0085_00b3_00e7_009a_0084predicate.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_0097_00a0_00e5_0085_00b3_00e7_009a_0084predicate">机器无关的predicate</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Predicates.html#Predicates">Predicates</a>
<hr>
</div>

<h4 class="subsection">16.7.2 定义机器特定的predicate</h4>

<p><a name="index-defining-predicates-3214"></a><a name="index-define_005fpredicate-3215"></a><a name="index-define_005fspecial_005fpredicate-3216"></a>
许多机器对操作数的要求无法使用通用的predicate来精确表达。
你可以使用表达式<code>define_predicate</code>和<code>define_special_predicate</code>来定义 额外的predicate。这些表达式具有三个操作数：
     <ul>
<li>predicate的名字，
其将在<code>match_operand</code>或<code>match_operator</code>表达式中被引用。

     <li>一个RTL表达式，如果predicate允许<var>op</var>操作数，则值为真，否则为假。
该表达式只能使用下列RTL代码：

          <dl>
<dt><code>MATCH_OPERAND</code><dd>当用于predicate表达式中时，
表达式<code>MATCH_OPERAND</code>在predicate允许<var>op</var>时为真。
操作数编号和constraint被忽略。由于<samp><span class="command">genrecog</span></samp>中的限制，
你只能用于引用通用的predicate和已经被定义的predicate。

          <br><dt><code>MATCH_CODE</code><dd>该表达式为真，
如果<var>op</var>或一个指定的<var>op</var>的子表达式具有给定RTX代码列表中的一个RTX代码。

          <p>该表达式的第一个操作数为一个字符串常量，
包含了逗号分割的RTX代码名字（小写形式）列表。这些是<code>MATCH_CODE</code>为真的代码。

          <p>第二个操作数为一个字符串常量，其指示<var>op</var>的什么子表达式需要被检查。
如果没有或者为空字符串，则检查<var>op</var>本身。
否则，字符串常量必须为一个数字和/或小写字母的序列。
每个字符指示从当前表达式中抽取的子表达式；
第一个字符为<var>op</var>，第二个和后续字符，其为先前字符的结果。
数字<var>n</var>用于抽取&lsquo;<samp><span class="samp">XEXP&nbsp;(</span><var>e</var><span class="samp">,&nbsp;</span><var>n</var><span class="samp">)<!-- /@w --></span></samp>&rsquo;；
字母<var>l</var>抽取&lsquo;<samp><span class="samp">XVECEXP&nbsp;(</span><var>e</var><span class="samp">,&nbsp;0,&nbsp;</span><var>n</var><span class="samp">)<!-- /@w --></span></samp>&rsquo;，
其中<var>n</var>为<var>l</var>的字母顺序（0为`a'，1为'b'，等等）。
<code>MATCH_CODE</code>然后检查完整字符串所抽取的子表达式的RTX代码。

          <br><dt><code>MATCH_TEST</code><dd>该表达式具有一个操作数，一个包含了一个C表达式的字符串常量。
在C表达式中可以使用predicate的参数，<var>op</var>和<var>mode</var>。
当C表达式为非0值时，<code>MATCH_TEST</code>为真。
<code>MATCH_TEST</code>表达式必须不具有副作用。

          <br><dt><code>AND</code><dt><code>IOR</code><dt><code>NOT</code><dt><code>IF_THEN_ELSE</code><dd>基本的&lsquo;<samp><span class="samp">MATCH_</span></samp>&rsquo;表达式可以使用这些逻辑操作符组合，
其分别具有C操作符&lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo;, &lsquo;<samp><span class="samp">||</span></samp>&rsquo;, &lsquo;<samp><span class="samp">!</span></samp>&rsquo;和&lsquo;<samp><span class="samp">?&nbsp;:<!-- /@w --></span></samp>&rsquo;的语义。
正如在Common Lisp中，可以给<code>AND</code>或<code>IOR</code>表达式任意数目的参数；
这跟写成两个参数的<code>AND</code>或<code>IOR</code>表达式链具有相同的效果。
</dl>

     <li>一个可选的C代码块，其应该在发现predicate匹配时执行&lsquo;<samp><span class="samp">return&nbsp;true<!-- /@w --></span></samp>&rsquo;，
不匹配时执行&lsquo;<samp><span class="samp">return&nbsp;false<!-- /@w --></span></samp>&rsquo;。其一定不要具有副作用。
predicate参数，<var>op</var>和<var>mode</var>，是有效的。

     <p>如果代码块存在于predicate定义中，则对于predicate允许的操作数，
RTL表达式必须求值为true并且代码块必须执行&lsquo;<samp><span class="samp">return&nbsp;true<!-- /@w --></span></samp>&rsquo;。
RTL表达式被首先求值，不要重复检查代码块中的在RTL表达式中曾经被检查过的任何事情。
</ul>

 <p>程序<samp><span class="command">genrecog</span></samp>扫描<code>define_predicate</code>和
<code>define_special_predicate</code>表达式来决定什么RTX代码可能被允许。
你应该使其在RTL predicate表达式中总是显式的，
使用<code>MATCH_OPERAND</code>和<code>MATCH_CODE</code>。

 <p>这里有一个简单的定义predicate的例子，来自IA64机器描述：

<pre class="smallexample">     ;; <span class="roman">True if </span><var>op</var><span class="roman"> is a </span><code>SYMBOL_REF</code><span class="roman"> which refers to the sdata section.</span>
     (define_predicate "small_addr_symbolic_operand"
       (and (match_code "symbol_ref")
            (match_test "SYMBOL_REF_SMALL_ADDR_P (op)")))
</pre>
 <p class="noindent">另一个例子，展示了C块的使用。

<pre class="smallexample">     ;; <span class="roman">True if </span><var>op</var><span class="roman"> is a register operand that is (or could be) a GR reg.</span>
     (define_predicate "gr_register_operand"
       (match_operand 0 "register_operand")
     {
       unsigned int regno;
       if (GET_CODE (op) == SUBREG)
         op = SUBREG_REG (op);
     
       regno = REGNO (op);
       return (regno &gt;= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));
     })
</pre>
 <p>使用<code>define_predicate</code>编写的predicate会自动包含一个测试，
用来测试<var>mode</var>为<code>VOIDmode</code>，
或者<var>op</var>具有与<var>mode</var>相同的机器模式，
或者<var>op</var>为<code>CONST_INT</code>或<code>CONST_DOUBLE</code>。
它们<em>不</em>专门检查整数<code>CONST_DOUBLE</code>，
也不测试每种常量的值是否适合所需求的机器模式。
这是因为接受常量的目标机特定的predicate，通常必须做更严厉的值检查。
如果你需要确切的通用predicate提供的对<code>CONST_INT</code>或
<code>CONST_DOUBLE</code>的对待，
则可以使用<code>MATCH_OPERAND</code>子表达式来调用<code>const_int_operand</code>,
<code>const_double_operand</code>或者<code>immediate_operand</code>。

 <p>使用<code>define_special_predicate</code>编写的predicate不做任何自动的机器模式检查，
并且<samp><span class="command">genrecog</span></samp>将其作为具有特定的机器模式处理来对待。

 <p>程序<samp><span class="command">genpreds</span></samp>负责生成代码来测试predicate。
其还编写了一个包含所有机器特定predicate的函数声明的头文件。
所以不需要在cpu-protos.h中声明这些predicate。

<!-- Most of this node appears by itself (in a different place) even -->
<!-- when the INTERNALS flag is clear.  Passages that require the internals -->
<!-- manual's context are conditionalized to appear only in the internals manual. -->
 </body></html>

