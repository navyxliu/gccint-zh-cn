<html lang="zh">
<head>
<title>维护CFG - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_008e_00a7_00e5_0088_00b6_00e6_00b5_0081.html#g_t_00e6_008e_00a7_00e5_0088_00b6_00e6_00b5_0081" title="控制流">
<link rel="prev" href="Profile_00e4_00bf_00a1_00e6_0081_00af.html#Profile_00e4_00bf_00a1_00e6_0081_00af" title="Profile信息">
<link rel="next" href="_00e6_00b4_00bb_00e8_00b7_0083_00e4_00bf_00a1_00e6_0081_00af.html#g_t_00e6_00b4_00bb_00e8_00b7_0083_00e4_00bf_00a1_00e6_0081_00af" title="活跃信息">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e7%bb%b4%e6%8a%a4CFG"></a>
<a name="g_t_00e7_00bb_00b4_00e6_008a_00a4CFG"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00b4_00bb_00e8_00b7_0083_00e4_00bf_00a1_00e6_0081_00af.html#g_t_00e6_00b4_00bb_00e8_00b7_0083_00e4_00bf_00a1_00e6_0081_00af">活跃信息</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Profile_00e4_00bf_00a1_00e6_0081_00af.html#Profile_00e4_00bf_00a1_00e6_0081_00af">Profile信息</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_008e_00a7_00e5_0088_00b6_00e6_00b5_0081.html#g_t_00e6_008e_00a7_00e5_0088_00b6_00e6_00b5_0081">控制流</a>
<hr>
</div>

<h3 class="section">15.4 维护CFG</h3>

<p><a name="index-cfghooks_002eh-3132"></a>
每个编译器过程都具有的一个重要任务是保持控制流图和所有profile信息更新。
在每个过程之后都重建控制流图是不可能的，因为这样代价会很高，
而且丢失的profile信息是根本无法重建的。

 <p>GCC有两个主要的中间表示，
并且它们都使用<code>basic_block</code>和<code>edge</code>数据类型来表示控制流。
两种表示都尽可能多的共享CFG维护的代码。对于每一种表示，
都定义了一套<dfn>hooks</dfn>，以便于需要的时候可以提供自己的CFG维护函数的实现。
这些钩子定义在<samp><span class="file">cfghooks.h</span></samp>中。这些钩子提供了几乎所有普通的CFG操作，
包括块分割和合并，边重定向，以及创建和删除基本块。
这些钩子应该提供所有需要的维护和操作RTL和<code>tree</code>表示下的CFG。

 <p>目前，基本块的边界在修改指令时会被透明的维护，因此很少需要手动移动它们
（比如当有人想要显式的输出基本块外面的指令的时候）。
将CFG看作指令链的组成部分，比看作建立在之上的结构，往往要更好些。
但是原则上，对于树表示的控制流图并不是数表示的必须部分。
函数树可以在不需要首先创建树表示的流图的情况下就被扩展。
这种情况在没有进行任何树优化的编译时会发生。当进行树优化时，
并且指令流被重写为SSA形式，CFG就和指令流非常紧密的联系起来了。
特别在语句插入和移除时要注意。实际上，如果没有同时对CFG进行恰当的维护，
整个树表示就很难使用和维护。

 <p><a name="index-BLOCK_005fFOR_005fINSN_002c-bb_005ffor_005fstmt-3133"></a>在RTL表示里，每条指令有一个<code>BLOCK_FOR_INSN</code>值用来表示指向包含该指令的基本块。
在<code>tree</code>表示里，函数<code>bb_for_stmt</code>返回一个指向包含所查询语句的基本块。

 <p><a name="index-block-statement-iterators-3134"></a>在<code>tree</code>表示里，当需要对函数进行改动时，
应该使用块语句迭代器（<dfn>block statement iterators</dfn>）。
这些迭代器提供了流程图和指令流的整体抽象。
块语句迭代器由<code>block_stmt_iterator</code>数据结构和一些修改函数构成，
包括下面的：

     <dl>
<dt><code>bsi_start</code><a name="index-bsi_005fstart-3135"></a><dd>该函数初始化一个<code>block_stmt_iterator</code>，使其指向基本块中第一条非空语句。

     <br><dt><code>bsi_last</code><a name="index-bsi_005flast-3136"></a><dd>该函数初始化一个<code>block_stmt_iterator</code>，使其指向基本块中最后一条语句。

     <br><dt><code>bsi_end_p</code><a name="index-bsi_005fend_005fp-3137"></a><dd>如果<code>block_stmt_iterator</code>表示基本块的结束，则为<code>true</code>。

     <br><dt><code>bsi_next</code><a name="index-bsi_005fnext-3138"></a><dd>该函数接受一个<code>block_stmt_iterator</code>，并使其指向它的后继。

     <br><dt><code>bsi_prev</code><a name="index-bsi_005fprev-3139"></a><dd>该函数接受一个<code>block_stmt_iterator</code>，并使其指向它的前驱。

     <br><dt><code>bsi_insert_after</code><a name="index-bsi_005finsert_005fafter-3140"></a><dd>该函数在<code>block_stmt_iterator</code>所在位置之后插入一条语句。
最后一个参数决定是否将语句迭代器更新指向新插入的语句，
还是保留指向原来的语句。

     <br><dt><code>bsi_insert_before</code><a name="index-bsi_005finsert_005fbefore-3141"></a><dd>该函数在<code>block_stmt_iterator</code>所在位置之前插入一条语句。
最后一个参数决定是否将语句迭代器更新指向新插入的语句，
还是保留指向原来的语句。

     <br><dt><code>bsi_remove</code><a name="index-bsi_005fremove-3142"></a><dd>该函数移除<code>block_stmt_iterator</code>所在位置的语句，
并且如果基本块中还有语句，则将剩余的语句重新链接。
</dl>

 <p><a name="index-BB_005fHEAD_002c-BB_005fEND-3143"></a>在RTL表示里，宏<code>BB_HEAD</code>和<code>BB_END</code>可以用来获得基本块的
起始<code>rtx</code>和结束<code>rtx</code>。没有抽象迭代器被定义用来遍历insn链，
不过可以使用<code>NEXT_INSN</code>和<code>PREV_INSN</code>替代。参见 <a href="Insns.html#Insns">Insns</a>。

 <p><a name="index-purge_005fdead_005fedges-3144"></a>通常一个代码操作过程将会简化指令流和控制流，也可能消除一些边。
例如当一个条件跳转被替换为非条件跳转，甚至在编译java时，
将可能的trapping指令简化为non-trapping。边的更新是不透明的，
每个优化过程都要求手动进行。不过，实际中这种情况很少发生。如果存在的话，
过程可以针对给定的基本块调用<code>purge_dead_edges</code>来移除多余的边。

 <p><a name="index-redirect_005fedge_005fand_005fbranch_002c-redirect_005fjump-3145"></a>另一个常见的情景是分支指令的重定向。
不过由于可以非常好的建模为控制流图里的边重定向，
因此应尽量使用<code>redirect_edge_and_branch</code>，而不是其它底层函数，
例如只是操作RTL链的<code>redirect_jump</code>。
定义在<samp><span class="file">cfghooks.h</span></samp>中的CFG钩子应该提供了操作和维护CFG所需要的全部API。

 <p><a name="index-split_005fblock-3146"></a>有时候，一个过程可能不得不要向基本块的中间插入控制流指令，这样的话，
就在基本块中间产生一个入口点。根据定义，这是不可能的，
因此必须要将块分开以确保只含有一个入口点，也就是基本块的头。
当基本块中间的指令必须成为跳转或分支指令的目标时，
可以使用CFG钩子<code>split_block</code>。

 <p><a name="index-insert_005finsn_005fon_005fedge-3147"></a><a name="index-commit_005fedge_005finsertions-3148"></a><a name="index-bsi_005finsert_005fon_005fedge-3149"></a><a name="index-bsi_005fcommit_005fedge_005finserts-3150"></a><a name="index-edge-splitting-3151"></a>对一个全局优化，一个常用的操作是在流图中将边拆分，并插入指令。
在RTL表示里，可以很容易的实现，
通过使用<code>insert_insn_on_edge</code>函数来生成一条暂存的“on the edge”指令，
以便之后的<code>commit_edge_insertions</code>调用来将插入的指令从边上移到基本块的指令流里。
如果需要的话，还会生成新的基本块。在<code>tree</code>表示里，
等价的函数为<code>bsi_insert_on_edge</code>，用来在边上插入一个块语句迭代器，
以及<code>bsi_commit_edge_inserts</code>，将指令挪到实际的指令流里。

 <p>在调试优化过程时，
函数<code>verify_flow_info</code>可能有助于发现在控制流图的更新代码中的bug。

 <p>注意，目前在由树的表示扩展到RTL时，控制流的表示会被丢弃。
长远的看，CFG应给被维持并随着函数树本身被扩展到RTL表示。

 </body></html>

