<html lang="zh">
<head>
<title>序列迭代器 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="GIMPLE.html#GIMPLE" title="GIMPLE">
<link rel="prev" href="GIMPLE_00e5_00ba_008f_00e5_0088_0097.html#GIMPLE_00e5_00ba_008f_00e5_0088_0097" title="GIMPLE序列">
<link rel="next" href="_00e5_00a2_009e_00e5_008a_00a0_00e4_00b8_0080_00e4_00b8_00aa_00e6_0096_00b0_00e7_009a_0084GIMPLE_00e8_00af_00ad_00e5_008f_00a5_00e4_00bb_00a3_00e7_00a0_0081.html#g_t_00e5_00a2_009e_00e5_008a_00a0_00e4_00b8_0080_00e4_00b8_00aa_00e6_0096_00b0_00e7_009a_0084GIMPLE_00e8_00af_00ad_00e5_008f_00a5_00e4_00bb_00a3_00e7_00a0_0081" title="增加一个新的GIMPLE语句代码">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%ba%8f%e5%88%97%e8%bf%ad%e4%bb%a3%e5%99%a8"></a>
<a name="g_t_00e5_00ba_008f_00e5_0088_0097_00e8_00bf_00ad_00e4_00bb_00a3_00e5_0099_00a8"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_00a2_009e_00e5_008a_00a0_00e4_00b8_0080_00e4_00b8_00aa_00e6_0096_00b0_00e7_009a_0084GIMPLE_00e8_00af_00ad_00e5_008f_00a5_00e4_00bb_00a3_00e7_00a0_0081.html#g_t_00e5_00a2_009e_00e5_008a_00a0_00e4_00b8_0080_00e4_00b8_00aa_00e6_0096_00b0_00e7_009a_0084GIMPLE_00e8_00af_00ad_00e5_008f_00a5_00e4_00bb_00a3_00e7_00a0_0081">增加一个新的GIMPLE语句代码</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="GIMPLE_00e5_00ba_008f_00e5_0088_0097.html#GIMPLE_00e5_00ba_008f_00e5_0088_0097">GIMPLE序列</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="GIMPLE.html#GIMPLE">GIMPLE</a>
<hr>
</div>

<h3 class="section">12.9 序列迭代器</h3>

<p><a name="index-Sequence-iterators-3003"></a>
序列迭代器为一些便利的结构，用于在序列中迭代语句。给定序列<code>SEQ</code>，典型的对gimple序列迭代器的使用为：

<pre class="smallexample">     gimple_stmt_iterator gsi;
     
     for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&amp;gsi))
       {
         gimple g = gsi_stmt (gsi);
         /* Do something with gimple statement <code>G</code>.  */
       }
</pre>
 <p>也可以向后迭代：

<pre class="smallexample">             for (gsi = gsi_last (seq); !gsi_end_p (gsi); gsi_prev (&amp;gsi))
</pre>
 <p>在基本块上进行前向和后向迭代可以通过配合使用<code>gsi_start_bb</code>和<code>gsi_last_bb</code>。

 <p>在下面的介绍中，我们有时会用到enum <code>gsi_iterator_update</code>。对于该枚举的有效操作有：

     <ul>
<li><code>GSI_NEW_STMT</code>
只有当增加单个语句被时才有效。将迭代器移动到该处。

     <li><code>GSI_SAME_STMT</code>
将迭代器放在相同的语句处。

     <li><code>GSI_CONTINUE_LINKING</code>
将迭代器移动到在相同方向上，适合链接其它语句的位置。
</ul>

 <p>下面为一个函数列表，用于操作和使用语句迭代器。

<div class="defun">
&mdash; GIMPLE function: gimple_stmt_iterator <b>gsi_start</b> (<var>gimple_seq seq</var>)<var><a name="index-gsi_005fstart-3004"></a></var><br>
<blockquote><p>返回一个新的迭代器，指向序列<code>SEQ</code>的第一个语句。如果<code>SEQ</code>为空，则迭代器的基本块为<code>NULL</code>。当迭代器总是需要正确设置基本块的时候，使用<code>gsi_start_bb</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_stmt_iterator <b>gsi_start_bb</b> (<var>basic_block bb</var>)<var><a name="index-gsi_005fstart_005fbb-3005"></a></var><br>
<blockquote><p>返回一个新的迭代器，指向基本块<code>BB</code>中的第一条语句。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_stmt_iterator <b>gsi_last</b> (<var>gimple_seq seq</var>)<var><a name="index-gsi_005flast-3006"></a></var><br>
<blockquote><p>返回一个新的迭代器，初始化为指向序列<code>SEQ</code>中的最后一条语句。如果<code>SEQ</code>为空，则迭代器的基本块为<code>NULL</code>。当迭代器总是需要正确设置基本块的时候，使用<code>gsi_last_bb</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_stmt_iterator <b>gsi_last_bb</b> (<var>basic_block bb</var>)<var><a name="index-gsi_005flast_005fbb-3007"></a></var><br>
<blockquote><p>返回一个新的迭代器，指向基本块<code>BB</code>中的最后一条语句。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: bool <b>gsi_end_p</b> (<var>gimple_stmt_iterator i</var>)<var><a name="index-gsi_005fend_005fp-3008"></a></var><br>
<blockquote><p>如果位于<code>I</code>的结尾，则返回<code>TRUE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: bool <b>gsi_one_before_end_p</b> (<var>gimple_stmt_iterator i</var>)<var><a name="index-gsi_005fone_005fbefore_005fend_005fp-3009"></a></var><br>
<blockquote><p>如果是<code>I</code>的结尾之前的一个语句，则返回<code>TRUE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_next</b> (<var>gimple_stmt_iterator *i</var>)<var><a name="index-gsi_005fnext-3010"></a></var><br>
<blockquote><p>将迭代器前进到下一个gimple语句。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_prev</b> (<var>gimple_stmt_iterator *i</var>)<var><a name="index-gsi_005fprev-3011"></a></var><br>
<blockquote><p>将迭代器前进到前一个gimple语句。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple <b>gsi_stmt</b> (<var>gimple_stmt_iterator i</var>)<var><a name="index-gsi_005fstmt-3012"></a></var><br>
<blockquote><p>返回当前的stmt。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_stmt_iterator <b>gsi_after_labels</b> (<var>basic_block bb</var>)<var><a name="index-gsi_005fafter_005flabels-3013"></a></var><br>
<blockquote><p>返回一个块语句迭代器，指向块<code>BB</code>中的第一个非标号的语句。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple <b>*gsi_stmt_ptr</b> (<var>gimple_stmt_iterator *i</var>)<var><a name="index-g_t_002agsi_005fstmt_005fptr-3014"></a></var><br>
<blockquote><p>返回指向当前stmt的指针。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: basic_block <b>gsi_bb</b> (<var>gimple_stmt_iterator i</var>)<var><a name="index-gsi_005fbb-3015"></a></var><br>
<blockquote><p>返回与该迭代器关联的基本块。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_seq <b>gsi_seq</b> (<var>gimple_stmt_iterator i</var>)<var><a name="index-gsi_005fseq-3016"></a></var><br>
<blockquote><p>返回与该迭代器关联的序列。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_remove</b> (<var>gimple_stmt_iterator *i, bool remove_eh_info</var>)<var><a name="index-gsi_005fremove-3017"></a></var><br>
<blockquote><p>从序列中移除当前stmt。迭代器被更新为指向下一条语句。当<code>REMOVE_EH_INFO</code>为真，则我们将迭代器<code>I</code>指向的语句从<code>EH</code>表中移除。否则我们不修改<code>EH</code>表。通常当语句将从<code>IL</code>中被移除，并不被插入到其它地方的时候，<code>REMOVE_EH_INFO</code>应该为真。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_link_seq_before</b> (<var>gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005flink_005fseq_005fbefore-3018"></a></var><br>
<blockquote><p>将语句序列<code>SEQ</code>链接在由迭代器<code>I</code>指向的语句之前。<code>MODE</code>指出了插入操作之后，迭代器要做什么（参见上面的<code>enum gsi_iterator_update</code>）。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_link_before</b> (<var>gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005flink_005fbefore-3019"></a></var><br>
<blockquote><p>将语句<code>G</code>链接在由迭代器<code>I</code>指向的语句之前。根据<code>MODE</code>来更新迭代器<code>I</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_link_seq_after</b> (<var>gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005flink_005fseq_005fafter-3020"></a></var><br>
<blockquote><p>将序列<code>SEQ</code>链接在由迭代器<code>I</code>指向的语句之后。<code>MODE</code>与在<code>gsi_insert_after</code>中的相同。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_link_after</b> (<var>gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005flink_005fafter-3021"></a></var><br>
<blockquote><p>将语句<code>G</code>链接在由迭代器<code>I</code>指向的语句之后。<code>MODE</code>与在<code>gsi_insert_after</code>中的相同。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_seq <b>gsi_split_seq_after</b> (<var>gimple_stmt_iterator i</var>)<var><a name="index-gsi_005fsplit_005fseq_005fafter-3022"></a></var><br>
<blockquote><p>将<code>I</code>之后的所有语句移送到新的序列中。返回该新的序列。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_seq <b>gsi_split_seq_before</b> (<var>gimple_stmt_iterator *i</var>)<var><a name="index-gsi_005fsplit_005fseq_005fbefore-3023"></a></var><br>
<blockquote><p>将<code>I</code>之前的所有语句移送到新的序列中。返回该新的序列。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_replace</b> (<var>gimple_stmt_iterator *i, gimple stmt, bool update_eh_info</var>)<var><a name="index-gsi_005freplace-3024"></a></var><br>
<blockquote><p>将由<code>I</code>指向的语句替换为<code>STMT</code>。如果<code>UPDATE_EH_INFO</code>为真，则原来语句的异常处理信息被移送到新的语句中。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_insert_before</b> (<var>gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005finsert_005fbefore-3025"></a></var><br>
<blockquote><p>在由迭代器<code>I</code>指向的语句之前插入语句<code>STMT</code>，更新<code>STMT</code>的基本块并扫描新的操作数。<code>MODE</code>描述了插入操作之后，如何更新迭代器<code>I</code>(参见enum <code>gsi_iterator_update</code>)。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_insert_seq_before</b> (<var>gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005finsert_005fseq_005fbefore-3026"></a></var><br>
<blockquote><p>类似于<code>gsi_insert_before</code>，不过是对于<code>SEQ</code>中的所有语句。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_insert_after</b> (<var>gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005finsert_005fafter-3027"></a></var><br>
<blockquote><p>在由迭代器<code>I</code>指向的语句之后插入语句<code>STMT</code>，更新<code>STMT</code>的基本块并扫描新的操作数。<code>MODE</code>描述了插入操作之后，如何更新迭代器<code>I</code>(参见enum <code>gsi_iterator_update</code>)。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_insert_seq_after</b> (<var>gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode</var>)<var><a name="index-gsi_005finsert_005fseq_005fafter-3028"></a></var><br>
<blockquote><p>类似于<code>gsi_insert_after</code>，不过是对于<code>SEQ</code>中的所有语句。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_stmt_iterator <b>gsi_for_stmt</b> (<var>gimple stmt</var>)<var><a name="index-gsi_005ffor_005fstmt-3029"></a></var><br>
<blockquote><p>查找<code>STMT</code>的迭代器。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_move_after</b> (<var>gimple_stmt_iterator *from, gimple_stmt_iterator *to</var>)<var><a name="index-gsi_005fmove_005fafter-3030"></a></var><br>
<blockquote><p>将语句移送到<code>FROM</code>处，使得其正好位于<code>TO</code>处的语句之后。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_move_before</b> (<var>gimple_stmt_iterator *from, gimple_stmt_iterator *to</var>)<var><a name="index-gsi_005fmove_005fbefore-3031"></a></var><br>
<blockquote><p>将语句移送到<code>FROM</code>处，使得其正好位于<code>TO</code>处的语句之前。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_move_to_bb_end</b> (<var>gimple_stmt_iterator *from, basic_block bb</var>)<var><a name="index-gsi_005fmove_005fto_005fbb_005fend-3032"></a></var><br>
<blockquote><p>将<code>FROM</code>处的语句移送到基本块<code>BB</code>的结尾。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_insert_on_edge</b> (<var>edge e, gimple stmt</var>)<var><a name="index-gsi_005finsert_005fon_005fedge-3033"></a></var><br>
<blockquote><p>将<code>STMT</code>增加到边<code>E</code>的待定列表中。直到调用<code>gsi_commit_edge_inserts</code>()之前，不会进行实际的插入操作。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_insert_seq_on_edge</b> (<var>edge e, gimple_seq seq</var>)<var><a name="index-gsi_005finsert_005fseq_005fon_005fedge-3034"></a></var><br>
<blockquote><p>将<code>SEQ</code>中语句序列增加到边<code>E</code>的待定列表中。直到调用<code>gsi_commit_edge_inserts</code>()之前，不会进行实际的插入操作。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: basic_block <b>gsi_insert_on_edge_immediate</b> (<var>edge e, gimple stmt</var>)<var><a name="index-gsi_005finsert_005fon_005fedge_005fimmediate-3035"></a></var><br>
<blockquote><p>类似于<code>gsi_insert_on_edge</code>+<code>gsi_commit_edge_inserts</code>。如果需要创建一个新的块，则将其返回。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_commit_one_edge_insert</b> (<var>edge e, basic_block *new_bb</var>)<var><a name="index-gsi_005fcommit_005fone_005fedge_005finsert-3036"></a></var><br>
<blockquote><p>提交在边<code>E</code>上进行的插入操作。如果创建了新的基本块，则将<code>NEW_BB</code>设置为该块，否则将其设置为<code>NULL</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: void <b>gsi_commit_edge_inserts</b> (<var>void</var>)<var><a name="index-gsi_005fcommit_005fedge_005finserts-3037"></a></var><br>
<blockquote><p>该函数将提交所有要进行的边插入操作，并在需要的时候创建新的基本块。
</p></blockquote></div>

 </body></html>

