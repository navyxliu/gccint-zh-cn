<html lang="zh">
<head>
<title>异常处理 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link rel="prev" href="_00e5_00b8_00a7_00e5_00b8_0083_00e5_00b1_0080.html#g_t_00e5_00b8_00a7_00e5_00b8_0083_00e5_00b1_0080" title="帧布局">
<link rel="next" href="_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5.html#g_t_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5" title="栈检查">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86"></a>
<a name="g_t_00e5_00bc_0082_00e5_00b8_00b8_00e5_00a4_0084_00e7_0090_0086"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5.html#g_t_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5">栈检查</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00b8_00a7_00e5_00b8_0083_00e5_00b1_0080.html#g_t_00e5_00b8_00a7_00e5_00b8_0083_00e5_00b1_0080">帧布局</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>
<hr>
</div>

<h4 class="subsection">17.10.2 对异常处理的支持</h4>

<p><a name="index-exception-handling-3982"></a>

<div class="defun">
&mdash; Macro: <b>EH_RETURN_DATA_REGNO</b> (<var>N</var>)<var><a name="index-EH_005fRETURN_005fDATA_005fREGNO-3983"></a></var><br>
<blockquote><p>一个C表达式，其值为第<var>N</var>个寄存器的编号，用于异常处理的数据，
或者为<code>INVALID_REGNUM</code>，如果小于<var>N</var>个寄存器可用。

      <p>异常处理库程序与异常处理者通过一套协定好的寄存器来通讯。理想的，
这些寄存器应该为调用破坏的；可以使用调用保存的寄存器，
但可能会对代码大小产生负影响。target必须支持至少两个数据寄存器，
但如果有足够的可用的寄存器，则应该定义为4。

      <p>你必须定义该宏，如果你想支持像DWARF 2提供的调用帧异常处理。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EH_RETURN_STACKADJ_RTX</b><var><a name="index-EH_005fRETURN_005fSTACKADJ_005fRTX-3984"></a></var><br>
<blockquote><p>一个C表达式，其值为RTL，表示一个位置，用来存储栈调整，在函数返回前应用。
这用于unwind栈到一个异常处理的调用帧中。其将被赋予0在通常的返回代码路径上。

      <p>通常这是一个调用破坏的硬件寄存器，但也可以为一个栈槽。

      <p>不要定义该宏，如果栈指针在调用帧本身通过序言和尾声来保存和恢复时；
这种情况下，异常处理库函数将更新栈位置并保存。否则，你必须定义该宏，
如果你想支持调用帧异常处理，就像DWARF2提供的那样。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EH_RETURN_HANDLER_RTX</b><var><a name="index-EH_005fRETURN_005fHANDLER_005fRTX-3985"></a></var><br>
<blockquote><p>一个C表达式，其值为一个RTL，表示一个位置，用来存储我们应该返回的异常处理的地址。
其在通常的返回的代码路径上将不被赋值。

      <p>通常这是在调用帧中通常返回地址存储的位置。对于通过在栈中弹出地址的target，
这可以为一个内存地址，就在target调用帧的下面，而不是在当前调用帧中。
如果被定义，<code>EH_RETURN_STACKADJ_RTX</code>将已经被赋值，
所以其可以用于计算target调用帧的位置。

      <p>一些target具有更加复杂的要求，比在初始化代码生成阶段存储到地址中。
这种情况下，要替代的使用<code>eh_return</code>指令模式。

      <p>如果你想支持调用帧异常处理，你必须定义该宏或者<code>eh_return</code>指令模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>RETURN_ADDR_OFFSET</b><var><a name="index-RETURN_005fADDR_005fOFFSET-3986"></a></var><br>
<blockquote><p>如果定义，则为一个整数值的C表达式，并会为此生成rtl来加上异常处理地址，
在其在异常处理表中搜索之前，并且再减去它，在用它来返回到异常处理之前。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_PREFERRED_EH_DATA_FORMAT</b> (<var>code, global</var>)<var><a name="index-ASM_005fPREFERRED_005fEH_005fDATA_005fFORMAT-3987"></a></var><br>
<blockquote><p>该宏选择在异常处理section中嵌入的指针的解码。如果尽可能，该宏应该被定义，
这样异常处理section将不会要求进行动态重定位，并可以为只读的。

      <p><var>code</var>为0，对于数据，1对于代码标号，2对于函数指针。
<var>global</var>为真，如果符号可以由动态重定位影响。
宏应该返回在<samp><span class="file">dwarf2.h</span></samp>中可以找到的<code>DW_EH_PE_*</code>的组合。

      <p>如果该宏没有定义，则指针将不被解码，而是直接表示。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX</b> (<var>file, encoding, size, addr, done</var>)<var><a name="index-ASM_005fMAYBE_005fOUTPUT_005fENCODED_005fADDR_005fRTX-3988"></a></var><br>
<blockquote><p>该宏允许target生成特定的magic，
用于表示<code>ASM_PREFERRED_EH_DATA_FORMAT</code>选择的encoding。
通常代码考虑pc-relative和indirect解码；
如果target使用text-relative或者data-relative解码，则必须定义该宏。

      <p>这是一个C语句，如果格式被处理，则执行分支跳转。<var>encoding</var>为选择的格式，
<var>size</var>为格式占用的字节数，<var>addr</var>为生成的<code>SYMBOL_REF</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MD_UNWIND_SUPPORT</b><var><a name="index-MD_005fUNWIND_005fSUPPORT-3989"></a></var><br>
<blockquote><p>一个字符串，指定了文件在unwind-dw2.c中被#include包含进来。
被包含进来的文件通常定义了<code>MD_FALLBACK_FRAME_STATE_FOR</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MD_FALLBACK_FRAME_STATE_FOR</b> (<var>context, fs</var>)<var><a name="index-MD_005fFALLBACK_005fFRAME_005fSTATE_005fFOR-3990"></a></var><br>
<blockquote><p>该宏允许target增加CPU和操作系统特定代码到call-frame unwinder，
用于当没有unwind数据可用时。最常见的原因是实现该宏来通过signal帧来unwind。

      <p>该宏由<samp><span class="file">unwind-dw2.c</span></samp>, <samp><span class="file">unwind-dw2-xtensa.c</span></samp>和<samp><span class="file">unwind-ia64.c</span></samp>中的
<code>uw_frame_state_for</code>调用。<var>context</var>为一个<code>_Unwind_Context</code>；
<var>fs</var>为一个<code>_Unwind_FrameState</code>。检查<code>context-&gt;ra</code>来得到被执行的
代码的地址，检查<code>context-&gt;cfa</code>来得到栈指针的值。如果帧可以被解码，
则寄存器保存地址应该在<var>fs</var>中更新，并且宏应该求值为<code>_URC_NO_REASON</code>。
如果帧不能被解码，则宏应该求解为<code>_URC_END_OF_STACK</code>。

      <p>对于java中合适的信号处理，该宏通过<code>MAKE_THROW_FRAME</code>来应用，
在<samp><span class="file">libjava/include/*-signal.h</span></samp>中定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MD_HANDLE_UNWABI</b> (<var>context, fs</var>)<var><a name="index-MD_005fHANDLE_005fUNWABI-3991"></a></var><br>
<blockquote><p>该宏允许target增加操作系统特定的代码到调用帧unwinder，
来处理IA-64 <code>.unwabi</code> unwinding伪指令，通常用于signal或者interrrupt帧。

      <p>该宏由<samp><span class="file">unwind-ia64.c</span></samp>中的<code>uw_update_context</code>调用。
<var>context</var>为一个<code>_Unwind_Context</code>；
<var>fs</var>为一个<code>_Unwind_FrameState</code>。检查<code>fs-&gt;unwabi</code>来得到abi。
如果<code>.unwabi</code>伪指令可以被处理，则寄存器保存地址应该在<var>fs</var>中更新。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_USES_WEAK_UNWIND_INFO</b><var><a name="index-TARGET_005fUSES_005fWEAK_005fUNWIND_005fINFO-3992"></a></var><br>
<blockquote><p>一个C表达式，计算为真，如果target需要unwind info给定comdat linkage。
定义其为<code>1</code>，如果comdat linkage有必要。缺省为<code>0</code>。
</p></blockquote></div>

 </body></html>

