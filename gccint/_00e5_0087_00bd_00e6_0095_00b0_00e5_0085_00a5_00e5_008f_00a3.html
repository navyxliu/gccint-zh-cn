<html lang="zh">
<head>
<title>函数入口 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link rel="prev" href="_00e8_00b0_0083_00e7_0094_00a8_00e8_0080_0085_00e4_00bf_009d_00e5_00ad_0098.html#g_t_00e8_00b0_0083_00e7_0094_00a8_00e8_0080_0085_00e4_00bf_009d_00e5_00ad_0098" title="调用者保存">
<link rel="next" href="Profiling.html#Profiling" title="Profiling">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%87%bd%e6%95%b0%e5%85%a5%e5%8f%a3"></a>
<a name="g_t_00e5_0087_00bd_00e6_0095_00b0_00e5_0085_00a5_00e5_008f_00a3"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Profiling.html#Profiling">Profiling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e8_00b0_0083_00e7_0094_00a8_00e8_0080_0085_00e4_00bf_009d_00e5_00ad_0098.html#g_t_00e8_00b0_0083_00e7_0094_00a8_00e8_0080_0085_00e4_00bf_009d_00e5_00ad_0098">调用者保存</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>
<hr>
</div>

<h4 class="subsection">17.10.11 函数入口和出口</h4>

<p><a name="index-function-entry-and-exit-4089"></a><a name="index-prologue-4090"></a><a name="index-epilogue-4091"></a>
这一章描述了输出函数入口（<dfn>prologue</dfn>）和出口（<dfn>epilogue</dfn>）代码的宏。

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_PROLOGUE</b> (<var>FILE *file, HOST_WIDE_INT size</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fPROLOGUE-4092"></a></var><br>
<blockquote><p>如果被定义，则为一个函数，其为函数的入口输出汇编代码。序言负责设置栈帧，
初始化帧指针寄存器，保存必须被保存的机器，并分配保存局部变量所需要的额外字节数
<var>size</var>。<var>size</var>为一个整数。
<var>file</var>为汇编代码应该被输出到的一个stdio流。

      <p>函数起始处的标号不需要被该宏输出。其已经在该宏运行时被输出了。

      <p><a name="index-regs_005fever_005flive-4093"></a>要确定哪些寄存器要保存，该宏可以引用数组<code>regs_ever_live</code>：
元素<var>r</var>为非零，如果硬件寄存器<var>r</var>在函数某处被使用。
这意味着倘若其不是调用使用的（call-used）寄存器，
则函数序言应该保存寄存器<var>r</var>。
(同样<code>TARGET_ASM_FUNCTION_EPILOGUE</code>也必须使用<code>regs_ever_live</code>。)

      <p>在具有“寄存器窗口”的机器上，函数入口代码不在栈中保存位于窗口中的寄存器，
即使它们认为被函数调用保留；替代的，如果在函数中使用了任何非调用使用的寄存器，
其使用适当的步骤来“压入”寄存器栈中。

      <p><a name="index-frame_005fpointer_005fneeded-4094"></a>在一些机器上，函数可以有帧指针，也可以没有，则函数入口代码必须相应的有所不同；
如果需要则其必须建立帧指针，否则不建立。要确定是否想要帧指针，
宏可以引用变量<code>frame_pointer_needed</code>。在运行时，如果函数需要帧指针，
则变量的值将被设为1。参见<a href="_00e6_00b6_0088_00e9_0099_00a4.html#g_t_00e6_00b6_0088_00e9_0099_00a4">消除</a>。

      <p>函数入口代码负责分配函数需要的任何栈空间。该栈空间包括下面列出的域。
大多数情况下，这些域按照列出的顺序被分配，最后列出的域最靠近栈顶
（如果<code>STACK_GROWS_DOWNWARD</code>被定义，则为最低地址，如果没有定义，
则为最高地址）。你可以为一个机器使用不同的顺序，
如果这样做更加方便或者出于兼容的原因。除了由于标准或者调试器的要求之外，
没有理由GCC使用的栈布局需要适合机器上的其它编译器所使用的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_END_PROLOGUE</b> (<var>FILE *file</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fEND_005fPROLOGUE-4095"></a></var><br>
<blockquote><p>如果被定义，则为一个函数，在序言的结尾处输出汇编代码。
这应该被用于当函数序言作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“序言指令模式”
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_BEGIN_EPILOGUE</b> (<var>FILE *file</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fBEGIN_005fEPILOGUE-4096"></a></var><br>
<blockquote><p>如果被定义，则为一个函数，在尾声的起始处输出汇编代码。
这应该被用于当函数尾声作为RTL输出时，并且你需要输出一些额外的汇编语言。
参见“尾声指令模式”
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_FUNCTION_EPILOGUE</b> (<var>FILE *file, HOST_WIDE_INT size</var>)<var><a name="index-TARGET_005fASM_005fFUNCTION_005fEPILOGUE-4097"></a></var><br>
<blockquote><p>如果被定义，则为一个函数，其为函数的退出输出汇编代码。
尾声负责恢复保存的寄存器和栈指针为函数被调用时的值，并将控制返回给调用者。
该宏接受跟<code>TARGET_ASM_FUNCTION_PROLOGUE</code>相同的参数，
并且要恢复的寄存器按照相同的方式通过<code>regs_ever_live</code>和
<code>CALL_USED_REGISTERS</code>来确定。

      <p>在一些机器上，有一个单独的指令，可以做从函数中返回的所有工作。
在这些机器上，给出那个名为&lsquo;<samp><span class="samp">return</span></samp>&rsquo;的指令，
并且不要定义宏<code>TARGET_ASM_FUNCTION_EPILOGUE</code>。

      <p>如果你想使用<code>TARGET_ASM_FUNCTION_EPILOGUE</code>，
则不要定义名为&lsquo;<samp><span class="samp">return</span></samp>&rsquo;的指令模式。
如果你想target切换使用return指令或者尾声，则定义一个&lsquo;<samp><span class="samp">return</span></samp>&rsquo;指令模式，
带有一个有效性条件用来测试target的适当的切换。
如果&lsquo;<samp><span class="samp">return</span></samp>&rsquo;指令模式的有效性条件为假，则使用尾声。

      <p>在一些机器上，函数可以有帧指针，也可以没有，则函数的退出代码必须相应有所不同。
有时这两种情况的代码会完全不同。要确定是否需要帧指针，
该宏可以引用变量<code>frame_pointer_needed</code>。当编译一个需要帧指针的函数时，
变量的值将为1。

      <p>通常，<code>TARGET_ASM_FUNCTION_PROLOGUE</code>和<code>TARGET_ASM_FUNCTION_EPILOGUE</code>
必须单独处理叶子函数。对于这样的函数，C变量<code>current_function_is_leaf</code>为
非零。参见<a href="_00e5_008f_00b6_00e5_00ad_0090_00e5_0087_00bd_00e6_0095_00b0.html#g_t_00e5_008f_00b6_00e5_00ad_0090_00e5_0087_00bd_00e6_0095_00b0">叶子函数</a>。

      <p>在一些机器上，一些函数在退出时弹出它们的参数，而其它的则将它们留给调用者来完成。
例如，68020当给定<samp><span class="option">-mrtd</span></samp>时会弹出具有固定参数个数的函数的参数。

      <p><a name="index-current_005ffunction_005fpops_005fargs-4098"></a>你对宏的定义决定了哪些函数弹出它们的自己的参数。
<code>TARGET_ASM_FUNCTION_EPILOGUE</code>需要知道这些。
称作<code>current_function_pops_args</code>的变量为函数应该弹出的参数的字节个数。
参见<a href="_00e6_00a0_0087_00e9_0087_008f_00e8_00bf_0094_00e5_009b_009e.html#g_t_00e6_00a0_0087_00e9_0087_008f_00e8_00bf_0094_00e5_009b_009e">标量返回</a>。
</p></blockquote></div>

     <ul>
<li><a name="index-current_005ffunction_005fpretend_005fargs_005fsize-4099"></a><code>current_function_pretend_args_size</code>个字节大小的未初始化空间位于栈中第一个
参数的下面。（这可能不是被分配的栈域的最起始处，如果调用序列在压入栈参数时还压入
了其它东西。通常，在这样的机器上，并没有压入其它东西，因为函数序言本身来做所有的
压栈操作）该域用于参数可以部分在寄存器中传递，部分在内存中传递的机器上，
以及支持<code>&lt;stdarg.h&gt;</code>的特性的情况。

     <li>有一块内存用于保存函数使用的特定的寄存器。该区域的大小，
可能还包括作为返回地址和指向之前栈帧的指针的一些空间，
其为机器特定的并且通常取决于函数中已经使用了哪些寄存器。
具有寄存器窗口的机器通常不需要这样的存储区域。

     <li>一块至少<var>size</var>个字节的区域，可能舍人到一个分配边界的大小，
来保存函数的局部变量。在一些机器上，该域和保存域可以按照相反的顺序出现，
使得保存域接近于栈顶。

     <li><a name="index-g_t_0040code_007bACCUMULATE_005fOUTGOING_005fARGS_007d-and-stack-frames-4100"></a>可选的，当<code>ACCUMULATE_OUTGOING_ARGS</code>被定义时，
还有一块<code>current_function_outgoing_args_size</code>字节大小的区域用于函数的传出
的参数列表。参见<a href="_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0.html#g_t_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0">栈参数</a>。
</ul>

<div class="defun">
&mdash; Macro: <b>EXIT_IGNORE_STACK</b><var><a name="index-EXIT_005fIGNORE_005fSTACK-4101"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，其为非0，如果返回指令或者函数尾声忽略栈指针的值；
换句话说，如果在从函数中返回前，删除调整栈指针的指令是安全的。缺省为0。

      <p>注意该宏的值只于维护帧指针的函数相关。
在没有帧指针的函数中删除最后的栈调整是绝对不安全的，并且编译器知道这种情况，
而不管<code>EXIT_IGNORE_STACK</code>定义如何。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EPILOGUE_USES</b> (<var>regno</var>)<var><a name="index-EPILOGUE_005fUSES-4102"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，其为非0，对于用于尾声或者&lsquo;<samp><span class="samp">return</span></samp>&rsquo;指令模式的寄存器。
栈和帧指针寄存器已经被假设需要使用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EH_USES</b> (<var>regno</var>)<var><a name="index-EH_005fUSES-4103"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，其为非0，对于用于异常处理机制的寄存器，
所以其应该被考虑为在一个异常边的入口上是活跃的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DELAY_SLOTS_FOR_EPILOGUE</b><var><a name="index-DELAY_005fSLOTS_005fFOR_005fEPILOGUE-4104"></a></var><br>
<blockquote><p>定义该宏，如果函数尾声包含延迟槽，并且函数其余的指令可以被移动过去。
该定义应该为一个C表达式，其值为一个整数表示有多少个延迟槽。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ELIGIBLE_FOR_EPILOGUE_DELAY</b> (<var>insn, n</var>)<var><a name="index-ELIGIBLE_005fFOR_005fEPILOGUE_005fDELAY-4105"></a></var><br>
<blockquote><p>一个C表达式，返回1，如果<var>insn</var>可以放在尾声中的延迟槽编号<var>n</var>中。

      <p>参数<var>n</var>为一个整数，其标识了目前被考虑的延迟槽（由于不同的延迟槽可以具有不同
的适任规则）。其从不为负，并且总是小于尾声延迟槽的总数
（<code>DELAY_SLOTS_FOR_EPILOGUE</code>的返回值）。
如果你为给定的延迟槽拒绝了一个特定的insn，原则上，其可以被后续的延迟槽重新考虑。
而且，其它insn还可以（至少原则上）被目前为止还没有被填充的延迟槽考虑。

      <p><a name="index-current_005ffunction_005fepilogue_005fdelay_005flist-4106"></a><a name="index-final_005fscan_005finsn-4107"></a>被接受填充尾声延迟槽的insn被放在一个RTL链表中，使用<code>insn_list</code>对象，
并存储在变量<code>current_function_epilogue_delay_list</code>中。
第一个延迟槽的insn位于链表中的第一个。你对宏<code>TARGET_ASM_FUNCTION_EPILOGUE</code>
的定义应该通过输出该链表的insn来填充延迟槽，通常是调用<code>final_scan_insn</code>。

      <p>你不需要定义该宏，如果你没有定义<code>DELAY_SLOTS_FOR_EPILOGUE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_ASM_OUTPUT_MI_THUNK</b> (<var>FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, tree function</var>)<var><a name="index-TARGET_005fASM_005fOUTPUT_005fMI_005fTHUNK-4108"></a></var><br>
<blockquote><p>一个函数，输出一个thunk函数的汇编代码，用于实现具有多继承的C++虚函数调用。
thunk作为一个虚函数的封装，用来调整隐式对象参数，在将控制移交给实函数之前。

      <p>首选，输出代码来增加整数<var>delta</var>为包含传递进来的第一个参数的为。
假设该参数包含一个指针，并用于在C++中传递<code>this</code>指针。
这是在函数序言之前的参数，例如在sparc上为&lsquo;<samp><span class="samp">%o0</span></samp>&rsquo;。

      <p>然后，如果<var>vcall_offset</var>非0，则在增加<var>delta</var>之后应该进行额外的调整。
特别是，如果<var>p</var>为被调整的指针，则应该进行如下的调整：

     <pre class="smallexample">          p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]
</pre>
      <p>加法之后，输出代码跳转到<var>function</var>，其为<code>FUNCTION_DECL</code>。
这是一个直接跳转，而不是调用，并且不触及返回地址。因此从<var>FUNCTION</var>中返回时，
将返回到调用当前&lsquo;<samp><span class="samp">thunk</span></samp>&rsquo;的地方。

      <p>其效果就好像是函数被直接调用，并使用调整后的第一个参数。
该宏负责输出thunk函数的所有代码；<code>TARGET_ASM_FUNCTION_PROLOGUE</code>和<code>TARGET_ASM_FUNCTION_EPILOGUE</code>不被调用。

      <p><var>thunk_fndecl</var>是冗余的。（<var>delta</var>和<var>function</var>已经从中被抽取出来。）
其可能在一些target上有用，也很可能没用。

      <p>如果你没有定义该宏，则C++前端的target无关代码将会生成一个不太有效的重量级的
thunk，其调用<var>function</var>而不是直接跳转过去。普通的方法不支持varargs。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ASM_CAN_OUTPUT_MI_THUNK</b> (<var>tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, tree function</var>)<var><a name="index-TARGET_005fASM_005fCAN_005fOUTPUT_005fMI_005fTHUNK-4109"></a></var><br>
<blockquote><p>一个函数，返回真，如果TARGET_ASM_OUTPUT_MI_THUNK应该能够为其传递的参数所指定的
thunk函数输出汇编代码，否则为假。在后一种情况下，C++前端将会使用普通的方式，
并具有之前提到的限制。
</p></blockquote></div>

 </body></html>

