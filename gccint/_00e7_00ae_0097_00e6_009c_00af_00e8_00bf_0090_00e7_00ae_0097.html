<html lang="zh">
<head>
<title>算术运算 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e5_0092_008c_00e5_0086_0085_00e5_00ad_0098.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e5_0092_008c_00e5_0086_0085_00e5_00ad_0098" title="寄存器和内存">
<link rel="next" href="_00e6_00af_0094_00e8_00be_0083_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e6_00af_0094_00e8_00be_0083_00e8_00bf_0090_00e7_00ae_0097" title="比较运算">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97"></a>
<a name="g_t_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00af_0094_00e8_00be_0083_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e6_00af_0094_00e8_00be_0083_00e8_00bf_0090_00e7_00ae_0097">比较运算</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e5_0092_008c_00e5_0086_0085_00e5_00ad_0098.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e5_0092_008c_00e5_0086_0085_00e5_00ad_0098">寄存器和内存</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.9 RTL算术运算表达式</h3>

<p><a name="index-arithmetic_002c-in-RTL-2404"></a><a name="index-math_002c-in-RTL-2405"></a><a name="index-RTL-expressions-for-arithmetic-2406"></a>
除非其它规定，所有算术表达式的操作数必须对模式<var>m</var>有效。一个操作数对模式<var>m</var>有效，是指当它具有模式<var>m</var>，或者如果它是一个<code>const_int</code>或者<code>const_double</code>，并且<var>m</var>是一个<code>MODE_INT</code>类的模式。

 <p>对于可交换的二进制操作，常量应该放到第二个操作数的位置。

     
<a name="index-plus-2407"></a>
<a name="index-ss_005fplus-2408"></a>
<a name="index-us_005fplus-2409"></a>
<a name="index-RTL-sum-2410"></a>
<a name="index-RTL-addition-2411"></a>
<a name="index-RTL-addition-with-signed-saturation-2412"></a>
<a name="index-RTL-addition-with-unsigned-saturation-2413"></a>
<dl><dt><code>(plus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_plus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_plus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>这三个表达式都表示<var>x</var>和<var>y</var>所表示的值的和，机器模式为<var>m</var>。它们在整数机器模式的溢出方面有所不同。<code>plus</code>以<var>m</var>的宽度求模进行环绕；<code>ss_plus</code>饱和为<var>m</var>可表示的有符号最大值；<code>us_plus</code>饱和为无符号最大值。

     <!-- ??? What happens on overflow of floating point modes? -->
     <p><a name="index-lo_005fsum-2414"></a><br><dt><code>(lo_sum:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>该表达式表示<var>x</var>与<var>y</var>低位的和。其跟<code>high</code> (see <a href="Constants.html#Constants">Constants</a>)一起使用，来表示在RISC机器中通常使用的两个指令序列，来引用一个全局内存位置。

     <p>低位的位数是机器相关的，但通常为<code>Pmode</code>中的位数减去<code>high</code>所设置的位数。

     <p><var>m</var>应该为<code>Pmode</code>。

     <p><a name="index-minus-2415"></a><a name="index-ss_005fminus-2416"></a><a name="index-us_005fminus-2417"></a><a name="index-RTL-difference-2418"></a><a name="index-RTL-subtraction-2419"></a><a name="index-RTL-subtraction-with-signed-saturation-2420"></a><a name="index-RTL-subtraction-with-unsigned-saturation-2421"></a><br><dt><code>(minus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_minus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_minus:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>
这三个表达式表示从<var>x</var>中减去<var>y</var>的结果，机器模式为<var>m</var>。在溢出方面的行为与<code>plus</code>的三种版本相同（参见上面）。

     <p><a name="index-compare-2422"></a><a name="index-RTL-comparison-2423"></a><br><dt><code>(compare:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>表示从<var>x</var>中减去<var>y</var>的结果，用于进行比较。计算结果不产生溢出，就好像是有无限的精度一样。

     <p>当然，机器不会真的进行无限精度的减法。然而，它们可以假定这样做，当只使用结果的正负符号时，这样情况下，结果被存放在条件代码中。并且，这是这种表达式唯一可以被使用的方式：作为值存储在条件代码中，或者<code>(cc0)</code>，或者一个寄存器。See <a href="Comparisons.html#Comparisons">Comparisons</a>。

     <p>机器模式<var>m</var>与<var>x</var>和<var>y</var>的机器模式没有关联，而是条件代码值的机器模式。如果使用<code>(cc0)</code>，则为<code>VOIDmode</code>，否则为类别<code>MODE_CC</code>中的某个模式，通常为<code>CCmode</code>。See <a href="Condition-Code.html#Condition-Code">Condition Code</a>。如果<var>m</var>为<code>VOIDmode</code>或者<code>CCmode</code>，则运算会返回足够的信息，使得任何比较运算符可以被应用到<code>COMPARE</code>运算的结果上。对于类别<code>MODE_CC</code>中的其它机器模式，运算只返回信息的子集。

     <p>通常，<var>x</var>和<var>y</var>必须具有相同的机器模式。否则，<code>compare</code>只有当<var>x</var>的机器模式在类别<code>MODE_INT</code>中，并且<var>y</var>为一个机器模式为<code>VOIDmode</code>的<code>const_int</code>或者<code>const_double</code>，这时才有效。<var>x</var>的机器模式决定了比较按照什么机器模式进行；因此其不能为<code>VOIDmode</code>。

     <p>如果其中一个操作数为常量，则其应该被放在第二个操作数的位置，并且相应的调整比较代码。

     <p>指定两个<code>VOIDmode</code>常量的<code>compare</code>是无效的，因为无法知道比较要按照什么机器模式进行；比较必须或者在编译过程中被折叠，或者第一个操作数必须被加载到机器模式已知的寄存器中。

     <p><a name="index-neg-2424"></a><a name="index-ss_005fneg-2425"></a><a name="index-us_005fneg-2426"></a><a name="index-negation-2427"></a><a name="index-negation-with-signed-saturation-2428"></a><a name="index-negation-with-unsigned-saturation-2429"></a><br><dt><code>(neg:</code><var>m</var> <var>x</var><code>)</code><dt><code>(ss_neg:</code><var>m</var> <var>x</var><code>)</code><dt><code>(us_neg:</code><var>m</var> <var>x</var><code>)</code><dd>这两个表达式表示<var>x</var>所表示的值的负数（零减去该值），机器模式为<var>m</var>。它们在整数机器模式的溢出行为上有所不同。对于<code>neg</code>，操作数的负数可以为无法用机器模式<var>m</var>表示的数，这种情况下，其被截取为<var>m</var>。<code>ss_neg</code>和<code>us_neg</code>确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

     <p><a name="index-mult-2430"></a><a name="index-ss_005fmult-2431"></a><a name="index-us_005fmult-2432"></a><a name="index-multiplication-2433"></a><a name="index-product-2434"></a><a name="index-multiplication-with-signed-saturation-2435"></a><a name="index-multiplication-with-unsigned-saturation-2436"></a><br><dt><code>(mult:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_mult:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_mult:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>表示<var>x</var>和<var>y</var>所表示的值的有符号乘积，机器模式为<var>m</var>。<code>ss_mult</code>和<code>us_mult</code>确保超出边界的结果饱和为最大或者最小的有符号或者无符号值。

     <p>一些机器支持产生比操作数更宽的乘积。则指令模式可以写成

     <pre class="smallexample">          (mult:<var>m</var> (sign_extend:<var>m</var> <var>x</var>) (sign_extend:<var>m</var> <var>y</var>))
</pre>
     <p>其中<var>m</var>比<var>x</var>和<var>y</var>的机器模式更宽。

     <p>对于无符号的加宽的乘法，使用相同的语句，只不过把<code>sign_extend</code>替换成<code>zero_extend</code>。

     <p><a name="index-div-2437"></a><a name="index-ss_005fdiv-2438"></a><a name="index-division-2439"></a><a name="index-signed-division-2440"></a><a name="index-signed-division-with-signed-saturation-2441"></a><a name="index-quotient-2442"></a><br><dt><code>(div:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ss_div:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>表示<var>x</var>有符号除以<var>y</var>的商，机器模式为<var>m</var>。如果<var>m</var>为一个浮点机器模式，则表示确切的商；否则为整数化的商。<code>ss_div</code>确保超出边界的结果饱和为最大或者最小的有符号值。

     <p>一些机器具有的除法指令，其操作数和商的宽度不全相同；你应该使用<code>truncate</code>和<code>sign_extend</code>来表示这样的指令，

     <pre class="smallexample">          (truncate:<var>m1</var> (div:<var>m2</var> <var>x</var> (sign_extend:<var>m2</var> <var>y</var>)))
</pre>
     <p><a name="index-udiv-2443"></a><a name="index-unsigned-division-2444"></a><a name="index-unsigned-division-with-unsigned-saturation-2445"></a><a name="index-division-2446"></a><br><dt><code>(udiv:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(us_div:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>类似<code>div</code>，不过表示无符号除法。<code>us_div</code>确保超出边界的结果饱和为最大或者最小的无符号值。

     <p><a name="index-mod-2447"></a><a name="index-umod-2448"></a><a name="index-remainder-2449"></a><a name="index-division-2450"></a><br><dt><code>(mod:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(umod:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>类似<code>div</code>和<code>udiv</code>，不过表示余数。

     <p><a name="index-smin-2451"></a><a name="index-smax-2452"></a><a name="index-signed-minimum-2453"></a><a name="index-signed-maximum-2454"></a><br><dt><code>(smin:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(smax:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>表示<var>x</var>和<var>y</var>的较小值（<code>smin</code>）或者较大值（<code>smax</code>），按照机器模式为<var>m</var>的有符号值解析。当用于浮点，如果两个操作数都为零，或者其中一个为<code>NaN</code>，则没有规定哪一个操作数被作为结果返回。

     <p><a name="index-umin-2455"></a><a name="index-umax-2456"></a><a name="index-unsigned-minimum-and-maximum-2457"></a><br><dt><code>(umin:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(umax:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>类似<code>smin</code>和<code>smax</code>，不过值被解析为无符号整数。

     <p><a name="index-not-2458"></a><a name="index-complement_002c-bitwise-2459"></a><a name="index-bitwise-complement-2460"></a><br><dt><code>(not:</code><var>m</var> <var>x</var><code>)</code><dd>表示对<var>x</var>所表示的值进行按位求补，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-and-2461"></a><a name="index-logical_002dand_002c-bitwise-2462"></a><a name="index-bitwise-logical_002dand-2463"></a><br><dt><code>(and:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>表示对<var>x</var>和<var>y</var>所表示的值按位进行逻辑与，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-ior-2464"></a><a name="index-inclusive_002dor_002c-bitwise-2465"></a><a name="index-bitwise-inclusive_002dor-2466"></a><br><dt><code>(ior:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>表示对<var>x</var>和<var>y</var>所表示的值按位进行逻辑或，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-xor-2467"></a><a name="index-exclusive_002dor_002c-bitwise-2468"></a><a name="index-bitwise-exclusive_002dor-2469"></a><br><dt><code>(xor:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>表示对<var>x</var>和<var>y</var>所表示的值按位进行逻辑异或，机器模式为<var>m</var>，且必须为一个定点机器模式。

     <p><a name="index-ashift-2470"></a><a name="index-ss_005fashift-2471"></a><a name="index-us_005fashift-2472"></a><a name="index-left-shift-2473"></a><a name="index-shift-2474"></a><a name="index-arithmetic-shift-2475"></a><a name="index-arithmetic-shift-with-signed-saturation-2476"></a><a name="index-arithmetic-shift-with-unsigned-saturation-2477"></a><br><dt><code>(ashift:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(ss_ashift:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(us_ashift:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dd>这三个表达式用来表示对<var>x</var>进行向左算术移位<var>c</var>。它们在整数机器模式的溢出方面有所不同。<code>ashift</code>运算是一个普通的移位，当符号位有改变时，其没有特殊的行为；<code>ss_ashift</code>和<code>us_ashift</code>，饱和为可表示的最小或者最大值，如果任何被移出的位与最终的符号位不同。

     <p><var>x</var>具有机器模式<var>m</var>，一个定点机器模式。<var>c</var>为一个定点机器模式或者一个模式为<code>VOIDmode</code>的常量。

     <p><a name="index-lshiftrt-2478"></a><a name="index-right-shift-2479"></a><a name="index-ashiftrt-2480"></a><br><dt><code>(lshiftrt:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(ashiftrt:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dd>类似于<code>ashift</code>，不过是向右移位。不像向左移位的情况，这两种运算是有区别的。

     <p><a name="index-rotate-2481"></a><a name="index-rotate-2482"></a><a name="index-left-rotate-2483"></a><a name="index-rotatert-2484"></a><a name="index-right-rotate-2485"></a><br><dt><code>(rotate:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dt><code>(rotatert:</code><var>m</var> <var>x</var> <var>c</var><code>)</code><dd>类似的，只不过是表示向左和向右旋转。如果<var>c</var>为常量，则使用<code>rotate</code>。

     <p><a name="index-abs-2486"></a><a name="index-absolute-value-2487"></a><br><dt><code>(abs:</code><var>m</var> <var>x</var><code>)</code><dd>表示<var>x</var>的绝对值，按照机器模式<var>m</var>来计算。

     <p><a name="index-sqrt-2488"></a><a name="index-square-root-2489"></a><br><dt><code>(sqrt:</code><var>m</var> <var>x</var><code>)</code><dd>表示<var>x</var>的平方根，按照机器模式<var>m</var>来计算。<var>m</var>通常为浮点机器模式。

     <p><a name="index-ffs-2490"></a><br><dt><code>(ffs:</code><var>m</var> <var>x</var><code>)</code><dd>表示在<var>x</var>中，最低有效，位为1的索引加上1，为一个模式<var>m</var>的整数。（如果<var>x</var>为零，则值为零。）<var>x</var>的机器模式不需要为<var>m</var>；取决于目标机器，可以有不同的机器模式的组合。

     <p><a name="index-clz-2491"></a><br><dt><code>(clz:</code><var>m</var> <var>x</var><code>)</code><dd>表示<var>x</var>中，从最高有效位开始，起始处为0的位数，为一个模式<var>m</var>的整数。如果<var>x</var>为零，则值由<code>CLZ_DEFINED_VALUE_AT_ZERO</code> (see <a href="Misc.html#Misc">Misc</a>)来确定。注意，。<var>x</var>的机器模式通常为一个整数模式。

     <p><a name="index-ctz-2492"></a><br><dt><code>(ctz:</code><var>m</var> <var>x</var><code>)</code><dd>表示<var>x</var>中，从最低有效位开始，结尾处为0的位数，为一个模式<var>m</var>的整数。如果<var>x</var>为零，则值由<code>CTZ_DEFINED_VALUE_AT_ZERO</code> (see <a href="Misc.html#Misc">Misc</a>)来确定。除此之外，<code>ctz(x)</code>等价于<code>ffs(</code><var>x</var><code>) - 1</code>。<var>x</var>的机器模式通常为一个整数模式。

     <p><a name="index-popcount-2493"></a><br><dt><code>(popcount:</code><var>m</var> <var>x</var><code>)</code><dd>表示<var>x</var>中为1的位数，为一个模式<var>m</var>的整数。<var>x</var>的机器模式通常为一个整数模式。

     <p><a name="index-parity-2494"></a><br><dt><code>(parity:</code><var>m</var> <var>x</var><code>)</code><dd>表示<var>x</var>中为1的位数对2进行求模，为一个模式<var>m</var>的整数。<var>x</var>的机器模式通常为一个整数模式。

     <p><a name="index-bswap-2495"></a><br><dt><code>(bswap:</code><var>m</var> <var>x</var><code>)</code><dd>表示将<var>x</var>值的字节顺序进行反转，结果为<var>m</var>机器模式，其必须为一个定点机器模式。

 </dl>

 </body></html>

