<html lang="zh">
<head>
<title>指令输出 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f.html#g_t_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f" title="汇编格式">
<link rel="prev" href="_00e7_0094_00a8_00e4_00ba_008e_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e5_00ae_008f.html#g_t_00e7_0094_00a8_00e4_00ba_008e_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e5_00ae_008f" title="用于初始化的宏">
<link rel="next" href="_00e6_00b4_00be_00e9_0081_00a3_00e8_00a1_00a8.html#g_t_00e6_00b4_00be_00e9_0081_00a3_00e8_00a1_00a8" title="派遣表">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%8c%87%e4%bb%a4%e8%be%93%e5%87%ba"></a>
<a name="g_t_00e6_008c_0087_00e4_00bb_00a4_00e8_00be_0093_00e5_0087_00ba"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00b4_00be_00e9_0081_00a3_00e8_00a1_00a8.html#g_t_00e6_00b4_00be_00e9_0081_00a3_00e8_00a1_00a8">派遣表</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e7_0094_00a8_00e4_00ba_008e_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e5_00ae_008f.html#g_t_00e7_0094_00a8_00e4_00ba_008e_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e5_00ae_008f">用于初始化的宏</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f.html#g_t_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f">汇编格式</a>
<hr>
</div>

<h4 class="subsection">17.21.7 汇编指令的输出</h4>

<!-- prevent bad page break with this line -->
<p>这章描述了汇编指令的输出。

<div class="defun">
&mdash; Macro: <b>REGISTER_NAMES</b><var><a name="index-REGISTER_005fNAMES-4442"></a></var><br>
<blockquote><p>一段C初始化程序，包含了机器寄存器的汇编名字，每个名字使用C字符串常量表示。
这用来将编译器中的寄存器编号转换成汇编语言。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ADDITIONAL_REGISTER_NAMES</b><var><a name="index-ADDITIONAL_005fREGISTER_005fNAMES-4443"></a></var><br>
<blockquote><p>如果定义，则为结构体数组的初始化程序，结构体包含了名字和寄存器编号。
该宏定义了硬件寄存器的附加名字，这样就可以允许在声明中的<code>asm</code>选项，
来使用附加名引用寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_OPCODE</b> (<var>stream, ptr</var>)<var><a name="index-ASM_005fOUTPUT_005fOPCODE-4444"></a></var><br>
<blockquote><p>定义该宏，如果你在使用一个不常见的汇编器，其需要不一样的机器指令名字。

      <p>定义为C语句，输出一个汇编指令代码到标准输入输出流<var>stream</var>中。
宏操作数<var>ptr</var>为类型是<code>char *</code>的变量，其指向内部形式中的指令码名字，
内部形式使用机器描述来表示。该定义应该输出操作码名字到<var>stream</var>中，
执行你想要的任何转换，并且将变量<var>ptr</var>增加到指向opcode的尾部，
这样其才不会被输出两次。

      <p>实际上，相对于整个指令码的名字，你的宏定义可以处理或多或少的部分；
但是如果你想处理包含&lsquo;<samp><span class="samp">%</span></samp>&rsquo;序列的文本，则必须小心你所做的替换。
要保证增加<var>ptr</var>，使得不会输出不应该被输出的文本。

      <p><a name="index-recog_005fdata_002eoperand-4445"></a>如果需要查看操作数的值，它们可以作为<code>recog_data.operand</code>的元素被找到。

      <p>如果宏定义不做任何事情，则指令使用通常的方式来输出。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FINAL_PRESCAN_INSN</b> (<var>insn, opvec, noperands</var>)<var><a name="index-FINAL_005fPRESCAN_005fINSN-4446"></a></var><br>
<blockquote><p>如果定义，则为一条C语句，其就在为<var>insn</var>输出汇编代码之前将被执行，
用来修改被抽取的操作数，从而可以被不同方式的输出。

      <p>这里的参数<var>opvec</var>为一个向量，包含了从<var>insn</var>中抽取的操作数，
<var>noperands</var>为向量的元素个数。该向量的内容用于将insn模板转换成汇编代码，
所以你可以通过修改向量的内容来改变汇编输出。

      <p>该宏当有多个汇编语法共用一个指令模式文件时很有用；通过定义该宏，
你可以使大量类别的指令按照不同的方式输出（例如重组操作）。
自然的，影响单个insn模式的汇编语法，
应该通过在那些指令模式中写条件输出程序来处理。

      <p>如果没有定义该宏，则其相当于一条空语句。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRINT_OPERAND</b> (<var>stream, x, code</var>)<var><a name="index-PRINT_005fOPERAND-4447"></a></var><br>
<blockquote><p>C复合语句，用来将指令操作数<var>x</var>的汇编语法输出到标准输入输出流<var>stream</var>中。
<var>x</var>为RTL表达式。

      <p><var>code</var>值可以用来指定打印操作数的方式。
用于当操作数必须根据上下文进行不同的打印的时候。
<var>code</var>来自用于打印操作数的&lsquo;<samp><span class="samp">%</span></samp>&rsquo;指定语句。
如果指定语句只是&lsquo;<samp><span class="samp">%</span><var>digit</var></samp>&rsquo;，则<var>code</var>为0；
如果指定语句为&lsquo;<samp><span class="samp">%</span><var>ltr</var><var>digit</var></samp>&rsquo;，则<var>code</var>为<var>ltr</var>的ASCII码。

      <p><a name="index-reg_005fnames-4448"></a>如果<var>x</var>为寄存器，则该宏应该打印寄存器的名字。
名字可以在数组<code>reg_names</code>中找到，数组的类型为<code>char *[]</code>。
<code>reg_names</code>通过<code>REGISTER_NAMES</code>来初始化。

      <p>当机器描述具有一个&lsquo;<samp><span class="samp">%</span><var>punct</var></samp>&rsquo;指定语句时
（&lsquo;<samp><span class="samp">%</span></samp>&rsquo;后面跟随一个标点符号字符），则该宏被调用时，<var>x</var>为空指针，
<var>code</var>为标点符号字符。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRINT_OPERAND_PUNCT_VALID_P</b> (<var>code</var>)<var><a name="index-PRINT_005fOPERAND_005fPUNCT_005fVALID_005fP-4449"></a></var><br>
<blockquote><p>一个C表达式，
当<var>code</var>为在<code>PRINT_OPERAND</code>宏中使用的有效的标点符号字符时，
其计算为真。如果没有定义<code>PRINT_OPERAND_PUNCT_VALID_P</code>，
则意味着不以这种方式使用标点符号字符（除了标准的&lsquo;<samp><span class="samp">%</span></samp>&rsquo;以外）。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRINT_OPERAND_ADDRESS</b> (<var>stream, x</var>)<var><a name="index-PRINT_005fOPERAND_005fADDRESS-4450"></a></var><br>
<blockquote><p>C复合语句，用来将指令操作数为内存引用，其地址为<var>x</var>的汇编语法，
输出到标准输入输出流<var>stream</var>中。<var>x</var>为一个RTL表达式。

      <p><a name="index-g_t_0040code_007bTARGET_005fENCODE_005fSECTION_005fINFO_007d-usage-4451"></a>在一些机器上，符号地址的语法取决于地址所引用的section。在这些机器上，
定义钩子<code>TARGET_ENCODE_SECTION_INFO</code>来将信息存储到<code>symbol_ref</code>，
并在这里进行检查。参见 <a href="_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f.html#g_t_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f">汇编格式</a>。
</p></blockquote></div>

 <p><a name="index-dbr_005fsequence_005flength-4452"></a>

<div class="defun">
&mdash; Macro: <b>DBR_OUTPUT_SEQEND</b> (<var>file</var>)<var><a name="index-DBR_005fOUTPUT_005fSEQEND-4453"></a></var><br>
<blockquote><p>C语句，在所有的栈槽填充指令被输出之后执行。如果需要的话，
调用<code>dbr_sequence_length</code>来判定在序列中被填充的栈槽数目
（如果当前不是输出一个序列，则为0），用来决定输出多少个no-ops，或其它。

      <p>如果不做任何事情，就不要定义该宏，但是如果将延迟序列显示化，
则会有助于阅读汇编输出（例如，使用空格）。
</p></blockquote></div>

 <p><a name="index-final_005fsequence-4454"></a>注意，用于带有延迟槽的指令的输出程序，
必须准备好处理没有被作为序列输出的情况（即，当没有运行调度过程，
或者没有找到栈槽填充者）。当没有处理序列时，变量<code>final_sequence</code>为空，
否则其包含了被输出的rtx <code>sequence</code>。

 <p><a name="index-asm_005ffprintf-4455"></a>

<div class="defun">
&mdash; Macro: <b>REGISTER_PREFIX</b><var><a name="index-REGISTER_005fPREFIX-4456"></a></var><br>
&mdash; Macro: <b>LOCAL_LABEL_PREFIX</b><var><a name="index-LOCAL_005fLABEL_005fPREFIX-4457"></a></var><br>
&mdash; Macro: <b>USER_LABEL_PREFIX</b><var><a name="index-USER_005fLABEL_005fPREFIX-4458"></a></var><br>
&mdash; Macro: <b>IMMEDIATE_PREFIX</b><var><a name="index-IMMEDIATE_005fPREFIX-4459"></a></var><br>
<blockquote><p>如果定义，则为C字符串表达式，用于<code>asm_fprintf</code>（参见 <samp><span class="file">final.c</span></samp>）
的选项&lsquo;<samp><span class="samp">%R</span></samp>&rsquo;, &lsquo;<samp><span class="samp">%L</span></samp>&rsquo;, &lsquo;<samp><span class="samp">%U</span></samp>&rsquo;和 &lsquo;<samp><span class="samp">%I</span></samp>&rsquo;。
这在单个<samp><span class="file">md</span></samp>文件必须支持多个汇编格式时很有用。这种情况下，
不同的<samp><span class="file">tm.h</span></samp>文件可以定义不同的这些宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_FPRINTF_EXTENSIONS</b> (<var>file, argptr, format</var>)<var><a name="index-ASM_005fFPRINTF_005fEXTENSIONS-4460"></a></var><br>
<blockquote><p>如果定义，该宏应该被扩展为一系列<code>case</code>语句，
其将在<code>asm_fprintf</code>函数中的<code>switch</code>语句里被解析。
这将应允许target来定义额外的printf格式，其在生成它们的汇编语句时很有帮助。
注意，大写字母被保留用于<code>asm_fprintf</code>将来的通用扩展，
所以不要用于target特定代码中。输出文件由参数<var>file</var>给定。
varargs输出指针为<var>argptr</var>，格式字符串的其余部分，由<var>format</var>指向。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASSEMBLER_DIALECT</b><var><a name="index-ASSEMBLER_005fDIALECT-4461"></a></var><br>
<blockquote><p>如果你的target支持多个汇编语言方言（例如不同的操作码），
可以定义该宏作为C表达式，给出汇编语言方言的索引，0作为第一个。

      <p>如果该宏被定义，你可以在指令模式的输出模版中（参见输出模版）或者asm_fprintf的第一个参数中使用如下的结构形式

     <pre class="smallexample">          &lsquo;<samp><span class="samp">{option0|option1|option2...}</span></samp>&rsquo;
</pre>
      <p class="noindent">该结构输出&lsquo;<samp><span class="samp">option0</span></samp>&rsquo;, &lsquo;<samp><span class="samp">option1</span></samp>&rsquo;, &lsquo;<samp><span class="samp">option2</span></samp>&rsquo;等等，
如果<code>ASSEMBLER_DIALECT</code>的值为0，1，2，等等。
这些字符串中的任何特殊字符将保留它们通常的含义。
如果括号中的可选项多于<code>ASSEMBLER_DIALECT</code>的值，则什么也不输出。

      <p>如果没有定义该宏，字符&lsquo;<samp><span class="samp">, &lsquo;</span><samp><span class="samp">|</span></samp><span class="samp">&rsquo;和&lsquo;</span><samp></samp><span class="samp">&rsquo;</span></samp>&rsquo;在模版中或
<code>asm_fprintf</code>的操作数中不具有任何特殊含义。

      <p>如果你能够通过定义宏<code>REGISTER_PREFIX</code>, <code>LOCAL_LABEL_PREFIX</code>,
<code>USER_LABEL_PREFIX</code>和<code>IMMEDIATE_PREFIX</code>来表达出汇编语言语法的
不同之处，则定义这些宏。如果语法差异比较大，涉及到操作码不同或操作数顺序，
则定义<code>ASSEMBLER_DIALECT</code>，使用&lsquo;<samp><span class="samp">option0|option1</span></samp>&rsquo;语法。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_REG_PUSH</b> (<var>stream, regno</var>)<var><a name="index-ASM_005fOUTPUT_005fREG_005fPUSH-4462"></a></var><br>
<blockquote><p>C表达式，向<var>stream</var>中输出汇编代码，用于将硬件寄存器编号<var>regno</var>压入栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_REG_POP</b> (<var>stream, regno</var>)<var><a name="index-ASM_005fOUTPUT_005fREG_005fPOP-4463"></a></var><br>
<blockquote><p>C表达式，向<var>stream</var>中输出汇编代码，用于将硬件寄存器编号<var>regno</var>弹出栈中。
代码不需要为最优的，因为该宏只在profiling的时候使用。
</p></blockquote></div>

 </body></html>

