<html lang="zh">
<head>
<title>比较运算 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097" title="算术运算">
<link rel="next" href="_00e4_00bd_008d_00e5_009f_009f_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e4_00bd_008d_00e5_009f_009f_00e8_00bf_0090_00e7_00ae_0097" title="位域运算">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%af%94%e8%be%83%e8%bf%90%e7%ae%97"></a>
<a name="g_t_00e6_00af_0094_00e8_00be_0083_00e8_00bf_0090_00e7_00ae_0097"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e4_00bd_008d_00e5_009f_009f_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e4_00bd_008d_00e5_009f_009f_00e8_00bf_0090_00e7_00ae_0097">位域运算</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097">算术运算</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.10 比较运算</h3>

<p><a name="index-RTL-comparison-operations-2496"></a>
Comparison operators test a relation on two operands and are considered
to represent a machine-dependent nonzero value described by, but not
necessarily equal to, <code>STORE_FLAG_VALUE</code> (see <a href="Misc.html#Misc">Misc</a>)
if the relation holds, or zero if it does not, for comparison operators
whose results have a `MODE_INT' mode,
<code>FLOAT_STORE_FLAG_VALUE</code> (see <a href="Misc.html#Misc">Misc</a>) if the relation holds, or
zero if it does not, for comparison operators that return floating-point
values, and a vector of either <code>VECTOR_STORE_FLAG_VALUE</code> (see <a href="Misc.html#Misc">Misc</a>)
if the relation holds, or of zeros if it does not, for comparison operators
that return vector results. 
The mode of the comparison operation is independent of the mode
of the data being compared.  If the comparison operation is being tested
(e.g., the first operand of an <code>if_then_else</code>), the mode must be
<code>VOIDmode</code>.

 <p><a name="index-condition-codes-2497"></a>There are two ways that comparison operations may be used.  The
comparison operators may be used to compare the condition codes
<code>(cc0)</code> against zero, as in <code>(eq (cc0) (const_int 0))</code>.  Such
a construct actually refers to the result of the preceding instruction
in which the condition codes were set.  The instruction setting the
condition code must be adjacent to the instruction using the condition
code; only <code>note</code> insns may separate them.

 <p>Alternatively, a comparison operation may directly compare two data
objects.  The mode of the comparison is determined by the operands; they
must both be valid for a common machine mode.  A comparison with both
operands constant would be invalid as the machine mode could not be
deduced from it, but such a comparison should never exist in RTL due to
constant folding.

 <p>In the example above, if <code>(cc0)</code> were last set to
<code>(compare </code><var>x</var> <var>y</var><code>)</code>, the comparison operation is
identical to <code>(eq </code><var>x</var> <var>y</var><code>)</code>.  Usually only one style
of comparisons is supported on a particular machine, but the combine
pass will try to merge the operations to produce the <code>eq</code> shown
in case it exists in the context of the particular insn involved.

 <p>Inequality comparisons come in two flavors, signed and unsigned.  Thus,
there are distinct expression codes <code>gt</code> and <code>gtu</code> for signed and
unsigned greater-than.  These can produce different results for the same
pair of integer values: for example, 1 is signed greater-than &minus;1 but not
unsigned greater-than, because &minus;1 when regarded as unsigned is actually
<code>0xffffffff</code> which is greater than 1.

 <p>The signed comparisons are also used for floating point values.  Floating
point comparisons are distinguished by the machine modes of the operands.

     
<a name="index-eq-2498"></a>
<a name="index-equal-2499"></a>
<dl><dt><code>(eq:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><code>STORE_FLAG_VALUE</code> if the values represented by <var>x</var> and <var>y</var>
are equal, otherwise 0.

     <p><a name="index-ne-2500"></a><a name="index-not-equal-2501"></a><br><dt><code>(ne:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><code>STORE_FLAG_VALUE</code> if the values represented by <var>x</var> and <var>y</var>
are not equal, otherwise 0.

     <p><a name="index-gt-2502"></a><a name="index-greater-than-2503"></a><br><dt><code>(gt:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><code>STORE_FLAG_VALUE</code> if the <var>x</var> is greater than <var>y</var>.  If they
are fixed-point, the comparison is done in a signed sense.

     <p><a name="index-gtu-2504"></a><a name="index-greater-than-2505"></a><a name="index-unsigned-greater-than-2506"></a><br><dt><code>(gtu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>Like <code>gt</code> but does unsigned comparison, on fixed-point numbers only.

     <p><a name="index-lt-2507"></a><a name="index-less-than-2508"></a><a name="index-ltu-2509"></a><a name="index-unsigned-less-than-2510"></a><br><dt><code>(lt:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ltu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>Like <code>gt</code> and <code>gtu</code> but test for &ldquo;less than&rdquo;.

     <p><a name="index-ge-2511"></a><a name="index-greater-than-2512"></a><a name="index-geu-2513"></a><a name="index-unsigned-greater-than-2514"></a><br><dt><code>(ge:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(geu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>Like <code>gt</code> and <code>gtu</code> but test for &ldquo;greater than or equal&rdquo;.

     <p><a name="index-le-2515"></a><a name="index-less-than-or-equal-2516"></a><a name="index-leu-2517"></a><a name="index-unsigned-less-than-2518"></a><br><dt><code>(le:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(leu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd>Like <code>gt</code> and <code>gtu</code> but test for &ldquo;less than or equal&rdquo;.

     <p><a name="index-if_005fthen_005felse-2519"></a><br><dt><code>(if_then_else </code><var>cond</var> <var>then</var> <var>else</var><code>)</code><dd>This is not a comparison operation but is listed here because it is
always used in conjunction with a comparison operation.  To be
precise, <var>cond</var> is a comparison expression.  This expression
represents a choice, according to <var>cond</var>, between the value
represented by <var>then</var> and the one represented by <var>else</var>.

     <p>On most machines, <code>if_then_else</code> expressions are valid only
to express conditional jumps.

     <p><a name="index-cond-2520"></a><br><dt><code>(cond [</code><var>test1</var> <var>value1</var> <var>test2</var> <var>value2</var><code> ...] </code><var>default</var><code>)</code><dd>Similar to <code>if_then_else</code>, but more general.  Each of <var>test1</var>,
<var>test2</var>, <small class="dots">...</small> is performed in turn.  The result of this expression is
the <var>value</var> corresponding to the first nonzero test, or <var>default</var> if
none of the tests are nonzero expressions.

     <p>This is currently not valid for instruction patterns and is supported only
for insn attributes.  See <a href="Insn-Attributes.html#Insn-Attributes">Insn Attributes</a>. 
</dl>

 </body></html>

