<html lang="zh">
<head>
<title>C++ ABI - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="PCH-Target.html#PCH-Target" title="PCH Target">
<link rel="next" href="_00e5_0085_00b6_00e5_00ae_0083.html#g_t_00e5_0085_00b6_00e5_00ae_0083" title="其它">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="C++-ABI"></a>
<a name="C_002b_002b-ABI"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_0085_00b6_00e5_00ae_0083.html#g_t_00e5_0085_00b6_00e5_00ae_0083">其它</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="PCH-Target.html#PCH-Target">PCH Target</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.29 C++ ABI参数</h3>

<p><a name="index-parameters_002c-c_002b_002b-abi-4612"></a>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_CXX_GUARD_TYPE</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fGUARD_005fTYPE-4613"></a></var><br>
<blockquote><p>定义该钩子来覆盖用于guard变量的整数类型。
这些被用于实现静态对象的一次构建。缺省为long_long_integer_type_node。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_GUARD_MASK_BIT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fGUARD_005fMASK_005fBIT-4614"></a></var><br>
<blockquote><p>该钩子确定如何使用guard变量。如果第一个字节应该被使用，
则应该返回<code>false</code>（缺省）。返回值为<code>true</code>表明应该使用最低有效位。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_CXX_GET_COOKIE_SIZE</b> (<var>tree type</var>)<var><a name="index-TARGET_005fCXX_005fGET_005fCOOKIE_005fSIZE-4615"></a></var><br>
<blockquote><p>该钩子返回cookie的大小，其中cookie为当分配一个数组其元素具有<var>type</var>类型，
所使用的cookie。假设已经知道需要一个cookie。
缺省为<code>max(sizeof (size_t), alignof(type))</code>，
在2.7节IA64/Generic C++ ABI中定义。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_COOKIE_HAS_SIZE</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fCOOKIE_005fHAS_005fSIZE-4616"></a></var><br>
<blockquote><p>该钩子应该返回<code>true</code>，如果元素大小应该被存放在数组cookie中。
缺省为返回<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_CXX_IMPORT_EXPORT_CLASS</b> (<var>tree type, int import_export</var>)<var><a name="index-TARGET_005fCXX_005fIMPORT_005fEXPORT_005fCLASS-4617"></a></var><br>
<blockquote><p>如果后端定义了该钩子，则允许覆盖对导出类<var>type</var>的决定。
<var>import_export</var>将包含1，如果类将被导出，&minus;1如果其将被导入，否则为0. 
该函数应该返回修改后的值，并执行其它需要的操作来支持后端的操作系统。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_CDTOR_RETURNS_THIS</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fCDTOR_005fRETURNS_005fTHIS-4618"></a></var><br>
<blockquote><p>该钩子应该返回<code>true</code>，如果构造者和析构者返回创建/销毁对象的地址。
缺省为返回<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_KEY_METHOD_MAY_BE_INLINE</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fKEY_005fMETHOD_005fMAY_005fBE_005fINLINE-4619"></a></var><br>
<blockquote><p>该钩子返回真，如果类的关键方法（即，如果方法在当前转换单元中定义，
其使得虚拟表被输出）可以为内联函数。对于标准的Itanium C++ ABI，
关键方法可以为内联函数，只要函数不在类定义中声明为内联的。
其它ABI的变体中，内联函数不能为关键方法。缺省为返回<code>true</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY</b> (<var>tree decl</var>)<var><a name="index-TARGET_005fCXX_005fDETERMINE_005fCLASS_005fDATA_005fVISIBILITY-4620"></a></var><br>
<blockquote><p><var>decl</var>为虚拟表，类型信息对象，或其它类似的隐含类数据对象，
其将在该转换单元中作为外部链接被输出。ELF的可视性不会被显示的指定。
如果target需要指定可视性，
可以使用该钩子来设置<code>DECL_VISIBILITY</code>和<code>DECL_VISIBILITY_SPECIFIED</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fCLASS_005fDATA_005fALWAYS_005fCOMDAT-4621"></a></var><br>
<blockquote><p>该钩子返回真（缺省情况）如果虚拟表和其它类似的隐式类数据对象总是为COMDAT，
如果它们具有外部连接。如果该钩子返回假，
则只在一个转换单元中被输出的虚拟表的类的类数据将不是COMDAT。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_LIBRARY_RTTI_COMDAT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fLIBRARY_005fRTTI_005fCOMDAT-4622"></a></var><br>
<blockquote><p>该钩子返回真（缺省情况），
如果在C++运行时定义的基本类型的RTTI信息应该总是为COMDAT，否则为假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_USE_AEABI_ATEXIT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fUSE_005fAEABI_005fATEXIT-4623"></a></var><br>
<blockquote><p>该钩子返回真，
如果<code>__aeabi_atexit</code>（如被ARM EABI定义）应该用于注册静态析构者，
当<samp><span class="option">-fuse-cxa-atexit</span></samp>为有效时。缺省是返回假，使用<code>__cxa_atexit</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT</b> (<var>void</var>)<var><a name="index-TARGET_005fCXX_005fUSE_005fATEXIT_005fFOR_005fCXA_005fATEXIT-4624"></a></var><br>
<blockquote><p>该钩子返回真，
如果target的<code>atexit</code>函数可以跟<code>__cxa_atexit</code>一样被用于注册静态析构者。
这要求在共享库中<code>atexit</code>注册的函数要按照正确的顺序运行，当库被卸载时。
缺省为返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_CXX_ADJUST_CLASS_AT_DEFINITION</b> (<var>tree type</var>)<var><a name="index-TARGET_005fCXX_005fADJUST_005fCLASS_005fAT_005fDEFINITION-4625"></a></var><br>
<blockquote><p><var>type</var>为一个刚被定义的C++类（即RECORD_TYPE 或 UNION_TYPE）。
使用该钩子来调整类（例如tweak可视性或者执行其它target需要的修改）。
</p></blockquote></div>

 </body></html>

