<html lang="en">
<head>
<title>define_peephole - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_00aa_00a5_00e5_00ad_0094_00e5_00ae_009a_00e4_00b9_0089.html#g_t_00e7_00aa_00a5_00e5_00ad_0094_00e5_00ae_009a_00e4_00b9_0089" title="窥孔定义">
<link rel="next" href="define_005fpeephole2.html#define_005fpeephole2" title="define_peephole2">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="define_peephole"></a>
<a name="define_005fpeephole"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="define_005fpeephole2.html#define_005fpeephole2">define_peephole2</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_00aa_00a5_00e5_00ad_0094_00e5_00ae_009a_00e4_00b9_0089.html#g_t_00e7_00aa_00a5_00e5_00ad_0094_00e5_00ae_009a_00e4_00b9_0089">窥孔定义</a>
<hr>
</div>

<h4 class="subsection">16.18.1 RTL到文本的窥孔优化器</h4>

<p><a name="index-define_005fpeephole-3562"></a>
定义的形式如下：

<pre class="smallexample">     (define_peephole
       [<var>insn-pattern-1</var>
        <var>insn-pattern-2</var>
        ...]
       "<var>condition</var>"
       "<var>template</var>"
       "<var>optional-insn-attributes</var>")
</pre>
 <p class="noindent">如果没有在该机器描述中使用任何机器特定的信息，
则可以省略掉最后的字符串操作数。
如果有，则其必须遵守在<code>define_insn</code>中相同的规则。

 <p>该结构中，<var>insn-pattern-1</var>等为匹配连续insn的指令模式。
当<var>insn-pattern-1</var>匹配第一个insn，
<var>insn-pattern-2</var>匹配下一个，等等依次类推的情况时，
则会将优化应用到该insn序列。

 <p>每个由窥孔匹配的insn也必须匹配一个<code>define_insn</code>。
窥孔只在代码生成前的最后阶段被检查，并且只是可选的。
因此，在一个未优化的编译中，或者不同的优化阶段中，
任何匹配窥孔但是不匹配<code>define_insn</code>的将会在代码生成时造成崩溃。

 <p>和通常一样，insn的操作数使用<code>match_operands</code>,
<code>match_operator</code>和<code>match_dup</code>来匹配。
不同的是，操作数编号应用在定义的所有insn指令模式中。所以，
你可以通过一个insn中的<code>match_operand</code>和另一个insn中的<code>match_dup</code>，
来在两个insn中检查相同的操作数。

 <p>用于<code>match_operand</code>指令模式的操作数约束对窥孔的适用性没有任何直接的影响，
不过它们将会在后面被验证，所以要确信当窥孔匹配时，你的约束要足够通用。
如果窥孔匹配，但约束却不满足，则编译器将崩溃。

 <p>将窥孔中的所有操作数的约束省略掉是安全的；
或者你可以编写约束作为之前测试过的标准的二次检查。

 <p>一旦insn序列匹配指令模式，则<code>condition</code>将被检查。
这是一个C表达式，用于对是否执行优化来做最后的决定
（如果表达式非0时，我们这样做）。
如果<code>condition</code>被省略掉（换句话说，字符串为空）
则优化会被应用到每个匹配指令模式的insn序列。

 <p>定义的窥孔优化在寄存器分配完成之后应用。
因此，窥孔定义可以只是查看操作数，便能检查哪些操作数结束于哪种寄存器。

 <p><a name="index-prev_005factive_005finsn-3563"></a>在条件中引用操作数的方式为对操作数编号<var>i</var>编写<code>operands[</code><var>i</var><code>]</code>
（匹配于<code>(match_operand </code><var>i</var><code> ...)</code>）。
使用变量<code>insn</code>来引用正在被匹配的insns的最后一个insn；
使用<code>prev_active_insn</code>来找到先前的insns。

 <p><a name="index-dead_005for_005fset_005fp-3564"></a>当正在优化中间结果计算时，
你可以使用条件来匹配只有当中间结果不在其它地方被使用的情况。
使用C表达式<code>dead_or_set_p (</code><var>insn</var><code>, </code><var>op</var><code>)</code>，
其中<var>insn</var>为你所期望其值为最后一次被使用的insn，
以及<var>op</var>为中间值（来自<code>operands[</code><var>i</var><code>]</code>）。

 <p>应用优化，意味着将insn序列替换为新的insn。
<var>template</var>控制了针对该组合insn的最终汇编代码输出。
就像<code>define_insn</code>模板所做的一样。
该模板中的操作数编号与用于要匹配的原始insn序列中的相同。

 <p>被定义的窥孔优化器的结果不需要匹配机器描述中的任何insn模式；
它甚至没有机会来匹配它们。窥孔优化器定义本身是作为insn模式，
用来控制insn如何输出。

 <p>被定义的窥孔优化器被作为汇编代码运行输出，
所以它们产生的insns不再被组合或重排。

 <p>这里有一个例子，来自68000机器描述：

<pre class="smallexample">     (define_peephole
       [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
        (set (match_operand:DF 0 "register_operand" "=f")
             (match_operand:DF 1 "register_operand" "ad"))]
       "FP_REG_P (operands[0]) &amp;&amp; ! FP_REG_P (operands[1])"
     {
       rtx xoperands[2];
       xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);
     #ifdef MOTOROLA
       output_asm_insn ("move.l %1,(sp)", xoperands);
       output_asm_insn ("move.l %1,-(sp)", operands);
       return "fmove.d (sp)+,%0";
     #else
       output_asm_insn ("movel %1,sp@", xoperands);
       output_asm_insn ("movel %1,sp@-", operands);
       return "fmoved sp@+,%0";
     #endif
     })
</pre>
 <p>该优化的效果是将

<pre class="smallexample">     jbsr _foobar
     addql #4,sp
     movel d1,sp@-
     movel d0,sp@-
     fmoved sp@+,fp0
</pre>
 <p class="noindent">转换为

<pre class="smallexample">     jbsr _foobar
     movel d1,sp@
     movel d0,sp@-
     fmoved sp@+,fp0
</pre>
 <p><var>insn-pattern-1</var>等看起来与<code>define_insn</code>的第二个操作数非常相似。
不过有一个重要的不同：<code>define_insn</code>的第二个操作数包含了一个或多个RTX，
使用方括号包裹。通常，只有一个：
那么相同的动作则可以写成<code>define_peephole</code>的一个元素。
但是，当在<code>define_insn</code>中有多个动作时，它们被隐式的由<code>parallel</code>包裹。
则你必须在<code>define_peephole</code>中，显式的写出<code>parallel</code>，以及里面的方括号。
因此，如果一个insn的指令模式如下，

<pre class="smallexample">     (define_insn "divmodsi4"
       [(set (match_operand:SI 0 "general_operand" "=d")
             (div:SI (match_operand:SI 1 "general_operand" "0")
                     (match_operand:SI 2 "general_operand" "dmsK")))
        (set (match_operand:SI 3 "general_operand" "=d")
             (mod:SI (match_dup 1) (match_dup 2)))]
       "TARGET_68020"
       "divsl%.l %2,%3:%0")
</pre>
 <p class="noindent">则在窥孔中提及该insn的方法为：

<pre class="smallexample">     (define_peephole
       [...
        (parallel
         [(set (match_operand:SI 0 "general_operand" "=d")
               (div:SI (match_operand:SI 1 "general_operand" "0")
                       (match_operand:SI 2 "general_operand" "dmsK")))
          (set (match_operand:SI 3 "general_operand" "=d")
               (mod:SI (match_dup 1) (match_dup 2)))])
        ...]
       ...)
</pre>
 </body></html>

