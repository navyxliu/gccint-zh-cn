<html lang="zh">
<head>
<title>别名分析 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tree-SSA.html#Tree-SSA" title="Tree SSA">
<link rel="prev" href="SSA.html#SSA" title="SSA">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%88%ab%e5%90%8d%e5%88%86%e6%9e%90"></a>
<a name="g_t_00e5_0088_00ab_00e5_0090_008d_00e5_0088_0086_00e6_009e_0090"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="SSA.html#SSA">SSA</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tree-SSA.html#Tree-SSA">Tree SSA</a>
<hr>
</div>

<h3 class="section">13.4 别名分析</h3>

<p><a name="index-alias-3068"></a><a name="index-flow_002dsensitive-alias-analysis-3069"></a><a name="index-flow_002dinsensitive-alias-analysis-3070"></a>
别名分析经历4个主要阶段：

     <ol type=1 start=1>
<li>结构体的别名分析。

     <p>该过程遍历结构体类型的变量，并确定哪些域可以使用域的偏移量和大小来重叠。
对于每个域，一个称作“结构体域标签”（SFT）的“子变量”被创建，
其使用独立的变量来表示那个域。对于给定域，
所有可能会重叠的访问将具有那个域的SFT的虚操作数。

     <pre class="smallexample">          struct foo
          {
            int a;
            int b;
          }
          struct foo temp;
          int bar (void)
          {
            int tmp1, tmp2, tmp3;
            SFT.0_2 = VDEF &lt;SFT.0_1&gt;
            temp.a = 5;
            SFT.1_4 = VDEF &lt;SFT.1_3&gt;
            temp.b = 6;
          
            VUSE &lt;SFT.1_4&gt;
            tmp1_5 = temp.b;
            VUSE &lt;SFT.0_2&gt;
            tmp2_6 = temp.a;
          
            tmp3_7 = tmp1_5 + tmp2_6;
            return tmp3_7;
          }
</pre>
     <p>如果你出于某种原因为一个变量复制符合标签，则有可能还要复制它的子变量。

     <li>Points-to和escape分析

     <p>该过程遍历SSA web中的use-def链，查看三件事情：

          <ul>
<li><code>P_i = &amp;VAR</code>形式的赋值
<li><code>P_i = malloc()</code>形式的赋值
<li>逃逸当前函数的指针和ADDR_EXPR
</ul>

     <p>逃逸的概念跟Java世界中使用的相同。当一个指针或者一个ADDR_EXPR逃逸，
指的是它已经被暴露在当前函数之外。所以，全局变量的赋值，函数参数，
以及返回指针都是逃逸的地点。

     <p>这是我们目前所限制的。因为并不是所有都被重命名到SSA，例如，
当指针被隐藏在一个结构体的域中的时候，我们就丢失了逃逸属性。
在那些情况下，我们假设指针是逃逸的。

     <p>我们使用逃逸分析来确定是否变量为call-clobbered。简单的说，
如果一个ADDR_EXPR逃逸，则变量是call-clobbered。如果一个指针P_i逃逸，
则所有P_i指向的变量（以及它的内存标签）也逃逸。

     <li>计算流敏感别名

     <p>我们有两类内存标签。内存标签与程序中的指针所指向的数据类型相关。
这些标签称为“符号内存标签”（SMT）。另一类是那些与SSA_NAME相关的，
称作“名字内存标签”（NMT）。基本的想法是，当为一个INDIRECT_REF *P_i增加操作数时，
我们将先检查P_i是否具有名字标签，如果有的话我们就使用，
因为那将具有更加精确的别名信息。否则，我们使用标准的符号标签。

     <p>在这一阶段，我们遍历在points-to分析中发现的所有指针，
并为与每个指针P_i关联的名字内存标签创建别名集。如果P_i逃逸，
我们标记它指向的变量和它的标签为call-clobbered。

     <li>计算流不敏感别名

     <p>该过程将比较每个符号内存标签的别名集与程序中发现的每个可寻址的变量。
给定一个符号内存标签SMT和一个可寻址变量V。
如果SMT的别名集和V冲突（通过may_alias_p来计算获得），
则V被标记为一个别名标签并被增加到SMT的别名集中。

     <p>每个希望执行语言相关的别名分析的语言应该定义一个函数，给定一个<code>tree</code>结点，
能够计算结点的别名集。在不同别名集中的节点不允许进行别名。例如，
参见C语言前端函数<code>c_get_alias_set</code>。
      </ol>

 <p>例如，考虑下面的函数：

<pre class="smallexample">     foo (int i)
     {
       int *p, *q, a, b;
     
       if (i &gt; 10)
         p = &amp;a;
       else
         q = &amp;b;
     
       *p = 3;
       *q = 5;
       a = b + 2;
       return *p;
     }
</pre>
 <p>在别名分析完成之后，指针<code>p</code>的符号内存标签将具有两个别名，
变量<code>a</code>和<code>b</code>。当每次指针<code>p</code>被dereference时，
我们想要标记操作为一个对<code>a</code>和<code>b</code>的潜在的引用。

<pre class="smallexample">     foo (int i)
     {
       int *p, a, b;
     
       if (i_2 &gt; 10)
         p_4 = &amp;a;
       else
         p_6 = &amp;b;
       # p_1 = PHI &lt;p_4(1), p_6(2)&gt;;
     
       # a_7 = VDEF &lt;a_3&gt;;
       # b_8 = VDEF &lt;b_5&gt;;
       *p_1 = 3;
     
       # a_9 = VDEF &lt;a_7&gt;
       # VUSE &lt;b_8&gt;
       a_9 = b_8 + 2;
     
       # VUSE &lt;a_9&gt;;
       # VUSE &lt;b_8&gt;;
       return *p_1;
     }
</pre>
 <p>在一些情况下，一个指针的可能别名列表可能会变得很大。
这会造成代码中插入的虚操作数的数目的膨胀，使得内存消耗和编译时间增大。

 <p>当表示别名加载和存储所需要的虚操作数数目增长的太大的时候
（可以使用<samp><span class="option">--param max-aliased-vops</span></samp>来配置），
别名集被分组以避免严重的编译时间下降和内存消耗。别名分组的heuristic如下：

     <ol type=1 start=1>
<li>将指针列表按照分配的虚操作数数目进行递减排序。

     <li>从列表中取出第一个指针并反转内存标签和别名的脚色。通常，
不管什么时候被别名的变量Vi被发现与内存标签T别名，
我们都将Vi增加到T的可能别名集中。这意味着，别名分析之后，我们将得到：

     <pre class="smallexample">          may-aliases(T) = { V1, V2, V3, ..., Vn }
</pre>
     <p>这意味着每条引用T的语句，将得到Vi标签的<code>n</code>个虚拟操作数。但是，
当启用了别名分组时，我们将T标记为别名标签并将其增加到所有Vi变量的别名集中：

     <pre class="smallexample">          may-aliases(V1) = { T }
          may-aliases(V2) = { T }
          ...
          may-aliases(Vn) = { T }
</pre>
     <p>这有两个效果：(a)引用T的语句将只得到一个单独的虚拟操作数，
(b)所有变量Vi现在将显示为相互别名。所以，
我们为了提高编译时间而失去了别名精确性。但是，理论上，
像这样使用高层次的别名的程序，应该不是把优化放在第一位。

     <li>由于变量可以在多个内存标签的别名集中，所以在步骤(2)中所作的分组工作需要被扩展
为针对所有与标签T的可能别名集具有非空交集的内存标签。例如，
如果我们最初具有这些可能别名集：

     <pre class="smallexample">          may-aliases(T) = { V1, V2, V3 }
          may-aliases(R) = { V2, V4 }
</pre>
     <p>在步骤(2)中，我们将会反转T的别名为：

     <pre class="smallexample">          may-aliases(V1) = { T }
          may-aliases(V2) = { T }
          may-aliases(V3) = { T }
</pre>
     <p>但是注意现在V2不再与R别名了。我们本应该将R增加到may-aliases(V2)中，
但是我们是在处理别名分组以减少虚拟操作数，所以我们所要做的是将V4增加到分组中，
以获得：

     <pre class="smallexample">          may-aliases(V1) = { T }
          may-aliases(V2) = { T }
          may-aliases(V3) = { T }
          may-aliases(V4) = { T }
</pre>
     <li>如果由于别名产生的虚拟操作数总数依然超出max-alias-vops设置的门槛，
则回到步骤(2)。
      </ol>

<!-- Copyright (c) 2006, 2007, 2008 Free Software Foundation, Inc. -->
<!-- Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gcc.texi. -->
<!--  -->
<!-- Loop Representation -->
<!--  -->
 </body></html>

