<html lang="zh">
<head>
<title>Varargs - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link rel="next" href="Trampolines.html#Trampolines" title="Trampolines">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Varargs"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Trampolines.html#Trampolines">Trampolines</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.11 实现Varargs宏</h3>

<p><a name="index-varargs-implementation-4123"></a>
GCC自带了<code>&lt;varargs.h&gt;</code>和<code>&lt;stdarg.h&gt;</code>的实现，
可直接用于在栈上传递参数的机器上。其它机器需要它们自己的varargs实现，
并且两个机器独立的头文件必须条件包含它。

 <p>ISO <code>&lt;stdarg.h&gt;</code>与传统<code>&lt;varargs.h&gt;</code>的区别主要在<code>va_start</code>的调用
约定上。传统的实现只接受一个参数，其为存储参数指针的变量。
ISO的实现接受额外的第二个参数。用户应该将函数的最后一个命名参数写在这里。

 <p>然而，<code>va_start</code>不应该使用这个参数。
发现命名参数结尾的方法为使用下面描述的内建函数。

<div class="defun">
&mdash; Macro: <b>__builtin_saveregs</b> ()<var><a name="index-g_t_005f_005fbuiltin_005fsaveregs-4124"></a></var><br>
<blockquote><p>使用该内建函数来将参数寄存器保存在内存中，使得varargs机制可以访问它们。
<code>va_start</code>的ISO版本和传统版本都必须使用<code>__builtin_saveregs</code>，
除非你使用<code>TARGET_SETUP_INCOMING_VARARGS</code>来替代（参见下面）。

      <p>在一些机器上，<code>__builtin_saveregs</code>为开放编码的，
在target钩子<code>TARGET_EXPAND_BUILTIN_SAVEREGS</code>的控制下。
在其它机器上，其调用了汇编语言写的例程，可以在<samp><span class="file">libgcc2.c</span></samp>中找到。

      <p>不管怎样，调用<code>__builtin_saveregs</code>的生成代码都出现在函数的起始处。
这是因为寄存器必须在函数开始使用它们前被保存。
<!-- i rewrote the first sentence above to fix an overfull hbox. -mew -->
<!-- 10feb93 -->
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>__builtin_args_info</b> (<var>category</var>)<var><a name="index-g_t_005f_005fbuiltin_005fargs_005finfo-4125"></a></var><br>
<blockquote><p>使用该内建函数来找到寄存器中第一个匿名参数。

      <p>通常，机器可以具有多个用于参数的寄存器类别，每一个用于特定的数据类型。
（例如，在一些机器上，浮点寄存器用于浮点参数，而其它参数在通用寄存器中传递。）
要使非varargs函数使用合适的调用约定，你已经定义了<code>CUMULATIVE_ARGS</code>数据类型
来记录在每个类别中有多少寄存器已被使用。

      <p><code>__builtin_args_info</code>在普通参数布局完成之后，
访问同一数据结构体<code>CUMULATIVE_ARGS</code>，使用<var>category</var>来指定访问哪个字。
因此，其值指示了在给定category中的第一个未使用的寄存器。

      <p>通常，你会在<code>va_start</code>的实现中使用<code>__builtin_args_info</code>，
访问每个类一次，并将值存储到<code>va_list</code>对象中。
这是因为<code>va_list</code>将必须更新值，
因此无法修改通过<code>__builtin_args_info</code>访问的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>__builtin_next_arg</b> (<var>lastarg</var>)<var><a name="index-g_t_005f_005fbuiltin_005fnext_005farg-4126"></a></var><br>
<blockquote><p>这与<code>__builtin_args_info</code>等价，用于栈参数。其返回第一个匿名栈参数的地址，
类型为<code>void *</code>。如果<code>ARGS_GROW_DOWNWARD</code>，
其返回第一个匿名栈参数的上面的位置地址。在<code>va_start</code>中使用它来初始化指针，
来从栈中获得参数。同样，在<code>va_start</code>中使用它来验证第二个参数<var>lastarg</var>
为当前函数的最后一个命名参数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>__builtin_classify_type</b> (<var>object</var>)<var><a name="index-g_t_005f_005fbuiltin_005fclassify_005ftype-4127"></a></var><br>
<blockquote><p>由于每个机器具有它自己的约定，对于哪些数据类型在哪种寄存器中传递，
因此你的<code>va_arg</code>实现必须包含这些约定。
将指定数据类型归类的最简单方法是使用<code>__builtin_classify_type</code>，
加上<code>sizeof</code>和<code>__alignof__</code>。

      <p><code>__builtin_classify_type</code>忽略<var>object</var>的值，只考虑它的数据类型。
其返回一个整数来描述什么类型为，整型，浮点，指针，结构体等。

      <p>文件<samp><span class="file">typeclass.h</span></samp>定义了一个枚举，
你可以用来解析<code>__builtin_classify_type</code>的值。
</p></blockquote></div>

 <p>这些机器描述宏用来帮助实现varargs：

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_EXPAND_BUILTIN_SAVEREGS</b> (<var>void</var>)<var><a name="index-TARGET_005fEXPAND_005fBUILTIN_005fSAVEREGS-4128"></a></var><br>
<blockquote><p>如果定义，该钩子产生机器特定代码，用于调用<code>__builtin_saveregs</code>。
该代码将被移动到函数的最开始处，在访问任何参数之前。
该函数的返回值应该为一个RTX，其包含了<code>__builtin_saveregs</code>的返回值。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SETUP_INCOMING_VARARGS</b> (<var>CUMULATIVE_ARGS *args_so_far, enum machine_mode mode, tree type, int *pretend_args_size, int second_time</var>)<var><a name="index-TARGET_005fSETUP_005fINCOMING_005fVARARGS-4129"></a></var><br>
<blockquote><p>该target钩子提供了使用<code>__builtin_saveregs</code>和定义
<code>TARGET_EXPAND_BUILTIN_SAVEREGS</code>钩子的替代。
使用它来将匿名寄存器参数存储到栈中，使得所有参数都像是通过栈连续的传递。
当这样做时，你可以使用varargs的标准实现，其用于将所有参数在栈上传递的机器上。

      <p>参数<var>args_so_far</var>指向<code>CUMULATIVE_ARGS</code>数据结构体，
包含了处理完命名参数之后所获得的值。
参数<var>mode</var>和<var>type</var>描述了最后一个命名参数的机器模式和作为树结点的数据类型。

      <p>该target钩子应该做两件事：第一，将所有不用于命名参数的参数寄存器压入栈中，
第二，存储数据的大小，把<var>pretend_args_size</var>指向的<code>int</code>值得变量压入。
这里你存储的值将作为额外的偏移量，用来建立栈帧。

      <p>因为你必须生成代码来将匿名参数在编译时压入，而不需要知道它们的数据类型，
所以<code>TARGET_SETUP_INCOMING_VARARGS</code>只在只有一种参数寄存器类别并用于所有
数据类型的机器上有用。

      <p>如果参数<var>second_time</var>非0，其以为着函数的参数被第二次分析。
这发生于内联函数，其直到源文件结尾才被实际编译。对于这种情况，
钩子<code>TARGET_SETUP_INCOMING_VARARGS</code>不应该产生任何指令。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_STRICT_ARGUMENT_NAMING</b> (<var>CUMULATIVE_ARGS *ca</var>)<var><a name="index-TARGET_005fSTRICT_005fARGUMENT_005fNAMING-4130"></a></var><br>
<blockquote><p>定义该钩子来返回<code>true</code>，如果函数参数传递的位置依赖于其是否为一个命名参数。

      <p>该钩子控制对于varargs和stdarg函数，如何设置FUNCTION_ARG的<var>named</var>参数。
如果该钩子返回<code>true</code>，则<var>named</var>参数总是为命名参数，未命名参数总是未假。
如果返回<code>false</code>，但是<code>TARGET_PRETEND_OUTGOING_VARARGS_NAMED</code>返回
<code>true</code>，则所有参数都被作为命名的对待。否则所有命名参数，除了最后一个，
被作为命名的对待。

      <p>如果其总是返回0，则不需要定义该钩子。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_PRETEND_OUTGOING_VARARGS_NAMED</b><var><a name="index-TARGET_005fPRETEND_005fOUTGOING_005fVARARGS_005fNAMED-4131"></a></var><br>
<blockquote><p>如果你需要条件的改变ABI，使得一种工作于<code>TARGET_SETUP_INCOMING_VARARGS</code>，
另一种工作于<code>TARGET_SETUP_INCOMING_VARARGS</code>和
<code>TARGET_STRICT_ARGUMENT_NAMING</code>都没有被定义，则定义该钩子返回<code>true</code>，
如果使用<code>TARGET_SETUP_INCOMING_VARARGS</code>，否则返回<code>false</code>。
否则，你不需要定义该钩子。
</p></blockquote></div>

 </body></html>

