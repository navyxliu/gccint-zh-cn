<html lang="zh">
<head>
<title>数据输出 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f.html#g_t_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f" title="汇编格式">
<link rel="prev" href="_00e6_0096_0087_00e4_00bb_00b6_00e6_00a1_0086_00e6_009e_00b6.html#g_t_00e6_0096_0087_00e4_00bb_00b6_00e6_00a1_0086_00e6_009e_00b6" title="文件框架">
<link rel="next" href="_00e6_009c_00aa_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae.html#g_t_00e6_009c_00aa_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae" title="未初始化的数据">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%95%b0%e6%8d%ae%e8%be%93%e5%87%ba"></a>
<a name="g_t_00e6_0095_00b0_00e6_008d_00ae_00e8_00be_0093_00e5_0087_00ba"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_009c_00aa_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae.html#g_t_00e6_009c_00aa_00e5_0088_009d_00e5_00a7_008b_00e5_008c_0096_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae">未初始化的数据</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_0096_0087_00e4_00bb_00b6_00e6_00a1_0086_00e6_009e_00b6.html#g_t_00e6_0096_0087_00e4_00bb_00b6_00e6_00a1_0086_00e6_009e_00b6">文件框架</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f.html#g_t_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f">汇编格式</a>
<hr>
</div>

<h4 class="subsection">17.21.2 数据的输出</h4>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_ASM_BYTE_OP</b><var><a name="index-TARGET_005fASM_005fBYTE_005fOP-4341"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_ALIGNED_HI_OP</b><var><a name="index-TARGET_005fASM_005fALIGNED_005fHI_005fOP-4342"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_ALIGNED_SI_OP</b><var><a name="index-TARGET_005fASM_005fALIGNED_005fSI_005fOP-4343"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_ALIGNED_DI_OP</b><var><a name="index-TARGET_005fASM_005fALIGNED_005fDI_005fOP-4344"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_ALIGNED_TI_OP</b><var><a name="index-TARGET_005fASM_005fALIGNED_005fTI_005fOP-4345"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_UNALIGNED_HI_OP</b><var><a name="index-TARGET_005fASM_005fUNALIGNED_005fHI_005fOP-4346"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_UNALIGNED_SI_OP</b><var><a name="index-TARGET_005fASM_005fUNALIGNED_005fSI_005fOP-4347"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_UNALIGNED_DI_OP</b><var><a name="index-TARGET_005fASM_005fUNALIGNED_005fDI_005fOP-4348"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_UNALIGNED_TI_OP</b><var><a name="index-TARGET_005fASM_005fUNALIGNED_005fTI_005fOP-4349"></a></var><br>
<blockquote><p>这些钩子指定了用于创建特定类型的整数对象的汇编伪指令。
<code>TARGET_ASM_BYTE_OP</code>伪指令创建一个字节大小的对象，
<code>TARGET_ASM_ALIGNED_HI_OP</code>创建一个两个字节对齐的对象，等等。
这些钩子都可以为<code>NULL</code>，这表示没有合适的伪指令。

      <p>编译器将在一个新行中的起始处打印这些字符串，随后紧跟对象的初始化值。
大多数情况下，字符串应该包含一个tab，一个伪操作符，然后是另一个tab。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ASM_INTEGER</b> (<var>rtx x, unsigned int size, int aligned_p</var>)<var><a name="index-TARGET_005fASM_005fINTEGER-4350"></a></var><br>
<blockquote><p>函数<code>assemble_integer</code>使用该钩子来输出一个整数对象。<var>x</var>为对象的值，
<var>size</var>为它的以字节为单位的大小，<var>aligned_p</var>指示其是否为对齐的。
函数应该返回真，如果它能够输出对象。如果返回假，
则<code>assemble_integer</code>将尝试把对象分割为更小的部分。

      <p>该钩子的缺省实现将使用<code>TARGET_ASM_BYTE_OP</code>字符串家族，
当相应字符串为<code>NULL</code>时返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>OUTPUT_ADDR_CONST_EXTRA</b> (<var>stream, x, fail</var>)<var><a name="index-OUTPUT_005fADDR_005fCONST_005fEXTRA-4351"></a></var><br>
<blockquote><p>一条C语句用来识别<code>output_addr_const</code>不能处理的<var>rtx</var>模式，
并输出汇编代码到模式<var>x</var>对应的<var>stream</var>中。
这可以用来允许在常量中出现机器相关的<code>UNSPEC</code>。

      <p>如果<code>OUTPUT_ADDR_CONST_EXTRA</code>没有能够识别出指令模式，
其必须<code>goto fail</code>， 这样就会打印出一个标准错误消息。
如果其本身打印了一个错误消息，
例如通过调用<code>output_operand_lossage</code>，其可以正常的结束。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_ASCII</b> (<var>stream, ptr, len</var>)<var><a name="index-ASM_005fOUTPUT_005fASCII-4352"></a></var><br>
<blockquote><p>一条C语句，用来输出到stdio流<var>stream</var>中一条汇编指令，
以组合一个在<var>ptr</var>处包含<var>len</var>个字节的字符串常量。
<var>ptr</var>将为一个<code>char *</code>类型的C表达式，
<var>len</var>为一个<code>int</code>型的C表达式。

      <p>如果汇编器具有一个<code>.ascii</code>伪指令，正如在Berkeley Unix汇编器上的，
则不要定义宏<code>ASM_OUTPUT_ASCII</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_FDESC</b> (<var>stream, decl, n</var>)<var><a name="index-ASM_005fOUTPUT_005fFDESC-4353"></a></var><br>
<blockquote><p>一条C语句，用来输出<var>decl</var>的函数描述符的字<var>n</var>。
这必须在定义<code>TARGET_VTABLE_USES_DESCRIPTORS</code>时被定义，否则将不起作用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONSTANT_POOL_BEFORE_FUNCTION</b><var><a name="index-CONSTANT_005fPOOL_005fBEFORE_005fFUNCTION-4354"></a></var><br>
<blockquote><p>你可以定义该宏为一个C表达式。你应该定义表达式具有非零值，
如果GCC应该在输出函数的代码前，输出常量池，或者定义为0，
如果GCC应该在函数后输出常量池。如果你不定义该宏，则通常情况下，
GCC将在函数前输出常量池。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_POOL_PROLOGUE</b> (<var>file, funname, fundecl, size</var>)<var><a name="index-ASM_005fOUTPUT_005fPOOL_005fPROLOGUE-4355"></a></var><br>
<blockquote><p>一条C语句，用来输出汇编命令，以定义函数的常量池的起始。
<var>funname</var>为一个字符串，给定了函数的名字。如果需要函数的返回类型，
则可以通过<var>fundecl</var>来获得。
<var>size</var>为在该调用之后要立即写入的常量池的大小，以字节为单位。

      <p>通常情况下，如果不需要常量池前缀，该宏不需要被定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_SPECIAL_POOL_ENTRY</b> (<var>file, x, mode, align, labelno, jumpto</var>)<var><a name="index-ASM_005fOUTPUT_005fSPECIAL_005fPOOL_005fENTRY-4356"></a></var><br>
<blockquote><p>一条C语句（带有或者不带有分号），用来输出一个常量在常量池中，
如果其需要特殊的处理。（该宏对于可以正常输出的RTL表达式不需要做任何事情。）

      <p>参数<var>file</var>为将汇编代码输出到的标准I/O流。<var>x</var>为要输出的常量的RTL表达式，
<var>mode</var>为机器模式（用于<var>x</var>为&lsquo;<samp><span class="samp">const_int</span></samp>&rsquo;时）。
<var>align</var>为值<var>x</var>所需要的对齐；你应该输出一个汇编伪指令来执行该对齐。

      <p>参数<var>labelno</var>为该池中实体的地址的内部标号的编号。
该宏的定义负责在合适的地方输出标号的定义。这里有一个实现的例子：

     <pre class="smallexample">          <code>(*targetm.asm_out.internal_label)</code> (<var>file</var>, "LC", <var>labelno</var>);
</pre>
      <p>当你专门输出一个池中实体时，你应该结束于一个<code>goto</code>，
以跳转到标号<var>jumpto</var>。这将阻止相同的池中实体通过通常的方式被再一次输出。

      <p>如果不做任何事情，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_OUTPUT_POOL_EPILOGUE</b> (<var>file funname fundecl size</var>)<var><a name="index-ASM_005fOUTPUT_005fPOOL_005fEPILOGUE-4357"></a></var><br>
<blockquote><p>一条C语句，用来输出汇编命令到函数常量池的结尾。<var>funname</var>为一个字符串，
给出了函数的名字。如果需要函数的返回类型，可以通过<var>fundecl</var>来获得。
<var>size</var>为GCC在该调用之前立即写入的常量池的大小，以字节为单位。

      <p>通常情况下，如果不需要常量池结束语，则不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IS_ASM_LOGICAL_LINE_SEPARATOR</b> (<var>C, STR</var>)<var><a name="index-IS_005fASM_005fLOGICAL_005fLINE_005fSEPARATOR-4358"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，其为非零，如果<var>C</var>被汇编器用作逻辑行分隔符。
<var>STR</var>指向在字符串中<var>C</var>被发现的位置；
这可以用于行分隔符使用多个字符的时候。

      <p>如果你不定义该宏，则缺省的为只将字符&lsquo;<samp><span class="samp">;</span></samp>&rsquo;作为逻辑行的分隔符。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_ASM_OPEN_PAREN</b><var><a name="index-TARGET_005fASM_005fOPEN_005fPAREN-4359"></a></var><br>
&mdash; Target Hook: const char * <b>TARGET_ASM_CLOSE_PAREN</b><var><a name="index-TARGET_005fASM_005fCLOSE_005fPAREN-4360"></a></var><br>
<blockquote><p>这些target钩子为C字符串常量，描述了算术表达式组合的汇编语法。
如果没有被覆盖，它们缺省为通常的括号，这对大多数汇编器都是正确的。
</p></blockquote></div>

 <p>这些宏由<samp><span class="file">real.h</span></samp>提供，用于写<code>ASM_OUTPUT_DOUBLE</code>等的定义：

<div class="defun">
&mdash; Macro: <b>REAL_VALUE_TO_TARGET_SINGLE</b> (<var>x, l</var>)<var><a name="index-REAL_005fVALUE_005fTO_005fTARGET_005fSINGLE-4361"></a></var><br>
&mdash; Macro: <b>REAL_VALUE_TO_TARGET_DOUBLE</b> (<var>x, l</var>)<var><a name="index-REAL_005fVALUE_005fTO_005fTARGET_005fDOUBLE-4362"></a></var><br>
&mdash; Macro: <b>REAL_VALUE_TO_TARGET_LONG_DOUBLE</b> (<var>x, l</var>)<var><a name="index-REAL_005fVALUE_005fTO_005fTARGET_005fLONG_005fDOUBLE-4363"></a></var><br>
&mdash; Macro: <b>REAL_VALUE_TO_TARGET_DECIMAL32</b> (<var>x, l</var>)<var><a name="index-REAL_005fVALUE_005fTO_005fTARGET_005fDECIMAL32-4364"></a></var><br>
&mdash; Macro: <b>REAL_VALUE_TO_TARGET_DECIMAL64</b> (<var>x, l</var>)<var><a name="index-REAL_005fVALUE_005fTO_005fTARGET_005fDECIMAL64-4365"></a></var><br>
&mdash; Macro: <b>REAL_VALUE_TO_TARGET_DECIMAL128</b> (<var>x, l</var>)<var><a name="index-REAL_005fVALUE_005fTO_005fTARGET_005fDECIMAL128-4366"></a></var><br>
<blockquote><p>这些将类型为<code>REAL_VALUE_TYPE</code>的<var>x</var>，转换为target的浮点表示，
并将其存储在变量<var>l</var>中。
对于<code>REAL_VALUE_TO_TARGET_SINGLE</code>和<code>REAL_VALUE_TO_TARGET_DECIMAL32</code>，
该变量应该为一个简单的<code>long int</code>。对于其它的，
其应该为一个<code>long int</code>的数组。
该数组的元素个数由所需要的target浮点数据类型的大小决定：
每个<code>long int</code>数组元素有32位。每个数组元素存放32位的结果，
即使<code>long int</code>在host机器上比32位宽。

      <p>数组元素值被设计成，
可以使用<code>fprintf</code>按照在target机器内存中的顺序来打印它们。
</p></blockquote></div>

 </body></html>

