<html lang="zh">
<head>
<title>共享 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8" title="函数调用">
<link rel="next" href="_00e8_00af_00bb_00e5_008f_0096RTL.html#g_t_00e8_00af_00bb_00e5_008f_0096RTL" title="读取RTL">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%85%b1%e4%ba%ab"></a>
<a name="g_t_00e5_0085_00b1_00e4_00ba_00ab"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e8_00af_00bb_00e5_008f_0096RTL.html#g_t_00e8_00af_00bb_00e5_008f_0096RTL">读取RTL</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8">函数调用</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.20 结构共享假设</h3>

<p><a name="index-sharing-of-RTL-components-2651"></a><a name="index-RTL-structure-sharing-assumptions-2652"></a>
编译器假设某些类型的RTL表达式是唯一的；不会存在两个不同的对象表示相同的值。对于其它情况，有相反的假设：在被包含的结构体中，不会在多个地方出现某一类型的RTL表达式对象。

 <p>这些假设针对于一个单独的函数；除了描述全局变量和外部函数的RTL对象，一些标准对象，例如小整形常数以外，没有其它RTL对象可以在两个函数中共用。

     
<a name="index-g_t_0040code_007breg_007d_002c-RTL-sharing-2653"></a>
<ul><li>每一个伪寄存器只有一个单独的<code>reg</code>对象来表示，因此也只有一种机器模式。

     <p><a name="index-symbolic-label-2654"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d_002c-RTL-sharing-2655"></a><li>对于任何标号，只有一个<code>symbol_ref</code>对象关联。

     <p><a name="index-g_t_0040code_007bconst_005fint_007d_002c-RTL-sharing-2656"></a><li>所有具有相同值的<code>const_int</code>表达式被共享。

     <p><a name="index-g_t_0040code_007bpc_007d_002c-RTL-sharing-2657"></a><li>T只有一个<code>pc</code>表达式。

     <p><a name="index-g_t_0040code_007bcc0_007d_002c-RTL-sharing-2658"></a><li>只有一个<code>cc0</code>表达式。

     <p><a name="index-g_t_0040code_007bconst_005fdouble_007d_002c-RTL-sharing-2659"></a><li>对于每一种浮点模式，只有一个<code>const_double</code>表达式其值为0。同样对于值1，2。

     <p><a name="index-g_t_0040code_007bconst_005fvector_007d_002c-RTL-sharing-2660"></a><li>对于每一种向量模式，只有一个<code>const_vector</code>表达式其值为0。其为整数或者双精度常量向量。

     <p><a name="index-g_t_0040code_007blabel_005fref_007d_002c-RTL-sharing-2661"></a><a name="index-g_t_0040code_007bscratch_007d_002c-RTL-sharing-2662"></a><li>在RTL结构体中不会在多个地方出现<code>label_ref</code>或<code>scratch</code>；换句话说，对函数中所有insn进行树遍历时，可以认为每次遇到的<code>label_ref</code>或者<code>scratch</code>都与在其它地方遇到的不同。

     <p><a name="index-g_t_0040code_007bmem_007d_002c-RTL-sharing-2663"></a><li>对于每个静态变量或者栈槽，通常只创建一个<code>mem</code>对象，所以这些对象在它们出现的所有地方被共享。然而，有时会为这些变量创建单独的，但是相等的对象。

     <p><a name="index-g_t_0040code_007basm_005foperands_007d_002c-RTL-sharing-2664"></a><li>当一个单独的<code>asm</code>语句具有多个输出操作数时，会为每一个输出数创建一个不同的<code>asm_operands</code>表达式。然后，这些表达式都共享包含着输入操作数序列的向量。这是为了之后用于测试两个<code>asm_operands</code>表达式是否来自同一语句，所以，所有的优化当进行复制整个向量时，必须仔细保持共享。

     <li>除了上面描述的以外，在RTL结构体中没有其它RTL对象会出现多次。编译器的许多遍扫描，都是依赖于这样的假设，即它们能在一个地方修改RTL对象，并且不会对其它insn产生不需要的副作用。

     <p><a name="index-unshare_005fall_005frtl-2665"></a><li>在最初的RTL生成过程中，可以随意使用共享结构。当一个函数的所有RTL都被生成之后，所有的共享结构体都被<samp><span class="file">emit-rtl.c</span></samp>中的<code>unshare_all_rtl</code>进行复制，之后，将保证上面的规则会被遵循。

     <p><a name="index-copy_005frtx_005fif_005fshared-2666"></a><li>在合并阶段，共享结构体可以在insn中临时存在。但是，在insn的合并完成之前，共享结构会被复制，通过调用<code>unshare_all_rtl</code>的子程序<code>copy_rtx_if_shared</code>。

 </ul>

 </body></html>

