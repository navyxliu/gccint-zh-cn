<html lang="zh">
<head>
<title>存储布局 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="_00e6_00af_008f_00e4_00b8_00aa_00e5_0087_00bd_00e6_0095_00b0_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae.html#g_t_00e6_00af_008f_00e4_00b8_00aa_00e5_0087_00bd_00e6_0095_00b0_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae" title="每个函数的数据">
<link rel="next" href="_00e7_00b1_00bb_00e5_009e_008b_00e5_00b8_0083_00e5_00b1_0080.html#g_t_00e7_00b1_00bb_00e5_009e_008b_00e5_00b8_0083_00e5_00b1_0080" title="类型布局">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%ad%98%e5%82%a8%e5%b8%83%e5%b1%80"></a>
<a name="g_t_00e5_00ad_0098_00e5_0082_00a8_00e5_00b8_0083_00e5_00b1_0080"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e7_00b1_00bb_00e5_009e_008b_00e5_00b8_0083_00e5_00b1_0080.html#g_t_00e7_00b1_00bb_00e5_009e_008b_00e5_00b8_0083_00e5_00b1_0080">类型布局</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_00af_008f_00e4_00b8_00aa_00e5_0087_00bd_00e6_0095_00b0_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae.html#g_t_00e6_00af_008f_00e4_00b8_00aa_00e5_0087_00bd_00e6_0095_00b0_00e7_009a_0084_00e6_0095_00b0_00e6_008d_00ae">每个函数的数据</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.5 存储布局</h3>

<p><a name="index-storage-layout-3753"></a>
注意该表格中的宏定义中，对于以bit为单位的大小或对齐，不需要为常量。
它们可以为引用了静态变量的C表达式，例如<code>target_flags</code>。
参见<a href="_00e8_00bf_0090_00e8_00a1_008c_00e6_0097_00b6_00e7_009b_00ae_00e6_00a0_0087_00e6_009c_00ba.html#g_t_00e8_00bf_0090_00e8_00a1_008c_00e6_0097_00b6_00e7_009b_00ae_00e6_00a0_0087_00e6_009c_00ba">运行时目标机</a>。

<div class="defun">
&mdash; Macro: <b>BITS_BIG_ENDIAN</b><var><a name="index-BITS_005fBIG_005fENDIAN-3754"></a></var><br>
<blockquote><p>定义该宏的值为1，如果字节中的最高有效位具有最低编号；否则定义其值为0。
这意味着bit-field指令从最高有效位计数。如果机器没有bit-field指令，
则该宏也需要被定义，但定义什么值都无所谓。该宏不需要为一个常量。

      <p>该宏不影响结构体域被打包成字节或者字的方式；
那是由<code>BYTES_BIG_ENDIAN</code>来控制的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BYTES_BIG_ENDIAN</b><var><a name="index-BYTES_005fBIG_005fENDIAN-3755"></a></var><br>
<blockquote><p>定义该宏的值为1，如果字中的最高有效字节具有最低编号。该宏不需要为一个常量。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WORDS_BIG_ENDIAN</b><var><a name="index-WORDS_005fBIG_005fENDIAN-3756"></a></var><br>
<blockquote><p>定义该宏的值为1，如果在多字（multiword）对象中，最高有效字具有最低编号。
这同时应用于内存位置和寄存器中；
GCC从根本上假设在内存中的字的顺序与在寄存器中的一样。该宏不需要为一个常量。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_WORDS_BIG_ENDIAN</b><var><a name="index-LIBGCC2_005fWORDS_005fBIG_005fENDIAN-3757"></a></var><br>
<blockquote><p>定义该宏如果<code>WORDS_BIG_ENDIAN</code>不是常量。该宏必须为一个常量值，
其与<code>WORDS_BIG_ENDIAN</code>的具有相同的含义，
并只用于编译<samp><span class="file">libgcc2.c</span></samp>的时候。通常该值会根据预处理器定义来设置。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FLOAT_WORDS_BIG_ENDIAN</b><var><a name="index-FLOAT_005fWORDS_005fBIG_005fENDIAN-3758"></a></var><br>
<blockquote><p>定义该宏值为1，如果<code>DFmode</code>, <code>XFmode</code>或<code>TFmode</code>浮点数被存储在
内存中，并且包含符号位的字位于最低地址；否则值为0。该宏不需要为一个常量。

      <p>你不需要定义该宏，如果顺序与多字整数相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BITS_PER_UNIT</b><var><a name="index-BITS_005fPER_005fUNIT-3759"></a></var><br>
<blockquote><p>定义该宏为一个可寻址的存储单元（字节）中的位数。如果没有定义，缺省为8。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BITS_PER_WORD</b><var><a name="index-BITS_005fPER_005fWORD-3760"></a></var><br>
<blockquote><p>字的位数。如果没有定义，缺省为<code>BITS_PER_UNIT * UNITS_PER_WORD</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_BITS_PER_WORD</b><var><a name="index-MAX_005fBITS_005fPER_005fWORD-3761"></a></var><br>
<blockquote><p>字的最大位数。如果没有定义，缺省为<code>BITS_PER_WORD</code>。
否则其为一个常量，为<code>BITS_PER_WORD</code>在运行时可以具有的最大值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>UNITS_PER_WORD</b><var><a name="index-UNITS_005fPER_005fWORD-3762"></a></var><br>
<blockquote><p>字中的存储单元数；通常为通用目的寄存器的大小，2的1到8次幂。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MIN_UNITS_PER_WORD</b><var><a name="index-MIN_005fUNITS_005fPER_005fWORD-3763"></a></var><br>
<blockquote><p>字中的最小存储单元数。如果没有定义，缺省为<code>UNITS_PER_WORD</code>。否则，
其为一个常量，为<code>UNITS_PER_WORD</code>在运行时可以具有的最小值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>UNITS_PER_SIMD_WORD</b> (<var>mode</var>)<var><a name="index-UNITS_005fPER_005fSIMD_005fWORD-3764"></a></var><br>
<blockquote><p>向量化可以产生的向量的单元数。缺省等于<code>UNITS_PER_WORD</code>，
因为向量化可以在即使没有专门的<acronym>SIMD</acronym>硬件的情况下做一些转换。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>POINTER_SIZE</b><var><a name="index-POINTER_005fSIZE-3765"></a></var><br>
<blockquote><p>指针的宽度，位数。必须指定不比<code>Pmode</code>宽的值。
如果其不等于<code>Pmode</code>的宽度，则必须定义<code>POINTERS_EXTEND_UNSIGNED</code>。
如果没有指定一个值，则缺省为<code>BITS_PER_WORD</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>POINTERS_EXTEND_UNSIGNED</b><var><a name="index-POINTERS_005fEXTEND_005fUNSIGNED-3766"></a></var><br>
<blockquote><p>一个C表达式，用来确定指针应该如何从<code>ptr_mode</code>扩展为<code>Pmode</code>或者
<code>word_mode</code>。如果指针应该被0扩展，则其比0大，如果应该被符号扩展则为0，
如果需要其它转换方式则为负。对于最后一种情况，
扩展通过target的<code>ptr_extend</code>指令来完成。

      <p>你不需要定义该宏，如果<code>ptr_mode</code>, <code>Pmode</code>和<code>word_mode</code>都为相同的宽度。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PROMOTE_MODE</b> (<var>m, unsignedp, type</var>)<var><a name="index-PROMOTE_005fMODE-3767"></a></var><br>
<blockquote><p>用来更新<var>m</var>和<var>unsignedp</var>，当一个类型为<var>type</var>并且具有特定的机器模式
的对象要被存储到寄存器中时。该宏只在<var>type</var>为一个标量类型时才被调用。

      <p>在大多数RISC机器上，只有作用于在整个寄存器上的运算，
定义该宏将<var>m</var>设为为<code>word_mode</code>，
如果<var>m</var>为一个比<code>BITS_PER_WORD</code>窄的整数模式。在大多数情况下，
只有整数模式应该被加宽，因为宽精度的浮点运算通常比相应的窄精度的运算代价要更高。

      <p>大多数机器，宏定义不改变<var>unsignedp</var>。然而，
一些机器具有优先处理特定模式的有符号或者无符号的指令。例如，在DEC Alpha上，
32位load和32位add指令会将结果有符号扩展为64位。在这样的机器上，
根据扩展的类型来设置<var>unsignedp</var>会更加有效。

      <p>如果从来不会修改<var>m</var>，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PROMOTE_FUNCTION_MODE</b><var><a name="index-PROMOTE_005fFUNCTION_005fMODE-3768"></a></var><br>
<blockquote><p>类似于<code>PROMOTE_MODE</code>，但应用于输出的函数参数，或者函数返回值，
分别由<code>TARGET_PROMOTE_FUNCTION_ARGS</code>和<code>TARGET_PROMOTE_FUNCTION_RETURN</code>指定。

      <p>缺省为<code>PROMOTE_MODE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_PROMOTE_FUNCTION_ARGS</b> (<var>tree fntype</var>)<var><a name="index-TARGET_005fPROMOTE_005fFUNCTION_005fARGS-3769"></a></var><br>
<blockquote><p>该target钩子应该返回<code>true</code>，
如果由<code>PROMOTE_FUNCTION_MODE</code>描述的提升应该应用于输出的函数参数。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_PROMOTE_FUNCTION_RETURN</b> (<var>tree fntype</var>)<var><a name="index-TARGET_005fPROMOTE_005fFUNCTION_005fRETURN-3770"></a></var><br>
<blockquote><p>该target钩子应该返回<code>true</code>，
如果由<code>PROMOTE_FUNCTION_MODE</code>描述的提升应该应用于函数返回值。

      <p>如果该target钩子返回<code>true</code>，
则<code>TARGET_FUNCTION_VALUE</code>必须执行与<code>PROMOTE_FUNCTION_MODE</code>相同的提升。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PARM_BOUNDARY</b><var><a name="index-PARM_005fBOUNDARY-3771"></a></var><br>
<blockquote><p>函数参数在栈上的对齐方式，位数。所有栈参数都接受这样的对齐，
而不论数据类型是什么。在大多数机器上，这与整数的大小相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_BOUNDARY</b><var><a name="index-STACK_005fBOUNDARY-3772"></a></var><br>
<blockquote><p>定义该宏为硬件要求的在该机器上的栈指针的最小对齐。定义为一个C表达式，
为所要的对齐（位数）。该值作为缺省值使用，
如果没有定义<code>PREFERRED_STACK_BOUNDARY</code>。在大多数机器上，
这应该与<code>PARM_BOUNDARY</code>相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PREFERRED_STACK_BOUNDARY</b><var><a name="index-PREFERRED_005fSTACK_005fBOUNDARY-3773"></a></var><br>
<blockquote><p>定义该宏，如果你希望对栈指针维持一个特定的对齐，大于硬件要求的对齐。
定义为一个C表达式，为所要的对齐（位数）。
该宏必须等于或大于<code>STACK_BOUNDARY</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INCOMING_STACK_BOUNDARY</b><var><a name="index-INCOMING_005fSTACK_005fBOUNDARY-3774"></a></var><br>
<blockquote><p>Define this macro if the incoming stack boundary may be different
from <code>PREFERRED_STACK_BOUNDARY</code>.  This macro must evaluate
to a value equal to or larger than <code>STACK_BOUNDARY</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_BOUNDARY</b><var><a name="index-FUNCTION_005fBOUNDARY-3775"></a></var><br>
<blockquote><p>函数入口点所需的对齐位数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BIGGEST_ALIGNMENT</b><var><a name="index-BIGGEST_005fALIGNMENT-3776"></a></var><br>
<blockquote><p>该机器上任何数据类型可以需要的最大对齐位数。注意这不是所支持的最大对齐，
而是如果违反该对齐则可能会造成错误。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MALLOC_ABI_ALIGNMENT</b><var><a name="index-MALLOC_005fABI_005fALIGNMENT-3777"></a></var><br>
<blockquote><p>Alignment, in bits, a C conformant malloc implementation has to
provide.  If not defined, the default value is <code>BITS_PER_WORD</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ATTRIBUTE_ALIGNED_VALUE</b><var><a name="index-ATTRIBUTE_005fALIGNED_005fVALUE-3778"></a></var><br>
<blockquote><p>Alignment used by the <code>__attribute__ ((aligned))</code> construct.  If
not defined, the default value is <code>BIGGEST_ALIGNMENT</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MINIMUM_ATOMIC_ALIGNMENT</b><var><a name="index-MINIMUM_005fATOMIC_005fALIGNMENT-3779"></a></var><br>
<blockquote><p>如果被定义，则为最小对齐位数，可以分给一个对象并且在一个操作中被应用，
而不需要干扰任何附近的对象。通常为<code>BITS_PER_UNIT</code>，
但在没有字节或半字的存储运算的机器上可以更大些。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BIGGEST_FIELD_ALIGNMENT</b><var><a name="index-BIGGEST_005fFIELD_005fALIGNMENT-3780"></a></var><br>
<blockquote><p>任何结构体或者联合体域在该机器上需要的最大对齐。如果被定义，
这将只覆盖结构体和联合体的域的<code>BIGGEST_ALIGNMENT</code>，
除非域对齐已经通过<code>__attribute__ ((aligned (</code><var>n</var><code>)))</code>设置。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ADJUST_FIELD_ALIGN</b> (<var>field, computed</var>)<var><a name="index-ADJUST_005fFIELD_005fALIGN-3781"></a></var><br>
<blockquote><p>一个表达式，为结构体域<var>field</var>的对齐方式，如果对齐方式是按照通常方式计算
（包括应用<code>BIGGEST_ALIGNMENT</code>和<code>BIGGEST_FIELD_ALIGNMENT</code>）。
其只覆盖没有通过<code>__attribute__ ((aligned (</code><var>n</var><code>)))</code>设置的域。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_STACK_ALIGNMENT</b><var><a name="index-MAX_005fSTACK_005fALIGNMENT-3782"></a></var><br>
<blockquote><p>Biggest stack alignment guaranteed by the backend.  Use this macro
to specify the maximum alignment of a variable on stack.

      <p>If not defined, the default value is <code>STACK_BOUNDARY</code>.

     <!-- FIXME: The default should be @code{PREFERRED_STACK_BOUNDARY}. -->
     <!-- But the fix for PR 32893 indicates that we can only guarantee -->
     <!-- maximum stack alignment on stack up to @code{STACK_BOUNDARY}, not -->
     <!-- @code{PREFERRED_STACK_BOUNDARY}, if stack alignment isn't supported. -->
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_OFILE_ALIGNMENT</b><var><a name="index-MAX_005fOFILE_005fALIGNMENT-3783"></a></var><br>
<blockquote><p>由该机器的目标文件格式所支持的最大对齐。使用该宏来限制可以使用
<code>__attribute__ ((aligned (</code><var>n</var><code>)))</code>结构来指定的对齐。
如果没有定义，则缺省值为<code>BIGGEST_ALIGNMENT</code>。

      <p>在使用ELF的系统上，缺省（在<samp><span class="file">config/elfos.h</span></samp>中）为在32位host上可以表示的
32位ELF section对齐，即&lsquo;<samp><span class="samp">(((unsigned HOST_WIDEST_INT) 1 &lt;&lt; 28) * 8)</span></samp>&rsquo;。
在32位ELF上，最大支持的section对齐位数是&lsquo;<samp><span class="samp">(0x80000000 * 8)</span></samp>&rsquo;，
但这在32位host上无法表示。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DATA_ALIGNMENT</b> (<var>type, basic-align</var>)<var><a name="index-DATA_005fALIGNMENT-3784"></a></var><br>
<blockquote><p>如果定义，则为一个C表达式，来计算在静态存储中的变量的对齐。
<var>type</var>为数据类型，<var>basic-align</var>为对象通常具有的对齐。
该宏的值被用于替代那个对齐，并应用的对象上。

      <p>如果该宏没有定义，则使用<var>basic-align</var>。

      <p><a name="index-strcpy-3785"></a>该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。
另一种用法是使得字符数组按照字对齐，这样<code>strcpy</code>调用可以通过内联方式完成。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONSTANT_ALIGNMENT</b> (<var>constant, basic-align</var>)<var><a name="index-CONSTANT_005fALIGNMENT-3786"></a></var><br>
<blockquote><p>如果定义，为一个C表达式，来计算放在内存中的常量的对齐。<var>constant</var>为常量，
<var>basic-align</var>为该对象通常具有的对齐。该宏的值被用于替代那个对齐，
并应用的对象上。

      <p>如果该宏没有定义，则使用<var>basic-align</var>。

      <p>该宏的典型用法为增加字符串常量的对齐，使其为字对齐，
这样<code>strcpy</code>调用可以通过内联方式完成。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LOCAL_ALIGNMENT</b> (<var>type, basic-align</var>)<var><a name="index-LOCAL_005fALIGNMENT-3787"></a></var><br>
<blockquote><p>如果定义，为一个C表达式，来计算在局部存储中的对象的对齐。<var>type</var>为数据类型，
<var>basic-align</var>为对象通常的对齐。该宏的值被用于替代那个对齐，并应用的对象上。

      <p>如果该宏没有定义，则使用<var>basic-align</var>。

      <p>该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_SLOT_ALIGNMENT</b> (<var>type, mode, basic-align</var>)<var><a name="index-STACK_005fSLOT_005fALIGNMENT-3788"></a></var><br>
<blockquote><p>If defined, a C expression to compute the alignment for stack slot. 
<var>type</var> is the data type, <var>mode</var> is the widest mode available,
and <var>basic-align</var> is the alignment that the slot would ordinarily
have.  The value of this macro is used instead of that alignment to
align the slot.

      <p>If this macro is not defined, then <var>basic-align</var> is used when
<var>type</var> is <code>NULL</code>.  Otherwise, <code>LOCAL_ALIGNMENT</code> will
be used.

      <p>This macro is to set alignment of stack slot to the maximum alignment
of all possible modes which the slot may have. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LOCAL_DECL_ALIGNMENT</b> (<var>decl</var>)<var><a name="index-LOCAL_005fDECL_005fALIGNMENT-3789"></a></var><br>
<blockquote><p>If defined, a C expression to compute the alignment for a local
variable <var>decl</var>.

      <p>If this macro is not defined, then
<code>LOCAL_ALIGNMENT (TREE_TYPE (</code><var>decl</var><code>), DECL_ALIGN (</code><var>decl</var><code>))</code>
is used.

      <p>One use of this macro is to increase alignment of medium-size data to
make it all fit in fewer cache lines. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EMPTY_FIELD_BOUNDARY</b><var><a name="index-EMPTY_005fFIELD_005fBOUNDARY-3790"></a></var><br>
<blockquote><p>允许像<code>int : 0;</code>；这样的空域的结构体位域的对齐位数。

      <p>如果<code>PCC_BITFIELD_TYPE_MATTERS</code>为真，则其覆盖该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STRUCTURE_SIZE_BOUNDARY</b><var><a name="index-STRUCTURE_005fSIZE_005fBOUNDARY-3791"></a></var><br>
<blockquote><p>任何结构体或联合体的大小必须为该位数的倍数。
每个结构体或联合体的大小都将被舍入到该位数的一个倍数。

      <p>如果没有定义该宏，则缺省与<code>BITS_PER_UNIT</code>相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STRICT_ALIGNMENT</b><var><a name="index-STRICT_005fALIGNMENT-3792"></a></var><br>
<blockquote><p>定义该宏值为1，如果给定数据不在通常对齐方式上，则指令无法工作。
如果对于这种情况指令只不过是变慢，则定义该宏为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PCC_BITFIELD_TYPE_MATTERS</b><var><a name="index-PCC_005fBITFIELD_005fTYPE_005fMATTERS-3793"></a></var><br>
<blockquote><p>定义该宏，如果你希望仿效许多其它C编译器处理位域和包含它们的结构体的对齐方式。

      <p>该行为是书写为命名位域（<code>int</code>,<code>short</code>或其它整数类型）的类型被实施
用于整个结构体的对齐，就好像结构体包含了一个该类型的普通的域。另外，
位域放在结构体中，使得其将适合这样的域，而不会跨越边界。

      <p>这样，大多数机器上，书写为<code>int</code>的命名位域将不会跨越一个四字节的边界，
并将使得整个结构体为四字节对齐。（可能不使用四字节对齐；其由其它对齐参数控制。）

      <p>一个没有命名的位域将不会影响包含结构体的对齐。

      <p>如果定义了该宏，则其定义为一个C表达式；该表达式的非0值会使用这样方式。

      <p>注意如果该宏没有定义，或者其值为0，则一些位域可能跨越多于一个的对齐边界。
编译器可以支持这种引用，如果有&lsquo;<samp><span class="samp">insv</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">extv</span></samp>&rsquo;和&lsquo;<samp><span class="samp">extzv</span></samp>&rsquo; insns可以直接引用内存。

      <p>其它已知的可以使位域工作的的方式为定义<code>STRUCTURE_SIZE_BOUNDARY</code>和<code>BIGGEST_ALIGNMENT</code>一样大。

      <p>除非机器具有位域指令或者你按照那种方式定义了<code>STRUCTURE_SIZE_BOUNDARY</code>，
否则你必须定义<code>PCC_BITFIELD_TYPE_MATTERS</code>具有非0值。

      <p>如果你的目标是使得GCC使用与其它编译器相同的约定来布局位域，
则这里有一种方式可以调查其它编译器是如何做的。编译运行该程序：

     <pre class="smallexample">          struct foo1
          {
            char x;
            char :0;
            char y;
          };
          
          struct foo2
          {
            char x;
            int :0;
            char y;
          };
          
          main ()
          {
            printf ("Size of foo1 is %d\n",
                    sizeof (struct foo1));
            printf ("Size of foo2 is %d\n",
                    sizeof (struct foo2));
            exit (0);
          }
</pre>
      <p>如果其打印2和5，则编译器的行为就是你通过<code>PCC_BITFIELD_TYPE_MATTERS</code>获得的效果。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BITFIELD_NBYTES_LIMITED</b><var><a name="index-BITFIELD_005fNBYTES_005fLIMITED-3794"></a></var><br>
<blockquote><p>跟<code>PCC_BITFIELD_TYPE_MATTERS</code>相似，除了它只影响结构体中的位域的对齐。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ALIGN_ANON_BITFIELD</b> (<var>void</var>)<var><a name="index-TARGET_005fALIGN_005fANON_005fBITFIELD-3795"></a></var><br>
<blockquote><p>当<code>PCC_BITFIELD_TYPE_MATTERS</code>为真，
该钩子将确定未命名位域是否要影响包含它的结构体的对齐。
钩子应该返回真，如果结构体应该继承未命名位域的类型所要求的对齐。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_NARROW_VOLATILE_BITFIELD</b> (<var>void</var>)<var><a name="index-TARGET_005fNARROW_005fVOLATILE_005fBITFIELD-3796"></a></var><br>
<blockquote><p>该target钩子应该返回<code>true</code>，如果访问volatile位域应该尽可能使用最窄的机器模式。其应该返回<code>false</code>，如果这些访问应该使用位域的容器的类型。

      <p>缺省为<code>!TARGET_STRICT_ALIGN</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MEMBER_TYPE_FORCES_BLK</b> (<var>field, mode</var>)<var><a name="index-MEMBER_005fTYPE_005fFORCES_005fBLK-3797"></a></var><br>
<blockquote><p>返回1，如果一个包含<var>field</var>的结构体或者数组应该使用<code>BLKMODE</code>模式来访问。

      <p>如果<var>field</var>为结构体中唯一的域，则<var>mode</var>为它的机器模式，
否则<var>mode</var>为VOIDmode。

      <p>通常，不需要该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ROUND_TYPE_ALIGN</b> (<var>type, computed, specified</var>)<var><a name="index-ROUND_005fTYPE_005fALIGN-3798"></a></var><br>
<blockquote><p>定义该宏为一个表达式，为一个类型（由作为树节点的<var>type</var>给定）的对齐，
如果按照通常方式计算的对齐方式为<var>computed</var>并且显示指定的对齐方式为<var>specified</var>。

      <p>缺省是使用<var>specified</var>，如果其更大；
否则使用<var>computed</var>和<code>BIGGEST_ALIGNMENT</code>中较小的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_FIXED_MODE_SIZE</b><var><a name="index-MAX_005fFIXED_005fMODE_005fSIZE-3799"></a></var><br>
<blockquote><p>一个整数表达式，为实际应该被使用的最大的整数机器模式的位数。
所有该大小或者更小一些的整数机器模式都可以用于结构体和联合体。
如果哦没有定义该宏，则假设为<code>GET_MODE_BITSIZE (DImode)</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_SAVEAREA_MODE</b> (<var>save_level</var>)<var><a name="index-STACK_005fSAVEAREA_005fMODE-3800"></a></var><br>
<blockquote><p>如果定义，则为一个<code>enum machine_mode</code>类型的表达式，
指定名为<code>save_stack_</code><var>level</var>的指令模式（参见<a href="_00e6_00a0_0087_00e5_0087_0086_00e5_0090_008d_00e5_00ad_0097.html#g_t_00e6_00a0_0087_00e5_0087_0086_00e5_0090_008d_00e5_00ad_0097">标准名字</a>）的save区域操作数的机器模式。
<var>save_level</var>为<code>SAVE_BLOCK</code>, <code>SAVE_FUNCTION</code>或<code>SAVE_NONLOCAL</code>中之一。

      <p>你不需要定义该宏，如果其总是返回<code>Pmode</code>。你通常将会定义该宏，
如果<code>save_stack_</code><var>level</var>指令模式需要同时支持32和64位机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_SIZE_MODE</b><var><a name="index-STACK_005fSIZE_005fMODE-3801"></a></var><br>
<blockquote><p>如果定义，为一个<code>enum machine_mode</code>类型的表达式，
指定名为<code>allocate_stack</code>的指令模式（参见<a href="_00e6_00a0_0087_00e5_0087_0086_00e5_0090_008d_00e5_00ad_0097.html#g_t_00e6_00a0_0087_00e5_0087_0086_00e5_0090_008d_00e5_00ad_0097">标准名字</a>）的size increment操作数的机器模式。

      <p>你不需要定义该宏，如果其总是返回<code>word_mode</code>。你通常将会定义该宏，
如果<code>allocate_stack</code>指令模式需要同时支持32和64位机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: enum machine_mode <b>TARGET_LIBGCC_CMP_RETURN_MODE</b> ()<var><a name="index-TARGET_005fLIBGCC_005fCMP_005fRETURN_005fMODE-3802"></a></var><br>
<blockquote><p>该target钩子应该返回扩展为libgcc调用的比较指令的返回值的机器模式。
如果没有定义，则返回<code>word_mode</code>，其对于大多数target是正确的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: enum machine_mode <b>TARGET_LIBGCC_SHIFT_COUNT_MODE</b> ()<var><a name="index-TARGET_005fLIBGCC_005fSHIFT_005fCOUNT_005fMODE-3803"></a></var><br>
<blockquote><p>该target钩子应该返回扩展为libgcc调用的移位指令的shift count操作数的机器模式。
如果没有定义，则返回<code>word_mode</code>，其对于大多数target是正确的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ROUND_TOWARDS_ZERO</b><var><a name="index-ROUND_005fTOWARDS_005fZERO-3804"></a></var><br>
<blockquote><p>如果定义，该宏应该为真，如果舍入的模式是朝向0。

      <p>定义该宏只影响<samp><span class="file">libgcc.a</span></samp>模拟浮点算术的方式。

      <p>不定义该宏，等价于其返回0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LARGEST_EXPONENT_IS_NORMAL</b> (<var>size</var>)<var><a name="index-LARGEST_005fEXPONENT_005fIS_005fNORMAL-3805"></a></var><br>
<blockquote><p>该宏应该返回真，如果具有<var>size</var>位数的浮点不具有NaN或无穷的表示，
但是使用最大的普通数的指数来替代表示。

      <p>定义该宏只影响<samp><span class="file">libgcc.a</span></samp>模拟浮点算术的方式。

      <p>该宏缺省定义对所有的size都返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VECTOR_OPAQUE_P</b> (<var>tree type</var>)<var><a name="index-TARGET_005fVECTOR_005fOPAQUE_005fP-3806"></a></var><br>
<blockquote><p>This target hook should return <code>true</code> a vector is opaque.  That
is, if no cast is needed when copying a vector value of type
<var>type</var> into another vector lvalue of the same size.  Vector opaque
types cannot be initialized.  The default is that there are no such
types. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_MS_BITFIELD_LAYOUT_P</b> (<var>tree record_type</var>)<var><a name="index-TARGET_005fMS_005fBITFIELD_005fLAYOUT_005fP-3807"></a></var><br>
<blockquote><p>This target hook returns <code>true</code> if bit-fields in the given
<var>record_type</var> are to be laid out following the rules of Microsoft
Visual C/C++, namely: (i) a bit-field won't share the same storage
unit with the previous bit-field if their underlying types have
different sizes, and the bit-field will be aligned to the highest
alignment of the underlying types of itself and of the previous
bit-field; (ii) a zero-sized bit-field will affect the alignment of
the whole enclosing structure, even if it is unnamed; except that
(iii) a zero-sized bit-field will be disregarded unless it follows
another bit-field of nonzero size.  If this hook returns <code>true</code>,
other macros that control bit-field layout are ignored.

      <p>When a bit-field is inserted into a packed record, the whole size
of the underlying type is used by one or more same-size adjacent
bit-fields (that is, if its long:3, 32 bits is used in the record,
and any additional adjacent long bit-fields are packed into the same
chunk of 32 bits.  However, if the size changes, a new field of that
size is allocated).  In an unpacked record, this is the same as using
alignment, but not equivalent when packing.

      <p>If both MS bit-fields and &lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo; are used,
the latter will take precedence.  If &lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo; is
used on a single field when MS bit-fields are in use, it will take
precedence for that field, but the alignment of the rest of the structure
may affect its placement. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_DECIMAL_FLOAT_SUPPORTED_P</b> (<var>void</var>)<var><a name="index-TARGET_005fDECIMAL_005fFLOAT_005fSUPPORTED_005fP-3808"></a></var><br>
<blockquote><p>返回真，如果target支持十进制浮点。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_FIXED_POINT_SUPPORTED_P</b> (<var>void</var>)<var><a name="index-TARGET_005fFIXED_005fPOINT_005fSUPPORTED_005fP-3809"></a></var><br>
<blockquote><p>返回真，如果target支持定点算术。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_EXPAND_TO_RTL_HOOK</b> (<var>void</var>)<var><a name="index-TARGET_005fEXPAND_005fTO_005fRTL_005fHOOK-3810"></a></var><br>
<blockquote><p>该钩子在扩展为rtl之前被调用，允许target在扩展前执行额外的实例化或者分析。
例如，rs6000port使用它来分配scratch栈槽，当被扩展的函数具有任何SDmode使用时，
用于在内存和浮点寄存器之间复制SDmode值。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_INSTANTIATE_DECLS</b> (<var>void</var>)<var><a name="index-TARGET_005fINSTANTIATE_005fDECLS-3811"></a></var><br>
<blockquote><p>该钩子允许后端执行额外的rtl实例化，这些实际上不存在于任何insn中，但在之后会有。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_MANGLE_TYPE</b> (<var>tree type</var>)<var><a name="index-TARGET_005fMANGLE_005fTYPE-3812"></a></var><br>
<blockquote><p>If your target defines any fundamental types, or any types your target
uses should be mangled differently from the default, define this hook
to return the appropriate encoding for these types as part of a C++
mangled name.  The <var>type</var> argument is the tree structure representing
the type to be mangled.  The hook may be applied to trees which are
not target-specific fundamental types; it should return <code>NULL</code>
for all such types, as well as arguments it does not recognize.  If the
return value is not <code>NULL</code>, it must point to a statically-allocated
string constant.

      <p>Target-specific fundamental types might be new fundamental types or
qualified versions of ordinary fundamental types.  Encode new
fundamental types as &lsquo;<samp><span class="samp">u&nbsp;</span><var>n</var><span class="samp">&nbsp;</span><var>name</var><span class="samp"><!-- /@w --></span></samp>&rsquo;, where <var>name</var>
is the name used for the type in source code, and <var>n</var> is the
length of <var>name</var> in decimal.  Encode qualified versions of
ordinary types as &lsquo;<samp><span class="samp">U&nbsp;</span><var>n</var><span class="samp">&nbsp;</span><var>name</var><span class="samp">&nbsp;</span><var>code</var><span class="samp"><!-- /@w --></span></samp>&rsquo;, where
<var>name</var> is the name used for the type qualifier in source code,
<var>n</var> is the length of <var>name</var> as above, and <var>code</var> is the
code used to represent the unqualified version of this type.  (See
<code>write_builtin_type</code> in <samp><span class="file">cp/mangle.c</span></samp> for the list of
codes.)  In both cases the spaces are for clarity; do not include any
spaces in your string.

      <p>This hook is applied to types prior to typedef resolution.  If the mangled
name for a particular type depends only on that type's main variant, you
can perform typedef resolution yourself using <code>TYPE_MAIN_VARIANT</code>
before mangling.

      <p>The default version of this hook always returns <code>NULL</code>, which is
appropriate for a target that does not define any new fundamental
types. 
</p></blockquote></div>

 </body></html>

