<html lang="zh">
<head>
<title>旧式约束 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab" title="寄存器类别">
<link rel="next" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%97%a7%e5%bc%8f%e7%ba%a6%e6%9d%9f"></a>
<a name="g_t_00e6_0097_00a7_00e5_00bc_008f_00e7_00ba_00a6_00e6_009d_009f"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab">寄存器类别</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.9 废弃的定义约束的宏</h3>

<p><a name="index-defining-constraints_002c-obsolete-method-3943"></a><a name="index-constraints_002c-defining_002c-obsolete-method-3944"></a>
机器特定的约束可以使用这些宏来定义，来替代在<a href="_00e5_00ae_009a_00e4_00b9_0089_00e7_00ba_00a6_00e6_009d_009f.html#g_t_00e5_00ae_009a_00e4_00b9_0089_00e7_00ba_00a6_00e6_009d_009f">定义约束</a>中描述的机器描述结构。
这种机制已经被废弃；旧的port应该转换为新的机制。

<div class="defun">
&mdash; Macro: <b>CONSTRAINT_LEN</b> (<var>char, str</var>)<var><a name="index-CONSTRAINT_005fLEN-3945"></a></var><br>
<blockquote><p>对于起始于<var>str</var>，其起始字母为<var>c</var>的约束，返回其长度。
这允许你具有比单个字母更长的寄存器类别/常量/额外约束；
你不需要定义该宏，如果你只用单个字母的约束。
该宏的定义应该使用DEFAULT_CONSTRAINT_LEN，对于你不想特别处理的所有字符。
在genoutput.c中有一些合理性检查，用来为md文件检查约束的长度。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REG_CLASS_FROM_LETTER</b> (<var>char</var>)<var><a name="index-REG_005fCLASS_005fFROM_005fLETTER-3946"></a></var><br>
<blockquote><p>一个C表达式，其为寄存器类别定义了机器相关的操作数约束字母。
如果<var>char</var>为这样的字母，则值应该为对应的寄存器类别。否则，
值应该为<code>NO_REGS</code>。寄存器字母&lsquo;<samp><span class="samp">r</span></samp>&rsquo;，对应于类别<code>GENERAL_REGS</code>，
将不被传给该宏；你不需要处理它。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REG_CLASS_FROM_CONSTRAINT</b> (<var>char, str</var>)<var><a name="index-REG_005fCLASS_005fFROM_005fCONSTRAINT-3947"></a></var><br>
<blockquote><p>类似于<code>REG_CLASS_FROM_LETTER</code>，不过你还得到在<var>str</var>中传递的字符串，
所以你可以使用后缀来区别不同的变种。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONST_OK_FOR_LETTER_P</b> (<var>value, c</var>)<var><a name="index-CONST_005fOK_005fFOR_005fLETTER_005fP-3948"></a></var><br>
<blockquote><p>一个C表达式，其定义了机器相关操作数约束字母（&lsquo;<samp><span class="samp">I</span></samp>&rsquo;, &lsquo;<samp><span class="samp">J</span></samp>&rsquo;, &lsquo;<samp><span class="samp">K</span></samp>&rsquo;,
<small class="dots">...</small> &lsquo;<samp><span class="samp">P</span></samp>&rsquo;），指定了整数值的特定范围。如果<var>c</var>为那些字母中的，
则表达式应该检查<var>value</var>，一个整数，如果在合适的范围中则返回1，否则返回0。
如果<var>c</var>不是那些字母中的，则值应该为0，而不管<var>value</var>是多少。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONST_OK_FOR_CONSTRAINT_P</b> (<var>value, c, str</var>)<var><a name="index-CONST_005fOK_005fFOR_005fCONSTRAINT_005fP-3949"></a></var><br>
<blockquote><p>类似<code>CONST_OK_FOR_LETTER_P</code>，但是你还得到在<var>str</var>中传递的字符串，
所以你可以使用后缀来区别不同的变种。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONST_DOUBLE_OK_FOR_LETTER_P</b> (<var>value, c</var>)<var><a name="index-CONST_005fDOUBLE_005fOK_005fFOR_005fLETTER_005fP-3950"></a></var><br>
<blockquote><p>一个C表达式，定义了机器相关操作数约束字母，
指定了<code>const_double</code>值的特定范围（&lsquo;<samp><span class="samp">G</span></samp>&rsquo;或&lsquo;<samp><span class="samp">H</span></samp>&rsquo;）。

      <p>如果<var>c</var>为那些字母中的，则表达式应该检查<var>value</var>，
一个代码为<code>const_double</code>的RTX，如果在合适的范围中则返回1，否则返回0。
如果<var>c</var>不是那些字母中的，则值应该为0，而不管<var>value</var>是多少。

      <p><code>const_double</code>用于所有的浮点常量和<code>DImode</code>定点常量。
一个给定的字母可以接受一种或者这两种类型的值。
其可以使用<code>GET_MODE</code>来区别这些类型。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONST_DOUBLE_OK_FOR_CONSTRAINT_P</b> (<var>value, c, str</var>)<var><a name="index-CONST_005fDOUBLE_005fOK_005fFOR_005fCONSTRAINT_005fP-3951"></a></var><br>
<blockquote><p>类似<code>CONST_DOUBLE_OK_FOR_LETTER_P</code>，但是你还得到在<var>str</var>中传递的字符串，
所以你可以使用后缀来区别不同的变种。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EXTRA_CONSTRAINT</b> (<var>value, c</var>)<var><a name="index-EXTRA_005fCONSTRAINT-3952"></a></var><br>
<blockquote><p>一个C表达式，定义了可选的机器相关约束字母，
其可以用于为target机器隔离特定类型的操作数，通常为内存引用。
任何没有在其它地方定义并且不被
<code>REG_CLASS_FROM_LETTER</code> / REG_CLASS_FROM_CONSTRAINT匹配的字母都可以使用。
通常该宏将不被定义。

      <p>如果对于特定的target机器需要该宏，则应该返回1，
如果<var>value</var>对应于由约束字母<var>c</var>表示的操作数类型。
如果<var>c</var>没有作为extra约束定义，则值应该为0，而不管<var>value</var>是多少。

      <p>例如，则ROMP上，加载指令不能将它们的输出放在r0中，
如果内存引用包含了一个符号地址。
约束字母&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;被定义来表示不包含符号地址的内存地址。
一个可选项使用&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;约束在输入上并且&lsquo;<samp><span class="samp">r</span></samp>&rsquo;在输出上来指定。
下一个可选项指定了&lsquo;<samp><span class="samp">m</span></samp>&rsquo;在输入上并且不包含r0的寄存器类别在输出上。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EXTRA_CONSTRAINT_STR</b> (<var>value, c, str</var>)<var><a name="index-EXTRA_005fCONSTRAINT_005fSTR-3953"></a></var><br>
<blockquote><p>类似<code>EXTRA_CONSTRAINT</code>，但是你还得到在<var>str</var>中传递的字符串，
所以你可以使用后缀来区别不同的变种。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EXTRA_MEMORY_CONSTRAINT</b> (<var>c, str</var>)<var><a name="index-EXTRA_005fMEMORY_005fCONSTRAINT-3954"></a></var><br>
<blockquote><p>一个C表达式，定义了可选的机器相关约束字母，
在那些由<code>EXTRA_CONSTRAINT</code>接受的字母中，
其应该被重载过程作为内存约束来对待。

      <p>其应该返回1，如果由<var>str</var>起始，并且第一个字母为<var>c</var>的约束所表示的操作数
类型所包含的所有内存引用为简单的基址寄存器。这允许重载过程来重载操作数，
如果其不直接对应于操作数类型<var>c</var>，通过将其地址复制到基址寄存器中。

      <p>例如，在S/390上，一些指令不接受任意的内存引用，只接受那些不使用索引寄存器的。
约束字母&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;被通过<code>EXTRA_CONSTRAINT</code>定义，来表示这种类型的内存地址。
如果字母&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;被标记为<code>EXTRA_MEMORY_CONSTRAINT</code>，
则一个&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;常量可以处理任何内存操作数，
因为重载过程知道其可以通过将内存地址复制到基址寄存器中如果需要的话。
这类似于可以处理任何内存操作数的&lsquo;<samp><span class="samp">o</span></samp>&rsquo;约束的方式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EXTRA_ADDRESS_CONSTRAINT</b> (<var>c, str</var>)<var><a name="index-EXTRA_005fADDRESS_005fCONSTRAINT-3955"></a></var><br>
<blockquote><p>一个C表达式，定义了可选的机器相关约束字母，在那些由
<code>EXTRA_CONSTRAINT</code> / <code>EXTRA_CONSTRAINT_STR</code>接受的字母中，
其应该被重载过程作为地址约束来对待。

      <p>其应该返回1，如果由<var>str</var>起始，并且第一个字母为<var>c</var>的约束所表示的操作数
类型所包含的所有内存引用为简单的基址寄存器。这允许重载过程来重载操作数，
如果其不直接对应于操作数类型<var>str</var>，通过将其地址复制到基址寄存器中。

      <p>标记为<code>EXTRA_ADDRESS_CONSTRAINT</code>的约束只能与<code>address_operand</code>断言
一起使用。其类似于&lsquo;<samp><span class="samp">p</span></samp>&rsquo;约束。
</p></blockquote></div>

 </body></html>

