<html lang="zh">
<head>
<title>处理器流水线描述 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Insn_00e5_00b1_009e_00e6_0080_00a7.html#Insn_00e5_00b1_009e_00e6_0080_00a7" title="Insn属性">
<link rel="prev" href="_00e5_00bb_00b6_00e8_00bf_009f_00e6_00a7_00bd.html#g_t_00e5_00bb_00b6_00e8_00bf_009f_00e6_00a7_00bd" title="延迟槽">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%a4%84%e7%90%86%e5%99%a8%e6%b5%81%e6%b0%b4%e7%ba%bf%e6%8f%8f%e8%bf%b0"></a>
<a name="g_t_00e5_00a4_0084_00e7_0090_0086_00e5_0099_00a8_00e6_00b5_0081_00e6_00b0_00b4_00e7_00ba_00bf_00e6_008f_008f_00e8_00bf_00b0"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00bb_00b6_00e8_00bf_009f_00e6_00a7_00bd.html#g_t_00e5_00bb_00b6_00e8_00bf_009f_00e6_00a7_00bd">延迟槽</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Insn_00e5_00b1_009e_00e6_0080_00a7.html#Insn_00e5_00b1_009e_00e6_0080_00a7">Insn属性</a>
<hr>
</div>

<h4 class="subsection">16.19.8 处理器流水线描述</h4>

<p><a name="index-processor-pipeline-description-3625"></a><a name="index-processor-functional-units-3626"></a><a name="index-instruction-latency-time-3627"></a><a name="index-interlock-delays-3628"></a><a name="index-data-dependence-delays-3629"></a><a name="index-reservation-delays-3630"></a><a name="index-pipeline-hazard-recognizer-3631"></a><a name="index-automaton-based-pipeline-description-3632"></a><a name="index-regular-expressions-3633"></a><a name="index-deterministic-finite-state-automaton-3634"></a><a name="index-automaton-based-scheduler-3635"></a><a name="index-RISC-3636"></a><a name="index-VLIW-3637"></a>
为了获得更好的性能，大多数现代处理器（超流水线，超标量<acronym>RISC</acronym>，
以及<acronym>VLIW</acronym>处理器）都具有许多功能单元（<dfn>functional units</dfn>），
可以在其上同时执行多条指令。一条指令当它的发射条件（issue conditions）
被满足时才开始执行。如果不满足，则指令会被阻塞（stalled），直到它的条件被满足。
这样的互锁（流水线）延迟(<dfn>interlock (pipeline) delay</dfn>)
导致对后续指令读取的中断（或者需要nop指令，例如一些MIPS处理器）。

 <p>现代处理器中有两种主要的互锁延迟。第一种为数据依赖延迟，用来确定指令延迟时间
（<dfn>instruction latency time</dfn>）。直到所有源数据都被先前指令求得，
该指令才会开始执行（有更加复杂的情况是，
当指令开始执行时数据还不可用，但是将会在指令开始执行后的给定时间准备好）。
考虑数据依赖延迟是简单的。
两个指令间的数据依赖（真依赖，输出依赖，反依赖）延迟被给定为一个常量。
大多数情况下该方法都适合。第二种互锁延迟为保留延迟（reservation delay）。
保留延迟意味着要执行的两条指令将会需要共享的处理器资源，即总线，内部寄存器，
以及/或者功能单元，而这些将被保留一段时间。考虑这种延迟是复杂的，
特别是对于现代<acronym>RISC</acronym>处理器。

 <p>探索更多的处理器并行的任务是由指令调度器来解决的。为了能够更好的解决该问题，
指令调度器必须具有一个处理器并行的适当描述（或者说流水线描述）。
GCC机器描述使用正规表达式来描述处理器并行和对指令组的功能单元保留。

 <p>GCC指令调度器使用流水线冒险识别器通过给定的处理器时钟周期模拟来找出可能的指令问题。
流水线冒险识别器通过处理器流水线描述自动生成。
由机器描述生成的流水线冒险识别器是基于有限确定状态机（<acronym>DFA</acronym>）：
如果存在从一个自动机状态到另一状态的转换，则可以进行指令发射。
该算法非常快，而且它的速度不依赖于处理器的复杂度
<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>。

 <p><a name="index-automaton-based-pipeline-description-3638"></a>该章节的剩余部分描述了构造一个基于自动机的处理器流水线描述的命令（directive）。
这些结构在机器描述文件中的顺序并不重要。

 <p><a name="index-define_005fautomaton-3639"></a><a name="index-pipeline-hazard-recognizer-3640"></a>下面的可选结构描述了生成的自动机的名字，并用于流水线冒险识别。
有时供流水线冒险识别器使用的生成的有限状态机会非常大。
如果我们使用多个自动机并且将功能单元绑定到自动机上，
则自动机的总的大小通常会小于单个自动机的情况。
如果没有这样一个结构，则会只生成一个有限状态机。

<pre class="smallexample">     (define_automaton <var>automata-names</var>)
</pre>
 <p><var>automata-names</var>为一个字符串，给出了自动机的名字。
名字由逗号分隔。所有自动机应该具有唯一的名字。
自动机名用于结构<code>define_cpu_unit</code>和<code>define_query_cpu_unit</code>。

 <p><a name="index-define_005fcpu_005funit-3641"></a><a name="index-processor-functional-units-3642"></a>用于指令保留描述的每个处理器功能单元应该使用下列结构来描述。

<pre class="smallexample">     (define_cpu_unit <var>unit-names</var> [<var>automaton-name</var>])
</pre>
 <p><var>unit-names</var>为一个字符串，给出了由逗号分隔的功能单元的名字。
不要使用名字&lsquo;<samp><span class="samp">nothing</span></samp>&rsquo;，它被保留用于其它目的。

 <p><var>automaton-name</var>为一个字符串，给出了功能单元绑定的自动机名。
自动机应该在结构<code>define_automaton</code>中有描述。
如果有一个定义的自动机，则你应该给出<dfn>automaton-name</dfn>。

 <p>为功能单元赋予自动机，受到insn保留中对功能单元使用的限制。
最重要的constraint为：如果一个功能单元保留。
其余的constraint将在后续的结构描述中提到。

 <p><a name="index-define_005fquery_005fcpu_005funit-3643"></a><a name="index-querying-function-unit-reservations-3644"></a>下面的结构描述了CPU功能单元，类似于<code>define_cpu_unit</code>。
对于这样的功能单元的保留，可以被询问自动机状态。
对于给定的自动机状态，指令调度器从来不询问功能单元的保留。
所以按照规则，你不需要该结构。
该结构可以被用于将来的代码生成目的（例如，生成<acronym>VLIW</acronym> insn模板）。

<pre class="smallexample">     (define_query_cpu_unit <var>unit-names</var> [<var>automaton-name</var>])
</pre>
 <p><var>unit-names</var>为一个字符串，给出了由逗号分隔的功能单元名字。

 <p><var>automaton-name</var>为一个字符串，给出了功能单元所绑定的自动机。

 <p><a name="index-define_005finsn_005freservation-3645"></a><a name="index-instruction-latency-time-3646"></a><a name="index-regular-expressions-3647"></a><a name="index-data-bypass-3648"></a>下面的结构为描述一条指令的流水线特征的主要结构。

<pre class="smallexample">     (define_insn_reservation <var>insn-name</var> <var>default_latency</var>
                              <var>condition</var> <var>regexp</var>)
</pre>
 <p><var>default_latency</var>为一个数，给出了指令的延迟时间。
在旧描述和基于自动机的流水线描述中，有一个重要的不同之处。
当我们使用旧描述时，延迟时间是用于所有的依赖。
在基于自动机的流水线描述中，给定的延迟时间只用于真依赖。
反依赖的代价总为0，并且输出依赖的代价是生产者insn和消费者insn的延迟时间之差
（如果差为负数，则代价被认为为0）。
你可以通过使用目标机钩子<code>TARGET_SCHED_ADJUST_COST</code>（参见<a href="_00e8_00b0_0083_00e5_00ba_00a6.html#g_t_00e8_00b0_0083_00e5_00ba_00a6">调度</a>），
来改变任何描述的缺省代价。

 <p><var>insn-name</var>为一个字符串，给出了insn的内部名字。
内部名字被用于结构<code>define_bypass</code>和为了调试所生成的自动机描述文件。
内部名字与<code>define_insn</code>中的名字没有任何关系。
使用在处理器手册中描述的insn类别，是一个很好的做法。

 <p><var>condition</var>定义了什么样的RTL insns由该结构描述。
你应该记住如果对于一个insn，
两个或更多不同<code>define_insn_reservation</code>结构的<var>condition</var>都为真，
则会出问题。这种情况，该insn将使用什么保留，是未定义的。
这种情况在流水线冒险识别器生成时，是不被检查的，
因为识别两个条件具有相同值是十分困难的
（特别是如果条件中包含<code>symbol_ref</code>）。
这在流水线识别器工作时，也不被检查，因为它将使识别器变得相当慢。

 <p><var>regexp</var>为一个字符串，描述了指令对cpu的功能单元的保留。
保留通过正规表达式来描述，语法如下：

<pre class="smallexample">            regexp = regexp "," oneof
                   | oneof
     
            oneof = oneof "|" allof
                  | allof
     
            allof = allof "+" repeat
                  | repeat
     
            repeat = element "*" number
                   | element
     
            element = cpu_function_unit_name
                    | reservation_name
                    | result_name
                    | "nothing"
                    | "(" regexp ")"
</pre>
     <ul>
<li>&lsquo;<samp><span class="samp">,</span></samp>&rsquo;用于描述在保留中，下一周期的开始。

     <li>&lsquo;<samp><span class="samp">|</span></samp>&rsquo;用于描述在保留中，第一个正规表达式<strong>or</strong>第二个正规表达式，
<strong>or</strong>等等。

     <li>&lsquo;<samp><span class="samp">+</span></samp>&rsquo;用于描述在保留中，第一个正规表达式<strong>and</strong>第二个正规表达式，
<strong>and</strong>等等。

     <li>&lsquo;<samp><span class="samp">*</span></samp>&rsquo;用于方便记述，其简单的表示一个正规表达式序列，
表达式随着周期前移被重复<var>number</var>次（参见&lsquo;<samp><span class="samp">,</span></samp>&rsquo;）。

     <li>&lsquo;<samp><span class="samp">cpu_function_unit_name</span></samp>&rsquo;表示对命名功能单元的保留。

     <li>&lsquo;<samp><span class="samp">reservation_name</span></samp>&rsquo; &mdash; 参见对结构&lsquo;<samp><span class="samp">define_reservation</span></samp>&rsquo;的描述。

     <li>&lsquo;<samp><span class="samp">nothing</span></samp>&rsquo;表示没有功能单元被保留。
</ul>

 <p><a name="index-define_005freservation-3649"></a>有时，对于不同insn，具有共同部分的单元保留。
这样情况，你可以通过使用下面的结构来描述共同部分，以简化流水线描述。

<pre class="smallexample">     (define_reservation <var>reservation-name</var> <var>regexp</var>)
</pre>
 <p><var>reservation-name</var>为一个字符串，给出了<var>regexp</var>的名字。
功能单元名和保留名属于同一命名空间。所以，保留名应该与功能单元名不同，
并且不能为预留名&lsquo;<samp><span class="samp">nothing</span></samp>&rsquo;。

 <p><a name="index-define_005fbypass-3650"></a><a name="index-instruction-latency-time-3651"></a><a name="index-data-bypass-3652"></a>下面的结构被用于描述对于给定的指令对，在延迟时间上的例外。也称之为bypass。

<pre class="smallexample">     (define_bypass <var>number</var> <var>out_insn_names</var> <var>in_insn_names</var>
                    [<var>guard</var>])
</pre>
 <p><var>number</var>定义了给定字符串<var>out_insn_names</var>的指令所产生的结果，
什么时候可以由给定字符串<var>in_insn_names</var>的指令使用。
字符串中的指令由逗号分隔。

 <p><var>guard</var>为一个可选的字符串，给出了C函数名，其定义了bypass的额外的保护条件。
该函数将两个insn作为参数。如果函数返回0，则对于该情况bypass将被忽略。
额外的guard在识别复杂的bypass时，很有必要。
例如当消费者只是一个insn &lsquo;<samp><span class="samp">store</span></samp>&rsquo;的地址（而不是被存储的值）。

 <p><a name="index-exclusion_005fset-3653"></a><a name="index-presence_005fset-3654"></a><a name="index-final_005fpresence_005fset-3655"></a><a name="index-absence_005fset-3656"></a><a name="index-final_005fabsence_005fset-3657"></a><a name="index-VLIW-3658"></a><a name="index-RISC-3659"></a>下面五个结构通常用于描述<acronym>VLIW</acronym>处理器，或者更精确的说，
来描述放入<acronym>VLIW</acronym>指令槽中的小指令的位置。
它们也可以用于<acronym>RISC</acronym>处理器。

<pre class="smallexample">     (exclusion_set <var>unit-names</var> <var>unit-names</var>)
     (presence_set <var>unit-names</var> <var>patterns</var>)
     (final_presence_set <var>unit-names</var> <var>patterns</var>)
     (absence_set <var>unit-names</var> <var>patterns</var>)
     (final_absence_set <var>unit-names</var> <var>patterns</var>)
</pre>
 <p><var>unit-names</var>为一个字符串，给出了由逗号分隔的功能单元的名字。

 <p><var>patterns</var>为一个字符串，给出了由逗号分隔的功能单元的模式。
目前的模式，为一个单元或者由空格分隔的单元。

 <p>第一个结构(&lsquo;<samp><span class="samp">exclusion_set</span></samp>&rsquo;) 意味着第一个字符串中的每个功能单元不能与
第二个字符串中的功能单元同时被保留，反之亦然。例如，结构可以用于描述处理器
（例如，一些SPARC处理器）具有全流水浮点功能单元，
其只可以同时执行单浮点insn或者双浮点insn。

 <p>第二个结构(&lsquo;<samp><span class="samp">presence_set</span></samp>&rsquo;) 意味着第一个字符串中的每个功能单元不能被保留，
除非至少一种模式的功能单元其名字在第二个字符串中且被保留。这是一个不对称关系。
例如，可以用于描述<acronym>VLIW</acronym> &lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;在&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;保留之后被保留。
我们可以使用下列结构来描述

<pre class="smallexample">     (presence_set "slot1" "slot0")
</pre>
 <p>或者&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;只在&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;和功能单元&lsquo;<samp><span class="samp">b0</span></samp>&rsquo;保留之后被保留。
这种情况下，我们可以写成

<pre class="smallexample">     (presence_set "slot1" "slot0 b0")
</pre>
 <p>第三个结构(&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;) 类似于&lsquo;<samp><span class="samp">presence_set</span></samp>&rsquo;。
区别在于什么时候进行检查。当指令在给定自动机状态被发射时，
其将影响所有当前和计划中的单元保留，并且自动机状态被改变。
第一个状态为源状态，第二个为结果状态。
对于&lsquo;<samp><span class="samp">presence_set</span></samp>&rsquo;的检查是在源状态保留时进行的，
对于&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;的检查是在结果状态下进行的。
该结构可以用于描述实际上是两个连续的保留的保留。例如，如果我们使用

<pre class="smallexample">     (presence_set "slot1" "slot0")
</pre>
 <p>下列insn将永远不会被发射（因为&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;需要&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;，
而&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;在源状态是空缺的）

<pre class="smallexample">     (define_reservation "insn_and_nop" "slot0 + slot1")
</pre>
 <p>但是如果我们使用类似的&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;其就可以被发射。

 <p>第四个结构 (&lsquo;<samp><span class="samp">absence_set</span></samp>&rsquo;) 意味着在第一个字符串中的每个功能单元，
只有在每个名字在第二个字符串中的功能单元没有被保留时才能被保留。
这是一个不对称关系（实际上&lsquo;<samp><span class="samp">exclusion_set</span></samp>&rsquo;与其类似，但它是对成的）。
例如，可以用于<acronym>VLIW</acronym>描述，来表示&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;不能在&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;或
&lsquo;<samp><span class="samp">slot2</span></samp>&rsquo;保留后被保留。这可以描述为

<pre class="smallexample">     (absence_set "slot0" "slot1, slot2")
</pre>
 <p>或者&lsquo;<samp><span class="samp">slot2</span></samp>&rsquo;不能被保留，如果&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;和单元&lsquo;<samp><span class="samp">b0</span></samp>&rsquo;被保留，
或者&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;和单元&lsquo;<samp><span class="samp">b1</span></samp>&rsquo;被保留. 这种情况下，我们可以写成

<pre class="smallexample">     (absence_set "slot2" "slot0 b0, slot1 b1")
</pre>
 <p>所有在集合（set）中提到的功能单元应属于相同的自动机。

 <p>最后一个结构(&lsquo;<samp><span class="samp">final_absence_set</span></samp>&rsquo;)类似于&lsquo;<samp><span class="samp">absence_set</span></samp>&rsquo;，
但是检查是在结果（状态）保留时进行。参见&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;的注解。

 <p><a name="index-automata_005foption-3660"></a><a name="index-deterministic-finite-state-automaton-3661"></a><a name="index-nondeterministic-finite-state-automaton-3662"></a><a name="index-finite-state-automaton-minimization-3663"></a>你可以使用下面的结构来控制流水线冒险识别器的生成。

<pre class="smallexample">     (automata_option <var>options</var>)
</pre>
 <p><var>options</var>为一个字符串，给出了影响生成代码的选项。目前有下列选项：

     <ul>
<li><dfn>no-minimization</dfn>不对自动机进行最小化处理。
这只在我们进行调试描述信息并且需要更加精确的查看保留状态时，才值得做。

     <li><dfn>time</dfn>意味着打印生成自动机的时间统计。

     <li><dfn>stats</dfn>意味着打印生成自动机的DFA状态，NDFA状态和arcs这样的数目统

     <li><dfn>v</dfn>意味着生成一个描述生成自动机的文件。文件具有后缀&lsquo;<samp><span class="samp">.dfa</span></samp>&rsquo;，
并且可以用于验证和调试描述。

     <li><dfn>w</dfn>意味着对于非关键的错误使用警告来替代。

     <li><dfn>ndfa</dfn>生成非确定有限状态机。这将影响对正规表达式中操作符&lsquo;<samp><span class="samp">|</span></samp>&rsquo;的对待。
通常对该操作符的处理是先尝试第一个，然后再第二个。
非确定状态机意味着尝试所有的选择，其中一些可以被后续的insn放弃。

     <li><dfn>progress</dfn>意味着输出一个进度条，来显示被处理的自动机目前生成了多少状态。
这在调试<acronym>DFA</acronym>描述时很有用。如果你看到太多的状态被生成，
你可以中断流水线冒险识别器的生成并尝试去弄清楚为什么会生成如此大的自动机。
</ul>

 <p>作为一个例子，考虑一个超标量<acronym>RISC</acronym>机器，
其可以在一个周期发射三条insn（两条整数insn和一条浮点insn），
但是只能完成两条insn。为了描述，我们定义下列功能单元。

<pre class="smallexample">     (define_cpu_unit "i0_pipeline, i1_pipeline, f_pipeline")
     (define_cpu_unit "port0, port1")
</pre>
 <p>所有简单的整数insn可以在任何整数流水线中被执行，并且结果可以在两个周期获得。
简单的整数insn将被发射到第一个流水线中，除非它被保留，
否则它们将被发射到第二个流水线中。整数除和乘insn只能在第二个整数流水线中被执行，
并且它们的结果相应的在8和4个周期获得。
整数除为非流水线，即后续的整数除insn在当前的除法insn完成前不能被发射。
浮点insn为全流水的并且它们的结果在3个周期获得。
当浮点insn的结果被整数insn使用使，将会产生一个额外的周期延迟。
要描述所有这些，我们可以指定

<pre class="smallexample">     (define_cpu_unit "div")
     
     (define_insn_reservation "simple" 2 (eq_attr "type" "int")
                              "(i0_pipeline | i1_pipeline), (port0 | port1)")
     
     (define_insn_reservation "mult" 4 (eq_attr "type" "mult")
                              "i1_pipeline, nothing*2, (port0 | port1)")
     
     (define_insn_reservation "div" 8 (eq_attr "type" "div")
                              "i1_pipeline, div*7, div + (port0 | port1)")
     
     (define_insn_reservation "float" 3 (eq_attr "type" "float")
                              "f_pipeline, nothing, (port0 | port1))
     
     (define_bypass 4 "float" "simple,mult,div")
</pre>
 <p>为了简化描述，我们可以描述下列保留

<pre class="smallexample">     (define_reservation "finish" "port0|port1")
</pre>
 <p>并在所有<code>define_insn_reservation</code>中使用，比如下面的结构

<pre class="smallexample">     (define_insn_reservation "simple" 2 (eq_attr "type" "int")
                              "(i0_pipeline | i1_pipeline), finish")
</pre>
 <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> 然而，自动机的大小依赖于处理器的复杂度。为了限制这种影响，
机器描述可以将机器描述的正交部分拆分成多个自动机：但是，
由于每个这样的自动机都必须独立的执行每一步，
所以这确实会在算法性能上造成一点消减。</p>

 <hr></div>

 </body></html>

