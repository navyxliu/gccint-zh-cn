<html lang="zh">
<head>
<title>类型 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Trees.html#Trees" title="Trees">
<link rel="prev" href="Tree_00e6_00a6_0082_00e8_00bf_00b0.html#Tree_00e6_00a6_0082_00e8_00bf_00b0" title="Tree概述">
<link rel="next" href="_00e4_00bd_009c_00e7_0094_00a8_00e5_009f_009f.html#g_t_00e4_00bd_009c_00e7_0094_00a8_00e5_009f_009f" title="作用域">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e7%b1%bb%e5%9e%8b"></a>
<a name="g_t_00e7_00b1_00bb_00e5_009e_008b"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e4_00bd_009c_00e7_0094_00a8_00e5_009f_009f.html#g_t_00e4_00bd_009c_00e7_0094_00a8_00e5_009f_009f">作用域</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Tree_00e6_00a6_0082_00e8_00bf_00b0.html#Tree_00e6_00a6_0082_00e8_00bf_00b0">Tree概述</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Trees.html#Trees">Trees</a>
<hr>
</div>

<h3 class="section">9.3 类型</h3>

<p><a name="index-type-1710"></a><a name="index-pointer-1711"></a><a name="index-reference-1712"></a><a name="index-fundamental-type-1713"></a><a name="index-array-1714"></a><a name="index-VOID_005fTYPE-1715"></a><a name="index-INTEGER_005fTYPE-1716"></a><a name="index-TYPE_005fMIN_005fVALUE-1717"></a><a name="index-TYPE_005fMAX_005fVALUE-1718"></a><a name="index-REAL_005fTYPE-1719"></a><a name="index-FIXED_005fPOINT_005fTYPE-1720"></a><a name="index-COMPLEX_005fTYPE-1721"></a><a name="index-ENUMERAL_005fTYPE-1722"></a><a name="index-BOOLEAN_005fTYPE-1723"></a><a name="index-POINTER_005fTYPE-1724"></a><a name="index-REFERENCE_005fTYPE-1725"></a><a name="index-FUNCTION_005fTYPE-1726"></a><a name="index-METHOD_005fTYPE-1727"></a><a name="index-ARRAY_005fTYPE-1728"></a><a name="index-RECORD_005fTYPE-1729"></a><a name="index-UNION_005fTYPE-1730"></a><a name="index-UNKNOWN_005fTYPE-1731"></a><a name="index-OFFSET_005fTYPE-1732"></a><a name="index-TYPENAME_005fTYPE-1733"></a><a name="index-TYPEOF_005fTYPE-1734"></a><a name="index-CP_005fTYPE_005fQUALS-1735"></a><a name="index-TYPE_005fUNQUALIFIED-1736"></a><a name="index-TYPE_005fQUAL_005fCONST-1737"></a><a name="index-TYPE_005fQUAL_005fVOLATILE-1738"></a><a name="index-TYPE_005fQUAL_005fRESTRICT-1739"></a><a name="index-TYPE_005fMAIN_005fVARIANT-1740"></a><a name="index-qualified-type-1741"></a><a name="index-TYPE_005fSIZE-1742"></a><a name="index-TYPE_005fALIGN-1743"></a><a name="index-TYPE_005fPRECISION-1744"></a><a name="index-TYPE_005fARG_005fTYPES-1745"></a><a name="index-TYPE_005fMETHOD_005fBASETYPE-1746"></a><a name="index-TYPE_005fPTRMEM_005fP-1747"></a><a name="index-TYPE_005fOFFSET_005fBASETYPE-1748"></a><a name="index-TREE_005fTYPE-1749"></a><a name="index-TYPE_005fCONTEXT-1750"></a><a name="index-TYPE_005fNAME-1751"></a><a name="index-TYPENAME_005fTYPE_005fFULLNAME-1752"></a><a name="index-TYPE_005fFIELDS-1753"></a><a name="index-TYPE_005fPTROBV_005fP-1754"></a><a name="index-TYPE_005fCANONICAL-1755"></a><a name="index-TYPE_005fSTRUCTURAL_005fEQUALITY_005fP-1756"></a><a name="index-SET_005fTYPE_005fSTRUCTURAL_005fEQUALITY-1757"></a>
所有的类型都有相应的树节点。
但是不要假设一个树节点就是正好对应于一个类型。
经常有多个节点对应于相同的类型。

 <p>在大多数情况下，不同种类的类型具有不同的树代码。
（例如，指针类型使用<code>POINTER_TYPE</code>代码，
而数组使用<code>ARRAY_TYPE</code>代码。）但是，
指向成员函数的指针使用<code>RECORD_TYPE</code>代码。
因此，当写与特定类型相关联的<code>switch</code>语句时，
应该在<code>RECORD_TYPE</code> case标签下小心处理指向成员函数的指针。

 <p>在C++中，数组类型没有被限定，而是数组元素的类型被限定。
这种情况反映在中间表示中。这里描述的宏在应用到数组类型时，
将总是检验元素类型的限定符。（如果元素类型本身是一个数组，
则会递归执行只到找到非数组类型，并检验该类型的限定符）所以，
例如，<code>CP_TYPE_CONST_P</code>当表示具有七个<code>int</code>的数组时，
将持有<code>const int ()[7]</code>类型。

 <p>下列函数和宏处理cv-qualification的类型：

     <dl>
<dt><code>CP_TYPE_QUALS</code><a name="index-CP_005fTYPE_005fQUALS-1758"></a><dd>该宏返回应用到该类型的类型限定符集。
如果没有应用限定符则该值为<code>TYPE_UNQUALIFIED</code>。
如果类型是<code>const</code>的，则会设置<code>TYPE_QUAL_CONST</code>位。
如果类型是<code>volatile</code>的，则会设置<code>TYPE_QUAL_VOLATILE</code>位。
如果类型是<code>restrict</code>的，则会设置<code>TYPE_QUAL_RESTRICT</code>位。

     <br><dt><code>CP_TYPE_CONST_P</code><a name="index-CP_005fTYPE_005fCONST_005fP-1759"></a><dd>该宏当类型是<code>const</code>时有效。

     <br><dt><code>CP_TYPE_VOLATILE_P</code><a name="index-CP_005fTYPE_005fVOLATILE_005fP-1760"></a><dd>该宏当类型是<code>volatile</code>时有效。

     <br><dt><code>CP_TYPE_RESTRICT_P</code><a name="index-CP_005fTYPE_005fRESTRICT_005fP-1761"></a><dd>该宏当类型是<code>restrict</code>时有效。

     <br><dt><code>CP_TYPE_CONST_NON_VOLATILE_P</code><a name="index-CP_005fTYPE_005fCONST_005fNON_005fVOLATILE_005fP-1762"></a><dd>该断言当类型是<code>const</code>的，但<em>不是</em><code>volatile</code>的时有效。
其它cv-qualifiers会被忽略，只测试<code>const</code>。

     <br><dt><code>TYPE_MAIN_VARIANT</code><a name="index-TYPE_005fMAIN_005fVARIANT-1763"></a><dd>该宏类型未限定的版本。可以用于一个未限定的类型，但这种情况下，
并不总是标识符函数。
</dl>

 <p>一些其它的宏和函数可用于所有的类型：
     <dl>
<dt><code>TYPE_SIZE</code><a name="index-TYPE_005fSIZE-1764"></a><dd>类型表示所需要的位数，为一个<code>INTEGER_CST</code>。
对于不完全类型，<code>TYPE_SIZE</code>将为<code>NULL_TREE</code>。

     <br><dt><code>TYPE_ALIGN</code><a name="index-TYPE_005fALIGN-1765"></a><dd>类型的对齐位数，为一个<code>int</code>。

     <br><dt><code>TYPE_NAME</code><a name="index-TYPE_005fNAME-1766"></a><dd>该宏返回类型的一个声明（按照<code>TYPE_DECL</code>的型式）。
（注意该宏不返回<code>IDENTIFIER_NODE</code>）
你可以查看<code>TYPE_DECL</code>的<code>DECL_NAME</code>来获得类型的实际的名字。
<code>TYPE_NAME</code>将为<code>NULL_TREE</code>，对于不是内建类型的，typedef的，
或者命名的class类型。

     <br><dt><code>CP_INTEGRAL_TYPE</code><a name="index-CP_005fINTEGRAL_005fTYPE-1767"></a><dd>该断言有效，如果类型为一个整数类型。注意在C++中，枚举<em>不是</em>整数类型。

     <br><dt><code>ARITHMETIC_TYPE_P</code><a name="index-ARITHMETIC_005fTYPE_005fP-1768"></a><dd>该断言有效，如果类型为一个整数类型（按照c++的观点）或者一个浮点类型。

     <br><dt><code>CLASS_TYPE_P</code><a name="index-CLASS_005fTYPE_005fP-1769"></a><dd>该断言有效，对于一个class类型。

     <br><dt><code>TYPE_BUILT_IN</code><a name="index-TYPE_005fBUILT_005fIN-1770"></a><dd>该断言有效，对于一个内建类型。

     <br><dt><code>TYPE_PTRMEM_P</code><a name="index-TYPE_005fPTRMEM_005fP-1771"></a><dd>该断言有效，如果类型为一个指向数据成员的指针。

     <br><dt><code>TYPE_PTR_P</code><a name="index-TYPE_005fPTR_005fP-1772"></a><dd>该断言有效，如果类型为一个指针，而指向者不是一个数据成员。

     <br><dt><code>TYPE_PTRFN_P</code><a name="index-TYPE_005fPTRFN_005fP-1773"></a><dd>该断言有效，对于一个执行函数类型的指针。

     <br><dt><code>TYPE_PTROB_P</code><a name="index-TYPE_005fPTROB_005fP-1774"></a><dd>该断言有效，对于一个指向object类型的指针。
注意其对于指向object类型<code>void *</code>的通用指针无效。
你可以使用<code>TYPE_PTROBV_P</code>来测试指针是指向object类型，
同时也是<code>void *</code>。

     <br><dt><code>TYPE_CANONICAL</code><a name="index-TYPE_005fCANONICAL-1775"></a><dd>该宏为给定的类型节点返回“正则”类型。正则类型用于C++和Objective-C的前端，使得在<code>same_type_p</code>中，可以对两个类型进行高效的比较，从而提高性能：如果类型的<code>TYPE_CANONICAL</code>值相等，则类型是等价的；否则，类型不相等。关于正则类型的相等的概念，与在语言中类型相等的概念是一样的。例如，

     <p>当<code>TYPE_CANONICAL</code>为<code>NULL_TREE</code>，则对于给定的类型节点，没有正则类型。这种情况下，比较该类型和任何其它类型，需要编译器执行深入的，“结构化的”比较，来看两个类型节点是否具有相同的形式和属性。

     <p>节点的正则类型，在等价的类型类别中，总是最根本的类型。例如，<code>int</code>为其自己的正则类型。<code>int</code>的自定义类型<code>I</code>，将<code>int</code>作为它的正则类型。类似的，<code>I*</code>和自定义类型<code>IP</code>（定义为<code>I*</code>），将<code>int*</code>作为它们的正则类型。当构建一个新的类型节点时，要记着将<code>TYPE_CANONICAL</code>设置为合适的正则类型。如果新类型为一个复合类型（从其它类型中构建的），并且那些类型中的任意一个需要进行结构化相等，则使用<code>SET_TYPE_STRUCTURAL_EQUALITY</code>来确保新的类型也需要结构化相等。最后，如果出于某种原因，你不能确保<code>TYPE_CANONICAL</code>能指向正则类型，则使用<code>SET_TYPE_STRUCTURAL_EQUALITY</code>来确保新的类型，任何基于它构建的类型，则需要结构化相等。如果你怀疑正则类型系统进行了错误的类型比较，则将<code>--param verify-canonical-types=1</code>传给编译器，或者使用<code>--enable-checking</code>来configure，强制编译器基于结构化比较来验证它的正则类型比较；如果正则类型比较有出入，则编译器将打印出警告信息。

     <br><dt><code>TYPE_STRUCTURAL_EQUALITY_P</code><a name="index-TYPE_005fSTRUCTURAL_005fEQUALITY_005fP-1776"></a><dd>当节点需要进行结构相等检查的时候，该断言成立，例如，当<code>TYPE_CANONICAL</code>为<code>NULL_TREE</code>时。

     <br><dt><code>SET_TYPE_STRUCTURAL_EQUALITY</code><a name="index-SET_005fTYPE_005fSTRUCTURAL_005fEQUALITY-1777"></a><dd>该宏规定给定的类型节点需要进行结构相等检查，例如，其将<code>TYPE_CANONICAL</code>设为<code>NULL_TREE</code>

     <br><dt><code>same_type_p</code><a name="index-same_005ftype_005fp-1778"></a><dd>该断言接受两个类型作为输入，如果它们为相同的类型，则判断成立。例如，如果一个类型为另一个类型的<code>typedef</code>，或者这两个都为同一个类型的<code>typedef</code>。如果作为输入给定的两个tree，只是简单的为另一个的复制，则该断言也成立；即，它们在源代码级别没有差别，但是，出于某种原因，在表示的时候进行了复制。不要用<code>==</code>（pointer equality）来比较类型；要用<code>same_type_p</code>。

 </dl>

 <p>下面详细介绍了各种类型，以及可以用来访问它们的宏。虽然有其它类型是在G++中用到，这里描述的类型将只是当你检查中间表示时会遇到的。

     <dl>
<dt><code>VOID_TYPE</code><dd>用于表示<code>void</code>类型。

     <br><dt><code>INTEGER_TYPE</code><dd>用来表示跟中整数类型，包括<code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>和<code>long long</code>。该代码不用于枚举类型和<code>bool</code>类型。<code>TYPE_PRECISION</code>为用于表示该类型的位数，是一个<code>unsigned int</code>。（注意，通常情况它的值与<code>TYPE_SIZE</code>不相同；假设有一个24位的整数类型，但是ABI要求32位的对齐方式。则，<code>TYPE_SIZE</code>将为一个<code>INTEGER_CST</code>，32，而<code>TYPE_PRECISION</code>为24。）如果<code>TYPE_UNSIGNED</code>成立，则整数类型为无符号的；否则为有符号的。

     <p><code>TYPE_MIN_VALUE</code>为一个<code>INTEGER_CST</code>，是该类型可以表示的最小整数。类似的，<code>TYPE_MAX_VALUE</code>为一个<code>INTEGER_CST</code>，是该类型可以表示的最大整数。

     <br><dt><code>REAL_TYPE</code><dd>用来表示类型<code>float</code>，<code>double</code>和<code>long double</code>。跟<code>INTEGER_TYPE</code>的情况类型，用于浮点表示的位数由<code>TYPE_PRECISION</code>给出。

     <br><dt><code>FIXED_POINT_TYPE</code><dd>用来表示类型<code>short _Fract</code>, <code>_Fract</code>, <code>long _Fract</code>, <code>long long _Fract</code>, <code>short _Accum</code>, <code>_Accum</code>, <code>long _Accum</code>, 和 <code>long long _Accum</code>。跟<code>INTEGER_TYPE</code>的情况类型，用于定点表示的位数由<code>TYPE_PRECISION</code>给出。可能会有填充位，小数位和整数位。小数的位数由<code>TYPE_FBIT</code>给出，整数的位数由<code>TYPE_IBIT</code>给出。如果<code>TYPE_UNSIGNED</code>成立，则定点类型为无符号的；否则为有符号的。

     <p>如果<code>TYPE_SATURATING</code>成立，则定点类型为饱和的；否则不是饱和的。。

     <br><dt><code>COMPLEX_TYPE</code><dd>用来表示GCC内建的<code>__complex__</code>数据类型。<code>TREE_TYPE</code>为实部和虚部的类型。

     <br><dt><code>ENUMERAL_TYPE</code><dd>用于表示枚举类型。<code>TYPE_PRECISION</code>给出了用于表示该类型的位数（为一个<code>int</code>）。如果没有负数的枚举常量，则<code>TYPE_UNSIGNED</code>成立。最小和最大的枚举常量，可以分别使用<code>TYPE_MIN_VALUE</code>和<code>TYPE_MAX_VALUE</code>获得；每个宏都返回一个<code>INTEGER_CST</code>。

     <p>实际的枚举常量可以通过查看<code>TYPE_VALUES</code>来获得。该宏将返回一个<code>TREE_LIST</code>，包含了常量；<code>TREE_VALUE</code>将为一个<code>INTEGER_CST</code>，给出了赋予那个常量的值。这些常量将按照它们被声明的顺序出现。每个常量的<code>TREE_TYPE</code>，将为枚举类型本身的类型。

     <br><dt><code>BOOLEAN_TYPE</code><dd>用来表示<code>bool</code>类型。

     <br><dt><code>POINTER_TYPE</code><dd>用来表示指针类型，以及指向数据成员的指针类型。<code>TREE_TYPE</code>给出了所指向的类型。如果类型为一个指向数据成员的指针，则<code>TYPE_PTRMEM_P</code>成立。对于一个指向&lsquo;<samp><span class="samp">T X::*</span></samp>&rsquo;形式的数据成员类型的指针，<code>TYPE_PTRMEM_CLASS_TYPE</code>将为类型<code>X</code>，而<code>TYPE_PTRMEM_POINTED_TO_TYPE</code>为类型<code>T</code>。

     <br><dt><code>REFERENCE_TYPE</code><dd>用来表示引用类型。<code>TREE_TYPE</code>给出了所引用的类型。

     <br><dt><code>FUNCTION_TYPE</code><dd>用来表示非成员函数和静态成员函数的类型。<code>TREE_TYPE</code>给出了函数的返回值类型。<code>TYPE_ARG_TYPES</code>为一个<code>TREE_LIST</code>，参数类型列表。该列表上的每个节点的<code>TREE_VALUE</code>为相应参数的类型；<code>TREE_PURPOSE</code>如果存在，则为缺省参数值的表达式。如果列表中的最后一个节点为<code>void_list_node</code>（一个<code>TREE_LIST</code>节点，其<code>TREE_VALUE</code>为<code>void_type_node</code>），则该类型的函数不接受可变参数。否则，它们是接受可变数目的参数。

     <p>注意，在C（而不是C++）中，一个声明如<code>void f()</code>的函数，为一个无函数原型的函数，其接受可变数目的参数；这样的函数的<code>TYPE_ARG_TYPES</code>将为<code>NULL</code>。

     <br><dt><code>METHOD_TYPE</code><dd>用来表示非静态成员函数的类型。像<code>FUNCTION_TYPE</code>一样，返回值由<code>TREE_TYPE</code>给出。<code>*this</code>的类型，即，这个函数成员所在的类的类型，由<code>TYPE_METHOD_BASETYPE</code>给出。<code>TYPE_ARG_TYPES</code>为参数列表，就像<code>FUNCTION_TYPE</code>一样，包含<code>this</code>参数。

     <br><dt><code>ARRAY_TYPE</code><dd>用于表示数组类型，<code>TREE_TYPE</code>给出了数组元素的类型。如果数组边界在类型中存在，则<code>TYPE_DOMAIN</code>为一个<code>INTEGER_TYPE</code>，它的<code>TYPE_MIN_VALUE</code>和<code>TYPE_MAX_VALUE</code>将分别为数组的下界和上界。<code>TYPE_MIN_VALUE</code>将总是为<code>INTEGER_CST</code>，0，而<code>TYPE_MAX_VALUE</code>将为数组元素数目减1，即可以用来索引数组元素的最大值。

     <br><dt><code>RECORD_TYPE</code><dd>用来表示<code>struct</code>和<code>class</code>类型，以及指向成员函数和其它语言中类似结构的指针。<code>TYPE_FIELDS</code>包含了该类型中包含的项，其可以为<code>FIELD_DECL</code>, <code>VAR_DECL</code>, <code>CONST_DECL</code>或<code>TYPE_DECL</code>。你不能假设类型中的域之间的顺序，以及它们是否有重叠。如果<code>TYPE_PTRMEMFUNC_P</code>成立，则该类型为一个指向成员（pointer-to-member）的类型。这种情况下，<code>TYPE_PTRMEMFUNC_FN_TYPE</code>为一个<code>POINTER_TYPE</code>，指向一个<code>METHOD_TYPE</code>。<code>METHOD_TYPE</code>为由pointer-to-member函数指向的函数的类型。如果<code>TYPE_PTRMEMFUNC_P</code>不成立，则该类型为一个class类型。更多信息，参见see <a href="Classes.html#Classes">Classes</a>。

     <br><dt><code>UNION_TYPE</code><dd>用来表示<code>union</code>类型。类似于<code>RECORD_TYPE</code>，只不过在<code>TYPE_FIELD</code>中的所有<code>FIELD_DECL</code>起始于0位。

     <br><dt><code>QUAL_UNION_TYPE</code><dd>用来表示Ada中的可变记录（variant record）的一部分。类似于<code>UNION_TYPE</code>，只不过每个<code>FIELD_DECL</code>具有一个<code>DECL_QUALIFIER</code>域，其包含了一个布尔表达式，用来指示该域是否在对象中存在。该类型将只有一个域，所以只有当<code>TYPE_FIELDS</code>中，先前的域中的表达式都不为零时，每个域的<code>DECL_QUALIFIER</code>才被求值。通常，这些表达式将使用<code>PLACEHOLDER_EXPR</code>引用外部对象的一个域。

     <br><dt><code>UNKNOWN_TYPE</code><dd>该节点用来表示一个类型，其信息不足以进行合理的处理。

     <br><dt><code>OFFSET_TYPE</code><dd>该节点用于表示一个pointer-to-data成员。对于一个数据成员<code>X::m</code>，则<code>TYPE_OFFSET_BASETYPE</code>为<code>X</code>，<code>TREE_TYPE</code>为 <code>m</code>类型.

     <br><dt><code>TYPENAME_TYPE</code><dd>用于表示<code>typename T::A</code>。<code>TYPE_CONTEXT</code>为<code>T</code>；<code>TYPE_NAME</code>为<code>A</code>的<code>IDENTIFIER_NODE</code>。如果类型通过模板id指定，则<code>TYPENAME_TYPE_FULLNAME</code>产生一个<code>TEMPLATE_ID_EXPR</code>。如果节点是被隐式的生成，用来支持隐式类型名扩展，则<code>TREE_TYPE</code>不为<code>NULL</code>；这种情况下，<code>TREE_TYPE</code>为基类的类型节点。

     <br><dt><code>TYPEOF_TYPE</code><dd>用于表示<code>__typeof__</code>扩展。<code>TYPE_FIELDS</code>为被表示的类型的表达式。
</dl>

 <p>有些变量，它们的值表示基本的类型。这包括：
     <dl>
<dt><code>void_type_node</code><dd><code>void</code>节点。

     <br><dt><code>integer_type_node</code><dd><code>int</code>节点。

     <br><dt><code>unsigned_type_node.</code><dd><code>unsigned int</code>节点。

     <br><dt><code>char_type_node.</code><dd><code>char</code>节点。
</dl>
 有时使用<code>same_type_p</code>将这些变量和手头的类型进行比较会很有帮助。

<!--  -->
<!-- Scopes -->
<!--  -->
 </body></html>

