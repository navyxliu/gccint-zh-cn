<html lang="zh">
<head>
<title>逻辑运算符 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0" title="操作数">
<link rel="prev" href="_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f.html#g_t_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f" title="条件表达式">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6"></a>
<a name="g_t_00e9_0080_00bb_00e8_00be_0091_00e8_00bf_0090_00e7_00ae_0097_00e7_00ac_00a6"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f.html#g_t_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f">条件表达式</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0">操作数</a>
<hr>
</div>

<h4 class="subsection">12.5.4 逻辑运算符</h4>

<p><a name="index-Logical-Operators-2685"></a>
Except when they appear in the condition operand of a
<code>GIMPLE_COND</code>, logical `and' and `or' operators are simplified
as follows: <code>a = b &amp;&amp; c</code> becomes

<pre class="smallexample">       T1 = (bool)b;
       if (T1 == true)
         T1 = (bool)c;
       a = T1;
</pre>
 <p>Note that <code>T1</code> in this example cannot be an expression temporary,
because it has two different assignments.

<h4 class="subsection">12.5.5 操作操作数</h4>

<p>All gimple operands are of type <code>tree</code>.  But only certain
types of trees are allowed to be used as operand tuples.  Basic
validation is controlled by the function
<code>get_gimple_rhs_class</code>, which given a tree code, returns an
<code>enum</code> with the following values of type <code>enum
gimple_rhs_class</code>

     <ul>
<li><code>GIMPLE_INVALID_RHS</code>
The tree cannot be used as a GIMPLE operand.

     <li><code>GIMPLE_BINARY_RHS</code>
The tree is a valid GIMPLE binary operation.

     <li><code>GIMPLE_UNARY_RHS</code>
The tree is a valid GIMPLE unary operation.

     <li><code>GIMPLE_SINGLE_RHS</code>
The tree is a single object, that cannot be split into simpler
operands (for instance, <code>SSA_NAME</code>, <code>VAR_DECL</code>, <code>COMPONENT_REF</code>, etc).

     <p>This operand class also acts as an escape hatch for tree nodes
that may be flattened out into the operand vector, but would need
more than two slots on the RHS.  For instance, a <code>COND_EXPR</code>
expression of the form <code>(a op b) ? x : y</code> could be flattened
out on the operand vector using 4 slots, but it would also
require additional processing to distinguish <code>c = a op b</code>
from <code>c = a op b ? x : y</code>.  Something similar occurs with
<code>ASSERT_EXPR</code>.   In time, these special case tree
expressions should be flattened into the operand vector. 
</ul>

 <p>For tree nodes in the categories <code>GIMPLE_BINARY_RHS</code> and
<code>GIMPLE_UNARY_RHS</code>, they cannot be stored inside tuples directly. 
They first need to be flattened and separated into individual
components.  For instance, given the GENERIC expression

<pre class="smallexample">     a = b + c
</pre>
 <p>its tree representation is:

<pre class="smallexample">     MODIFY_EXPR &lt;VAR_DECL  &lt;a&gt;, PLUS_EXPR &lt;VAR_DECL &lt;b&gt;, VAR_DECL &lt;c&gt;&gt;&gt;
</pre>
 <p>In this case, the GIMPLE form for this statement is logically
identical to its GENERIC form but in GIMPLE, the <code>PLUS_EXPR</code>
on the RHS of the assignment is not represented as a tree,
instead the two operands are taken out of the <code>PLUS_EXPR</code> sub-tree
and flattened into the GIMPLE tuple as follows:

<pre class="smallexample">     GIMPLE_ASSIGN &lt;PLUS_EXPR, VAR_DECL &lt;a&gt;, VAR_DECL &lt;b&gt;, VAR_DECL &lt;c&gt;&gt;
</pre>
 <h4 class="subsection">12.5.6 操作数向量分配</h4>

<p>The operand vector is stored at the bottom of the three tuple
structures that accept operands. This means, that depending on
the code of a given statement, its operand vector will be at
different offsets from the base of the structure.  To access
tuple operands use the following accessors

<div class="defun">
&mdash; GIMPLE function: unsigned <b>gimple_num_ops</b> (<var>gimple g</var>)<var><a name="index-gimple_005fnum_005fops-2686"></a></var><br>
<blockquote><p>Returns the number of operands in statement G. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: tree <b>gimple_op</b> (<var>gimple g, unsigned i</var>)<var><a name="index-gimple_005fop-2687"></a></var><br>
<blockquote><p>Returns operand <code>I</code> from statement <code>G</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: tree <b>*gimple_ops</b> (<var>gimple g</var>)<var><a name="index-g_t_002agimple_005fops-2688"></a></var><br>
<blockquote><p>Returns a pointer into the operand vector for statement <code>G</code>.  This
is computed using an internal table called <code>gimple_ops_offset_</code>[]. 
This table is indexed by the gimple code of <code>G</code>.

      <p>When the compiler is built, this table is filled-in using the
sizes of the structures used by each statement code defined in
gimple.def.  Since the operand vector is at the bottom of the
structure, for a gimple code <code>C</code> the offset is computed as sizeof
(struct-of <code>C</code>) - sizeof (tree).

      <p>This mechanism adds one memory indirection to every access when
using <code>gimple_op</code>(), if this becomes a bottleneck, a pass can
choose to memoize the result from <code>gimple_ops</code>() and use that to
access the operands. 
</p></blockquote></div>

<h4 class="subsection">12.5.7 操作数有效性</h4>

<p>When adding a new operand to a gimple statement, the operand will
be validated according to what each tuple accepts in its operand
vector.  These predicates are called by the
<code>gimple_&lt;name&gt;_set_...()</code>.  Each tuple will use one of the
following predicates (Note, this list is not exhaustive):

<div class="defun">
&mdash; GIMPLE function: is_gimple_operand <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2689"></a></var><br>
<blockquote><p>This is the most permissive of the predicates.  It essentially
checks whether t has a <code>gimple_rhs_class</code> of <code>GIMPLE_SINGLE_RHS</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_val <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2690"></a></var><br>
<blockquote><p>Returns true if t is a "GIMPLE value", which are all the
non-addressable stack variables (variables for which
<code>is_gimple_reg</code> returns true) and constants (expressions for which
<code>is_gimple_min_invariant</code> returns true). 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_addressable <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2691"></a></var><br>
<blockquote><p>Returns true if t is a symbol or memory reference whose address
can be taken. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_asm_val <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2692"></a></var><br>
<blockquote><p>Similar to <code>is_gimple_val</code> but it also accepts hard registers. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_call_addr <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2693"></a></var><br>
<blockquote><p>Return true if t is a valid expression to use as the function
called by a <code>GIMPLE_CALL</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_constant <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2694"></a></var><br>
<blockquote><p>Return true if t is a valid gimple constant. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_min_invariant <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2695"></a></var><br>
<blockquote><p>Return true if t is a valid minimal invariant.  This is different
from constants, in that the specific value of t may not be known
at compile time, but it is known that it doesn't change (e.g.,
the address of a function local variable). 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_min_invariant_address <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2696"></a></var><br>
<blockquote><p>Return true if t is an <code>ADDR_EXPR</code> that does not change once the
program is running. 
</p></blockquote></div>

<h4 class="subsection">12.5.8 语句有效性</h4>

<div class="defun">
&mdash; GIMPLE function: is_gimple_assign <b>(</b><var>gimple g</var>)<var><a name="index-g_t_0028-2697"></a></var><br>
<blockquote><p>Return true if the code of g is <code>GIMPLE_ASSIGN</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_call <b>(</b><var>gimple g</var>)<var><a name="index-g_t_0028-2698"></a></var><br>
<blockquote><p>Return true if the code of g is <code>GIMPLE_CALL</code>
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_assign_cast_p <b>(</b><var>gimple g</var>)<var><a name="index-g_t_0028-2699"></a></var><br>
<blockquote><p>Return true if g is a <code>GIMPLE_ASSIGN</code> that performs a type cast
operation
</p></blockquote></div>

 </body></html>

