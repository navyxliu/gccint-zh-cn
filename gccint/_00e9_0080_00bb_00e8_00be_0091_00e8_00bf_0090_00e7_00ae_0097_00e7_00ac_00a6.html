<html lang="zh">
<head>
<title>逻辑运算符 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0" title="操作数">
<link rel="prev" href="_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f.html#g_t_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f" title="条件表达式">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6"></a>
<a name="g_t_00e9_0080_00bb_00e8_00be_0091_00e8_00bf_0090_00e7_00ae_0097_00e7_00ac_00a6"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f.html#g_t_00e6_009d_00a1_00e4_00bb_00b6_00e8_00a1_00a8_00e8_00be_00be_00e5_00bc_008f">条件表达式</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0">操作数</a>
<hr>
</div>

<h4 class="subsection">12.5.4 逻辑运算符</h4>

<p><a name="index-Logical-Operators-2685"></a>
除非它们出现在<code>GIMPLE_COND</code>的条件操作数中，否则逻辑的`and'和`or'操作符将按照下列方式进行简化：<code>a = b &amp;&amp; c</code>变成

<pre class="smallexample">       T1 = (bool)b;
       if (T1 == true)
         T1 = (bool)c;
       a = T1;
</pre>
 <p>注意该例子中的<code>T1</code>不能为表达式临时对象，因为其具有两个不同的赋值。

<h4 class="subsection">12.5.5 操作操作数</h4>

<p>所有的gimple操作数都是<code>tree</code>类型的。不过只有特定类型的tree可以被用作操作数元组。函数<code>get_gimple_rhs_class</code>可以进行基本的验证，其给定一个tree代码，返回一个<code>enum</code>，为下列<code>enum gimple_rhs_class</code>类型的值

     <ul>
<li><code>GIMPLE_INVALID_RHS</code>
该tree不能用作GIMPLE操作数。

     <li><code>GIMPLE_BINARY_RHS</code>
该tree为一个有效的GIMPLE二元运算。

     <li><code>GIMPLE_UNARY_RHS</code>
该tree为一个有效的GIMPLE一元运算。

     <li><code>GIMPLE_SINGLE_RHS</code>
该tree为单个对象，不能被拆分成更简单的操作数（例如，<code>SSA_NAME</code>, <code>VAR_DECL</code>, <code>COMPONENT_REF</code>等等）。

     <p>该操作数类别还作为转义通口，对于那些可以被平整到操作数向量中，但是右手边会需要多于两个插槽的tree节点。例如，<code>(a op b) ? x : y</code>的<code>COND_EXPR</code>表达式，会被平整到使用4个插槽的操作数向量中，但是其还需要额外的处理来从<code>c = a op b ? x : y</code>中判断<code>c = a op b</code>。对于<code>ASSERT_EXPR</code>，也有类似的情况。这些特殊情况的tree表达式应该被平整到操作数向量中。
</ul>

 <p>对于在<code>GIMPLE_BINARY_RHS</code>和<code>GIMPLE_UNARY_RHS</code>类别中的tree节点，它们不能被直接存放在元组中。需要首先被平整，分隔到独立的部分。例如，给定GENERIC表达式

<pre class="smallexample">     a = b + c
</pre>
 <p>其tree表示为:

<pre class="smallexample">     MODIFY_EXPR &lt;VAR_DECL  &lt;a&gt;, PLUS_EXPR &lt;VAR_DECL &lt;b&gt;, VAR_DECL &lt;c&gt;&gt;&gt;
</pre>
 <p>这种情况下，该语句的GIMPLE形式逻辑上等同于它的GENERIC形式，但是在GIMPLE中，赋值语句的右手边<code>PLUS_EXPR</code>，不被表示成一个tree，替代的，<code>PLUS_EXPR</code>的两个操作数子树被拿出来，并平整到GIMPLE元组中，如下：

<pre class="smallexample">     GIMPLE_ASSIGN &lt;PLUS_EXPR, VAR_DECL &lt;a&gt;, VAR_DECL &lt;b&gt;, VAR_DECL &lt;c&gt;&gt;
</pre>
 <h4 class="subsection">12.5.6 操作数向量分配</h4>

<p>操作数向量被存放在三元组结构的底部。这意味着，取决于给定语句的代码，其操作数向量相对于基本结构体的偏移量会不同。使用下列方法来访问元组操作数

<div class="defun">
&mdash; GIMPLE function: unsigned <b>gimple_num_ops</b> (<var>gimple g</var>)<var><a name="index-gimple_005fnum_005fops-2686"></a></var><br>
<blockquote><p>返回语句<code>G</code>中的操作数个数。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: tree <b>gimple_op</b> (<var>gimple g, unsigned i</var>)<var><a name="index-gimple_005fop-2687"></a></var><br>
<blockquote><p>返回语句<code>G</code>的第<code>I</code>个操作数。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: tree <b>*gimple_ops</b> (<var>gimple g</var>)<var><a name="index-g_t_002agimple_005fops-2688"></a></var><br>
<blockquote><p>返回指向语句<code>G</code>的操作数向量的指针。这通过内部称作<code>gimple_ops_offset_</code>[]的表来计算。该表的索引为<code>G</code>的gimple代码。

      <p>当编译器被构建时，将gimple.def中定义的每个语句代码，所对应的结构体大小来填充该表。因为操作数向量在结构体的底部，所以对于gimple代码<code>C</code>，其偏移量被计算为sizeof (struct-of <code>C</code>) - sizeof (tree)。

      <p>该机制对于使用<code>gimple_op</code>()的每次访问，都增加了一个内存重定向，如果这会变成瓶颈，则编译过程可以选择记住<code>gimple_ops</code>()的结果，并使用它来访问操作数。
</p></blockquote></div>

<h4 class="subsection">12.5.7 操作数有效性</h4>

<p>当为gimple语句增加一个新的操作数，将根据每个元组在它操作数向量中可以接受的情况来验证该操作数。这些断言由<code>gimple_&lt;name&gt;_set_...()</code>调用。元组会使用下列断言（注意，该列表并不全）：

<div class="defun">
&mdash; GIMPLE function: is_gimple_operand <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2689"></a></var><br>
<blockquote><p>这是条件最宽的断言。其实质上是检查t是否具有<code>GIMPLE_SINGLE_RHS</code>的<code>gimple_rhs_class</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_val <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2690"></a></var><br>
<blockquote><p>返回真，如果t为一个“GIMPLE值”，其为所有非寻址的栈变量（<code>is_gimple_reg</code>返回真的变量）和常量（<code>is_gimple_min_invariant</code>返回真的表达式）。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_addressable <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2691"></a></var><br>
<blockquote><p>返回真，如果t为一个符号，或者内存引用，其地址可以被使用。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_asm_val <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2692"></a></var><br>
<blockquote><p>类似于<code>is_gimple_val</code>，不过其还接受硬件寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_call_addr <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2693"></a></var><br>
<blockquote><p>返回真，如果t为一个有效的表达式，被作用由<code>GIMPLE_CALL</code>调用的函数。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_constant <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2694"></a></var><br>
<blockquote><p>返回真，如果t为一个有效的gimple常量。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_min_invariant <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2695"></a></var><br>
<blockquote><p>返回真，如果t为一个有效的最小不变量。这与常量不同，其特定的值在编译的时候可能不已知，但是知道其不会改变（例如，函数局部变量的地址）。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_min_invariant_address <b>(</b><var>tree t</var>)<var><a name="index-g_t_0028-2696"></a></var><br>
<blockquote><p>返回真，如果t为一个<code>ADDR_EXPR</code>，其在程序运行时不会改变。
</p></blockquote></div>

<h4 class="subsection">12.5.8 语句有效性</h4>

<div class="defun">
&mdash; GIMPLE function: is_gimple_assign <b>(</b><var>gimple g</var>)<var><a name="index-g_t_0028-2697"></a></var><br>
<blockquote><p>返回真，如果g的代码为<code>GIMPLE_ASSIGN</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: is_gimple_call <b>(</b><var>gimple g</var>)<var><a name="index-g_t_0028-2698"></a></var><br>
<blockquote><p>返回真，如果g的代码为<code>GIMPLE_CALL</code>。
</p></blockquote></div>

<div class="defun">
&mdash; GIMPLE function: gimple_assign_cast_p <b>(</b><var>gimple g</var>)<var><a name="index-g_t_0028-2699"></a></var><br>
<blockquote><p>返回真，如果g为一个<code>GIMPLE_ASSIGN</code>并执行一个类型转换操作。
</p></blockquote></div>

 </body></html>

