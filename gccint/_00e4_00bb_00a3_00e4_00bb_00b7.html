<html lang="zh">
<head>
<title>代价 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="_00e6_009d_00a1_00e4_00bb_00b6_00e4_00bb_00a3_00e7_00a0_0081.html#g_t_00e6_009d_00a1_00e4_00bb_00b6_00e4_00bb_00a3_00e7_00a0_0081" title="条件代码">
<link rel="next" href="_00e8_00b0_0083_00e5_00ba_00a6.html#g_t_00e8_00b0_0083_00e5_00ba_00a6" title="调度">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e4%bb%a3%e4%bb%b7"></a>
<a name="g_t_00e4_00bb_00a3_00e4_00bb_00b7"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e8_00b0_0083_00e5_00ba_00a6.html#g_t_00e8_00b0_0083_00e5_00ba_00a6">调度</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_009d_00a1_00e4_00bb_00b6_00e4_00bb_00a3_00e7_00a0_0081.html#g_t_00e6_009d_00a1_00e4_00bb_00b6_00e4_00bb_00a3_00e7_00a0_0081">条件代码</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.17 描述操作的相对代价</h3>

<p><a name="index-costs-of-instructions-4219"></a><a name="index-relative-costs-4220"></a><a name="index-speed-of-instructions-4221"></a>
这些宏让你描述target机器上各种操作的相对速度。

<div class="defun">
&mdash; Macro: <b>REGISTER_MOVE_COST</b> (<var>mode, from, to</var>)<var><a name="index-REGISTER_005fMOVE_005fCOST-4222"></a></var><br>
<blockquote><p>一个C表达式，
为从寄存器类别<var>from</var>到类别<var>to</var>移动模式为<var>mode</var>的数据的代价。
类别使用枚举值表示，例如<code>GENERAL_REGS</code>。缺省值为2；其它值相对于它来解析。

      <p>当<var>from</var>与<var>to</var>相同时，并不要求代价总是为2；在一些机器上，
如果不是通用寄存器，则寄存器之间的移动代价是昂贵的。

      <p>如果重载遇到一个insn，由两个硬件寄存器之间的单个<code>set</code>组成，
并且如果<code>REGISTER_MOVE_COST</code>应用到它们的类别上返回2，
则重载不检查insn的约束是否满足。将代价设为2以外的值将允许重载验证约束是否满足。
如果&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;模式的约束不允许这样的复制，则你应该这样做。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MEMORY_MOVE_COST</b> (<var>mode, class, in</var>)<var><a name="index-MEMORY_005fMOVE_005fCOST-4223"></a></var><br>
<blockquote><p>一个C表达式，
为在寄存器类别<var>class</var>和内存之间移动模式为<var>mode</var>的数据的代价；
<var>in</var>为0，如果值要被写到内存中，非0，如果要从内存中读进。
该代价为<code>REGISTER_MOVE_COST</code>的相对值。
如果在寄存器和内存间移动比两个寄存器之间更昂贵，则应该定义该宏来表示相对代价。

      <p>如果你没有定义该宏，如果需要的话，
则GCC使用缺省值4加上通过第二个重载寄存器复制的代价。
如果你的机器需要第二个重载寄存器在内存和寄存器类别<var>class</var>直接复制，
但是重载机制比通过中间物质复制更复杂，则定义该宏来反映move的实际代价。

      <p>GCC定义函数<code>memory_move_secondary_cost</code>，如果需要第二次重载。
其根据通过第二个寄存器复制来计算代价。
如果你的机器使用第二个寄存器按照约定的方式从内存中复制，
但是缺省值4对你的机器不正确，则定义该宏来增加某个其它值作为那个函数的结果。
函数的参数与该宏相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BRANCH_COST</b> (<var>speed_p, predictable_p</var>)<var><a name="index-BRANCH_005fCOST-4224"></a></var><br>
<blockquote><p>一个C表达式，为分支指令的代价。缺省值为1；其它值相对于它来解析。
</p></blockquote></div>

 <p>这些是额外的宏，其不指定确切的相对代价，而只是指定特定的动作比GCC通常期望的要昂贵。

<div class="defun">
&mdash; Macro: <b>SLOW_BYTE_ACCESS</b><var><a name="index-SLOW_005fBYTE_005fACCESS-4225"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，如果访问小于一个字的内存
（即<code>char</code>或者<code>short</code>）不如访问一个字的内存快，即，
如果这样的访问需要多于一条的指令，并且如果字节和（对齐的）字加载的代价没有区别，
则值为非零。

      <p>当该宏没有被定义，则编译器将通过找到最小的包含对象来访问一个域；当其被定义，
如果允许对齐，则会使用全字的加载。除非字节访问比字访问快，则使用字访问比较好，
因为其可以消除后续的内存访问，如果后续的访问发生在结构体的相同字的其它域。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SLOW_UNALIGNED_ACCESS</b> (<var>mode, alignment</var>)<var><a name="index-SLOW_005fUNALIGNED_005fACCESS-4226"></a></var><br>
<blockquote><p>定义该宏的值为1，
如果由<var>mode</var>和<var>alignment</var>参数描述的内存访问比对齐的访问具有多倍的代价，
例如如果它们在陷阱处理中被模拟。

      <p>当该宏为非0时，编译器在为块移动生成代码时，
将按照<code>STRICT_ALIGNMENT</code>为非0的方式执行。这可以引起相当多的指令被产生。
因此如果非对齐访问只是增加一个周期或者两个，则不要设置该宏为非零。

      <p>如果该宏的值总是0，则不需要被定义。如果该宏被定义，其应该产生一个非0值，
当<code>STRICT_ALIGNMENT</code>非0时。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_RATIO</b><var><a name="index-MOVE_005fRATIO-4227"></a></var><br>
<blockquote><p>标量的内存到内存的move insn的临界数，<em>低于</em>其值的时候，
应该生成一个insn序列，而不是字符串move insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

      <p>注意在一些机器上，对应的move insn为一个<code>define_expand</code>，
其产生一个insn序列，则该宏为该序列的个数。

      <p>如果没有定义，则会使用一个合理的缺省值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-MOVE_005fBY_005fPIECES_005fP-4228"></a></var><br>
<blockquote><p>一个C表达式，用于确定是否使用<code>move_by_pieces</code>来复制一块内存，
或者使用其它某种块移动机制。缺省为1，
如果<code>move_by_pieces_ninsns</code>返回值小于<code>MOVE_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_MAX_PIECES</b><var><a name="index-MOVE_005fMAX_005fPIECES-4229"></a></var><br>
<blockquote><p>一个C表达式，
由<code>move_by_pieces</code>使用用于确定load或者store用于复制内存的最大单元。
缺省为<code>MOVE_MAX</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CLEAR_RATIO</b><var><a name="index-CLEAR_005fRATIO-4230"></a></var><br>
<blockquote><p>标量move insn的临界数，<em>低于</em>其值时，应该生成一个insn序列来清除内存，
而不是字符串clear insn或者库调用。增加值将总是使得代码更快，
但是会最终由于代码大小的增加而产生高的代价。

      <p>如果没有定义，则会使用一个合理的缺省值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CLEAR_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-CLEAR_005fBY_005fPIECES_005fP-4231"></a></var><br>
<blockquote><p>一个C表达式，用于确定是否使用<code>clear_by_pieces</code>来清除一块内存，
或者使用其它块清楚机制。缺省为1，
如果<code>move_by_pieces_ninsns</code>返回值小于<code>CLEAR_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SET_RATIO</b><var><a name="index-SET_005fRATIO-4232"></a></var><br>
<blockquote><p>标量move insn的临界数，<em>低于</em>其值时，
应该生成一个insn序列来将内存设为一个常量值，而不是一个块设置insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

      <p>如果没有定义，缺省值为<code>MOVE_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SET_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-SET_005fBY_005fPIECES_005fP-4233"></a></var><br>
<blockquote><p>一个C表达式用来确定是否使用<code>store_by_pieces</code>来设置内存块为常量值，
或者使用其它机制。当存储非常数0的值时，由<code>__builtin_memset</code>使用。
缺省为1，如果<code>move_by_pieces_ninsns</code>返回值小于<code>SET_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STORE_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-STORE_005fBY_005fPIECES_005fP-4234"></a></var><br>
<blockquote><p>一个C表达式用来确定是否使用<code>store_by_pieces</code>来设置内存块为常量字符串，
或者使用其它的机制。当使用常量源字符串调用时，被<code>__builtin_strcpy</code>使用。
缺省为1，如果<code>move_by_pieces_ninsns</code>返回值小于<code>MOVE_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_POST_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPOST_005fINCREMENT-4235"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，后增加载是否好。
缺省值为<code>HAVE_POST_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_POST_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPOST_005fDECREMENT-4236"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，后减加载是否好。
缺省值为<code>HAVE_POST_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_PRE_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPRE_005fINCREMENT-4237"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，前增加载是否好。
缺省值为<code>HAVE_PRE_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_PRE_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPRE_005fDECREMENT-4238"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，前减加载是否好。
缺省值为<code>HAVE_PRE_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_POST_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPOST_005fINCREMENT-4239"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，后增存储是否好。
缺省值为<code>HAVE_POST_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_POST_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPOST_005fDECREMENT-4240"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，后减存储是否好。
缺省值为<code>HAVE_POST_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_PRE_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPRE_005fINCREMENT-4241"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，前增存储是否好。
缺省值为<code>HAVE_PRE_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_PRE_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPRE_005fDECREMENT-4242"></a></var><br>
<blockquote><p>一个C表达式用于确定对于给定的mode，前减存储是否好。
缺省值为<code>HAVE_PRE_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_FUNCTION_CSE</b><var><a name="index-NO_005fFUNCTION_005fCSE-4243"></a></var><br>
<blockquote><p>定义该宏，如果调用常量函数地址要比调用保存在寄存器中的地址好些。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>RANGE_TEST_NON_SHORT_CIRCUIT</b><var><a name="index-RANGE_005fTEST_005fNON_005fSHORT_005fCIRCUIT-4244"></a></var><br>
<blockquote><p>定义该宏，如果由&lsquo;<samp><span class="samp">fold_range_test ()</span></samp>&rsquo;产生的non-short-circuit操作为可选的。
该宏缺省为真，如果<code>BRANCH_COST</code>大于或等于2。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_RTX_COSTS</b> (<var>rtx x, int code, int outer_code, int *total</var>)<var><a name="index-TARGET_005fRTX_005fCOSTS-4245"></a></var><br>
<blockquote><p>该target钩子描述了RTL表达式的相对代价。

      <p>代价可以依赖于表达式的确切形式，可以通过检查<var>x</var>来获得表达式的形式，
表达式包含的rtx的代码为<var>outer_code</var>。<var>code</var>为表达式代码，冗余的，
因为其可以使用<code>GET_CODE (</code><var>x</var><code>)</code>获得。

      <p>实现该钩子时，
你可以使用结构<code>COSTS_N_INSNS (</code><var>n</var><code>)</code>来指定代价等价于<var>n</var>个指令。

      <p>在钩子的入口处，<code>*</code><var>total</var>包含了缺省的表达式代价的估值。需要的话，
钩子应该修改该值。传统的，缺省代价对于乘法为<code>COSTS_N_INSNS (5)</code>，
对于除法和求模为<code>COSTS_N_INSNS (7)</code>，
对于其它操作为<code>COSTS_N_INSNS (1)</code>。

      <p>当优化代码大小时，即，当<code>optimize_size</code>非0时，
该target钩子应该用于估计一个表达式的相对大小代价，
同样也是相对于<code>COSTS_N_INSNS</code>。

      <p>钩子返回真，当所有<var>x</var>的子表达式都被处理，当<code>rtx_cost</code>应该递归时返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_ADDRESS_COST</b> (<var>rtx address</var>)<var><a name="index-TARGET_005fADDRESS_005fCOST-4246"></a></var><br>
<blockquote><p>该钩子计算包含<var>address</var>的寻址模式的代价。如果没有定义，
代价通过<var>address</var>表达式和<code>TARGET_RTX_COST</code>钩子来计算。

      <p>对于大多数CISC机器，缺省代价为寻址模式的真实代价的合理近似值。
然而，在RISC机器上，所有指令通常具有相同的长度和执行时间。
因此所有寻址将具有相等的代价。

      <p>对于多于一个的形式的寻址，将会使用最低代价的形式。
如果多个形式具有相同的，最低的代价，则使用最复杂的。

      <p>例如，假设地址等于寄存器和常量的和，并在同一基本块中使用两次。
当该宏没有被定义，地址将在寄存器中计算，并且内存引用将通过寄存器间接实现。
在一些机器上，包含该和的寻址模式的代价不比简单的间接引用高，
这样则会产生一条额外的指令，并且可能需要一个额外的寄存器。
对该宏进行合适的指定，会消除这样的情况。

      <p>该钩子从不会被无效地址调用。

      <p>在一些机器上，地址包括多于一个寄存器的代价，
跟只包含一个寄存器的地址计算代价一样低，
则定义<code>TARGET_ADDRESS_COST</code>来反映这种情况，
可以使得两个寄存器在代码域中为活跃的，如果没有定义则可能只有一个为活跃的。
这种效果在定义该宏时应该被考虑。
可能只有对于有大量寄存器的机器才可能会有相等的代价。
</p></blockquote></div>

 </body></html>

