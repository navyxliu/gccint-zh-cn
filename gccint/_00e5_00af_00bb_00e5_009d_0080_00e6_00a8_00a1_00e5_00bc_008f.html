<html lang="zh">
<head>
<title>寻址模式 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="_00e5_00ba_0093_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e5_00ba_0093_00e8_00b0_0083_00e7_0094_00a8" title="库调用">
<link rel="next" href="Anchored_00e5_009c_00b0_00e5_009d_0080.html#Anchored_00e5_009c_00b0_00e5_009d_0080" title="Anchored地址">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f"></a>
<a name="g_t_00e5_00af_00bb_00e5_009d_0080_00e6_00a8_00a1_00e5_00bc_008f"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Anchored_00e5_009c_00b0_00e5_009d_0080.html#Anchored_00e5_009c_00b0_00e5_009d_0080">Anchored地址</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00ba_0093_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e5_00ba_0093_00e8_00b0_0083_00e7_0094_00a8">库调用</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.14 寻址模式</h3>

<p><a name="index-addressing-modes-4167"></a>
<!-- prevent bad page break with this line -->
这是关于寻址模式的宏。

<div class="defun">
&mdash; Macro: <b>HAVE_PRE_INCREMENT</b><var><a name="index-HAVE_005fPRE_005fINCREMENT-4168"></a></var><br>
&mdash; Macro: <b>HAVE_PRE_DECREMENT</b><var><a name="index-HAVE_005fPRE_005fDECREMENT-4169"></a></var><br>
&mdash; Macro: <b>HAVE_POST_INCREMENT</b><var><a name="index-HAVE_005fPOST_005fINCREMENT-4170"></a></var><br>
&mdash; Macro: <b>HAVE_POST_DECREMENT</b><var><a name="index-HAVE_005fPOST_005fDECREMENT-4171"></a></var><br>
<blockquote><p>一个C表达式，为非0，如果机器分别支持前增，前减，后增，或者后减寻址。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HAVE_PRE_MODIFY_DISP</b><var><a name="index-HAVE_005fPRE_005fMODIFY_005fDISP-4172"></a></var><br>
&mdash; Macro: <b>HAVE_POST_MODIFY_DISP</b><var><a name="index-HAVE_005fPOST_005fMODIFY_005fDISP-4173"></a></var><br>
<blockquote><p>一个C表达式，非零，如果机器支持pre-或者post-address，
除了生成内存操作数的大小以外，还有常量副作用生成。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HAVE_PRE_MODIFY_REG</b><var><a name="index-HAVE_005fPRE_005fMODIFY_005fREG-4174"></a></var><br>
&mdash; Macro: <b>HAVE_POST_MODIFY_REG</b><var><a name="index-HAVE_005fPOST_005fMODIFY_005fREG-4175"></a></var><br>
<blockquote><p>一个C表达式，非零，如果机器支持pre-或者post-address，
除了生成内存操作数的大小以外，还有寄存器置换的副作用生成。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONSTANT_ADDRESS_P</b> (<var>x</var>)<var><a name="index-CONSTANT_005fADDRESS_005fP-4176"></a></var><br>
<blockquote><p>一个C表达式，为1，如果RTX <var>x</var>为一个常量，其为一个有效地址。
在大多数机器上，这可以被定义为<code>CONSTANT_P (</code><var>x</var><code>)</code>，
但一些机器在支持哪些常量地址方面更加严格。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONSTANT_P</b> (<var>x</var>)<var><a name="index-CONSTANT_005fP-4177"></a></var><br>
<blockquote><p><code>CONSTANT_P</code>，其由target无关代码定义，接受整数值表达式，
其值不被显示的知道，例如<code>symbol_ref</code>, <code>label_ref</code>，<code>high</code>表达式，
以及<code>const</code>算术表达式，<code>const_int</code>和<code>const_double</code>表达式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_REGS_PER_ADDRESS</b><var><a name="index-MAX_005fREGS_005fPER_005fADDRESS-4178"></a></var><br>
<blockquote><p>一个数，为可以出现在一个有效的内存地址中的最大寄存器编号。
注意需要你来指定<code>GO_IF_LEGITIMATE_ADDRESS</code>应该能够接受的等于该最大值的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GO_IF_LEGITIMATE_ADDRESS</b> (<var>mode, x, label</var>)<var><a name="index-GO_005fIF_005fLEGITIMATE_005fADDRESS-4179"></a></var><br>
<blockquote><p>一个C复合语句，带有条件<code>goto </code><var>label</var><code>;</code>；
如果对于一个模式为<var>mode</var>的内存操作数，
<var>x</var>（一个RTX）为一个在target机器上的合法内存地址时，被执行。

      <p>通常定义多个相对简单的宏来作为该宏的子程序。否则其可能会太复杂，难以理解。

      <p>该宏必须按照两种方式退出：一种严格的方式和一种非严格的。严格的方式用于重载阶段。
其必须被定义，以便任何没有被分配硬件寄存器的伪寄存器被作为内存引用考虑。
在需要某种寄存器的上下文中，一个没有硬件寄存器的伪寄存器必须被拒绝。

      <p>非严格的方式用于其它过程。其必须被定义来接受所有伪寄存器，
在每个需要某种寄存器的上下文中。

      <p><a name="index-REG_005fOK_005fSTRICT-4180"></a>想要使用该宏的严格方式的编译器源文件定义宏<code>REG_OK_STRICT</code>。
你应该使用一个<code>#ifdef REG_OK_STRICT</code>条件来定义严格方式，反之定义非严格的。

      <p>出于不同目的（对于基址寄存器，对于索引寄存器等等）来检查可接受的寄存器的子程序通常用于定义<code>GO_IF_LEGITIMATE_ADDRESS</code>。
那么只有这些子程序宏需要这两种方式；高级别的宏对于严格的或者不严格的可以相同。

      <p>通常常量地址，其为一个<code>symbol_ref</code>和一个整数的和，
被存储在一个<code>const</code> RTX中，来标记它们为一个常量。
因此，不需要专门识别这样的和是否为合法地址。
通常你应该简化识别任何合法的<code>const</code>。

      <p>通常<code>PRINT_OPERAND_ADDRESS</code>不准备处理没有标记为<code>const</code>的常量和。
其假设<code>plus</code>表示为索引。如果是这样，
你<em>必须</em>作为非法地址来拒绝这样的常量sum，
以便不会提供给<code>PRINT_OPERAND_ADDRESS</code>。

      <p><a name="index-g_t_0040code_007bTARGET_005fENCODE_005fSECTION_005fINFO_007d-and-address-validation-4181"></a>在一些机器上，一个符号地址是否为合法的，依赖于地址所引用的section。
在这些机器上，定义target钩子<code>TARGET_ENCODE_SECTION_INFO</code>来将信息存储
到<code>symbol_ref</code>中，然后在此处检查。当你遇到一个<code>const</code>，
你将必须查看内部，来找到<code>symbol_ref</code>，以便确定section。参见<a href="_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f.html#g_t_00e6_00b1_0087_00e7_00bc_0096_00e6_00a0_00bc_00e5_00bc_008f">汇编格式</a>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_MEM_CONSTRAINT</b><var><a name="index-TARGET_005fMEM_005fCONSTRAINT-4182"></a></var><br>
<blockquote><p>A single character to be used instead of the default <code>'m'</code>
character for general memory addresses.  This defines the constraint
letter which matches the memory addresses accepted by
<code>GO_IF_LEGITIMATE_ADDRESS_P</code>.  Define this macro if you want to
support new address formats in your back end without changing the
semantics of the <code>'m'</code> constraint.  This is necessary in order to
preserve functionality of inline assembly constructs using the
<code>'m'</code> constraint. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FIND_BASE_TERM</b> (<var>x</var>)<var><a name="index-FIND_005fBASE_005fTERM-4183"></a></var><br>
<blockquote><p>一个C表达式，用来确定地址<var>x</var>的base term。该宏只在两个地方使用：
<samp><span class="file">alias.c</span></samp>的<code>find_base_value</code>和 <code>find_base_term</code>。

      <p>不定义该宏也总是安全的。它的存在是为了别名分析可以理解机器相关的地址。

      <p>该宏的典型用法是处理在UNSPEC中包含label_ref或symbol_ref的地址。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LEGITIMIZE_ADDRESS</b> (<var>x, oldx, mode, win</var>)<var><a name="index-LEGITIMIZE_005fADDRESS-4184"></a></var><br>
<blockquote><p>一个c复合语句，对于模式为<var>mode</var>的操作数，
尝试使用有效的内存地址来替换<var>x</var>。<var>win</var>为代码中某处的一个c语句标号；
宏定义可以使用

     <pre class="smallexample">          GO_IF_LEGITIMATE_ADDRESS (<var>mode</var>, <var>x</var>, <var>win</var>);
</pre>
      <p class="noindent">来避免进一步的处理，如果地址已经变为合法的。

      <p><a name="index-break_005fout_005fmemory_005frefs-4185"></a><var>x</var>总是为调用<code>break_out_memory_refs</code>的结果，
<var>oldx</var>将为传给那个函数来生成<var>x</var>的操作数。

      <p>该宏生成的代码不应该修改<var>x</var>的子结构。
如果其将<var>x</var>转换为一个更加合法的形式，
其应该为<var>x</var>（其总为一个c变量）赋予一个新的值。

      <p>该宏不必要产生一个合法的地址。编译器具有做这件事的标准方法。
实际上省略掉该宏是安全的。但是通常机器相关的策略可以产生更好的代码。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LEGITIMIZE_RELOAD_ADDRESS</b> (<var>x, mode, opnum, type, ind_levels, win</var>)<var><a name="index-LEGITIMIZE_005fRELOAD_005fADDRESS-4186"></a></var><br>
<blockquote><p>一条C复合语句，其尝试使用一个机器模式为<var>mode</var>的操作数的有效内存地址，
来替换地址需要重载的<var>x</var>。<var>win</var>为代码中的一个C语句标号。
不必要定义该宏，但其可能会对性能有帮助。

      <p>例如，在i386上，有时可能通过将两个伪寄存器的和重载到一个寄存器中，
从而只使用一个重载寄存器，而不是两个。另一方面，
许多RISC处理器的偏移量是有限制的，使得经常要生成一个中间地址来寻址一个栈槽。
通过适当的定义<code>LEGITIMIZE_RELOAD_ADDRESS</code>，
为邻近的一些栈槽生成的中间地址可以为同一个，实现共享。

      <p>注意：该宏应该慎重使用。有必要了解重载是如何工作的，以便有效的使用该宏。

      <p>注意：该宏必须能够重载由该宏的之前调用所创建的地址。
如果不能处理这样的地址，则编译器可能会产生不正确的代码或者中断退出。

      <p><a name="index-push_005freload-4187"></a>宏定义应该使用<code>push_reload</code>来指示需要重载的部分；
<var>opnum</var>，<var>type</var>和<var>ind_levels</var>通常无需更改而直接传给<code>push_reload</code>。

      <p>该宏生成的代码必须不要修改<var>x</var>的子结构体。如果其将<var>x</var>转换成更合法的形式，
则其必须为<var>x</var>（其总为一个c变量）赋予一个新的值。
这也通常应用于你通过调用<code>push_reload</code>而间接改变的部分。

      <p><a name="index-strict_005fmemory_005faddress_005fp-4188"></a>宏定义可以使用<code>strict_memory_address_p</code>来测试地址是否已经为合法的。

      <p><a name="index-copy_005frtx-4189"></a>如果你只想改变<var>x</var>的一部分，一种标准的方法是使用<code>copy_rtx</code>。
但是注意，其只与rtl同一级不共享。因此，如果改变的部分不在顶层，
则你要首先替换顶层。

      <p>该宏不必要产生一个合法的地址；但是通常机器相关的策略可以产生更好的代码。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GO_IF_MODE_DEPENDENT_ADDRESS</b> (<var>addr, label</var>)<var><a name="index-GO_005fIF_005fMODE_005fDEPENDENT_005fADDRESS-4190"></a></var><br>
<blockquote><p>一条C语句或者复合语句，具有一个条件<code>goto </code><var>label</var><code>;</code>；
当内存地址<var>x</var>（一个RTX）可以具有不同的含义，
该含义取决于内存引用的机器模式时，被执行。

      <p>自动递增和自动递减地址通常具有机器模式相关的效果，
因为递增或递减的数量为被寻址的操作数的大小。
一些机器具有其它机器模式相关的地址。许多RISC机器没有机器模式相关的地址。

      <p>你可以假设<var>addr</var>对于机器是一个有效的地址。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LEGITIMATE_CONSTANT_P</b> (<var>x</var>)<var><a name="index-LEGITIMATE_005fCONSTANT_005fP-4191"></a></var><br>
<blockquote><p>一个C表达式，如果<var>x</var>对于target机器上的一个立即操作数为合法的常量，
则为非0。你可以假设<var>x</var>满足<code>CONSTANT_P</code>，所以不需要进行检查。
实际上，在任何<code>CONSTANT_P</code>都是有效的机器上，为该宏定义为&lsquo;<samp><span class="samp">1</span></samp>&rsquo;是合适的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_DELEGITIMIZE_ADDRESS</b> (<var>rtx x</var>)<var><a name="index-TARGET_005fDELEGITIMIZE_005fADDRESS-4192"></a></var><br>
<blockquote><p>该钩子用于撤销<code>LEGITIMIZE_ADDRESS</code>和<code>LEGITIMIZE_RELOAD_ADDRESS</code> target
宏可能造成的模糊效果。这些宏的一些后端实现，
将符号引用包含在一个<code>UNSPEC</code> rtx中来表示PIC或者类似的寻址模式。
该target钩子允许GCC的优化器来理解这些透明的<code>UNSPEC</code>的语义，
通过将它们转换回到它们最初的形式。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CANNOT_FORCE_CONST_MEM</b> (<var>rtx x</var>)<var><a name="index-TARGET_005fCANNOT_005fFORCE_005fCONST_005fMEM-4193"></a></var><br>
<blockquote><p>该钩子应该返回真，如果<var>x</var>不能够（或不应该）被溢出到常量池中。
该钩子的缺省版本返回假。

      <p>定义该钩子的主要原因是阻止重载决定将一个不合法的常量从常量池中重载，
而不是溢出并重载一个寄存器来保存常量。对于不同的target，
该限制对于TLS符号的地址常常是真。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_USE_BLOCKS_FOR_CONSTANT_P</b> (<var>enum machine_mode mode, rtx x</var>)<var><a name="index-TARGET_005fUSE_005fBLOCKS_005fFOR_005fCONSTANT_005fP-4194"></a></var><br>
<blockquote><p>该钩子应该返回真，
如果常量<var>x</var>的池实体（pool entries）可以放在一个<code>object_block</code>结构体中。
<var>mode</var>为<var>x</var>的机器模式。

      <p>缺省版本为所有的常量返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_BUILTIN_RECIPROCAL</b> (<var>enum tree_code fn, bool tm_fn, bool sqrt</var>)<var><a name="index-TARGET_005fBUILTIN_005fRECIPROCAL-4195"></a></var><br>
<blockquote><p>该钩子应该返回一个函数的decl，该函数实现了代码为<var>fn</var>的内建函数的倒数，
或者如果没有这样的函数，则返回<code>NULL_TREE</code>。
当<var>fn</var>为一个机器相关的内建函数的代码时，<var>tm_fn</var>为真。
当<var>sqrt</var>为真时，只对平方根函数进行额外的优化，
并且只有<var>sqrt</var>函数的倒数可用。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD</b> (<var>void</var>)<var><a name="index-TARGET_005fVECTORIZE_005fBUILTIN_005fMASK_005fFOR_005fLOAD-4196"></a></var><br>
<blockquote><p>该钩子应该返回一个函数<var>f</var>的decl，给定一个地址<var>addr</var>作为参数，
该函数返回一个掩码<var>m</var>，在<var>addr</var>没有被适当的对齐时，
其可以用于从两个向量中抽取位于<var>addr</var>中的相关数据。

      <p>自动向量化，当向量化一个加载操作，且地址<var>addr</var>可以没有对齐，
则会生成两个向量加载，从<var>addr</var>附件的两个对齐的地址。
其然后生成一个<code>REALIGN_LOAD</code>操作，来从两个加载的向量中抽取相关数据。
<code>REALIGN_LOAD</code>的前两个参数，<var>v1</var>和<var>v2</var>，为两个向量，
每个的大小为<var>VS</var>，第三个参数，<var>OFF</var>，定义了数据如何从这两个向量中抽取：
如果<var>OFF</var>为0，则返回的向量为<var>V2</var>；
否则返回的向量由<var>v1</var>的后<var>VS</var>-<var>OFF</var>个元素连接到<var>v2</var>的前<var>OFF</var>个元素而组成。

      <p>如果定义了该钩子，则自动向量化会生成一个对<var>f</var>的调用（使用该钩子返回的DECL）
并使用<var>f</var>的返回值作为<code>REALIGN_LOAD</code>的参数<var>OFF</var>。因此，
<var>f</var>返回的掩码<var>m</var>应该遵守<code>REALIGN_LOAD</code>所期望的上面描述的语义。
如果该钩子没有被定义，
则<var>addr</var>将作为<code>REALIGN_LOAD</code>的参数<var>OFF</var>来使用，
这种情况下将会考虑<var>addr</var>的低log2(<var>VS</var>)-1位。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN</b> (<var>tree x</var>)<var><a name="index-TARGET_005fVECTORIZE_005fBUILTIN_005fMUL_005fWIDEN_005fEVEN-4197"></a></var><br>
<blockquote><p>该钩子应该返回一个函数<var>f</var>的decl，
该函数实现了两个类型为<var>x</var>的输入向量作为偶数元素的加宽乘法。

      <p>如果定义了该钩子，则自动化向量当进行向量化加宽乘法时，
将会使用它和<code>TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD</code> target钩子，
以防结果顺序不需要被保存（例如，只用于减法计算）。
否则将使用<code>widen_mult_hi/lo</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD</b> (<var>tree x</var>)<var><a name="index-TARGET_005fVECTORIZE_005fBUILTIN_005fMUL_005fWIDEN_005fODD-4198"></a></var><br>
<blockquote><p>该钩子应该返回一个函数<var>f</var>的decl，
该函数实现了两个类型为<var>x</var>的输入向量作为奇数元素的加宽乘法。

      <p>如果定义了该钩子，则自动化向量当进行向量化加宽乘法时，
将会使用它和<code>TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN</code> target钩子，
以防结果顺序不需要被保存（例如，只用于减法计算）。
否则将使用<code>widen_mult_hi/lo</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_VECTORIZE_BUILTIN_CONVERSION</b> (<var>enum tree_code code, tree type</var>)<var><a name="index-TARGET_005fVECTORIZE_005fBUILTIN_005fCONVERSION-4199"></a></var><br>
<blockquote><p>该钩子应该返回一个函数的decl，该函数实现了类型为<var>type</var>的输入向量的转换。
如果<var>type</var>为一个整数类型，则转换结果为一个同样大小的浮点类型的向量。
如果<var>type</var>为浮点类型，则转换结果为一个同样大小的整数类型的向量。
<var>code</var>指定了如何应用转换（截断，舍入，等）。

      <p>如果定义了该钩子，则自动向量化当进行向量化转换时，
会使用<code>TARGET_VECTORIZE_BUILTIN_CONVERSION</code> target钩子。
否则，其应该返回<code>NULL_TREE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION</b> (<var>enum built_in_function code, tree vec_type_out, tree vec_type_in</var>)<var><a name="index-TARGET_005fVECTORIZE_005fBUILTIN_005fVECTORIZED_005fFUNCTION-4200"></a></var><br>
<blockquote><p>该钩子应该返回一个函数的decl，
该函数实现了代码为<var>code</var>的内建函数的向量化变体，
或者如果没有这样的函数则返回<code>NULL_TREE</code>。
向量化的函数的返回类型应该为向量类型<var>vec_type_out</var>，
并且参数类型应该为<var>vec_type_in</var>。
</p></blockquote></div>

 </body></html>

