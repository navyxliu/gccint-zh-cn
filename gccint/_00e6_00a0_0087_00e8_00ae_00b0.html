<html lang="zh">
<head>
<title>标记 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0" title="访问特殊操作数">
<link rel="next" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f" title="机器模式">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%a0%87%e8%ae%b0"></a>
<a name="g_t_00e6_00a0_0087_00e8_00ae_00b0"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f">机器模式</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0">访问特殊操作数</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.5 RTL表达式中的标记</h3>

<p><a name="index-flags-in-RTL-expression-2133"></a>
RTL表达式包含几个标记（位域），用于特定类型的表达式。通常它们使用下列的宏来访问，并被扩展为左值。

     
<a name="index-CONSTANT_005fPOOL_005fADDRESS_005fP-2134"></a>
<a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002fu_007d-2135"></a>
<a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bsymbol_005fref_007d-2136"></a>
<dl><dt><code>CONSTANT_POOL_ADDRESS_P (</code><var>x</var><code>)</code><dd>位于<code>symbol_ref</code>中，如果其引用了当前函数的常量池中的一部分，则非零。对于大多数目标机器，这些地址在<code>.rodata</code>段中，与函数完全分离，但是对于有些目标机器，这些地址是靠近函数起始处。不管哪种情况，GCC都假设这些地址可以被直接寻址，或者通过基址寄存器。其被存储在<code>unchanging</code>域，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-RTL_005fCONST_005fCALL_005fP-2137"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fu_007d-2138"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bcall_005finsn_007d-2139"></a><br><dt><code>RTL_CONST_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，表明该insn表示一个对const函数的调用。存储在<code>unchanging</code>域，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-RTL_005fPURE_005fCALL_005fP-2140"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fi_007d-2141"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007bcall_005finsn_007d-2142"></a><br><dt><code>RTL_PURE_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，表明该insn表示一个对pure函数的调用。存储在<code>return_val</code>域，打印输出为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-RTL_005fCONST_005fOR_005fPURE_005fCALL_005fP-2143"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fu_007d-or-_0040samp_007b_002fi_007d-2144"></a><br><dt><code>RTL_CONST_OR_PURE_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，如果<code>RTL_CONST_CALL_P</code>或者<code>RTL_PURE_CALL_P</code>为真，则其为真。

     <p><a name="index-RTL_005fLOOPING_005fCONST_005fOR_005fPURE_005fCALL_005fP-2145"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fc_007d-2146"></a><a name="index-g_t_0040code_007bcall_007d_002c-in-_0040code_007bcall_005finsn_007d-2147"></a><br><dt><code>RTL_LOOPING_CONST_OR_PURE_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，表明该insn表示一个对const或者pure函数，可能是无限循环的调用。存储在<code>call</code>域，打印输出为&lsquo;<samp><span class="samp">/c</span></samp>&rsquo;。只有当<code>RTL_CONST_CALL_P</code>或者<code>RTL_PURE_CALL_P</code>为真时，其才为真。

     <p><a name="index-INSN_005fANNULLED_005fBRANCH_005fP-2148"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fu_007d-2149"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fu_007d-2150"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fu_007d-2151"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bjump_005finsn_007d_002c-_0040code_007bcall_005finsn_007d-and-_0040code_007binsn_007d-2152"></a><br><dt><code>INSN_ANNULLED_BRANCH_P (</code><var>x</var><code>)</code><dd>位于<code>jump_insn</code>，<code>call_insn</code>或者<code>insn</code>中，表明该分支跳转被取消。参见下面关于<code>sequence</code>的讨论。存储在<code>unchanging</code>域，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-INSN_005fDELETED_005fP-2153"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fv_007d-2154"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fv_007d-2155"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fv_007d-2156"></a><a name="index-g_t_0040code_007bcode_005flabel_007d-and-_0040samp_007b_002fv_007d-2157"></a><a name="index-g_t_0040code_007bbarrier_007d-and-_0040samp_007b_002fv_007d-2158"></a><a name="index-g_t_0040code_007bnote_007d-and-_0040samp_007b_002fv_007d-2159"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007binsn_007d_002c-_0040code_007bcall_005finsn_007d_002c-_0040code_007bjump_005finsn_007d_002c-_0040code_007bcode_005flabel_007d_002c-_0040code_007bbarrier_007d_002c-and-_0040code_007bnote_007d-2160"></a><br><dt><code>INSN_DELETED_P (</code><var>x</var><code>)</code><dd>位于<code>insn</code>, <code>call_insn</code>, <code>jump_insn</code>, <code>code_label</code>, <code>barrier</code>或<code>note</code>中，如果该insn被删除掉，则非零。存储在<code>volatil</code>域，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-INSN_005fFROM_005fTARGET_005fP-2161"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fs_007d-2162"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fs_007d-2163"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fs_007d-2164"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007binsn_007d-and-_0040code_007bjump_005finsn_007d-and-_0040code_007bcall_005finsn_007d-2165"></a><br><dt><code>INSN_FROM_TARGET_P (</code><var>x</var><code>)</code><dd>位于<code>insn</code>，<code>jump_insn</code>或者<code>call_insn</code>中，在分支延迟槽中，表明该insn是来自分支跳转的目标。如果分支insn设置了<code>INSN_ANNULLED_BRANCH_P</code>，则该insn只有当进行分支跳转的时候，才被执行。对于被取消的分支，如果是清除了<code>INSN_FROM_TARGET_P</code>，则insn只有当没有进行分支跳转的时候，才被执行。当<code>INSN_ANNULLED_BRANCH_P</code>没有被设置，该insn将总是被执行。存储在<code>in_struct</code>域，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-LABEL_005fPRESERVE_005fP-2166"></a><a name="index-g_t_0040code_007bcode_005flabel_007d-and-_0040samp_007b_002fi_007d-2167"></a><a name="index-g_t_0040code_007bnote_007d-and-_0040samp_007b_002fi_007d-2168"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007bcode_005flabel_007d-and-_0040code_007bnote_007d-2169"></a><br><dt><code>LABEL_PRESERVE_P (</code><var>x</var><code>)</code><dd>位于<code>code_label</code>或者<code>note</code>中，表明被代码或者数据引用的该标号，对于给定的函数RTL不可见。通过非局部goto引用的标号，将设置该位。存储在<code>in_struct</code>域中，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-LABEL_005fREF_005fNONLOCAL_005fP-2170"></a><a name="index-g_t_0040code_007blabel_005fref_007d-and-_0040samp_007b_002fv_007d-2171"></a><a name="index-g_t_0040code_007breg_005flabel_007d-and-_0040samp_007b_002fv_007d-2172"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007blabel_005fref_007d-and-_0040code_007breg_005flabel_007d-2173"></a><br><dt><code>LABEL_REF_NONLOCAL_P (</code><var>x</var><code>)</code><dd>位于<code>label_ref</code>和<code>reg_label</code>表达式中，如果其为对一个非局部标号的引用，则非零。存储在<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-MEM_005fIN_005fSTRUCT_005fP-2174"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fs_007d-2175"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007bmem_007d-2176"></a><br><dt><code>MEM_IN_STRUCT_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>表达式中，对于引用一整个结构体，联合体，数组，或者是它们的一部分，则非零。如果是引用一个标量变量，或者是标量指针，则为零。如果该标记和<code>MEM_SCALAR_P</code>都被清除，则我们无法知道该<code>mem</code>是否在一个结构体中。这两个标记不要被同时设置。存储在<code>in_struct</code>域中，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-MEM_005fKEEP_005fALIAS_005fSET_005fP-2177"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fj_007d-2178"></a><a name="index-g_t_0040code_007bjump_007d_002c-in-_0040code_007bmem_007d-2179"></a><br><dt><code>MEM_KEEP_ALIAS_SET_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>表达式中，如果为1，则表明当访问一个部件时，应该保持该mem的别名集合不变。例如，当在一个聚合体的不可寻址部件中的时候，将其设为1。存储在<code>jump</code>域中，打印输出为&lsquo;<samp><span class="samp">/j</span></samp>&rsquo;。

     <p><a name="index-MEM_005fSCALAR_005fP-2180"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fi_007d-2181"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007bmem_007d-2182"></a><br><dt><code>MEM_SCALAR_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>表达式中，如果引用的标量，被已知不是结构体，联合体或者数组的成员，则为非零。如果是这样的引用，或者通过指针的间接引用，即便是指向标量类型，则为零，如果该标记和<code>MEM_IN_STRUCT_P</code>都被清除，则我们无法知道该<code>mem</code>是否为一个结构体。这两个标记不要被同时设置。存储在<code>return_val</code>域中，打印输出为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-MEM_005fVOLATILE_005fP-2183"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fv_007d-2184"></a><a name="index-g_t_0040code_007basm_005finput_007d-and-_0040samp_007b_002fv_007d-2185"></a><a name="index-g_t_0040code_007basm_005foperands_007d-and-_0040samp_007b_002fv_007d-2186"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bmem_007d_002c-_0040code_007basm_005foperands_007d_002c-and-_0040code_007basm_005finput_007d-2187"></a><br><dt><code>MEM_VOLATILE_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>, <code>asm_operands</code>和<code>asm_input</code>表达式中，对于volatile内存引用，为非零。存储在<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-MEM_005fNOTRAP_005fP-2188"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fc_007d-2189"></a><a name="index-g_t_0040code_007bcall_007d_002c-in-_0040code_007bmem_007d-2190"></a><br><dt><code>MEM_NOTRAP_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>中，对于不会产生陷阱的内存引用，为非零。存储在<code>call</code>域中，打印输出为&lsquo;<samp><span class="samp">/c</span></samp>&rsquo;。

     <p><a name="index-MEM_005fPOINTER-2191"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002ff_007d-2192"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007bmem_007d-2193"></a><br><dt><code>MEM_POINTER (</code><var>x</var><code>)</code><dd>位于<code>mem</code>中，如果内存引用存放了一个指针，则非零。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p><a name="index-REG_005fFUNCTION_005fVALUE_005fP-2194"></a><a name="index-g_t_0040code_007breg_007d-and-_0040samp_007b_002fi_007d-2195"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007breg_007d-2196"></a><br><dt><code>REG_FUNCTION_VALUE_P (</code><var>x</var><code>)</code><dd>位于<code>reg</code>中，如果其为存放函数返回值的地方，则非零。（这只发生在硬件寄存器中。）存储在<code>return_val</code>域中，打印输出为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-REG_005fPOINTER-2197"></a><a name="index-g_t_0040code_007breg_007d-and-_0040samp_007b_002ff_007d-2198"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007breg_007d-2199"></a><br><dt><code>REG_POINTER (</code><var>x</var><code>)</code><dd>位于<code>reg</code>中，如果寄存器存放一个指针，则非零。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p><a name="index-REG_005fUSERVAR_005fP-2200"></a><a name="index-g_t_0040code_007breg_007d-and-_0040samp_007b_002fv_007d-2201"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007breg_007d-2202"></a><br><dt><code>REG_USERVAR_P (</code><var>x</var><code>)</code><dd>位于<code>reg</code>中，如果其对应于用户源代码中出现的一个变量，则非零。对于编译器内部生成的临时对象，则为零。存储在<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-RTX_005fFRAME_005fRELATED_005fP-2203"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002ff_007d-2204"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002ff_007d-2205"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002ff_007d-2206"></a><a name="index-g_t_0040code_007bbarrier_007d-and-_0040samp_007b_002ff_007d-2207"></a><a name="index-g_t_0040code_007bset_007d-and-_0040samp_007b_002ff_007d-2208"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007binsn_007d_002c-_0040code_007bcall_005finsn_007d_002c-_0040code_007bjump_005finsn_007d_002c-_0040code_007bbarrier_007d_002c-and-_0040code_007bset_007d-2209"></a><br><dt><code>RTX_FRAME_RELATED_P (</code><var>x</var><code>)</code><dd>位于<code>insn</code>, <code>call_insn</code>, <code>jump_insn</code>, <code>barrier</code>, 或者<code>set</code>中，如果其为函数序言的一部分，用来设置栈指针，帧指针，或者保存寄存器，则为非零。对于设置用于帧指针的临时寄存器的指令，该标记也应被设置。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p>特别的，在一些RISC目标机器上，对于立即数常量的大小有限制，有时不能直接通过栈指针来到达寄存器的保存区域。这种情况下，一个足够接近寄存器保存区域的临时寄存器被使用，并且正则帧地址（Canonical Frame Address）寄存器，即DWARF2的逻辑帧指针寄存器，必须（临时的）被改成该临时寄存器。所以，设置该临时寄存器的指令必须被标记为<code>RTX_FRAME_RELATED_P</code>。

     <p>如果被标记的指令过于复杂（跟据<code>dwarf2out_frame_debug_expr</code>能否处理，而定义的术语），则你还必须要创建一个<code>REG_FRAME_RELATED_EXPR</code>注解，并附加在该指令上。该注解应该包含一个该指令执行计算的简单表达式，即<code>dwarf2out_frame_debug_expr</code>可以处理的。

     <p>在带有RTL序言的目标机器上，提供异常处理的支持时，会用到该标记。

     <p><a name="index-MEM_005fREADONLY_005fP-2210"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fu_007d-2211"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bmem_007d-2212"></a><br><dt><code>MEM_READONLY_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>中，如果内存是静态分配并且只读的，则非零。

     <p>在该上下文中只读，意味着在程序的生命周期中不会被修改，但是不必要是在ROM或者不可写的页中。对于后者，一个常见的例子，是共享库的全局偏移表。该表由运行时加载器初始化，所以内存在技术上是可写的，但是当控制从运行时加载器转移给应用程序时，该内存将不再被修改。

     <p>存储在<code>unchanging</code>域中，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-SCHED_005fGROUP_005fP-2213"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fs_007d-2214"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fs_007d-2215"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fs_007d-2216"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007binsn_007d_002c-_0040code_007bjump_005finsn_007d-and-_0040code_007bcall_005finsn_007d-2217"></a><br><dt><code>SCHED_GROUP_P (</code><var>x</var><code>)</code><dd>在指令调度过程中，位于<code>insn</code>, <code>call_insn</code>或者<code>jump_insn</code>中，表明前一个insn必须与该insn一起调度。这用来确保特定的指令组不会被指令调度过程分隔开。例如，在<code>call_insn</code>之前的<code>use</code> insn不可以从<code>call_insn</code>中分开。存储在<code>in_struct</code>域中，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-SET_005fIS_005fRETURN_005fP-2218"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fj_007d-2219"></a><a name="index-g_t_0040code_007bjump_007d_002c-in-_0040code_007binsn_007d-2220"></a><br><dt><code>SET_IS_RETURN_P (</code><var>x</var><code>)</code><dd>对于<code>set</code>，如果是针对一个return，则非零。存储在<code>jump</code>域中，打印输出为&lsquo;<samp><span class="samp">/j</span></samp>&rsquo;。

     <p><a name="index-SIBLING_005fCALL_005fP-2221"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fj_007d-2222"></a><a name="index-g_t_0040code_007bjump_007d_002c-in-_0040code_007bcall_005finsn_007d-2223"></a><br><dt><code>SIBLING_CALL_P (</code><var>x</var><code>)</code><dd>对于<code>call_insn</code>，如果该insn为一个sibling call，则非零。存储在<code>jump</code>域中，打印输出为&lsquo;<samp><span class="samp">/j</span></samp>&rsquo;。

     <p><a name="index-STRING_005fPOOL_005fADDRESS_005fP-2224"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002ff_007d-2225"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007bsymbol_005fref_007d-2226"></a><br><dt><code>STRING_POOL_ADDRESS_P (</code><var>x</var><code>)</code><dd>对于一个<code>symbol_ref</code>表达式，如果其为对该函数的字符串常量池的寻址，则非零。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p><a name="index-SUBREG_005fPROMOTED_005fUNSIGNED_005fP-2227"></a><a name="index-g_t_0040code_007bsubreg_007d-and-_0040samp_007b_002fu_007d-and-_0040samp_007b_002fv_007d-2228"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bsubreg_007d-2229"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bsubreg_007d-2230"></a><br><dt><code>SUBREG_PROMOTED_UNSIGNED_P (</code><var>x</var><code>)</code><dd>如果<code>subreg</code>对于<code>SUBREG_PROMOTED_VAR_P</code>为非零，并且被引用的对象为零扩展，则返回一个大于零的值；如果保持为符号扩展，则为零；如果是通过<code>ptr_extend</code>指令，进行某种其它方式的扩展，则小于零。存储在<code>unchanging</code>域和<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;和&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。该宏只用于获得值，不能用于修改值。使用<code>SUBREG_PROMOTED_UNSIGNED_SET</code>来修改值。

     <p><a name="index-SUBREG_005fPROMOTED_005fUNSIGNED_005fSET-2231"></a><a name="index-g_t_0040code_007bsubreg_007d-and-_0040samp_007b_002fu_007d-2232"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bsubreg_007d-2233"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bsubreg_007d-2234"></a><br><dt><code>SUBREG_PROMOTED_UNSIGNED_SET (</code><var>x</var><code>)</code><dd>设置<code>subreg</code>中的<code>unchanging</code>和<code>volatil</code>域，来反映零扩展，符号扩展，或其它扩展。如果<code>volatil</code>为零，然后如果<code>unchanging</code>为非零，则意味着零扩展，如果为零，则意味着符号扩展。如果<code>volatil</code>为非零，则通过<code>ptr_extend</code>指令使用了其它某种扩展。

     <p><a name="index-SUBREG_005fPROMOTED_005fVAR_005fP-2235"></a><a name="index-g_t_0040code_007bsubreg_007d-and-_0040samp_007b_002fs_007d-2236"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007bsubreg_007d-2237"></a><br><dt><code>SUBREG_PROMOTED_VAR_P (</code><var>x</var><code>)</code><dd>位于<code>subreg</code>中，如果当访问一个被提升为符合机器描述宏<code>PROMOTED_MODE</code>的(see <a href="Storage-Layout.html#Storage-Layout">Storage Layout</a>)，宽机器模式的对象时，则非零。这种情况下，<code>subreg</code>的机器模式为对象被声明的机器模式，<code>SUBREG_REG</code>的机器模式为存放该对象的寄存器的机器模式。被提升的变量，在每个赋值中，总是被符号扩展或者零扩展成宽机器模式。存储在<code>in_struct</code>域中，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-SYMBOL_005fREF_005fUSED-2238"></a><a name="index-g_t_0040code_007bused_007d_002c-in-_0040code_007bsymbol_005fref_007d-2239"></a><br><dt><code>SYMBOL_REF_USED (</code><var>x</var><code>)</code><dd>位于<code>symbol_ref</code>中，表明<var>x</var>已经被使用。这通常只用于确保<var>x</var>只在外部被声明一次。存储在<code>used</code>中。

     <p><a name="index-SYMBOL_005fREF_005fWEAK-2240"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002fi_007d-2241"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007bsymbol_005fref_007d-2242"></a><br><dt><code>SYMBOL_REF_WEAK (</code><var>x</var><code>)</code><dd>位于<code>symbol_ref</code>中，表明<var>x</var>已经被声明为weak。存储在<code>return_val</code>域中，打印输出为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-SYMBOL_005fREF_005fFLAG-2243"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002fv_007d-2244"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bsymbol_005fref_007d-2245"></a><br><dt><code>SYMBOL_REF_FLAG (</code><var>x</var><code>)</code><dd>位于<code>symbol_ref</code>中，用于机器特定目的的标记。存储在<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p>大多对<code>SYMBOL_REF_FLAG</code>的使用，是历史性的，并且可以通过<code>SYMBOL_REF_FLAGS</code>来归类。当然，如果目标机器需要多于一个位的存储时，对<code>SYMBOL_REF_FLAGS</code>的使用是强制的。

 </dl>

 <p>这些是上面的宏所引用的域：

     
<a name="index-call-2246"></a>
<a name="index-g_t_0040samp_007b_002fc_007d-in-RTL-dump-2247"></a>
<dl><dt><code>call</code><dd>在<code>mem</code>中，1表示该内存引用不会有陷阱。

     <p>在<code>call</code>中，1表示该pure或者const调用，可能为无限循环。

     <p>在RTL转储中，该标记被表示为&lsquo;<samp><span class="samp">/c</span></samp>&rsquo;。

     <p><a name="index-frame_005frelated-2248"></a><a name="index-g_t_0040samp_007b_002ff_007d-in-RTL-dump-2249"></a><br><dt><code>frame_related</code><dd>在<code>insn</code>或者<code>set</code>表达式中，1表示其为函数序言的一部分，设置栈寄存器，设置帧寄存器，保存寄存器，或者设置一个用于帧寄存器的临时寄存器。

     <p>在<code>reg</code>表达式中，1表示该寄存器存放一个指针。

     <p>在<code>mem</code>表达式中，1表示该内存引用存放一个指针。

     <p>在<code>symbol_ref</code>表达式中，1表示该引用是对函数的字符串常量池的寻址。

     <p>在RTL转储中，该标记被表示为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p><a name="index-in_005fstruct-2250"></a><a name="index-g_t_0040samp_007b_002fs_007d-in-RTL-dump-2251"></a><br><dt><code>in_struct</code><dd>在<code>mem</code>表达式中，如果所引用的内存数据为整个结构体或者数组，或者一部分，其为1；如果为（或者可能为）一个标量变量。则为0。通过C指针的引用，为0，因为指针可以指向一个标量变量。该信息允许编译器来确定别名的可能情况。

     <p>在<code>reg</code>表达式中，如果寄存器整个生命期都包含在某个循环的测试表达式中，则为1。

     <p>在<code>subreg</code>表达式中，1表示<code>subreg</code>在访问一个从更宽的机器模式进行提升的对象。

     <p>在<code>label_ref</code>表达式中，1表示被引用的标号位于包含发现<code>label_ref</code>的insn的最内层循环的外面。

     <p>在<code>code_label</code>表达式中，如果标号不能被删除，则为1。这用于其为非局部goto的目标的标号。对于已经被删除的这样的标号，使用类型为<code>NOTE_INSN_DELETED_LABEL</code>的<code>note</code>来替换。

     <p>在<code>insn</code>中，在死代码消除阶段，1表示该insn为死代码。

     <p>在<code>insn</code>或者<code>jump_insn</code>中，在针对分支延迟槽中insn的reorg阶段，1表示该insn来自分支跳转的目标。

     <p>在<code>insn</code>中，在指令调度阶段，1表示该insn必须与之前的insn一起进行调度。

     <p>在RTL转储中，该标记被表示为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-return_005fval-2252"></a><a name="index-g_t_0040samp_007b_002fi_007d-in-RTL-dump-2253"></a><br><dt><code>return_val</code><dd>在<code>reg</code>表达式中，1表示寄存器包含了当且函数的返回值。对于在寄存器中传递参数的机器上，同一个寄存器编号也可以被用作参数，但是这种情况下，该标记不被设置。

     <p>在<code>mem</code>中，1表示内存引用为一个已知不为结构体，联合体，数组的成员的标量。

     <p>在<code>symbol_ref</code>表达式中，1表示被引用的符号为weak。

     <p>在<code>call</code>表达式中，1表示调用是pure。

     <p>在RTL转储中，该标记被表示为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-jump-2254"></a><a name="index-g_t_0040samp_007b_002fj_007d-in-RTL-dump-2255"></a><br><dt><code>jump</code><dd>在<code>mem</code>表达式中，1表示当访问一个部件时，应该保持该mem的别名集不变。

     <p>在<code>set</code>中，1表示其为一个return。

     <p>在<code>call_insn</code>中，1表示其为一个sibling call。

     <p>在RTL转储中，该标记被表示为&lsquo;<samp><span class="samp">/j</span></samp>&rsquo;。

     <p><a name="index-unchanging-2256"></a><a name="index-g_t_0040samp_007b_002fu_007d-in-RTL-dump-2257"></a><br><dt><code>unchanging</code><dd>在<code>reg</code>和<code>mem</code>表达式中，1表示表达式的值不会改变。

     <p>在<code>subreg</code>表达式中，如果<code>subreg</code>引用了机器模式已经被提升为一个宽模式的无符号对象，则为1。 references an

     <p>在分支指令延迟槽中的<code>insn</code>或<code>jump_insn</code>中，1表示将使用一个被取消的分支。

     <p>在<code>symbol_ref</code>表达式中，1表示该符号对函数的常量池进行寻址。

     <p>在<code>call_insn</code>中，1表示该指令为对const函数的调用。

     <p>在RTL转储中，该标记被表示为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-used-2258"></a><br><dt><code>used</code><dd>该标记在函数的RTL生成阶段的结尾被直接使用（不通过访问宏），来计数表达式在insns中出现的次数。出现次数大于一的表达式，根据共享结构的规则（see <a href="Sharing.html#Sharing">Sharing</a>），被复制。

     <p>对于<code>reg</code>，其被叶子寄存器重编号代码直接使用（不通过访问宏），来确保每个寄存器只被重编号一次。

     <p>在<code>symbol_ref</code>中，其表示该符号的外部声明已经被书写了。

     <p><a name="index-volatil-2259"></a><a name="index-g_t_0040samp_007b_002fv_007d-in-RTL-dump-2260"></a><br><dt><code>volatil</code><dd><a name="index-volatile-memory-references-2261"></a>在<code>mem</code>, <code>asm_operands</code>或者<code>asm_input</code>表达式中，如果内存引用是volatile的，则为1。volatile的内存引用不可以被删除，重排或者合并。

     <p>在<code>symbol_ref</code>表达式中，其用于机器特定的目的。

     <p>在<code>reg</code>表达式中，如果值为用户级的变量，则为1。0表示为内部的编译器临时对象。

     <p>在<code>insn</code>中，1表示该insn已经被删除。

     <p>在<code>label_ref</code>和<code>reg_label</code>表达式中，1表示对非局部标号的引用。

     <p>在RTL转储中，该标记被表示为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。
</dl>

 </body></html>

