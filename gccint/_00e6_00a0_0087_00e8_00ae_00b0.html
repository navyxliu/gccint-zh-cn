<html lang="zh">
<head>
<title>标记 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0" title="访问特殊操作数">
<link rel="next" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f" title="机器模式">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%a0%87%e8%ae%b0"></a>
<a name="g_t_00e6_00a0_0087_00e8_00ae_00b0"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f">机器模式</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#g_t_00e8_00ae_00bf_00e9_0097_00ae_00e7_0089_00b9_00e6_00ae_008a_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0">访问特殊操作数</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.5 RTL表达式中的标记</h3>

<p><a name="index-flags-in-RTL-expression-2133"></a>
RTL表达式包含几个标记（位域），用于特定类型的表达式。通常它们使用下列的宏来访问，并被扩展为左值。

     
<a name="index-CONSTANT_005fPOOL_005fADDRESS_005fP-2134"></a>
<a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002fu_007d-2135"></a>
<a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bsymbol_005fref_007d-2136"></a>
<dl><dt><code>CONSTANT_POOL_ADDRESS_P (</code><var>x</var><code>)</code><dd>位于<code>symbol_ref</code>中，如果其引用了当前函数的常量池中的一部分，则非零。对于大多数目标机器，这些地址在<code>.rodata</code>段中，与函数完全分离，但是对于有些目标机器，这些地址是靠近函数起始处。不管哪种情况，GCC都假设这些地址可以被直接寻址，或者通过基址寄存器。其被存储在<code>unchanging</code>域，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-RTL_005fCONST_005fCALL_005fP-2137"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fu_007d-2138"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bcall_005finsn_007d-2139"></a><br><dt><code>RTL_CONST_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，表明该insn表示一个对const函数的调用。存储在<code>unchanging</code>域，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-RTL_005fPURE_005fCALL_005fP-2140"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fi_007d-2141"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007bcall_005finsn_007d-2142"></a><br><dt><code>RTL_PURE_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，表明该insn表示一个对pure函数的调用。存储在<code>return_val</code>域，打印输出为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-RTL_005fCONST_005fOR_005fPURE_005fCALL_005fP-2143"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fu_007d-or-_0040samp_007b_002fi_007d-2144"></a><br><dt><code>RTL_CONST_OR_PURE_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，如果<code>RTL_CONST_CALL_P</code>或者<code>RTL_PURE_CALL_P</code>为真，则其为真。

     <p><a name="index-RTL_005fLOOPING_005fCONST_005fOR_005fPURE_005fCALL_005fP-2145"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fc_007d-2146"></a><a name="index-g_t_0040code_007bcall_007d_002c-in-_0040code_007bcall_005finsn_007d-2147"></a><br><dt><code>RTL_LOOPING_CONST_OR_PURE_CALL_P (</code><var>x</var><code>)</code><dd>位于<code>call_insn</code>中，表明该insn表示一个对const或者pure函数，可能是无限循环的调用。存储在<code>call</code>域，打印输出为&lsquo;<samp><span class="samp">/c</span></samp>&rsquo;。只有当<code>RTL_CONST_CALL_P</code>或者<code>RTL_PURE_CALL_P</code>为真时，其才为真。

     <p><a name="index-INSN_005fANNULLED_005fBRANCH_005fP-2148"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fu_007d-2149"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fu_007d-2150"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fu_007d-2151"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bjump_005finsn_007d_002c-_0040code_007bcall_005finsn_007d-and-_0040code_007binsn_007d-2152"></a><br><dt><code>INSN_ANNULLED_BRANCH_P (</code><var>x</var><code>)</code><dd>位于<code>jump_insn</code>，<code>call_insn</code>或者<code>insn</code>中，表明该分支跳转被取消。参见下面关于<code>sequence</code>的讨论。存储在<code>unchanging</code>域，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-INSN_005fDELETED_005fP-2153"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fv_007d-2154"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fv_007d-2155"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fv_007d-2156"></a><a name="index-g_t_0040code_007bcode_005flabel_007d-and-_0040samp_007b_002fv_007d-2157"></a><a name="index-g_t_0040code_007bbarrier_007d-and-_0040samp_007b_002fv_007d-2158"></a><a name="index-g_t_0040code_007bnote_007d-and-_0040samp_007b_002fv_007d-2159"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007binsn_007d_002c-_0040code_007bcall_005finsn_007d_002c-_0040code_007bjump_005finsn_007d_002c-_0040code_007bcode_005flabel_007d_002c-_0040code_007bbarrier_007d_002c-and-_0040code_007bnote_007d-2160"></a><br><dt><code>INSN_DELETED_P (</code><var>x</var><code>)</code><dd>位于<code>insn</code>, <code>call_insn</code>, <code>jump_insn</code>, <code>code_label</code>, <code>barrier</code>或<code>note</code>中，如果该insn被删除掉，则非零。存储在<code>volatil</code>域，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-INSN_005fFROM_005fTARGET_005fP-2161"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fs_007d-2162"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fs_007d-2163"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fs_007d-2164"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007binsn_007d-and-_0040code_007bjump_005finsn_007d-and-_0040code_007bcall_005finsn_007d-2165"></a><br><dt><code>INSN_FROM_TARGET_P (</code><var>x</var><code>)</code><dd>位于<code>insn</code>，<code>jump_insn</code>或者<code>call_insn</code>中，在分支延迟槽中，表明该insn是来自分支跳转的目标。如果分支insn设置了<code>INSN_ANNULLED_BRANCH_P</code>，则该insn只有当进行分支跳转的时候，才被执行。对于被取消的分支，如果是清除了<code>INSN_FROM_TARGET_P</code>，则insn只有当没有进行分支跳转的时候，才被执行。当<code>INSN_ANNULLED_BRANCH_P</code>没有被设置，该insn将总是被执行。存储在<code>in_struct</code>域，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-LABEL_005fPRESERVE_005fP-2166"></a><a name="index-g_t_0040code_007bcode_005flabel_007d-and-_0040samp_007b_002fi_007d-2167"></a><a name="index-g_t_0040code_007bnote_007d-and-_0040samp_007b_002fi_007d-2168"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007bcode_005flabel_007d-and-_0040code_007bnote_007d-2169"></a><br><dt><code>LABEL_PRESERVE_P (</code><var>x</var><code>)</code><dd>位于<code>code_label</code>或者<code>note</code>中，表明被代码或者数据引用的该标号，对于给定的函数RTL不可见。通过非局部goto引用的标号，将设置该位。存储在<code>in_struct</code>域中，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-LABEL_005fREF_005fNONLOCAL_005fP-2170"></a><a name="index-g_t_0040code_007blabel_005fref_007d-and-_0040samp_007b_002fv_007d-2171"></a><a name="index-g_t_0040code_007breg_005flabel_007d-and-_0040samp_007b_002fv_007d-2172"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007blabel_005fref_007d-and-_0040code_007breg_005flabel_007d-2173"></a><br><dt><code>LABEL_REF_NONLOCAL_P (</code><var>x</var><code>)</code><dd>位于<code>label_ref</code>和<code>reg_label</code>表达式中，如果其为对一个非局部标号的引用，则非零。存储在<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-MEM_005fIN_005fSTRUCT_005fP-2174"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fs_007d-2175"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007bmem_007d-2176"></a><br><dt><code>MEM_IN_STRUCT_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>表达式中，对于引用一整个结构体，联合体，数组，或者是它们的一部分，则非零。如果是引用一个标量变量，或者是标量指针，则为零。如果该标记和<code>MEM_SCALAR_P</code>都被清除，则我们无法知道该<code>mem</code>是否在一个结构体中。这两个标记不要被同时设置。存储在<code>in_struct</code>域中，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-MEM_005fKEEP_005fALIAS_005fSET_005fP-2177"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fj_007d-2178"></a><a name="index-g_t_0040code_007bjump_007d_002c-in-_0040code_007bmem_007d-2179"></a><br><dt><code>MEM_KEEP_ALIAS_SET_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>表达式中，如果为1，则表明当访问一个部件时，应该保持该mem的别名集合不变。例如，当在一个聚合体的不可寻址部件中的时候，将其设为1。存储在<code>jump</code>域中，打印输出为&lsquo;<samp><span class="samp">/j</span></samp>&rsquo;。

     <p><a name="index-MEM_005fSCALAR_005fP-2180"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fi_007d-2181"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007bmem_007d-2182"></a><br><dt><code>MEM_SCALAR_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>表达式中，如果引用的标量，被已知不是结构体，联合体或者数组的成员，则为非零。如果是这样的引用，或者通过指针的间接引用，即便是指向标量类型，则为零，如果该标记和<code>MEM_IN_STRUCT_P</code>都被清除，则我们无法知道该<code>mem</code>是否为一个结构体。这两个标记不要被同时设置。存储在<code>return_val</code>域中，打印输出为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-MEM_005fVOLATILE_005fP-2183"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fv_007d-2184"></a><a name="index-g_t_0040code_007basm_005finput_007d-and-_0040samp_007b_002fv_007d-2185"></a><a name="index-g_t_0040code_007basm_005foperands_007d-and-_0040samp_007b_002fv_007d-2186"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bmem_007d_002c-_0040code_007basm_005foperands_007d_002c-and-_0040code_007basm_005finput_007d-2187"></a><br><dt><code>MEM_VOLATILE_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>, <code>asm_operands</code>和<code>asm_input</code>表达式中，对于volatile内存引用，为非零。存储在<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-MEM_005fNOTRAP_005fP-2188"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fc_007d-2189"></a><a name="index-g_t_0040code_007bcall_007d_002c-in-_0040code_007bmem_007d-2190"></a><br><dt><code>MEM_NOTRAP_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>中，对于不会产生陷阱的内存引用，为非零。存储在<code>call</code>域中，打印输出为&lsquo;<samp><span class="samp">/c</span></samp>&rsquo;。

     <p><a name="index-MEM_005fPOINTER-2191"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002ff_007d-2192"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007bmem_007d-2193"></a><br><dt><code>MEM_POINTER (</code><var>x</var><code>)</code><dd>位于<code>mem</code>中，如果内存引用存放了一个指针，则非零。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p><a name="index-REG_005fFUNCTION_005fVALUE_005fP-2194"></a><a name="index-g_t_0040code_007breg_007d-and-_0040samp_007b_002fi_007d-2195"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007breg_007d-2196"></a><br><dt><code>REG_FUNCTION_VALUE_P (</code><var>x</var><code>)</code><dd>位于<code>reg</code>中，如果其为存放函数返回值的地方，则非零。（这只发生在硬件寄存器中。）存储在<code>return_val</code>域中，打印输出为&lsquo;<samp><span class="samp">/i</span></samp>&rsquo;。

     <p><a name="index-REG_005fPOINTER-2197"></a><a name="index-g_t_0040code_007breg_007d-and-_0040samp_007b_002ff_007d-2198"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007breg_007d-2199"></a><br><dt><code>REG_POINTER (</code><var>x</var><code>)</code><dd>位于<code>reg</code>中，如果寄存器存放一个指针，则非零。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p><a name="index-REG_005fUSERVAR_005fP-2200"></a><a name="index-g_t_0040code_007breg_007d-and-_0040samp_007b_002fv_007d-2201"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007breg_007d-2202"></a><br><dt><code>REG_USERVAR_P (</code><var>x</var><code>)</code><dd>位于<code>reg</code>中，如果其对应于用户源代码中出现的一个变量，则非零。对于编译器内部生成的临时对象，则为零。存储在<code>volatil</code>域中，打印输出为&lsquo;<samp><span class="samp">/v</span></samp>&rsquo;。

     <p><a name="index-RTX_005fFRAME_005fRELATED_005fP-2203"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002ff_007d-2204"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002ff_007d-2205"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002ff_007d-2206"></a><a name="index-g_t_0040code_007bbarrier_007d-and-_0040samp_007b_002ff_007d-2207"></a><a name="index-g_t_0040code_007bset_007d-and-_0040samp_007b_002ff_007d-2208"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007binsn_007d_002c-_0040code_007bcall_005finsn_007d_002c-_0040code_007bjump_005finsn_007d_002c-_0040code_007bbarrier_007d_002c-and-_0040code_007bset_007d-2209"></a><br><dt><code>RTX_FRAME_RELATED_P (</code><var>x</var><code>)</code><dd>位于<code>insn</code>, <code>call_insn</code>, <code>jump_insn</code>, <code>barrier</code>, 或者<code>set</code>中，如果其为函数序言的一部分，用来设置栈指针，帧指针，或者保存寄存器，则为非零。对于设置用于帧指针的临时寄存器的指令，该标记也应被设置。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p>特别的，在一些RISC目标机器上，对于立即数常量的大小有限制，有时不能直接通过栈指针来到达寄存器的保存区域。这种情况下，一个足够接近寄存器保存区域的临时寄存器被使用，并且正则帧地址（Canonical Frame Address）寄存器，即DWARF2的逻辑帧指针寄存器，必须（临时的）被改成该临时寄存器。所以，设置该临时寄存器的指令必须被标记为<code>RTX_FRAME_RELATED_P</code>。

     <p>如果被标记的指令过于复杂（跟据<code>dwarf2out_frame_debug_expr</code>能否处理，而定义的术语），则你还必须要创建一个<code>REG_FRAME_RELATED_EXPR</code>注解，并附加在该指令上。该注解应该包含一个该指令执行计算的简单表达式，即<code>dwarf2out_frame_debug_expr</code>可以处理的。

     <p>在带有RTL序言的目标机器上，提供异常处理的支持时，会用到该标记。

     <p><a name="index-MEM_005fREADONLY_005fP-2210"></a><a name="index-g_t_0040code_007bmem_007d-and-_0040samp_007b_002fu_007d-2211"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bmem_007d-2212"></a><br><dt><code>MEM_READONLY_P (</code><var>x</var><code>)</code><dd>位于<code>mem</code>中，如果内存是静态分配并且只读的，则非零。

     <p>在该上下文中只读，意味着在程序的生命周期中不会被修改，但是不必要是在ROM或者不可写的页中。对于后者，一个常见的例子，是共享库的全局偏移表。该表由运行时加载器初始化，所以内存在技术上是可写的，但是当控制从运行时加载器转移给应用程序时，该内存将不再被修改。

     <p>存储在<code>unchanging</code>域中，打印输出为&lsquo;<samp><span class="samp">/u</span></samp>&rsquo;。

     <p><a name="index-SCHED_005fGROUP_005fP-2213"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fs_007d-2214"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fs_007d-2215"></a><a name="index-g_t_0040code_007bjump_005finsn_007d-and-_0040samp_007b_002fs_007d-2216"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007binsn_007d_002c-_0040code_007bjump_005finsn_007d-and-_0040code_007bcall_005finsn_007d-2217"></a><br><dt><code>SCHED_GROUP_P (</code><var>x</var><code>)</code><dd>在指令调度过程中，位于<code>insn</code>, <code>call_insn</code>或者<code>jump_insn</code>中，表明前一个insn必须与该insn一起调度。这用来确保特定的指令组不会被指令调度过程分隔开。例如，在<code>call_insn</code>之前的<code>use</code> insn不可以从<code>call_insn</code>中分开。存储在<code>in_struct</code>域中，打印输出为&lsquo;<samp><span class="samp">/s</span></samp>&rsquo;。

     <p><a name="index-SET_005fIS_005fRETURN_005fP-2218"></a><a name="index-g_t_0040code_007binsn_007d-and-_0040samp_007b_002fj_007d-2219"></a><a name="index-g_t_0040code_007bjump_007d_002c-in-_0040code_007binsn_007d-2220"></a><br><dt><code>SET_IS_RETURN_P (</code><var>x</var><code>)</code><dd>对于<code>set</code>，如果是针对一个return，则非零。存储在<code>jump</code>域中，打印输出为&lsquo;<samp><span class="samp">/j</span></samp>&rsquo;。

     <p><a name="index-SIBLING_005fCALL_005fP-2221"></a><a name="index-g_t_0040code_007bcall_005finsn_007d-and-_0040samp_007b_002fj_007d-2222"></a><a name="index-g_t_0040code_007bjump_007d_002c-in-_0040code_007bcall_005finsn_007d-2223"></a><br><dt><code>SIBLING_CALL_P (</code><var>x</var><code>)</code><dd>对于<code>call_insn</code>，如果该insn为一个sibling call，则非零。存储在<code>jump</code>域中，打印输出为&lsquo;<samp><span class="samp">/j</span></samp>&rsquo;。

     <p><a name="index-STRING_005fPOOL_005fADDRESS_005fP-2224"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002ff_007d-2225"></a><a name="index-g_t_0040code_007bframe_005frelated_007d_002c-in-_0040code_007bsymbol_005fref_007d-2226"></a><br><dt><code>STRING_POOL_ADDRESS_P (</code><var>x</var><code>)</code><dd>对于一个<code>symbol_ref</code>表达式，如果其为对该函数的字符串常量池的寻址，则非零。存储在<code>frame_related</code>域中，打印输出为&lsquo;<samp><span class="samp">/f</span></samp>&rsquo;。

     <p><a name="index-SUBREG_005fPROMOTED_005fUNSIGNED_005fP-2227"></a><a name="index-g_t_0040code_007bsubreg_007d-and-_0040samp_007b_002fu_007d-and-_0040samp_007b_002fv_007d-2228"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bsubreg_007d-2229"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bsubreg_007d-2230"></a><br><dt><code>SUBREG_PROMOTED_UNSIGNED_P (</code><var>x</var><code>)</code><dd>Returns a value greater then zero for a <code>subreg</code> that has
<code>SUBREG_PROMOTED_VAR_P</code> nonzero if the object being referenced is kept
zero-extended, zero if it is kept sign-extended, and less then zero if it is
extended some other way via the <code>ptr_extend</code> instruction. 
Stored in the <code>unchanging</code>
field and <code>volatil</code> field, printed as &lsquo;<samp><span class="samp">/u</span></samp>&rsquo; and &lsquo;<samp><span class="samp">/v</span></samp>&rsquo;. 
This macro may only be used to get the value it may not be used to change
the value.  Use <code>SUBREG_PROMOTED_UNSIGNED_SET</code> to change the value.

     <p><a name="index-SUBREG_005fPROMOTED_005fUNSIGNED_005fSET-2231"></a><a name="index-g_t_0040code_007bsubreg_007d-and-_0040samp_007b_002fu_007d-2232"></a><a name="index-g_t_0040code_007bunchanging_007d_002c-in-_0040code_007bsubreg_007d-2233"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bsubreg_007d-2234"></a><br><dt><code>SUBREG_PROMOTED_UNSIGNED_SET (</code><var>x</var><code>)</code><dd>Set the <code>unchanging</code> and <code>volatil</code> fields in a <code>subreg</code>
to reflect zero, sign, or other extension.  If <code>volatil</code> is
zero, then <code>unchanging</code> as nonzero means zero extension and as
zero means sign extension.  If <code>volatil</code> is nonzero then some
other type of extension was done via the <code>ptr_extend</code> instruction.

     <p><a name="index-SUBREG_005fPROMOTED_005fVAR_005fP-2235"></a><a name="index-g_t_0040code_007bsubreg_007d-and-_0040samp_007b_002fs_007d-2236"></a><a name="index-g_t_0040code_007bin_005fstruct_007d_002c-in-_0040code_007bsubreg_007d-2237"></a><br><dt><code>SUBREG_PROMOTED_VAR_P (</code><var>x</var><code>)</code><dd>Nonzero in a <code>subreg</code> if it was made when accessing an object that
was promoted to a wider mode in accord with the <code>PROMOTED_MODE</code> machine
description macro (see <a href="Storage-Layout.html#Storage-Layout">Storage Layout</a>).  In this case, the mode of
the <code>subreg</code> is the declared mode of the object and the mode of
<code>SUBREG_REG</code> is the mode of the register that holds the object. 
Promoted variables are always either sign- or zero-extended to the wider
mode on every assignment.  Stored in the <code>in_struct</code> field and
printed as &lsquo;<samp><span class="samp">/s</span></samp>&rsquo;.

     <p><a name="index-SYMBOL_005fREF_005fUSED-2238"></a><a name="index-g_t_0040code_007bused_007d_002c-in-_0040code_007bsymbol_005fref_007d-2239"></a><br><dt><code>SYMBOL_REF_USED (</code><var>x</var><code>)</code><dd>In a <code>symbol_ref</code>, indicates that <var>x</var> has been used.  This is
normally only used to ensure that <var>x</var> is only declared external
once.  Stored in the <code>used</code> field.

     <p><a name="index-SYMBOL_005fREF_005fWEAK-2240"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002fi_007d-2241"></a><a name="index-g_t_0040code_007breturn_005fval_007d_002c-in-_0040code_007bsymbol_005fref_007d-2242"></a><br><dt><code>SYMBOL_REF_WEAK (</code><var>x</var><code>)</code><dd>In a <code>symbol_ref</code>, indicates that <var>x</var> has been declared weak. 
Stored in the <code>return_val</code> field and printed as &lsquo;<samp><span class="samp">/i</span></samp>&rsquo;.

     <p><a name="index-SYMBOL_005fREF_005fFLAG-2243"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d-and-_0040samp_007b_002fv_007d-2244"></a><a name="index-g_t_0040code_007bvolatil_007d_002c-in-_0040code_007bsymbol_005fref_007d-2245"></a><br><dt><code>SYMBOL_REF_FLAG (</code><var>x</var><code>)</code><dd>In a <code>symbol_ref</code>, this is used as a flag for machine-specific purposes. 
Stored in the <code>volatil</code> field and printed as &lsquo;<samp><span class="samp">/v</span></samp>&rsquo;.

     <p>Most uses of <code>SYMBOL_REF_FLAG</code> are historic and may be subsumed
by <code>SYMBOL_REF_FLAGS</code>.  Certainly use of <code>SYMBOL_REF_FLAGS</code>
is mandatory if the target requires more than one bit of storage. 
</dl>

 <p>These are the fields to which the above macros refer:

     
<a name="index-call-2246"></a>
<a name="index-g_t_0040samp_007b_002fc_007d-in-RTL-dump-2247"></a>
<dl><dt><code>call</code><dd>In a <code>mem</code>, 1 means that the memory reference will not trap.

     <p>In a <code>call</code>, 1 means that this pure or const call may possibly
infinite loop.

     <p>In an RTL dump, this flag is represented as &lsquo;<samp><span class="samp">/c</span></samp>&rsquo;.

     <p><a name="index-frame_005frelated-2248"></a><a name="index-g_t_0040samp_007b_002ff_007d-in-RTL-dump-2249"></a><br><dt><code>frame_related</code><dd>In an <code>insn</code> or <code>set</code> expression, 1 means that it is part of
a function prologue and sets the stack pointer, sets the frame pointer,
saves a register, or sets up a temporary register to use in place of the
frame pointer.

     <p>In <code>reg</code> expressions, 1 means that the register holds a pointer.

     <p>In <code>mem</code> expressions, 1 means that the memory reference holds a pointer.

     <p>In <code>symbol_ref</code> expressions, 1 means that the reference addresses
this function's string constant pool.

     <p>In an RTL dump, this flag is represented as &lsquo;<samp><span class="samp">/f</span></samp>&rsquo;.

     <p><a name="index-in_005fstruct-2250"></a><a name="index-g_t_0040samp_007b_002fs_007d-in-RTL-dump-2251"></a><br><dt><code>in_struct</code><dd>In <code>mem</code> expressions, it is 1 if the memory datum referred to is
all or part of a structure or array; 0 if it is (or might be) a scalar
variable.  A reference through a C pointer has 0 because the pointer
might point to a scalar variable.  This information allows the compiler
to determine something about possible cases of aliasing.

     <p>In <code>reg</code> expressions, it is 1 if the register has its entire life
contained within the test expression of some loop.

     <p>In <code>subreg</code> expressions, 1 means that the <code>subreg</code> is accessing
an object that has had its mode promoted from a wider mode.

     <p>In <code>label_ref</code> expressions, 1 means that the referenced label is
outside the innermost loop containing the insn in which the <code>label_ref</code>
was found.

     <p>In <code>code_label</code> expressions, it is 1 if the label may never be deleted. 
This is used for labels which are the target of non-local gotos.  Such a
label that would have been deleted is replaced with a <code>note</code> of type
<code>NOTE_INSN_DELETED_LABEL</code>.

     <p>In an <code>insn</code> during dead-code elimination, 1 means that the insn is
dead code.

     <p>In an <code>insn</code> or <code>jump_insn</code> during reorg for an insn in the
delay slot of a branch,
1 means that this insn is from the target of the branch.

     <p>In an <code>insn</code> during instruction scheduling, 1 means that this insn
must be scheduled as part of a group together with the previous insn.

     <p>In an RTL dump, this flag is represented as &lsquo;<samp><span class="samp">/s</span></samp>&rsquo;.

     <p><a name="index-return_005fval-2252"></a><a name="index-g_t_0040samp_007b_002fi_007d-in-RTL-dump-2253"></a><br><dt><code>return_val</code><dd>In <code>reg</code> expressions, 1 means the register contains
the value to be returned by the current function.  On
machines that pass parameters in registers, the same register number
may be used for parameters as well, but this flag is not set on such
uses.

     <p>In <code>mem</code> expressions, 1 means the memory reference is to a scalar
known not to be a member of a structure, union, or array.

     <p>In <code>symbol_ref</code> expressions, 1 means the referenced symbol is weak.

     <p>In <code>call</code> expressions, 1 means the call is pure.

     <p>In an RTL dump, this flag is represented as &lsquo;<samp><span class="samp">/i</span></samp>&rsquo;.

     <p><a name="index-jump-2254"></a><a name="index-g_t_0040samp_007b_002fj_007d-in-RTL-dump-2255"></a><br><dt><code>jump</code><dd>In a <code>mem</code> expression, 1 means we should keep the alias set for this
mem unchanged when we access a component.

     <p>In a <code>set</code>, 1 means it is for a return.

     <p>In a <code>call_insn</code>, 1 means it is a sibling call.

     <p>In an RTL dump, this flag is represented as &lsquo;<samp><span class="samp">/j</span></samp>&rsquo;.

     <p><a name="index-unchanging-2256"></a><a name="index-g_t_0040samp_007b_002fu_007d-in-RTL-dump-2257"></a><br><dt><code>unchanging</code><dd>In <code>reg</code> and <code>mem</code> expressions, 1 means
that the value of the expression never changes.

     <p>In <code>subreg</code> expressions, it is 1 if the <code>subreg</code> references an
unsigned object whose mode has been promoted to a wider mode.

     <p>In an <code>insn</code> or <code>jump_insn</code> in the delay slot of a branch
instruction, 1 means an annulling branch should be used.

     <p>In a <code>symbol_ref</code> expression, 1 means that this symbol addresses
something in the per-function constant pool.

     <p>In a <code>call_insn</code> 1 means that this instruction is a call to a const
function.

     <p>In an RTL dump, this flag is represented as &lsquo;<samp><span class="samp">/u</span></samp>&rsquo;.

     <p><a name="index-used-2258"></a><br><dt><code>used</code><dd>This flag is used directly (without an access macro) at the end of RTL
generation for a function, to count the number of times an expression
appears in insns.  Expressions that appear more than once are copied,
according to the rules for shared structure (see <a href="Sharing.html#Sharing">Sharing</a>).

     <p>For a <code>reg</code>, it is used directly (without an access macro) by the
leaf register renumbering code to ensure that each register is only
renumbered once.

     <p>In a <code>symbol_ref</code>, it indicates that an external declaration for
the symbol has already been written.

     <p><a name="index-volatil-2259"></a><a name="index-g_t_0040samp_007b_002fv_007d-in-RTL-dump-2260"></a><br><dt><code>volatil</code><dd><a name="index-volatile-memory-references-2261"></a>In a <code>mem</code>, <code>asm_operands</code>, or <code>asm_input</code>
expression, it is 1 if the memory
reference is volatile.  Volatile memory references may not be deleted,
reordered or combined.

     <p>In a <code>symbol_ref</code> expression, it is used for machine-specific
purposes.

     <p>In a <code>reg</code> expression, it is 1 if the value is a user-level variable. 
0 indicates an internal compiler temporary.

     <p>In an <code>insn</code>, 1 means the insn has been deleted.

     <p>In <code>label_ref</code> and <code>reg_label</code> expressions, 1 means a reference
to a non-local label.

     <p>In an RTL dump, this flag is represented as &lsquo;<samp><span class="samp">/v</span></samp>&rsquo;. 
</dl>

 </body></html>

