<html lang="zh">
<head>
<title>循环表示 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e5_00be_00aa_00e7_008e_00af_00e5_0088_0086_00e6_009e_0090_00e5_0092_008c_00e8_00a1_00a8_00e7_00a4_00ba.html#g_t_00e5_00be_00aa_00e7_008e_00af_00e5_0088_0086_00e6_009e_0090_00e5_0092_008c_00e8_00a1_00a8_00e7_00a4_00ba" title="循环分析和表示">
<link rel="next" href="_00e5_00be_00aa_00e7_008e_00af_00e6_009f_00a5_00e8_00af_00a2.html#g_t_00e5_00be_00aa_00e7_008e_00af_00e6_009f_00a5_00e8_00af_00a2" title="循环查询">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%be%aa%e7%8e%af%e8%a1%a8%e7%a4%ba"></a>
<a name="g_t_00e5_00be_00aa_00e7_008e_00af_00e8_00a1_00a8_00e7_00a4_00ba"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_00be_00aa_00e7_008e_00af_00e6_009f_00a5_00e8_00af_00a2.html#g_t_00e5_00be_00aa_00e7_008e_00af_00e6_009f_00a5_00e8_00af_00a2">循环查询</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e5_00be_00aa_00e7_008e_00af_00e5_0088_0086_00e6_009e_0090_00e5_0092_008c_00e8_00a1_00a8_00e7_00a4_00ba.html#g_t_00e5_00be_00aa_00e7_008e_00af_00e5_0088_0086_00e6_009e_0090_00e5_0092_008c_00e8_00a1_00a8_00e7_00a4_00ba">循环分析和表示</a>
<hr>
</div>

<h3 class="section">14.1 循环表示</h3>

<p><a name="index-Loop-representation-3072"></a><a name="index-Loop-analysis-3073"></a>
这章描述了GCC中循环的表示，以及可以用来构建，修改和分析这些表示的函数。
大多数接口和数据结构都在<samp><span class="file">cfgloop.h</span></samp>中声明。目前，
只是由处理循环的优化过程来分析这些循环结构和更新这些信息，
不过正在做一些努力，使得其在大多数优化过程中都可用。

 <p>通常，一个自然的循环会具有一个入口块（header），
以及可能多个的从循环内部通向header的回边（latch）。
如果多个循环共享单个 header，或者在循环中间有个分支跳转，
则可能会出现带有多个latch的循环。然而GCC中对循环的表示只允许具有单个latch。
在循环分析过程中，为了消除循环结构的歧义，这样的循环的header会被拆分，
并创建前向的块。基于profile信息的heuristic，
以及循环中的归纳变量的结构被用来判定latches是否与子循环相关，
还是与单个循环中的控制流相关。这意味着分析有时候会改变CFG，
并且如果你在一个优化过程的中间运行了该分析，则必须能够处理新的块。
可以通过传递<code>LOOPS_MAY_HAVE_MULTIPLE_LATCHES</code>标记来避免CFG改变，
但是要注意，对于具有多个latch边的循环，
大多其它的循环操作函数将无法正确工作
（只有查询块成员与循环和子循环关系的，或者枚举和测试循环出口的函数能够工作）。

 <p>循环体是由header支配的一组基本块，并且可以通过回边沿着CFG中边的方向达到。
循环使用树的层次结构来组织，直接包含在循环L中的所有循环在树中都为L的子节点。
该树由<code>struct loops</code>结构体表示。该树的根是一个假循环，包含了函数中的所有块。
每个循环都由<code>struct loop</code>结构体表示。
每个循环都被赋予一个索引（<code>struct loop</code>结构体的<code>num</code>域），
并且指向循环的指针被存在<code>struct loops</code>结构体中的<code>larray</code>向量的对应域里。
索引不必是连续的，<code>larray</code>中可能会有空项（<code>NULL</code>），是由删除循环产生的。
而且不保证索引的数字与循环和子循环有关系。循环的索引不会改变。

 <p>不要直接访问<code>larray</code>域中的项。函数<code>get_loop</code>返回给定索引的循环描述。
<code>number_of_loops</code>函数返回函数中的循环数目。要遍历所有的循环，
使用<code>FOR_EACH_LOOP</code>宏。宏的标记参数用来决定遍历的方向和要访问的循环集。
不管循环树是否变化，以及在遍历过程中循环是否被移除，每个循环都保证只被访问一次。
新创建的循环将不会被访问到，如果需要访问，这必须在它们创建之后单独进行。
<code>FOR_EACH_LOOP</code>宏会分配临时变量，如果使用break或者goto终止了<code>FOR_EACH_LOOP</code>，
它们将不会被释放；因此必须使用<code>FOR_EACH_LOOP_BREAK</code>宏。

 <p>每个基本块包含了对其所属的最内层循环的引用（<code>loop_father</code>）。
基于这个原因，对每个CFG只可能有一个<code>struct loops</code>结构体在同一时间被初始化。
全局变量<code>current_loops</code>包含了<code>struct loops</code>结构体。
许多循环操作函数都假设dominance信息是最新的。

 <p>通过<code>loop_optimizer_init</code>函数来分析循环。
该函数的参数是一个标记集，使用整数位掩码表示。
这些标记指定了循环结构体的其它哪些属性将在之后被计算/赋予，并且保留：

     <ul>
<li><code>LOOPS_MAY_HAVE_MULTIPLE_LATCHES</code>:
如果设置了该标记，循环分析将不会改变CFG，特别的，
具有多个回边的循环将不会被消除歧义。如果循环具有多个回边，
它的回边块被设为NULL。对于这种形式，大多循环操作函数将无法工作。
<li><code>LOOPS_HAVE_PREHEADERS</code>:
创建前驱块的方法为，每个循环只有一个入口边，另外，这个入口边的源块只有一个后继。
这就创建了一个自然的位置，使得代码能够被移出循环，
并且保证循环的入口边由它的直接外循环进来。
<li><code>LOOPS_HAVE_SIMPLE_LATCHES</code>:
创建前驱块，从而使得每个循环的回边块只有一个后继。
这就保证了循环的回边不属于任何子循环，并且使得对循环的操作变得非常容易。
许多循环操作函数都假设循环是处于这种形式的。注意使用该标记时，
其中没有任何控制流，且只有一个出口的“正常”循环，将包括两个基本块。
<li><code>LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS</code>:
强连通组件中的基本块和边，如果不是自然循环（具有多个入口块），
将被<code>BB_IRREDUCIBLE_LOOP</code>和<code>EDGE_IRREDUCIBLE_LOOP</code>标记。
在这样的不可消减区域中的块和边，如果属于自然循环的，
则不被标记（但是会为进入和离开该区域的入口边和出口边做标记）。
<li><code>LOOPS_HAVE_RECORDED_EXITS</code>:
为每个循环记录并更新出口列表。
这使得一些函数（如<code>get_loop_exit_edges</code>）更加有效。
一些函数（如<code>single_exit</code>）只有在出口列表被记录的情况下才能用。
</ul>

 <p>这些属性也可以在之后使用函数<code>create_preheaders</code>,
<code>force_single_succ_latches</code>,<code>mark_irreducible_loops</code> 和
<code>record_loop_exits</code>来求得/赋予。

 <p>循环结构体占用的内存应该在<code>loop_optimizer_finalize</code>函数中被释放。

 <p>CFG操作函数通常不更新循环结构体。在GIMPLE上，如果设置了<code>current_loops</code>，
则<code>cleanup_tree_cfg_loop</code>可以被用来在清除CFG的同时，更新循环结构体。

 </body></html>

