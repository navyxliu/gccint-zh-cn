<html lang="zh">
<head>
<title>副作用 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="RTL_00e5_00a3_00b0_00e6_0098_008e.html#RTL_00e5_00a3_00b0_00e6_0098_008e" title="RTL声明">
<link rel="next" href="Incdec.html#Incdec" title="Incdec">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%89%af%e4%bd%9c%e7%94%a8"></a>
<a name="g_t_00e5_0089_00af_00e4_00bd_009c_00e7_0094_00a8"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Incdec.html#Incdec">Incdec</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="RTL_00e5_00a3_00b0_00e6_0098_008e.html#RTL_00e5_00a3_00b0_00e6_0098_008e">RTL声明</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.15 副作用表达式</h3>

<p><a name="index-RTL-side-effect-expressions-2551"></a>
目前为止，所描述的表达式代码都是用来表示一个值，而不是操作。但是机器指令是不会产生值的，而只是通过副作用来改变机器状态。特定的表达式代码被用来表示副作用。

 <p>一条指令的主体，总是这些副作用代码之一；上面描述的表示值的代码，只是作为操作数出现在其中。

     
<a name="index-set-2552"></a>
<dl><dt><code>(set </code><var>lval</var> <var>x</var><code>)</code><dd>表示将<var>x</var>的值存放到由<var>lval</var>表示的地方。<var>lval</var>必须是表示可以用来存放的地方的表达式：<code>reg</code>（或者<code>subreg</code>，<code>strict_low_part</code>或者<code>zero_extract</code>），<code>mem</code>，<code>pc</code>，<code>parallel</code>或者<code>cc0</code>。

     <p>如果<var>lval</var>是一个<code>reg</code>，<code>subreg</code>或者<code>mem</code>，其具有一个机器模式；则<var>x</var>必须对这种模式有效。

     <p>如果<var>lval</var>是一个<code>subreg</code>的<code>strict_low_part</code>，则由<code>subreg</code>的机器模式所指定的寄存器的那部分被赋予值<var>x</var>，而寄存器的其它部分不变。

     <p>如果<var>lval</var>是一个<code>zero_extract</code>，则由<code>zero_extract</code>指定的相关位域（内存或者寄存器相关的），被赋予值<var>x</var>，而其它位域不变。注意<code>sign_extract</code>不能出现在<var>lval</var>中。

     <p>如果<var>lval</var>是<code>(cc0)</code>，其没有机器模式，并且<var>x</var>可以为一个<code>compare</code>表达式或者任意模式的值。后者情况表示是一个“test”指令。表达式<code>(set (cc0) (reg:</code><var>m</var> <var>n</var><code>))</code> 等价于<code>(set (cc0) (compare (reg:</code><var>m</var> <var>n</var><code>)))</code>。在编译过程中可以使用前一个表达式来节省空间。

     <p>如果<var>lval</var>是一个<code>parallel</code>，其用来表示一个函数通过多个寄存器来返回一个结构体的情况。<code>parallel</code>中的每一个元素是一个<code>expr_list</code>，其第一个操作数是一个<code>reg</code>，并且第二个操作数是一个<code>const_int</code>，表示相应寄存器的数据在结构体中的偏移量（以字节为单位）。第一个元素也可能为null，用来指示结构体也有一部分是在内存中传递的。

     <p><a name="index-jump-instructions-and-_0040code_007bset_007d-2553"></a><a name="index-g_t_0040code_007bif_005fthen_005felse_007d-usage-2554"></a>如果<var>lval</var>是<code>(pc)</code>，则为一个跳转指令，并且<var>x</var>只有几种可能。其可能为一个<code>label_ref</code>表达式（无条件跳转）。可能为一个<code>if_then_else</code>（条件跳转），这种情况下，第二个或者第三个操作数必须是<code>(pc)</code>（用于不进行跳转的情况），并且另外两个必须是一个<code>label_ref</code>（用于进行跳转的情况）。<var>x</var>也可以是一个<code>mem</code>或者<code>(plus:SI (pc) </code><var>y</var><code>)</code>, 其中y可以为一个<code>reg</code>或者<code>mem</code>；这些独特的模式用来表示通过分支表来进行跳转。

     <p>如果<var>lval</var>即不是<code>(cc0)</code>也不是<code>(pc)</code>,则<var>lval</var>的模式一定不是<code>VOIDmode</code>，并且<var>x</var>的模式必须对于<var>lval</var>的模式有效。

     <p><a name="index-SET_005fDEST-2555"></a><a name="index-SET_005fSRC-2556"></a><var>lval</var>通常通过<code>SET_DEST</code>宏来访问，<var>x</var>通常使用<code>SET_SRC</code>宏。

     <p><a name="index-return-2557"></a><br><dt><code>(return)</code><dd>在指令模式中作为单独的表达式，表示从当前函数的一个返回，在一些机器上，可以使用一条指令来完成，例如VAXen。在一些机器上，为了从函数中返回，包括多条指令的尾声必须被执行，则返回操作，通过跳转到一个位于尾声之前的标号来完成，并且不使用<code>return</code>表达式代码。

     <p>在<code>if_then_else</code>表达式中，表示放在<code>pc</code>中的，返回给调用者的值。

     <p>注意，指令模式为<code>(return)</code>的insn，在逻辑上等价于<code>(set (pc) (return))</code>，但是不使用后者的形式。

     <p><a name="index-call-2558"></a><br><dt><code>(call </code><var>function</var> <var>nargs</var><code>)</code><dd>表示一个函数调用。<var>function</var>为一个<code>mem</code>表达式，其地址为被调用的函数的地址。<var>nargs</var>为一个表达式，其可以用于两个目的：在一些机器上，其表示栈参数的字节数目；在其它机器上，其表示参数寄存器的数目。

     <p>每个机器具有一个标准的，<var>function</var>必须具有的机器模式。机器描述定义了宏<code>FUNCTION_MODE</code>，来扩展为需要的模式名。在一些机器上，所允许的寻址方式取决于被寻址的机器模式，则该机器模式的用途是来描述，允许什么样的寻址。

     <p><a name="index-clobber-2559"></a><br><dt><code>(clobber </code><var>x</var><code>)</code><dd>表示一个不可预期的存储或者可能的存储，将不可描述的值存储到<var>x</var>，其必须为一个<code>reg</code>，<code>scratch</code>, <code>parallel</code> 或者 <code>mem</code>表达式。

     <p>可以用在字符串指令中，将标准的值存储到特定的硬件寄存器中。不需要去描述被存储的值，只用来告诉编译器寄存器被修改了，以免其尝试在字符串指令中保持数据。

     <p>如果<var>x</var>为<code>(mem:BLK (const_int 0))</code>或者<code>(mem:BLK (scratch))</code>，则意味着所有的内存位置必须假设被破坏。如果<var>x</var>为一个<code>parallel</code>，其具有与<code>set</code>表达式中的<code>parallel</code>相同的含义。

     <p>注意，机器描述将特定的硬件寄存器归类为“call-clobbered”。所有函数调用指令都被假设为，缺省的，会破坏这些寄存器，所以不需要使用<code>clobber</code>表达式来表示这些。而且，每个函数调用都被假设为潜在的修改任何内存位置，除非函数被声明为<code>const</code>。

     <p>如果在<code>parallel</code>中的最后一组表达式为<code>clobber</code>表达式，其参数为<code>reg</code>或者<code>match_scratch</code>（see <a href="RTL-Template.html#RTL-Template">RTL Template</a>）表达式，则合并阶段可以向构建的insn中增加适当的<code>clobber</code>表达式，当这样可以使得指令模式被匹配。

     <p>例如，该特点可以用在，乘法和加法指令不使用MQ寄存器，但具有一个加法累加指令，而且破坏MQ寄存器的机器上。类似的，被合并的指令可能需要临时的寄存器，而成员指令则不需要。

     <p>当寄存器的<code>clobber</code>表达式，出现在具有其它副作用的<code>parallel</code>中，如果是硬件寄存器，则寄存器分配者来确保在insn之前和之后，该寄存器都不会被占用。对于伪寄存器的破坏，寄存器分配者和重载过程，不对clobber分配相同的硬件寄存器，以及输入操作数。你可以破坏一个特定的硬件寄存器，一个伪寄存器，或者一个<code>scratch</code>表达式；在后两种情况下，GCC将会分配一个硬件寄存器，临时使用。

     <p>对于需要临时寄存器的指令，应该使用<code>scratch</code>，而不是伪寄存器，因为这将使得合并阶段可以在需要的时候增加<code>clobber</code>。方式为(<code>clobber</code> (<code>match_scratch</code> <small class="dots">...</small>))。如果确实是破坏了一个伪寄存器，则使用没有出现在其它地方的伪寄存器，每次生成一个新的。否则，你可能会使CSE（公共子表达式消除）迷惑。

     <p>还有一种在<code>parallel</code>中破坏伪寄存器的用法：当insn的输入操作数也被insn破坏。这种情况下，使用相同的伪寄存器。

     <p><a name="index-use-2560"></a><br><dt><code>(use </code><var>x</var><code>)</code><dd>表示对<var>x</var>值的使用。其表示<var>x</var>中的值在程序的这个点上是被需要的，即使可能不清楚为什么。因此，如果先前的执行的作用只是将一个值存储在<var>x</var>中，则编译器将不会尝试将其删除。<var>x</var>必须为一个<code>reg</code>表达式。

     <p>在一些情况下，可能会想到，在<code>parallel</code>中增加一个对寄存器的<code>use</code>，来描述特定寄存器的值将会影响指令的行为。一个假定的例子为，对于一个加法指令模式，其可以根据特定的控制寄存器的值来执行环绕或者饱和加法：

     <pre class="smallexample">          (parallel [(set (reg:SI 2) (unspec:SI [(reg:SI 3)
                                                 (reg:SI 4)] 0))
                     (use (reg:SI 1))])
</pre>
     <p class="noindent">这将不会工作，一些优化器将只查看局部的表达式；很可能如果你有多个具有针对<code>unspec</code>相同输入的insn，它们将被优化掉，即使寄存器1中间有所改变。

     <p>这意味着，<code>use</code>只能被用于描述寄存器是活跃的。在增加<code>use</code>语句时，你应该多思考一下，通常，你将会使用<code>unspec</code>来替代。<code>use</code> RTX最常用于描述一个隐式的用于insn的固定寄存器。还可以安全的用于，编译器知道整个指令模式的结果是可变的，这样的指令模式中，例如&lsquo;<samp><span class="samp">movmem</span><var>m</var></samp>&rsquo;或者&lsquo;<samp><span class="samp">call</span></samp>&rsquo;。

     <p>在重载阶段，具有<code>use</code>指令模式的insn可以附带一个reg_equal注解。这些<code>use</code> insn将在重载阶段退出之前被删除。

     <p>在延迟分支调度阶段，<var>x</var>可以为一个insn。这表示<var>x</var>之前曾经在该位置被定位，它的数据依赖需要被考虑。这些<code>use</code> insn将在延迟分支调度阶段退出之前被删除。

     <p><a name="index-parallel-2561"></a><br><dt><code>(parallel [</code><var>x0</var> <var>x1</var><code> ...])</code><dd>表示并行执行多个副作用。方括号表示一个向量；<code>parallel</code>的操作数为向量表达式。<var>x0</var>, <var>x1</var>等等为单独的副作用表达式，<code>set</code>, <code>call</code>, <code>return</code>, <code>clobber</code> 或 <code>use</code>。

     <p>“并行”意味着，首先所有在单个副作用中使用的值将被计算，然后，所有实际的副作用被执行。例如，

     <pre class="smallexample">          (parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
                     (set (mem:SI (reg:SI 1)) (reg:SI 1))])
</pre>
     <p class="noindent">清楚的说明了，将硬件寄存器1的值与其所寻址的内存中的值进行交换。在<code>(reg:SI 1)</code>作为内存地址出现的两个地方，其都是使用执行insn之前，在寄存器1中的值。

     <p>从而，如果使用<code>parallel</code>，并且期望<code>set</code>的值，可以用于下一个<code>set</code>，则是不正确的。例如，人们有时候尝试用这种方式来表示，为零则跳转的指令：

     <pre class="smallexample">          (parallel [(set (cc0) (reg:SI 34))
                     (set (pc) (if_then_else
                                  (eq (cc0) (const_int 0))
                                  (label_ref ...)
                                  (pc)))])
</pre>
     <p class="noindent">但这是不正确的，因为其说明了跳转条件取决于，该指令之前的条件代码的值，而不是被该指令设置后的新值。

     <p><a name="index-peephole-optimization_002c-RTL-representation-2562"></a>与最后的汇编代码输出一起执行的窥孔优化，可以产生由<code>parallel</code>组成的insn，其元素为需要输出汇编代码的操作数，通常为<code>reg</code>, <code>mem</code>或者常量表达式。这在其它编译阶段，将不是一个好的RTL形式，但是在这里是可以的，因为已经没有其它的优化了。然而，宏<code>NOTICE_UPDATE_CC</code>的定义，如果存在，如果定义了窥孔优化，则需要处理这样的insn。

     <p><a name="index-cond_005fexec-2563"></a><br><dt><code>(cond_exec [</code><var>cond</var> <var>expr</var><code>])</code><dd>表示一个条件执行表达式。只有当<var>cond</var>为非零时，<var>expr</var>才被执行。<var>cond</var>表达式不能具有副作用，但是<var>expr</var>可以。

     <p><a name="index-sequence-2564"></a><br><dt><code>(sequence [</code><var>insns</var><code> ...])</code><dd>表示一个insn序列。每个出现在向量中的<var>insns</var>，都适合出现在insn链中，所以其必须为<code>insn</code>, <code>jump_insn</code>, <code>call_insn</code>, <code>code_label</code>, <code>barrier</code> 或 <code>note</code>。

     <p>在RTL生成过程中，不会在实际的insn中放入<code>sequence</code> RTX。其表示<code>define_expand</code>产生的insn序列，用来传递给<code>emit_insn</code>，从而将它们插入到insn链中。当实际被插入的时候，单独的子insn将被分离出来，<code>sequence</code>将被忽略掉。

     <p>当延迟槽调度完成之后，insn和所有位于其延迟槽中的insn被组成一个<code>sequence</code>。需要延迟槽的insn为向量中的第一个insn；后续的insn为将被放在延迟槽中的insn。

     <p><code>INSN_ANNULLED_BRANCH_P</code>用来表示分支insn将会有条件的取消延迟槽中的insn的效果。这种情况下，<code>INSN_FROM_TARGET_P</code>表示insn是来自分支的目标，并且只有当进行分支时，其才被执行；否则，insn只有当不进行分支时才被执行。See <a href="Delay-Slots.html#Delay-Slots">Delay Slots</a>

 </dl>

 <p>这些表达式代码出现在副作用的地方，作为insn的主体，虽然严格的讲，它们并不总是描述副作用：

     
<a name="index-asm_005finput-2565"></a>
<dl><dt><code>(asm_input </code><var>s</var><code>)</code><dd>表示文字的汇编代码，通过字符串<var>s</var>来描述。

     <p><a name="index-unspec-2566"></a><a name="index-unspec_005fvolatile-2567"></a><br><dt><code>(unspec [</code><var>operands</var><code> ...] </code><var>index</var><code>)</code><dt><code>(unspec_volatile [</code><var>operands</var><code> ...] </code><var>index</var><code>)</code><dd>表示一个机器特定的针对<var>operands</var>的操作。<var>index</var>在多个机器特定的操作之间进行选择。<code>unspec_volatile</code>用于volatile操作，并且可以有陷阱；<code>unspec</code>用于其它操作。

     <p>这些代码可以出现在insn的<code>pattern</code>中，<code>parallel</code>中，或者表达式中。

     <p><a name="index-addr_005fvec-2568"></a><br><dt><code>(addr_vec:</code><var>m</var><code> [</code><var>lr0</var> <var>lr1</var><code> ...])</code><dd>表示跳转地址表。向量元素<var>lr0</var>等等，为<code>label_ref</code>表达式。机器模式<var>m</var>描述了为每个地址给定了多少空间；通常<var>m</var>为<code>Pmode</code>。

     <p><a name="index-addr_005fdiff_005fvec-2569"></a><br><dt><code>(addr_diff_vec:</code><var>m</var> <var>base</var><code> [</code><var>lr0</var> <var>lr1</var><code> ...] </code><var>min</var> <var>max</var> <var>flags</var><code>)</code><dd>表示一个跳转地址表，表示为<var>base</var>的偏移量。向量元素<var>lr0</var>等等，为<code>label_ref</code>表达式，<var>base</var>也是。机器模式<var>m</var>描述了为每个地址偏移给定的空间大小。<var>min</var>和<var>max</var>由分支缩短过程设置，分别存放了一个具有最小地址和最大地址的标号。详情参见rtl.def。

     <p><a name="index-prefetch-2570"></a><br><dt><code>(prefetch:</code><var>m</var> <var>addr</var> <var>rw</var> <var>locality</var><code>)</code><dd>表示对地址为<var>addr</var>的内存进行预取。如果预取的数据将被写，则操作数为<var>rw</var>，否则为0；不支持写预取的目标机，应该将其作为一个普通的预取。操作数<var>locality</var>描述了时间局部性的数量；如果没有，则为0，否则按照时间局部性的递增级别，依次为1，2或者3；不支持局部性暗示的目标机，应该忽略该项。

     <p>该insn用于最小化cache-miss的延迟，通过在访问数据之前将其移送到cache中。其应该只用于非故障的数据预取指令。

 </dl>

 </body></html>

