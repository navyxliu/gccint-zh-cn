<html lang="zh">
<head>
<title>扩展定义 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0" title="机器描述">
<link rel="prev" href="Insn_00e8_00a7_0084_00e8_008c_0083_00e5_008c_0096.html#Insn_00e8_00a7_0084_00e8_008c_0083_00e5_008c_0096" title="Insn规范化">
<link rel="next" href="Insn_00e6_008b_0086_00e5_0088_0086.html#Insn_00e6_008b_0086_00e5_0088_0086" title="Insn拆分">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%89%a9%e5%b1%95%e5%ae%9a%e4%b9%89"></a>
<a name="g_t_00e6_0089_00a9_00e5_00b1_0095_00e5_00ae_009a_00e4_00b9_0089"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Insn_00e6_008b_0086_00e5_0088_0086.html#Insn_00e6_008b_0086_00e5_0088_0086">Insn拆分</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Insn_00e8_00a7_0084_00e8_008c_0083_00e5_008c_0096.html#Insn_00e8_00a7_0084_00e8_008c_0083_00e5_008c_0096">Insn规范化</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0">机器描述</a>
<hr>
</div>

<h3 class="section">16.15 为代码生成定义RTL序列</h3>

<p><a name="index-expander-definitions-3543"></a><a name="index-code-generation-RTL-sequences-3544"></a><a name="index-defining-RTL-sequences-for-code-generation-3545"></a>
在一些目标机上，一些用于RTL生成的标准指令模式名无法通过单个insn来处理，
但是可以用一个RTL insn序列来表示它们。对于这些目标机，
你可以写一个<code>define_expand</code>来指定如何生成RTL序列。

 <p><a name="index-define_005fexpand-3546"></a><code>define_expand</code>为一个RTL表达式，看起来非常像<code>define_insn</code>；
但是不同之处为，<code>define_expand</code>只用于RTL生成，并且可以产生多个RTL insn。

 <p><code>define_expand</code> RTX具有4个操作数:

     <ul>
<li>名字。每个<code>define_expand</code>必须具有一个名字，
因为必须通过对名字的引用才能使用它。

     <li>RTL模板。这是一个RTL表达式向量，表示一个指令序列。

     <li>条件，一个字符串包含了一个C表达式。
该表达式用于表示该指令模式对于GCC运行时命令行选项所选择的什么样的target机器
子类别有效。这跟具有标准名字的<code>define_insn</code>的条件类似。因此，
条件（如果存在）可以不依赖于所匹配的insn的数据，而只是依赖于target机器类型标号。
编译器需要在初始化时测试这些条件，以便确切的知道在一次特定的运行时，
哪些命名指令有效。

     <li>准备语句，一个字符串，包含了0个或多个C语句，其将在RTL模板生成RTL代码前被执行。
</ul>

 <p>每个由<code>define_expand</code>生成的RTL insn必须匹配机器描述中的某个
<code>define_insn</code>。否则，编译器在尝试为insn生成代码或者试图对其进行优化的时候，
将会崩溃。

 <p>RTL模板，除了控制RTL insn的生成，还描述了当使用该指令模式时，
所需要指定的操作数。特别是，它为每个操作数给出了断言。

 <p>需要被指定的由指令模式生成RTL的，真正的操作数，
在RTL模板中它第一次出现的位置使用<code>match_operand</code>来描述。
这将把对于操作数的断言信息放入记录该事情的表中。
如果操作数被引用多次，则后续的引用应该使用<code>match_dup</code>。

 <p>RTL模板还可以引用内部操作数，
其为只在由<code>define_expand</code>生成的序列中使用的临时寄存器或者标号。
内部操作数使用<code>match_dup</code>来替换到RTL模板中，而不是<code>match_operand</code>。
内部操作数的值在编译器需要使用该指令模式时，不作为参数传入。替代的，
它们在指令模式中计算，在准备语句中。
这些语句计算值并将它们存入到合适的<code>operands</code>元素中，
以便<code>match_dup</code>可以找到它们。

 <p>有两个特定的宏，用于准备语句中：<code>DONE</code>和<code>FAIL</code>。
在其后面跟随一个分号，以作为一条语句来使用。

     
<a name="index-DONE-3547"></a>
<dl><dt><code>DONE</code><dd>使用<code>DONE</code>宏来结束该指令模式的RTL生成。这种情况下，
由该指令模式生成的唯一的RTL insn将为在准备语句中显示调用<code>emit_insn</code>生成
的insn；RTL模板将不被生成。

     <p><a name="index-FAIL-3548"></a><br><dt><code>FAIL</code><dd>
使指令模式对于这种情况失败。当指令模式失败时，这意味着指令模式实际上无效。编译器中的调用程序将会尝试其它策略，使用其它指令模式来进行代码生成。

     <p>目前，FAIL操作只支持二元（加法，乘法，移位等）和
位域（<code>extv</code>, <code>extzv</code>和<code>insv</code>）操作。
</dl>

 <p>如果准备语句即没有调用<code>DONE</code>，也没有调用<code>FAIL</code>，
则<code>define_expand</code>的行为便跟<code>define_insn</code>一样，即RTL模板用于生成insn

 <p>RTL模板不用于匹配，只是用于生成最初的insn列表。
如果准备语句总是调用<code>DONE</code>或者<code>FAIL</code>，
则RTL模板可以简化为一个简单的操作数列表，例如：

<pre class="smallexample">     (define_expand "addsi3"
       [(match_operand:SI 0 "register_operand" "")
        (match_operand:SI 1 "register_operand" "")
        (match_operand:SI 2 "register_operand" "")]
       ""
       "
     {
       handle_add (operands[0], operands[1], operands[2]);
       DONE;
     }")
</pre>
 <p>这里有一个例子，是为SPUR芯片定义的左移位：

<pre class="smallexample">     (define_expand "ashlsi3"
       [(set (match_operand:SI 0 "register_operand" "")
             (ashift:SI
               (match_operand:SI 1 "register_operand" "")
               (match_operand:SI 2 "nonmemory_operand" "")))]
       ""
       "
</pre>
 <pre class="smallexample">     {
       if (GET_CODE (operands[2]) != CONST_INT
           || (unsigned) INTVAL (operands[2]) &gt; 3)
         FAIL;
     }")
</pre>
 <p class="noindent">这个例子使用了<code>define_expand</code>，使得当移位数在支持的0到3的范围内时，
便会生成移位RTL insn，而对于其它情况，则会失败。当其失败时，
编译器便会使用不同的指令模式（比如一个库调用）来尝试其它策略。

 <p>如果编译器能够处理具有名字的指令模式中的非平凡的条件字符串，
则对于这样情况也可以使用<code>define_insn</code>。这里有另一种情况（68000上的0扩展），
其使用了<code>define_expand</code>的更强大的功能：

<pre class="smallexample">     (define_expand "zero_extendhisi2"
       [(set (match_operand:SI 0 "general_operand" "")
             (const_int 0))
        (set (strict_low_part
               (subreg:HI
                 (match_dup 0)
                 0))
             (match_operand:HI 1 "general_operand" ""))]
       ""
       "operands[1] = make_safe_from (operands[1], operands[0]);")
</pre>
 <p class="noindent"><a name="index-make_005fsafe_005ffrom-3549"></a>这里将会生成两个RTL insn，一个用于清除整个输出操作数，
另一个用于将输入操作数复制到其低半部份。
该指令序列在输入操作数指向输出操作数（的旧值）时，是不正确的。
所以，准备语句用来确保不是这样。当其指向<code>operands[0]</code>时，
函数<code>make_safe_from</code>用来将<code>operands[1]</code>复制到临时寄存器中。
其通过生成另一个RTL insn来完成这件事。

 <p>最后，第三个例子显示了内部操作数的使用。
在SPUR芯片上的0扩展是通过将结果与上半字mask来完成的。
但是该mask不能通过一个<code>const_int</code>来表示，因为常量值太大，
无法在该机器上被合法化。所以其必须使用<code>force_reg</code>复制到寄存器中，
然后在<code>and</code>中使用该寄存器。

<pre class="smallexample">     (define_expand "zero_extendhisi2"
       [(set (match_operand:SI 0 "register_operand" "")
             (and:SI (subreg:SI
                       (match_operand:HI 1 "register_operand" "")
                       0)
                     (match_dup 2)))]
       ""
       "operands[2]
          = force_reg (SImode, GEN_INT (65535)); ")
</pre>
 <p>注意：如果<code>define_expand</code>被用于一个标准的二元或者一元算数运算，
或者一个位域运算，则其生成的最后的insn一定不能为一个<code>code_label</code>,
<code>barrier</code>或<code>note</code>。其必须为一个<code>insn</code>,
<code>jump_insn</code>或<code>call_insn</code>。如果你在结尾处不需要实际的insn，
则可以生成一条将操作数的结果复制到其本身的insn。这样的insn将不会生成代码，
但可以避免编译器中的问题。

 </body></html>

