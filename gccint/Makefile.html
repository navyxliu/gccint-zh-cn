<html lang="en">
<head>
<title>Makefile - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="gcc_00e7_009b_00ae_00e5_00bd_0095.html#gcc_00e7_009b_00ae_00e5_00bd_0095" title="gcc目录">
<link rel="prev" href="_00e6_009e_0084_00e5_00bb_00ba.html#g_t_00e6_009e_0084_00e5_00bb_00ba" title="构建">
<link rel="next" href="_00e5_00ba_0093_00e6_0096_0087_00e4_00bb_00b6.html#g_t_00e5_00ba_0093_00e6_0096_0087_00e4_00bb_00b6" title="库文件">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Makefile"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_00ba_0093_00e6_0096_0087_00e4_00bb_00b6.html#g_t_00e5_00ba_0093_00e6_0096_0087_00e4_00bb_00b6">库文件</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_009e_0084_00e5_00bb_00ba.html#g_t_00e6_009e_0084_00e5_00bb_00ba">构建</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="gcc_00e7_009b_00ae_00e5_00bd_0095.html#gcc_00e7_009b_00ae_00e5_00bd_0095">gcc目录</a>
<hr>
</div>

<h4 class="subsection">6.3.4 Makefile工作目标</h4>

<p><a name="index-makefile-targets-1660"></a><a name="index-targets_002c-makefile-1661"></a>
这些工作目标可以从&lsquo;<samp><span class="samp">gcc</span></samp>&rsquo;目录下获得：

     <dl>
<dt><code>all</code><dd>这是缺省工作目标。它会根据你对build/host/target的配置，
来协调构建所有需要的事物。

     <br><dt><code>doc</code><dd>生成info格式的文档和man页。实质上它是调用了&lsquo;<samp><span class="samp">make man</span></samp>&rsquo;和&lsquo;<samp><span class="samp">make info</span></samp>&rsquo;。

     <br><dt><code>dvi</code><dd>生成DVI格式的文档。

     <br><dt><code>pdf</code><dd>生成PDF格式的文档。

     <br><dt><code>html</code><dd>生成HTML格式的文档。

     <br><dt><code>man</code><dd>生成man页。

     <br><dt><code>info</code><dd>生成info格式的页。

     <br><dt><code>mostlyclean</code><dd>删除构建编译器中创建的文件。

     <br><dt><code>clean</code><dd>由&lsquo;<samp><span class="samp">make all</span></samp>&rsquo;创建的所有其它文件。

     <br><dt><code>distclean</code><dd>由<samp><span class="command">configure</span></samp>创建的所有文件。

     <br><dt><code>maintainer-clean</code><dd>Distclean，以及任何由其它文件生成的文件。
注意可能会需要，除了构建gcc所需的，额外的工具。

     <br><dt><code>srcextra</code><dd>在源目录生成不在CVS中存在的，但是属于发行tar包的文件。
由CVS源文件<samp><span class="file">gcc/java/parse.y</span></samp>生成的<samp><span class="file">gcc/java/parse.c</span></samp>是一个例子。

     <br><dt><code>srcinfo</code><dt><code>srcman</code><dd>将info格式的和manpage文档复制到源目录，用于生成发行tar包。

     <br><dt><code>install</code><dd>安装gcc。

     <br><dt><code>uninstall</code><dd>删除安装的文件。

     <br><dt><code>check</code><dd>运行测试包。这将创建一个<samp><span class="file">testsuite</span></samp>子目录，
其中具有各种包含测试结果的<samp><span class="file">.sum</span></samp>和<samp><span class="file">.log</span></samp>文件。
可以使用，例如&lsquo;<samp><span class="samp">make check-gcc</span></samp>&rsquo;的方式，来运行一个测试子集。
可以通过设定RUNTESTFLAGS为<samp><span class="file">.exp</span></samp>文件名，
（对于某些测试）后面可选的一个等号和一个文件通配符，来指定特定的测试。如：

     <pre class="smallexample">          make check-gcc RUNTESTFLAGS="execute.exp=19980413-*"
</pre>
     <p>注意可能需要安装额外的工具，像TCL或dejagnu，来运行测试包。
</dl>

 <p>开始编译GCC的顶层树不是GCC目录，而是使用一个复杂的Makefile来协调构建的各个步骤，包括自举（bootstrap）编译器，以及使用新的编译器来构建目标库。

 <p>当GCC被配置为本地配置时，<samp><span class="command">make</span></samp>的缺省动作是执行完整的三阶段自举。
这意味着GCC将被构建三次，一次是使用本地编译器，
一次是使用刚由本地编译器构建的编译器，一次是使用第二次构建的编译器。
理论上，最后两次应该产生相同的结果，这可以使用&lsquo;<samp><span class="samp">make compare</span></samp>&rsquo;来检验。
每个阶段都被单独的配置和编译到独立的目录里，
以尽可能减少由于本地编译器和GCC之间的ABI不兼容所带来的问题。

 <p>如果做了改动，重建工作将还会从第一阶段开始，并且将改动贯穿三个阶段。
每个阶段都在它的构建目录下开始（如果先前曾被构建过），
重建，并且复制到它的子目录。这将允许你，在修订了引起第二阶段构建崩溃的bug之后，
可以继续进行自举。这虽然对编译器没有提供像从头进行自举那样好的覆盖效果，
但却能保证新的代码在语法上是正确的（例如，没有错误使用GCC的扩展功能），
并避免了不合逻辑的自举比较失败
<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>。

 <p>其它由顶层可以获得的目标包括：

     <dl>
<dt><code>bootstrap-lean</code><dd>类似<code>bootstrap</code>，除了各个阶段当不再需要的时候，将被移除。
这可以节省磁盘空间。

     <br><dt><code>bootstrap2</code><dt><code>bootstrap2-lean</code><dd>只执行前两个阶段的自举。不像三阶段自举，这将不执行测试编译器运行正常的比较。
注意使用“lean”的自举所需要的磁盘空间几乎是与阶段数目无关的。

     <br><dt><code>stage</code><var>N</var><code>-bubble (</code><var>N</var><code> = 1...4)</code><dd>使用适当的标记，来重建所有的阶段，只到<var>N</var>，并将按照上面描述的来传播改动。

     <br><dt><code>all-stage</code><var>N</var><code> (</code><var>N</var><code> = 1...4)</code><dd>假设阶段<var>N</var>已经被构建，使用适当的标记来重建它。这个很少用到。

     <br><dt><code>cleanstrap</code><dd>移除所有（&lsquo;<samp><span class="samp">make clean</span></samp>&rsquo;）并重建（&lsquo;<samp><span class="samp">make bootstrap</span></samp>&rsquo;）。

     <br><dt><code>compare</code><dd>比较阶段2和3的结果。这用于确保编译器运行正常，因为不管它本身是如何被编译的，都应该产生相同的目标文件。

     <br><dt><code>profiledbootstrap</code><dd>构建带有profile反馈信息的编译器。更多信息，参见
<a href="../gccinstall/Building.html#Building">Building with profile feedback</a>。

     <br><dt><code>restrap</code><dd>重新启动自举，使得任何没有使用系统编译器构建的将被重建。

     <br><dt><code>stage</code><var>N</var><code>-start (</code><var>N</var><code> = 1...4)</code><dd>对于被自举的每个package，重命名目录，使得例如，
当使用<var>N-1</var>阶段的（stageN-1）GCC编译时，gcc指向<var>N</var>阶段的（stageN）GCC。

     <p>如果需要测试或调试<var>N</var>阶段的GCC时，你将使用该目标。
如果只需要执行GCC（但不需要运行&lsquo;<samp><span class="samp">make</span></samp>&rsquo;，也不需要重建或运行测试包），
你应该能够在<samp><span class="file">stage</span><var>N</var><span class="file">-gcc</span></samp>目录下工作。
这使得很容易进行并行的调试多个阶段。
<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>。

     <br><dt><code>stage</code><dd>对于被自举的每个package，重定位它的构建目录来指示它的阶段。
例如，如果<samp><span class="file">gcc</span></samp>目录指向阶段2的GCC，则执行该目标之后，
将被重命名为<samp><span class="file">stage2-gcc</span></samp>。

 </dl>

 <p>如果在编译阶段2和阶段3的编译器时，想使用非缺省的GCC标记，
则在执行&lsquo;<samp><span class="samp">make</span></samp>&rsquo;时，在命令行上设置<code>BOOT_CFLAGS</code>。

 <p>通常，第一阶段只构建编写编译器的语言：通常是C，以及可能会有Ada。
如果你在调试一个其它的阶段2前端的错误编译（例如，Fortran前端），
你可能想要在第一阶段也有其它语言的前端。如果这样，
在执行&lsquo;<samp><span class="samp">make</span></samp>&rsquo;时在命令行中设置<code>STAGE1_LANGUAGES</code>。

 <p>例如，在前述情况中，要调试由阶段1编译器造成的Fortran前端的错误编译，
可能需要一个命令如

<pre class="example">     make stage2-bubble STAGE1_LANGUAGES=c,fortran
</pre>
 <p>另外，可以使用每个语言的目标，来构建和测试没有在阶段1启用的语言。
例如，<samp><span class="command">make f951</span></samp>将在stage1构建目录下构建一个Fortran编译器。

 <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> 除非编译器有bug，以及一些没有被修改的文件被错误编译了。
在这种情况下，最好使用<samp><span class="command">make restrap</span></samp>。</p>

 <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> 习惯上，系统编译器也被称为0阶段（<samp><span class="file">stage0</span></samp>）GCC。</p>

 <hr></div>

 </body></html>

