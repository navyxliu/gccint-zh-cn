<html lang="zh">
<head>
<title>目标机属性 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f_00e5_0088_0087_00e6_008d_00a2.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f_00e5_0088_0087_00e6_008d_00a2" title="机器模式切换">
<link rel="next" href="_00e6_00a8_00a1_00e6_008b_009fTLS.html#g_t_00e6_00a8_00a1_00e6_008b_009fTLS" title="模拟TLS">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e7%9b%ae%e6%a0%87%e6%9c%ba%e5%b1%9e%e6%80%a7"></a>
<a name="g_t_00e7_009b_00ae_00e6_00a0_0087_00e6_009c_00ba_00e5_00b1_009e_00e6_0080_00a7"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00a8_00a1_00e6_008b_009fTLS.html#g_t_00e6_00a8_00a1_00e6_008b_009fTLS">模拟TLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f_00e5_0088_0087_00e6_008d_00a2.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_00a8_00a1_00e5_00bc_008f_00e5_0088_0087_00e6_008d_00a2">机器模式切换</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.25 定义目标机特定的<code>__attribute__</code>用法</h3>

<p><a name="index-target-attributes-4575"></a><a name="index-machine-attributes-4576"></a><a name="index-attributes_002c-target_002dspecific-4577"></a>
可以为函数，数据和类型定义target特定的属性。
这些使用下列target钩子来描述；它们还需要在<samp><span class="file">extend.texi</span></samp>中被记述。

<div class="defun">
&mdash; Target Hook: const struct attribute_spec * <b>TARGET_ATTRIBUTE_TABLE</b><var><a name="index-TARGET_005fATTRIBUTE_005fTABLE-4578"></a></var><br>
<blockquote><p>如果定义，
该目标钩子指向一个&lsquo;<samp><span class="samp">struct attribute_spec</span></samp>&rsquo; (在<samp><span class="file">tree.h</span></samp>中定义) 数组，
用来指定该目标的机器特定的属性，
以及这些属性被应用到的实体和它们接受的参数的一些限制。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_COMP_TYPE_ATTRIBUTES</b> (<var>tree type1, tree type2</var>)<var><a name="index-TARGET_005fCOMP_005fTYPE_005fATTRIBUTES-4579"></a></var><br>
<blockquote><p>如果定义，该目标钩子为一个函数，
如果<var>type1</var>和<var>type2</var>的属性不匹配则返回0，匹配则返回1，
几乎匹配则返回2（这将产生一个warning）。如果没有被定义，
则机器特定的属性总被假定为匹配的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SET_DEFAULT_TYPE_ATTRIBUTES</b> (<var>tree type</var>)<var><a name="index-TARGET_005fSET_005fDEFAULT_005fTYPE_005fATTRIBUTES-4580"></a></var><br>
<blockquote><p>如果定义，该目标钩子为一个函数，其将缺省属性赋予新定义的类型<var>type</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_MERGE_TYPE_ATTRIBUTES</b> (<var>tree type1, tree type2</var>)<var><a name="index-TARGET_005fMERGE_005fTYPE_005fATTRIBUTES-4581"></a></var><br>
<blockquote><p>定义该target钩子，如果合并类型属性需要进行特殊的处理。
如果定义，则结果为<var>type1</var>和<var>type2</var>的组合<code>TYPE_ATTRIBUTES</code>列表。
其假设<code>comptypes</code>总是被调用并返回1。
该函数可以调用<code>merge_attributes</code>来处理机器无关的合并。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_MERGE_DECL_ATTRIBUTES</b> (<var>tree olddecl, tree newdecl</var>)<var><a name="index-TARGET_005fMERGE_005fDECL_005fATTRIBUTES-4582"></a></var><br>
<blockquote><p>定义该target钩子，如果合并decl属性需要进行特殊的处理。如果定义，
则结果为<var>olddecl</var>和<var>newdecl</var>的组合<code>DECL_ATTRIBUTES</code>列表。
<var>newdecl</var>为<var>olddecl</var>的拷贝。这样的例子是当一个属性覆盖另一个，
或者当一个属性被后续的属性置空的情况。
该函数可以调用<code>merge_attributes</code>来处理机器无关的合并。

      <p><a name="index-TARGET_005fDLLIMPORT_005fDECL_005fATTRIBUTES-4583"></a>如果唯一需要target特定的处理是Microsoft Windows target的&lsquo;<samp><span class="samp">dllimport</span></samp>&rsquo;，
则你应该定义宏<code>TARGET_DLLIMPORT_DECL_ATTRIBUTES</code>为<code>1</code>。
然后编译器将会定义一个叫做<code>merge_dllimport_decl_attributes</code>的函数，
其可以被定义为<code>TARGET_MERGE_DECL_ATTRIBUTES</code>的扩展。
你还可以为你的port在属性表中增加<code>handle_dll_attribute</code>，
来执行&lsquo;<samp><span class="samp">dllimport</span></samp>&rsquo;和&lsquo;<samp><span class="samp">dllexport</span></samp>&rsquo;属性的初始化处理。
例如，在<samp><span class="file">i386/cygwin.h</span></samp>和<samp><span class="file">i386/i386.c</span></samp>中。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VALID_DLLIMPORT_ATTRIBUTE_P</b> (<var>tree decl</var>)<var><a name="index-TARGET_005fVALID_005fDLLIMPORT_005fATTRIBUTE_005fP-4584"></a></var><br>
<blockquote><p><var>decl</var>为一个指定为<code>__attribute__((dllimport))</code>的变量或者函数。
使用该钩子，如果target需要给<code>handle_dll_attribute</code>增加额外的有效性检查。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_DECLSPEC</b><var><a name="index-TARGET_005fDECLSPEC-4585"></a></var><br>
<blockquote><p>定义该宏为非零，
如果你想将<code>__declspec(X)</code>与<code>__attribute((X))</code>等同对待。
缺省下，只有在定义了<code>TARGET_DLLIMPORT_DECL_ATTRIBUTES</code>的target上才可以。
目前对于<code>__declspec</code>的实现是通过一个内建的宏，但是你不应该依赖于实现细节。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_INSERT_ATTRIBUTES</b> (<var>tree node, tree *attr_ptr</var>)<var><a name="index-TARGET_005fINSERT_005fATTRIBUTES-4586"></a></var><br>
<blockquote><p>定义该target钩子，如果你想在decl被创建时，能够为其增加属性。
这在后端想要实现一个pragma，并且用到与pragma相关的属性的时候，
通常很有用。参数<var>node</var>是正在创建的decl。
参数<var>attr_ptr</var>是指向该decl的属性列表的指针。不要修改列表本身，
因为其可能与其它decl共享，但是可以将属性链接到列表的头部，
并且修改<code>*</code><var>attr_ptr</var>以指向新的属性，或者如果需要进一步的修改，
创建一个列表的拷贝。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P</b> (<var>tree fndecl</var>)<var><a name="index-TARGET_005fFUNCTION_005fATTRIBUTE_005fINLINABLE_005fP-4587"></a></var><br>
<blockquote><p><a name="index-inlining-4588"></a>该target钩子返回<code>true</code>，如果可以将<var>fndecl</var>内联到当前函数中，
而不管它具有的target特定属性，否则为<code>false</code>。
缺省下，如果函数具有一个target特定属性，则不会被内联。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VALID_OPTION_ATTRIBUTE_P</b> (<var>tree fndecl, tree name, tree args, int flags</var>)<var><a name="index-TARGET_005fVALID_005fOPTION_005fATTRIBUTE_005fP-4589"></a></var><br>
<blockquote><p>This hook is called to parse the <code>attribute(option("..."))</code>, and
it allows the function to set different target machine compile time
options for the current function that might be different than the
options specified on the command line.  The hook should return
<code>true</code> if the options are valid.

      <p>The hook should set the <var>DECL_FUNCTION_SPECIFIC_TARGET</var> field in
the function declaration to hold a pointer to a target specific
<var>struct cl_target_option</var> structure. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_OPTION_SAVE</b> (<var>struct cl_target_option *ptr</var>)<var><a name="index-TARGET_005fOPTION_005fSAVE-4590"></a></var><br>
<blockquote><p>This hook is called to save any additional target specific information
in the <var>struct cl_target_option</var> structure for function specific
options. 
See <a href="_00e9_0080_0089_00e9_00a1_00b9_00e6_0096_0087_00e4_00bb_00b6_00e6_00a0_00bc_00e5_00bc_008f.html#g_t_00e9_0080_0089_00e9_00a1_00b9_00e6_0096_0087_00e4_00bb_00b6_00e6_00a0_00bc_00e5_00bc_008f">选项文件格式</a>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_OPTION_RESTORE</b> (<var>struct cl_target_option *ptr</var>)<var><a name="index-TARGET_005fOPTION_005fRESTORE-4591"></a></var><br>
<blockquote><p>This hook is called to restore any additional target specific
information in the <var>struct cl_target_option</var> structure for
function specific options. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_OPTION_PRINT</b> (<var>struct cl_target_option *ptr</var>)<var><a name="index-TARGET_005fOPTION_005fPRINT-4592"></a></var><br>
<blockquote><p>This hook is called to print any additional target specific
information in the <var>struct cl_target_option</var> structure for
function specific options. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_OPTION_PRAGMA_PARSE</b> (<var>target args</var>)<var><a name="index-TARGET_005fOPTION_005fPRAGMA_005fPARSE-4593"></a></var><br>
<blockquote><p>This target hook parses the options for <code>#pragma GCC option</code> to
set the machine specific options for functions that occur later in the
input stream.  The options should be the same as handled by the
<code>TARGET_VALID_OPTION_ATTRIBUTE_P</code> hook. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CAN_INLINE_P</b> (<var>tree caller, tree callee</var>)<var><a name="index-TARGET_005fCAN_005fINLINE_005fP-4594"></a></var><br>
<blockquote><p>This target hook returns <code>false</code> if the <var>caller</var> function
cannot inline <var>callee</var>, based on target specific information.  By
default, inlining is not allowed if the callee function has function
specific target options and the caller does not use the same options. 
</p></blockquote></div>

 </body></html>

