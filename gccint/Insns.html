<html lang="zh">
<head>
<title>Insns - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e6_00b1_0087_00e7_00bc_0096.html#g_t_00e6_00b1_0087_00e7_00bc_0096" title="汇编">
<link rel="next" href="_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8" title="函数调用">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Insns"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e5_0087_00bd_00e6_0095_00b0_00e8_00b0_0083_00e7_0094_00a8">函数调用</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_00b1_0087_00e7_00bc_0096.html#g_t_00e6_00b1_0087_00e7_00bc_0096">汇编</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.18 Insns</h3>

<p><a name="index-insns-2583"></a>
一个函数的代码的RTL表示是一个被称作<dfn>insns</dfn>对象的双向链表。insn只不过是具有特定代码的表达式。有些insn是实际的指令；有些用来表示<code>switch</code>语句的派遣表。有些用来表示要调转的标号或者不同类别的声明信息。

 <p>除了本身特定的数据，每个insn必须有一个唯一的id号用来区别当前函数中其它的insn（经过分支延迟调度之后，具有相同id号的一个insn 的拷贝，可能会出现在一个函数中的多个地方，但是这些拷贝总是同样的，并且只是出现在一个<code>sequence</code>中），以及指向前面和后面insn的链表指针。这三个域在每个insn中占有相同的位置，并且独立于insn的表达式代码。它们可以通过<code>XEXP</code>和<code>XINT</code>来访问，不过，有三个特定的宏经常会被使用：

     
<a name="index-INSN_005fUID-2584"></a>
<dl><dt><code>INSN_UID (</code><var>i</var><code>)</code><dd>访问insn <var>i</var>的唯一id。

     <p><a name="index-PREV_005fINSN-2585"></a><br><dt><code>PREV_INSN (</code><var>i</var><code>)</code><dd>访问指向<var>i</var>之前的insn的链表指针。如果<var>i</var>是第一个insn，则是一个null指针。

     <p><a name="index-NEXT_005fINSN-2586"></a><br><dt><code>NEXT_INSN (</code><var>i</var><code>)</code><dd>访问指向<var>i</var>之后的insn的链表指针。如果<var>i</var>是最后一个insn，则是一个null指针。

 </dl>

 <p><a name="index-get_005finsns-2587"></a><a name="index-get_005flast_005finsn-2588"></a>链表中的第一个insn可以通过调用<code>get_insns</code>获得；最后一个insn可以通过调用<code>get_last_insn</code>来获得。在由这些insn界定的链中，<code>NEXT_INSN</code>和<code>PREV_INSN</code>指针必须总是相当：如果<var>insn</var> 不是第一个insn，则

<pre class="smallexample">     NEXT_INSN (PREV_INSN (<var>insn</var>)) == <var>insn</var>
</pre>
 <p class="noindent">总是真，并且如果<var>insn</var>不是最后一个insn，则

<pre class="smallexample">     PREV_INSN (NEXT_INSN (<var>insn</var>)) == <var>insn</var>
</pre>
 <p class="noindent">总是真。

 <p>在延迟槽调度之后，在链中的一些insn可能为<code>sequence</code>表达式，其包含了一个insn向量。这个向量中除了最后一个insn之外，其它insn的<code>NEXT_INSN</code>的值都是向量中的下一个insn；向量中的最后一个insn的<code>NEXT_INSN</code>的值，等于包含<code>sequence</code>的insn的<code>NEXT_INSN</code>的值。对于<code>PREV_INSN</code>，也有类似的规则。

 <p>这意味着上面的恒等式，对于在<code>sequence</code>表达式中的insn不需要成立。特别是，如果<var>insn</var>为<code>sequence</code>中的第一个insn，则<code>NEXT_INSN (PREV_INSN (</code><var>insn</var><code>))</code>为包含<code>sequence</code>表达式的insn，同样如果<var>insn</var>为<code>sequence</code>中的最后一个insn，则<code>PREV_INSN (NEXT_INSN (</code><var>insn</var><code>))</code>的值也是如此。你可以使用这些表达式来查找包含<code>sequence</code>的insn。

 <p>每个insn都具有下列六种表达式代码中的一个：

     
<a name="index-insn-2589"></a>
<dl><dt><code>insn</code><dd>表达式代码<code>insn</code>用于不进行跳转和函数调用的指令。<code>sequence</code>表达式总是包含在表达式代码为<code>insn</code>的insn中，即使它们中的一个insn是跳转或者函数调用。

     <p>表达式代码为<code>insn</code>的insn，除了上面列出的三个必须的域以外，还具有四个额外的域。这四个域在后面的表中有描述。

     <p><a name="index-jump_005finsn-2590"></a><br><dt><code>jump_insn</code><dd>表达式代码<code>jump_insn</code>用于可能执行跳转（或者，更一般的讲，指令中可能包含了<code>label_ref</code>表达式，并用其来设置<code>pc</code>）的指令。如果有一条从当前函数返回的指令，则其被记录为<code>jump_insn</code>。

     <p><a name="index-JUMP_005fLABEL-2591"></a><code>jump_insn</code>具有跟<code>insn</code>相同的额外的域，并使用同样的方式来访问，除此之外，还包含了一个域<code>JUMP_LABEL</code>，其当执行完跳转优化后被定义。

     <p>对于简单的条件跳转和无条件跳转，该域包含了该insn将（可能有条件的）分支跳转到的<code>code_label</code>。在更复杂的跳转中，<code>JUMP_LABEL</code>记录了insn引用的其中一个标号；其它跳转目标标号作为<code>REG_LABEL_TARGET</code>注解来记录。<code>addr_vec</code>和<code>addr_diff_vec</code>是例外的情况，对此，<code>JUMP_LABEL</code>为<code>NULL_RTX</code>，而只有扫描整个insn体干才能找到标号。

     <p>返回指令insn作为跳转看待，但由于它们并不引用任何标号，所以它们的<code>JUMP_LABEL</code>为<code>NULL_RTX</code>。

     <p><a name="index-call_005finsn-2592"></a><br><dt><code>call_insn</code><dd>表达式代码<code>call_insn</code>用于可能执行函数调用的指令。区分这些指令是很重要的，因为它们意味着特定的寄存器和内存位置可以被不可预知的方式改变。

     <p><a name="index-CALL_005fINSN_005fFUNCTION_005fUSAGE-2593"></a><code>call_insn</code>具有与<code>insn</code>相同的额外的域，并使用相同的方式访问，除此之外，还包含一个域<code>CALL_INSN_FUNCTION_USAGE</code>，其包含了一个列表（<code>expr_list</code>表达式链），包含了<code>use</code>和<code>clobber</code>表达式，表示了被调用函数使用和破坏的硬件寄存器和<code>MEM</code>。

     <p>一个<code>MEM</code>通常指向一个栈槽，参数在其中按照引用方式（see <a href="Register-Arguments.html#Register-Arguments">TARGET_PASS_BY_REFERENCE</a>）传递给libcall。如果参数是caller-copied（see <a href="Register-Arguments.html#Register-Arguments">TARGET_CALLEE_COPIES</a>），则栈槽会在<code>CLOBBER</code>和<code>USE</code>中被提到；如果是callee-copied，则只会出现<code>USE</code>，并且<code>MEM</code>可能指向不是栈槽的地址。

     <p>在列表中，被<code>CLOBBER</code>的寄存器，增加了在<code>CALL_USED_REGISTERS</code>中描述的寄存器（see <a href="Register-Basics.html#Register-Basics">Register Basics</a>）。

     <p><a name="index-code_005flabel-2594"></a><a name="index-CODE_005fLABEL_005fNUMBER-2595"></a><br><dt><code>code_label</code><dd><code>code_label</code> insn表示一个跳转insn可以跳转到的标号。除了三个标准的域以为，其还包含两个特定的域。<code>CODE_LABEL_NUMBER</code>用于存放<dfn>label number</dfn>，在编译过程中，唯一标识该标号。最终，标号在汇编输出中作为汇编标号来表示，通常的形式为&lsquo;<samp><span class="samp">L</span><var>n</var></samp>&rsquo;，其中<var>n</var>为标号编号。

     <p>当<code>code_label</code>出现在RTL表达式中，其通常出现在<code>label_ref</code>中，其表示了标号的地址，为一个编号。

     <p>除了作为<code>code_label</code>以外，标号还可以作为类型为<code>NOTE_INSN_DELETED_LABEL</code>的<code>note</code>来表示。

     <p><a name="index-LABEL_005fNUSES-2596"></a>域<code>LABEL_NUSES</code>只当完成跳转优化过程后才被定义。其包含了在当前函数中，该标号被引用的次数。

     <p><a name="index-LABEL_005fKIND-2597"></a><a name="index-SET_005fLABEL_005fKIND-2598"></a><a name="index-LABEL_005fALT_005fENTRY_005fP-2599"></a><a name="index-alternate-entry-points-2600"></a>域<code>LABEL_KIND</code>用来区分四种不同类型的标号：<code>LABEL_NORMAL</code>，<code>LABEL_STATIC_ENTRY</code>，<code>LABEL_GLOBAL_ENTRY</code>和<code>LABEL_WEAK_ENTRY</code>。唯一不具有类型<code>LABEL_NORMAL</code>的标号，为当前函数的<dfn>alternate entry points</dfn>。这些可以为static（只在当前转换单元中可见），global（对所有的转换单元可见）或者weak（全局的，但是可以被另一个具有相同名字的符号覆盖）。

     <p>编译器大多将所有四种标号同等对待。有些地方需要知道标号是否为候选入口点；为此，提供了宏<code>LABEL_ALT_ENTRY_P</code>。其等价于测试是否&lsquo;<samp><span class="samp">LABEL_KIND (label) == LABEL_NORMAL</span></samp>&rsquo;。除了前端创建static，global和weak alternate entry points的代码以外，其它唯一关心它们的区别的地方是<samp><span class="file">final.c</span></samp>文件中的函数<code>output_alternate_entry_point</code>。

     <p>使用宏<code>SET_LABEL_KIND</code>来设置标号的种类。

     <p><a name="index-barrier-2601"></a><br><dt><code>barrier</code><dd>栅栏被放在指令流中，控制无法经过的地方。它们被放在无条件跳转指令的后面，表示跳转是无条件的，以及对<code>volatile</code>函数的调用之后，表示不会返回（例如，<code>exit</code>）。除了三个标准的域以外，不包含其它信息。

     <p><a name="index-note-2602"></a><a name="index-NOTE_005fLINE_005fNUMBER-2603"></a><a name="index-NOTE_005fSOURCE_005fFILE-2604"></a><br><dt><code>note</code><dd><code>note</code> insns用于表示额外的调试和说明信息。它们包含两个非标准的域，一个使用宏<code>NOTE_LINE_NUMBER</code>访问的整数，以及一个使用<code>NOTE_SOURCE_FILE</code>访问的字符串。

     <p>如果<code>NOTE_LINE_NUMBER</code>是正的，则注解表示源文件行号，并且<code>NOTE_SOURCE_FILE</code>为源文件名。这些注解控制在汇编输出中的生成行号数据。

     <p>否则，<code>NOTE_LINE_NUMBER</code>不是一个行号，而是一个具有下列值之一的代码（并且<code>NOTE_SOURCE_FILE</code>必须包含一个空指针）：

          
<a name="index-NOTE_005fINSN_005fDELETED-2605"></a>
<dl><dt><code>NOTE_INSN_DELETED</code><dd>这样的注解被完全忽略掉。编译器的一些过程会通过将insn修改成这种类型的注解，来删除insn。

          <p><a name="index-NOTE_005fINSN_005fDELETED_005fLABEL-2606"></a><br><dt><code>NOTE_INSN_DELETED_LABEL</code><dd>标记了曾经为<code>code_label</code>，但现在只用于获得其地址，并且没有代码会跳转到这里。

          <p><a name="index-NOTE_005fINSN_005fBLOCK_005fBEG-2607"></a><a name="index-NOTE_005fINSN_005fBLOCK_005fEND-2608"></a><br><dt><code>NOTE_INSN_BLOCK_BEG</code><dt><code>NOTE_INSN_BLOCK_END</code><dd>这些类型的注解表示处于变量名作用域的起始和结束。它们控制调试信息的输出。

          <p><a name="index-NOTE_005fINSN_005fEH_005fREGION_005fBEG-2609"></a><a name="index-NOTE_005fINSN_005fEH_005fREGION_005fEND-2610"></a><br><dt><code>NOTE_INSN_EH_REGION_BEG</code><dt><code>NOTE_INSN_EH_REGION_END</code><dd>这些类型的注解表示处于异常处理作用域的起始和结束。<code>NOTE_BLOCK_NUMBER</code>标识了哪一个类型为<code>NOTE_INSN_DELETED_LABEL</code>的<code>CODE_LABEL</code>或<code>note</code>与给定的区域相关联。

          <p><a name="index-NOTE_005fINSN_005fLOOP_005fBEG-2611"></a><a name="index-NOTE_005fINSN_005fLOOP_005fEND-2612"></a><br><dt><code>NOTE_INSN_LOOP_BEG</code><dt><code>NOTE_INSN_LOOP_END</code><dd>这些类型的注解表示处于<code>while</code>或者<code>for</code>循环的起始和结束。它们使得循环优化可以快速的发现循环。

          <p><a name="index-NOTE_005fINSN_005fLOOP_005fCONT-2613"></a><br><dt><code>NOTE_INSN_LOOP_CONT</code><dd>出现在循环中<code>continue</code>语句跳转的地方。

          <p><a name="index-NOTE_005fINSN_005fLOOP_005fVTOP-2614"></a><br><dt><code>NOTE_INSN_LOOP_VTOP</code><dd>该注解表示循环中退出测试（exit test）起始的地方，并且退出测试在循环中被复制。当考虑循环不变量时，该位置为循环的另一个虚拟起始点。

          <p><a name="index-NOTE_005fINSN_005fFUNCTION_005fBEG-2615"></a><br><dt><code>NOTE_INSN_FUNCTION_BEG</code><dd>出现在函数序言之后，函数体的起始处。

     </dl>

     <p>在调试转储中，这些代码被符号化的打印。
</dl>

 <p><a name="index-g_t_0040code_007bTImode_007d_002c-in-_0040code_007binsn_007d-2616"></a><a name="index-g_t_0040code_007bHImode_007d_002c-in-_0040code_007binsn_007d-2617"></a><a name="index-g_t_0040code_007bQImode_007d_002c-in-_0040code_007binsn_007d-2618"></a>insn的机器模式通常为<code>VOIDmode</code>，但有些阶段出于不同的目的而使用其它机器模式。

 <p>公共子表达式消除过程将一个insn的机器模式设为<code>QImode</code>，当其为已经被处理过的块中的第一个insn时。

 <p>第二次Haifa调度过程中，对于可以多发射的目标机，当insn被认为是一个发射组合中的起始指令时，将其机器模式设为<code>TImode</code>。也就是说，该指令不能和之前的指令同时发射。这可以在后面的过程中用到，特别是机器特定的reorg。

 <p>下面的表中列出了<code>insn</code>, <code>jump_insn</code>和<code>call_insn</code>的其它域：

     
<a name="index-PATTERN-2619"></a>
<dl><dt><code>PATTERN (</code><var>i</var><code>)</code><dd>一个表达式，为该insn执行的副作用。必须为下列代码中的一个：<code>set</code>, <code>call</code>, <code>use</code>, <code>clobber</code>, <code>return</code>, <code>asm_input</code>, <code>asm_output</code>, <code>addr_vec</code>, <code>addr_diff_vec</code>, <code>trap_if</code>, <code>unspec</code>, <code>unspec_volatile</code>, <code>parallel</code>, <code>cond_exec</code>或<code>sequence</code>。如果其为<code>parallel</code>，则<code>parallel</code>中的每个元素必须是这些代码中的一个，并且，<code>parallel</code>表达式不能被嵌套，<code>addr_vec</code>和<code>addr_diff_vec</code>不允许在<code>parallel</code>表达式中。

     <p><a name="index-INSN_005fCODE-2620"></a><br><dt><code>INSN_CODE (</code><var>i</var><code>)</code><dd>一个整数，说明机器描述中的哪一个指令模式匹配该insn，或者，如果还没有进行匹配，则为&minus;1。

     <p>对于指令模式由单个<code>use</code>, <code>clobber</code>, <code>asm_input</code>, <code>addr_vec</code> 或 <code>addr_diff_vec</code>表达式组成的insn，则不会进行这样的匹配，并且该域保持为&minus;1。

     <p><a name="index-asm_005fnoperands-2621"></a>对于来自<code>asm</code>语句的insn，也不会进行指令模式匹配。这些至少包含了一个<code>asm_operands</code>表达式。函数<code>asm_noperands</code>为这样的insn返回一个非负的值。

     <p>在调试输出中，该域被打印成一个数字，紧随一个符号表示，用来定位在<samp><span class="file">md</span></samp>中的指令模式，数字表示相对命名指令模式的正的或者负的偏移量。

     <p><a name="index-LOG_005fLINKS-2622"></a><br><dt><code>LOG_LINKS (</code><var>i</var><code>)</code><dd>一个列表（<code>insn_list</code>表达式链），给出了基本块中指令之间的依赖信息。相关联的insn之间不会有跳转或者标号。这些只被用于指令调度和组合。这是一个不被推荐的数据结构。现在推荐使用def-use和use-def链。

     <p><a name="index-REG_005fNOTES-2623"></a><br><dt><code>REG_NOTES (</code><var>i</var><code>)</code><dd>一个列表（<code>expr_list</code>和<code>insn_list</code>表达式链），给出了insn的其它信息。通常为从属于该insn使用的寄存器的信息。

 </dl>

 <p>insn的<code>LOG_LINKS</code>域为<code>insn_list</code>表达式链。每一个都具有两个操作数：第一个为insn，第二个为另一个<code>insn_list</code>表达式（链中的下一个）。链中的最后一个<code>insn_list</code>的第二个操作数为空指针。对于表达式链，重要的是有哪些insn（<code>insn_list</code>表达式的第一个操作数）。它们的顺序并不重要。

 <p>该列表最初由流分析过程建立；在此之前还只是空指针。流分析只将那些可以用于指令合并的数据依赖，加入到列表中。

 <p>insn的<code>REG_NOTES</code>域是一个类似于<code>LOG_LINKS</code>域的链，不过除了<code>insn_list</code>表达式，其还包含<code>expr_list</code>表达式。有多种寄存器注解，其通过机器模式区分。注解的第一个操作数<var>op</var>的含义依赖注解的种类。

 <p><a name="index-REG_005fNOTE_005fKIND-2624"></a><a name="index-PUT_005fREG_005fNOTE_005fKIND-2625"></a>宏<code>REG_NOTE_KIND (</code><var>x</var><code>)</code>返回寄存器注解的种类。宏<code>PUT_REG_NOTE_KIND (</code><var>x</var><code>, </code><var>newkind</var><code>)</code>将<var>x</var>的寄存器注解类型设置为<var>newkind</var>。

 <p>寄存器注解有三种类别：可以用来说明insn的输入，可以用来说明insn的输出，或者可以用来创建两个insn之间的连接。还有一个值集，只用于<code>LOG_LINKS</code>中。

 <p>这些注解用来说明insn的输入：

     
<a name="index-REG_005fDEAD-2626"></a>
<dl><dt><code>REG_DEAD</code><dd><var>op</var>中的值在该insn中死掉；也就是说，紧接这个insn之后，修改该值将不会影响程序将来的行为。

     <p>这并不是说从该insn之后，寄存器<var>op</var>就没有有用的值了。而是说，后续的指令不会用到<var>op</var>的内容。

     <p><a name="index-REG_005fUNUSED-2627"></a><br><dt><code>REG_UNUSED</code><dd>被该insn设置的寄存器<var>op</var>，将不会在后续的insn中使用。这与<code>REG_DEAD</code>注解不同，后者表示输入中的值将不会被后续insn使用。这两个注解是不相关的；可能会都出现在同一个寄存器中。

     <p><a name="index-REG_005fINC-2628"></a><br><dt><code>REG_INC</code><dd>寄存器<var>op</var>由于insn中嵌入的副作用，而被递增（或递减）。这意味着其出现在<code>post_inc</code>, <code>pre_inc</code>, <code>post_dec</code>或<code>pre_dec</code>表达式中。

     <p><a name="index-REG_005fNONNEG-2629"></a><br><dt><code>REG_NONNEG</code><dd>寄存器<var>op</var>在到达该insn的时候，被已知为具有一个非负的值。对于递减并分支跳转，直到为零的指令，例如m68k dbra，可以用来进行匹配。

     <p><code>REG_NONNEG</code>注解，只有当机器描述具有&lsquo;<samp><span class="samp">decrement_and_branch_until_zero</span></samp>&rsquo;指令模式的时候，才被加到insn中。

     <p><a name="index-REG_005fLABEL_005fOPERAND-2630"></a><br><dt><code>REG_LABEL_OPERAND</code><dd>该insn使用<var>op</var>，一个类型为<code>NOTE_INSN_DELETED_LABEL</code>的<code>code_label</code>或者<code>note</code>，但是不为<code>jump_insn</code>。或者，其为一个将操作数作为普通操作数的<code>jump_insn</code>。标号最终也可以为跳转目标，但这是在后续insn的间接跳转中。该注解使得跳转优化知道<var>op</var>实际上被使用了，从而流优化可以创建一个精确的流图。

     <p><a name="index-REG_005fLABEL_005fTARGET-2631"></a><br><dt><code>REG_LABEL_TARGET</code><dd>该insn为一个<code>jump_insn</code>，但不是<code>addr_vec</code>和<code>addr_diff_vec</code>。其使用<var>op</var>，一个<code>code_label</code>，作为直接或间接跳转的目标。其用途与<code>REG_LABEL_OPERAND</code>类似。该注解只存在于当insn具有多个目标的时候；insn中的最后一个标号（在最高编号的insn域中），放到<code>JUMP_LABEL</code>域中，并且没有<code>REG_LABEL_TARGET</code>。See <a href="Insns.html#Insns">JUMP_LABEL</a>。

     <p><a name="index-REG_005fCROSSING_005fJUMP-2632"></a><br><dt><code>REG_CROSSING_JUMP</code><dd>该insn为一个分支指令（无条件跳转或者间接跳转），其穿越了热代码段和冷代码段，并可能潜在的位于可执行程序中非常远的部分。该注解用来指示其它优化，表示该分支指令不应该被折叠为简单的分支结构。其用于当优化将基本块分成热代码段和冷代码段的时候。

     <p><a name="index-REG_005fSETJMP-2633"></a><br><dt><code>REG_SETJMP</code><dd>附加在每个针对<code>setjmp</code>或者相关的函数的<code>CALL_INSN</code>上。

 </dl>

 <p>下列注解描述了有关insn的输出的属性：

     
<a name="index-REG_005fEQUIV-2634"></a>
<a name="index-REG_005fEQUAL-2635"></a>
<dl><dt><code>REG_EQUIV</code><dt><code>REG_EQUAL</code><dd>该注解只用在只设置一个寄存器的insn上，用来表示那个寄存器在运行时等价于<var>op</var>；该等值的作用域根据两种类型的注解而有所不同。insn显式的复制进寄存器的值可能看起来与<var>op</var>不同，但它们将在运行时相等。如果单个<code>set</code>的输出为一个<code>strict_low_part</code>表达式，则注解是用于<code>subreg</code>表达式<code>SUBREG_REG</code>所包含的寄存器。

     <p>对于<code>REG_EQUIV</code>，在整个函数中，寄存器都等价于<var>op</var>，并且可以在其所有出现的地方被<var>op</var>有效替换。（有效，这里是指程序的数据流；简单的替换可能会使得某些insn无效。）例如，当一个常量被加载到一个寄存器中，并且寄存器不再被赋予任何其它值，则会使用这种注解。

     <p>当在函数入口处，一个参数被复制到一个伪寄存器中时，这种的注解会用来记录该寄存器等价于传递参数的栈槽。虽然，这种情况下，寄存器可能被其它的insn设置，其也可以在整个函数中被栈槽来替换。

     <p><code>REG_EQUIV</code>注解还用于，在函数入口处，将一个寄存器参数复制到一个伪寄存器中的指令，如果存在一个参数本来应该被存放的栈槽。虽然其它insn可以设置该伪寄存器，但编译器还是可以在整个函数中，使用栈槽来替换伪寄存器，假设编译器可以确保栈槽被适当的初始化。这被用于调用约定为寄存器参数分配栈空间的机器上。参见<a href="Stack-Arguments.html#Stack-Arguments">Stack Arguments</a>中的<code>REG_PARM_STACK_SPACE</code>。

     <p>对于<code>REG_EQUAL</code>的情况，被该insn设置的寄存器，将在运行时，在该insn的结尾处，但不必要是函数的其它地方，等价与<var>op</var>。这种情况下，<var>op</var>通常为一个算术表达式。例如，当一个库调用的insn序列，被用在一个算术运算上，则该类的注解将被附加在产生或者复制最终值的insn上。

     <p>这两个注解在编译器过程中，按照不同的方法来使用。<code>REG_EQUAL</code>用于寄存器分配之前的过程中（例如公共子表达式消除和循环优化），来告诉它们如何考虑那个值。<code>REG_EQUIV</code>注解用于寄存器分配，来表示存在一个可用的替换表达式（为栈上一个参数位置的常量或者<code>mem</code>表达式），其可以用在没有足够寄存器的地方。

     <p>除了为参数提供地方的栈以外，其它所有等值最初都是通过附加一个<code>REG_EQUAL</code>注解来表示。在寄存器分配的早期阶段，如果<var>op</var>是一个常量并且insn只表示对其目的寄存器进行设置，则<code>REG_EQUAL</code>被改变成<code>REG_EQUIV</code>注解。

     <p>因此，寄存器分配之前的编译过程，只需要检查<code>REG_EQUAL</code>注解，而之后的编译过程只需要检查<code>REG_EQUIV</code>注解。

 </dl>

 <p>这些注解描述了insn之间的联系。它们成对的出现：一个insn具有一对注解，其中之一用来指向第二个insn，并且第二个insn也由一个反过来指向第一个insn的注解。

     
<a name="index-REG_005fCC_005fSETTER-2636"></a>
<a name="index-REG_005fCC_005fUSER-2637"></a>
<dl><dt><code>REG_CC_SETTER</code><dt><code>REG_CC_USER</code><dd>在使用<code>cc0</code>的机器上，设置和使用<code>cc0</code>的insns是相邻的。然而，当做完分支延迟槽填充之后，就不一定是这样的了。这种情况下，<code>REG_CC_USER</code>注解将被放在设置<code>cc0</code>的insn上，来指向使用<code>cc0</code>的insn，并且<code>REG_CC_SETTER</code>注解将被放在使用<code>cc0</code>的insn上，来指向设置<code>cc0</code>的insn。

 </dl>

 <p>这些值只用在<code>LOG_LINKS</code>域，用来表示每个链接表示的依赖类型。表示一个数据依赖（写后读依赖）的链接，不使用任何代码，它们只是简单的具有<code>VOIDmode</code>模式，并在打印输出中没有任何描述文本。

     
<a name="index-REG_005fDEP_005fTRUE-2638"></a>
<dl><dt><code>REG_DEP_TRUE</code><dd>这表示一个真依赖（写后读依赖）。

     <p><a name="index-REG_005fDEP_005fOUTPUT-2639"></a><br><dt><code>REG_DEP_OUTPUT</code><dd>这表示一个输出依赖（写后写依赖）。

     <p><a name="index-REG_005fDEP_005fANTI-2640"></a><br><dt><code>REG_DEP_ANTI</code><dd>这表示一个反依赖（读后写依赖）。

 </dl>

 <p>这些注解描述了从gcov profile数据中搜集的信息。它们作为<code>expr_list</code>存储在insn的<code>REG_NOTES</code>域中。

     
<a name="index-REG_005fBR_005fPROB-2641"></a>
<dl><dt><code>REG_BR_PROB</code><dd>用于指定分支跳转率，根据profile数据。值位于0和REG_BR_PROB_BASE之间；较大的值表示该分支更可能会被执行。

     <p><a name="index-REG_005fBR_005fPRED-2642"></a><br><dt><code>REG_BR_PRED</code><dd>这些注解在JUMP insn中，并出现在延迟分支调度之后。它们表示JUMP的方向和可能性。格式为ATTR_FLAG_*值的掩码。

     <p><a name="index-REG_005fFRAME_005fRELATED_005fEXPR-2643"></a><br><dt><code>REG_FRAME_RELATED_EXPR</code><dd>用在RTX_FRAME_RELATED_P insn上，其附加的表达式被用在实际的insn模式上。这用于指令模式过于复杂或者产生误解的情况。

 </dl>

 <p>为方便起见，在<code>insn_list</code>或者<code>expr_list</code>中的机器模式，在调试转储中使用这些符号化的代码来打印。

 <p><a name="index-insn_005flist-2644"></a><a name="index-expr_005flist-2645"></a>表达式代码<code>insn_list</code>和<code>expr_list</code>之间的唯一区别是，<code>insn_list</code>的第一个操作数被假设为一个insn，并在调试转储中作为insn的唯一id来打印；而<code>expr_list</code>的第一个操作数作为表达式，按照普通的方式来打印。

 </body></html>

