<html lang="zh">
<head>
<title>栈检查 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link rel="prev" href="_00e5_00bc_0082_00e5_00b8_00b8_00e5_00a4_0084_00e7_0090_0086.html#g_t_00e5_00bc_0082_00e5_00b8_00b8_00e5_00a4_0084_00e7_0090_0086" title="异常处理">
<link rel="next" href="_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8.html#g_t_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8" title="帧寄存器">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%a0%88%e6%a3%80%e6%9f%a5"></a>
<a name="g_t_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8.html#g_t_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8">帧寄存器</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00bc_0082_00e5_00b8_00b8_00e5_00a4_0084_00e7_0090_0086.html#g_t_00e5_00bc_0082_00e5_00b8_00b8_00e5_00a4_0084_00e7_0090_0086">异常处理</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>
<hr>
</div>

<h4 class="subsection">17.10.3 指定如何进行栈检查</h4>

<p>GCC将检查栈引用是否位于栈的边界里，如果指定了<samp><span class="option">-fstack-check</span></samp>，
使用三种方式的之一：

     <ol type=1 start=1>
<li>如果<code>STACK_CHECK_BUILTIN</code>宏的值为非0，
则GCC将假设你已经安排了在配置文件的合适的地方进行栈检查，例如，
在TARGET_ASM_FUNCTION_PROLOGUE中。GCC将不再做其它特殊的处理。

     <li>If <code>STACK_CHECK_BUILTIN</code> is zero and the value of the
<code>STACK_CHECK_STATIC_BUILTIN</code> macro is nonzero, GCC will assume
that you have arranged for static stack checking (checking of the
static stack frame of functions) to be done at appropriate places
in the configuration files.  GCC will only emit code to do dynamic
stack checking (checking on dynamic stack allocations) using the third
approach below.

     <li>如果上面两种方式都不是，则GCC将生成代码来周期的“探测”栈指针，
使用下面定义的宏的值。
      </ol>

 <p>If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is defined,
GCC will change its allocation strategy for large objects if the option
<samp><span class="option">-fstack-check</span></samp> is specified: they will always be allocated
dynamically if their size exceeds <code>STACK_CHECK_MAX_VAR_SIZE</code> bytes.

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_BUILTIN</b><var><a name="index-STACK_005fCHECK_005fBUILTIN-3994"></a></var><br>
<blockquote><p>一个非0值，如果栈检查按照机器相关的方式通过配置文件来完成。
你应该定义该宏，如果栈检查被你的机器的ABI要求，
或者你想让栈检查使用比GCC可移植方式更有效的方法。该宏的缺省值为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_STATIC_BUILTIN</b><var><a name="index-STACK_005fCHECK_005fSTATIC_005fBUILTIN-3995"></a></var><br>
<blockquote><p>A nonzero value if static stack checking is done by the configuration files
in a machine-dependent manner.  You should define this macro if you would
like to do static stack checking in some more efficient way than the generic
approach.  The default value of this macro is zero. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_PROBE_INTERVAL</b><var><a name="index-STACK_005fCHECK_005fPROBE_005fINTERVAL-3996"></a></var><br>
<blockquote><p>一个整数表示GCC必须生成栈探测指令的间隔。
你通常需要定义该宏为不大于在栈结尾处的“guard pages”的大小。
缺省值4096适合于大多数系统。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_PROBE_LOAD</b><var><a name="index-STACK_005fCHECK_005fPROBE_005fLOAD-3997"></a></var><br>
<blockquote><p>一个整数，其为非0，如果GCC应该使用加载指令来执行栈探测，
为0如果GCC应该使用存储指令。缺省为0，其在大多数系统是更有效的选择。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_PROTECT</b><var><a name="index-STACK_005fCHECK_005fPROTECT-3998"></a></var><br>
<blockquote><p>栈从栈溢出中恢复所需要的字节数，用于这样的恢复被支持的语言。
缺省值75个字应该适合大多数机器。
</p></blockquote></div>

 <p>The following macros are relevant only if neither STACK_CHECK_BUILTIN
nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether
in the opposite case.

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_MAX_FRAME_SIZE</b><var><a name="index-STACK_005fCHECK_005fMAX_005fFRAME_005fSIZE-3999"></a></var><br>
<blockquote><p>一个栈帧的最大大小，以字节为单位。
GCC将生成探测指令在非叶子函数来确保栈中至少这么多大小的字节是可用的。
如果一个栈帧大于该大小，则栈检查将不可靠并且GCC将产生一个警告。缺省值被选择，
使得GCC只生成一条指令，在大多数系统上。你通常不应该修改该宏的缺省值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_FIXED_FRAME_SIZE</b><var><a name="index-STACK_005fCHECK_005fFIXED_005fFRAME_005fSIZE-4000"></a></var><br>
<blockquote><p>GCC使用该值来生成上面的警告消息。其表示函数使用的固定的帧数量，
不包括用于任何被调用者保存的寄存器，临时变量和用户变量的空间。
你只需要指定该数量的上界并且通常使用缺省值，4个字。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_CHECK_MAX_VAR_SIZE</b><var><a name="index-STACK_005fCHECK_005fMAX_005fVAR_005fSIZE-4001"></a></var><br>
<blockquote><p>为当用户指定<samp><span class="option">-fstack-check</span></samp>时，GCC将在栈帧的固定域放入的对象的最大大小，
以字节为单位。GCC根据上面的宏来计算缺省值并且你通常不需要覆盖缺省值。
</p></blockquote></div>

 </body></html>

