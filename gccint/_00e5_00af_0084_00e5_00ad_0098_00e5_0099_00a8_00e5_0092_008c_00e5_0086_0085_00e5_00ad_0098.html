<html lang="zh">
<head>
<title>寄存器和内存 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e5_00b8_00b8_00e6_0095_00b0.html#g_t_00e5_00b8_00b8_00e6_0095_00b0" title="常数">
<link rel="next" href="_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097" title="算术运算">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%af%84%e5%ad%98%e5%99%a8%e5%92%8c%e5%86%85%e5%ad%98"></a>
<a name="g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e5_0092_008c_00e5_0086_0085_00e5_00ad_0098"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097">算术运算</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00b8_00b8_00e6_0095_00b0.html#g_t_00e5_00b8_00b8_00e6_0095_00b0">常数</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.8 寄存器和内存</h3>

<p><a name="index-RTL-register-expressions-2367"></a><a name="index-RTL-memory-expressions-2368"></a>
这些是描述访问机器寄存器和内存的RTL表达式类型。

     
<a name="index-reg-2369"></a>
<a name="index-hard-registers-2370"></a>
<a name="index-pseudo-registers-2371"></a>
<dl><dt><code>(reg:</code><var>m</var> <var>n</var><code>)</code><dd>对于值小（那些小于<code>FIRST_PSEUDO_REGISTER</code>）的整数<var>n</var>，这表示对机器寄存器号为<var>n</var>的引用。对于值大的<var>n</var>，它表示一个临时的值或者伪寄存器（<dfn>pseudo register</dfn>）。编译器的策略是，在生成代码时假设有无限数目的伪寄存器，并在之后将它们转换为硬件寄存器（<dfn>hard register</dfn>）或者内存的引用。

     <p><var>m</var>为引用的机器模式。指定机器模式是有必要的，因为机器通常可以使用多种机器模式来引用每个寄存器。例如，一个寄存器可以包含一个整字，但是可以有指令来作为半字或者一个单独的字节来引用，同样，也有指令可以作为不同精度的浮点来引用。

     <p>即使对于机器只能使用一种机器模式来引用的寄存器，mode也必须被指定。

     <p>符号<code>FIRST_PSEUDO_REGISTER</code>被机器描述定义，由于机器的硬件寄存器数目是一个不变的特征。然而要注意，并不是所有的机器寄存器都必须是通用寄存器。所有的可以用于存储数据的机器寄存器都为被给定硬件寄存器编号，即使那些只可以被用于特定指令或者只能存放特定类型数据。

     <p>一个硬件寄存器可以在整个函数中按照多种机器模式来访问，但是每个伪寄存器都被给定一个自然的机器模式并且只能按照那个机器模式来访问。当需要描述一个使用非自然机器模式来访问伪寄存器的时候，则使用一个<code>subreg</code>表达式。

     <p>一个<code>reg</code>表达式具有的机器模式，如果指定了多于一个字的数据，则实际上代表了多个连续的寄存器。如果寄存器编号还指定了一个硬件寄存器，则其实际上表示起始于指定寄存器的多个连续的硬件寄存器。

     <p>每个在函数的RTL代码中使用的伪寄存器编号，使用一个唯一的<code>reg</code>表达式来表示。

     <p><a name="index-FIRST_005fVIRTUAL_005fREGISTER-2372"></a><a name="index-LAST_005fVIRTUAL_005fREGISTER-2373"></a>一些伪寄存器编号，处于<code>FIRST_VIRTUAL_REGISTER</code>到<code>LAST_VIRTUAL_REGISTER</code>之间，只在RTL生成阶段出现并且在优化阶段之前被消除。这些表示在栈帧中的位置，并且直到函数的RTL生成完成后才能确定。下列虚寄存器编号被定义：

          
<a name="index-VIRTUAL_005fINCOMING_005fARGS_005fREGNUM-2374"></a>
<dl><dt><code>VIRTUAL_INCOMING_ARGS_REGNUM</code><dd>这指向栈上传递的参数的第一个字。通常这些参数由调用者存放，但是被调用者可能已经将之前在寄存器中传递的参数压入栈中。

          <p><a name="index-g_t_0040code_007bFIRST_005fPARM_005fOFFSET_007d-and-virtual-registers-2375"></a><a name="index-g_t_0040code_007bARG_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2376"></a>当RTL生成完成时，该虚寄存器由<code>ARG_POINTER_REGNUM</code>给定的寄存器和<code>FIRST_PARM_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fSTACK_005fVARS_005fREGNUM-2377"></a><a name="index-g_t_0040code_007bFRAME_005fGROWS_005fDOWNWARD_007d-and-virtual-registers-2378"></a><br><dt><code>VIRTUAL_STACK_VARS_REGNUM</code><dd>如果<code>FRAME_GROWS_DOWNWARD</code>被定义为非0的值，则该宏指向栈上第一个变量的上一个位置。否则，其指向栈上的第一个变量。

          <p><a name="index-g_t_0040code_007bSTARTING_005fFRAME_005fOFFSET_007d-and-virtual-registers-2379"></a><a name="index-g_t_0040code_007bFRAME_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2380"></a><code>VIRTUAL_STACK_VARS_REGNUM</code>由<code>FRAME_POINTER_REGNUM</code>给定的寄存器和<code>STARTING_FRAME_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fSTACK_005fDYNAMIC_005fREGNUM-2381"></a><br><dt><code>VIRTUAL_STACK_DYNAMIC_REGNUM</code><dd>该宏指向栈指针根据内存需要已经被调整后的栈上动态分配内存的位置。

          <p><a name="index-g_t_0040code_007bSTACK_005fDYNAMIC_005fOFFSET_007d-and-virtual-registers-2382"></a><a name="index-g_t_0040code_007bSTACK_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2383"></a>该虚寄存器由<code>STACK_POINTER_REGNUM</code>给定的寄存器和<code>STACK_DYNAMIC_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fOUTGOING_005fARGS_005fREGNUM-2384"></a><br><dt><code>VIRTUAL_OUTGOING_ARGS_REGNUM</code><dd>其指向栈中，当预先压栈时（使用push insn压栈的参数应该总是使用<code>STACK_POINTER_REGNUM</code>），书写输出参数的位置。

          <p><a name="index-g_t_0040code_007bSTACK_005fPOINTER_005fOFFSET_007d-and-virtual-registers-2385"></a>该虚拟寄存器，被替换成由<code>STACK_POINTER_REGNUM</code>给定的寄存器与值<code>STACK_POINTER_OFFSET</code>的和。

     </dl>

     <p><a name="index-subreg-2386"></a><br><dt><code>(subreg:</code><var>m1</var> <var>reg:m2</var> <var>bytenum</var><code>)</code><dd>
<code>subreg</code>表达式用于引用 expressions are used to refer to a register in a machine
mode other than its natural one, or to refer to one register of
a multi-part <code>reg</code> that actually refers to several registers.

     <p>Each pseudo register has a natural mode.  If it is necessary to
operate on it in a different mode, the register must be
enclosed in a <code>subreg</code>.

     <p>There are currently three supported types for the first operand of a
<code>subreg</code>:
          <ul>
<li>pseudo registers
This is the most common case.  Most <code>subreg</code>s have pseudo
<code>reg</code>s as their first operand.

          <li>mem
<code>subreg</code>s of <code>mem</code> were common in earlier versions of GCC and
are still supported.  During the reload pass these are replaced by plain
<code>mem</code>s.  On machines that do not do instruction scheduling, use of
<code>subreg</code>s of <code>mem</code> are still used, but this is no longer
recommended.  Such <code>subreg</code>s are considered to be
<code>register_operand</code>s rather than <code>memory_operand</code>s before and
during reload.  Because of this, the scheduling passes cannot properly
schedule instructions with <code>subreg</code>s of <code>mem</code>, so for machines
that do scheduling, <code>subreg</code>s of <code>mem</code> should never be used. 
To support this, the combine and recog passes have explicit code to
inhibit the creation of <code>subreg</code>s of <code>mem</code> when
<code>INSN_SCHEDULING</code> is defined.

          <p>The use of <code>subreg</code>s of <code>mem</code> after the reload pass is an area
that is not well understood and should be avoided.  There is still some
code in the compiler to support this, but this code has possibly rotted. 
This use of <code>subreg</code>s is discouraged and will most likely not be
supported in the future.

          <li>hard registers
It is seldom necessary to wrap hard registers in <code>subreg</code>s; such
registers would normally reduce to a single <code>reg</code> rtx.  This use of
<code>subreg</code>s is discouraged and may not be supported in the future.

     </ul>

     <p><code>subreg</code>s of <code>subreg</code>s are not supported.  Using
<code>simplify_gen_subreg</code> is the recommended way to avoid this problem.

     <p><code>subreg</code>s come in two distinct flavors, each having its own
usage and rules:

          <dl>
<dt>Paradoxical subregs<dd>When <var>m1</var> is strictly wider than <var>m2</var>, the <code>subreg</code>
expression is called <dfn>paradoxical</dfn>.  The canonical test for this
class of <code>subreg</code> is:

          <pre class="smallexample">               GET_MODE_SIZE (<var>m1</var>) &gt; GET_MODE_SIZE (<var>m2</var>)
</pre>
          <p>Paradoxical <code>subreg</code>s can be used as both lvalues and rvalues. 
When used as an lvalue, the low-order bits of the source value
are stored in <var>reg</var> and the high-order bits are discarded. 
When used as an rvalue, the low-order bits of the <code>subreg</code> are
taken from <var>reg</var> while the high-order bits may or may not be
defined.

          <p>The high-order bits of rvalues are in the following circumstances:

               <ul>
<li><code>subreg</code>s of <code>mem</code>
When <var>m2</var> is smaller than a word, the macro <code>LOAD_EXTEND_OP</code>,
can control how the high-order bits are defined.

               <li><code>subreg</code> of <code>reg</code>s
The upper bits are defined when <code>SUBREG_PROMOTED_VAR_P</code> is true. 
<code>SUBREG_PROMOTED_UNSIGNED_P</code> describes what the upper bits hold. 
Such subregs usually represent local variables, register variables
and parameter pseudo variables that have been promoted to a wider mode.

          </ul>

          <p><var>bytenum</var> is always zero for a paradoxical <code>subreg</code>, even on
big-endian targets.

          <p>For example, the paradoxical <code>subreg</code>:

          <pre class="smallexample">               (set (subreg:SI (reg:HI <var>x</var>) 0) <var>y</var>)
</pre>
          <p>stores the lower 2 bytes of <var>y</var> in <var>x</var> and discards the upper
2 bytes.  A subsequent:

          <pre class="smallexample">               (set <var>z</var> (subreg:SI (reg:HI <var>x</var>) 0))
</pre>
          <p>would set the lower two bytes of <var>z</var> to <var>y</var> and set the upper
two bytes to an unknown value assuming <code>SUBREG_PROMOTED_VAR_P</code> is
false.

          <br><dt>Normal subregs<dd>When <var>m1</var> is at least as narrow as <var>m2</var> the <code>subreg</code>
expression is called <dfn>normal</dfn>.

          <p>Normal <code>subreg</code>s restrict consideration to certain bits of
<var>reg</var>.  There are two cases.  If <var>m1</var> is smaller than a word,
the <code>subreg</code> refers to the least-significant part (or
<dfn>lowpart</dfn>) of one word of <var>reg</var>.  If <var>m1</var> is word-sized or
greater, the <code>subreg</code> refers to one or more complete words.

          <p>When used as an lvalue, <code>subreg</code> is a word-based accessor. 
Storing to a <code>subreg</code> modifies all the words of <var>reg</var> that
overlap the <code>subreg</code>, but it leaves the other words of <var>reg</var>
alone.

          <p>When storing to a normal <code>subreg</code> that is smaller than a word,
the other bits of the referenced word are usually left in an undefined
state.  This laxity makes it easier to generate efficient code for
such instructions.  To represent an instruction that preserves all the
bits outside of those in the <code>subreg</code>, use <code>strict_low_part</code>
or <code>zero_extract</code> around the <code>subreg</code>.

          <p><var>bytenum</var> must identify the offset of the first byte of the
<code>subreg</code> from the start of <var>reg</var>, assuming that <var>reg</var> is
laid out in memory order.  The memory order of bytes is defined by
two target macros, <code>WORDS_BIG_ENDIAN</code> and <code>BYTES_BIG_ENDIAN</code>:

               <ul>
<li><a name="index-g_t_0040code_007bWORDS_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2387"></a><code>WORDS_BIG_ENDIAN</code>, if set to 1, says that byte number zero is
part of the most significant word; otherwise, it is part of the least
significant word.

               <li><a name="index-g_t_0040code_007bBYTES_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2388"></a><code>BYTES_BIG_ENDIAN</code>, if set to 1, says that byte number zero is
the most significant byte within a word; otherwise, it is the least
significant byte within a word. 
</ul>

          <p><a name="index-g_t_0040code_007bFLOAT_005fWORDS_005fBIG_005fENDIAN_007d_002c-_0028lack-of_0029-effect-on-_0040code_007bsubreg_007d-2389"></a>On a few targets, <code>FLOAT_WORDS_BIG_ENDIAN</code> disagrees with
<code>WORDS_BIG_ENDIAN</code>.  However, most parts of the compiler treat
floating point values as if they had the same endianness as integer
values.  This works because they handle them solely as a collection of
integer values, with no particular numerical value.  Only real.c and
the runtime libraries care about <code>FLOAT_WORDS_BIG_ENDIAN</code>.

          <p>Thus,

          <pre class="smallexample">               (subreg:HI (reg:SI <var>x</var>) 2)
</pre>
          <p>on a <code>BYTES_BIG_ENDIAN</code>, &lsquo;<samp><span class="samp">UNITS_PER_WORD == 4</span></samp>&rsquo; target is the same as

          <pre class="smallexample">               (subreg:HI (reg:SI <var>x</var>) 0)
</pre>
          <p>on a little-endian, &lsquo;<samp><span class="samp">UNITS_PER_WORD == 4</span></samp>&rsquo; target.  Both
<code>subreg</code>s access the lower two bytes of register <var>x</var>.

     </dl>

     <p>A <code>MODE_PARTIAL_INT</code> mode behaves as if it were as wide as the
corresponding <code>MODE_INT</code> mode, except that it has an unknown
number of undefined bits.  For example:

     <pre class="smallexample">          (subreg:PSI (reg:SI 0) 0)
</pre>
     <p>accesses the whole of &lsquo;<samp><span class="samp">(reg:SI 0)</span></samp>&rsquo;, but the exact relationship
between the <code>PSImode</code> value and the <code>SImode</code> value is not
defined.  If we assume &lsquo;<samp><span class="samp">UNITS_PER_WORD &lt;= 4</span></samp>&rsquo;, then the following
two <code>subreg</code>s:

     <pre class="smallexample">          (subreg:PSI (reg:DI 0) 0)
          (subreg:PSI (reg:DI 0) 4)
</pre>
     <p>represent independent 4-byte accesses to the two halves of
&lsquo;<samp><span class="samp">(reg:DI 0)</span></samp>&rsquo;.  Both <code>subreg</code>s have an unknown number
of undefined bits.

     <p>If &lsquo;<samp><span class="samp">UNITS_PER_WORD &lt;= 2</span></samp>&rsquo; then these two <code>subreg</code>s:

     <pre class="smallexample">          (subreg:HI (reg:PSI 0) 0)
          (subreg:HI (reg:PSI 0) 2)
</pre>
     <p>represent independent 2-byte accesses that together span the whole
of &lsquo;<samp><span class="samp">(reg:PSI 0)</span></samp>&rsquo;.  Storing to the first <code>subreg</code> does not
affect the value of the second, and vice versa.  &lsquo;<samp><span class="samp">(reg:PSI 0)</span></samp>&rsquo;
has an unknown number of undefined bits, so the assignment:

     <pre class="smallexample">          (set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
</pre>
     <p>does not guarantee that &lsquo;<samp><span class="samp">(subreg:HI (reg:PSI 0) 0)</span></samp>&rsquo; has the
value &lsquo;<samp><span class="samp">(reg:HI 4)</span></samp>&rsquo;.

     <p><a name="index-g_t_0040code_007bCANNOT_005fCHANGE_005fMODE_005fCLASS_007d-and-subreg-semantics-2390"></a>The rules above apply to both pseudo <var>reg</var>s and hard <var>reg</var>s. 
If the semantics are not correct for particular combinations of
<var>m1</var>, <var>m2</var> and hard <var>reg</var>, the target-specific code
must ensure that those combinations are never used.  For example:

     <pre class="smallexample">          CANNOT_CHANGE_MODE_CLASS (<var>m2</var>, <var>m1</var>, <var>class</var>)
</pre>
     <p>must be true for every class <var>class</var> that includes <var>reg</var>.

     <p><a name="index-SUBREG_005fREG-2391"></a><a name="index-SUBREG_005fBYTE-2392"></a>The first operand of a <code>subreg</code> expression is customarily accessed
with the <code>SUBREG_REG</code> macro and the second operand is customarily
accessed with the <code>SUBREG_BYTE</code> macro.

     <p>It has been several years since a platform in which
<code>BYTES_BIG_ENDIAN</code> not equal to <code>WORDS_BIG_ENDIAN</code> has
been tested.  Anyone wishing to support such a platform in the future
may be confronted with code rot.

     <p><a name="index-scratch-2393"></a><a name="index-scratch-operands-2394"></a><br><dt><code>(scratch:</code><var>m</var><code>)</code><dd>This represents a scratch register that will be required for the
execution of a single instruction and not used subsequently.  It is
converted into a <code>reg</code> by either the local register allocator or
the reload pass.

     <p><code>scratch</code> is usually present inside a <code>clobber</code> operation
(see <a href="Side-Effects.html#Side-Effects">Side Effects</a>).

     <p><a name="index-cc0-2395"></a><a name="index-condition-code-register-2396"></a><br><dt><code>(cc0)</code><dd>This refers to the machine's condition code register.  It has no
operands and may not have a machine mode.  There are two ways to use it:

          <ul>
<li>To stand for a complete set of condition code flags.  This is best on
most machines, where each comparison sets the entire series of flags.

          <p>With this technique, <code>(cc0)</code> may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) and in comparison operators comparing against zero
(<code>const_int</code> with value zero; that is to say, <code>const0_rtx</code>).

          <li>To stand for a single flag that is the result of a single condition. 
This is useful on machines that have only a single flag bit, and in
which comparison instructions must specify the condition to test.

          <p>With this technique, <code>(cc0)</code> may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) where the source is a comparison operator, and as the
first operand of <code>if_then_else</code> (in a conditional branch). 
</ul>

     <p><a name="index-cc0_005frtx-2397"></a>There is only one expression object of code <code>cc0</code>; it is the
value of the variable <code>cc0_rtx</code>.  Any attempt to create an
expression of code <code>cc0</code> will return <code>cc0_rtx</code>.

     <p>Instructions can set the condition code implicitly.  On many machines,
nearly all instructions set the condition code based on the value that
they compute or store.  It is not necessary to record these actions
explicitly in the RTL because the machine description includes a
prescription for recognizing the instructions that do so (by means of
the macro <code>NOTICE_UPDATE_CC</code>).  See <a href="Condition-Code.html#Condition-Code">Condition Code</a>.  Only
instructions whose sole purpose is to set the condition code, and
instructions that use the condition code, need mention <code>(cc0)</code>.

     <p>On some machines, the condition code register is given a register number
and a <code>reg</code> is used instead of <code>(cc0)</code>.  This is usually the
preferable approach if only a small subset of instructions modify the
condition code.  Other machines store condition codes in general
registers; in such cases a pseudo register should be used.

     <p>Some machines, such as the SPARC and RS/6000, have two sets of
arithmetic instructions, one that sets and one that does not set the
condition code.  This is best handled by normally generating the
instruction that does not set the condition code, and making a pattern
that both performs the arithmetic and sets the condition code register
(which would not be <code>(cc0)</code> in this case).  For examples, search
for &lsquo;<samp><span class="samp">addcc</span></samp>&rsquo; and &lsquo;<samp><span class="samp">andcc</span></samp>&rsquo; in <samp><span class="file">sparc.md</span></samp>.

     <p><a name="index-pc-2398"></a><br><dt><code>(pc)</code><dd><a name="index-program-counter-2399"></a>This represents the machine's program counter.  It has no operands and
may not have a machine mode.  <code>(pc)</code> may be validly used only in
certain specific contexts in jump instructions.

     <p><a name="index-pc_005frtx-2400"></a>There is only one expression object of code <code>pc</code>; it is the value
of the variable <code>pc_rtx</code>.  Any attempt to create an expression of
code <code>pc</code> will return <code>pc_rtx</code>.

     <p>All instructions that do not jump alter the program counter implicitly
by incrementing it, but there is no need to mention this in the RTL.

     <p><a name="index-mem-2401"></a><br><dt><code>(mem:</code><var>m</var> <var>addr</var> <var>alias</var><code>)</code><dd>This RTX represents a reference to main memory at an address
represented by the expression <var>addr</var>.  <var>m</var> specifies how large
a unit of memory is accessed.  <var>alias</var> specifies an alias set for the
reference.  In general two items are in different alias sets if they cannot
reference the same memory address.

     <p>The construct <code>(mem:BLK (scratch))</code> is considered to alias all
other memories.  Thus it may be used as a memory barrier in epilogue
stack deallocation patterns.

     <p><a name="index-concat-2402"></a><br><dt><code>(concat</code><var>m</var> <var>rtx</var> <var>rtx</var><code>)</code><dd>This RTX represents the concatenation of two other RTXs.  This is used
for complex values.  It should only appear in the RTL attached to
declarations and during RTL generation.  It should not appear in the
ordinary insn chain.

     <p><a name="index-concatn-2403"></a><br><dt><code>(concatn</code><var>m</var><code> [</code><var>rtx</var><code> ...])</code><dd>This RTX represents the concatenation of all the <var>rtx</var> to make a
single value.  Like <code>concat</code>, this should only appear in
declarations, and not in the insn chain. 
</dl>

 </body></html>

