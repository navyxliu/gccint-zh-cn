<html lang="zh">
<head>
<title>寄存器和内存 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="_00e5_00b8_00b8_00e6_0095_00b0.html#g_t_00e5_00b8_00b8_00e6_0095_00b0" title="常数">
<link rel="next" href="_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097" title="算术运算">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%af%84%e5%ad%98%e5%99%a8%e5%92%8c%e5%86%85%e5%ad%98"></a>
<a name="g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e5_0092_008c_00e5_0086_0085_00e5_00ad_0098"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097.html#g_t_00e7_00ae_0097_00e6_009c_00af_00e8_00bf_0090_00e7_00ae_0097">算术运算</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00b8_00b8_00e6_0095_00b0.html#g_t_00e5_00b8_00b8_00e6_0095_00b0">常数</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.8 寄存器和内存</h3>

<p><a name="index-RTL-register-expressions-2367"></a><a name="index-RTL-memory-expressions-2368"></a>
这些是描述访问机器寄存器和内存的RTL表达式类型。

     
<a name="index-reg-2369"></a>
<a name="index-hard-registers-2370"></a>
<a name="index-pseudo-registers-2371"></a>
<dl><dt><code>(reg:</code><var>m</var> <var>n</var><code>)</code><dd>对于值小（那些小于<code>FIRST_PSEUDO_REGISTER</code>）的整数<var>n</var>，这表示对机器寄存器号为<var>n</var>的引用。对于值大的<var>n</var>，它表示一个临时的值或者伪寄存器（<dfn>pseudo register</dfn>）。编译器的策略是，在生成代码时假设有无限数目的伪寄存器，并在之后将它们转换为硬件寄存器（<dfn>hard register</dfn>）或者内存的引用。

     <p><var>m</var>为引用的机器模式。指定机器模式是有必要的，因为机器通常可以使用多种机器模式来引用每个寄存器。例如，一个寄存器可以包含一个整字，但是可以有指令来作为半字或者一个单独的字节来引用，同样，也有指令可以作为不同精度的浮点来引用。

     <p>即使对于机器只能使用一种机器模式来引用的寄存器，mode也必须被指定。

     <p>符号<code>FIRST_PSEUDO_REGISTER</code>被机器描述定义，由于机器的硬件寄存器数目是一个不变的特征。然而要注意，并不是所有的机器寄存器都必须是通用寄存器。所有的可以用于存储数据的机器寄存器都为被给定硬件寄存器编号，即使那些只可以被用于特定指令或者只能存放特定类型数据。

     <p>一个硬件寄存器可以在整个函数中按照多种机器模式来访问，但是每个伪寄存器都被给定一个自然的机器模式并且只能按照那个机器模式来访问。当需要描述一个使用非自然机器模式来访问伪寄存器的时候，则使用一个<code>subreg</code>表达式。

     <p>一个<code>reg</code>表达式具有的机器模式，如果指定了多于一个字的数据，则实际上代表了多个连续的寄存器。如果寄存器编号还指定了一个硬件寄存器，则其实际上表示起始于指定寄存器的多个连续的硬件寄存器。

     <p>每个在函数的RTL代码中使用的伪寄存器编号，使用一个唯一的<code>reg</code>表达式来表示。

     <p><a name="index-FIRST_005fVIRTUAL_005fREGISTER-2372"></a><a name="index-LAST_005fVIRTUAL_005fREGISTER-2373"></a>一些伪寄存器编号，处于<code>FIRST_VIRTUAL_REGISTER</code>到<code>LAST_VIRTUAL_REGISTER</code>之间，只在RTL生成阶段出现并且在优化阶段之前被消除。这些表示在栈帧中的位置，并且直到函数的RTL生成完成后才能确定。下列虚寄存器编号被定义：

          
<a name="index-VIRTUAL_005fINCOMING_005fARGS_005fREGNUM-2374"></a>
<dl><dt><code>VIRTUAL_INCOMING_ARGS_REGNUM</code><dd>这指向栈上传递的参数的第一个字。通常这些参数由调用者存放，但是被调用者可能已经将之前在寄存器中传递的参数压入栈中。

          <p><a name="index-g_t_0040code_007bFIRST_005fPARM_005fOFFSET_007d-and-virtual-registers-2375"></a><a name="index-g_t_0040code_007bARG_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2376"></a>当RTL生成完成时，该虚寄存器由<code>ARG_POINTER_REGNUM</code>给定的寄存器和<code>FIRST_PARM_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fSTACK_005fVARS_005fREGNUM-2377"></a><a name="index-g_t_0040code_007bFRAME_005fGROWS_005fDOWNWARD_007d-and-virtual-registers-2378"></a><br><dt><code>VIRTUAL_STACK_VARS_REGNUM</code><dd>如果<code>FRAME_GROWS_DOWNWARD</code>被定义为非0的值，则该宏指向栈上第一个变量的上一个位置。否则，其指向栈上的第一个变量。

          <p><a name="index-g_t_0040code_007bSTARTING_005fFRAME_005fOFFSET_007d-and-virtual-registers-2379"></a><a name="index-g_t_0040code_007bFRAME_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2380"></a><code>VIRTUAL_STACK_VARS_REGNUM</code>由<code>FRAME_POINTER_REGNUM</code>给定的寄存器和<code>STARTING_FRAME_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fSTACK_005fDYNAMIC_005fREGNUM-2381"></a><br><dt><code>VIRTUAL_STACK_DYNAMIC_REGNUM</code><dd>该宏指向栈指针根据内存需要已经被调整后的栈上动态分配内存的位置。

          <p><a name="index-g_t_0040code_007bSTACK_005fDYNAMIC_005fOFFSET_007d-and-virtual-registers-2382"></a><a name="index-g_t_0040code_007bSTACK_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2383"></a>该虚寄存器由<code>STACK_POINTER_REGNUM</code>给定的寄存器和<code>STACK_DYNAMIC_OFFSET</code>的值的和替换。

          <p><a name="index-VIRTUAL_005fOUTGOING_005fARGS_005fREGNUM-2384"></a><br><dt><code>VIRTUAL_OUTGOING_ARGS_REGNUM</code><dd>其指向栈中，当预先压栈时（使用push insn压栈的参数应该总是使用<code>STACK_POINTER_REGNUM</code>），书写输出参数的位置。

          <p><a name="index-g_t_0040code_007bSTACK_005fPOINTER_005fOFFSET_007d-and-virtual-registers-2385"></a>该虚拟寄存器，被替换成由<code>STACK_POINTER_REGNUM</code>给定的寄存器与值<code>STACK_POINTER_OFFSET</code>的和。

     </dl>

     <p><a name="index-subreg-2386"></a><br><dt><code>(subreg:</code><var>m1</var> <var>reg:m2</var> <var>bytenum</var><code>)</code><dd><code>subreg</code>表达式用于按照自然的机器模式之外的，其它机器模式来引用一个寄存器，或者引用有多个寄存器组成的<code>reg</code>的其中一个寄存器。

     <p>每个伪寄存器都具有一个自然的机器模式。如果需要按照不同的机器模式来对其操作，则寄存器必须用<code>subreg</code>进行包含。

     <p>目前对于<code>subreg</code>的第一个操作数，有三种被支持的类型：

          <ul>
<li>pseudo registers
这是最常见的情况。大多<code>subreg</code>将伪寄存器<code>reg</code>作为它们的第一个操作数。

          <li>mem
<code>mem</code>的<code>subreg</code>，在早期版本的GCC中比较常见，现在仍被支持。在重载过程中，这些被普通的<code>mem</code>替换掉。在不进行指令调度的机器上，仍然使用<code>mem</code>的<code>subreg</code>，但是不推荐这样。在重载过程之前和过程之中，这样的<code>subreg</code>被考虑成<code>register_operand</code>，而不是<code>memory_operand</code>。因此，调度过程无法对具有<code>mem</code>的<code>subreg</code>这样的指令进行合适的调度。所以，对于进行调度的机器，不要使用<code>mem</code>的<code>subreg</code>。为此，当<code>INSN_SCHEDULING</code>被定义的时候，合并过程和recog过程，具有显式的代码来禁止创建<code>mem</code>的<code>subreg</code>。

          <p>在重载过程之后使用<code>mem</code>的<code>subreg</code>，将难以理解，应该避免这样。编译器中还有一些代码支持这些，但是这些代码可能已经过时了。这种<code>subreg</code>的用法不被推荐，将来很可能不被支持。

          <li>hard registers
很少有必要在<code>subreg</code>中包裹硬件寄存器；这样的寄存器通常应该被缩减为一个单独的<code>reg</code> rtx。这种<code>subreg</code>的用法不被推荐，将来可能不被支持。

     </ul>

     <p><code>subreg</code>的<code>subreg</code>不被支持。推荐使用<code>simplify_gen_subreg</code>来避免这种问题。

     <p><code>subreg</code>有两种不同的风格，分别具有自己的用法和规则：

          <dl>
<dt>Paradoxical subregs<dd>当<var>m1</var>严格宽于<var>m2</var>的时候，<code>subreg</code>表达式被称作反常的（<dfn>paradoxical</dfn>）。对该类别的<code>subreg</code>的正规测试为：

          <pre class="smallexample">               GET_MODE_SIZE (<var>m1</var>) &gt; GET_MODE_SIZE (<var>m2</var>)
</pre>
          <p>反常的<code>subreg</code>可以用于左值和右值。当用于左值时，源值的低位被存储在<var>reg</var>中，高位被丢弃。当用作右值时，<code>subreg</code>的低位来自<var>reg</var>，而高位可以被定义，也可以未被定义。

          <p>右值的高位有以下几种情况：

               <ul>
<li><code>subreg</code>s of <code>mem</code>
当<var>m2</var>小于一个字的时候，宏<code>LOAD_EXTEND_OP</code>可以控制高位如何被定义。

               <li><code>subreg</code> of <code>reg</code>s
当<code>SUBREG_PROMOTED_VAR_P</code>为真时，高位被定义。<code>SUBREG_PROMOTED_UNSIGNED_P</code>描述了高位的内容。这样的subreg通常表示已经被提升为更宽的机器模式的局部变量，寄存器变量以及参数伪变量。

          </ul>

          <p>对于反常的<code>subreg</code>，<var>bytenum</var>总是为零，即使在大端的目标机上。

          <p>例如反常的<code>subreg</code>:

          <pre class="smallexample">               (set (subreg:SI (reg:HI <var>x</var>) 0) <var>y</var>)
</pre>
          <p>在<var>x</var>中存储了<var>y</var>的低位2个字节，并丢弃高位2个字节。接着：

          <pre class="smallexample">               (set <var>z</var> (subreg:SI (reg:HI <var>x</var>) 0))
</pre>
          <p>将会把<var>z</var>的低位2个字节设置成<var>x</var>，并将高位两个字节设置为未知的值，假定<code>SUBREG_PROMOTED_VAR_P</code>为假。

          <br><dt>Normal subregs<dd>当<var>m1</var>最多跟<var>m2</var>一样宽的时候，<code>subreg</code>表达式被称作正常的（<dfn>normal</dfn>）。

          <p>正常的<code>subreg</code>被限定为<var>reg</var>的特定位。有两种情况。如果<var>m1</var>比一个字小，则<code>subreg</code>指的是一个<var>reg</var>字的最小有效部分。如果<var>m1</var>为字大小，或者更大，则<code>subreg</code>指的是一个或者更多个完整的字。

          <p>当用作左值时，<code>subreg</code>为一个基于字的访问。对<code>subreg</code>进行存储，会修改<var>reg</var>中所有与<code>subreg</code>重叠的字，并将<var>reg</var>中的其它字保持不变。

          <p>当对小于一个字的正常<code>subreg</code>进行存储的时候，被引用的字的其它位通常处于未定义的状态。这种松弛的方式易于对这样的指令产生高效的代码。要表示保持<code>subreg</code>之外的所有位的指令，在<code>subreg</code>周围使用<code>strict_low_part</code>或者<code>zero_extract</code>。

          <p><var>bytenum</var>必须标识从<var>reg</var>的起始，<code>subreg</code>的第一个字节的偏移量，假设<var>reg</var>按照内存的顺序布局。字节的内存顺序通过两个目标宏定义，<code>WORDS_BIG_ENDIAN</code>和<code>BYTES_BIG_ENDIAN</code>：

               <ul>
<li><a name="index-g_t_0040code_007bWORDS_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2387"></a><code>WORDS_BIG_ENDIAN</code>，如果设为1，则说明第零个字节为最大有效字的部分；否则，为最小有效字的部分。

               <li><a name="index-g_t_0040code_007bBYTES_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2388"></a><code>BYTES_BIG_ENDIAN</code>，如果设为1，则说明第零个字节为字中的最高有效字节；否则，为字中的最低有效字节。

          </ul>

          <p><a name="index-g_t_0040code_007bFLOAT_005fWORDS_005fBIG_005fENDIAN_007d_002c-_0028lack-of_0029-effect-on-_0040code_007bsubreg_007d-2389"></a>在一些目标机上，<code>FLOAT_WORDS_BIG_ENDIAN</code>与<code>WORDS_BIG_ENDIAN</code>不一致。然而，编译器的大部分地方会将浮点值看作它们与整数值具有相同的大小端。这是因为只将它们作为整数值的集合来处理，没有特定的数值。只有real.c和运行时库关心<code>FLOAT_WORDS_BIG_ENDIAN</code>。

          <p>因此，

          <pre class="smallexample">               (subreg:HI (reg:SI <var>x</var>) 2)
</pre>
          <p>在一个<code>BYTES_BIG_ENDIAN</code>，&lsquo;<samp><span class="samp">UNITS_PER_WORD == 4</span></samp>&rsquo;的目标机上，等同于

          <pre class="smallexample">               (subreg:HI (reg:SI <var>x</var>) 0)
</pre>
          <p>在一个小端，&lsquo;<samp><span class="samp">UNITS_PER_WORD == 4</span></samp>&rsquo;的目标机上。两个<code>subreg</code>都是访问寄存器<var>x</var>的低两个字节。

     </dl>

     <p><code>MODE_PARTIAL_INT</code>机器模式的行为就好像其与相对应的<code>MODE_INT</code>机器模式一样宽，只不过其具有未知数目的未定义的位。例如：

     <pre class="smallexample">          (subreg:PSI (reg:SI 0) 0)
</pre>
     <p>访问整个&lsquo;<samp><span class="samp">(reg:SI 0)</span></samp>&rsquo;，但是<code>PSImode</code>值和<code>SImode</code>值的确切关系没有被定义。如果我们假设&lsquo;<samp><span class="samp">UNITS_PER_WORD &lt;= 4</span></samp>&rsquo;，则下面两个<code>subreg</code>：

     <pre class="smallexample">          (subreg:PSI (reg:DI 0) 0)
          (subreg:PSI (reg:DI 0) 4)
</pre>
     <p>表示对&lsquo;<samp><span class="samp">(reg:DI 0)</span></samp>&rsquo;的两个部分进行无关的四个字节访问。每个<code>subreg</code>都具有未知数目的未定义位。

     <p>如果&lsquo;<samp><span class="samp">UNITS_PER_WORD &lt;= 2</span></samp>&rsquo;，则这两个<code>subreg</code>

     <pre class="smallexample">          (subreg:HI (reg:PSI 0) 0)
          (subreg:HI (reg:PSI 0) 2)
</pre>
     <p>表示无关的两个字节访问，一起贯穿整个&lsquo;<samp><span class="samp">(reg:PSI 0)</span></samp>&rsquo;。对第一个<code>subreg</code>进行存储不影响第二个的值，反之亦然。&lsquo;<samp><span class="samp">(reg:PSI 0)</span></samp>&rsquo;具有未知数目的未定义位，所以赋值：

     <pre class="smallexample">          (set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
</pre>
     <p>不保证&lsquo;<samp><span class="samp">(subreg:HI (reg:PSI 0) 0)</span></samp>&rsquo;具有值&lsquo;<samp><span class="samp">(reg:HI 4)</span></samp>&rsquo;。

     <p><a name="index-g_t_0040code_007bCANNOT_005fCHANGE_005fMODE_005fCLASS_007d-and-subreg-semantics-2390"></a>上面的规则应用于伪寄存器<var>reg</var>和硬件寄存器<var>reg</var>。如果对于<var>m1</var>, <var>m2</var>和硬件寄存器<var>reg</var>的特定组合，其语义不正确，则目标机特定的代码必须确保这些组合不会被用到。例如：

     <pre class="smallexample">          CANNOT_CHANGE_MODE_CLASS (<var>m2</var>, <var>m1</var>, <var>class</var>)
</pre>
     <p>必须为真，对于每个包含<var>reg</var>的类别<var>class</var>。

     <p><a name="index-SUBREG_005fREG-2391"></a><a name="index-SUBREG_005fBYTE-2392"></a><code>subreg</code>表达式的第一个操作数通常使用<code>SUBREG_REG</code>宏来访问，第二个操作数通常使用<code>SUBREG_BYTE</code>宏来访问。

     <p><code>BYTES_BIG_ENDIAN</code>不等于<code>WORDS_BIG_ENDIAN</code>的平台是在很多年前被测试的。对于希望在将来支持这样一个平台的人们，可能会面对一些过时的代码。

     <p><a name="index-scratch-2393"></a><a name="index-scratch-operands-2394"></a><br><dt><code>(scratch:</code><var>m</var><code>)</code><dd>这表示一个scratch寄存器，其在单个指令的执行中用到，并随后不再被使用。其被局部寄存器分配或者重载过程，转换成一个<code>reg</code>。

     <p><code>scratch</code>通常位于<code>clobber</code>操作中。(see <a href="Side-Effects.html#Side-Effects">Side Effects</a>)。

     <p><a name="index-cc0-2395"></a><a name="index-condition-code-register-2396"></a><br><dt><code>(cc0)</code><dd>为机器的条件代码寄存器。其没有参数，并可以没有机器模式。有两种使用它的方式：

          <ul>
<li>表示一个完整的条件代码标记的集合。这在大多机器上是最好的方式，每个比较都会设置整个标记系列。

          <p>使用这种技术，<code>(cc0)</code>只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中）和在跟零进行比较的比较运算符中（值为零的<code>const_int</code>；也就是说，<code>const0_rtx</code>）。

          <li>表示单个标记，为单个条件的结果。这用于只有一个标记位，比较指令必须指定要测试的条件的机器上。

          <p>使用这种技术，<code>(cc0)</code>只在两种上下文中有效：为一个赋值的对象（在测试和比较指令中），其中源操作数为一个比较运算符，以及<code>if_then_else</code>的第一个参数（在条件分支中）。

     </ul>

     <p><a name="index-cc0_005frtx-2397"></a>只有一个代码为<code>cc0</code>的表达式对象；其为变量<code>cc0_rtx</code>的值。任何尝试创建一个代码为<code>cc0</code>的表达式，将返回<code>cc0_rtx</code>。

     <p>指令可以隐式的设置条件代码。在许多机器上，几乎所有的指令根据它们计算或者存储的值来设置条件码。没有必要在RTL中显式的记录这些行为，因为机器描述包含一个对策，用于识别这样做的指令（通过宏<code>NOTICE_UPDATE_CC</code>）。See <a href="Condition-Code.html#Condition-Code">Condition Code</a>。只有目的纯粹是设置条件码的指令，以及使用条件码的指令，才需要提及<code>(cc0)</code>。

     <p>在一些机器上，条件码寄存器被给定一个寄存器编号，并且一个<code>reg</code>用于替代<code>(cc0)</code>。这通常为更好的方式，如果只有一个小的指令子集修改条件码。其它机器将条件码存储在通用寄存器中；这种情况下应该使用伪寄存器。

     <p>一些机器，例如SPARC和RS/6000，具有两个算术指令集合，一个设置条件码，另一个不设置。可以通常情况下生成不设置条件码的指令，并创建一个同时执行算术运算并设置条件码寄存器（这种情况下将不会是<code>(cc0)</code>）的指令模式。例如，搜一下<samp><span class="file">sparc.md</span></samp>中的&lsquo;<samp><span class="samp">addcc</span></samp>&rsquo;和&lsquo;<samp><span class="samp">andcc</span></samp>&rsquo;。

     <p><a name="index-pc-2398"></a><br><dt><code>(pc)</code><dd><a name="index-program-counter-2399"></a>表示机器的程序计数器。其没有操作数并可能没有机器模式。<code>(pc)</code>只在跳转指令的特定上下文中使用。

     <p><a name="index-pc_005frtx-2400"></a>只有一个代码为<code>pc</code>的表达式对象；其为变量<code>pc_rtx</code>的值。任何尝试创建一个代码为<code>pc</code>的表达式，将返回<code>pc_rtx</code>。

     <p>所有不进行跳转的指令会隐式的通过递增的方式改变程序计数器，但是不需要在RTL中提起这些。

     <p><a name="index-mem-2401"></a><br><dt><code>(mem:</code><var>m</var> <var>addr</var> <var>alias</var><code>)</code><dd>该RTX表示对表达式<var>addr</var>所表示的地址的主内存进行引用。<var>m</var>描述了被访问的内存的单元大小。<var>alias</var>描述了该引用的别名集合。总得来说，两个项如果不引用相同的内存地址，则在不同的别名集合里。

     <p>结构<code>(mem:BLK (scratch))</code>被认为是所有其它内存的别名。因此其可以在函数尾声的栈销毁中用作内存栅栏。

     <p><a name="index-concat-2402"></a><br><dt><code>(concat</code><var>m</var> <var>rtx</var> <var>rtx</var><code>)</code><dd>该RTX表示对两个其它RTX的连结。这用于复数值。其应该只出现在附加在声明中的RTL中，以及RTL生成中。不应该出现在普通的insn链上。

     <p><a name="index-concatn-2403"></a><br><dt><code>(concatn</code><var>m</var><code> [</code><var>rtx</var><code> ...])</code><dd>该RTX表示将所有的<var>rtx</var>进行连结，生成一个单个的值。类似<code>concat</code>，其应该只出现在声明中，不应该出现在insn链上。

 </dl>

 </body></html>

