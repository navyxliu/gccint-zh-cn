<html lang="zh">
<head>
<title>条件代码 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="Anchored_00e5_009c_00b0_00e5_009d_0080.html#Anchored_00e5_009c_00b0_00e5_009d_0080" title="Anchored地址">
<link rel="next" href="_00e4_00bb_00a3_00e4_00bb_00b7.html#g_t_00e4_00bb_00a3_00e4_00bb_00b7" title="代价">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%9d%a1%e4%bb%b6%e4%bb%a3%e7%a0%81"></a>
<a name="g_t_00e6_009d_00a1_00e4_00bb_00b6_00e4_00bb_00a3_00e7_00a0_0081"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e4_00bb_00a3_00e4_00bb_00b7.html#g_t_00e4_00bb_00a3_00e4_00bb_00b7">代价</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Anchored_00e5_009c_00b0_00e5_009d_0080.html#Anchored_00e5_009c_00b0_00e5_009d_0080">Anchored地址</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.16 条件代码状态</h3>

<p><a name="index-condition-code-status-4207"></a>
<!-- prevent bad page break with this line -->
这节描述了条件代码状态。

 <p><a name="index-cc_005fstatus-4208"></a>文件<samp><span class="file">conditions.h</span></samp>定义了变量<code>cc_status</code>，
用来描述条件代码如何被计算（对于条件代码的解释取决于设置它的指令的情况）。
该变量包含了条件码目前基于的RTL表达式，以及一些标准的标记。

 <p>有时额外的机器特定的标记必须被定义，在机器描述头文件中。
其还可以增加额外的机器特定信息，通过定义<code>CC_STATUS_MDEP</code>。

<div class="defun">
&mdash; Macro: <b>CC_STATUS_MDEP</b><var><a name="index-CC_005fSTATUS_005fMDEP-4209"></a></var><br>
<blockquote><p>一个数据类型的C代码，其用于声明<code>cc_status</code>的<code>mdep</code>部件。
缺省为<code>int</code>。

      <p>该宏在不使用<code>cc0</code>的机器上不被使用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CC_STATUS_MDEP_INIT</b><var><a name="index-CC_005fSTATUS_005fMDEP_005fINIT-4210"></a></var><br>
<blockquote><p>一个C表达式，用来初始化<code>mdep</code>域为“空”。缺省定义不做任何事，
因为大多数机器不使用该域。如果你想使用该域，则可能应该定义该宏来初始化它。

      <p>该宏在不使用<code>cc0</code>的机器上不被使用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NOTICE_UPDATE_CC</b> (<var>exp, insn</var>)<var><a name="index-NOTICE_005fUPDATE_005fCC-4211"></a></var><br>
<blockquote><p>一个C复合语句，用来适当的为主体为<var>exp</var>的<var>insn</var>，
设置<code>cc_status</code>的部件。
该宏负责识别insn将条件码设置作为副产品以及显示的set <code>(cc0)</code>。

      <p>该宏在不使用<code>cc0</code>的机器上不被使用。

      <p>如果insn不设置条件码，但修改其它机器寄存器，
则该宏必须检查它们是否使得记录条件码的表达式变为无效。例如，在68000上，
在地址寄存器上存储insn不设置条件码，
其意味着通常<code>NOTICE_UPDATE_CC</code>对于这样的insn可以不修改<code>cc_status</code>。
但是假设之前的insn将条件码设成基于位置&lsquo;<samp><span class="samp">a4@(102)</span></samp>&rsquo;，
并且当前insn在&lsquo;<samp><span class="samp">a4</span></samp>&rsquo;上存储了一个新值。虽然条件码没有被改变，
但其不再为真，因为其反映了&lsquo;<samp><span class="samp">a4@(102)</span></samp>&rsquo;的内容。因此对于这种情况，
<code>NOTICE_UPDATE_CC</code>必须修改<code>cc_status</code>，来表示条件码值不可知。

      <p><code>NOTICE_UPDATE_CC</code>的定义必须要准备处理窥孔优化的结果：
insn的指令模式为<code>parallel</code> RTXs，其包含了不同的<code>reg</code>，
<code>mem</code>或者常量操作数。这些insn的RTL结构体不足以表明insn实际要做的事情。
<code>NOTICE_UPDATE_CC</code>应该做的是当遇到这样的，就直接运行<code>CC_STATUS_INIT</code>。

      <p><code>NOTICE_UPDATE_CC</code>可能的定义为调用一个函数，
来查看一个属性（参见 <a href="Insn_00e5_00b1_009e_00e6_0080_00a7.html#Insn_00e5_00b1_009e_00e6_0080_00a7">Insn属性</a>），例如名为&lsquo;<samp><span class="samp">cc</span></samp>&rsquo;。这避免了在两个地方，
<samp><span class="file">md</span></samp>文件和<code>NOTICE_UPDATE_CC</code>中具有指令模式的详细信息。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SELECT_CC_MODE</b> (<var>op, x, y</var>)<var><a name="index-SELECT_005fCC_005fMODE-4212"></a></var><br>
<blockquote><p>当比较运算代码<var>op</var>应用到rtx <var>x</var>和<var>y</var>上时，
从<code>MODE_CC</code>类中返回一个机器模式。例如，在SPARC上，
<code>SELECT_CC_MODE</code>被定义为（该定义的描述，参见 <a href="_00e8_00b7_00b3_00e8_00bd_00ac_00e6_008c_0087_00e4_00bb_00a4_00e6_00a8_00a1_00e5_00bc_008f.html#g_t_00e8_00b7_00b3_00e8_00bd_00ac_00e6_008c_0087_00e4_00bb_00a4_00e6_00a8_00a1_00e5_00bc_008f">跳转指令模式</a>）

     <pre class="smallexample">          #define SELECT_CC_MODE(OP,X,Y) \
            (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT          \
             ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)    \
             : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS    \
                 || GET_CODE (X) == NEG) \
                ? CC_NOOVmode : CCmode))
</pre>
      <p>你应该定义该宏，当且仅当你在<samp><var>machine</var><span class="file">-modes.def</span></samp>中定义了额外的CC机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CANONICALIZE_COMPARISON</b> (<var>code, op0, op1</var>)<var><a name="index-CANONICALIZE_005fCOMPARISON-4213"></a></var><br>
<blockquote><p>在一些机器上，并不是所有可能的比较都被定义，
但你可以将一个无效的比较转换为一个有效的。例如，Alpha没有<code>GT</code>比较，
但你可以使用<code>LT</code>比较来替代，并且交换操作数的顺序。

      <p>在一些机器上，定义该宏为一条C语句来做任何需要的转换。
<var>code</var>为初始化比较代码，<var>op0</var>和<var>op1</var>为比较的左，右操作数。
你应该根据需要来修改<var>code</var>，<var>op0</var>和<var>op1</var>。

      <p>GCC将不假设该宏的比较结果为有效的，
但会查看结果insn是否匹配<samp><span class="file">md</span></samp>文件中的指令模式。

      <p>你不需要定义该宏，如果其不会改变比较代码或者操作数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REVERSIBLE_CC_MODE</b> (<var>mode</var>)<var><a name="index-REVERSIBLE_005fCC_005fMODE-4214"></a></var><br>
<blockquote><p>一个C表达式，其值为1，如果总是可以安全的将模式为<var>mode</var>的比较运算逆转。
如果<code>SELECT_CC_MODE</code>可以为浮点不等于比较返回<var>mode</var>，
则<code>REVERSIBLE_CC_MODE (</code><var>mode</var><code>)</code>必须为0。

      <p>你不需要定义该宏，如果其总是返回0，
或者如果浮点格式不是<code>IEEE_FLOAT_FORMAT</code>。
例如，这是在SPARC上的定义，其中浮点不等于比较总是为<code>CCFPEmode</code>：

     <pre class="smallexample">          #define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>REVERSE_CONDITION</b> (<var>code, mode</var>)<var><a name="index-REVERSE_005fCONDITION-4215"></a></var><br>
<blockquote><p>一个C表达式，其值为按照CC_MODE模式进行比较的条件码的逆转。
宏只用于<code>REVERSIBLE_CC_MODE (</code><var>mode</var><code>)</code>为非0的情况。
当机器具有某种非标准的方式来反转特定条件时，定义该宏。
例如，当所有浮点条件为非陷阱的，编译器可以自由的转换未排序的比较为排序的。
则定义可以为：

     <pre class="smallexample">          #define REVERSE_CONDITION(CODE, MODE) \
             ((MODE) != CCFPmode ? reverse_condition (CODE) \
              : reverse_condition_maybe_unordered (CODE))
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>REVERSE_CONDEXEC_PREDICATES_P</b> (<var>op1, op2</var>)<var><a name="index-REVERSE_005fCONDEXEC_005fPREDICATES_005fP-4216"></a></var><br>
<blockquote><p>C表达式，返回真，如果条件执行断言<var>op1</var>，一个比较操作，为<var>op2</var>的反转，
反之亦然。定义该宏返回0，如果target具有条件执行断言，且不能被安全的反转。
不需要验证参数op1和op2相等，这已经被单独执行过。如果没有指定，该宏被定义为：

     <pre class="smallexample">          #define REVERSE_CONDEXEC_PREDICATES_P (x, y) \
             (GET_CODE ((x)) == reversed_comparison_code ((y), NULL))
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_FIXED_CONDITION_CODE_REGS</b> (<var>unsigned int *, unsigned int *</var>)<var><a name="index-TARGET_005fFIXED_005fCONDITION_005fCODE_005fREGS-4217"></a></var><br>
<blockquote><p>对于一些target，其不使用<code>(cc0)</code>，而是使用硬件寄存器来存放条件码，
而不是伪寄存器，则正规的CSE过程通常不能识别硬件寄存器被设为一个普通值的情况。
使用该钩子来开启一个小的过程，来优化这种情况。该钩子应该返回真，来开启该过程，
并且应该将参数设置成指向用于条件码的硬件寄存器编号。当只有一个这样的寄存器时，
这在大多数系统上都为真，则第二个参数指向的整数应该被设为<code>INVALID_REGNUM</code>。

      <p>该钩子的缺省版本返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: enum <b>machine_mode</b><var> TARGET_CC_MODES_COMPATIBLE </var>(<var>enum machine_mode, enum machine_mode</var>)<var><a name="index-machine_005fmode-4218"></a></var><br>
<blockquote><p>对于一些target，其使用<code>MODE_CC</code>类别中的多个条件码机器模式，
有时比较可以对多个机器模式都有效。在这样的系统上，
定义该target钩子来接收两个mode参数并返回一个mode，
对于该模式两个比较都可以被有效执行。如果没有这样的模式，则返回<code>VOIDmode</code>。

      <p>该钩子的缺省版本检查模式是否相同。如果是，则返回该模式。如果不同，
则返回<code>VOIDmode</code>。
</p></blockquote></div>

 </body></html>

