<html lang="zh">
<head>
<title>消除 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link rel="prev" href="_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8.html#g_t_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8" title="帧寄存器">
<link rel="next" href="_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0.html#g_t_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0" title="栈参数">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%b6%88%e9%99%a4"></a>
<a name="g_t_00e6_00b6_0088_00e9_0099_00a4"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0.html#g_t_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0">栈参数</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8.html#g_t_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8">帧寄存器</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>
<hr>
</div>

<h4 class="subsection">17.10.5 消除帧指针和参数指针</h4>

<!-- prevent bad page break with this line -->
<p>这些是关于消除帧指针和参数指针的。

<div class="defun">
&mdash; Macro: <b>FRAME_POINTER_REQUIRED</b><var><a name="index-FRAME_005fPOINTER_005fREQUIRED-4018"></a></var><br>
<blockquote><p>一个C表达式，其为非0，如果函数必须具有并且使用帧指针。
该表达式在重载过程被求值。如果值为非零，则函数将具有一个帧指针。

      <p>原则上表达式可以检查当前函数并根据事实来决定，但在大多数机器上，
常量0或者1就足够了。使用0当机器允许生成的代码不具有帧指针，
这将节省一些时间或空间。使用1当避免帧指针不会带来好处。

      <p>在一些情况下，编译器不知道如何生成没有帧指针的有效的代码。
编译器识别到哪些情况，并自动的给函数一个帧指针，
而不管<code>FRAME_POINTER_REQUIRED</code>如何。你不需要为此担心。

      <p>在不需要帧指针的函数中，帧指针寄存器可以被分配用于普通用法，
除非你标记其为一个固定寄存器。更多信息，参见<code>FIXED_REGISTERS</code>。
</p></blockquote></div>

 <p><a name="index-get_005fframe_005fsize-4019"></a>

<div class="defun">
&mdash; Macro: <b>INITIAL_FRAME_POINTER_OFFSET</b> (<var>depth-var</var>)<var><a name="index-INITIAL_005fFRAME_005fPOINTER_005fOFFSET-4020"></a></var><br>
<blockquote><p>一条C语句，用来紧接着函数序言之后，
将帧指针和栈指针值的差存储在<var>depth-var</var>中。
该值应该通过像<code>get_frame_size ()</code>这样的结果信息以及寄存器表
<code>regs_ever_live</code>和<code>call_used_regs</code>中被计算。

      <p>如果<code>ELIMINABLE_REGS</code>被定义，则该宏将不被使用并不需要被定义。
否则，其必须被定义，即使<code>FRAME_POINTER_REQUIRED</code>被定义为总是为真；
这这种情况下，你可以设置<var>depth-var</var>为任何值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ELIMINABLE_REGS</b><var><a name="index-ELIMINABLE_005fREGS-4021"></a></var><br>
<blockquote><p>如果被定义，则该宏指定了一个寄存器双对的表，用于消除不需要的指向栈帧的寄存器。
如果没有被定义，则编译器唯一尝试去做的消除是将对帧指针的引用替换为对栈指针的引用。

      <p>该宏的定义为一个结构体初始化列表，每个指定了最初的和替换后的寄存器。

      <p>在一些机器上，参数指针的位置直到编译结束时才知道。这种情况下，
一个单独的硬件寄存器必须用于参数指针。
该寄存器可以通过替换为帧指针或者参数指针来消除，这取决于帧指针是否已经被消除。

      <p>这种情况下，你可能会指定：

     <pre class="smallexample">          #define ELIMINABLE_REGS  \
          {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
           {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
           {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
</pre>
      <p>注意首先指定的是使用栈指针来消除参数指针，因为这是首选的消除方式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CAN_ELIMINATE</b> (<var>from-reg, to-reg</var>)<var><a name="index-CAN_005fELIMINATE-4022"></a></var><br>
<blockquote><p>一个C表达式，其返回非0，
如果编译器被允许尝试使用寄存器编号<var>to-reg</var>来替换寄存器编号<var>from-reg</var>。
该宏只在<code>ELIMINABLE_REGS</code>被定义时才需要定义，并且通常为常量1，
因为大多数情况下编译器已经知道是否不该进行寄存器消除。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INITIAL_ELIMINATION_OFFSET</b> (<var>from-reg, to-reg, offset-var</var>)<var><a name="index-INITIAL_005fELIMINATION_005fOFFSET-4023"></a></var><br>
<blockquote><p>该宏类似于<code>INITIAL_FRAME_POINTER_OFFSET</code>。
其指定了被指定的寄存器双对的初始差。该宏必须被定义，
如果<code>ELIMINABLE_REGS</code>被定义。
</p></blockquote></div>

 </body></html>

