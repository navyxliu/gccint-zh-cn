<html lang="en">
<head>
<title>Looping Patterns - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Looping-Patterns"></a>

<hr>
</div>

<h3 class="section">16.13 Defining Looping Instruction Patterns</h3>

<p><a name="index-looping-instruction-patterns-3527"></a><a name="index-defining-looping-instruction-patterns-3528"></a>
Some machines have special jump instructions that can be utilized to
make loops more efficient.  A common example is the 68000 &lsquo;<samp><span class="samp">dbra</span></samp>&rsquo;
instruction which performs a decrement of a register and a branch if the
result was greater than zero.  Other machines, in particular digital
signal processors (DSPs), have special block repeat instructions to
provide low-overhead loop support.  For example, the TI TMS320C3x/C4x
DSPs have a block repeat instruction that loads special registers to
mark the top and end of a loop and to count the number of loop
iterations.  This avoids the need for fetching and executing a
&lsquo;<samp><span class="samp">dbra</span></samp>&rsquo;-like instruction and avoids pipeline stalls associated with
the jump.

 <p>GCC has three special named patterns to support low overhead looping. 
They are &lsquo;<samp><span class="samp">decrement_and_branch_until_zero</span></samp>&rsquo;, &lsquo;<samp><span class="samp">doloop_begin</span></samp>&rsquo;,
and &lsquo;<samp><span class="samp">doloop_end</span></samp>&rsquo;.  The first pattern,
&lsquo;<samp><span class="samp">decrement_and_branch_until_zero</span></samp>&rsquo;, is not emitted during RTL
generation but may be emitted during the instruction combination phase. 
This requires the assistance of the loop optimizer, using information
collected during strength reduction, to reverse a loop to count down to
zero.  Some targets also require the loop optimizer to add a
<code>REG_NONNEG</code> note to indicate that the iteration count is always
positive.  This is needed if the target performs a signed loop
termination test.  For example, the 68000 uses a pattern similar to the
following for its <code>dbra</code> instruction:

<pre class="smallexample">     (define_insn "decrement_and_branch_until_zero"
       [(set (pc)
             (if_then_else
               (ge (plus:SI (match_operand:SI 0 "general_operand" "+d*am")
                            (const_int -1))
                   (const_int 0))
               (label_ref (match_operand 1 "" ""))
               (pc)))
        (set (match_dup 0)
             (plus:SI (match_dup 0)
                      (const_int -1)))]
       "find_reg_note (insn, REG_NONNEG, 0)"
       "...")
</pre>
 <p>Note that since the insn is both a jump insn and has an output, it must
deal with its own reloads, hence the `m' constraints.  Also note that
since this insn is generated by the instruction combination phase
combining two sequential insns together into an implicit parallel insn,
the iteration counter needs to be biased by the same amount as the
decrement operation, in this case &minus;1.  Note that the following similar
pattern will not be matched by the combiner.

<pre class="smallexample">     (define_insn "decrement_and_branch_until_zero"
       [(set (pc)
             (if_then_else
               (ge (match_operand:SI 0 "general_operand" "+d*am")
                   (const_int 1))
               (label_ref (match_operand 1 "" ""))
               (pc)))
        (set (match_dup 0)
             (plus:SI (match_dup 0)
                      (const_int -1)))]
       "find_reg_note (insn, REG_NONNEG, 0)"
       "...")
</pre>
 <p>The other two special looping patterns, &lsquo;<samp><span class="samp">doloop_begin</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">doloop_end</span></samp>&rsquo;, are emitted by the loop optimizer for certain
well-behaved loops with a finite number of loop iterations using
information collected during strength reduction.

 <p>The &lsquo;<samp><span class="samp">doloop_end</span></samp>&rsquo; pattern describes the actual looping instruction
(or the implicit looping operation) and the &lsquo;<samp><span class="samp">doloop_begin</span></samp>&rsquo; pattern
is an optional companion pattern that can be used for initialization
needed for some low-overhead looping instructions.

 <p>Note that some machines require the actual looping instruction to be
emitted at the top of the loop (e.g., the TMS320C3x/C4x DSPs).  Emitting
the true RTL for a looping instruction at the top of the loop can cause
problems with flow analysis.  So instead, a dummy <code>doloop</code> insn is
emitted at the end of the loop.  The machine dependent reorg pass checks
for the presence of this <code>doloop</code> insn and then searches back to
the top of the loop, where it inserts the true looping insn (provided
there are no instructions in the loop which would cause problems).  Any
additional labels can be emitted at this point.  In addition, if the
desired special iteration counter register was not allocated, this
machine dependent reorg pass could emit a traditional compare and jump
instruction pair.

 <p>The essential difference between the
&lsquo;<samp><span class="samp">decrement_and_branch_until_zero</span></samp>&rsquo; and the &lsquo;<samp><span class="samp">doloop_end</span></samp>&rsquo;
patterns is that the loop optimizer allocates an additional pseudo
register for the latter as an iteration counter.  This pseudo register
cannot be used within the loop (i.e., general induction variables cannot
be derived from it), however, in many cases the loop induction variable
may become redundant and removed by the flow pass.

 </body></html>

