<html lang="zh">
<head>
<title>语法分析过程 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Passes.html#Passes" title="Passes">
<link rel="next" href="Gimplification_00e8_00bf_0087_00e7_00a8_008b.html#Gimplification_00e8_00bf_0087_00e7_00a8_008b" title="Gimplification过程">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%bf%87%e7%a8%8b"></a>
<a name="g_t_00e8_00af_00ad_00e6_00b3_0095_00e5_0088_0086_00e6_009e_0090_00e8_00bf_0087_00e7_00a8_008b"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Gimplification_00e8_00bf_0087_00e7_00a8_008b.html#Gimplification_00e8_00bf_0087_00e7_00a8_008b">Gimplification过程</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Passes.html#Passes">Passes</a>
<hr>
</div>

<h3 class="section">8.1 语法分析过程</h3>

<p><a name="index-GENERIC-1667"></a><a name="index-lang_005fhooks_002eparse_005ffile-1668"></a>语言前端只被调用一次，通过<code>lang_hooks.parse_file</code>，
用来解析整个输入。语言前端可以使用任何被认为合适的中间语言表示。
C前端使用了GENERIC树，以及在<samp><span class="file">c-common.def</span></samp>中定义的
（double handful of）语言特定的树代码。
Fortran前端使用了完全不同的私有表示。

 <p><a name="index-GIMPLE-1669"></a><a name="index-gimplification-1670"></a><a name="index-gimplifier-1671"></a><a name="index-language_002dindependent-intermediate-representation-1672"></a><a name="index-intermediate-representation-lowering-1673"></a><a name="index-lowering_002c-language_002ddependent-intermediate-representation-1674"></a>在某个地方，
前端必须将其使用的表示转换为编译器中语言独立的部分能够理解的表示。
目前的实现采用了两种形式。C前端在函数编译完之前，
手动的对每个函数调用gimplifier，
并且使用gimplifier回调函数将语言特定的树代码直接转换为GIMPLE。
Fortran前端将私有表示转换为 GENERIC，之后当函数编译完时，
再降低为GIMPLE。选择哪种途径可能取决于GENERIC（及其扩展）
是否能够很好的匹配源语言，以及是否需要解析数据结构。

 <p>BUG：Gimplification必须在nested function lowering之前进行，
并且nested function lowering必须在将数据传给cgraph之前，由前端完成。

 <p>TODO：Cgraph应该控制nested function lowering。并且只会在确定最外层函数被使用时才调用。

 <p>TODO：Cgraph需要一个gimplify_function回调函数。
并且在下列情况下会被调用：(1)确定函数被使用，
(2)为了兑现用户指定的警告选项，需要多次的编译，
(3)语言本身表明了在gimplification进行前，语义分析会不完整。
嗯。。。听起来有点过度复杂。或许我们应该总是进行前端的gimplify；
大多数情况，这只是一个函数调用。

 <p>前端需要将所有函数的定义和顶层的声明传给中端，
以至于它们能被编译和生成目标文件。对于一个简单的程序语言，
顶层的每个声明和定义都能找到，因此这样做非常方便。
另外，对于生成函数代码和生成完全的调试信息，也有差别。
对于函数代码，唯一必须的是将函数和数据定义传给中端。
对于完全的调试信息，函数，数据和类型的声明也都需要被传递。

 <p><a name="index-rest_005fof_005fdecl_005fcompilation-1675"></a><a name="index-rest_005fof_005ftype_005fcompilation-1676"></a><a name="index-cgraph_005ffinalize_005ffunction-1677"></a>任何情况下，如果前端需要每个完全的顶层函数或数据声明，
则每个数据定义应该传给<code>rest_of_decl_compilation</code>。
每个完全的类型定义应该传给<code>rest_of_type_compilation</code>。
每个函数定义应给传给<code>cgraph_finalize_function</code>。

 <p>中端根据自己的选择，将会立即生成函数和数据的定义，
或者放入队列中以便后面的处理。

 </body></html>

