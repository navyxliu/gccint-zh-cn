<html lang="zh">
<head>
<title>元组表示 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="GIMPLE.html#GIMPLE" title="GIMPLE">
<link rel="next" href="GIMPLE_00e6_008c_0087_00e4_00bb_00a4_00e9_009b_0086.html#GIMPLE_00e6_008c_0087_00e4_00bb_00a4_00e9_009b_0086" title="GIMPLE指令集">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%85%83%e7%bb%84%e8%a1%a8%e7%a4%ba"></a>
<a name="g_t_00e5_0085_0083_00e7_00bb_0084_00e8_00a1_00a8_00e7_00a4_00ba"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="GIMPLE_00e6_008c_0087_00e4_00bb_00a4_00e9_009b_0086.html#GIMPLE_00e6_008c_0087_00e4_00bb_00a4_00e9_009b_0086">GIMPLE指令集</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="GIMPLE.html#GIMPLE">GIMPLE</a>
<hr>
</div>

<h3 class="section">12.1 元组表示</h3>

<p><a name="index-tuples-2675"></a>
GIMPLE指令为可变大小的元组，并由两部分组成：一个描述指令和位置的头，一个具有所有操作数的可变长度的身体。元组被组织成一个层次结构，并有3个主要类别。

<h4 class="subsection">12.1.1 <code>gimple_statement_base</code> (gsbase)</h4>

<p><a name="index-gimple_005fstatement_005fbase-2676"></a>
这是层次结构的根，其存放了大多GIMPLE语句所需要的基本信息。有一些域并不与所有的GIMPLE语句相关，但是被挪到基础结构中是为了利用其它域剩下的空位（从而使得结构体更加紧凑）。结构体在64位主机上占用4个字（32个字节 ）：

 <p><table summary=""><tr align="left"><td valign="top">Field				</td><td valign="top">Size (bits)
<br></td></tr><tr align="left"><td valign="top"><code>code</code>			</td><td valign="top">8
<br></td></tr><tr align="left"><td valign="top"><code>subcode</code>			</td><td valign="top">16
<br></td></tr><tr align="left"><td valign="top"><code>no_warning</code>			</td><td valign="top">1
<br></td></tr><tr align="left"><td valign="top"><code>visited</code>			</td><td valign="top">1
<br></td></tr><tr align="left"><td valign="top"><code>nontemporal_move</code>		</td><td valign="top">1
<br></td></tr><tr align="left"><td valign="top"><code>plf</code>			</td><td valign="top">2
<br></td></tr><tr align="left"><td valign="top"><code>modified</code>			</td><td valign="top">1
<br></td></tr><tr align="left"><td valign="top"><code>has_volatile_ops</code>		</td><td valign="top">1
<br></td></tr><tr align="left"><td valign="top"><code>references_memory_p</code>	</td><td valign="top">1
<br></td></tr><tr align="left"><td valign="top"><code>uid</code>			</td><td valign="top">32
<br></td></tr><tr align="left"><td valign="top"><code>location</code>			</td><td valign="top">32
<br></td></tr><tr align="left"><td valign="top"><code>num_ops</code>			</td><td valign="top">32
<br></td></tr><tr align="left"><td valign="top"><code>bb</code>				</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>block</code>			</td><td valign="top">63
<br></td></tr><tr align="left"><td valign="top">Total size			</td><td valign="top">32 bytes
 <br></td></tr></table>

     <ul>
<li><code>code</code>
GIMPLE指令的主要标识

     <li><code>subcode</code>
用来区分相同基本指令的不同变体，或者提供使用于给定代码的标记。<code>subcode</code>标记域具有不同的用法，并取决于指令的代码，但是其主要是用来区分相同家族的指令。该域最突出的用法是在赋值中，其子代码指出了在赋值的右手边所进行的操作。例如，a = b + c被编码为<code>GIMPLE_ASSIGN &lt;PLUS_EXPR, a, b, c&gt;</code>。

     <li><code>no_warning</code>
位标记，用来指出是否在该语句上已经产生了一个警告。

     <li><code>visited</code>
通用目的的“访问”标记 。由每个编译过程根据需要来设置和清除。

     <li><code>nontemporal_move</code>
位标记，用在赋值中，用来表示非临时的移动。虽然该位标记只用于赋值，但其被放到这里是为了利用先前域所剩下的空位。

     <li><code>plf</code>
编译过程局部标记。该2个位的掩码可以由任何编译过程用作通用的标记。编译过程负责相应的清除和设置这两个标记。

     <li><code>modified</code>
位标记，用来指出语句是否被修改。主要由操作数扫描器来使用，用来确定什么时候重新扫描一条语句的操作数。

     <li><code>has_volatile_ops</code>
位标记，用来指出语句是否包含被标记为volatile的操作数。

     <li><code>references_memory_p</code>
位标记，用来指出语句是否包含内存引用（即，其操作数为全局变量，或者指针解引用，或者任何必须在内存中的）。

     <li><code>uid</code>
为无符号整数，由想要为每条语句分配ID的编译过程使用。这些ID必须由每个编译过程来分配和使用。

     <li><code>location</code>
为一个<code>location_t</code>标识符，用来指定该语句的源代码位置。其从前端继承下来。

     <li><code>num_ops</code>
该语句具有的操作数个数。这描述了元组中嵌套的操作数向量的大小。只在一些元组中使用，但其声明在基础元组中是为了利用先前语所剩下的32位空位。

     <li><code>bb</code>
包含该语句的基本块。

     <li><code>block</code>
包含该语句的词法块。还用于调试信息的生成。

 </ul>

<h4 class="subsection">12.1.2 <code>gimple_statement_with_ops</code></h4>

<p><a name="index-gimple_005fstatement_005fwith_005fops-2677"></a>
该元组实际分成两部分：<code>gimple_statement_with_ops_base</code> 和 <code>gimple_statement_with_ops</code>。这是为了适应操作数向量的分配方法。操作数向量被定义为有1个元素的数组。所以，要分配动态数目的操作数，内存分配器(<code>gimple_alloc</code>)只是简单的分配足够的内存来存放结构体本身，以及在结构体尾部加上<code>N - 1</code>个操作数。例如，要为有3个操作数的元组分配空间，<code>gimple_alloc</code>预留了<code>sizeof (struct gimple_statement_with_ops) + 2 * sizeof (tree)</code>个字节。

 <p>另一方面，该元组中的一些域需要与<code>gimple_statement_with_memory_ops</code>元组共享。所以，这些公共域被放在<code>gimple_statement_with_ops_base</code>中，然后由其它两个元组来继承。

 <p><table summary=""><tr align="left"><td valign="top"><code>gsbase</code>		</td><td valign="top">256
<br></td></tr><tr align="left"><td valign="top"><code>addresses_taken</code>	</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>def_ops</code>		</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>use_ops</code>		</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>op</code>		</td><td valign="top"><code>num_ops</code> * 64
<br></td></tr><tr align="left"><td valign="top">Total size		</td><td valign="top">56 + 8 * <code>num_ops</code> bytes
 <br></td></tr></table>

     <ul>
<li><code>gsbase</code>
继承自<code>struct gimple_statement_base</code>。

     <li><code>addresses_taken</code>
位图，存放了所有<code>VAR_DECL</code>的UID，该语句使用了这些<code>VAR_DECL</code>的地址。例如，形式为<code>p = &amp;b</code>的语句将在该集合中具有符号<code>b</code>的UID。

     <li><code>def_ops</code>
指针数组，指向操作数数组，指出该包含语句写入的变量的所有插槽。该数组还用于立即使用链。注意，是可以不依赖该数组的，但是这种实现会很具有入侵性。

     <li><code>use_ops</code>
类似于<code>def_ops</code>，不过是针对语句读取的变量。

     <li><code>op</code>
具有<code>num_ops</code>插槽的tree数组。
</ul>

<h4 class="subsection">12.1.3 <code>gimple_statement_with_memory_ops</code></h4>

<p>该元组本质上等同于<code>gimple_statement_with_ops</code>，除了其包含4个额外的域，来存放与内存存储和加载相关的向量。类似于先前的情况，结构体被分成两部分，用来容纳操作数向量(<code>gimple_statement_with_memory_ops_base</code>和<code>gimple_statement_with_memory_ops</code>)。

 <p><table summary=""><tr align="left"><td valign="top">Field				</td><td valign="top">Size (bits)
<br></td></tr><tr align="left"><td valign="top"><code>gsbase</code>			</td><td valign="top">256
<br></td></tr><tr align="left"><td valign="top"><code>addresses_taken</code>		</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>def_ops</code>			</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>use_ops</code>			</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>vdef_ops</code>			</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>vuse_ops</code>			</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>stores</code>			</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>loads</code>			</td><td valign="top">64
<br></td></tr><tr align="left"><td valign="top"><code>op</code>				</td><td valign="top"><code>num_ops</code> * 64
<br></td></tr><tr align="left"><td valign="top">Total size			</td><td valign="top">88 + 8 * <code>num_ops</code> bytes
 <br></td></tr></table>

     <ul>
<li><code>vdef_ops</code>
类似于<code>def_ops</code>，不过用于<code>VDEF</code>操作符。这是该语句写入的内存符号的一个实体。这用于维护内存SSA use-def和def-def链。

     <li><code>vuse_ops</code>
类似于<code>use_ops</code>，不过用于<code>VUSE</code>操作数。这是该语句加载的内存符号的一个实体。这用于维护内存SSA use-def链。

     <li><code>stores</code>
位集合，该语句写入的符号的所有UID。这与<code>vdef_ops</code>不同之处是，所有被影响的符号都在该集合中被提到。如果开启了内存划分，则<code>vdef_ops</code>向量将指向内存划分。而且，该集合中不存放SSA信息。

     <li><code>loads</code>
类似于<code>stores</code>，不过用于内存加载。（注意，这里有一些冗余，应该可以通过移除这些集合来减少内存使用）。

 </ul>

 <p>所有其它元组按照这三个基本元组来定义。每个元组会增加一些域。gimple类型被定义成所有这些结构体的联合体（为了清晰，省略掉了<code>GTY</code>标记）：

<pre class="smallexample">     union gimple_statement_d
     {
       struct gimple_statement_base gsbase;
       struct gimple_statement_with_ops gsops;
       struct gimple_statement_with_memory_ops gsmem;
       struct gimple_statement_omp omp;
       struct gimple_statement_bind gimple_bind;
       struct gimple_statement_catch gimple_catch;
       struct gimple_statement_eh_filter gimple_eh_filter;
       struct gimple_statement_phi gimple_phi;
       struct gimple_statement_resx gimple_resx;
       struct gimple_statement_try gimple_try;
       struct gimple_statement_wce gimple_wce;
       struct gimple_statement_asm gimple_asm;
       struct gimple_statement_omp_critical gimple_omp_critical;
       struct gimple_statement_omp_for gimple_omp_for;
       struct gimple_statement_omp_parallel gimple_omp_parallel;
       struct gimple_statement_omp_task gimple_omp_task;
       struct gimple_statement_omp_sections gimple_omp_sections;
       struct gimple_statement_omp_single gimple_omp_single;
       struct gimple_statement_omp_continue gimple_omp_continue;
       struct gimple_statement_omp_atomic_load gimple_omp_atomic_load;
       struct gimple_statement_omp_atomic_store gimple_omp_atomic_store;
     };
</pre>
 </body></html>

