<html lang="zh">
<head>
<title>标准名字 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0" title="机器描述">
<link rel="prev" href="Constraints.html#Constraints" title="Constraints">
<link rel="next" href="_00e6_008c_0087_00e4_00bb_00a4_00e6_00a8_00a1_00e5_00bc_008f_00e9_00a1_00ba_00e5_00ba_008f.html#g_t_00e6_008c_0087_00e4_00bb_00a4_00e6_00a8_00a1_00e5_00bc_008f_00e9_00a1_00ba_00e5_00ba_008f" title="指令模式顺序">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%a0%87%e5%87%86%e5%90%8d%e5%ad%97"></a>
<a name="g_t_00e6_00a0_0087_00e5_0087_0086_00e5_0090_008d_00e5_00ad_0097"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_008c_0087_00e4_00bb_00a4_00e6_00a8_00a1_00e5_00bc_008f_00e9_00a1_00ba_00e5_00ba_008f.html#g_t_00e6_008c_0087_00e4_00bb_00a4_00e6_00a8_00a1_00e5_00bc_008f_00e9_00a1_00ba_00e5_00ba_008f">指令模式顺序</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Constraints.html#Constraints">Constraints</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0">机器描述</a>
<hr>
</div>

<h3 class="section">16.9 用于生成的标准指令模式名</h3>

<p><a name="index-standard-pattern-names-3286"></a><a name="index-pattern-names-3287"></a><a name="index-names_002c-pattern-3288"></a>
这里有一个在编译器的RTL生成过程中有意义的指令名称表，在指令模式中给定这些名字中的一个，则告诉RTL生成过程，其可以使用该指令模式来完成一个特定的任务。

     
<a name="index-g_t_0040code_007bmov_0040var_007bm_007d_007d-instruction-pattern-3289"></a>
<dl><dt>&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;<dd>这里<var>m</var>表示一个两字母的机器模式名字，小写。该指令模式将那种机器模式的数据从操作数1移送到操作数0。例如&lsquo;<samp><span class="samp">movsi</span></samp>&rsquo;移送整字数据。

     <p>如果操作数0为一个寄存器的<code>subreg</code>，机器模式为<var>m</var>，寄存器自己的机器模式比<var>m</var>更宽，则该指令的效果是将指定的值存储在寄存器的对应于机器模式<var>m</var>的部分。<var>m</var>之外，且与<code>subreg</code>在同一个目标字中的位，为未定义。目标字以外的位保持不变。

     <p>这类指令模式有几处特别的地方。首先，每个这些直到整字大小的名字，包括整字大小的，必须被定义，因为没有其它方式来从一个地方将数据复制到另一个地方。如果有接受更大机器模式的操作数的指令模式，则必须为那些大小的整数机器模式定义&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;。

     <p>第二，这些指令模式不仅用在RTL生成过程。甚至重载过程可以生成move insn将值从栈槽复制到临时寄存器中。当这样的时候，其中一个操作数为硬件寄存器，另一个为需要被重载到寄存器中的操作数。

     <p><a name="index-force_005freg-3290"></a>因此，当给定这样一对操作数时，指令模式必须生成不需要重载，并且不需要临时寄存器的RTL。例如，如果你使用一个<code>define_expand</code>来支持该指令模式，则这种情况下，<code>define_expand</code>一定不能调用<code>force_reg</code>或者任何其它可能生成新的伪寄存器的函数。

     <p>甚至对于在RISC机器上的子字机器模式，从内存中获取这些机器模式通常需要多个insn和一些临时变量，该要求也存在。

     <p><a name="index-change_005faddress-3291"></a>重载过程中，具有无效地址的内存引用可以被作为操作数。这样的地址将在重载过程的后面被替换成有效地址。这种情况下，可能对地址没有做任何事情，而只是使用它。如果其被复制，则将无法使用有效的地址进行替换。不要尝试将这样的地址变成有效的地址。注意，<code>general_operand</code>当应用到这样的地址的时候将会失败。

     <p><a name="index-reload_005fin_005fprogress-3292"></a>全局变量<code>reload_in_progress</code>（其必须被显式的声明）可以用来确定是否需要这样的特殊的处理。

     <p>需要进行重载的操作数的种类取决于机器描述的其余部分，不过通常在RISC机器上，只有那些没有获得硬件寄存器的伪寄存器，而在其它机器上，显式的内存引用也有可能需要进行重载。

     <p>如果一个scratch寄存器，被需要用来将一个对象与内存之间进行移送，则其可以活跃分析之前，使用<code>gen_reg_rtx</code>来进行分配。

     <p>如果在重载过程中，或者之后，有需要scratch寄存器的情况，则你必须提供一个适当的secondary_reload目标钩子。

     <p><a name="index-can_005fcreate_005fpseudo_005fp-3293"></a>宏<code>can_create_pseudo_p</code>可以用来确定创建一个新的伪寄存器是否不安全。如果该变量为非零，则调用<code>gen_reg_rtx</code>来分配一个新的伪寄存器是不安全的。

     <p>&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;上的约束必须允许将任何硬件寄存器移送到任何其它硬件寄存器上，假设<code>HARD_REGNO_MODE_OK</code>在两个寄存器上都允许机器模式<var>m</var>，并且<code>REGISTER_MOVE_COST</code>应用到它们的类别上返回值2。

     <p>必须提供浮点&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;指令，用于任何可以存放定点值的寄存器，因为联合体和结构体（具有机器模式<code>SImode</code>或<code>DImode</code>）可以在那些寄存器中，并且它们可以具有浮点成员。

     <p>还需要支持定点&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;指令，用于浮点寄存器。不幸的是，我忘了为什么要这样，并且不知道这是否还是真的。如果<code>HARD_REGNO_MODE_OK</code>排斥在浮点寄存器中的定点值，则定点&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;指令的约束必须被设计成，避免尝试重载到一个浮点寄存器。

     <p><a name="index-g_t_0040code_007breload_005fin_007d-instruction-pattern-3294"></a><a name="index-g_t_0040code_007breload_005fout_007d-instruction-pattern-3295"></a><br><dt>&lsquo;<samp><span class="samp">reload_in</span><var>m</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">reload_out</span><var>m</var></samp>&rsquo;<dd>这些命名指令模式已经被目标钩子<code>secondary_reload</code>废弃。

     <p>类似&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;，不过用于当需要使用scratch寄存器在操作数0和操作数1之间移送的时候。操作数2描述scratch寄存器。参见在see <a href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab">寄存器类别</a>中对<code>SECONDARY_RELOAD_CLASS</code>宏的讨论。

     <p>这些指令模式中的<code>match_operand</code>的形式，有一些特殊的限制。首先，只有重载操作数的断言才被检查，即<code>reload_in</code>检查操作数1，而不检查操作数0和2。第二，在约束中只能有一个可选项。第三，约束只能使用单个寄存器类别字母；后续的约束字母都被忽略。一个例外是，空的约束字符串匹配<code>ALL_REGS</code>寄存器类别。这可以减轻后端为这些指令模式定义<code>ALL_REGS</code>约束字母的负担。

     <p><a name="index-g_t_0040code_007bmovstrict_0040var_007bm_007d_007d-instruction-pattern-3296"></a><br><dt>&lsquo;<samp><span class="samp">movstrict</span><var>m</var></samp>&rsquo;<dd>类似&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;，只不过，如果操作数0为一个寄存器的机器模式为<var>m</var>的<code>subreg</code>，且寄存器的自然机器模式是较宽的，则&lsquo;<samp><span class="samp">movstrict</span><var>m</var></samp>&rsquo;指令保证不会修改属于机器模式<var>m</var>之外的寄存器的任何部分。

     <p><a name="index-g_t_0040code_007bmovmisalign_0040var_007bm_007d_007d-instruction-pattern-3297"></a><br><dt>&lsquo;<samp><span class="samp">movmisalign</span><var>m</var></samp>&rsquo;<dd>该move指令模式的变体，被设计为从没有与其机器模式自然对齐的内存地址中加载和存储值。对于存储，内存将在操作数0中；对于加载，内存将在操作数1中。其它操作数保证不为内存，所以容易判别是加载还是存储。

     <p>该指令模式用于向量化，当展开<code>MISALIGNED_INDIRECT_REF</code>表达式的时候。

     <p><a name="index-g_t_0040code_007bload_005fmultiple_007d-instruction-pattern-3298"></a><br><dt>&lsquo;<samp><span class="samp">load_multiple</span></samp>&rsquo;<dd>将多个连续的内存位置加载到连续的寄存器中。操作数0为连续寄存器中的第一个，操作数1为第一个内存位置，操作数2为一个常量：连续寄存器的数目。

     <p>只有当目标机器确实具有这样指令的时候才定义该指令模式；如果将内存加载到连续寄存器的最有效的方式，是每次加载一个，则 不用定义该指令模式。

     <p>在一些机器上，对于哪些连续寄存器可以存储到内存中，会有一些限制，例如特定的起始寄存器或者结尾寄存器的编号，或者一个有效范围。对于那些机器，使用<code>define_expand</code> (see <a href="_00e6_0089_00a9_00e5_00b1_0095_00e5_00ae_009a_00e4_00b9_0089.html#g_t_00e6_0089_00a9_00e5_00b1_0095_00e5_00ae_009a_00e4_00b9_0089">扩展定义</a>)，并当不符合限制的时候，将指令模式变成失败。

     <p>将生成的insn写成一个<code>parallel</code>，其元素为一个从适当内存位置到寄存器的<code>set</code>（可能还需要<code>use</code>或元素<code>clobber</code>）。使用<code>match_parallel</code> (see <a href="RTL_00e6_00a8_00a1_00e6_009d_00bf.html#RTL_00e6_00a8_00a1_00e6_009d_00bf">RTL模板</a>)来识别insn。关于使用该insn模式的例子，可以参见<samp><span class="file">rs6000.md</span></samp>。

     <p><a name="index-g_t_0040samp_007bstore_005fmultiple_007d-instruction-pattern-3299"></a><br><dt>&lsquo;<samp><span class="samp">store_multiple</span></samp>&rsquo;<dd>类似于&lsquo;<samp><span class="samp">load_multiple</span></samp>&rsquo;，不过是将多个连续的寄存器存储到连续的内存位置。操作数0为连续内存位置的第一个，操作数1为第一个寄存器，操作数2为常量：连续寄存器的数目。

     <p><a name="index-g_t_0040code_007bvec_005fset_0040var_007bm_007d_007d-instruction-pattern-3300"></a><br><dt>&lsquo;<samp><span class="samp">vec_set</span><var>m</var></samp>&rsquo;<dd>设置向量中给定的域。操作数0为要修改的向量，操作数1为域的新值，操作数2指定了域的索引。

     <p><a name="index-g_t_0040code_007bvec_005fextract_0040var_007bm_007d_007d-instruction-pattern-3301"></a><br><dt>&lsquo;<samp><span class="samp">vec_extract</span><var>m</var></samp>&rsquo;<dd>从向量中抽取给定的域。操作数1为向量，操作数2指定了域索引，操作数0为存放值的地方。

     <p><a name="index-g_t_0040code_007bvec_005fextract_005feven_0040var_007bm_007d_007d-instruction-pattern-3302"></a><br><dt>&lsquo;<samp><span class="samp">vec_extract_even</span><var>m</var></samp>&rsquo;<dd>从输入向量（操作数1和2）中，抽取偶数元素。操作数2的偶数元素按照它们原来的顺序，连结到操作数1的偶数元素后面。结果存储在操作数0中。输出和输入向量应该具有相同的模式。

     <p><a name="index-g_t_0040code_007bvec_005fextract_005fodd_0040var_007bm_007d_007d-instruction-pattern-3303"></a><br><dt>&lsquo;<samp><span class="samp">vec_extract_odd</span><var>m</var></samp>&rsquo;<dd>从输入向量（操作数1和2）中，抽取奇数元素。操作数2的奇数元素按照它们原来的顺序，连结到操作数1的奇数元素后面。结果存储在操作数0中。输出和输入向量应该具有相同的模式。

     <p><a name="index-g_t_0040code_007bvec_005finterleave_005fhigh_0040var_007bm_007d_007d-instruction-pattern-3304"></a><br><dt>&lsquo;<samp><span class="samp">vec_interleave_high</span><var>m</var></samp>&rsquo;<dd>将两个输入向量的高部分元素合并到输入向量中。输出和输入向量应该具有相同的模式(<code>N</code>个元素)。第一个输入向量的高<code>N/2</code>个元素被第二个输入向量的高<code>N/2</code>个元素交错的插入。

     <p><a name="index-g_t_0040code_007bvec_005finterleave_005flow_0040var_007bm_007d_007d-instruction-pattern-3305"></a><br><dt>&lsquo;<samp><span class="samp">vec_interleave_low</span><var>m</var></samp>&rsquo;<dd>将两个输入向量的低部分元素合并到输入向量中。输出和输入向量应该具有相同的模式(<code>N</code>个元素)。第一个输入向量的低<code>N/2</code>个元素被第二个输入向量的低<code>N/2</code>个元素交错的插入。

     <p><a name="index-g_t_0040code_007bvec_005finit_0040var_007bm_007d_007d-instruction-pattern-3306"></a><br><dt>&lsquo;<samp><span class="samp">vec_init</span><var>m</var></samp>&rsquo;<dd>将向量初始化为给定的值。操作数0为要初始化的向量，操作数1并行的包含每个域的值。

     <p><a name="index-g_t_0040code_007bpush_0040var_007bm_007d1_007d-instruction-pattern-3307"></a><br><dt>&lsquo;<samp><span class="samp">push</span><var>m</var><span class="samp">1</span></samp>&rsquo;<dd>输出一个push指令。操作数0是压栈的值。只有当<code>PUSH_ROUNDING</code>被定义时，才被使用。出于历史原因，该指令模式可以缺失，这种情况下使用<code>mov</code>扩展来替代，并用<code>MEM</code>表达式来形成压栈运算。<code>mov</code>扩展方法不被推荐。

     <p><a name="index-g_t_0040code_007badd_0040var_007bm_007d3_007d-instruction-pattern-3308"></a><br><dt>&lsquo;<samp><span class="samp">add</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>操作数2加上操作数1，将结果存储在操作数0中。所有操作数必须具有机器模式<var>m</var>。这也可以用于两地址机器上，通过约束来要求操作数1和0为相同的位置。

     <p><a name="index-g_t_0040code_007bssadd_0040var_007bm_007d3_007d-instruction-pattern-3309"></a><a name="index-g_t_0040code_007busadd_0040var_007bm_007d3_007d-instruction-pattern-3310"></a><a name="index-g_t_0040code_007bsub_0040var_007bm_007d3_007d-instruction-pattern-3311"></a><a name="index-g_t_0040code_007bsssub_0040var_007bm_007d3_007d-instruction-pattern-3312"></a><a name="index-g_t_0040code_007bussub_0040var_007bm_007d3_007d-instruction-pattern-3313"></a><a name="index-g_t_0040code_007bmul_0040var_007bm_007d3_007d-instruction-pattern-3314"></a><a name="index-g_t_0040code_007bssmul_0040var_007bm_007d3_007d-instruction-pattern-3315"></a><a name="index-g_t_0040code_007busmul_0040var_007bm_007d3_007d-instruction-pattern-3316"></a><a name="index-g_t_0040code_007bdiv_0040var_007bm_007d3_007d-instruction-pattern-3317"></a><a name="index-g_t_0040code_007bssdiv_0040var_007bm_007d3_007d-instruction-pattern-3318"></a><a name="index-g_t_0040code_007budiv_0040var_007bm_007d3_007d-instruction-pattern-3319"></a><a name="index-g_t_0040code_007busdiv_0040var_007bm_007d3_007d-instruction-pattern-3320"></a><a name="index-g_t_0040code_007bmod_0040var_007bm_007d3_007d-instruction-pattern-3321"></a><a name="index-g_t_0040code_007bumod_0040var_007bm_007d3_007d-instruction-pattern-3322"></a><a name="index-g_t_0040code_007bumin_0040var_007bm_007d3_007d-instruction-pattern-3323"></a><a name="index-g_t_0040code_007bumax_0040var_007bm_007d3_007d-instruction-pattern-3324"></a><a name="index-g_t_0040code_007band_0040var_007bm_007d3_007d-instruction-pattern-3325"></a><a name="index-g_t_0040code_007bior_0040var_007bm_007d3_007d-instruction-pattern-3326"></a><a name="index-g_t_0040code_007bxor_0040var_007bm_007d3_007d-instruction-pattern-3327"></a><br><dt>&lsquo;<samp><span class="samp">ssadd</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">usadd</span><var>m</var><span class="samp">3</span></samp>&rsquo;<br><dt>&lsquo;<samp><span class="samp">sub</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">sssub</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ussub</span><var>m</var><span class="samp">3</span></samp>&rsquo;<br><dt>&lsquo;<samp><span class="samp">mul</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ssmul</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">usmul</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">div</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ssdiv</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">udiv</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">usdiv</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">mod</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">umod</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">umin</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">umax</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">and</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ior</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">xor</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>类似的，用于其它算术运算。

     <p><a name="index-g_t_0040code_007bmin_0040var_007bm_007d3_007d-instruction-pattern-3328"></a><a name="index-g_t_0040code_007bmax_0040var_007bm_007d3_007d-instruction-pattern-3329"></a><br><dt>&lsquo;<samp><span class="samp">smin</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">smax</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>有符号的最小值和最大值运算。当用于浮点，如果两个操作数都为零，或者有一个为<code>NaN</code>，则没有明确指定哪个操作数作为结果返回。

     <p><a name="index-g_t_0040code_007breduc_005fsmin_005f_0040var_007bm_007d_007d-instruction-pattern-3330"></a><a name="index-g_t_0040code_007breduc_005fsmax_005f_0040var_007bm_007d_007d-instruction-pattern-3331"></a><br><dt>&lsquo;<samp><span class="samp">reduc_smin_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">reduc_smax_</span><var>m</var></samp>&rsquo;<dd>查找向量的有符号最小/最大元素。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

     <p><a name="index-g_t_0040code_007breduc_005fumin_005f_0040var_007bm_007d_007d-instruction-pattern-3332"></a><a name="index-g_t_0040code_007breduc_005fumax_005f_0040var_007bm_007d_007d-instruction-pattern-3333"></a><br><dt>&lsquo;<samp><span class="samp">reduc_umin_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">reduc_umax_</span><var>m</var></samp>&rsquo;<dd>查找向量的无符号最小/最大元素。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

     <p><a name="index-g_t_0040code_007breduc_005fsplus_005f_0040var_007bm_007d_007d-instruction-pattern-3334"></a><br><dt>&lsquo;<samp><span class="samp">reduc_splus_</span><var>m</var></samp>&rsquo;<dd>计算向量的有符号元素的和。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

     <p><a name="index-g_t_0040code_007breduc_005fuplus_005f_0040var_007bm_007d_007d-instruction-pattern-3335"></a><br><dt>&lsquo;<samp><span class="samp">reduc_uplus_</span><var>m</var></samp>&rsquo;<dd>计算向量的无符号元素的和。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

     <p><a name="index-g_t_0040code_007bsdot_005fprod_0040var_007bm_007d_007d-instruction-pattern-3336"></a><br><dt>&lsquo;<samp><span class="samp">sdot_prod</span><var>m</var></samp>&rsquo;<dd><a name="index-g_t_0040code_007budot_005fprod_0040var_007bm_007d_007d-instruction-pattern-3337"></a><br><dt>&lsquo;<samp><span class="samp">udot_prod</span><var>m</var></samp>&rsquo;<dd>计算两个有符号/无符号元素乘积的和。操作数1和2为相同的模式。它们的乘积，为一个宽的模式，被计算并增加到操作数3上。操作数3的机器模式等于或宽于乘积的机器模式。结果被放在操作数0上，其与操作数3具有相同的机器模式。

     <p><a name="index-g_t_0040code_007bssum_005fwiden_0040var_007bm3_007d_007d-instruction-pattern-3338"></a><br><dt>&lsquo;<samp><span class="samp">ssum_widen</span><var>m3</var></samp>&rsquo;<dd><a name="index-g_t_0040code_007busum_005fwiden_0040var_007bm3_007d_007d-instruction-pattern-3339"></a><br><dt>&lsquo;<samp><span class="samp">usum_widen</span><var>m3</var></samp>&rsquo;<dd>操作数0和2具有相同的机器模式，其比操作数1的宽。将操作数1加上操作数2，并将加宽的结果放在操作数0中。（这用于表示元素累加到一个更宽模式的累加器中）

     <p><a name="index-g_t_0040code_007bvec_005fshl_005f_0040var_007bm_007d_007d-instruction-pattern-3340"></a><a name="index-g_t_0040code_007bvec_005fshr_005f_0040var_007bm_007d_007d-instruction-pattern-3341"></a><br><dt>&lsquo;<samp><span class="samp">vec_shl_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_shr_</span><var>m</var></samp>&rsquo;<dd>整个向量向左/向右移位。操作数1为被移位的向量。操作数2为移位的位数。操作数0为移位后的结果向量被存储的地方。输出和输入向量应该具有相同的模式。

     <p><a name="index-g_t_0040code_007bvec_005fpack_005ftrunc_005f_0040var_007bm_007d_007d-instruction-pattern-3342"></a><br><dt>&lsquo;<samp><span class="samp">vec_pack_trunc_</span><var>m</var></samp>&rsquo;<dd>变窄（降级）并合并两个向量的元素。操作数1和2为具有相同机器模式，N个，大小为S的整数或者浮点元素的向量。操作数0为结果向量，通过使用截取的方式，将它们变窄并连接成，2×N个大小为N/2的元素。

     <p><a name="index-g_t_0040code_007bvec_005fpack_005fssat_005f_0040var_007bm_007d_007d-instruction-pattern-3343"></a><a name="index-g_t_0040code_007bvec_005fpack_005fusat_005f_0040var_007bm_007d_007d-instruction-pattern-3344"></a><br><dt>&lsquo;<samp><span class="samp">vec_pack_ssat_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_pack_usat_</span><var>m</var></samp>&rsquo;<dd>变窄（降级）并合并两个向量的元素。操作数1和2为具有相同机器模式，N个，大小为S的整数元素的向量。操作数0为结果向量，通过使用有符号/无符号饱和算术的方式，将它们变窄并连接成。

     <p><a name="index-g_t_0040code_007bvec_005fpack_005fsfix_005ftrunc_005f_0040var_007bm_007d_007d-instruction-pattern-3345"></a><a name="index-g_t_0040code_007bvec_005fpack_005fufix_005ftrunc_005f_0040var_007bm_007d_007d-instruction-pattern-3346"></a><br><dt>&lsquo;<samp><span class="samp">vec_pack_sfix_trunc_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_pack_ufix_trunc_</span><var>m</var></samp>&rsquo;<dd>将两个向量的元素变窄，转成有符号/无符号整数类型并合并。操作数1和2为具有相同机器模式，N个，大小为S的浮点元素的向量。操作数0为结果向量，由2×N个大小为N/2的元素连接而成。

     <p><a name="index-g_t_0040code_007bvec_005funpacks_005fhi_005f_0040var_007bm_007d_007d-instruction-pattern-3347"></a><a name="index-g_t_0040code_007bvec_005funpacks_005flo_005f_0040var_007bm_007d_007d-instruction-pattern-3348"></a><br><dt>&lsquo;<samp><span class="samp">vec_unpacks_hi_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_unpacks_lo_</span><var>m</var></samp>&rsquo;<dd>抽取并变宽（提升），具有有符号整数或浮点元素的，向量的高/低部分。输入向量（操作数1）具有N个大小为S的元素。使用有符号或者浮点扩展，将向量的高/低元素进行变宽（提升），并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

     <p><a name="index-g_t_0040code_007bvec_005funpacku_005fhi_005f_0040var_007bm_007d_007d-instruction-pattern-3349"></a><a name="index-g_t_0040code_007bvec_005funpacku_005flo_005f_0040var_007bm_007d_007d-instruction-pattern-3350"></a><br><dt>&lsquo;<samp><span class="samp">vec_unpacku_hi_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_unpacku_lo_</span><var>m</var></samp>&rsquo;<dd>抽取并变宽（提升），具有无符号整数元素的，向量的高/低部分。输入向量（操作数1）具有N个大小为S的元素。使用零扩展，将向量的高/低元素进行变宽（提升），并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

     <p><a name="index-g_t_0040code_007bvec_005funpacks_005ffloat_005fhi_005f_0040var_007bm_007d_007d-instruction-pattern-3351"></a><a name="index-g_t_0040code_007bvec_005funpacks_005ffloat_005flo_005f_0040var_007bm_007d_007d-instruction-pattern-3352"></a><a name="index-g_t_0040code_007bvec_005funpacku_005ffloat_005fhi_005f_0040var_007bm_007d_007d-instruction-pattern-3353"></a><a name="index-g_t_0040code_007bvec_005funpacku_005ffloat_005flo_005f_0040var_007bm_007d_007d-instruction-pattern-3354"></a><br><dt>&lsquo;<samp><span class="samp">vec_unpacks_float_hi_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_unpacks_float_lo_</span><var>m</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">vec_unpacku_float_hi_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_unpacku_float_lo_</span><var>m</var></samp>&rsquo;<dd>抽取具有有符号/无符号整数元素的，向量的高/低部分，并转换成浮点类型。输入向量（操作数1）具有N个大小为S的元素。使用浮点转换，将向量的高/低元素进行转换，并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

     <p><a name="index-g_t_0040code_007bvec_005fwiden_005fumult_005fhi_005f_0040var_007bm_007d_007d-instruction-pattern-3355"></a><a name="index-g_t_0040code_007bvec_005fwiden_005fumult_005flo_005f_005f_0040var_007bm_007d_007d-instruction-pattern-3356"></a><a name="index-g_t_0040code_007bvec_005fwiden_005fsmult_005fhi_005f_0040var_007bm_007d_007d-instruction-pattern-3357"></a><a name="index-g_t_0040code_007bvec_005fwiden_005fsmult_005flo_005f_0040var_007bm_007d_007d-instruction-pattern-3358"></a><br><dt>&lsquo;<samp><span class="samp">vec_widen_umult_hi_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_widen_umult_lo_</span><var>m</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">vec_widen_smult_hi_</span><var>m</var></samp>&rsquo;, &lsquo;<samp><span class="samp">vec_widen_smult_lo_</span><var>m</var></samp>&rsquo;<dd>有符号/无符号加宽乘法。两个输入（操作数1和2）为，N个大小为S的有符号/无符号元素的向量。将两个向量的高/低元素相乘，并将N/2个大小为2×S的乘积放在输出向量（操作数0）中。

     <p><a name="index-g_t_0040code_007bmulhisi3_007d-instruction-pattern-3359"></a><br><dt>&lsquo;<samp><span class="samp">mulhisi3</span></samp>&rsquo;<dd>机器模式为<code>HImode</code>的操作数1和2相乘，并将<code>SImode</code>乘积放在操作数0中。

     <p><a name="index-g_t_0040code_007bmulqihi3_007d-instruction-pattern-3360"></a><a name="index-g_t_0040code_007bmulsidi3_007d-instruction-pattern-3361"></a><br><dt>&lsquo;<samp><span class="samp">mulqihi3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">mulsidi3</span></samp>&rsquo;<dd>类似的其它宽度的加宽乘法指令。

     <p><a name="index-g_t_0040code_007bumulqihi3_007d-instruction-pattern-3362"></a><a name="index-g_t_0040code_007bumulhisi3_007d-instruction-pattern-3363"></a><a name="index-g_t_0040code_007bumulsidi3_007d-instruction-pattern-3364"></a><br><dt>&lsquo;<samp><span class="samp">umulqihi3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">umulhisi3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">umulsidi3</span></samp>&rsquo;<dd>类似的加宽乘法指令，进行无符号乘法。

     <p><a name="index-g_t_0040code_007busmulqihi3_007d-instruction-pattern-3365"></a><a name="index-g_t_0040code_007busmulhisi3_007d-instruction-pattern-3366"></a><a name="index-g_t_0040code_007busmulsidi3_007d-instruction-pattern-3367"></a><br><dt>&lsquo;<samp><span class="samp">usmulqihi3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">usmulhisi3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">usmulsidi3</span></samp>&rsquo;<dd>类似的加宽乘法指令，将第一个操作数解析为无符号的，第二个为有符号的，然后进行有符号乘法。

     <p><a name="index-g_t_0040code_007bsmul_0040var_007bm_007d3_005fhighpart_007d-instruction-pattern-3368"></a><br><dt>&lsquo;<samp><span class="samp">smul</span><var>m</var><span class="samp">3_highpart</span></samp>&rsquo;<dd>对机器模式为<var>m</var>的操作数1和2进行有符号乘法，并将乘积的最高有效的一半放在操作数0中。乘积的最低有效的一半被丢弃。

     <p><a name="index-g_t_0040code_007bumul_0040var_007bm_007d3_005fhighpart_007d-instruction-pattern-3369"></a><br><dt>&lsquo;<samp><span class="samp">umul</span><var>m</var><span class="samp">3_highpart</span></samp>&rsquo;<dd>类似的，只不过乘法是无符号的。

     <p><a name="index-g_t_0040code_007bmadd_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3370"></a><br><dt>&lsquo;<samp><span class="samp">madd</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>将操作数1和2进行相乘，有符号扩展成机器模式<var>n</var>，加上操作数3，并将结果存放在操作数0中。操作数1和2具有机器模式<var>m</var>，操作数0和3具有机器模式<var>n</var>。两种机器模式必须都为整数或者浮点模式，并且<var>n</var>必须为<var>m</var>的两倍大小。

     <p>换句话说，<code>madd</code><var>m</var><var>n</var><code>4</code>类似于<code>mul</code><var>m</var><var>n</var><code>3</code>，只不过其还加上操作数3。

     <p>这些指令不允许执行<code>FAIL</code>。

     <p><a name="index-g_t_0040code_007bumadd_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3371"></a><br><dt>&lsquo;<samp><span class="samp">umadd</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>类似<code>madd</code><var>m</var><var>n</var><code>4</code>，只不过零扩展乘法操作数，而不是有符号扩展它们。

     <p><a name="index-g_t_0040code_007bssmadd_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3372"></a><br><dt>&lsquo;<samp><span class="samp">ssmadd</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>类似<code>madd</code><var>m</var><var>n</var><code>4</code>，不过所有的运算都必须是有符号饱和的。

     <p><a name="index-g_t_0040code_007busmadd_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3373"></a><br><dt>&lsquo;<samp><span class="samp">usmadd</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>类似<code>umadd</code><var>m</var><var>n</var><code>4</code>，不过所有的运算都必须是无符号饱和的。

     <p><a name="index-g_t_0040code_007bmsub_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3374"></a><br><dt>&lsquo;<samp><span class="samp">msub</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>将操作数1和2相乘，有符号扩展为机器模式<var>n</var>，减去操作数3，并将结果存放在操作数0中。操作数1和2具有机器模式<var>m</var>，操作数0和3具有机器模式<var>n</var>。两种机器模式必须都为整数或者浮点模式，并且<var>n</var>必须为<var>m</var>的两倍大小。

     <p>换句话说，<code>msub</code><var>m</var><var>n</var><code>4</code>类似于<code>mul</code><var>m</var><var>n</var><code>3</code>，只不过其还减去操作数3。

     <p>这些指令不允许执行<code>FAIL</code>。

     <p><a name="index-g_t_0040code_007bumsub_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3375"></a><br><dt>&lsquo;<samp><span class="samp">umsub</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>类似<code>msub</code><var>m</var><var>n</var><code>4</code>，不过零扩展乘法操作数，而不是有符号扩展它们。

     <p><a name="index-g_t_0040code_007bssmsub_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3376"></a><br><dt>&lsquo;<samp><span class="samp">ssmsub</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>类似<code>msub</code><var>m</var><var>n</var><code>4</code>，不过所有的运算都必须是有符号饱和的。

     <p><a name="index-g_t_0040code_007busmsub_0040var_007bm_007d_0040var_007bn_007d4_007d-instruction-pattern-3377"></a><br><dt>&lsquo;<samp><span class="samp">usmsub</span><var>m</var><var>n</var><span class="samp">4</span></samp>&rsquo;<dd>类似<code>umsub</code><var>m</var><var>n</var><code>4</code>，不过所有的运算都必须是无符号饱和的。

     <p><a name="index-g_t_0040code_007bdivmod_0040var_007bm_007d4_007d-instruction-pattern-3378"></a><br><dt>&lsquo;<samp><span class="samp">divmod</span><var>m</var><span class="samp">4</span></samp>&rsquo;<dd>有符号除法，同时产生商和余数。操作数1被操作数2除，产生商存储在操作数0中，余数存储在操作数3中。

     <p>对于具有同时产生商和余数的指令的机器，提供&lsquo;<samp><span class="samp">divmod</span><var>m</var><span class="samp">4</span></samp>&rsquo;指令模式，但不要提供&lsquo;<samp><span class="samp">div</span><var>m</var><span class="samp">3</span></samp>&rsquo; 和 &lsquo;<samp><span class="samp">mod</span><var>m</var><span class="samp">3</span></samp>&rsquo;。这使得当商和余数都被计算的时候，可以优化成相对常见的情况。

     <p>如果存在只产生商或者余数的指令，并且比都产生的指令更有效，则将&lsquo;<samp><span class="samp">divmod</span><var>m</var><span class="samp">4</span></samp>&rsquo;的输出例程写成调用<code>find_reg_note</code>，查看商或者余数的<code>REG_UNUSED</code>注解，来产生适当的指令。

     <p><a name="index-g_t_0040code_007budivmod_0040var_007bm_007d4_007d-instruction-pattern-3379"></a><br><dt>&lsquo;<samp><span class="samp">udivmod</span><var>m</var><span class="samp">4</span></samp>&rsquo;<dd>类似的，不过进行无符号除法。

     <p><a name="shift-patterns"></a><a name="index-g_t_0040code_007bashl_0040var_007bm_007d3_007d-instruction-pattern-3380"></a><a name="index-g_t_0040code_007bssashl_0040var_007bm_007d3_007d-instruction-pattern-3381"></a><a name="index-g_t_0040code_007busashl_0040var_007bm_007d3_007d-instruction-pattern-3382"></a><br><dt>&lsquo;<samp><span class="samp">ashl</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ssashl</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">usashl</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>将操作数1向左算术移位，左移位数由操作数2指定，将结果存储在操作数0中。这里<var>m</var>为操作数0和1的机器模式；操作数2的机器模式通过指令模式来指定，编译器会在生成指令之前，将操作数转换成该模式。超出范围的移位数目的含义，可以通过<code>TARGET_SHIFT_TRUNCATION_MASK</code>来指定。See <a href="TARGET_005fSHIFT_005fTRUNCATION_005fMASK.html#TARGET_005fSHIFT_005fTRUNCATION_005fMASK">TARGET_SHIFT_TRUNCATION_MASK</a>。操作数2总是一个标量类型。

     <p><a name="index-g_t_0040code_007bashr_0040var_007bm_007d3_007d-instruction-pattern-3383"></a><a name="index-g_t_0040code_007blshr_0040var_007bm_007d3_007d-instruction-pattern-3384"></a><a name="index-g_t_0040code_007brotl_0040var_007bm_007d3_007d-instruction-pattern-3385"></a><a name="index-g_t_0040code_007brotr_0040var_007bm_007d3_007d-instruction-pattern-3386"></a><br><dt>&lsquo;<samp><span class="samp">ashr</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">lshr</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">rotl</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">rotr</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>其它移位或者旋转指令，类似于<code>ashl</code><var>m</var><code>3</code>指令。操作数2总是一个标量类型。

     <p><a name="index-g_t_0040code_007bvashl_0040var_007bm_007d3_007d-instruction-pattern-3387"></a><a name="index-g_t_0040code_007bvashr_0040var_007bm_007d3_007d-instruction-pattern-3388"></a><a name="index-g_t_0040code_007bvlshr_0040var_007bm_007d3_007d-instruction-pattern-3389"></a><a name="index-g_t_0040code_007bvrotl_0040var_007bm_007d3_007d-instruction-pattern-3390"></a><a name="index-g_t_0040code_007bvrotr_0040var_007bm_007d3_007d-instruction-pattern-3391"></a><br><dt>&lsquo;<samp><span class="samp">vashl</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">vashr</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">vlshr</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">vrotl</span><var>m</var><span class="samp">3</span></samp>&rsquo;, &lsquo;<samp><span class="samp">vrotr</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>向量移位和旋转指令，操作数2为向量，而不是标量类型。

     <p><a name="index-g_t_0040code_007bneg_0040var_007bm_007d2_007d-instruction-pattern-3392"></a><a name="index-g_t_0040code_007bssneg_0040var_007bm_007d2_007d-instruction-pattern-3393"></a><a name="index-g_t_0040code_007busneg_0040var_007bm_007d2_007d-instruction-pattern-3394"></a><br><dt>&lsquo;<samp><span class="samp">neg</span><var>m</var><span class="samp">2</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ssneg</span><var>m</var><span class="samp">2</span></samp>&rsquo;, &lsquo;<samp><span class="samp">usneg</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>对操作数1求负，并将结果存放在操作数0中。

     <p><a name="index-g_t_0040code_007babs_0040var_007bm_007d2_007d-instruction-pattern-3395"></a><br><dt>&lsquo;<samp><span class="samp">abs</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1的绝对值存放在操作数0中。

     <p><a name="index-g_t_0040code_007bsqrt_0040var_007bm_007d2_007d-instruction-pattern-3396"></a><br><dt>&lsquo;<samp><span class="samp">sqrt</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1的平方根存储在操作数0中。

     <p><code>sqrt</code>内建C函数，总是使用对应于C数据类型<code>double</code>的机器模式，<code>sqrtf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bfmod_0040var_007bm_007d3_007d-instruction-pattern-3397"></a><br><dt>&lsquo;<samp><span class="samp">fmod</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>将操作数1除以操作数2的余数，存储在操作数0中，并向零方向舍入为整数。

     <p><code>fmod</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>fmodf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bremainder_0040var_007bm_007d3_007d-instruction-pattern-3398"></a><br><dt>&lsquo;<samp><span class="samp">remainder</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>将操作数1除以操作数2的余数，存储在操作数0中，并舍入为最接近的整数。

     <p><code>remainder</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>remainderf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bcos_0040var_007bm_007d2_007d-instruction-pattern-3399"></a><br><dt>&lsquo;<samp><span class="samp">cos</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1的余弦存放在操作数0中。

     <p><code>cos</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>cosf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bsin_0040var_007bm_007d2_007d-instruction-pattern-3400"></a><br><dt>&lsquo;<samp><span class="samp">sin</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1的正弦存放在操作数0中。

     <p><code>sin</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>sinf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bexp_0040var_007bm_007d2_007d-instruction-pattern-3401"></a><br><dt>&lsquo;<samp><span class="samp">exp</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1的幂存放在操作数0中。

     <p><code>exp</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>expf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007blog_0040var_007bm_007d2_007d-instruction-pattern-3402"></a><br><dt>&lsquo;<samp><span class="samp">log</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1的自然对数存放在操作数0中。

     <p><code>log</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>logf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bpow_0040var_007bm_007d3_007d-instruction-pattern-3403"></a><br><dt>&lsquo;<samp><span class="samp">pow</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>将操作数1的，指数为操作数2的幂值存放在操作数0中

     <p><code>pow</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>powf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007batan2_0040var_007bm_007d3_007d-instruction-pattern-3404"></a><br><dt>&lsquo;<samp><span class="samp">atan2</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>将操作数1除以操作数2的反正切，存放在操作数0中，使用两个参数的正负符号来确定结果的商。

     <p><code>atan2</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>atan2f</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bfloor_0040var_007bm_007d2_007d-instruction-pattern-3405"></a><br><dt>&lsquo;<samp><span class="samp">floor</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>存储不大于参数的最大整数值。

     <p><code>floor</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>floorf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bbtrunc_0040var_007bm_007d2_007d-instruction-pattern-3406"></a><br><dt>&lsquo;<samp><span class="samp">btrunc</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>存储将参数向零方向舍入的整数。

     <p><code>trunc</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>truncf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bround_0040var_007bm_007d2_007d-instruction-pattern-3407"></a><br><dt>&lsquo;<samp><span class="samp">round</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>存储将参数向远离零的方向舍入的整数。

     <p><code>round</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>roundf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bceil_0040var_007bm_007d2_007d-instruction-pattern-3408"></a><br><dt>&lsquo;<samp><span class="samp">ceil</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>存储将参数向远离零的方向舍入的整数。

     <p><code>ceil</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>ceilf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bnearbyint_0040var_007bm_007d2_007d-instruction-pattern-3409"></a><br><dt>&lsquo;<samp><span class="samp">nearbyint</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将参数根据缺省的舍入模式，舍入为整数。

     <p><code>nearbyint</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>nearbyintf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007brint_0040var_007bm_007d2_007d-instruction-pattern-3410"></a><br><dt>&lsquo;<samp><span class="samp">rint</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将参数根据缺省的舍入模式，舍入为整数，并且当结果与参数的值不同的时候，抛出不精确异常。

     <p><code>rint</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>rintf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007blrint_0040var_007bm_007d_0040var_007bn_007d2_007d-3411"></a><br><dt>&lsquo;<samp><span class="samp">lrint</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对于浮点模式<var>m</var>有效）转换成定点机器模式<var>n</var>，作为有符号数，根据当前的舍入模式，并存储在操作数0（具有机器模式<var>n</var>）中。

     <p><a name="index-g_t_0040code_007blround_0040var_007bm_007d_0040var_007bn_007d2_007d-3412"></a><br><dt>&lsquo;<samp><span class="samp">lround</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对于浮点模式<var>m</var>有效）转换成定点机器模式<var>n</var>，舍入到最近的，远离零方向的有符号数，并存储在操作数0（具有机器模式<var>n</var>）中。

     <p><a name="index-g_t_0040code_007blfloor_0040var_007bm_007d_0040var_007bn_007d2_007d-3413"></a><br><dt>&lsquo;<samp><span class="samp">lfloor</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对于浮点模式<var>m</var>有效）转换成定点机器模式<var>n</var>，向下舍入成有符号数，并存储在操作数0（具有机器模式<var>n</var>）中。

     <p><a name="index-g_t_0040code_007blceil_0040var_007bm_007d_0040var_007bn_007d2_007d-3414"></a><br><dt>&lsquo;<samp><span class="samp">lceil</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对于浮点模式<var>m</var>有效）转换成定点机器模式<var>n</var>，向上舍入成有符号数，并存储在操作数0（具有机器模式<var>n</var>）中。

     <p><a name="index-g_t_0040code_007bcopysign_0040var_007bm_007d3_007d-instruction-pattern-3415"></a><br><dt>&lsquo;<samp><span class="samp">copysign</span><var>m</var><span class="samp">3</span></samp>&rsquo;<dd>将操作数1的数量级和操作数的符号组成的值，存放在操作数0中。

     <p><code>copysign</code>内建C函数总是使用对应于C数据类型<code>double</code>的机器模式，<code>copysignf</code>内建函数使用对应于C数据类型<code>float</code>的机器模式。

     <p><a name="index-g_t_0040code_007bffs_0040var_007bm_007d2_007d-instruction-pattern-3416"></a><br><dt>&lsquo;<samp><span class="samp">ffs</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1的最小有效，置1的位的索引，加上1，存放在操作数0中。如果操作数1为零，则存储零。<var>m</var>为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

     <p><code>ffs</code>内建C函数总是使用对应于C数据类型<code>int</code>的机器模式。

     <p><a name="index-g_t_0040code_007bclz_0040var_007bm_007d2_007d-instruction-pattern-3417"></a><br><dt>&lsquo;<samp><span class="samp">clz</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将<var>x</var>中，从最高有效位开始，起始处置0的位的数目，存放在操作数0中。如果<var>x</var>为0，则<code>CLZ_DEFINED_VALUE_AT_ZERO</code> (see <a href="Misc.html#Misc">Misc</a>)宏定义了结果是否为未定义或者一个有用的值。<var>m</var>为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

     <p><a name="index-g_t_0040code_007bctz_0040var_007bm_007d2_007d-instruction-pattern-3418"></a><br><dt>&lsquo;<samp><span class="samp">ctz</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将<var>x</var>中，从最小有效位开始，结尾处置0的位的数目，存放在操作数0中。如果<var>x</var>为0，则<code>CTZ_DEFINED_VALUE_AT_ZERO</code> (see <a href="Misc.html#Misc">Misc</a>)宏定义了结果是否为未定义或者一个有用的值。<var>m</var>为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

     <p><a name="index-g_t_0040code_007bpopcount_0040var_007bm_007d2_007d-instruction-pattern-3419"></a><br><dt>&lsquo;<samp><span class="samp">popcount</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将<var>x</var>中置1的位的数目，存放在操作数0中。<var>m</var>为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

     <p><a name="index-g_t_0040code_007bparity_0040var_007bm_007d2_007d-instruction-pattern-3420"></a><br><dt>&lsquo;<samp><span class="samp">parity</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将<var>x</var>的奇偶校验存放在操作数0中，即：<var>x</var>中置1的位数对2求模。<var>m</var>为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

     <p><a name="index-g_t_0040code_007bone_005fcmpl_0040var_007bm_007d2_007d-instruction-pattern-3421"></a><br><dt>&lsquo;<samp><span class="samp">one_cmpl</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>对操作数1进行按位求补，并存放在操作数0中。

     <p><a name="index-g_t_0040code_007bcmp_0040var_007bm_007d_007d-instruction-pattern-3422"></a><br><dt>&lsquo;<samp><span class="samp">cmp</span><var>m</var></samp>&rsquo;<dd>比较操作数0和1，并设置条件代码。RTL指令模式应该像这样：

     <pre class="smallexample">          (set (cc0) (compare (match_operand:<var>m</var> 0 ...)
                              (match_operand:<var>m</var> 1 ...)))
</pre>
     <p><a name="index-g_t_0040code_007btst_0040var_007bm_007d_007d-instruction-pattern-3423"></a><br><dt>&lsquo;<samp><span class="samp">tst</span><var>m</var></samp>&rsquo;<dd>将操作数0与零进行比较，并设置条件码。RTL指令模式应该像这样：

     <pre class="smallexample">          (set (cc0) (match_operand:<var>m</var> 0 ...))
</pre>
     <p>&lsquo;<samp><span class="samp">tst</span><var>m</var></samp>&rsquo;指令模式不应该为不使用<code>(cc0)</code>的机器定义。这样做会使得编译器变得迷惑，因为其将会不清楚哪一个<code>set</code>操作为比较。应该使用&lsquo;<samp><span class="samp">cmp</span><var>m</var></samp>&rsquo;。

     <p><a name="index-g_t_0040code_007bmovmem_0040var_007bm_007d_007d-instruction-pattern-3424"></a><br><dt>&lsquo;<samp><span class="samp">movmem</span><var>m</var></samp>&rsquo;<dd>块移动指令。内存的目的块和源块为前两个操作数，都为地址是<code>Pmode</code>的<code>mem:BLK</code>。

     <p>要移动的字节数为第三个操作数，机器模式为<var>m</var>。通常，你会将<var>m</var>指定为<code>word_mode</code>。然而，如果你可以生成更好的代码，知道有效长度的范围比一整个字要小，则你应该提供一个指令模式，其机器模式对应于你可以更有效的处理的值的范围（例如，<code>QImode</code>对于范围0&ndash;127；注意我们回避了负数），并且一个使用<code>word_mode</code>的指令模式。

     <p>第四个操作数为已知的源和目的的共享对齐，形式为一个<code>const_int</code> rtx。因此，如果编译器知道源和目的都是字对齐的，则其可以为该操作数提供值4。

     <p>可选的操作数5和6，分别指定了期望的对齐方式和块的大小。期望的对齐方式不同于操作数4中的对齐方式，块并不要求所有的情况下都按照这样对齐。期望的对齐方式也是以字节为单位，类似于操作数4。期望的大小，当不知道的时候，被设置为<code>(const_int -1)</code>。

     <p>描述多个<code>movmem</code><var>m</var>指令模式，只有当对于更小的机器模式的指令模式，对操作数1，2，4具有更少限制的时候，才会获利。注意<code>movmem</code><var>m</var>中的机器模式<var>m</var>不对块中单独的被移动的数据单元的机器模式做任何限制。

     <p>这些指令模式不需要对源和目的可能重叠的情况，进行特殊的考虑。

     <p><a name="index-g_t_0040code_007bmovstr_007d-instruction-pattern-3425"></a><br><dt>&lsquo;<samp><span class="samp">movstr</span></samp>&rsquo;<dd>字符串复制指令，具有<code>stpcpy</code>的语义。操作数0为输出操作数，机器模式为<code>Pmode</code>。目的字符串和源字符串的地址为操作数1和2，都是地址为<code>Pmode</code>的<code>mem:BLK</code>。对该指令模式的执行，应该将地址存放在操作数0中，其中<code>NUL</code>终结符存放在目标字符串中。

     <p><a name="index-g_t_0040code_007bsetmem_0040var_007bm_007d_007d-instruction-pattern-3426"></a><br><dt>&lsquo;<samp><span class="samp">setmem</span><var>m</var></samp>&rsquo;<dd>块设置指令。目的字符串为第一个操作数，作为一个<code>mem:BLK</code>，其地址的机器模式为codePmode。被设置的字节的数目是第二个操作数，机器模式为<var>m</var>。用于初始化内存的值为第三个操作数。只支持清空内存的目标机应该拒绝任何不为常数0的值。关于对机器模式选择的讨论，参见&lsquo;<samp><span class="samp">movmem</span><var>m</var></samp>&rsquo;。

     <p>第四个操作数为目标的已知对齐方式，形式为<code>const_int</code> rtx。因此，如果编译器知道目的操作数是字对齐的，则其可以为该操作数提供值4。

     <p>可选的操作数5和6，分别指定了期望的对齐方式和块的大小。期望的对齐方式不同于操作数4中的对齐方式，块并不要求所有的情况下都按照这样对齐。期望的对齐方式也是以字节为单位，类似于操作数4。期望的大小，当不知道的时候，被设置为<code>(const_int -1)</code>。

     <p>对多个<code>setmem</code><var>m</var>的使用，类似于<code>movmem</code><var>m</var>

     <p><a name="index-g_t_0040code_007bcmpstrn_0040var_007bm_007d_007d-instruction-pattern-3427"></a><br><dt>&lsquo;<samp><span class="samp">cmpstrn</span><var>m</var></samp>&rsquo;<dd>字符串比较指令，有5个操作数。操作数0为输出，机器模式为<var>m</var>。剩下的4个操作数类似于&lsquo;<samp><span class="samp">movmem</span><var>m</var></samp>&rsquo;的操作数。两个指定的内存块按字节来进行比较，按照字典顺序，从每个字符串的起始处开始。指令不允许一次取多个字节，因为每个字符串都可能在第一个字节中终止，读取后面的字节可能会访问一个无效的页或者段，并产生一个缺失。该指令的效果是将值存放在操作数0中，其符号表示了比较的结果。

     <p><a name="index-g_t_0040code_007bcmpstr_0040var_007bm_007d_007d-instruction-pattern-3428"></a><br><dt>&lsquo;<samp><span class="samp">cmpstr</span><var>m</var></samp>&rsquo;<dd>字符串比较指令，不知道最大的长度。操作数0为输出，机器模式为<var>m</var>。第二个和第三个操作数为被比较的内存块；都是机器模式为<code>Pmode</code>的<code>mem:BLK</code>。

     <p>第四个操作数为源和目的的已知共享的对齐方式，形式为<code>const_int</code> rtx。因此，如果编译器知道源和目的都是字对齐的，则其可以为该操作数提供值4。

     <p>两个指定的内存块按字节来进行比较，按照字典顺序，从每个字符串的起始处开始。指令不允许一次取多个字节，因为每个字符串都可能在第一个字节中终止，读取后面的字节可能会访问一个无效的页或者段，并产生一个缺失。该指令的效果是将值存放在操作数0中，其符号表示了比较的结果。

     <p><a name="index-g_t_0040code_007bcmpmem_0040var_007bm_007d_007d-instruction-pattern-3429"></a><br><dt>&lsquo;<samp><span class="samp">cmpmem</span><var>m</var></samp>&rsquo;<dd>块比较指令，这5个操作数类似于&lsquo;<samp><span class="samp">cmpstr</span><var>m</var></samp>&rsquo;。两个指定的内存块按字节来进行比较，按照字典顺序，从每个字符串的起始处开始。不像&lsquo;<samp><span class="samp">cmpstr</span><var>m</var></samp>&rsquo;，该指令可以在两个内存块中取任意个字节。该指令的效果是将值存放在操作数0中，其符号表示了比较的结果。

     <p><a name="index-g_t_0040code_007bstrlen_0040var_007bm_007d_007d-instruction-pattern-3430"></a><br><dt>&lsquo;<samp><span class="samp">strlen</span><var>m</var></samp>&rsquo;<dd>计算字符串的长度，有3个操作数。操作数0为结果（机器模式为<var>m</var>），操作数1为一个<code>mem</code>，指出字符串的第一个字符，操作数2为要查找的字符（通常为零），操作数3为一个常量，描述了字符串起始处的已知对齐方式。

     <p><a name="index-g_t_0040code_007bfloat_0040var_007bmn_007d2_007d-instruction-pattern-3431"></a><br><dt>&lsquo;<samp><span class="samp">float</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将有符号整数，操作数1（对于定点机器模式<var>m</var>有效），转换成浮点机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。

     <p><a name="index-g_t_0040code_007bfloatuns_0040var_007bmn_007d2_007d-instruction-pattern-3432"></a><br><dt>&lsquo;<samp><span class="samp">floatuns</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将无符号整数，操作数1（对于定点机器模式<var>m</var>有效），转换成浮点机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。

     <p><a name="index-g_t_0040code_007bfix_0040var_007bmn_007d2_007d-instruction-pattern-3433"></a><br><dt>&lsquo;<samp><span class="samp">fix</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对于浮点机器模式<var>m</var>有效），转换成定点机器模式<var>n</var>，作为一个有符号数并存放在操作数0（机器模式为<var>n</var>）中。该指令的结果，只有当操作数1的值为整数时，才被定义。

     <p>如果机器描述定义了该指令模式，则其还需要定义<code>ftrunc</code>指令模式。

     <p><a name="index-g_t_0040code_007bfixuns_0040var_007bmn_007d2_007d-instruction-pattern-3434"></a><br><dt>&lsquo;<samp><span class="samp">fixuns</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对于浮点机器模式<var>m</var>有效），转换成定点机器模式<var>n</var>，作为一个无符号数并存放在操作数0（机器模式为<var>n</var>）中。该指令的结果，只有当操作数1的值为整数时，才被定义。

     <p><a name="index-g_t_0040code_007bftrunc_0040var_007bm_007d2_007d-instruction-pattern-3435"></a><br><dt>&lsquo;<samp><span class="samp">ftrunc</span><var>m</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对于浮点机器模式<var>m</var>有效），转换成整数值，仍按照浮点机器模式<var>m</var>来表示，并存放在操作数0（对于浮点机器模式<var>m</var>有效）中。

     <p><a name="index-g_t_0040code_007bfix_005ftrunc_0040var_007bmn_007d2_007d-instruction-pattern-3436"></a><br><dt>&lsquo;<samp><span class="samp">fix_trunc</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>类似于&lsquo;<samp><span class="samp">fix</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;，不过工作于，将任意机器模式为<var>m</var>的浮点值，转换成整数。

     <p><a name="index-g_t_0040code_007bfixuns_005ftrunc_0040var_007bmn_007d2_007d-instruction-pattern-3437"></a><br><dt>&lsquo;<samp><span class="samp">fixuns_trunc</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>类似&lsquo;<samp><span class="samp">fixuns</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;，不过工作于，将任意机器模式为<var>m</var>的浮点值，转换成整数。

     <p><a name="index-g_t_0040code_007btrunc_0040var_007bmn_007d2_007d-instruction-pattern-3438"></a><br><dt>&lsquo;<samp><span class="samp">trunc</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对机器模式<var>m</var>有效），截取为机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。两个机器模式都必须同为定点的或者浮点的。

     <p><a name="index-g_t_0040code_007bextend_0040var_007bmn_007d2_007d-instruction-pattern-3439"></a><br><dt>&lsquo;<samp><span class="samp">extend</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对机器模式<var>m</var>有效）符号扩展成机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。两个机器模式都必须同为定点的或者浮点的。

     <p><a name="index-g_t_0040code_007bzero_005fextend_0040var_007bmn_007d2_007d-instruction-pattern-3440"></a><br><dt>&lsquo;<samp><span class="samp">zero_extend</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将操作数1（对机器模式<var>m</var>有效）零扩展成机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。两个机器模式都必须同为定点的或者浮点的。

     <p><a name="index-g_t_0040code_007bfract_0040var_007bmn_007d2_007d-instruction-pattern-3441"></a><br><dt>&lsquo;<samp><span class="samp">fract</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将机器模式为<var>m</var>的操作数1，转换成机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。机器模式<var>m</var>和<var>n</var>可以为定点到定点，有符号整数到定点，定点到有符号整数，浮点到浮点，或者定点到浮点。当发生溢出时，结果未定义。

     <p><a name="index-g_t_0040code_007bsatfract_0040var_007bmn_007d2_007d-instruction-pattern-3442"></a><br><dt>&lsquo;<samp><span class="samp">satfract</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将机器模式为<var>m</var>的操作数1，转换成机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。机器模式<var>m</var>和<var>n</var>可以为定点到定点，有符号整数到定点，或者浮点到定点。当发生溢出时，指令将结果饱和为最大或最小值。

     <p><a name="index-g_t_0040code_007bfractuns_0040var_007bmn_007d2_007d-instruction-pattern-3443"></a><br><dt>&lsquo;<samp><span class="samp">fractuns</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将机器模式为<var>m</var>的操作数1，转换成机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。机器模式<var>m</var>和<var>n</var>可以为无符号整数到定点，或者定点到无符号整数。当发生溢出时，结果未定义。

     <p><a name="index-g_t_0040code_007bsatfractuns_0040var_007bmn_007d2_007d-instruction-pattern-3444"></a><br><dt>&lsquo;<samp><span class="samp">satfractuns</span><var>m</var><var>n</var><span class="samp">2</span></samp>&rsquo;<dd>将机器模式为<var>m</var>的，无符号整数，操作数1，转换成定点机器模式<var>n</var>，并存放在操作数0（机器模式为<var>n</var>）中。当发生溢出时，指令将结果饱和为最大或最小值。

     <p><a name="index-g_t_0040code_007bextv_007d-instruction-pattern-3445"></a><br><dt>&lsquo;<samp><span class="samp">extv</span></samp>&rsquo;<dd>从操作数1（寄存器或者内存操作数）中抽取一个位域，其中操作数2指定了宽度，按位为单位，操作数3为起始位，并将结果存放在操作数0中。操作数0必须具有机器模式<code>word_mode</code>。操作数1可以具有机器模式<code>byte_mode</code> 或 <code>word_mode</code>；通常<code>word_mode</code>只允许用于寄存器。操作数2和3必须对<code>word_mode</code>有效。

     <p>RTL生成过程，生成的该指令，操作数2和3为常量，并且对于操作数2，常量不为零。

     <p>位域的值，在存放到操作数0之前，被有符号扩展为一整个字的整数。

     <p><a name="index-g_t_0040code_007bextzv_007d-instruction-pattern-3446"></a><br><dt>&lsquo;<samp><span class="samp">extzv</span></samp>&rsquo;<dd>类似&lsquo;<samp><span class="samp">extv</span></samp>&rsquo;，只不过位域的值被零扩展。

     <p><a name="index-g_t_0040code_007binsv_007d-instruction-pattern-3447"></a><br><dt>&lsquo;<samp><span class="samp">insv</span></samp>&rsquo;<dd>将操作数3（必须对<code>word_mode</code>有效）存储到操作数0中的位域，其中操作数1指定了位宽，操作数2指定了起始位。操作数0可以具有机器模式<code>byte_mode</code> 或 <code>word_mode</code>；通常<code>word_mode</code>只允许用于寄存器。操作数1和2必须对<code>word_mode</code>有效。

     <p>RTL生成过程，生成的该指令，操作数1和2为常量，并且对于操作数1，常量不为零。

     <p><a name="index-g_t_0040code_007bmov_0040var_007bmode_007dcc_007d-instruction-pattern-3448"></a><br><dt>&lsquo;<samp><span class="samp">mov</span><var>mode</var><span class="samp">cc</span></samp>&rsquo;<dd>根据对操作数1的比较，有条件的将操作数2或者3移送到操作数0中。如果比较为真，则操作数2被移送到操作数0中，否则操作数3被移送。

     <p>操作数的机器模式不需要与被移送的操作数的相同。一些机器，例如sparc64，具有可以根据浮点条件码，条件移送整数值的指令，以及相反的指令。

     <p>如果机器没有条件移送指令，则不要定义这些指令模式。

     <p><a name="index-g_t_0040code_007badd_0040var_007bmode_007dcc_007d-instruction-pattern-3449"></a><br><dt>&lsquo;<samp><span class="samp">add</span><var>mode</var><span class="samp">cc</span></samp>&rsquo;<dd>类似于&lsquo;<samp><span class="samp">mov</span><var>mode</var><span class="samp">cc</span></samp>&rsquo;，不过是条件加法。根据在操作数1中的比较，条件性的将操作数2或者(操作数2 + 操作数3)，移送到操作数0中。如果比较为真，则操作数2被移送到操作数0中，否则(操作数2 + 操作数3)被移送。

     <p><a name="index-g_t_0040code_007bs_0040var_007bcond_007d_007d-instruction-pattern-3450"></a><br><dt>&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;<dd>根据条件码将零或者非零存放在操作数中。当且仅当条件<var>cond</var>为真时，存储的值才为非零。<var>cond</var>为一个比较运算表达式代码的名字，例如<code>eq</code>, <code>lt</code>或<code>leu</code>。

     <p>当书写<code>match_operand</code>表达式的时候，你来指定操作数必须具有的机器模式。编译器自动的查看你使用的机器模式，并提供那个机器模式的操作数。

     <p>对于条件为真时所存储的值，其低位必须为1，不然必须为负。否则，指令就不适合，你应该从机器描述中将其去掉。你可以通过定义宏<code>STORE_FLAG_VALUE</code> (see <a href="Misc.html#Misc">Misc</a>)，来描述哪个值被存放。如果不能找到一个用于所有&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;指令模式的描述，则你应该从机器描述中去掉这些操作。

     <p>这些操作可以失败，但应该只在相对不常见的情况下这样做；如果它们对于常见的情况，包括整数比较，会失败，则最好去掉这些指令模式。

     <p>如果这些操作被去掉，则编译器通常会生成，将常量复制到目标，并在将零赋值给目标的语句附近进行分支跳转。如果这样的代码比用于&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;模式的指令，后面跟着需要将结果转成<code>SImode</code>的1或者零的的指令，更有效，则你应该从机器描述中去掉&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;操作。

     <p><a name="index-g_t_0040code_007bb_0040var_007bcond_007d_007d-instruction-pattern-3451"></a><br><dt>&lsquo;<samp><span class="samp">b</span><var>cond</var></samp>&rsquo;<dd>条件分支指令。操作数0为一个<code>label_ref</code>指出要跳转到的标号。如果条件码符合条件<var>cond</var>则跳转。

     <p>一些机器不遵循这里假设的模型，即一个比较指令，跟随一个条件跳转指令。那种情况下，&lsquo;<samp><span class="samp">cmp</span><var>m</var></samp>&rsquo; (和 &lsquo;<samp><span class="samp">tst</span><var>m</var></samp>&rsquo;)指令模式，应该简单的将操作数存放开，并在<code>define_expand</code> (see <a href="Expander-Definitions.html#Expander-Definitions">Expander Definitions</a>)中为条件分支操作，生成所有需要的insn。所有对扩展&lsquo;<samp><span class="samp">b</span><var>cond</var></samp>&rsquo;指令模式的调用，都会立即优先执行对扩展&lsquo;<samp><span class="samp">cmp</span><var>m</var></samp>&rsquo;或者&lsquo;<samp><span class="samp">tst</span><var>m</var></samp>&rsquo;的调用。

     <p>对条件代码值使用伪寄存器的，或者用于比较的机器模式取决于被测试的条件的机器，也应该使用上面的机制。See <a href="Jump-Patterns.html#Jump-Patterns">Jump Patterns</a>。

     <p>上面的讨论也应用在&lsquo;<samp><span class="samp">mov</span><var>mode</var><span class="samp">cc</span></samp>&rsquo;和&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;指令模式上。

     <p><a name="index-g_t_0040code_007bcbranch_0040var_007bmode_007d4_007d-instruction-pattern-3452"></a><br><dt>&lsquo;<samp><span class="samp">cbranch</span><var>mode</var><span class="samp">4</span></samp>&rsquo;<dd>条件分支指令，结合一个比较指令。操作数0为比较运算符。操作数1和2分别为比较运算的第一个和第二个操作数。操作数3为一个<code>label_ref</code>，指出了跳转的标号。

     <p><a name="index-g_t_0040code_007bjump_007d-instruction-pattern-3453"></a><br><dt>&lsquo;<samp><span class="samp">jump</span></samp>&rsquo;<dd>函数内部跳转；无条件分支。操作数0为一个<code>label_ref</code>，指出了跳转的标号。该指令模式名在所有机器上都是强制必须的。

     <p><a name="index-g_t_0040code_007bcall_007d-instruction-pattern-3454"></a><br><dt>&lsquo;<samp><span class="samp">call</span></samp>&rsquo;<dd>没有返回值的子程序调用指令。操作数0为调用的函数；操作数1为压栈的参数的字节数，为一个<code>const_int</code>；操作数2为用作操作数的寄存器数目。

     <p>在大多机器上，操作数2没有被实际存放在RTL模式中。提供它是出于安全考虑，一些RISC机器需要将该信息放到汇编代码中；它们可以将其放在RTL中，而不是操作数1中。

     <p>操作数0应该为一个<code>mem</code> RTX，其地址为函数的地址。然而注意，该地址可以为一个<code>symbol_ref</code>表达式，即使其在目标机器上可能不是一个合法的内存地址。如果其也不是调用指令的有效参数，则该操作的指令模式应该为一个<code>define_expand</code> (see <a href="Expander-Definitions.html#Expander-Definitions">Expander Definitions</a>)，其将地址放入寄存器中，并在调用指令中使用寄存器。

     <p><a name="index-g_t_0040code_007bcall_005fvalue_007d-instruction-pattern-3455"></a><br><dt>&lsquo;<samp><span class="samp">call_value</span></samp>&rsquo;<dd>有返回值的子程序调用指令。操作数0为硬件寄存器，存放返回值。还有三个操作数，与&lsquo;<samp><span class="samp">call</span></samp>&rsquo;指令相同（只不过将编号加一）。

     <p>返回 <code>BLKmode</code>对象的子程序，使用&lsquo;<samp><span class="samp">call</span></samp>&rsquo; insn。

     <p><a name="index-g_t_0040code_007bcall_005fpop_007d-instruction-pattern-3456"></a><a name="index-g_t_0040code_007bcall_005fvalue_005fpop_007d-instruction-pattern-3457"></a><br><dt>&lsquo;<samp><span class="samp">call_pop</span></samp>&rsquo;, &lsquo;<samp><span class="samp">call_value_pop</span></samp>&rsquo;<dd>类似于&lsquo;<samp><span class="samp">call</span></samp>&rsquo; 和 &lsquo;<samp><span class="samp">call_value</span></samp>&rsquo;，只不过用于其被定义，并且<code>RETURN_POPS_ARGS</code>为非零的时候。它们应该生成一个 <code>parallel</code>，包含函数调用和一个<code>set</code>，来指示对帧指针的调整。

     <p>对于<code>RETURN_POPS_ARGS</code>可以为非零的机器，使用这些指令模式可以增加帧指针被消除掉的函数的数目。

     <p><a name="index-g_t_0040code_007buntyped_005fcall_007d-instruction-pattern-3458"></a><br><dt>&lsquo;<samp><span class="samp">untyped_call</span></samp>&rsquo;<dd>返回一个任意类型的值的子函数调用指令。操作数0为调用的函数；操作数1为内存位置，存放调用函数后的结果；操作数2为一个<code>parallel</code>表达式，其中每个元素都为一个<code>set</code>表达式，用来指示将函数返回值保存到结果块中。

     <p>该指令模式应该被定义，来支持<code>__builtin_apply</code>，在一些机器上，需要特殊的指令来调用一个具有任意参数的子程序，或者将返回值保存。在具有多个寄存器，可以存放一个返回值（即<code>FUNCTION_VALUE_REGNO_P</code>对多个寄存器都为真）的机器上，需要该指令模式。

     <p><a name="index-g_t_0040code_007breturn_007d-instruction-pattern-3459"></a><br><dt>&lsquo;<samp><span class="samp">return</span></samp>&rsquo;<dd>子程序返回指令。该指令模式名应该只有当，单个指令可以做从函数中返回时的所有工作的时候，才被定义。

     <p>类似&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;指令模式，该指令模式也在RTL生成阶段之后被使用。这种情况下，其用来支持一些机器，从函数中返回通常需要多个指令，但是某些类别的函数只需要一条指令来实现返回。
 patterns, this pattern is also used after the
RTL generation phase.  In this case it is to support machines where
multiple instructions are usually needed to return from a function, but
some class of functions only requires one instruction to implement a
return.  Normally, the applicable functions are those which do not need
to save any registers or allocate stack space.

     <p><a name="index-reload_005fcompleted-3460"></a><a name="index-leaf_005ffunction_005fp-3461"></a>For such machines, the condition specified in this pattern should only
be true when <code>reload_completed</code> is nonzero and the function's
epilogue would only be a single instruction.  For machines with register
windows, the routine <code>leaf_function_p</code> may be used to determine if
a register window push is required.

     <p>Machines that have conditional return instructions should define patterns
such as

     <pre class="smallexample">          (define_insn ""
            [(set (pc)
                  (if_then_else (match_operator
                                   0 "comparison_operator"
                                   [(cc0) (const_int 0)])
                                (return)
                                (pc)))]
            "<var>condition</var>"
            "...")
</pre>
     <p>where <var>condition</var> would normally be the same condition specified on the
named &lsquo;<samp><span class="samp">return</span></samp>&rsquo; pattern.

     <p><a name="index-g_t_0040code_007buntyped_005freturn_007d-instruction-pattern-3462"></a><br><dt>&lsquo;<samp><span class="samp">untyped_return</span></samp>&rsquo;<dd>Untyped subroutine return instruction.  This instruction pattern should
be defined to support <code>__builtin_return</code> on machines where special
instructions are needed to return a value of any type.

     <p>Operand 0 is a memory location where the result of calling a function
with <code>__builtin_apply</code> is stored; operand 1 is a <code>parallel</code>
expression where each element is a <code>set</code> expression that indicates
the restoring of a function return value from the result block.

     <p><a name="index-g_t_0040code_007bnop_007d-instruction-pattern-3463"></a><br><dt>&lsquo;<samp><span class="samp">nop</span></samp>&rsquo;<dd>No-op instruction.  This instruction pattern name should always be defined
to output a no-op in assembler code.  <code>(const_int 0)</code> will do as an
RTL pattern.

     <p><a name="index-g_t_0040code_007bindirect_005fjump_007d-instruction-pattern-3464"></a><br><dt>&lsquo;<samp><span class="samp">indirect_jump</span></samp>&rsquo;<dd>An instruction to jump to an address which is operand zero. 
This pattern name is mandatory on all machines.

     <p><a name="index-g_t_0040code_007bcasesi_007d-instruction-pattern-3465"></a><br><dt>&lsquo;<samp><span class="samp">casesi</span></samp>&rsquo;<dd>Instruction to jump through a dispatch table, including bounds checking. 
This instruction takes five operands:

          <ol type=1 start=1>
<li>The index to dispatch on, which has mode <code>SImode</code>.

          <li>The lower bound for indices in the table, an integer constant.

          <li>The total range of indices in the table&mdash;the largest index
minus the smallest one (both inclusive).

          <li>A label that precedes the table itself.

          <li>A label to jump to if the index has a value outside the bounds.
          </ol>

     <p>The table is a <code>addr_vec</code> or <code>addr_diff_vec</code> inside of a
<code>jump_insn</code>.  The number of elements in the table is one plus the
difference between the upper bound and the lower bound.

     <p><a name="index-g_t_0040code_007btablejump_007d-instruction-pattern-3466"></a><br><dt>&lsquo;<samp><span class="samp">tablejump</span></samp>&rsquo;<dd>Instruction to jump to a variable address.  This is a low-level
capability which can be used to implement a dispatch table when there
is no &lsquo;<samp><span class="samp">casesi</span></samp>&rsquo; pattern.

     <p>This pattern requires two operands: the address or offset, and a label
which should immediately precede the jump table.  If the macro
<code>CASE_VECTOR_PC_RELATIVE</code> evaluates to a nonzero value then the first
operand is an offset which counts from the address of the table; otherwise,
it is an absolute address to jump to.  In either case, the first operand has
mode <code>Pmode</code>.

     <p>The &lsquo;<samp><span class="samp">tablejump</span></samp>&rsquo; insn is always the last insn before the jump
table it uses.  Its assembler code normally has no need to use the
second operand, but you should incorporate it in the RTL pattern so
that the jump optimizer will not delete the table as unreachable code.

     <p><a name="index-g_t_0040code_007bdecrement_005fand_005fbranch_005funtil_005fzero_007d-instruction-pattern-3467"></a><br><dt>&lsquo;<samp><span class="samp">decrement_and_branch_until_zero</span></samp>&rsquo;<dd>Conditional branch instruction that decrements a register and
jumps if the register is nonzero.  Operand 0 is the register to
decrement and test; operand 1 is the label to jump to if the
register is nonzero.  See <a href="Looping-Patterns.html#Looping-Patterns">Looping Patterns</a>.

     <p>This optional instruction pattern is only used by the combiner,
typically for loops reversed by the loop optimizer when strength
reduction is enabled.

     <p><a name="index-g_t_0040code_007bdoloop_005fend_007d-instruction-pattern-3468"></a><br><dt>&lsquo;<samp><span class="samp">doloop_end</span></samp>&rsquo;<dd>Conditional branch instruction that decrements a register and jumps if
the register is nonzero.  This instruction takes five operands: Operand
0 is the register to decrement and test; operand 1 is the number of loop
iterations as a <code>const_int</code> or <code>const0_rtx</code> if this cannot be
determined until run-time; operand 2 is the actual or estimated maximum
number of iterations as a <code>const_int</code>; operand 3 is the number of
enclosed loops as a <code>const_int</code> (an innermost loop has a value of
1); operand 4 is the label to jump to if the register is nonzero. 
See <a href="Looping-Patterns.html#Looping-Patterns">Looping Patterns</a>.

     <p>This optional instruction pattern should be defined for machines with
low-overhead looping instructions as the loop optimizer will try to
modify suitable loops to utilize it.  If nested low-overhead looping is
not supported, use a <code>define_expand</code> (see <a href="Expander-Definitions.html#Expander-Definitions">Expander Definitions</a>)
and make the pattern fail if operand 3 is not <code>const1_rtx</code>. 
Similarly, if the actual or estimated maximum number of iterations is
too large for this instruction, make it fail.

     <p><a name="index-g_t_0040code_007bdoloop_005fbegin_007d-instruction-pattern-3469"></a><br><dt>&lsquo;<samp><span class="samp">doloop_begin</span></samp>&rsquo;<dd>Companion instruction to <code>doloop_end</code> required for machines that
need to perform some initialization, such as loading special registers
used by a low-overhead looping instruction.  If initialization insns do
not always need to be emitted, use a <code>define_expand</code>
(see <a href="Expander-Definitions.html#Expander-Definitions">Expander Definitions</a>) and make it fail.

     <p><a name="index-g_t_0040code_007bcanonicalize_005ffuncptr_005ffor_005fcompare_007d-instruction-pattern-3470"></a><br><dt>&lsquo;<samp><span class="samp">canonicalize_funcptr_for_compare</span></samp>&rsquo;<dd>Canonicalize the function pointer in operand 1 and store the result
into operand 0.

     <p>Operand 0 is always a <code>reg</code> and has mode <code>Pmode</code>; operand 1
may be a <code>reg</code>, <code>mem</code>, <code>symbol_ref</code>, <code>const_int</code>, etc
and also has mode <code>Pmode</code>.

     <p>Canonicalization of a function pointer usually involves computing
the address of the function which would be called if the function
pointer were used in an indirect call.

     <p>Only define this pattern if function pointers on the target machine
can have different values but still call the same function when
used in an indirect call.

     <p><a name="index-g_t_0040code_007bsave_005fstack_005fblock_007d-instruction-pattern-3471"></a><a name="index-g_t_0040code_007bsave_005fstack_005ffunction_007d-instruction-pattern-3472"></a><a name="index-g_t_0040code_007bsave_005fstack_005fnonlocal_007d-instruction-pattern-3473"></a><a name="index-g_t_0040code_007brestore_005fstack_005fblock_007d-instruction-pattern-3474"></a><a name="index-g_t_0040code_007brestore_005fstack_005ffunction_007d-instruction-pattern-3475"></a><a name="index-g_t_0040code_007brestore_005fstack_005fnonlocal_007d-instruction-pattern-3476"></a><br><dt>&lsquo;<samp><span class="samp">save_stack_block</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">save_stack_function</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">save_stack_nonlocal</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">restore_stack_block</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">restore_stack_function</span></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">restore_stack_nonlocal</span></samp>&rsquo;<dd>Most machines save and restore the stack pointer by copying it to or
from an object of mode <code>Pmode</code>.  Do not define these patterns on
such machines.

     <p>Some machines require special handling for stack pointer saves and
restores.  On those machines, define the patterns corresponding to the
non-standard cases by using a <code>define_expand</code> (see <a href="Expander-Definitions.html#Expander-Definitions">Expander Definitions</a>) that produces the required insns.  The three types of
saves and restores are:

          <ol type=1 start=1>
<li>&lsquo;<samp><span class="samp">save_stack_block</span></samp>&rsquo; saves the stack pointer at the start of a block
that allocates a variable-sized object, and &lsquo;<samp><span class="samp">restore_stack_block</span></samp>&rsquo;
restores the stack pointer when the block is exited.

          <li>&lsquo;<samp><span class="samp">save_stack_function</span></samp>&rsquo; and &lsquo;<samp><span class="samp">restore_stack_function</span></samp>&rsquo; do a
similar job for the outermost block of a function and are used when the
function allocates variable-sized objects or calls <code>alloca</code>.  Only
the epilogue uses the restored stack pointer, allowing a simpler save or
restore sequence on some machines.

          <li>&lsquo;<samp><span class="samp">save_stack_nonlocal</span></samp>&rsquo; is used in functions that contain labels
branched to by nested functions.  It saves the stack pointer in such a
way that the inner function can use &lsquo;<samp><span class="samp">restore_stack_nonlocal</span></samp>&rsquo; to
restore the stack pointer.  The compiler generates code to restore the
frame and argument pointer registers, but some machines require saving
and restoring additional data such as register window information or
stack backchains.  Place insns in these patterns to save and restore any
such required data.
          </ol>

     <p>When saving the stack pointer, operand 0 is the save area and operand 1
is the stack pointer.  The mode used to allocate the save area defaults
to <code>Pmode</code> but you can override that choice by defining the
<code>STACK_SAVEAREA_MODE</code> macro (see <a href="Storage-Layout.html#Storage-Layout">Storage Layout</a>).  You must
specify an integral mode, or <code>VOIDmode</code> if no save area is needed
for a particular type of save (either because no save is needed or
because a machine-specific save area can be used).  Operand 0 is the
stack pointer and operand 1 is the save area for restore operations.  If
&lsquo;<samp><span class="samp">save_stack_block</span></samp>&rsquo; is defined, operand 0 must not be
<code>VOIDmode</code> since these saves can be arbitrarily nested.

     <p>A save area is a <code>mem</code> that is at a constant offset from
<code>virtual_stack_vars_rtx</code> when the stack pointer is saved for use by
nonlocal gotos and a <code>reg</code> in the other two cases.

     <p><a name="index-g_t_0040code_007ballocate_005fstack_007d-instruction-pattern-3477"></a><br><dt>&lsquo;<samp><span class="samp">allocate_stack</span></samp>&rsquo;<dd>Subtract (or add if <code>STACK_GROWS_DOWNWARD</code> is undefined) operand 1 from
the stack pointer to create space for dynamically allocated data.

     <p>Store the resultant pointer to this space into operand 0.  If you
are allocating space from the main stack, do this by emitting a
move insn to copy <code>virtual_stack_dynamic_rtx</code> to operand 0. 
If you are allocating the space elsewhere, generate code to copy the
location of the space to operand 0.  In the latter case, you must
ensure this space gets freed when the corresponding space on the main
stack is free.

     <p>Do not define this pattern if all that must be done is the subtraction. 
Some machines require other operations such as stack probes or
maintaining the back chain.  Define this pattern to emit those
operations in addition to updating the stack pointer.

     <p><a name="index-g_t_0040code_007bcheck_005fstack_007d-instruction-pattern-3478"></a><br><dt>&lsquo;<samp><span class="samp">check_stack</span></samp>&rsquo;<dd>If stack checking cannot be done on your system by probing the stack with
a load or store instruction (see <a href="Stack-Checking.html#Stack-Checking">Stack Checking</a>), define this pattern
to perform the needed check and signaling an error if the stack
has overflowed.  The single operand is the location in the stack furthest
from the current stack pointer that you need to validate.  Normally,
on machines where this pattern is needed, you would obtain the stack
limit from a global or thread-specific variable or register.

     <p><a name="index-g_t_0040code_007bnonlocal_005fgoto_007d-instruction-pattern-3479"></a><br><dt>&lsquo;<samp><span class="samp">nonlocal_goto</span></samp>&rsquo;<dd>Emit code to generate a non-local goto, e.g., a jump from one function
to a label in an outer function.  This pattern has four arguments,
each representing a value to be used in the jump.  The first
argument is to be loaded into the frame pointer, the second is
the address to branch to (code to dispatch to the actual label),
the third is the address of a location where the stack is saved,
and the last is the address of the label, to be placed in the
location for the incoming static chain.

     <p>On most machines you need not define this pattern, since GCC will
already generate the correct code, which is to load the frame pointer
and static chain, restore the stack (using the
&lsquo;<samp><span class="samp">restore_stack_nonlocal</span></samp>&rsquo; pattern, if defined), and jump indirectly
to the dispatcher.  You need only define this pattern if this code will
not work on your machine.

     <p><a name="index-g_t_0040code_007bnonlocal_005fgoto_005freceiver_007d-instruction-pattern-3480"></a><br><dt>&lsquo;<samp><span class="samp">nonlocal_goto_receiver</span></samp>&rsquo;<dd>This pattern, if defined, contains code needed at the target of a
nonlocal goto after the code already generated by GCC.  You will not
normally need to define this pattern.  A typical reason why you might
need this pattern is if some value, such as a pointer to a global table,
must be restored when the frame pointer is restored.  Note that a nonlocal
goto only occurs within a unit-of-translation, so a global table pointer
that is shared by all functions of a given module need not be restored. 
There are no arguments.

     <p><a name="index-g_t_0040code_007bexception_005freceiver_007d-instruction-pattern-3481"></a><br><dt>&lsquo;<samp><span class="samp">exception_receiver</span></samp>&rsquo;<dd>This pattern, if defined, contains code needed at the site of an
exception handler that isn't needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored after control flow is branched to the handler of
an exception.  There are no arguments.

     <p><a name="index-g_t_0040code_007bbuiltin_005fsetjmp_005fsetup_007d-instruction-pattern-3482"></a><br><dt>&lsquo;<samp><span class="samp">builtin_setjmp_setup</span></samp>&rsquo;<dd>This pattern, if defined, contains additional code needed to initialize
the <code>jmp_buf</code>.  You will not normally need to define this pattern. 
A typical reason why you might need this pattern is if some value, such
as a pointer to a global table, must be restored.  Though it is
preferred that the pointer value be recalculated if possible (given the
address of a label for instance).  The single argument is a pointer to
the <code>jmp_buf</code>.  Note that the buffer is five words long and that
the first three are normally used by the generic mechanism.

     <p><a name="index-g_t_0040code_007bbuiltin_005fsetjmp_005freceiver_007d-instruction-pattern-3483"></a><br><dt>&lsquo;<samp><span class="samp">builtin_setjmp_receiver</span></samp>&rsquo;<dd>This pattern, if defined, contains code needed at the site of an
built-in setjmp that isn't needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored.  It takes one argument, which is the label
to which builtin_longjmp transfered control; this pattern may be emitted
at a small offset from that label.

     <p><a name="index-g_t_0040code_007bbuiltin_005flongjmp_007d-instruction-pattern-3484"></a><br><dt>&lsquo;<samp><span class="samp">builtin_longjmp</span></samp>&rsquo;<dd>This pattern, if defined, performs the entire action of the longjmp. 
You will not normally need to define this pattern unless you also define
<code>builtin_setjmp_setup</code>.  The single argument is a pointer to the
<code>jmp_buf</code>.

     <p><a name="index-g_t_0040code_007beh_005freturn_007d-instruction-pattern-3485"></a><br><dt>&lsquo;<samp><span class="samp">eh_return</span></samp>&rsquo;<dd>This pattern, if defined, affects the way <code>__builtin_eh_return</code>,
and thence the call frame exception handling library routines, are
built.  It is intended to handle non-trivial actions needed along
the abnormal return path.

     <p>The address of the exception handler to which the function should return
is passed as operand to this pattern.  It will normally need to copied by
the pattern to some special register or memory location. 
If the pattern needs to determine the location of the target call
frame in order to do so, it may use <code>EH_RETURN_STACKADJ_RTX</code>,
if defined; it will have already been assigned.

     <p>If this pattern is not defined, the default action will be to simply
copy the return address to <code>EH_RETURN_HANDLER_RTX</code>.  Either
that macro or this pattern needs to be defined if call frame exception
handling is to be used.

     <p><a name="index-g_t_0040code_007bprologue_007d-instruction-pattern-3486"></a><a name="prologue-instruction-pattern"></a><br><dt>&lsquo;<samp><span class="samp">prologue</span></samp>&rsquo;<dd>This pattern, if defined, emits RTL for entry to a function.  The function
entry is responsible for setting up the stack frame, initializing the frame
pointer register, saving callee saved registers, etc.

     <p>Using a prologue pattern is generally preferred over defining
<code>TARGET_ASM_FUNCTION_PROLOGUE</code> to emit assembly code for the prologue.

     <p>The <code>prologue</code> pattern is particularly useful for targets which perform
instruction scheduling.

     <p><a name="index-g_t_0040code_007bepilogue_007d-instruction-pattern-3487"></a><a name="epilogue-instruction-pattern"></a><br><dt>&lsquo;<samp><span class="samp">epilogue</span></samp>&rsquo;<dd>This pattern emits RTL for exit from a function.  The function
exit is responsible for deallocating the stack frame, restoring callee saved
registers and emitting the return instruction.

     <p>Using an epilogue pattern is generally preferred over defining
<code>TARGET_ASM_FUNCTION_EPILOGUE</code> to emit assembly code for the epilogue.

     <p>The <code>epilogue</code> pattern is particularly useful for targets which perform
instruction scheduling or which have delay slots for their return instruction.

     <p><a name="index-g_t_0040code_007bsibcall_005fepilogue_007d-instruction-pattern-3488"></a><br><dt>&lsquo;<samp><span class="samp">sibcall_epilogue</span></samp>&rsquo;<dd>This pattern, if defined, emits RTL for exit from a function without the final
branch back to the calling function.  This pattern will be emitted before any
sibling call (aka tail call) sites.

     <p>The <code>sibcall_epilogue</code> pattern must not clobber any arguments used for
parameter passing or any stack slots for arguments passed to the current
function.

     <p><a name="index-g_t_0040code_007btrap_007d-instruction-pattern-3489"></a><br><dt>&lsquo;<samp><span class="samp">trap</span></samp>&rsquo;<dd>This pattern, if defined, signals an error, typically by causing some
kind of signal to be raised.  Among other places, it is used by the Java
front end to signal `invalid array index' exceptions.

     <p><a name="index-g_t_0040code_007bconditional_005ftrap_007d-instruction-pattern-3490"></a><br><dt>&lsquo;<samp><span class="samp">conditional_trap</span></samp>&rsquo;<dd>Conditional trap instruction.  Operand 0 is a piece of RTL which
performs a comparison.  Operand 1 is the trap code, an integer.

     <p>A typical <code>conditional_trap</code> pattern looks like

     <pre class="smallexample">          (define_insn "conditional_trap"
            [(trap_if (match_operator 0 "trap_operator"
                       [(cc0) (const_int 0)])
                      (match_operand 1 "const_int_operand" "i"))]
            ""
            "...")
</pre>
     <p><a name="index-g_t_0040code_007bprefetch_007d-instruction-pattern-3491"></a><br><dt>&lsquo;<samp><span class="samp">prefetch</span></samp>&rsquo;<dd>
This pattern, if defined, emits code for a non-faulting data prefetch
instruction.  Operand 0 is the address of the memory to prefetch.  Operand 1
is a constant 1 if the prefetch is preparing for a write to the memory
address, or a constant 0 otherwise.  Operand 2 is the expected degree of
temporal locality of the data and is a value between 0 and 3, inclusive; 0
means that the data has no temporal locality, so it need not be left in the
cache after the access; 3 means that the data has a high degree of temporal
locality and should be left in all levels of cache possible;  1 and 2 mean,
respectively, a low or moderate degree of temporal locality.

     <p>Targets that do not support write prefetches or locality hints can ignore
the values of operands 1 and 2.

     <p><a name="index-g_t_0040code_007bblockage_007d-instruction-pattern-3492"></a><br><dt>&lsquo;<samp><span class="samp">blockage</span></samp>&rsquo;<dd>
This pattern defines a pseudo insn that prevents the instruction
scheduler from moving instructions across the boundary defined by the
blockage insn.  Normally an UNSPEC_VOLATILE pattern.

     <p><a name="index-g_t_0040code_007bmemory_005fbarrier_007d-instruction-pattern-3493"></a><br><dt>&lsquo;<samp><span class="samp">memory_barrier</span></samp>&rsquo;<dd>
If the target memory model is not fully synchronous, then this pattern
should be defined to an instruction that orders both loads and stores
before the instruction with respect to loads and stores after the instruction. 
This pattern has no operands.

     <p><a name="index-g_t_0040code_007bsync_005fcompare_005fand_005fswap_0040var_007bmode_007d_007d-instruction-pattern-3494"></a><br><dt>&lsquo;<samp><span class="samp">sync_compare_and_swap</span><var>mode</var></samp>&rsquo;<dd>
This pattern, if defined, emits code for an atomic compare-and-swap
operation.  Operand 1 is the memory on which the atomic operation is
performed.  Operand 2 is the &ldquo;old&rdquo; value to be compared against the
current contents of the memory location.  Operand 3 is the &ldquo;new&rdquo; value
to store in the memory if the compare succeeds.  Operand 0 is the result
of the operation; it should contain the contents of the memory
before the operation.  If the compare succeeds, this should obviously be
a copy of operand 2.

     <p>This pattern must show that both operand 0 and operand 1 are modified.

     <p>This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

     <p><a name="index-g_t_0040code_007bsync_005fcompare_005fand_005fswap_005fcc_0040var_007bmode_007d_007d-instruction-pattern-3495"></a><br><dt>&lsquo;<samp><span class="samp">sync_compare_and_swap_cc</span><var>mode</var></samp>&rsquo;<dd>
This pattern is just like <code>sync_compare_and_swap</code><var>mode</var>, except
it should act as if compare part of the compare-and-swap were issued via
<code>cmp</code><var>m</var>.  This comparison will only be used with <code>EQ</code> and
<code>NE</code> branches and <code>setcc</code> operations.

     <p>Some targets do expose the success or failure of the compare-and-swap
operation via the status flags.  Ideally we wouldn't need a separate
named pattern in order to take advantage of this, but the combine pass
does not handle patterns with multiple sets, which is required by
definition for <code>sync_compare_and_swap</code><var>mode</var>.

     <p><a name="index-g_t_0040code_007bsync_005fadd_0040var_007bmode_007d_007d-instruction-pattern-3496"></a><a name="index-g_t_0040code_007bsync_005fsub_0040var_007bmode_007d_007d-instruction-pattern-3497"></a><a name="index-g_t_0040code_007bsync_005fior_0040var_007bmode_007d_007d-instruction-pattern-3498"></a><a name="index-g_t_0040code_007bsync_005fand_0040var_007bmode_007d_007d-instruction-pattern-3499"></a><a name="index-g_t_0040code_007bsync_005fxor_0040var_007bmode_007d_007d-instruction-pattern-3500"></a><a name="index-g_t_0040code_007bsync_005fnand_0040var_007bmode_007d_007d-instruction-pattern-3501"></a><br><dt>&lsquo;<samp><span class="samp">sync_add</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_sub</span><var>mode</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">sync_ior</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_and</span><var>mode</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">sync_xor</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_nand</span><var>mode</var></samp>&rsquo;<dd>
These patterns emit code for an atomic operation on memory. 
Operand 0 is the memory on which the atomic operation is performed. 
Operand 1 is the second operand to the binary operator.

     <p>The &ldquo;nand&rdquo; operation is <code>~op0 &amp; op1</code>.

     <p>This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

     <p>If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.

     <p><a name="index-g_t_0040code_007bsync_005fold_005fadd_0040var_007bmode_007d_007d-instruction-pattern-3502"></a><a name="index-g_t_0040code_007bsync_005fold_005fsub_0040var_007bmode_007d_007d-instruction-pattern-3503"></a><a name="index-g_t_0040code_007bsync_005fold_005fior_0040var_007bmode_007d_007d-instruction-pattern-3504"></a><a name="index-g_t_0040code_007bsync_005fold_005fand_0040var_007bmode_007d_007d-instruction-pattern-3505"></a><a name="index-g_t_0040code_007bsync_005fold_005fxor_0040var_007bmode_007d_007d-instruction-pattern-3506"></a><a name="index-g_t_0040code_007bsync_005fold_005fnand_0040var_007bmode_007d_007d-instruction-pattern-3507"></a><br><dt>&lsquo;<samp><span class="samp">sync_old_add</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_old_sub</span><var>mode</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">sync_old_ior</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_old_and</span><var>mode</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">sync_old_xor</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_old_nand</span><var>mode</var></samp>&rsquo;<dd>
These patterns are emit code for an atomic operation on memory,
and return the value that the memory contained before the operation. 
Operand 0 is the result value, operand 1 is the memory on which the
atomic operation is performed, and operand 2 is the second operand
to the binary operator.

     <p>This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

     <p>If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.

     <p><a name="index-g_t_0040code_007bsync_005fnew_005fadd_0040var_007bmode_007d_007d-instruction-pattern-3508"></a><a name="index-g_t_0040code_007bsync_005fnew_005fsub_0040var_007bmode_007d_007d-instruction-pattern-3509"></a><a name="index-g_t_0040code_007bsync_005fnew_005fior_0040var_007bmode_007d_007d-instruction-pattern-3510"></a><a name="index-g_t_0040code_007bsync_005fnew_005fand_0040var_007bmode_007d_007d-instruction-pattern-3511"></a><a name="index-g_t_0040code_007bsync_005fnew_005fxor_0040var_007bmode_007d_007d-instruction-pattern-3512"></a><a name="index-g_t_0040code_007bsync_005fnew_005fnand_0040var_007bmode_007d_007d-instruction-pattern-3513"></a><br><dt>&lsquo;<samp><span class="samp">sync_new_add</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_new_sub</span><var>mode</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">sync_new_ior</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_new_and</span><var>mode</var></samp>&rsquo;<dt>&lsquo;<samp><span class="samp">sync_new_xor</span><var>mode</var></samp>&rsquo;, &lsquo;<samp><span class="samp">sync_new_nand</span><var>mode</var></samp>&rsquo;<dd>
These patterns are like their <code>sync_old_</code><var>op</var> counterparts,
except that they return the value that exists in the memory location
after the operation, rather than before the operation.

     <p><a name="index-g_t_0040code_007bsync_005flock_005ftest_005fand_005fset_0040var_007bmode_007d_007d-instruction-pattern-3514"></a><br><dt>&lsquo;<samp><span class="samp">sync_lock_test_and_set</span><var>mode</var></samp>&rsquo;<dd>
This pattern takes two forms, based on the capabilities of the target. 
In either case, operand 0 is the result of the operand, operand 1 is
the memory on which the atomic operation is performed, and operand 2
is the value to set in the lock.

     <p>In the ideal case, this operation is an atomic exchange operation, in
which the previous value in memory operand is copied into the result
operand, and the value operand is stored in the memory operand.

     <p>For less capable targets, any value operand that is not the constant 1
should be rejected with <code>FAIL</code>.  In this case the target may use
an atomic test-and-set bit operation.  The result operand should contain
1 if the bit was previously set and 0 if the bit was previously clear. 
The true contents of the memory operand are implementation defined.

     <p>This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as an acquire barrier, that is all memory
operations after the pattern do not occur until the lock is acquired.

     <p>If this pattern is not defined, the operation will be constructed from
a compare-and-swap operation, if defined.

     <p><a name="index-g_t_0040code_007bsync_005flock_005frelease_0040var_007bmode_007d_007d-instruction-pattern-3515"></a><br><dt>&lsquo;<samp><span class="samp">sync_lock_release</span><var>mode</var></samp>&rsquo;<dd>
This pattern, if defined, releases a lock set by
<code>sync_lock_test_and_set</code><var>mode</var>.  Operand 0 is the memory
that contains the lock; operand 1 is the value to store in the lock.

     <p>If the target doesn't implement full semantics for
<code>sync_lock_test_and_set</code><var>mode</var>, any value operand which is not
the constant 0 should be rejected with <code>FAIL</code>, and the true contents
of the memory operand are implementation defined.

     <p>This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as a release barrier, that is the lock is
released only after all previous memory operations have completed.

     <p>If this pattern is not defined, then a <code>memory_barrier</code> pattern
will be emitted, followed by a store of the value to the memory operand.

     <p><a name="index-g_t_0040code_007bstack_005fprotect_005fset_007d-instruction-pattern-3516"></a><br><dt>&lsquo;<samp><span class="samp">stack_protect_set</span></samp>&rsquo;<dd>
This pattern, if defined, moves a <code>Pmode</code> value from the memory
in operand 1 to the memory in operand 0 without leaving the value in
a register afterward.  This is to avoid leaking the value some place
that an attacker might use to rewrite the stack guard slot after
having clobbered it.

     <p>If this pattern is not defined, then a plain move pattern is generated.

     <p><a name="index-g_t_0040code_007bstack_005fprotect_005ftest_007d-instruction-pattern-3517"></a><br><dt>&lsquo;<samp><span class="samp">stack_protect_test</span></samp>&rsquo;<dd>
This pattern, if defined, compares a <code>Pmode</code> value from the
memory in operand 1 with the memory in operand 0 without leaving the
value in a register afterward and branches to operand 2 if the values
weren't equal.

     <p>If this pattern is not defined, then a plain compare pattern and
conditional branch pattern is used.

     <p><a name="index-g_t_0040code_007bclear_005fcache_007d-instruction-pattern-3518"></a><br><dt>&lsquo;<samp><span class="samp">clear_cache</span></samp>&rsquo;<dd>
This pattern, if defined, flushes the instruction cache for a region of
memory.  The region is bounded to by the Pmode pointers in operand 0
inclusive and operand 1 exclusive.

     <p>If this pattern is not defined, a call to the library function
<code>__clear_cache</code> is used.

 </dl>

<!-- Each of the following nodes are wrapped in separate -->
<!-- "@ifset INTERNALS" to work around memory limits for the default -->
<!-- configuration in older tetex distributions.  Known to not work: -->
<!-- tetex-1.0.7, known to work: tetex-2.0.2. -->
 </body></html>

