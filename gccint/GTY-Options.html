<html lang="en">
<head>
<title>GTY Options - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Type-Information.html#Type-Information" title="Type Information">
<link rel="next" href="GGC-Roots.html#GGC-Roots" title="GGC Roots">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Funding Free Software'', the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="GTY-Options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="GGC-Roots.html#GGC-Roots">GGC Roots</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Type-Information.html#Type-Information">Type Information</a>
<hr>
</div>

<h3 class="section">22.1 The Inside of a <code>GTY(())</code></h3>

<p>有时候C代码不足以完全描述类型结构体，这时可以使用 <code>GTY</code> 选项和
额外标记来提供额外的信息。一些选项接受一个参数，其可以为字符串或者类
型名。如果一个选项不需要参数，则可以完全省略参数，或者提供一个空字符
串作为参数。例如，<code>GTY&nbsp;((skip))<!-- /@w --></code> 和
<code>GTY&nbsp;((skip("")))<!-- /@w --></code> 是等价的。

 <p>当参数为字符串时，通常为一个C代码片段。有四种特定换码符可以在字符串
中使用，用来指定被标记的数据结构体：

 <p><a name="index-g_t_0025-in-GTY-option-4777"></a>
     <dl>
<dt><code>%h</code><dd>当前结构体。
<br><dt><code>%1</code><dd>直接包含当前结构体的结构体。
<br><dt><code>%0</code><dd>包含当前结构体的最外层结构体。
<br><dt><code>%a</code><dd><code>[i1][i2]...</code> 形式的部分表达式，用来索引当前被标记的数组项。
</dl>

 <p>例如，假设有一个结构体
<pre class="smallexample">     struct A {
       ...
     };
     struct B {
       struct A foo[12];
     };
</pre>
 <p class="noindent">并且 <code>b</code> 是 <code>struct B</code> 类型的变量。当标记 &lsquo;<samp><span class="samp">b.foo[11]</span></samp>&rsquo;
时，<code>%h</code> 将扩展为 &lsquo;<samp><span class="samp">b.foo[11]</span></samp>&rsquo;，<code>%0</code> 和 <code>%1</code> 都会
扩展为 &lsquo;<samp><span class="samp">b</span></samp>&rsquo;，<code>%a</code> 会扩展为 &lsquo;<samp><span class="samp">[11]</span></samp>&rsquo;。

 <p>由于原始的C中，相邻的字符串会被连接；这对于复杂的表达式是有帮助的。

<pre class="smallexample">     GTY ((chain_next ("TREE_CODE (&amp;%h.generic) == INTEGER_TYPE"
                       " ? TYPE_NEXT_VARIANT (&amp;%h.generic)"
                       " : TREE_CHAIN (&amp;%h.generic)")))
</pre>
 <p>可用的选项：

     
<a name="index-length-4778"></a>
<dl><dt><code>length ("</code><var>expression</var><code>")</code><dd>
有两个地方需要显示的告诉类型机构一个数组的长度。第一种情况是当一个结
构体结束于一个可变长度数组，像这样：
     <pre class="smallexample">          struct rtvec_def GTY(()) {
            int num_elem;         /* <span class="roman">number of elements</span> */
            rtx GTY ((length ("%h.num_elem"))) elem[1];
          };
</pre>
     <p>在这种情况下，<code>length</code> 选项用来覆盖指定数组的长度（通常本应该为
<code>1</code>）。选项的参数是C代码片断用来计算长度。

     <p>第二种情况是当一个结构体或者全局变量包含一个指向数组的指针，像这样：

     <pre class="smallexample">          tree *
            GTY ((length ("%h.regno_pointer_align_length"))) regno_decl;
</pre>
     <p>在这种情况下，<code>regno_decl</code> 已经通过类似下面的方式被分配：
     <pre class="smallexample">            x-&gt;regno_decl =
              ggc_alloc (x-&gt;regno_pointer_align_length * sizeof (tree));
</pre>
     <p>并且 <code>length</code> 提供了指定域的长度。

     <p><code>lenght</code> 的第二种用法还包括在全局变量上，像这样：
<pre class="verbatim">     
       static GTY((length ("reg_base_value_size")))
         rtx *reg_base_value;
</pre>

     <p><a name="index-skip-4779"></a><br><dt><code>skip</code><dd>
如果 <code>skip</code> 应用在一个域上，则类型机构将会忽略该域。这有些危险；
唯一安全的使用方式是在一个联合体中，当一个域确实不会被使用到的时候。

     <p><a name="index-desc-4780"></a><a name="index-tag-4781"></a><a name="index-default-4782"></a><br><dt><code>desc ("</code><var>expression</var><code>")</code><dt><code>tag ("</code><var>constant</var><code>")</code><dt><code>default</code><dd>
类型机构需要知道 <code>union</code> 的哪一个域是当前活跃的。这是通过赋给每个
域一个常数 <code>tag</code> 值，并且使用 <code>desc</code> 指定一个判别器来完成的。
由 <code>desc</code> 给出的表达式的值用来与每个 <code>tag</code> 值比较，每个
<code>tag</code> 值应该不同。如果没有 <code>tag</code> 匹配，则会使用标记为
<code>default</code> 的域。

     <p>在 <code>desc</code> 选项中，“当前结构体”是指要进行判别的联合体，可以使用
<code>%1</code> 来指定。 <code>tag</code> 选项没有换码符可用，因为其为常数。

     <p>例如,

     <pre class="smallexample">          struct tree_binding GTY(())
          {
            struct tree_common common;
            union tree_binding_u {
              tree GTY ((tag ("0"))) scope;
              struct cp_binding_level * GTY ((tag ("1"))) level;
            } GTY ((desc ("BINDING_HAS_LEVEL_P ((tree)&amp;%0)"))) xscope;
            tree value;
          };
</pre>
     <p>在这个例子中，当BINDING_HAS_LEVEL_P应用到 <code>struct tree_binding*</code>
时，其值会被假设为0或者1。如果是1，类型机制则会认为域 <code>level</code> 存在，
如果是0，则会认为域 <code>scope</code> 存在。

     <p><a name="index-param_005fis-4783"></a><a name="index-use_005fparam-4784"></a><br><dt><code>param_is (</code><var>type</var><code>)</code><dt><code>use_param</code><dd>
有时候，定义某种数据结构作为通用指针（也就是 <code>PTR</code>），并且与特定
类型一起使用是比较方便的。<code>param_is</code> 指定了所指向的真正类型，
<code>use_param</code> 说明了该类型应该放在通用数据结构的哪个地方。

     <p>例如，为了让 <code>htab_t</code> 指向trees，则应该像这样来写 <code>htab_t</code>
的定义：

     <pre class="smallexample">          typedef struct GTY(()) {
            ...
            void ** GTY ((use_param, ...)) entries;
            ...
          } htab_t;
</pre>
     <p>然后按这种方式声明变量：
     <pre class="smallexample">            static htab_t GTY ((param_is (union tree_node))) ict;
</pre>
     <p><a name="index-param_0040var_007bn_007d_005fis-4785"></a><a name="index-use_005fparam_0040var_007bn_007d-4786"></a><br><dt><code>param</code><var>n</var><code>_is (</code><var>type</var><code>)</code><dt><code>use_param</code><var>n</var><dd>
在更复杂的情况下，数据结构可能需要工作在多个不同类型之上，而且这些类型
也不必都是指针。对于这样的，可以使用 <code>param1_is</code> 到
<code>param9_is</code> 来指定由 <code>use_param1</code> 到 <code>use_param9</code> 标识的
实际类型域。

     <p><a name="index-use_005fparams-4787"></a><br><dt><code>use_params</code><dd>
当结构体包含另一个参数化的结构体时，不需要做特别的处理，内部结构体会继
承外部的参数。当结构体包含指向一个参数化的结构体的指针时，类型机构不会
自动检测到（是应该可以的，只是还没有实现），所以需要告诉类型机构所指向
的结构体将使用外部结构体的相同参数。这可以通过使用 <code>usr_params</code>
选项来标识指针。

     <p><a name="index-deletable-4788"></a><br><dt><code>deletable</code><dd>
将 <code>deletable</code> 应用到全局变量上时，表示当垃圾收集运行时，不需要标记
由该变量指向的任何对象，可以只是将其设为 <code>NULL</code>。这可以用来维护一个
可以重用的空闲结构体列表。

     <p><a name="index-if_005fmarked-4789"></a><br><dt><code>if_marked ("</code><var>expression</var><code>")</code><dd>
假设你想要一些类别的对象是唯一的，并且为此你将它们放在了哈希表中。如果垃
圾搜集标记了哈希表，这些对象将永远不会被释放掉，即使最后一个引用也不存在。
对此GCC有特定的处理方式：如果你使用 <code>if_marked</code> 选项在一个全局哈希表
上，GCC将会对每个哈希表项调用该选项参数命名的函数。如果函数返回非0，哈希
表项将按照通常的方式被标记，如果返回0，则哈希表项将会被删除。

     <p>函数 <code>ggc_marded_p</code> 可以用来判断一个元素是否已经被标记。实际上，通常
的情况是使用 <code>if_marked ("ggc_marked_p")</code>。

     <p><a name="index-mark_005fhook-4790"></a><br><dt><code>mark_hook ("</code><var>hook-routine-name</var><code>")</code><dd>
如果用在结构体或者联合体类型上，给出的（双引号之间的）
<var>hook-routine-name</var> 则为一个函数名，其在垃圾搜集器刚刚标记数据为可达
（reachable）时会被调用。该函数不应该改变数据，或者调用任何ggc函数。它的
唯一参数是一个指向刚刚被标记的结构体或联合体的指针。

     <p><a name="index-maybe_005fundef-4791"></a><br><dt><code>maybe_undef</code><dd>
当应用到一个域时，<code>maybe_undef</code> 表示可以允许该域所指向的结构体没有被
定义，只要该域总是为 <code>NULL</code>。这可以用来避免要求后端去定义一些可选的
结构体。该选项对语言前端不起作用。

     <p><a name="index-nested_005fptr-4792"></a><br><dt><code>nested_ptr (</code><var>type</var><code>, "</code><var>to expression</var><code>", "</code><var>from expression</var><code>")</code><dd>
类型设备期望所有指针都指向一个对象的起始处。有时候出于抽象目的，使用指向
对象内部的指针是比较方便的。只要能够对原始对象和指针进行相互转换，这样的
指针还是可以使用的。<var>type</var> 是原始对象的类型，<var>to expression</var> 返回
给定原始对象的指针，<var>from expression</var> 返回给定指针的原始对象。指针可
以使用 <code>%h</code> 转换符得到。

     <p><a name="index-chain_005fnext-4793"></a><a name="index-chain_005fprev-4794"></a><a name="index-chain_005fcircular-4795"></a><br><dt><code>chain_next ("</code><var>expression</var><code>")</code><dt><code>chain_prev ("</code><var>expression</var><code>")</code><dt><code>chain_circular ("</code><var>expression</var><code>")</code><dd>
让类型设备知道对象是否经常被链接在长的链表中是有帮助作用的。这可以让其
使用遍历链表的方式来替代递归调用，从而使得生成的代码使用很少的栈空间。
<code>chain_next</code> 是链表中的下一项，<code>chain_prev</code> 是前一项。对于单
向链表，只使用 <code>chain_next</code>；对于双向链表，两者都使用。设备要求对
一个项求 <code>chain_prev</code>，然后 <code>chain_next</code>，可以得到原始的项。

     <p><a name="index-reorder-4796"></a><br><dt><code>reorder ("</code><var>function name</var><code>")</code><dd>
一些数据结构依赖于相应的指针顺序。如果预编译头文件设备需要改变顺序，其
将会调用由 <code>reorder</code> 选项指定的函数。函数必须接收4个参数，
&lsquo;<samp><span class="samp">void&nbsp;*,&nbsp;void&nbsp;*,&nbsp;gt_pointer_operator,&nbsp;void&nbsp;*<!-- /@w --></span></samp>&rsquo;。第一个参数是指
向更新对象的结构体的指针，或者对象本身，如果没有包含的结构体。第二个参
数为一个cookie，目前被忽略。第三个参数是一个函数，给定指针，将会更新该
指针为正确的新值。第四个参数是一个cookie，且必须传给第二个参数。

     <p>PCH无法处理依赖于指针绝对值得数据结构。<code>reorder</code> 函数代价很高。在
可能的情况下，最好依赖于数据的属性，像ID号或者字符串的哈希值。

     <p><a name="index-special-4797"></a><br><dt><code>special ("</code><var>name</var><code>")</code><dd>
<code>special</code> 选项用来标记类型必须由特定情况的机制来处理。参数是特定
情况的名字。详细信息参见 <samp><span class="file">gengtype.c</span></samp>。应避免添加新的特定情况，除
非没有别的办法。
</dl>

 </body></html>

