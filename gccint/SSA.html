<html lang="en">
<head>
<title>SSA - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tree-SSA.html#Tree-SSA" title="Tree SSA">
<link rel="prev" href="SSA_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#SSA_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0" title="SSA操作数">
<link rel="next" href="_00e5_0088_00ab_00e5_0090_008d_00e5_0088_0086_00e6_009e_0090.html#g_t_00e5_0088_00ab_00e5_0090_008d_00e5_0088_0086_00e6_009e_0090" title="别名分析">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="SSA"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_0088_00ab_00e5_0090_008d_00e5_0088_0086_00e6_009e_0090.html#g_t_00e5_0088_00ab_00e5_0090_008d_00e5_0088_0086_00e6_009e_0090">别名分析</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="SSA_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0.html#SSA_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0">SSA操作数</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tree-SSA.html#Tree-SSA">Tree SSA</a>
<hr>
</div>

<h3 class="section">13.3 静态单赋值</h3>

<p><a name="index-SSA-3053"></a><a name="index-static-single-assignment-3054"></a>
大多数树优化器都依赖于静态单赋值（SSA）形式所提供的数据流信息。
我们是按照<cite>R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and
K. Zadeck.  Efficiently Computing Static Single Assignment Form and the
Control Dependence Graph.  ACM Transactions on Programming Languages
and Systems, 13(4):451-490, October 1991</cite>中的描述来实现SSA形式的。

 <p>SSA形式基于的前提是程序变量只在程序中的一个位置被赋值。
对同一变量的多次赋值将创建那个变量的新的版本。
实际的程序最初自然很少是SSA形式的，因为变量一般会被赋值多次。
编译器修改程序表示，使得代码中每次变量被赋值的时候，便会创建一个新版本的变量。
不同版本的同一变量通过变量名字的版本号作为下标来区分开。
在表达式右端使用的变量被重命名，使得它们的版本号匹配最近的赋值。

 <p>我们使用<code>SSA_NAME</code>节点来表示变量版本。
<samp><span class="file">tree-ssa.c</span></samp>中的重命名程序将每个实操作数和虚操作数，
用包含了版本号和创建<code>SSA_NAME</code>的语句的<code>SSA_NAME</code>节点包裹起来。
只有定义和虚定义可能会创建新的<code>SSA_NAME</code>节点。

 <p><a name="index-PHI-nodes-3055"></a>有时，控制流使得无法确定变量的最近版本是多少。这种情况下，
编译器插入一个那个变量的人造定义，称作<dfn>PHI function</dfn>或者<dfn>PHI node</dfn>。
这个新的定义将变量的所有可能引入的版本合并一起，以创建一个新的名字。例如，

<pre class="smallexample">     if (...)
       a_1 = 5;
     else if (...)
       a_2 = 2;
     else
       a_3 = 13;
     
     # a_4 = PHI &lt;a_1, a_2, a_3&gt;
     return a_4;
</pre>
 <p>由于不可能确定在运行时，将运行三个分支中的哪一个，
所以我们不知道在return语句中要使用<code>a_1</code>,<code>a_2</code>或<code>a_3</code>中的哪一个。
因此，SSA重命名将会创建一个新的版本a_4，其被赋值为“合并”a_1, a_2和a_3的结果。
因此，PHI节点意味着“这些操作数中的一个，我不知道是哪一个”。

 <p>下面的宏可以用来检查PHI节点。

<div class="defun">
&mdash; Macro: <b>PHI_RESULT</b> (<var>phi</var>)<var><a name="index-PHI_005fRESULT-3056"></a></var><br>
<blockquote><p>返回由PHI节点<var>phi</var>(即, <var>phi</var>'s LHS)创建的<code>SSA_NAME</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_NUM_ARGS</b> (<var>phi</var>)<var><a name="index-PHI_005fNUM_005fARGS-3057"></a></var><br>
<blockquote><p>返回<var>phi</var>中的参数个数。这个数目就是持有<var>phi</var>的基本块所引入的边的数目。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_ARG_ELT</b> (<var>phi, i</var>)<var><a name="index-PHI_005fARG_005fELT-3058"></a></var><br>
<blockquote><p>返回<var>phi</var>的第<var>i</var>个参数的tuple表示。
tuple中的每个元素包含了一个<code>SSA_NAME</code> <var>var</var>和<var>var</var>借以流向的引入边。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_ARG_EDGE</b> (<var>phi, i</var>)<var><a name="index-PHI_005fARG_005fEDGE-3059"></a></var><br>
<blockquote><p>返回<var>phi</var>的第<var>i</var>个参数对应的引入边。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PHI_ARG_DEF</b> (<var>phi, i</var>)<var><a name="index-PHI_005fARG_005fDEF-3060"></a></var><br>
<blockquote><p>返回<var>phi</var>的第<var>i</var>个参数的<code>SSA_NAME</code>。
</p></blockquote></div>

<h4 class="subsection">13.3.1 保持SSA形式</h4>

<p><a name="index-update_005fssa-3061"></a><a name="index-preserving-SSA-form-3062"></a>一些优化过程会改变函数并使得不再具有SSA特性。
这可能会发生在当一个过程增加了新的符号或者改变了程序使得变量不再被别名的时候。
不管什么时候发生类似的情况，受到影响的符号必须被再次重命名为SSA形式。
产生新代码或者替代存在的语句的转换也需要更新SSA形式。

 <p>由于GCC为寄存器和虚变量实现了两种不同的SSA形式，
所有保持SSA形式的更新取决于你是否正在更新寄存器或者虚名字。
这两种情况对于不断的SSA更新的背后思想是类似的：当新的SSA名字被创建时，
它们通常意味着要替换程序中的其它存在的名字。

 <p>例如，给定下列代码：

<pre class="smallexample">          1  L0:
          2  x_1 = PHI (0, x_5)
          3  if (x_1 &lt; 10)
          4    if (x_1 &gt; 7)
          5      y_2 = 0
          6    else
          7      y_3 = x_1 + x_7
          8    endif
          9    x_5 = x_1 + 1
          10   goto L0;
          11 endif
</pre>
 <p>假设我们插入了新的名字<code>x_10</code>和<code>x_11</code>（第<code>4</code>行和第<code>8</code>行）。

<pre class="smallexample">          1  L0:
          2  x_1 = PHI (0, x_5)
          3  if (x_1 &lt; 10)
          4    x_10 = ...
          5    if (x_1 &gt; 7)
          6      y_2 = 0
          7    else
          8      x_11 = ...
          9      y_3 = x_1 + x_7
          10   endif
          11   x_5 = x_1 + 1
          12   goto L0;
          13 endif
</pre>
 <p>我们想使用<code>x_10</code>和<code>x_11</code>的新的定义来替换<code>x_1</code>的所有使用。
注意将要被替换的使用只在行<code>5</code>, <code>9</code>和<code>11</code>中。而且，
第<code>9</code>行<code>x_7</code>的使用不应被替换
（这就是为什么我们不能仅仅标记符号<code>x</code>为重命名）。

 <p>另外，我们可能需要在第<code>11</code>行插入一个PHI节点，
因为有一个<code>x_10</code>和<code>x_11</code>的合并点。
所以<code>x_1</code>在第<code>11</code>行的使用将用新的PHI节点来替换。
PHI节点的插入是可选的。它们并不完全必要用于保持SSA形式，
并且取决于调用者的插入内容，它们可能对优化器没有用处。

 <p>更新SSA形式分为两步。首先，过程必须分别出哪些名字需要被更新，
以及哪些符号需要被重命名为SSA形式。当新的名字被引入以替换程序中现存的名字时，
新旧名字之间的映射通过调用<code>register_new_name_mapping</code>来注册
（注意如果你的过程通过复制基本块创建了新的代码，
对<code>tree_duplicate_bb</code>的调用将会自动建立所需的映射）。另一方面，
如果你的过程使得一个新的符号需要为SSA形式，
则新符号需要使用<code>mark_sym_for_renaming</code>来注册。

 <p>在替换映射被注册完，并且新符号被标记了要重命名后，
将会调用<code>update_ssa</code>来按照注册的进行改变。
这可以通过显示的调用或者为你的过程在<code>tree_opt_pass</code>结构体中创建
<code>TODO</code>标记来完成。
这里有几个<code>TODO</code>标记用于控制<code>update_ssa</code>的行为：

     <ul>
<li><code>TODO_update_ssa</code>. 
采用为新出现的符号插入PHI节点，以及虚名字进行标记的方式更新SSA形式。
当更新实名字时，只为<code>O_j</code>的所有新旧定义所到达的块中的实名字<code>O_j</code>
插入PHI节点。如果<code>O_j</code>的迭代的dominance边界没有被截枝，
我们可以在块中危机具有一个或多个没有即来定义的<code>O_j</code>结束插入PHI节点。
这将导致对<code>O_j</code>符号的未初始化警告。

     <li><code>TODO_update_ssa_no_phi</code>. 
不使用插入任何新PHI节点的方式来更新SSA形式。这被用于要自己插入所有PHI节点的
过程或者只需要更新use-def和def-def链的虚名字的过程（例如，DCE）。

     <li><code>TODO_update_ssa_full_phi</code>. 
在任何需要的地方都插入PHI节点。不进行IDF的截枝。
这被过程用于需要<code>O_j</code>的PHI节点的情况
（例如，<code>pass_linear_transform</code>）。

     <p>警告: 如果你需要使用这个标记，则有可能你的过程是在做一些错误的事情。
为一个旧名字插入PHI节点可能会导致沉默的codegen错误或者虚假的未初始化警告。

     <li><code>TODO_update_ssa_only_virtuals</code>. 
自己更新SSA的过程可能想要使用虚名字更新来代表通用的更新。因为FUD链易于维护，
所有这简化了他们所需的工作。注意：如果使用了该标记，
则任何实名字OLD-&gt;NEW的映射将被显式的破坏，只有标记为重命名的符合被处理。
</ul>

<h4 class="subsection">13.3.2 保持虚SSA形式</h4>

<p><a name="index-preserving-virtual-SSA-form-3063"></a>
虚SSA形式比非虚SSA形式要难以保持，主要是因为语句的虚操作数集可能会意外的改变。
通常，语句修改应该被对<code>push_stmt_changes</code>和<code>pop_stmt_changes</code>的调用
所包裹。例如，

<pre class="smallexample">         munge_stmt (tree stmt)
         {
            push_stmt_changes (&amp;stmt);
            ... rewrite STMT ...
            pop_stmt_changes (&amp;stmt);
         }
</pre>
 <p>对<code>push_stmt_changes</code>的调用保存了语句操作数的当前状态，
对<code>pop_stmt_changes</code>的调用比较保存的状态和现在的，
并对适当的符号标记为SSA重命名。

 <p>当处理一个语句栈时，通过使用LIFO顺序来调用<code>push_stmt_changes</code>和
<code>pop_stmt_changes</code>，可以一次修改多条语句。

 <p>另外，如果过程在调用<code>push_stmt_changes</code>后发现它不需要改变语句，
它可以通过调用<code>discard_stmt_changes</code>来简单的丢弃最顶层的缓存。
这将避免用来确定是否符合需要被标记为重命名所需的昂贵的操作数重扫描操作和缓存比较。

<h4 class="subsection">13.3.3 检验<code>SSA_NAME</code>节点</h4>

<p><a name="index-examining-SSA_005fNAMEs-3064"></a>
下面的宏可以用来检查<code>SSA_NAME</code>节点

<div class="defun">
&mdash; Macro: <b>SSA_NAME_DEF_STMT</b> (<var>var</var>)<var><a name="index-SSA_005fNAME_005fDEF_005fSTMT-3065"></a></var><br>
<blockquote><p>返回创建<code>SSA_NAME</code> <var>var</var>的语句<var>s</var>。
如过<var>s</var>是空语句（即，<code>IS_EMPTY_STMT (</code><var>s</var><code>)</code>返回<code>true</code>），
则意味着对该变量的第一个引用是一个USE或者VUSE。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SSA_NAME_VERSION</b> (<var>var</var>)<var><a name="index-SSA_005fNAME_005fVERSION-3066"></a></var><br>
<blockquote><p>返回<code>SSA_NAME</code>对象<var>var</var>的版本号。
</p></blockquote></div>

<h4 class="subsection">13.3.4 遍历use-def链</h4>

<div class="defun">
&mdash; Tree SSA function: void <b>walk_use_def_chains</b> (<var>var, fn, data</var>)<var><a name="index-walk_005fuse_005fdef_005fchains-3067"></a></var><br>
<blockquote>
      <p>对use-def链的遍历起始于<code>SSA_NAME</code>节点<var>var</var>。
对每一个发现的可达定义调用函数<var>fn</var>。函数<var>fn</var>接受三个参数：<var>var</var>，
它的定义语句（<var>def_stmt</var>）和一个通用指针指向<var>fn</var>可能想要维护的任何状态
信息（数据）。函数<var>fn</var>可以通过返回<code>true</code>来停止遍历，否则要继续遍历，
<var>fn</var>应该返回<code>false</code>。

      <p>注意，如果<var>def_stmt</var>是一个<code>PHI</code>节点，则语法有点不同。
对PHI节点的每个参数<var>arg</var>，该函数将：

          <ol type=1 start=1>
<li>为<var>arg</var>遍历use-def链
<li>调用<code>FN (</code><var>arg</var><code>, </code><var>phi</var><code>, </code><var>data</var><code>)</code>.
           </ol>

      <p>注意不管<var>fn</var>的第一个是否还是最初的变量<var>var</var>，目前都会检测PHI的参数。
如果<var>fn</var>想获得<var>var</var>，则应该调用<code>PHI_RESULT</code> (<var>phi</var>)。
</p></blockquote></div>

<h4 class="subsection">13.3.5 遍历支配树</h4>

<div class="defun">
&mdash; Tree SSA function: void <b>walk_dominator_tree</b> (<var>walk_data, bb</var>)<var><a name="index-walk_005fdominator_005ftree-3068"></a></var><br>
<blockquote>
      <p>该函数遍历当前CFG的支配树，
并调用在<samp><span class="file">domwalk.h</span></samp>中<var>struct dom_walk_data</var>里定义的一系列回调函数。
你所需要定义的回调函数可以用于在遍历过程中的不同点执行自定义的代码：

          <ol type=1 start=1>
<li>当处理<var>bb</var>和它的孩子（children）时，在初始化所需要的任何局部数据的时候。
该局部数据被压入一个内部的栈中，该栈在遍历支配树时会被自动的压入和弹出。

          <li>在遍历<var>bb</var>中的所有语句之前。

          <li>对于<var>bb</var>中的每条语句。

          <li>当遍历过所有语句之后，并在递归到<var>bb</var>的支配孩子之前。

          <li>然后递归到<var>bb</var>的所有支配孩子。

          <li>在递归到<var>bb</var>的所有支配孩子之后，可选的，
重新遍历<var>bb</var>中的每条语句（即，重复步骤2和3）。

          <li>当遍历完<var>bb</var>和<var>bb</var>的支配孩子中的所有语句之后。这时，块局部数据栈被弹出。
           </ol>
</p></blockquote></div>

 </body></html>

