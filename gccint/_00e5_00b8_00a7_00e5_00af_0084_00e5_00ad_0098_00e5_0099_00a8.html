<html lang="zh">
<head>
<title>帧寄存器 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link rel="prev" href="_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5.html#g_t_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5" title="栈检查">
<link rel="next" href="_00e6_00b6_0088_00e9_0099_00a4.html#g_t_00e6_00b6_0088_00e9_0099_00a4" title="消除">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%b8%a7%e5%af%84%e5%ad%98%e5%99%a8"></a>
<a name="g_t_00e5_00b8_00a7_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00b6_0088_00e9_0099_00a4.html#g_t_00e6_00b6_0088_00e9_0099_00a4">消除</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5.html#g_t_00e6_00a0_0088_00e6_00a3_0080_00e6_009f_00a5">栈检查</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>
<hr>
</div>

<h4 class="subsection">17.10.4 用于栈帧寻址的寄存器</h4>

<!-- prevent bad page break with this line -->
<p>这里讨论了用于栈帧寻址的寄存器。

<div class="defun">
&mdash; Macro: <b>STACK_POINTER_REGNUM</b><var><a name="index-STACK_005fPOINTER_005fREGNUM-4001"></a></var><br>
<blockquote><p>栈指针寄存器的寄存器编号，其还必须为一个<code>FIXED_REGISTERS</code>中的固定寄存器。
在大多数机器上，硬件决定了这是哪个寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FRAME_POINTER_REGNUM</b><var><a name="index-FRAME_005fPOINTER_005fREGNUM-4002"></a></var><br>
<blockquote><p>帧指针寄存器的寄存器编号，其用于访问在栈帧中的自动变量。
在一些机器上，硬件决定了这是哪个寄存器。
在其它机器上，你可以选择任意寄存器来达到该目的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_FRAME_POINTER_REGNUM</b><var><a name="index-HARD_005fFRAME_005fPOINTER_005fREGNUM-4003"></a></var><br>
<blockquote><p>在一些机器上，帧指针和自动变量的起始处之间的偏移量直到寄存器分配进行完之后才知道
（例如，因为保存寄存器位于这两个位置之间）。这些机器上，
定义<code>FRAME_POINTER_REGNUM</code>为一个特定的固定寄存器的编号，在内部使用，
直到位移已知，并且定义<code>HARD_FRAME_POINTER_REGNUM</code>为实际的硬件寄存器，
用于帧指针。

      <p>你只需要在非常少见的情况下定义该宏，当不可能计算帧指针和自动变量的偏移时，
并且直到寄存器分配完成。当该宏被定义，
你必须还要在你的<code>ELIMINABLE_REGS</code>的定义中指示如果消除
<code>FRAME_POINTER_REGNUM</code>为<code>HARD_FRAME_POINTER_REGNUM</code>或者
<code>STACK_POINTER_REGNUM</code>。

      <p>如果其与<code>FRAME_POINTER_REGNUM</code>相同，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ARG_POINTER_REGNUM</b><var><a name="index-ARG_005fPOINTER_005fREGNUM-4004"></a></var><br>
<blockquote><p>arg指针寄存器的寄存器编号，其用于访问函数的参数列表。在大多数机器上，
这与帧指针寄存器相同。在一些机器上，硬件决定了其为那个寄存器。在其它机器上，
你可以选择任意的寄存器。如果这与帧指针寄存器不同，
则你必须标记其为一个固定寄存器，
根据<code>FIXED_REGISTERS</code>或者设法能够消除它（参见<a href="_00e6_00b6_0088_00e9_0099_00a4.html#g_t_00e6_00b6_0088_00e9_0099_00a4">消除</a>）。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>RETURN_ADDRESS_POINTER_REGNUM</b><var><a name="index-RETURN_005fADDRESS_005fPOINTER_005fREGNUM-4005"></a></var><br>
<blockquote><p>返回地址指针寄存器的寄存器编号，其用于访问栈中当前函数的返回地址。
在一些机器上，返回地址不在帧指针或栈指针或参数指针的固定偏移处。
该寄存器被定义指向栈中的返回地址，
并且然后通过<code>ELIMINABLE_REGS</code>转换为帧指针或者栈指针。

      <p>不要定义该宏，除非没有其他的方式从栈中获得返回地址。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STATIC_CHAIN_REGNUM</b><var><a name="index-STATIC_005fCHAIN_005fREGNUM-4006"></a></var><br>
&mdash; Macro: <b>STATIC_CHAIN_INCOMING_REGNUM</b><var><a name="index-STATIC_005fCHAIN_005fINCOMING_005fREGNUM-4007"></a></var><br>
<blockquote><p>用于传递函数static链指针的寄存器编号。如果寄存器窗口被使用，
则寄存器编号由被调用函数所看到是<code>STATIC_CHAIN_INCOMING_REGNUM</code>，
而由调用者函数看到的是<code>STATIC_CHAIN_REGNUM</code>。如果这些寄存器是相同的，
则不需要定义<code>STATIC_CHAIN_INCOMING_REGNUM</code>。

      <p>静态链寄存器不需要为一个固定寄存器。

      <p>如果静态链在内存中传递，则这些宏不需要定义；替代的，应该定义下面的两个宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STATIC_CHAIN</b><var><a name="index-STATIC_005fCHAIN-4008"></a></var><br>
&mdash; Macro: <b>STATIC_CHAIN_INCOMING</b><var><a name="index-STATIC_005fCHAIN_005fINCOMING-4009"></a></var><br>
<blockquote><p>如果静态链在内存中传递，则这些宏提供了给出它们存储的<code>mem</code>表达式rtx。
<code>STATIC_CHAIN</code>和<code>STATIC_CHAIN_INCOMING</code>分别给出了由调用者和被调用函数
所看到的位置。通常前者将在栈指针的一个偏移处并且后者将在帧指针的一个偏移处。

      <p><a name="index-stack_005fpointer_005frtx-4010"></a><a name="index-frame_005fpointer_005frtx-4011"></a><a name="index-arg_005fpointer_005frtx-4012"></a>变量<code>stack_pointer_rtx</code>, <code>frame_pointer_rtx</code>和<code>arg_pointer_rtx</code>将在使用这些宏之前被初始化，并可以引用。

      <p>如果静态链在寄存器中传递，则应该定义之前的两个宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF_FRAME_REGISTERS</b><var><a name="index-DWARF_005fFRAME_005fREGISTERS-4013"></a></var><br>
<blockquote><p>该宏指定了可以在一个调用帧中被保存的硬件寄存器的最大数。
这用于DWARF2异常处理中的size数据结构体。

      <p>在GCC3.0之前，该宏需要用来建立一个稳定的异常处理ABI。

      <p>如果该宏没有被定义，其缺省为<code>FIRST_PSEUDO_REGISTER</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRE_GCC3_DWARF_FRAME_REGISTERS</b><var><a name="index-PRE_005fGCC3_005fDWARF_005fFRAME_005fREGISTERS-4014"></a></var><br>
<blockquote><p>该宏类似于<code>DWARF_FRAME_REGISTERS</code>，是为了向后兼容在GCC3.0之前编译的代码而提供。

      <p>如果没有定义该宏，其缺省为<code>DWARF_FRAME_REGISTERS</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF_REG_TO_UNWIND_COLUMN</b> (<var>regno</var>)<var><a name="index-DWARF_005fREG_005fTO_005fUNWIND_005fCOLUMN-4015"></a></var><br>
<blockquote><p>定义该宏，如果target对于dwarf寄存器的表示与对于unwind column的内部表示不相同。
给定一个dwarf寄存器，该宏应该返回替代使用的内部unwind column编号。

      <p>例子参见PowerPC's SPE target。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF_FRAME_REGNUM</b> (<var>regno</var>)<var><a name="index-DWARF_005fFRAME_005fREGNUM-4016"></a></var><br>
<blockquote><p>定义该宏，如果target对于用在.eh_frame或者.debug_frame的dwarf寄存器的表示与用在
其它调试信息section中的不同。给定一个GCC硬件寄存器编号，该宏应该返回.eh_frame
寄存器编号。缺省为<code>DBX_REGISTER_NUMBER (</code><var>regno</var><code>)</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF2_FRAME_REG_OUT</b> (<var>regno, for_eh</var>)<var><a name="index-DWARF2_005fFRAME_005fREG_005fOUT-4017"></a></var><br>
<blockquote><p>定义该宏来影射在调用帧信息中存放的寄存器编号，
其为GCC使用<code>DWARF_FRAME_REGNUM</code>来搜集的应该放在.debug_frame
（<var>for_eh</var>为0）和.eh_frame（<var>for_eh</var>为非0）中的寄存器。
缺省为返回<var>regno</var>。
</p></blockquote></div>

 </body></html>

