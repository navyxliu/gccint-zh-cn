<html lang="zh">
<head>
<title>其它 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f" title="目标宏">
<link rel="prev" href="C_002b_002b-ABI.html#C_002b_002b-ABI" title="C++ ABI">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%85%b6%e5%ae%83"></a>
<a name="g_t_00e5_0085_00b6_00e5_00ae_0083"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="C_002b_002b-ABI.html#C_002b_002b-ABI">C++ ABI</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f.html#g_t_00e7_009b_00ae_00e6_00a0_0087_00e5_00ae_008f">目标宏</a>
<hr>
</div>

<h3 class="section">17.30 其它参数</h3>

<p><a name="index-parameters_002c-miscellaneous-4625"></a>
<!-- prevent bad page break with this line -->
这是一些其它参数。

<div class="defun">
&mdash; Macro: <b>HAS_LONG_COND_BRANCH</b><var><a name="index-HAS_005fLONG_005fCOND_005fBRANCH-4626"></a></var><br>
<blockquote><p>定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的条件分支转换为无条件分支或间接跳转。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HAS_LONG_UNCOND_BRANCH</b><var><a name="index-HAS_005fLONG_005fUNCOND_005fBRANCH-4627"></a></var><br>
<blockquote><p>定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的无条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的无条件分支转换为间接跳转。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_VECTOR_MODE</b><var><a name="index-CASE_005fVECTOR_005fMODE-4628"></a></var><br>
<blockquote><p>机器模式名字的一个别名。这是跳转表（jump-table）的元素应该具有的机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_VECTOR_SHORTEN_MODE</b> (<var>min_offset, max_offset, body</var>)<var><a name="index-CASE_005fVECTOR_005fSHORTEN_005fMODE-4629"></a></var><br>
<blockquote><p>可选的：当最小值和最大值位移已知时，返回<code>addr_diff_vec</code>的首选机器模式。
如果定义了该宏，这使得在分支缩短中增加了额外的代码来处理<code>addr_diff_vec</code>。
要使其工作，还必须要定义<code>INSN_ALIGN</code>，
并且显示的对<code>addr_diff_vec</code>进行对齐。参数<var>body</var>被提供，
使得可以更新<code>offset_unsigned</code>和标量标记。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_VECTOR_PC_RELATIVE</b><var><a name="index-CASE_005fVECTOR_005fPC_005fRELATIVE-4630"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，来指示跳转表什么时候应该包含相对地址。
你不需要定义该宏，如果跳转表从来不包含相对地址，
或者跳转表只在<samp><span class="option">-fPIC</span></samp>或者<samp><span class="option">-fPIC</span></samp>有效时才包含相对地址。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_VALUES_THRESHOLD</b><var><a name="index-CASE_005fVALUES_005fTHRESHOLD-4631"></a></var><br>
<blockquote><p>定义其为一个最小差值数，用于选择是使用跳转表来替代条件分支树。
缺省为4，对于具有<code>casesi</code>指令的机器，其它的为5。这对大多数机器是最好的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_USE_BIT_TESTS</b><var><a name="index-CASE_005fUSE_005fBIT_005fTESTS-4632"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，来指示C switch语句是否可以通过位测试序列来实现。
这在可以通过寄存器中的位数来有效实现左移1位的处理器上很有利，
但不适合需要循环的target。缺省下，该宏返回<code>true</code>，
如果target定义了<code>ashlsi3</code>指令模式，否则返回<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WORD_REGISTER_OPERATIONS</b><var><a name="index-WORD_005fREGISTER_005fOPERATIONS-4633"></a></var><br>
<blockquote><p>定义该宏，如果整数机器模式的小于一个字的寄存器间的运算总是在整个寄存器中执行。
大多数RISC机器具有这个属性，大多数CISC机器不具有。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LOAD_EXTEND_OP</b> (<var>mem_mode</var>)<var><a name="index-LOAD_005fEXTEND_005fOP-4634"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，
指示当insn使用比一个字窄的的整数模式的<var>mem_mode</var>模式读取内存时，
将读取的数据的<var>mem_mode</var>外的位进行符号扩展或者零扩展。
返回<code>SIGN_EXTEND</code>，对于那些要符号扩展的insn，
返回<code>ZERO_EXTEND</code>对那些零扩展的，对于其它的机器模式返回<code>UNKNOWN</code>。

      <p>该宏不会被非整型的，或者宽度大于等于<code>BITS_PER_WORD</code>的<var>mem_mode</var>调用，
所以对于这种情况你可以返回任何值。如果总是返回<code>UNKNOWN</code>，则不要定义该宏。
在定义该宏的机器上，你通常要定义其为常量<code>SIGN_EXTEND</code>或者<code>ZERO_EXTEND</code>。

      <p>你可以返回一个非<code>UNKNOWN</code>的值，即使对于一些硬件寄存器并没有执行符号扩展，如果对于这些硬件寄存器的<code>REGNO_REG_CLASS</code>，当<var>from</var>机器模式为<var>mem_mode</var>，并且<var>to</var>机器模式为任何大于其但是不大于<code>word_mode</code>的整形机器模式的时候，<code>CANNOT_CHANGE_MODE_CLASS</code>返回非零。

      <p>你必须返回<code>UNKNOWN</code>，如果一些硬件寄存器允许该机器模式，<code>CANNOT_CHANGE_MODE_CLASS</code>说它们不能变成<code>word_mode</code>，但是它们可以变成其它大于<var>mem_mode</var>且仍然小于<code>word_mode</code>的整形机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SHORT_IMMEDIATES_SIGN_EXTEND</b><var><a name="index-SHORT_005fIMMEDIATES_005fSIGN_005fEXTEND-4635"></a></var><br>
<blockquote><p>定义该宏，如果将short立即数加载到寄存器中要进行符号扩展。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FIXUNS_TRUNC_LIKE_FIX_TRUNC</b><var><a name="index-FIXUNS_005fTRUNC_005fLIKE_005fFIX_005fTRUNC-4636"></a></var><br>
<blockquote><p>定义该宏，如果将浮点数转换为有符号定点数的指令，
同样可以有效的转换为无符号的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_MIN_DIVISIONS_FOR_RECIP_MUL</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fMIN_005fDIVISIONS_005fFOR_005fRECIP_005fMUL-4637"></a></var><br>
<blockquote><p>当<samp><span class="option">-ffast-math</span></samp>有效时，GCC尝试使用相同的除数来优化除法，
通过将它们转换为乘以倒数的方式。
缺省实现返回3，如果机器具有除法指令，否则为2。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_MAX</b><var><a name="index-MOVE_005fMAX-4638"></a></var><br>
<blockquote><p>单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_MOVE_MAX</b><var><a name="index-MAX_005fMOVE_005fMAX-4639"></a></var><br>
<blockquote><p>单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
如果没有定义，则缺省为<code>MOVE_MAX</code>。
否则，其为<code>MOVE_MAX</code>在运行时可以具有的最大常数值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SHIFT_COUNT_TRUNCATED</b><var><a name="index-SHIFT_005fCOUNT_005fTRUNCATED-4640"></a></var><br>
<blockquote><p>一个C表达式，为非零，如果在该机器上，实际用于计算移位运算的位数等同于，用来表示被移位的对象大小的位数。当该宏为非零的时候，编译器将假设可以安全的忽略掉对移位运算的计数进行截取的有符号扩展，零扩展和按位与指令。在一些机器上，具有指令可以作用于可变位置的位域，其可能会包含‘位测试’指令，非零的<code>SHIFT_COUNT_TRUNCATED</code>还可以使得作为位域指令参数的值的截取运算。

      <p>如果指令会截取计数（对于位移运算）和位置（对于位域运算），或者如果没有可变位置的位域指令存在，则你应该定义该宏。

      <p>然而，在一些机器上，例如80386和680x0，截取操作只应用在移位运算上，而不在位域运算上。在这样的机器上，定义<code>SHIFT_COUNT_TRUNCATED</code>为零。可替代的，在<samp><span class="file">md</span></samp>文件中增加指令模式，包含对移位指令隐式的截取操作。

      <p>如果其值总是为零，则不需要定义该宏。
</p></blockquote></div>

 <p><a name="TARGET_005fSHIFT_005fTRUNCATION_005fMASK"></a>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SHIFT_TRUNCATION_MASK</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fSHIFT_005fTRUNCATION_005fMASK-4641"></a></var><br>
<blockquote><p>该函数描述了标准的移位指令模式，对于<var>mode</var>，如何处理负的数量或者大于机器模式宽度的数量的移位。
See <a href="shift-patterns.html#shift-patterns">shift patterns</a>.

      <p>在许多机器上，移位指令模式将会应用一个掩码<var>m</var>到移位计数上，意味着将<var>x</var>固定宽度移位<var>y</var>等价于对<var>x</var>任意宽度移位<var>y &amp; m</var>。如果这对机器模式<var>mode</var>为真，则函数应该返回<var>m</var>，否则应该返回0。返回值0意味着不保证特定的行为。

      <p>注意，不像<code>SHIFT_COUNT_TRUNCATED</code>，该函数不应用到通用的移位rtx上；其只应用到由命名移位指令模式生成的指令上。

      <p>该函数的缺省实现返回<code>GET_MODE_BITSIZE (</code><var>mode</var><code>) - 1</code>，如果<code>SHIFT_COUNT_TRUNCATED</code>，否则为0。该定义总是安全的，但是如果<code>SHIFT_COUNT_TRUNCATED</code>为假，并且一些移位指令模式还是截取移位计数，则你可以通过重写覆盖该宏来获得更好的代码。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TRULY_NOOP_TRUNCATION</b> (<var>outprec, inprec</var>)<var><a name="index-TRULY_005fNOOP_005fTRUNCATION-4642"></a></var><br>
<blockquote><p>一个C表达式，其为非零，如果在该机器上，将<var>inprec</var>个位数的整数转换成<var>outprec</var>个位数（<var>outprec</var>比<var>inprec</var>小），通过简单的认为其只具有<var>outprec</var>个位。

      <p>在许多机器上，该表达式可以为1。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_MODE_REP_EXTENDED</b> (<var>enum machine_mode mode, enum machine_mode rep_mode</var>)<var><a name="index-TARGET_005fMODE_005fREP_005fEXTENDED-4643"></a></var><br>
<blockquote><p>整型机器模式可以表示为一个值，其总是被扩展为更宽的整型模式。返回<code>SIGN_EXTEND</code>，如果机器模式为<var>mode</var>的值被表示为有符号扩展成<var>rep_mode</var>的形式。否则，返回<code>UNKNOWN</code>。（目前，没有目标机使用零扩展表示，所以不像<code>LOAD_EXTEND_OP</code>，<code>TARGET_MODE_REP_EXTENDED</code>被期望返回<code>SIGN_EXTEND</code>或者<code>UNKNOWN</code>。而且没有目标机将<var>mode</var>扩展为<var>mode_rep</var>，以至于<var>mode_rep</var>不是下一个最宽的整型机器模式，目前，我们利用了这个事实。）

      <p>类似于<code>LOAD_EXTEND_OP</code>，你可以返回一个非<code>UNKNOWN</code>的值，即使扩展在特定硬件寄存器上没有被执行，只要对于这些硬件寄存器的<code>REGNO_REG_CLASS</code>，<code>CANNOT_CHANGE_MODE_CLASS</code>返回非零。

      <p>注意，<code>TARGET_MODE_REP_EXTENDED</code>和<code>LOAD_EXTEND_OP</code>描述了两个相关联的属性。如果你定义了<code>TARGET_MODE_REP_EXTENDED (mode, word_mode)</code>，你可能还要定义<code>LOAD_EXTEND_OP (mode)</code>，来返回相同类型的扩展。

      <p>为了加强<code>mode</code>的表示，当截取成<code>mode</code>时，<code>TRULY_NOOP_TRUNCATION</code>应该返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STORE_FLAG_VALUE</b><var><a name="index-STORE_005fFLAG_005fVALUE-4644"></a></var><br>
<blockquote><p>一个C表达式，描述了整型机器模式的比较运算符返回的值，并且当条件为真时由存储标记指令(&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;)存储。该描述必须应用到所有的&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;指令模式，并且所有比较运算的结果必须具有<code>MODE_INT</code>机器模式。

      <p>值为1或者-1，意味着实现比较运算的指令当比较为真时返回确切的1或者-1，当比较为假时返回0。否则，值会表示当比较为真时结果的哪些位保证为1。该值按照比较运算的机器模式来解析，其由&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;指令模式中的第一个操作数的机器模式给出。目前，编译器只用到了<code>STORE_FLAG_VALUE</code>的低位或者符号位。

      <p>如果<code>STORE_FLAG_VALUE</code>不为1或者-1，则编译器将生成只依赖特定位的代码。其还可以用等价的运算来替换比较运算，如果它们会造成需要的位被设置，即使其它位没有被定义。例如，在比较运算返回一个<code>SImode</code>值的机器上，其<code>STORE_FLAG_VALUE</code>被定义为&lsquo;<samp><span class="samp">0x80000000</span></samp>&rsquo;，说明只有符号位是相关的，表达式

     <pre class="smallexample">          (ne:SI (and:SI <var>x</var> (const_int <var>power-of-2</var>)) (const_int 0))
</pre>
      <p class="noindent">可以被转换为

     <pre class="smallexample">          (ashift:SI <var>x</var> (const_int <var>n</var>))
</pre>
      <p class="noindent">其中<var>n</var>为适当的移位计数，用来将被测试的位移送到符号位。

      <p>没有办法来描述，一个机器对于真值，总是设置低顺序的位，而不保证其它位的值。但是，我们不知道是否有机器具有这样的指令。如果你正在尝试将GCC移植到这样的机器上，那么可以在比较运算的指令模式中，包含一条指令来执行将结果和1进行逻辑与，并且通过<a href="mailto:gcc@gcc.gnu.org">gcc@gcc.gnu.org</a>让我们知道。

      <p>通常，机器将具有多个指令，从比较（或者条件代码）中获得一个值。这里有一些规则用来指导对<code>STORE_FLAG_VALUE</code>的值的选择，以及要使用的指令：

          <ul>
<li>使用最短的序列，产生<code>STORE_FLAG_VALUE</code>的有效定义。对编译器来说，将值正常化（例如，将其转成1或者0）要比进行比较运算更有效，因为可能会有一些机会来合并其它的正常化运算。

          <li>对于等长的序列，使用值1或者－1。在跳转代价比较高的机器上，一般会倾向于－1，其它一些机器喜欢用1。

          <li>作为第二种选择，选择值&lsquo;<samp><span class="samp">0x80000001</span></samp>&rsquo;，如果存在指令，同时设置符号位和低顺序位，但是不定义其它位。

          <li>否则，使用值&lsquo;<samp><span class="samp">0x80000000</span></samp>&rsquo;。
</ul>

      <p>许多机器可以同时产生供<code>STORE_FLAG_VALUE</code>选择的值，以及同样数量指令的取反。在那些机器上，你应该还定义这些情况的指令模式，例如，

     <pre class="smallexample">          (set <var>A</var> (neg:<var>m</var> (ne:<var>m</var> <var>B</var> <var>C</var>)))
</pre>
      <p>一些机器还可以在条件代码值上，执行<code>and</code>或者<code>plus</code>运算，使用少于相应的&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo; insn后跟随<code>and</code>或者<code>plus</code>的指令数目。在这些机器上，需要定义适当的指令模式。分别使用名字<code>incscc</code>和<code>decscc</code>，对于在条件代码值上执行<code>plus</code>或者<code>minus</code>运算的指令模式。参见<samp><span class="file">rs6000.md</span></samp>中的一些例子。可以使用GNU Superoptizer来在其它机器上查找这样的指令序列。

      <p>如果该宏没有被定义，则使用缺省的值1。你不需要定义<code>STORE_FLAG_VALUE</code>，如果机器没有存储标记的指令，或者如果这些指令生成的值为1。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FLOAT_STORE_FLAG_VALUE</b> (<var>mode</var>)<var><a name="index-FLOAT_005fSTORE_005fFLAG_005fVALUE-4645"></a></var><br>
<blockquote><p>一个C表达式，给出一个非零的<code>REAL_VALUE_TYPE</code>值，当浮点比较运算的结果为真时返回该值。在一些机器上，具有返回浮点值的比较运算，可以定义该宏。如果没有这样的运算，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>VECTOR_STORE_FLAG_VALUE</b> (<var>mode</var>)<var><a name="index-VECTOR_005fSTORE_005fFLAG_005fVALUE-4646"></a></var><br>
<blockquote><p>一个C表达式，给出一个rtx，表示向量比较中非零的真元素。返回的rtx应该对于<var>mode</var>的内部机器模式是有效的，<var>mode</var>为一个向量机器模式。定义该宏，在一些机器上，具有返回向量结果的向量比较运算。如果没有这样的运算，则不要定义该宏。通常，该宏被定义为<code>const1_rtx</code>或者<code>constm1_rtx</code>。该宏可以返回<code>NULL_RTX</code>，来阻止编译器优化给定的机器模式的向量比较运算。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CLZ_DEFINED_VALUE_AT_ZERO</b> (<var>mode, value</var>)<var><a name="index-CLZ_005fDEFINED_005fVALUE_005fAT_005fZERO-4647"></a></var><br>
&mdash; Macro: <b>CTZ_DEFINED_VALUE_AT_ZERO</b> (<var>mode, value</var>)<var><a name="index-CTZ_005fDEFINED_005fVALUE_005fAT_005fZERO-4648"></a></var><br>
<blockquote><p>一个C表达式，指示体系机构是否为<code>clz</code>或者<code>ctz</code>在操作数为零时，定义了值。结果为<code>0</code>，表示值未被定义。如果值只被定义为RTL表达式，则宏应该求值为<code>1</code>；如果还应用到相应的optab项（其通常情况为直接扩展为相应的RTL），则宏应该求值为<code>2</code>。在值被定义的情况下，<var>value</var>应该被设置为该值。

      <p>如果该宏没有被定义，则<code>clz</code>或者<code>ctz</code>在操作数为零时，被认为未定义。

      <p>该宏必须被定义，如果目标机对<code>ffs</code>的扩展，依赖于特定的值，以获得正确的结果。否则，没有必要，虽然其可以用于优化一些边角的情况，并且为<code>ffs</code> optab提供缺省的扩展。

      <p>注意，不论该宏是否定义，<code>clz</code>和<code>ctz</code>在操作数为0时的定义，都不会被扩展为用户可见的内建函数。因此，可以任意调整该值，来匹配对这些运算的目标机扩展，而无需担心会破坏API。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>Pmode</b><var><a name="index-Pmode-4649"></a></var><br>
<blockquote><p>指针的机器模式别名。在大多数机器上，定义该宏为整型机器模式，对应于硬件指针宽度；32位机器上为<code>SImode</code>，64位机器上为<code>DImode</code>。在一些机器上，你必须定义该宏为部分整型机器模式，例如<code>PSImode</code>。

      <p><code>Pmode</code>的宽度必须至少与<code>POINTER_SIZE</code>的值一样大。如果不相等，你必须定义宏<code>POINTERS_EXTEND_UNSIGNED</code>来描述指针如何被扩展为<code>Pmode</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_MODE</b><var><a name="index-FUNCTION_005fMODE-4650"></a></var><br>
<blockquote><p>机器模式的别名，在<code>call</code> RTL表达式中，用于被调用函数的内存引用。在大多数CISC机器上，指令可以起始于任意字节地址，这应该为<code>QImode</code>。在大多RISC机器上，所有的指令都具有固定的大小和对齐方式，这应该为与机器指令字具有相同大小和对齐的机器模式，通常为<code>SImode</code>或者<code>HImode</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STDC_0_IN_SYSTEM_HEADERS</b><var><a name="index-STDC_005f0_005fIN_005fSYSTEM_005fHEADERS-4651"></a></var><br>
<blockquote><p>正常的操作中，预处理器会将<code>__STDC__</code>扩展为常量1，来表明GCC遵循ISO标准C。在一些主机上，例如Solaris，系统编译器使用不同的约定，<code>__STDC__</code>通常为0，但是如果用户指出要严格遵循C标准时为1。

      <p>定义<code>STDC_0_IN_SYSTEM_HEADERS</code>使得GNU CPP遵循主机的约定，当处理系统头文件时，但是，当处理用户文件时<code>__STDC__</code>将总是被扩展为1。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_IMPLICIT_EXTERN_C</b><var><a name="index-NO_005fIMPLICIT_005fEXTERN_005fC-4652"></a></var><br>
<blockquote><p>定义该宏，如果系统头文件支持C++，也支持C。该宏抑制了通常在C++中使用系统头文件的方法，即假设文件的内容包含在&lsquo;<samp><span class="samp">extern "C" {...}</span></samp>&rsquo;中。
</p></blockquote></div>

 <p><a name="index-g_t_0023pragma-4653"></a><a name="index-pragma-4654"></a>

<div class="defun">
&mdash; Macro: <b>REGISTER_TARGET_PRAGMAS</b> ()<var><a name="index-REGISTER_005fTARGET_005fPRAGMAS-4655"></a></var><br>
<blockquote><p>定义该宏，如果你想实现任何目标机特定的pragma。如果被定义，其为一个C表达式，为每个pragma使用一系列的对<code>c_register_pragma</code>或者<code>c_register_pragma_with_expansion</code>调用。该宏还可以做任何pragma所要求的设置。

      <p>定义该宏的主要原因是提供相同目标机上，与其它编译器的兼容性。大体上，我们不鼓励为GCC定义目标机特定的pragma。

      <p>如果pragma可以通过attribute属性来实现，则你也应该考虑定义目标机钩子&lsquo;<samp><span class="samp">TARGET_INSERT_ATTRIBUTES</span></samp>&rsquo;。

      <p>出现在pragma行中的预处理器宏不被扩展。所有不匹配被注册的&lsquo;<samp><span class="samp">#pragma</span></samp>&rsquo;指令，将被安静的忽略，除非用户指定<samp><span class="option">-Wunknown-pragmas</span></samp>。
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>c_register_pragma</b> (<var>const char *space, const char *name, void </var>(<var>*callback</var>) (<var>struct cpp_reader *</var>))<var><a name="index-c_005fregister_005fpragma-4656"></a></var><br>
&mdash; Function: void <b>c_register_pragma_with_expansion</b> (<var>const char *space, const char *name, void </var>(<var>*callback</var>) (<var>struct cpp_reader *</var>))<var><a name="index-c_005fregister_005fpragma_005fwith_005fexpansion-4657"></a></var><br>
<blockquote>
      <p>每个对<code>c_register_pragma</code>或者<code>c_register_pragma_with_expansion</code>的调用，都建立了一个pragma。当预处理器遇到一个形式为

     <pre class="smallexample">          #pragma [<var>space</var>] <var>name</var> ...
</pre>
      <p>的pragma，则<var>callback</var>函数将被调用。

      <p><var>space</var>为大小写敏感的pragma命名空间，或者为<code>NULL</code>，将gragma放在全局命名空间中。回调函数接受<var>pfile</var>作为第一个参数，如果需要其可以被传递给cpplib的函数。你可以通过调用<code>pragma_lex</code>，来词法分析<var>name</var>之后的token。没有被回调函数读入的token将被安静的忽略。行尾由类型为<code>CPP_EOF</code>的token来指示。宏扩展发生在使用<code>c_register_pragma_with_expansion</code>注册的pragma的参数上，但不在使用<code>c_register_pragma</code>注册的pragma的参数上。

      <p>注意，使用<code>pragma_lex</code>是特定于C和C++编译器的。其在Java或者Fortran编译器上，或者其它语言编译器上无法工作。因此，如果<code>pragma_lex</code>准备从目标机特定代码中被调用，其必须只在构建C和C++编译器的时候执行。这可以通过在<samp><span class="file">config.gcc</span></samp>文件中的目标机项中，定义变量<code>c_target_objs</code>和<code>cxx_target_objs</code>来实现。这些变量应该命名目标机特定的，语言特定的对象文件，其包含了使用<code>pragma_lex</code>的代码。注意，还有必要增加一个规则到由<code>tmake_file</code>指定的makefile片断中，来显示如何构建该目标文件。
</p></blockquote></div>

 <p><a name="index-g_t_0023pragma-4658"></a><a name="index-pragma-4659"></a>

<div class="defun">
&mdash; Macro: <b>HANDLE_SYSV_PRAGMA</b><var><a name="index-HANDLE_005fSYSV_005fPRAGMA-4660"></a></var><br>
<blockquote><p>定义该宏（值为1），如果你想gcc支持System V风格的pragma &lsquo;<samp><span class="samp">#pragma pack(&lt;n&gt;)</span></samp>&rsquo;和&lsquo;<samp><span class="samp">#pragma weak &lt;name&gt; [=&lt;value&gt;]</span></samp>&rsquo;。

      <p>pack pragma描述了结构体中域的最大对齐方式（以字节为单位），很大程度上等同于使用&lsquo;<samp><span class="samp">__aligned__</span></samp>&rsquo;和&lsquo;<samp><span class="samp">__packed__</span></samp>&rsquo; <code>__attribute__</code>。pack值为零，会将行为重置为缺省。

      <p>对于目标机支持的微软Visual C/C++风格的位域打包（例如-mms-bitfields），其微妙之处在于：当位域被插入到一个打包了的记录中时，则底层类型的整个大小会被一个或多个相同大小临近的位域使用（也就是说，如果为long:3，则记录会使用32位，任何额外的临近的long位域将被打包到32位块中。然而，如果大小改变了，则会分配一个新的同样大小的域）。

      <p>如果MS位域和&lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo;都被使用，则后者优先。如果当在使用MS位域的时候，&lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo;被用于一个单独的域，则对于该域是优先的，但是结构体的其它部分的对齐方式会影响它的放置。

      <p>weak pragma只有当<code>SUPPORTS_WEAK</code>和<code>ASM_WEAKEN_LABEL</code>被定义时，才工作。如果可用，其允许创建特殊命名的弱标号，以及可选的值。
</p></blockquote></div>

 <p><a name="index-g_t_0023pragma-4661"></a><a name="index-pragma-4662"></a>

<div class="defun">
&mdash; Macro: <b>HANDLE_PRAGMA_PACK_PUSH_POP</b><var><a name="index-HANDLE_005fPRAGMA_005fPACK_005fPUSH_005fPOP-4663"></a></var><br>
<blockquote><p>定义该宏（值为1），如果你想支持Win32风格的pragmas &lsquo;<samp><span class="samp">#pragma pack(push[,</span><var>n</var><span class="samp">])</span></samp>&rsquo; and &lsquo;<samp><span class="samp">#pragma pack(pop)</span></samp>&rsquo;。&lsquo;<samp><span class="samp">pack(push,[</span><var>n</var><span class="samp">])</span></samp>&rsquo; pragma指定结构体内的域的最大对齐方式（按字节），等同于使用&lsquo;<samp><span class="samp">__aligned__</span></samp>&rsquo; 和 &lsquo;<samp><span class="samp">__packed__</span></samp>&rsquo; <code>__attribute__</code>。如果pack值为0，则会将行为重置为缺省情况。连续的调用该pragma会造成先前的值被压栈，所以调用&lsquo;<samp><span class="samp">#pragma pack(pop)</span></samp>&rsquo;会返回先前的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HANDLE_PRAGMA_PACK_WITH_EXPANSION</b><var><a name="index-HANDLE_005fPRAGMA_005fPACK_005fWITH_005fEXPANSION-4664"></a></var><br>
<blockquote><p>定义该宏，以及<code>HANDLE_SYSV_PRAGMA</code>，如果在&lsquo;<samp><span class="samp">#pragma pack</span></samp>&rsquo;中的参数宏应该被扩展。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_DEFAULT_PACK_STRUCT</b><var><a name="index-TARGET_005fDEFAULT_005fPACK_005fSTRUCT-4665"></a></var><br>
<blockquote><p>如果你的目标机要求结构体缺省的打包方式不是0（意味着机器缺省方式），则定义该宏为必要的值（以字节为单位）。该值必须还对于&lsquo;<samp><span class="samp">#pragma pack()</span></samp>&rsquo;有效（也就是说，2的小的幂数）。
</p></blockquote></div>

 <p><a name="index-g_t_0023pragma-4666"></a><a name="index-pragma-4667"></a>

<div class="defun">
&mdash; Macro: <b>HANDLE_PRAGMA_PUSH_POP_MACRO</b><var><a name="index-HANDLE_005fPRAGMA_005fPUSH_005fPOP_005fMACRO-4668"></a></var><br>
<blockquote><p>定义该宏，如果你想支持Win32风格的pragmas &lsquo;<samp><span class="samp">#pragma push_macro(macro-name-as-string)</span></samp>&rsquo;和&lsquo;<samp><span class="samp">#pragma pop_macro(macro-name-as-string)</span></samp>&rsquo;。&lsquo;<samp><span class="samp">#pragma push_macro(macro-name-as-string)</span></samp>&rsquo;用来保存命名的宏，并且通过&lsquo;<samp><span class="samp">#pragma pop_macro(macro-name-as-string)</span></samp>&rsquo;来返回先前的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DOLLARS_IN_IDENTIFIERS</b><var><a name="index-DOLLARS_005fIN_005fIDENTIFIERS-4669"></a></var><br>
<blockquote><p>定义该宏，来控制C语言家族，标识符名字中对字符&lsquo;<samp><span class="samp">$</span></samp>&rsquo;的使用。0意味着缺省不允许使用&lsquo;<samp><span class="samp">$</span></samp>&rsquo;；1意味着允许。缺省为1；对于这种情况，不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_DOLLAR_IN_LABEL</b><var><a name="index-NO_005fDOLLAR_005fIN_005fLABEL-4670"></a></var><br>
<blockquote><p>定义该宏，如果汇编器不接受标号名字中的&lsquo;<samp><span class="samp">$</span></samp>&rsquo;。缺省的，G++的构造函数和析构函数会在标识符中使用&lsquo;<samp><span class="samp">$</span></samp>&rsquo;。如果该宏被定义，则使用&lsquo;<samp><span class="samp">.</span></samp>&rsquo;来替代。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_DOT_IN_LABEL</b><var><a name="index-NO_005fDOT_005fIN_005fLABEL-4671"></a></var><br>
<blockquote><p>定义该宏，如果汇编器不接受标号名字中的&lsquo;<samp><span class="samp">.</span></samp>&rsquo;。缺省的，G++的构造函数和析构函数的名字会使用&lsquo;<samp><span class="samp">.</span></samp>&rsquo;。如果该宏被定义，则这些名字被重写，以避免出现&lsquo;<samp><span class="samp">.</span></samp>&rsquo;。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INSN_SETS_ARE_DELAYED</b> (<var>insn</var>)<var><a name="index-INSN_005fSETS_005fARE_005fDELAYED-4672"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在<var>insn</var>的延迟槽中是安全的，即使它们可能会使用<var>insn</var>设置或者破坏的一个资源。<var>insn</var>总是一个<code>jump_insn</code>或者<code>insn</code>；GCC知道每个<code>call_insn</code>具有这种行为。在一些机器上，一些<code>insn</code>或者<code>jump_insn</code>确实为一个函数调用，因此也具有这种行为，你应该定义该宏。

      <p>如果其总是返回零，则不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INSN_REFERENCES_ARE_DELAYED</b> (<var>insn</var>)<var><a name="index-INSN_005fREFERENCES_005fARE_005fDELAYED-4673"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在<var>insn</var>的延迟槽中是安全的，即使它们可能会设置或者破坏<var>insn</var>使用的一个资源。<var>insn</var>总是一个<code>jump_insn</code>或者<code>insn</code>。在一些机器上，一些<code>insn</code>或者<code>jump_insn</code>确实为一个函数调用，并且其操作数为寄存器，实际是在其调用的子函数中使用，你应该定义该宏。这使得延迟槽调度器将复制参数到参数寄存器的指令移送到<var>insn</var>的延迟槽中。

      <p>如果其总是返回零，则不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MULTIPLE_SYMBOL_SPACES</b><var><a name="index-MULTIPLE_005fSYMBOL_005fSPACES-4674"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，其为非零，如果对于一些情况，没有用户的介入，一个转换单元中的全局符号可能不会被发现为另一个转换单元中的未定义的符号。例如，在Microsoft Windows下，符号必须被从共享库（DLL）中显式的导入。

      <p>如果其总是为零，则不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_MD_ASM_CLOBBERS</b> (<var>tree outputs, tree inputs, tree clobbers</var>)<var><a name="index-TARGET_005fMD_005fASM_005fCLOBBERS-4675"></a></var><br>
<blockquote><p>该目标钩子将移植平台希望一个asm可以自动破坏的硬件寄存器增加到<var>clobbers</var> <code>STRING_CST</code> tree中。其应该返回最后一个用于增加一个破坏者的<code>tree_cons</code>。<var>outputs</var>, <var>inputs</var> 和 <var>clobber</var>为asm的相应的参数，可以用来检查以避免破坏asm的输入或者输出寄存器。你可以使用<samp><span class="file">tree.h</span></samp>中声明的<code>tree_overlaps_hard_reg_set</code>来测试是否与asm声明的寄存器有重叠。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MATH_LIBRARY</b><var><a name="index-MATH_005fLIBRARY-4676"></a></var><br>
<blockquote><p>定义该宏为一个C字符串常量，为连接器的参数，作为系统数学库连接，或者&lsquo;<samp><span class="samp">""</span></samp>&rsquo;，如果目标机没有单独的数学库。

      <p>只有当缺省的&lsquo;<samp><span class="samp">"-lm"</span></samp>&rsquo;有错误时，才需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBRARY_PATH_ENV</b><var><a name="index-LIBRARY_005fPATH_005fENV-4677"></a></var><br>
<blockquote><p>定义该宏为一个C字符串常量，为一个环境变量，指定了连接器应该从哪里查找库。

      <p>只有当缺省的&lsquo;<samp><span class="samp">"LIBRARY_PATH"</span></samp>&rsquo;有错误时，才需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_POSIX_IO</b><var><a name="index-TARGET_005fPOSIX_005fIO-4678"></a></var><br>
<blockquote><p>定义该宏，如果目标机支持下列POSIX文件函数，access, mkdir和使用fcntl / F_SETLKW的文件加锁。其还在运行时为交叉profiling创建目录。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_CONDITIONAL_EXECUTE</b><var><a name="index-MAX_005fCONDITIONAL_005fEXECUTE-4679"></a></var><br>
<blockquote><p>一个C表达式，为通过条件执行指令来替代分支的最大指令数。值<code>BRANCH_COST</code>+1为缺省值，如果机器没有使用cc0，如果使用了cc0，则为1。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_TESTS</b> (<var>ce_info, true_expr, false_expr</var>)<var><a name="index-IFCVT_005fMODIFY_005fTESTS-4680"></a></var><br>
<blockquote><p>使用该宏，如果目标机需要在将基本块转为条件执行代码时，对条件进行机器相关的修改。<var>ce_info</var>指向一个数据结构，<code>struct ce_if_block</code>，其包含了关于当前被处理的块的信息。<var>true_expr</var>和<var>false_expr</var>为测试，分别用于转换then-block和else-block。如果测试不能被转换，则将<var>true_expr</var>或者<var>false_expr</var>设置为空指针。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_MULTIPLE_TESTS</b> (<var>ce_info, bb, true_expr, false_expr</var>)<var><a name="index-IFCVT_005fMODIFY_005fMULTIPLE_005fTESTS-4681"></a></var><br>
<blockquote><p>类似于<code>IFCVT_MODIFY_TESTS</code>，不过用于将更加复杂的if语句转换为由<code>and</code>和<code>or</code>运算组合的条件。<var>bb</var>包含的基本块，包含了当前被处理的测试，并将被转换为一个条件。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_INSN</b> (<var>ce_info, pattern, insn</var>)<var><a name="index-IFCVT_005fMODIFY_005fINSN-4682"></a></var><br>
<blockquote><p>一个C表达式，来修改<var>INSN</var>的<var>PATTERN</var>，其将被转换为一个条件执行的格式。<var>ce_info</var>指向一个数据结构，<code>struct ce_if_block</code>，其包含了关于当前被处理的块的信息。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_FINAL</b> (<var>ce_info</var>)<var><a name="index-IFCVT_005fMODIFY_005fFINAL-4683"></a></var><br>
<blockquote><p>一个C表达式，用来执行在将代码转换为条件执行时，任何最终机器相关的修改。涉及到的基本块可以在由<var>ce_info</var>指向的<code>struct ce_if_block</code>结构体中找到。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_CANCEL</b> (<var>ce_info</var>)<var><a name="index-IFCVT_005fMODIFY_005fCANCEL-4684"></a></var><br>
<blockquote><p>一个C表达式，用来取消在将代码转换为条件执行时，任何机器相关的修改。涉及到的基本块可以在由<var>ce_info</var>指向的<code>struct ce_if_block</code>结构体中找到。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_INIT_EXTRA_FIELDS</b> (<var>ce_info</var>)<var><a name="index-IFCVT_005fINIT_005fEXTRA_005fFIELDS-4685"></a></var><br>
<blockquote><p>一个C表达式，来初始化任何<code>struct ce_if_block</code>结构体中额外的域，其通过<code>IFCVT_EXTRA_FIELDS</code>宏来定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_EXTRA_FIELDS</b><var><a name="index-IFCVT_005fEXTRA_005fFIELDS-4686"></a></var><br>
<blockquote><p>如果被定义，其应该扩展为一个域声明集合，其将被增加到<code>struct ce_if_block</code>结构体中。这些应该通过<code>IFCVT_INIT_EXTRA_FIELDS</code>宏来初始化。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_MACHINE_DEPENDENT_REORG</b> ()<var><a name="index-TARGET_005fMACHINE_005fDEPENDENT_005fREORG-4687"></a></var><br>
<blockquote><p>如果非空，则该钩子对指令流执行目标机特定的编译过程。编译器将在所有优化级别上执行该过程，就在其通常执行延迟分支调度之前的地方。

      <p>该钩子的确切目的因目标机不同而不同。一些用来为了正确性执行必要的转换，例如布局函数常量池，或者避免硬件冒险。其它用来作为机器相关的优化。

      <p>如果没有什么可做的，则不需要实现该钩子。缺省定义为空。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_INIT_BUILTINS</b> ()<var><a name="index-TARGET_005fINIT_005fBUILTINS-4688"></a></var><br>
<blockquote><p>定义该钩子，如果你有任何需要被定义的机器特定的内建函数。其应该为一个函数，执行必要的设置。

      <p>机器特定的内建函数可以用于扩展特定的机器指令，否则其通常不会被生成，因为在源语言中没有等价的对应（例如，SIMD向量指令或者预取指令）。

      <p>要创建一个内建函数，调用函数<code>lang_hooks.builtin_function</code>，其由语言前端定义。你可以使用任何由<code>build_common_tree_nodes</code>和<code>build_common_tree_nodes_2</code>建立的类型节点；只有使用这两个函数的语言前端会调用&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_EXPAND_BUILTIN</b> (<var>tree exp, rtx target, rtx subtarget, enum machine_mode mode, int ignore</var>)<var><a name="index-TARGET_005fEXPAND_005fBUILTIN-4689"></a></var><br>
<blockquote><p>扩展由&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;建立的对一个机器特定的内建函数的调用。<var>exp</var>为函数调用的表达式；如果方便的话，结果应该放到<var>target</var>，并且具有机器模式<var>mode</var>。<var>subtarget</var>可以用作目标，来计算<var>exp</var>的操作数。<var>ignore</var>为非零，如果值将被忽略。该函数应该返回调用内建函数的结果。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_RESOLVE_OVERLOADED_BUILTIN</b> (<var>tree fndecl, tree arglist</var>)<var><a name="index-TARGET_005fRESOLVE_005fOVERLOADED_005fBUILTIN-4690"></a></var><br>
<blockquote><p>为&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;建立的机器特定内建函数选择一个替身。这发生在常规的类型检查之前，因此允许目标机来实现函数重载的粗糙形式。<var>fndecl</var>为内建函数的声明。<var>arglist</var>为传递给内建函数的参数列表。结果为一个完全表达式，实现了该运算，通常为另一个<code>CALL_EXPR</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_FOLD_BUILTIN</b> (<var>tree fndecl, tree arglist, bool ignore</var>)<var><a name="index-TARGET_005fFOLD_005fBUILTIN-4691"></a></var><br>
<blockquote><p>将&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;建立的机器特定的内建函数的调用进行折叠。<var>fndecl</var>为内建函数的声明。<var>arglist</var>为传递给内建函数的参数列表。结果为另一个tree，包含了一个简化的表达式，为调用的结果。如果<var>ignore</var>为真，则值将被忽略。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const <b>char</b><var> * TARGET_INVALID_WITHIN_DOLOOP </var>(<var>rtx insn</var>)<var><a name="index-char-4692"></a></var><br>
<blockquote><p>接受一个指令<var>insn</var>，如果其在一个低开销循环中有效，则返回NULL，否则返回一个字符串说明为什么不能应用doloop。

      <p>许多目标机使用特定的寄存器，用于低开销循环。对于任何破坏这些的指令，该函数应该返回一个字符串，指出不能应用doloop的原因。缺省的，RTL循环优化不对包含函数调用或者表指令分支的循环，使用现有的doloop指令模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MD_CAN_REDIRECT_BRANCH</b> (<var>branch1, branch2</var>)<var><a name="index-MD_005fCAN_005fREDIRECT_005fBRANCH-4693"></a></var><br>
<blockquote><p>接受一个分支insn <var>branch1</var>和另一个<var>branch2</var>。返回真，如果将<var>branch1</var>重定向到<var>branch2</var>的目的地是可能的。

      <p>在一些目标机上，分支可能具有有限的范围。优化延迟槽的填充，可以导致分支可以被重定向，反过来也可能会造成一个分支的偏移量溢出。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_COMMUTATIVE_P</b> (<var>rtx x, outer_code</var>)<var><a name="index-TARGET_005fCOMMUTATIVE_005fP-4694"></a></var><br>
<blockquote><p>该目标钩子返回<code>true</code>，如果<var>x</var>被认为是可交换的。通常，这就是COMMUTATIVE_P (<var>x</var>)。但是HP PA不认为PLUS在MEM中是可交换的。<var>outer_code</var>为包含rtl的rtx代码，如果知道，否则为UNKNOWN。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_ALLOCATE_INITIAL_VALUE</b> (<var>rtx hard_reg</var>)<var><a name="index-TARGET_005fALLOCATE_005fINITIAL_005fVALUE-4695"></a></var><br>
<blockquote><p>当硬件寄存器的初始值已经被复制到伪寄存器中，通常没有必要为该伪寄存器分配另一个寄存器，因为可以使用原始的硬件寄存器或者被保存到的栈槽。在寄存器分配的起始处，<code>TARGET_ALLOCATE_INITIAL_VALUE</code>针对每个其初始值使用<code>get_func_hard_reg_initial_val</code>或者<code>get_hard_reg_initial_val</code>复制过的，硬件寄存器被调用一次。可能的值为，<code>NULL_RTX</code>如果你不想做任何特殊的分配，一个<code>REG</code> rtx——其通常为硬件寄存器本身，如果知道其不会被破坏——或者一个<code>MEM</code>。如果返回一个<code>MEM</code>，这只是一个给分配器的提示；其仍然有可能会决定用另一个寄存器。你可以在钩子中使用<code>current_function_leaf_function</code>，用来确定被询问的硬件寄存器是否会被破坏。该钩子的缺省值为<code>NULL</code>，其禁止了任何特殊的分配。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_UNSPEC_MAY_TRAP_P</b> (<var>const_rtx x, unsigned flags</var>)<var><a name="index-TARGET_005fUNSPEC_005fMAY_005fTRAP_005fP-4696"></a></var><br>
<blockquote><p>该目标钩子返回非零，如果<var>x</var>，一个<code>unspec</code>或者<code>unspec_volatile</code>运算，可能会造成一个陷阱。目标机可以使用该钩子来加强对<code>unspec</code>和<code>unspec_volatile</code>运算的分析的精确性。你可以调用<code>may_trap_p_1</code>来分析<var>x</var>的内部元素，这种情况下，也应该传递<var>flags</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SET_CURRENT_FUNCTION</b> (<var>tree decl</var>)<var><a name="index-TARGET_005fSET_005fCURRENT_005fFUNCTION-4697"></a></var><br>
<blockquote><p>编译器每当改变当前函数上下文(<code>cfun</code>)时，便会调用该钩子。你可以定义该函数，如果后端需要基于每个函数执行任何初始化或者重置行为。例如，其可以用来实现函数属性，影响寄存器的使用或者代码生成指令模式。参数<var>decl</var>为新的函数上下文的声明，可以为空，表示编译器已经离开函数上下文，要返回顶层去处理。缺省钩子函数不做任何事情。

      <p>GCC将<code>cfun</code>设置为一个哑的函数上下文，在初始化后端一些部分的时候。钩子函数在这种情况下不会被调用；你不需要担心钩子函数被递归调用，或者当后端处于部分初始化的状态。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OBJECT_SUFFIX</b><var><a name="index-TARGET_005fOBJECT_005fSUFFIX-4698"></a></var><br>
<blockquote><p>定义该宏为C字符串，表示在你的目标机器上，对象文件的后缀。如果没有定义该宏，则GCC会使用&lsquo;<samp><span class="samp">.o</span></samp>&rsquo;作为目标文件的后缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_EXECUTABLE_SUFFIX</b><var><a name="index-TARGET_005fEXECUTABLE_005fSUFFIX-4699"></a></var><br>
<blockquote><p>定义该宏为C字符串，表示在你的目标机器上，为可执行文件自动增加的后缀。如果没有定义该宏，GCC将为可执行文件使用空字符串作为后缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>COLLECT_EXPORT_LIST</b><var><a name="index-COLLECT_005fEXPORT_005fLIST-4700"></a></var><br>
<blockquote><p>如果被定义，<code>collect2</code>将在其命令行中扫描单独的目标文件，并为连接器创建一个导出列表。为AIX这样的系统定义该宏，并使用导出列表，其连接器会丢弃没有从<code>main</code>中引用的对象文件。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MODIFY_JNI_METHOD_CALL</b> (<var>mdecl</var>)<var><a name="index-MODIFY_005fJNI_005fMETHOD_005fCALL-4701"></a></var><br>
<blockquote><p>定义该宏为一个C表达式，表示方法调用<var>mdecl</var>的一个变种，如果Java Native Interface (JNI)方法必须通过你目标机上其它方法来调用。例如，在32位Microsoft Windows上，JNI方法必须使用<code>stdcall</code>调用约定来调用，该宏则被定义为如下表达式：

     <pre class="smallexample">          build_type_attribute_variant (<var>mdecl</var>,
                                        build_tree_list
                                        (get_identifier ("stdcall"),
                                         NULL))
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CANNOT_MODIFY_JUMPS_P</b> (<var>void</var>)<var><a name="index-TARGET_005fCANNOT_005fMODIFY_005fJUMPS_005fP-4702"></a></var><br>
<blockquote><p>该目标钩子在一个点之后返回<code>true</code>，该处应该创建新的跳转指令。在一些机器上，对每个跳转都要求使用寄存器，例如SH5的SHmedia ISA，该点通常为重载，所以该目标钩子应该被定义为这样的函数：

     <pre class="smallexample">          static bool
          cannot_modify_jumps_past_reload_p ()
          {
            return (reload_completed || reload_in_progress);
          }
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_BRANCH_TARGET_REGISTER_CLASS</b> (<var>void</var>)<var><a name="index-TARGET_005fBRANCH_005fTARGET_005fREGISTER_005fCLASS-4703"></a></var><br>
<blockquote><p>该目标钩子返回一个寄存器类，分支目标寄存器优化将会应用在该类别上。该类别中的所有寄存器应该是可以互换使用的。重载之后，该类别中的寄存器将被重新分配，并且加载将被悬挂在循环之外，从属于块间调度。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED</b> (<var>bool after_prologue_epilogue_gen</var>)<var><a name="index-TARGET_005fBRANCH_005fTARGET_005fREGISTER_005fCALLEE_005fSAVED-4704"></a></var><br>
<blockquote><p>分支目标寄存器优化，缺省的会将，被调用者保存的寄存器排除在外，其在当前函数中已经是不活跃的。如果目标钩子返回真，它们将被包含进来。目标代码必须确保在由&lsquo;<samp><span class="samp">TARGET_BRANCH_TARGET_REGISTER_CLASS</span></samp>&rsquo;返回的类别中的所有寄存器，如果需要保存的，会被保存。<var>after_prologue_epilogue_gen</var>指出是否序言和尾声已经被生成。注意，即使你只当<var>after_prologue_epilogue_gen</var>为假时返回真，你还可能要在<code>INITIAL_ELIMINATION_OFFSET</code>做出特定的预防，来为调用者保存的目标寄存器保留空间。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>POWI_MAX_MULTS</b><var><a name="index-POWI_005fMAX_005fMULTS-4705"></a></var><br>
<blockquote><p>如果被定义，该宏被解析为一个有符号整型C表达式，描述了浮点乘法的最大数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>TARGET_EXTRA_INCLUDES</b> (<var>const char *sysroot, const char *iprefix, int stdinc</var>)<var><a name="index-TARGET_005fEXTRA_005fINCLUDES-4706"></a></var><br>
<blockquote><p>该钩子用于记录目标机的任何额外的include文件。参数<var>stdinc</var>指示是否存在通常的include文件。参数<var>sysroot</var>为系统根目录。参数<var>iprefix</var>为gcc目录的前缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>TARGET_EXTRA_PRE_INCLUDES</b> (<var>const char *sysroot, const char *iprefix, int stdinc</var>)<var><a name="index-TARGET_005fEXTRA_005fPRE_005fINCLUDES-4707"></a></var><br>
<blockquote><p>该钩子用于记录目标机的任何先于标准头文件之前的include文件。参数<var>stdinc</var>指示是否存在通常的include文件。参数<var>sysroot</var>为系统根目录。参数<var>iprefix</var>为gcc目录的前缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>TARGET_OPTF</b> (<var>char *path</var>)<var><a name="index-TARGET_005fOPTF-4708"></a></var><br>
<blockquote><p>该目标机钩子用来记录目标机特殊的include路径。参数<var>path</var>为要记录的include。在Darwin系统上，被用于Framework include，其语义与<samp><span class="option">-I</span></samp>有所不同。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_USE_LOCAL_THUNK_ALIAS_P</b> (<var>tree fndecl</var>)<var><a name="index-TARGET_005fUSE_005fLOCAL_005fTHUNK_005fALIAS_005fP-4709"></a></var><br>
<blockquote><p>该目标机钩子返回<code>true</code>，如果当为虚函数构造thunk时，使用局部别名是安全的，否则为<code>false</code>。缺省的，钩子对所有函数返回<code>true</code>，如果目标机支持别名（即：定义了<code>ASM_OUTPUT_DEF</code>），否则<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_FORMAT_TYPES</b><var><a name="index-TARGET_005fFORMAT_005fTYPES-4710"></a></var><br>
<blockquote><p>如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式检查信息，针对<samp><span class="option">-Wformat</span></samp>选项。缺省为没有目标机特定的格式检查。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_N_FORMAT_TYPES</b><var><a name="index-TARGET_005fN_005fFORMAT_005fTYPES-4711"></a></var><br>
<blockquote><p>如果被定义，则该宏为<code>TARGET_FORMAT_TYPES</code>中的项数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OVERRIDES_FORMAT_ATTRIBUTES</b><var><a name="index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES-4712"></a></var><br>
<blockquote><p>如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式，用来覆盖<samp><span class="option">-Wformat</span></samp>选项。缺省为没有目标机特定的格式覆盖。如果被定义，则<code>TARGET_FORMAT_TYPES</code>也必须被定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OVERRIDES_FORMAT_ATTRIBUTES_COUNT</b><var><a name="index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES_005fCOUNT-4713"></a></var><br>
<blockquote><p>如果被定义，该宏描述<code>TARGET_OVERRIDES_FORMAT_ATTRIBUTES</code>中的项数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OVERRIDES_FORMAT_INIT</b><var><a name="index-TARGET_005fOVERRIDES_005fFORMAT_005fINIT-4714"></a></var><br>
<blockquote><p>如果被定义，则该宏描述可选的初始化程序，用于目标机特定的系统printf和scanf格式设置。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_RELAXED_ORDERING</b><var><a name="index-TARGET_005fRELAXED_005fORDERING-4715"></a></var><br>
<blockquote><p>如果设置为<code>true</code>，则意味着目标机的内存模型不保证，没有依赖关系的加载操作会按照指令流的顺序来访问主存；如果顺序很重要，那么必须使用显式的内存栅栏。这对许多现在的处理器是这样的，例如Alpha, PowerPC和ia64，其实现了关于内存一致性的&ldquo;relaxed,&rdquo; &ldquo;weak,&rdquo; 或 &ldquo;release&rdquo;策略。缺省为<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const <b>char</b><var> *TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN </var>(<var>tree typelist, tree funcdecl, tree val</var>)<var><a name="index-char-4716"></a></var><br>
<blockquote><p>如果被定义，则当传递参数<var>val</var>给函数原型为<var>typelist</var>的函数<var>funcdecl</var>是非法的时候，该宏会返回诊断信息。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_CONVERSION</b> (<var>tree fromtype, tree totype</var>)<var><a name="index-TARGET_005fINVALID_005fCONVERSION-4717"></a></var><br>
<blockquote><p>如果被定义，则当从<var>fromtype</var>转换成<var>totype</var>是无效的时候，该宏会返回诊断信息，或者返回<code>NULL</code>，如果有效性应该由前端来确定。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_UNARY_OP</b> (<var>int op, tree type</var>)<var><a name="index-TARGET_005fINVALID_005fUNARY_005fOP-4718"></a></var><br>
<blockquote><p>如果被定义，则当在类型为<var>type</var>的操作数上执行<var>op</var>（一元的加号通过<code>CONVERT_EXPR</code>来表示）是无效的时候，该宏会返回诊断信息，或者返回<code>NULL</code>，如果有效性应该由前端来确定。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_BINARY_OP</b> (<var>int op, tree type1, tree type2</var>)<var><a name="index-TARGET_005fINVALID_005fBINARY_005fOP-4719"></a></var><br>
<blockquote><p>如果被定义，则当在类型为<var>type1</var>和<var>type2</var>的操作数上执行<var>op</var>是无效的时候，该宏会返回诊断信息，或者返回<code>NULL</code>，如果有效性应该由前端来确定。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_USE_JCR_SECTION</b><var><a name="index-TARGET_005fUSE_005fJCR_005fSECTION-4720"></a></var><br>
<blockquote><p>该宏定义是否使用JCR段来记录Java类。缺省的，如果SUPPORTS_WEAK和TARGET_HAVE_NAMED_SECTIONS都为真，则TARGET_USE_JCR_SECTION被定义为1，否则为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>OBJC_JBLEN</b><var><a name="index-OBJC_005fJBLEN-4721"></a></var><br>
<blockquote><p>该宏为NeXT运行时，确定objective C跳转缓存的大小。缺省的，OBJC_JBLEN被定义为一个无害的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_UNWIND_ATTRIBUTE</b><var><a name="index-LIBGCC2_005fUNWIND_005fATTRIBUTE-4722"></a></var><br>
<blockquote><p>定义该宏，如果对于<samp><span class="file">libgcc</span></samp>中那些为调用栈展开（call stack unwinding）提供低级别支持的函数上，需要附加目标机特定的属性时。其被用在<samp><span class="file">unwind-generic.h</span></samp>中的声明和那些函数相关的定义中。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_UPDATE_STACK_BOUNDARY</b> (<var>void</var>)<var><a name="index-TARGET_005fUPDATE_005fSTACK_005fBOUNDARY-4723"></a></var><br>
<blockquote><p>如果需要，定义该宏来更新当前函数栈边界。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_GET_DRAP_RTX</b> (<var>void</var>)<var><a name="index-TARGET_005fGET_005fDRAP_005fRTX-4724"></a></var><br>
<blockquote><p>定义该宏为动态重对齐参数指针（Dynamic Realign Argument Pointer）的rtx，如果当栈被对齐时，需要用不同的参数指针寄存器来访问函数的参数列表。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS</b> (<var>void</var>)<var><a name="index-TARGET_005fALLOCATE_005fSTACK_005fSLOTS_005fFOR_005fARGS-4725"></a></var><br>
<blockquote><p>当优化被禁止时，该钩子用来指示参数是否应该被分配到栈槽中。通常，GCC当不做优化时，会为参数分配栈槽，以便于调试。然而，当函数使用<code>__attribute__((naked))</code>声明时，将没有栈帧，因此编译器不能安全的将参数从用来传递它们的寄存器中移送到栈上。因此，该钩子通常应该返回真，但是对于裸露的函数应该返回假。缺省的实现总是返回真。
</p></blockquote></div>

<!-- Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, -->
<!-- 2000, 2001, 2002, 2003, 2004, 2005, 2008 Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gccint.texi. -->
 </body></html>

