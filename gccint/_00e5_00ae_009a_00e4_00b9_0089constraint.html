<html lang="zh">
<head>
<title>定义constraint - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Constraints.html#Constraints" title="Constraints">
<link rel="prev" href="_00e6_009c_00ba_00e5_0099_00a8constraint.html#g_t_00e6_009c_00ba_00e5_0099_00a8constraint" title="机器constraint">
<link rel="next" href="C-constraint_00e6_008e_00a5_00e5_008f_00a3.html#C-constraint_00e6_008e_00a5_00e5_008f_00a3" title="C constraint接口">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%ae%9a%e4%b9%89constraint"></a>
<a name="g_t_00e5_00ae_009a_00e4_00b9_0089constraint"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="C-constraint_00e6_008e_00a5_00e5_008f_00a3.html#C-constraint_00e6_008e_00a5_00e5_008f_00a3">C constraint接口</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_009c_00ba_00e5_0099_00a8constraint.html#g_t_00e6_009c_00ba_00e5_0099_00a8constraint">机器constraint</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Constraints.html#Constraints">Constraints</a>
<hr>
</div>

<h4 class="subsection">16.8.7 定义机器特定的constraint</h4>

<p><a name="index-defining-constraints-3273"></a><a name="index-constraints_002c-defining-3274"></a>
机器特定的约束分为两类：寄存器约束和非寄存器约束。在后者中，
如果约束允许所有可能的内存或地址操作数，则应该被专门标记出来，
以便给<code>reload</code>更多信息。

 <p>机器特定的约束可以给定任意长度的名字，但是它们全部由字母，数字，
下划线（&lsquo;<samp><span class="samp">_</span></samp>&rsquo;）和三角括号（&lsquo;<samp><span class="samp">&lt; &gt;</span></samp>&rsquo;）组成。跟C标识符类似，
它们必须起始于字母或者下划线。

 <p>为了避免操作数约束字符串的混淆，约束的名字不能起始于任何其它约束的名字。
例如，如果<code>x</code>被定义为一个约束名，则不可以定义<code>xy</code>，反之依然。
按照这个规则，所有约束都不能起始于通用约束字母：&lsquo;<samp><span class="samp">E F V X g i m n o p r s</span></samp>&rsquo;。

 <p>寄存器约束直接对应于寄存器类别。参见<a href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab">寄存器类别</a>。
因此它们的定义没有太多的灵活性。

<div class="defun">
&mdash; MD Expression: <b>define_register_constraint</b><var> name regclass docstring<a name="index-define_005fregister_005fconstraint-3275"></a></var><br>
<blockquote><p>这三个参数都是字符串常量。<var>name</var>为约束的名字，
将在<code>match_operand</code>表达式中出现。如果<var>name</var>为多个字母的约束，
则它的长度应该与所有起始与同一字母的约束相同。
<var>regclass</var>可以为相应的寄存器类别的名字（参见<a href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab">寄存器类别</a>），
或者一个C表达式，其值为合适的寄存器类别。如果为表达式，其必须不具有副作用，
并且不能查看操作数。通常使用表达式是为了当寄存器类别对于给定的子体系结构无效时，
将一些寄存器约束映射为<code>NO_REGS</code>。

      <p><var>docstring</var>为一条语句，介绍了约束的含义。这将在下面做进一步的解释。
</p></blockquote></div>

 <p>非寄存器的约束更加像断言：约束定义给出一个布尔表达式，其指示是否约束匹配。

<div class="defun">
&mdash; MD Expression: <b>define_constraint</b><var> name docstring exp<a name="index-define_005fconstraint-3276"></a></var><br>
<blockquote><p><var>name</var>和<var>docstring</var>参数与<code>define_register_constraint</code>的相同，
但是注意docstring直接跟随name之后。<var>exp</var>为一个RTL表达式，
遵循在断言定义中相同的规则。详情参见<a href="_00e5_00ae_009a_00e4_00b9_0089predicate.html#g_t_00e5_00ae_009a_00e4_00b9_0089predicate">定义predicate</a>。如果求得为真，
则约束匹配；如果求得为假，则不匹配。约束表达式应该指示出它们可能匹配的RTL，
就像断言表达式一样。

      <p>C表达式<code>match_test</code>，可以访问下列变量：

          <dl>
<dt><var>op</var><dd>定义操作数的RTL对象。
<br><dt><var>mode</var><dd><var>op</var>的机器模式。
<br><dt><var>ival</var><dd>&lsquo;<samp><span class="samp">INTVAL (</span><var>op</var><span class="samp">)</span></samp>&rsquo;, 如果<var>op</var>为<code>const_int</code>。
<br><dt><var>hval</var><dd>&lsquo;<samp><span class="samp">CONST_DOUBLE_HIGH (</span><var>op</var><span class="samp">)</span></samp>&rsquo;, 如果<var>op</var>为整数<code>const_double</code>。
<br><dt><var>lval</var><dd>&lsquo;<samp><span class="samp">CONST_DOUBLE_LOW (</span><var>op</var><span class="samp">)</span></samp>&rsquo;, 如果<var>op</var>为整数<code>const_double</code>。
<br><dt><var>rval</var><dd>&lsquo;<samp><span class="samp">CONST_DOUBLE_REAL_VALUE (</span><var>op</var><span class="samp">)</span></samp>&rsquo;,
如果<var>op</var>为浮点<code>const_double</code>。
</dl>

      <p>变量<var>*val</var>应该只在表达式的其它部分已经验证了<var>op</var>为合适类型的RTL对象时，
才被使用。
</p></blockquote></div>

 <p>大多数非寄存器约束应该使用<code>define_constraint</code>来定义。
其余的两个定义表达式只适合当约束匹配失败时，应该由<code>reload</code>单独处理的约束。

<div class="defun">
&mdash; MD Expression: <b>define_memory_constraint</b><var> name docstring exp<a name="index-define_005fmemory_005fconstraint-3277"></a></var><br>
<blockquote><p>使用该表达式来定义匹配所有内存操作数的子集的约束：也就是，
<code>reload</code>能够通过将操作数转换为&lsquo;<samp><span class="samp">(mem&nbsp;(reg&nbsp;</span><var>X</var><span class="samp">))<!-- /@w --></span></samp>&rsquo;的形式使得它们
匹配。其中<var>X</var>为基址寄存器（通过<code>BASE_REG_CLASS</code>指定的寄存器类别，
参见<a href="_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab.html#g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e7_00b1_00bb_00e5_0088_00ab">寄存器类别</a>）。

      <p>例如，在S/390上，一些指令不接受任意的内存引用，只接受那些不使用索引寄存器的。
约束字母&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;被定义用来表示这个类型的内存地址。
如果&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;使用<code>define_memory_constraint</code>定义，
则&lsquo;<samp><span class="samp">Q</span></samp>&rsquo;约束可以处理任意内存操作数，因为<code>reload</code>知道在需要的时候，
它可以简单的将内存地址复制到基址寄存器中。
这与&lsquo;<samp><span class="samp">o</span></samp>&rsquo;约束可以处理任意内存操作数的方式类似。

      <p>语法和语义在其它方面都与<code>define_constraint</code>相同。
</p></blockquote></div>

<div class="defun">
&mdash; MD Expression: <b>define_address_constraint</b><var> name docstring exp<a name="index-define_005faddress_005fconstraint-3278"></a></var><br>
<blockquote><p>使用该表达式来定义匹配所有地址操作数的子集的约束：也就是，
<code>reload</code>能够通过将操作数转换为&lsquo;<samp><span class="samp">(reg&nbsp;</span><var>X</var><span class="samp">)<!-- /@w --></span></samp>&rsquo;的形式使得它们匹配。
同样<var>X</var>为基址寄存器。

      <p>使用<code>define_address_constraint</code>定义的约束只能用于<code>address_operand</code>断言
，或者机器特定的同样方式的断言。它们与通用的&lsquo;<samp><span class="samp">p</span></samp>&rsquo;约束类似。

      <p>语法和语义在其它方面都与<code>define_constraint</code>相同。
</p></blockquote></div>

 <p>由于历史的原因，
起始于字母&lsquo;<samp><span class="samp">G H</span></samp>&rsquo;的名字被保留为只匹配<code>const_double</code>的约束，
起始与字母&lsquo;<samp><span class="samp">I J K L M N O P</span></samp>&rsquo;被保留为只匹配<code>const_int</code>的约束。
这在将来可能会改变。暂时的，这些名字的约束必须使用固定形式来书写，
以便<code>genpreds</code>能够辨别出你在做正确的事情：

<pre class="smallexample">     (define_constraint "[<var>GHIJKLMNOP</var>]..."
       "<var>doc</var>..."
       (and (match_code "const_int")  ; <code>const_double</code><span class="roman"> for G/H</span>
            <var>condition</var>...))            ; <span class="roman">usually a </span><code>match_test</code>
</pre>
 <!-- the semicolons line up in the formatted manual -->
 <p>可以使用起始于其它字母的名字来定义匹配<code>const_double</code>或<code>const_int</code>的约束。

 <p>在约束定义中的每个docstring应该是一条或多条完整的语句，使用Texinfo格式来标记。
它们目前没有被使用。在将来，它们将被复制到 GCC手册中，在机器约束这一章节，
用来替换手工维护的表格。而且，将来编译器可以使用其来给出更多有帮助的诊断信息，
当过少的<code>asm</code>约束选择造成重载失败时。

 <p>如果你在docstring的起始出放入伪Texinfo指令&lsquo;<samp><span class="samp">@internal</span></samp>&rsquo;，
则（在将来）其将只出现在internals手册版本的机器特定约束表中。
这可以用于不应该出现在<code>asm</code>语句中的约束。

 </body></html>

