<html lang="zh">
<head>
<title>RTL模板 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0" title="机器描述">
<link rel="prev" href="_00e4_00be_008b_00e5_00ad_0090.html#g_t_00e4_00be_008b_00e5_00ad_0090" title="例子">
<link rel="next" href="_00e8_00be_0093_00e5_0087_00ba_00e6_00a8_00a1_00e6_009d_00bf.html#g_t_00e8_00be_0093_00e5_0087_00ba_00e6_00a8_00a1_00e6_009d_00bf" title="输出模板">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="RTL%e6%a8%a1%e6%9d%bf"></a>
<a name="RTL_00e6_00a8_00a1_00e6_009d_00bf"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e8_00be_0093_00e5_0087_00ba_00e6_00a8_00a1_00e6_009d_00bf.html#g_t_00e8_00be_0093_00e5_0087_00ba_00e6_00a8_00a1_00e6_009d_00bf">输出模板</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e4_00be_008b_00e5_00ad_0090.html#g_t_00e4_00be_008b_00e5_00ad_0090">例子</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0.html#g_t_00e6_009c_00ba_00e5_0099_00a8_00e6_008f_008f_00e8_00bf_00b0">机器描述</a>
<hr>
</div>

<h3 class="section">16.4 RTL模板</h3>

<p><a name="index-RTL-insn-template-3164"></a><a name="index-generating-insns-3165"></a><a name="index-insns_002c-generating-3166"></a><a name="index-recognizing-insns-3167"></a><a name="index-insns_002c-recognizing-3168"></a>
RTL模板用来定义哪些insn匹配特定的模式，以及如何找到它们的操作数。对于命名的模
式，RTL模板还说明了如何根据特定的操作数来构建一个insn。

 <p>构建insn涉及到替换指定操作数到模板。匹配insn涉及到测定被匹配insn的操作数值。这
些匹配和替换操作数的行为都是由专门的表达式类型来控制。

     
<a name="index-match_005foperand-3169"></a>
<dl><dt><code>(match_operand:</code><var>m</var> <var>n</var> <var>predicate</var> <var>constraint</var><code>)</code><dd>该表达式用来代表insn中的第 <var>n</var> 个操作数。当构建insn时，操作数编号 <var>n</var> 将
在此处被替换。当匹配insn时，凡是在insn中该位置出现的将被当作操作数编号 <var>n</var>；
但是其必须满足 <var>predicate</var>，否则该指令模式将根本不匹配。

     <p>每个指令模式中的操作数编号必须从0开始连续的选择。在指令模式中，可以对每个操作数
编号只是用一个 <code>match_operand</code> 表达式。 通常操作数按照在
<code>match_operand</code> 表达式中出现的顺序被编号。对于 <code>define_expand</code>，任何
使用的操作数编号，只有在 <code>match_dup</code> 表达式中才会具有比其它操作数编号更高
的值。

     <p><var>predicate</var> 为一个字符串，为一个函数的名字，其接受两个参数，一个表达式和一个
机器模式。see <a href="Predicates.html#Predicates">Predicates</a>。在匹配过程中，函数将会被调用，使用假定的操作数作为
表达式并且 <var>m</var> 作为机器模式参数（如果 <var>m</var> 没有被指定，则使用
<code>VOIDmode</code>，这通常会使得 <var>predicate</var> 可以接受任何机器模式）。如果其返
回0，则该指令模式匹配失败。<var>predicate</var> 可以为一个空字符串；这意味着不对操作
数作测试，这样出现在该位置的任何都是有效的。

     <p>大多时候，<var>predicate</var> 将会拒绝 <var>m</var> 之外的机器模式——但并不总是这样。例
如，predicate <code>address_operand</code> 使用 <var>m</var> 作为内存引用的机器模式。许多predicate
接受 <code>const_int</code> 节点，即使它们的机器模式为 <code>VOIDmode</code>。

     <p><var>constraint</var> 控制重载以及针对一个值选择最好的寄存器类别来使用，将在后面解释
（see <a href="_00e7_00ba_00a6_00e6_009d_009f_00e6_009d_00a1_00e4_00bb_00b6.html#g_t_00e7_00ba_00a6_00e6_009d_009f_00e6_009d_00a1_00e4_00bb_00b6">约束条件</a>）。如果constraint为空字符串，则可以忽略掉。

     <p>人们经常弄不清楚constraint和predicate的区别。predicate帮助决定一个给定的insn是否匹配指令模式。constraint在该决定中不发挥作用；替代的，其控制已经匹配的insn的各种决定。

     <p><a name="index-match_005fscratch-3170"></a><br><dt><code>(match_scratch:</code><var>m</var> <var>n</var> <var>constraint</var><code>)</code><dd>该表达式也是操作数编号 <var>n</var> 的占位符，并且指示操作数必须为一个 <code>scratch</code>
或者 <code>reg</code> 表达式。

     <p>当在匹配指令模式时，其相当于

     <pre class="smallexample">          (match_operand:<var>m</var> <var>n</var> "scratch_operand" <var>pred</var>)
</pre>
     <p>但是，当在生成RTL时，其产生一个(<code>scratch</code>:<var>m</var>)表达式。

     <p>如果在一个 <code>parallel</code> 中的最后几个表达式为 <code>clobber</code> 表达式，其操作数
为一个硬寄存器或者 <code>match_scratch</code>，则组合器可以在需要的时候增加或删除它
们。see <a href="_00e5_0089_00af_00e4_00bd_009c_00e7_0094_00a8.html#g_t_00e5_0089_00af_00e4_00bd_009c_00e7_0094_00a8">副作用</a>。

     <p><a name="index-match_005fdup-3171"></a><br><dt><code>(match_dup </code><var>n</var><code>)</code><dd>该表达式也为操作数编号 <var>n</var> 的占位符。其用于当操作数需要在insn中出现多次的
情况。

     <p>在构建过程中，<code>match_dup</code> 的作用就跟 <code>match_operand</code> 一样。操作数被
替换到正在被构建的insn中。但是在匹配时，<code>match_dup</code> 的行为就有所不同了。
其假设操作数编号 <var>n</var> 已经由在识别模板中之前出现的 <code>match_operand</code> 确
定了，其只匹配相同的表达式。

     <p>注意 <code>match_dup</code> 不要用来告诉编译器特定寄存器被用于两个操作数（例如：
<code>add</code> 将一个寄存器加到另一个之上；第二个寄存器即为输入操作数，同样也为输
出操作数）。可以为此使用匹配constraint（see <a href="_00e7_00ae_0080_00e5_008d_0095constraint.html#g_t_00e7_00ae_0080_00e5_008d_0095constraint">简单constraint</a>）。<code>match_dup</code>
是用于一个操作数在模板中的两个地方被使用的情况，例如一条指令同时计算商和余数，
其中操作码接受两个输入操作数，但是RTL模板不得不引用它们两次；一次用于求商指令
模式，一次用于求余数指令模式。

     <p><a name="index-match_005foperator-3172"></a><br><dt><code>(match_operator:</code><var>m</var> <var>n</var> <var>predicate</var><code> [</code><var>operands</var><code>...])</code><dd>该指令模式为一个可变RTL表达式代码的一种占位符。

     <p>当构造一个insn时，其代表RTL表达式，其表达式代码取自操作数 <var>n</var>，并且其操作
数从指令模式 <var>operands</var> 中构造。

     <p>当匹配一个表达式时，其匹配一个表达式，如果函数 <var>predicate</var> 对于该表达式返
回非零，<em>并且</em> 指令模式 <var>operands</var> 匹配表达式的操作数。

     <p>假设函数 <code>commutative_operator</code> 被如下定义，来匹配任何表达式，其操作符为
RTL中可交换的算术操作符，并且其机器模式为 <var>mode</var>：

     <pre class="smallexample">          int
          commutative_integer_operator (x, mode)
               rtx x;
               enum machine_mode mode;
          {
            enum rtx_code code = GET_CODE (x);
            if (GET_MODE (x) != mode)
              return 0;
            return (GET_RTX_CLASS (code) == RTX_COMM_ARITH
                    || code == EQ || code == NE);
          }
</pre>
     <p>那么下列指令模式将匹配任何RTL表达式，其由一个可交换操作符和两个通用操作数组成：

     <pre class="smallexample">          (match_operator:SI 3 "commutative_operator"
            [(match_operand:SI 1 "general_operand" "g")
             (match_operand:SI 2 "general_operand" "g")])
</pre>
     <p>这里的向量 <code>[</code><var>operands</var><code>...]</code> 包含了两个指令模式，因为要匹配的表达
式都是包含两个操作数。

     <p>当该指令模式确实匹配时，可交换操作符的两个操作数被记录为insn的操作数1和2。（这
由 <code>match_operand</code> 的两个实例完成）。insn的操作数3将为整个可交换表达式：使
用 <code>GET_CODE (operands[3])</code> 来查看使用了哪个可交换操作符。

     <p><code>match_operator</code> 的机器模式 <var>m</var> 的作用与 <code>match_operand</code> 的类似：
其被作为第二个参数传递给predicate函数，并且函数专门负责决定被匹配的表达式是否具有那
个机器模式。

     <p>当构造insn时，gen-function 的参数3将会指定要构造的表达式的操作（即，表达式代
码）。其应该为一个RTL表达式，其表达式代码被复制到一个新的表达式中，新表达式的
操作数为 gen-function的参数1和2。参数3的子表达式不被使用；只与它的表达式代码
有关。

     <p>当 <code>match_operator</code> 被用于指令模式中来匹配insn时，通常最好让
<code>match_operator</code> 的操作数编号高于insn的实际操作数。这将提高寄存器分配，
因为寄存器分配者通常查看insn的操作数1和2，来看是否它可以做寄存器绑定
（register tying）。

     <p>无法指定在 <code>match_operator</code> 中的constraint。对应于 <code>match_operator</code> 的
insn的操作数，不具有任何constraint，因为它从来不作为一个整体被重载。但是，如果它
的 <var>operands</var> 的一部分被 <code>match_operand</code> 指令模式匹配，那些部分可
以具有它们自己的constraint。

     <p><a name="index-match_005fop_005fdup-3173"></a><br><dt><code>(match_op_dup:</code><var>m</var> <var>n</var><code>[</code><var>operands</var><code>...])</code><dd>类似 <code>match_dup</code>，除了其应用于操作符而不是操作数。当构造insn时，操作数
编号 <var>n</var> 将在这一点被替代。但是在匹配时，<code>match_op_dup</code> 的行为有所
不同。其假设操作数编号 <var>n</var> 已经被在识别模板中先前出现的
<code>match_operator</code> 所确定，并且其只匹配identical-looking的表达式。

     <p><a name="index-match_005fparallel-3174"></a><br><dt><code>(match_parallel </code><var>n</var> <var>predicate</var><code> [</code><var>subpat</var><code>...])</code><dd>该指令模式为一个insn的占位符，该insn由一个具有可变数目元素的 <code>parallel</code>
表达式组成。该表达式应该只在insn指令模式的顶层出现。

     <p>当构造insn时，操作数编号 <var>n</var> 将在该处被替换。当匹配一个insn时，其当insn
的主体为一个 <code>parallel</code> 表达式，其具有至少跟向量 <var>subpat</var> 表达式同
样多数目元素，并且函数 <var>predicate</var> 返回非零时才匹配。predicate负责判定在
<code>match_parallel</code> 中的 <code>parallel</code> 的元素是否有效。

     <p><code>match_parallel</code> 的一个典型用法是，匹配加载和存储多个表达式，其可以在
<code>parallel</code> 中包含一个可变数目的元素。例如，

     <pre class="smallexample">          (define_insn ""
            [(match_parallel 0 "load_multiple_operation"
               [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                     (match_operand:SI 2 "memory_operand" "m"))
                (use (reg:SI 179))
                (clobber (reg:SI 179))])]
            ""
            "loadm 0,0,%1,%2")
</pre>
     <p>这个例子来自 <samp><span class="file">a29k.md</span></samp>。函数 <code>load_multiple_operation</code> 在
<samp><span class="file">a29k.c</span></samp> 中定义，其检查在 <code>parallel</code> 中的序列元素，是否与在
指令模式中的 <code>set</code> 相同，除非它们在引用后续的寄存器和内存位置。

     <p>匹配该指令模式的insn可能看起来像：

     <pre class="smallexample">          (parallel
           [(set (reg:SI 20) (mem:SI (reg:SI 100)))
            (use (reg:SI 179))
            (clobber (reg:SI 179))
            (set (reg:SI 21)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 4))))
            (set (reg:SI 22)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 8))))])
</pre>
     <p><a name="index-match_005fpar_005fdup-3175"></a><br><dt><code>(match_par_dup </code><var>n</var><code> [</code><var>subpat</var><code>...])</code><dd>与 <code>match_op_dup</code> 类似，但是针对于 <code>match_parallel</code>，而不是
<code>match_operator</code>。
</dl>

 </body></html>

