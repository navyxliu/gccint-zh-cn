<html lang="zh">
<head>
<title>寄存器参数 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8" title="栈和调用">
<link rel="prev" href="_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0.html#g_t_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0" title="栈参数">
<link rel="next" href="_00e6_00a0_0087_00e9_0087_008f_00e8_00bf_0094_00e5_009b_009e.html#g_t_00e6_00a0_0087_00e9_0087_008f_00e8_00bf_0094_00e5_009b_009e" title="标量返回">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%af%84%e5%ad%98%e5%99%a8%e5%8f%82%e6%95%b0"></a>
<a name="g_t_00e5_00af_0084_00e5_00ad_0098_00e5_0099_00a8_00e5_008f_0082_00e6_0095_00b0"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00a0_0087_00e9_0087_008f_00e8_00bf_0094_00e5_009b_009e.html#g_t_00e6_00a0_0087_00e9_0087_008f_00e8_00bf_0094_00e5_009b_009e">标量返回</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0.html#g_t_00e6_00a0_0088_00e5_008f_0082_00e6_0095_00b0">栈参数</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8.html#g_t_00e6_00a0_0088_00e5_0092_008c_00e8_00b0_0083_00e7_0094_00a8">栈和调用</a>
<hr>
</div>

<h4 class="subsection">17.10.7 在寄存器中传递参数</h4>

<p><a name="index-arguments-in-registers-4038"></a><a name="index-registers-arguments-4039"></a>
这节描述了让你控制不同类型的参数如何在寄存器中传递，
或者它们如何被安排在栈中的宏。

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG</b> (<var>cum, mode, type, named</var>)<var><a name="index-FUNCTION_005fARG-4040"></a></var><br>
<blockquote><p>— Macro: FUNCTION_ARG (cum, mode, type, named)

      <p>一个C表达式，控制函数的参数是否在寄存器中传递，以及在那个寄存器中传递。

      <p>参数为<var>cum</var>，其总结了所有之前的参数；<var>mode</var>，参数的机器模式；
<var>type</var>，参数的数据类型，作为一个树节点或者0如果不知道（这发生于C支持库的
函数）；<var>named</var>，其为1对于普通参数，0对于无名参数，
对应于在被调用函数原型中的&lsquo;<samp><span class="samp">...</span></samp>&rsquo;。<var>type</var>可以为一个不完全类型，
如果之前产生了语法错误。

      <p>表达式的值通常为一个在其中传递参数的硬件寄存器的<code>reg</code> RTX，或者0，
在栈上传递参数。

      <p>对于像VAX和68000的机器，其通常所有参数被压栈，则定义为0就行。

      <p>表达式的值也可以为一个<code>parallel</code> RTX。这用于当参数在多个位置传递的时候。
<code>parallel</code>的机器模式应该为整个参数的机器模式。
<code>parallel</code>保存了任意数目的<code>expr_list</code>对；
每一个描述了该部分参数在哪里传递，
<code>reg</code> RTX的机器模式指示了该部分的参数有多大。
<code>expr_list</code>的第二个操作数为一个const_int，
其给出了该部分起始处与整个参数的偏移字节数。作为一个特例，
<code>parallel</code> RTX中的第一个<code>expr_list</code>的第一个操作数可以为0。
这意味着整个参数也在栈中存储。

      <p>该宏最后一次被调用的时候，<code>MODE == VOIDmode</code>，
并且结果被传递给<code>call</code>或者<code>call_value</code>指令模式，分别作为其操作数2和3。

      <p><a name="index-g_t_0040file_007bstdarg_002eh_007d-and-register-arguments-4041"></a>通常使ISO库<samp><span class="file">stdarg.h</span></samp>在一些参数在寄存器中传递的机器上工作的方法，
是使无名参数在栈上传递。这通过使<code>FUNCTION_ARG</code>当<var>named</var>为0时返回0来实现。

      <p><a name="index-g_t_0040code_007bTARGET_005fMUST_005fPASS_005fIN_005fSTACK_007d_002c-and-_0040code_007bFUNCTION_005fARG_007d-4042"></a><a name="index-g_t_0040code_007bREG_005fPARM_005fSTACK_005fSPACE_007d_002c-and-_0040code_007bFUNCTION_005fARG_007d-4043"></a>你可以在该宏的定义中，使用钩子<code>targetm.calls.must_pass_in_stack</code>来确定该
参数是否为一个必须在栈中传递的类型。如果<code>REG_PARM_STACK_SPACE</code>没有定义并且
<code>FUNCTION_ARG</code>对于这样的参数返回非0，则编译器会abort。
如果<code>REG_PARM_STACK_SPACE</code>被定义，则参数会在栈中计算并且然后加载到寄存器中。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_MUST_PASS_IN_STACK</b> (<var>enum machine_mode mode, tree type</var>)<var><a name="index-TARGET_005fMUST_005fPASS_005fIN_005fSTACK-4044"></a></var><br>
<blockquote><p>该target钩子应该返回<code>true</code>，如果我们不应该只在寄存器中传递<var>type</var>。
文件<samp><span class="file">expr.h</span></samp>中有一个定义，其通常是合适的，更多的文档请参考<samp><span class="file">expr.h</span></samp>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_INCOMING_ARG</b> (<var>cum, mode, type, named</var>)<var><a name="index-FUNCTION_005fINCOMING_005fARG-4045"></a></var><br>
<blockquote><p>定义该宏，如果target机器具有“寄存器窗口”，
这样函数看到的参数寄存器没有必要与调用者传递参数的寄存器相同。

      <p>对于这样的机器，<code>FUNCTION_ARG</code>计算调用者传递值的寄存器，
<code>FUNCTION_INCOMING_ARG</code>应该按照类似的方式定义，
来告诉被调用的函数参数在哪里到来。

      <p>如果<code>FUNCTION_INCOMING_ARG</code>没有定义，则<code>FUNCTION_ARG</code>具有这两种用途。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_ARG_PARTIAL_BYTES</b> (<var>CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named</var>)<var><a name="index-TARGET_005fARG_005fPARTIAL_005fBYTES-4046"></a></var><br>
<blockquote><p>该target钩子返回在参数的起始处必须被放入寄存器的字节数。
值必须为0对于参数全部放在寄存器中或者全部压入栈中。

      <p>一些机器上，特定的参数必须部分在寄存器中传递并且部分在内存中传递。
在这些机器上，通常参数的起始一些字在寄存器中传递，其余的在栈上。
如果一个多字的参数（<code>double</code>或者结构体）跨越了边界，
则其起始的一些字必须在寄存器中传递并且剩余的被压栈。
该宏告诉编译器这种情况什么时候发生，以及多少字节应该在寄存器中。

      <p><code>FUNCTION_ARG</code>对于这些参数应该返回第一个寄存器，被调用者用于该参数；
通常<code>FUNCTION_INCOMING_ARG</code>用于被调用的函数。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_PASS_BY_REFERENCE</b> (<var>CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named</var>)<var><a name="index-TARGET_005fPASS_005fBY_005fREFERENCE-4047"></a></var><br>
<blockquote><p>该target钩子应该返回<code>true</code>，
如果<var>cum</var>所指示的位置的参数应该按照引用的方式来传递。

      <p>如果钩子返回真，则参数的副本在内存中产生并且指向参数的指针被替代参数本身来传递。
指针按照传递该类型的指针的方式来传递。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CALLEE_COPIES</b> (<var>CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named</var>)<var><a name="index-TARGET_005fCALLEE_005fCOPIES-4048"></a></var><br>
<blockquote><p>由该钩子的参数所描述的函数的参数已知为通过引用来传递的。钩子应该返回真，
如果函数参数应该由被调用者复制，而不是调用者。

      <p>对于任何该钩子返回真的参数，如果其可以被确定参数没有被修改，则不需要产生副本。

      <p>该钩子的缺省版本总是返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CUMULATIVE_ARGS</b><var><a name="index-CUMULATIVE_005fARGS-4049"></a></var><br>
<blockquote><p>一个C类型，用来声明一个变量，
被用作<code>FUNCTION_ARG</code>的第一个参数以及其它相关的值。对于一些target机器，
类型<code>int</code>可以满足并且目前可以保持参数的字节数。

      <p>不需要在<code>CUMULATIVE_ARGS</code>中记录任何已经在栈中传递的参数的信息。
编译器有其它变量来记录。对于所有参数在栈上传递的target机器，
不需要在<code>CUMULATIVE_ARGS</code>中保存任何事物；然而，
数据结构体必须存在并且不能为空，因此可以使用<code>int</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>OVERRIDE_ABI_FORMAT</b> (<var>fndecl</var>)<var><a name="index-OVERRIDE_005fABI_005fFORMAT-4050"></a></var><br>
<blockquote>
      <p>If defined, this macro is called before generating any code for a
function, but after the <var>cfun</var> descriptor for the function has been
created.  The back end may use this macro to update <var>cfun</var> to
reflect an ABI other than that which would normally be used by default. 
If the compiler is generating code for a compiler-generated function,
<var>fndecl</var> may be <code>NULL</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INIT_CUMULATIVE_ARGS</b> (<var>cum, fntype, libname, fndecl, n_named_args</var>)<var><a name="index-INIT_005fCUMULATIVE_005fARGS-4051"></a></var><br>
<blockquote><p>一条C语句（没有分号），用于初始化变量<var>cum</var>，在参数列表的起始处。
变量具有类型<code>CUMULATIVE_ARGS</code>。<var>fntype</var>的值为树节点，
为将要接受参数的函数的数据类型，或者为0如果参数是传给编译器支持库的函数。
对于直接调用，没有libcall，<var>fndecl</var>包含了被编译的函数。
<var>fndecl</var>在当<code>INIT_CUMULATIVE_ARGS</code>被用于查找被编译的函数的参数时，
也被设置。<var>n_named_args</var>被设为命名参数的个数，包括一个结构体返回地址，
如果其作为参数被传递。当处理流入参数时，<var>n_named_args</var>被设为-1。

      <p>当处理对编译器支持库的函数的调用时，<var>libname</var>指示了为哪一个函数。
其为一个<code>symbol_ref</code> rtx，包含了函数的名字，作为字符串。<var>libname</var>为0，
当一个普通C函数被处理。因此，每次该宏被调用时，
或者<var>libname</var>或者<var>fntype</var>为非 0，但不会同时非0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INIT_CUMULATIVE_LIBCALL_ARGS</b> (<var>cum, mode, libname</var>)<var><a name="index-INIT_005fCUMULATIVE_005fLIBCALL_005fARGS-4052"></a></var><br>
<blockquote><p>类似于<code>INIT_CUMULATIVE_ARGS</code>，但只用于流出的libcall，
其接受一个<code>MODE</code>参数而不是<var>fntype</var>。如果该宏没有定义，
则使用<code>INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname,0)</code>来替代。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INIT_CUMULATIVE_INCOMING_ARGS</b> (<var>cum, fntype, libname</var>)<var><a name="index-INIT_005fCUMULATIVE_005fINCOMING_005fARGS-4053"></a></var><br>
<blockquote><p>类似于<code>INIT_CUMULATIVE_ARGS</code>，但会覆盖其，用于查找被编译的函数的参数。
如果该宏没有被定义，则使用<code>INIT_CUMULATIVE_ARGS</code>来替代。

      <p>传递给<var>libname</var>的值总是为0，因为库函数具有特定的调用约定，从来不被GCC编译。
参数<var>libname</var>的存在是为了与<code>INIT_CUMULATIVE_ARGS</code>对称。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_ADVANCE</b> (<var>cum, mode, type, named</var>)<var><a name="index-FUNCTION_005fARG_005fADVANCE-4054"></a></var><br>
<blockquote><p>一条C语句（没有分号），来更新总结变量<var>cum</var>来在参数列表中前进一个参数。
值<var>mode</var>, <var>type</var>和<var>named</var>描述了那个参数。一旦执行后，
变量<var>cum</var>便适合分析随后的参数。

      <p>该宏不需要做任何事情，如果要询问的参数是在栈中传递的。
编译器知道如何追踪用于参数的栈空间，不需要任何特殊帮助。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_OFFSET</b> (<var>mode, type</var>)<var><a name="index-FUNCTION_005fARG_005fOFFSET-4055"></a></var><br>
<blockquote><p>If defined, a C expression that is the number of bytes to add to the
offset of the argument passed in memory.  This is needed for the SPU,
which passes <code>char</code> and <code>short</code> arguments in the preferred
slot that is in the middle of the quad word instead of starting at the
top. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_PADDING</b> (<var>mode, type</var>)<var><a name="index-FUNCTION_005fARG_005fPADDING-4056"></a></var><br>
<blockquote><p>如果被定义，则为一个C表达式，其确定是否使用额外的空间来填补参数，
以及按照什么方向。值应该为类型<code>enum direction</code>：或者<code>upward</code>，
向上填补参数，<code>downward</code>向下，或者<code>none</code>不进行填补。

      <p>填补的数目总是刚足够达到下一个<code>FUNCTION_ARG_BOUNDARY</code>的倍数；
该宏不进行控制。

      <p>该宏具有一个缺省定义，其对大多数系统是对的。对于小端机器，缺省为向上填补。
对于大端机器，缺省为如果参数的大小比<code>int</code>短则向下填补，否则向上。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PAD_VARARGS_DOWN</b><var><a name="index-PAD_005fVARARGS_005fDOWN-4057"></a></var><br>
<blockquote><p>如果定义，则为一个C表达式，其确定va_arg的缺省实现是否会尝试向下填补，
在读取下一个参数之前，如果那个参数比<code>PARM_BOUNDARY</code>所控制的对齐空间要小。
如果该宏没有定义，则所有这样的参数都被向下填补，
如果<code>BYTES_BIG_ENDIAN</code>为真。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BLOCK_REG_PADDING</b> (<var>mode, type, first</var>)<var><a name="index-BLOCK_005fREG_005fPADDING-4058"></a></var><br>
<blockquote><p>指定了寄存器和内存间移动的块的最后一个元素的填补。<var>first</var>为非0，
如果这是唯一的元素。定义该宏，允许更好的处理在大端机器上寄存器函数参数，
不使用<code>PARALLEL</code> rtl。特别的，
<code>MUST_PASS_IN_STACK</code>不需要测试填充和寄存器中的类型的机器模式，
因为在寄存器中不在有“错误的”部分；例如，
一个三字节的聚合类型可能在寄存器的高部传递，如果需要的话。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_BOUNDARY</b> (<var>mode, type</var>)<var><a name="index-FUNCTION_005fARG_005fBOUNDARY-4059"></a></var><br>
<blockquote><p>如果定义，为一个C表达式，其给出了指定的mode和type的参数的对齐边界位数。
如果没有定义，则<code>PARM_BOUNDARY</code>用于所有参数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_REGNO_P</b> (<var>regno</var>)<var><a name="index-FUNCTION_005fARG_005fREGNO_005fP-4060"></a></var><br>
<blockquote><p>一个C表达式，其为非0，如果<var>regno</var>为硬件寄存器的编号，
函数参数有时在其中传递。这不包括隐式参数，像静态链和结构体值的地址。
在许多机器上，没有寄存器可以用于此目的，因为所有函数参数都被压到栈上。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SPLIT_COMPLEX_ARG</b> (<var>tree type</var>)<var><a name="index-TARGET_005fSPLIT_005fCOMPLEX_005fARG-4061"></a></var><br>
<blockquote><p>该钩子应该返回真，如果参数<var>type</var>作为两个标量参数传递。缺省的，
GCC将尝试将复数参数打包成target的字大小。
一些ABI要求复数参数要被拆分开并且作为单独的部分对待。例如，在AIX64上，
复数浮点应该在一对浮点寄存器中传递，即使复数浮点可以适合一个64位的浮点寄存器。

      <p>该钩子的缺省值为<code>NULL</code>，其被最为假来对待。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_BUILD_BUILTIN_VA_LIST</b> (<var>void</var>)<var><a name="index-TARGET_005fBUILD_005fBUILTIN_005fVA_005fLIST-4062"></a></var><br>
<blockquote><p>该钩子返回一个target的<code>va_list</code>的类型节点。缺省版本返回<code>void*</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_FN_ABI_VA_LIST</b> (<var>tree fndecl</var>)<var><a name="index-TARGET_005fFN_005fABI_005fVA_005fLIST-4063"></a></var><br>
<blockquote><p>This hook returns the va_list type of the calling convention specified by
<var>fndecl</var>. 
The default version of this hook returns <code>va_list_type_node</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_CANONICAL_VA_LIST_TYPE</b> (<var>tree type</var>)<var><a name="index-TARGET_005fCANONICAL_005fVA_005fLIST_005fTYPE-4064"></a></var><br>
<blockquote><p>This hook returns the va_list type of the calling convention specified by the
type of <var>type</var>. If <var>type</var> is not a valid va_list type, it returns
<code>NULL_TREE</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_GIMPLIFY_VA_ARG_EXPR</b> (<var>tree valist, tree type, tree *pre_p, tree *post_p</var>)<var><a name="index-TARGET_005fGIMPLIFY_005fVA_005fARG_005fEXPR-4065"></a></var><br>
<blockquote><p>该钩子执行target特定的<code>VA_ARG_EXPR</code>的gimplification。
前两个参数对应于<code>va_arg</code>的参数；后两个作为<code>gimplify.c:gimplify_expr</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VALID_POINTER_MODE</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fVALID_005fPOINTER_005fMODE-4066"></a></var><br>
<blockquote><p>定义该钩子返回非0，如果port可以处理具有机器模式<var>mode</var>的指针。
缺省版本对于<code>ptr_mode</code>和<code>Pmode</code>都返回真。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SCALAR_MODE_SUPPORTED_P</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fSCALAR_005fMODE_005fSUPPORTED_005fP-4067"></a></var><br>
<blockquote><p>定义该钩子来返回非0，如果port准备好了处理涉及标量机器模式<var>mode</var>的insn。
对于被考虑支持的一个标量机器模式，所有的基本算术和比较都必须能工作。

      <p>缺省版本返回真，对于任何要求处理基本C类型（被port定义）的机器模式。
包括在<samp><span class="file">optabs.c</span></samp>中的代码支持的双字算术。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VECTOR_MODE_SUPPORTED_P</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fVECTOR_005fMODE_005fSUPPORTED_005fP-4068"></a></var><br>
<blockquote><p>定义该钩子来返回非0，如果port准备好了处理涉及向量模式<var>mode</var>的insn。
最起码，其必须有该机器模式的move指令模式。
</p></blockquote></div>

 </body></html>

