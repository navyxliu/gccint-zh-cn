<html lang="zh">
<head>
<title>Insn长度 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Insn_00e5_00b1_009e_00e6_0080_00a7.html#Insn_00e5_00b1_009e_00e6_0080_00a7" title="Insn属性">
<link rel="prev" href="_00e5_00b1_009e_00e6_0080_00a7_00e4_00be_008b_00e5_00ad_0090.html#g_t_00e5_00b1_009e_00e6_0080_00a7_00e4_00be_008b_00e5_00ad_0090" title="属性例子">
<link rel="next" href="_00e5_00b8_00b8_00e9_0087_008f_00e5_00b1_009e_00e6_0080_00a7.html#g_t_00e5_00b8_00b8_00e9_0087_008f_00e5_00b1_009e_00e6_0080_00a7" title="常量属性">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Insn%e9%95%bf%e5%ba%a6"></a>
<a name="Insn_00e9_0095_00bf_00e5_00ba_00a6"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_00b8_00b8_00e9_0087_008f_00e5_00b1_009e_00e6_0080_00a7.html#g_t_00e5_00b8_00b8_00e9_0087_008f_00e5_00b1_009e_00e6_0080_00a7">常量属性</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_00e5_00b1_009e_00e6_0080_00a7_00e4_00be_008b_00e5_00ad_0090.html#g_t_00e5_00b1_009e_00e6_0080_00a7_00e4_00be_008b_00e5_00ad_0090">属性例子</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Insn_00e5_00b1_009e_00e6_0080_00a7.html#Insn_00e5_00b1_009e_00e6_0080_00a7">Insn属性</a>
<hr>
</div>

<h4 class="subsection">16.19.5 计算一个Insn的长度</h4>

<p><a name="index-insn-lengths_002c-computing-3615"></a><a name="index-computing-the-length-of-an-insn-3616"></a>
许多机器提供了多种类型的分支指令，针对于不同长度的分支位移。多数情况下，
汇编器会选择使用正确的指令。但是，当汇编器无法做到的时候，如果一个特殊的属性，
<code>length</code>属性，被定义，则可以由GCC来完成。
该属性必须通过在它的<code>define_attr</code>中指定一个空字符串，
从而被定义成具有数字值。

 <p>对于<code>length</code>属性，在test表达式中允许两个额外形式的算术术语：

     
<a name="index-g_t_0040code_007bmatch_005fdup_007d-and-attributes-3617"></a>
<dl><dt><code>(match_dup </code><var>n</var><code>)</code><dd>这是指当前insn的操作数<var>n</var>的地址，其必须为一个<code>label_ref</code>。

     <p><a name="index-g_t_0040code_007bpc_007d-and-attributes-3618"></a><br><dt><code>(pc)</code><dd>这是指当前insn的地址。或许可以将其设为下一个insn的地址，
从而跟其它地方的用法一致，但是这样容易引起混淆，因为还要计算当前insn的长度。
</dl>

 <p><a name="index-g_t_0040code_007baddr_005fvec_007d_002c-length-of-3619"></a><a name="index-g_t_0040code_007baddr_005fdiff_005fvec_007d_002c-length-of-3620"></a>对于通常的insn，长度将由<code>length</code>属性的值来确定。
对于<code>addr_vec</code>和<code>addr_diff_vec</code>的insn模式，
长度通过向量数乘于每个向量的大小来计算获得。

 <p>长度按照可寻址的存储单元（字节）来度量。

 <p>下列宏可以用于改进长度计算：

     
<a name="index-ADJUST_005fINSN_005fLENGTH-3621"></a>
<dl><dt><code>ADJUST_INSN_LENGTH (</code><var>insn</var><code>, </code><var>length</var><code>)</code><dd>如果定义，则在上下文中作为函数来使用，用于修改赋予指令<var>insn</var>的长度。
<var>length</var>为一个lvalue（左值）包含了最初计算的insn长度并将使用insn的正确长度来更新。

     <p>该宏通常并不需要。一种使用它的情况为ROMP。在这个机器上，
一个<code>addr_vec</code> insn的大小必须被加2用于补偿可能需要的指令对齐。
</dl>

 <p><a name="index-get_005fattr_005flength-3622"></a>返回<code>get_attr_length</code>（<code>length</code>属性的值）的程序，
可以被输出程序用来确定将要写入的分支指令的形式，正如下面的例子。

 <p>作为一个指定可变长度分支的例子，可以考虑一下IBM360。
如果我们采用寄存器将被设为函数起始地址这样的约定，
我们则可以使用一个4字节的指令来跳转到4K范围的标号。
否则，我们需要一个6字节的序列来从内存加载地址并然后分支到那里。

 <p>对于这样的机器，可以按照如下的方式来指定一个分支指令模式：

<pre class="smallexample">     (define_insn "jump"
       [(set (pc)
             (label_ref (match_operand 0 "" "")))]
       ""
     {
        return (get_attr_length (insn) == 4
                ? "b %l0" : "l r15,=a(%l0); br r15");
     }
       [(set (attr "length")
             (if_then_else (lt (match_dup 0) (const_int 4096))
                           (const_int 4)
                           (const_int 6)))])
</pre>
 </body></html>

