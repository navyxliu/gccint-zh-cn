<html lang="zh">
<head>
<title>测试用语 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e6_00b5_008b_00e8_00af_0095_00e5_008c_0085.html#g_t_00e6_00b5_008b_00e8_00af_0095_00e5_008c_0085" title="测试包">
<link rel="next" href="_00e6_00b5_008b_00e8_00af_0095_00e6_008c_0087_00e4_00bb_00a4.html#g_t_00e6_00b5_008b_00e8_00af_0095_00e6_008c_0087_00e4_00bb_00a4" title="测试指令">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e6%b5%8b%e8%af%95%e7%94%a8%e8%af%ad"></a>
<a name="g_t_00e6_00b5_008b_00e8_00af_0095_00e7_0094_00a8_00e8_00af_00ad"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e6_00b5_008b_00e8_00af_0095_00e6_008c_0087_00e4_00bb_00a4.html#g_t_00e6_00b5_008b_00e8_00af_0095_00e6_008c_0087_00e4_00bb_00a4">测试指令</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e6_00b5_008b_00e8_00af_0095_00e5_008c_0085.html#g_t_00e6_00b5_008b_00e8_00af_0095_00e5_008c_0085">测试包</a>
<hr>
</div>

<h4 class="subsection">6.4.1 测试包代码中使用的习惯用法</h4>

<p>通常，C 测试用例以<samp><span class="file">-</span><var>n</var><span class="file">.c</span></samp>结尾，并且从<samp><span class="file">-1.c</span></samp>开始，
以便于以后增加其它具有类似名字的测试用例。
如果是测试一些明确定义的特征，则测试的名字应该指出这个特征，
例如<samp><var>feature</var><span class="file">-1.c</span></samp>。如果不是测试一个明确定义的特征，
而只是检验在编译器中存在的，并且是在GCC bug库中归档的bug，
则可以使用<samp><span class="file">pr</span><var>bug-number</var><span class="file">-1.c</span></samp>这样的名字形式。
否则（对于在GCC bug库中没有归档的各种bug），
测试用例根据它们被添加的日期来命名，这种情况在以前更加常见。
这样使人们能够一眼看出一个测试失败是由于一个新发现并且还没有被修复的bug造成的，
还是由于一个回退错误造成的，但它并没有给出关于bug的其它信息，
以及从哪里可以找到相关的讨论。一些其它语言的测试包也遵守类似的惯例。

 <p>在<samp><span class="file">gcc.dg</span></samp>测试包中，通常需要测试一个错误确实是硬件错误，
而不只是一个警告——例如，在C标准中的violatile限定，
在有<samp><span class="option">-pedantic-errors</span></samp>的时候必须为一个错误。为此，
可以使用下面的习惯用法，其中第一行为产生错误的文件的行<var>line</var>。

<pre class="smallexample">     /* { dg-bogus "warning" "warning in place of error" } */
     /* { dg-error "<var>regexp</var>" "<var>message</var>" { target *-*-* } <var>line</var> } */
</pre>
 <p>可能需要检查一个表达式为整数常量表达式，并且具有一个特定的值。
要检查<var>E</var>具有值<var>V</var>，可以使用类似下面的习惯用法：

<pre class="smallexample">     char x[((E) == (V) ? 1 : -1)];
</pre>
 <p>在<samp><span class="file">gcc.dg</span></samp>测试中，<code>__typeof__</code>有时被用于表达式类型的断言。
例如，可以参见<samp><span class="file">gcc.dg/c99-condexpr-1.c</span></samp>。
更加巧妙的用法依靠了C标准中条件表达式类型的确切规则；
例如，可以参见<samp><span class="file">gcc.dg/c99-intconst-1.c</span></samp>。

 <p>如果能够测试优化被做的很适当会很有帮助。这并不能在所有情况下都能做到，
但对于可以使得代码被优化掉的情况
（例如，流分析或别名分析应该显示那样的代码不会被调用），
或者函数将不被调用，因为它们已经被扩展为内建的函数时，是可以做到的。
这样的测试在<samp><span class="file">gcc.c-torture/execute</span></samp>中。
在将要被优化掉的代码的地方，可以插入一个像<code>link_failure ()</code>
这样的对一个不存在的函数的调用；并且还需要如下定义，

<pre class="smallexample">     #ifndef __OPTIMIZE__
     void
     link_failure (void)
     {
       abort ();
     }
     #endif
</pre>
 <p class="noindent">从而使得当测试在没有优化而运行时，连接依然成功。
当对一个内建函数的所有调用都已经被优化，并且不会剩下对函数的非内建版本的调用时，
那个函数可以定义为<code>static</code>，并且调用<code>abort ()</code>
（虽然将函数声明为静态的可能不会在所有的目标上工作）。

 <p>所有测试用例都必须是可移植的。
目标特定的测试用例必须具有适当的代码来避免在不支持的系统上引起失败；
不幸的是，这种机制随目录有所不同。

 <p>FIXME: 讨论一下非C的测试包。

 </body></html>

