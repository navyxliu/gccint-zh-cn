<html lang="zh">
<head>
<title>关于声明的操作 - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="_00e5_00a3_00b0_00e6_0098_008e.html#g_t_00e5_00a3_00b0_00e6_0098_008e" title="声明">
<link rel="next" href="_00e5_0086_0085_00e9_0083_00a8_00e7_00bb_0093_00e6_009e_0084.html#g_t_00e5_0086_0085_00e9_0083_00a8_00e7_00bb_0093_00e6_009e_0084" title="内部结构">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.2版本或者之后的任何版本，
对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文
字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在
标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行
     的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="%e5%85%b3%e4%ba%8e%e5%a3%b0%e6%98%8e%e7%9a%84%e6%93%8d%e4%bd%9c"></a>
<a name="g_t_00e5_0085_00b3_00e4_00ba_008e_00e5_00a3_00b0_00e6_0098_008e_00e7_009a_0084_00e6_0093_008d_00e4_00bd_009c"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="_00e5_0086_0085_00e9_0083_00a8_00e7_00bb_0093_00e6_009e_0084.html#g_t_00e5_0086_0085_00e9_0083_00a8_00e7_00bb_0093_00e6_009e_0084">内部结构</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="_00e5_00a3_00b0_00e6_0098_008e.html#g_t_00e5_00a3_00b0_00e6_0098_008e">声明</a>
<hr>
</div>

<h4 class="subsection">9.5.1 关于声明的操作</h4>

<p>一些宏可以用于任何种类的声明。这包括：
     <dl>
<dt><code>DECL_NAME</code><a name="index-DECL_005fNAME-1826"></a><dd>该宏返回一个<code>IDENTIFIER_NODE</code>，给出了实体的名字。

     <br><dt><code>TREE_TYPE</code><a name="index-TREE_005fTYPE-1827"></a><dd>该宏返回被声明的实体的类型。

     <br><dt><code>TREE_FILENAME</code><a name="index-TREE_005fFILENAME-1828"></a><dd>该宏返回被声明的实体所在的文件的名字，作为一个<code>char*</code>。对于由编译器隐式声明的实体（比如<code>__builtin_memcpy</code>），这将为字符串<code>"&lt;internal&gt;"</code>。

     <br><dt><code>TREE_LINENO</code><a name="index-TREE_005fLINENO-1829"></a><dd>该宏返回被声明的实体所在的行号，作为一个<code>int</code>。

     <br><dt><code>DECL_ARTIFICIAL</code><a name="index-DECL_005fARTIFICIAL-1830"></a><dd>该断言用来表示声明是否为编译器隐式产生的。例如，该断言可以用来存放一个隐式声明的成员函数，或者为一个class类型隐式生成的<code>TYPE_DECL</code>。回想一下在C++代码中：

     <pre class="smallexample">          struct S {};
</pre>
     <p class="noindent">大体上等价于C代码：
     <pre class="smallexample">          struct S {};
          typedef struct S S;
</pre>
     <p>隐式生成的<code>typedef</code>声明由<code>TYPE_DECL</code>表示，在<code>DECL_ARTIFICIAL</code>中存放。

     <br><dt><code>DECL_NAMESPACE_SCOPE_P</code><a name="index-DECL_005fNAMESPACE_005fSCOPE_005fP-1831"></a><dd>该断言用来表示实体是否在一个命名空间中被声明。

     <br><dt><code>DECL_CLASS_SCOPE_P</code><a name="index-DECL_005fCLASS_005fSCOPE_005fP-1832"></a><dd>该断言用来表示实体是否在一个class作用域中被声明。

     <br><dt><code>DECL_FUNCTION_SCOPE_P</code><a name="index-DECL_005fFUNCTION_005fSCOPE_005fP-1833"></a><dd>该断言用来表示实体是否在一个函数体中被声明。

 </dl>

 <p>各种类型的声明：
     <dl>
<dt><code>LABEL_DECL</code><dd>这些节点用于表示函数体内的标号。更多信息，可以参考<a href="Functions.html#Functions">Functions</a>。这些节点只出现在块作用域（block scope）。

     <br><dt><code>CONST_DECL</code><dd>这些节点用于表示枚举常量。常量的值由<code>DECL_INITIAL</code>给出，为一个<code>INTEGER_CST</code>，并且和<code>CONST_DECL</code>的<code>TREE_TYPE</code>具有相同的类型，即<code>ENUMERAL_TYPE</code>。

     <br><dt><code>RESULT_DECL</code><dd>这些节点表示函数的返回值。当<code>RESULT_DECL</code>被赋予一个值的时候，这表明该值将被函数通过按位拷贝的方式返回。就像对于<code>VAR_DECL</code>一样，你可以在<code>RESULT_DECL</code>上使用<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>。

     <br><dt><code>TYPE_DECL</code><dd>这些节点表示<code>typedef</code>声明。<code>TREE_TYPE</code>为被声明的类型，其名字由<code>DECL_NAME</code>给出。有些情况下，没有相关联的名字。

     <br><dt><code>VAR_DECL</code><dd>这些节点表示具有命名空间或者块作用域的变量，以及静态数据成员。<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>，类似于<code>TYPE_SIZE</code>和<code>TYPE_ALIGN</code>。对于声明，你应该总是使用<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>，而不是由<code>TREE_TYPE</code>给定的<code>TYPE_SIZE</code>和<code>TYPE_ALIGN</code>，因为，可能会对变量应用了特定的属性，使其具有特定的大小和对齐方式。你可以使用断言<code>DECL_THIS_STATIC</code>或<code>DECL_THIS_EXTERN</code>来测试是否使用了存储类别说明符<code>static</code>或<code>extern</code>来声明一个变量。

     <p>如果该变量被初始化（并需要一个构造者），则<code>DECL_INITIAL</code>将为初始化者的表达式。初始化者将被求值，并按位复制到变量中。如果<code>DECL_INITIAL</code>为<code>error_mark_node</code>，则表明存在一个初始化者，只不过它由之后代码中的显式的语句给出；这将不需要进行按位复制。

     <p>GCC提供了一个扩展，允许自动变量或者全局变量，被放到特定的寄存器中。如果<code>DECL_REGISTER</code>存放了<code>VAR_DECL</code>，并且<code>DECL_ASSEMBLER_NAME</code>不等于<code>DECL_NAME</code>，则<code>VAR_DECL</code>是使用了该扩展。这种情况下，<code>DECL_ASSEMBLER_NAME</code>为存放变量的寄存器的名字。

     <br><dt><code>PARM_DECL</code><dd>用于表示一个函数的参数。这些节点可以作为<code>VAR_DECL</code>节点来看待。这些节点只出现在<code>FUNCTION_DECL</code>的<code>DECL_ARGUMENTS</code>中。

     <p><code>PARM_DECL</code>的<code>DECL_ARG_TYPE</code>为，当值传给函数时实际使用的类型。其可以为一个比参数的<code>TREE_TYPE</code>更宽的类型；例如，原始类型可能为<code>short</code>，而<code>DECL_ARG_TYPE</code>为<code>int</code>。

     <br><dt><code>FIELD_DECL</code><dd>这些节点表示非静态数据成员。<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>的行为，跟<code>VAR_DECL</code>节点的一样。在父记录（parent record）中的域的位置，由三个属性组合指定。<code>DECL_FIELD_OFFSET</code>为按字节计数的位置，

     <p>如果DECL_C_BIT_FIELD有效，则该域是一个位域。在位域中，DECL_BIT_FIELD_TYPE还包含了原始指定的类型，而DECL_TYPE可能是根据位域的大小，修改后具有更少精度的类型。

     <br><dt><code>NAMESPACE_DECL</code><dd>See <a href="Namespaces.html#Namespaces">Namespaces</a>.

     <br><dt><code>TEMPLATE_DECL</code><dd>这些节点用于表示类，函数和变量（静态数据成员）模板。<code>DECL_TEMPLATE_SPECIALIZATIONS</code>为一个<code>TREE_LIST</code>。列表中每个节点的<code>TREE_VALUE</code>为一个<code>TEMPLATE_DECL</code>或者<code>FUNCTION_DECL</code>，表示该模板的特列（包括实例）。后端可以安全的忽略<code>TEMPLATE_DECL</code>，但是应该检查特例列表中的<code>FUNCTION_DECL</code>，就像是普通的<code>FUNCTION_DECL</code>节点一样。

     <p>对于类模板，<code>DECL_TEMPLATE_INSTANTIATIONS</code>列表包含了实例。每个节点的<code>TREE_VALUE</code>为类的一个实例。<code>DECL_TEMPLATE_SPECIALIZATIONS</code>包含了类的部分特例。

     <br><dt><code>USING_DECL</code><dd>后端可以安全的忽略掉这些节点。

 </dl>

 </body></html>

