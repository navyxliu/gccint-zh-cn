<html lang="zh">
<head>
<title>Sharing - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="Calls.html#Calls" title="Calls">
<link rel="next" href="Reading-RTL.html#Reading-RTL" title="Reading RTL">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Sharing"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Reading-RTL.html#Reading-RTL">Reading RTL</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Calls.html#Calls">Calls</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.21 结构共享假设</h3>

<p><a name="index-sharing-of-RTL-components-2291"></a><a name="index-RTL-structure-sharing-assumptions-2292"></a>
<!-- The compiler assumes that certain kinds of RTL expressions are unique; -->
<!-- there do not exist two distinct objects representing the same value. -->
<!-- In other cases, it makes an opposite assumption: that no RTL expression -->
<!-- object of a certain kind appears in more than one place in the -->
<!-- containing structure. -->
编译器假设某些类型的RTL表达式是唯一的；不会存在两个不同的对象表示相同的值。对于其它情况，有相反的假设：在被包含的结构体中，不会在多个地方出现某一类型的RTL表达式对象。

<!-- These assumptions refer to a single function; except for the RTL -->
<!-- objects that describe global variables and external functions, -->
<!-- and a few standard objects such as small integer constants, -->
<!-- no RTL objects are common to two functions. -->
 <p>这些假设针对于一个单独的函数；除了描述全局变量和外部函数的RTL对象，一些标准对象，例如小整形常数以外，没有其它RTL对象可以在两个函数中共用。

     
<a name="index-g_t_0040code_007breg_007d_002c-RTL-sharing-2293"></a>
<ul><li><!-- Each pseudo-register has only a single @code{reg} object to represent it, -->
<!-- and therefore only a single machine mode. -->
每一个伪寄存器只有一个单独的<code>reg</code>对象来表示，因此也只有一种机器模式。

     <p><a name="index-symbolic-label-2294"></a><a name="index-g_t_0040code_007bsymbol_005fref_007d_002c-RTL-sharing-2295"></a><li><!-- For any symbolic label, there is only one @code{symbol_ref} object -->
<!-- referring to it. -->
对于任何标号，只有一个<code>symbol_ref</code>对象关联。

     <p><a name="index-g_t_0040code_007bconst_005fint_007d_002c-RTL-sharing-2296"></a><li><!-- All @code{const_int} expressions with equal values are shared. -->
所有具有相同值的<code>const_int</code>表达式被共享。

     <p><a name="index-g_t_0040code_007bpc_007d_002c-RTL-sharing-2297"></a><li><!-- There is only one @code{pc} expression. -->
T只有一个<code>pc</code>表达式。

     <p><a name="index-g_t_0040code_007bcc0_007d_002c-RTL-sharing-2298"></a><li><!-- There is only one @code{cc0} expression. -->
只有一个<code>cc0</code>表达式。

     <p><a name="index-g_t_0040code_007bconst_005fdouble_007d_002c-RTL-sharing-2299"></a><li><!-- There is only one @code{const_double} expression with value 0 for -->
<!-- each floating point mode.  Likewise for values 1 and 2. -->
对于每一种浮点模式，只有一个<code>const_double</code>表达式其值为0。同样对于值1，2。

     <p><a name="index-g_t_0040code_007bconst_005fvector_007d_002c-RTL-sharing-2300"></a><li><!-- There is only one @code{const_vector} expression with value 0 for -->
<!-- each vector mode, be it an integer or a double constant vector. -->
对于每一种向量模式，只有一个<code>const_vector</code>表达式其值为0。其为整数或者双精度常量向量。

     <p><a name="index-g_t_0040code_007blabel_005fref_007d_002c-RTL-sharing-2301"></a><a name="index-g_t_0040code_007bscratch_007d_002c-RTL-sharing-2302"></a><li><!-- No @code{label_ref} or @code{scratch} appears in more than one place in -->
<!-- the RTL structure; in other words, it is safe to do a tree-walk of all -->
<!-- the insns in the function and assume that each time a @code{label_ref} -->
<!-- or @code{scratch} is seen it is distinct from all others that are seen. -->
在RTL结构体中不会在多个地方出现<code>label_ref</code>或<code>scratch</code>；换句话说，对函数中所有insn进行树遍历时，可以认为每次遇到的<code>label_ref</code>或者<code>scratch</code>都与在其它地方遇到的不同。

     <p><a name="index-g_t_0040code_007bmem_007d_002c-RTL-sharing-2303"></a><li><!-- Only one @code{mem} object is normally created for each static -->
<!-- variable or stack slot, so these objects are frequently shared in all -->
<!-- the places they appear.  However, separate but equal objects for these -->
<!-- variables are occasionally made. -->
对于每个静态变量或者栈槽，通常只创建一个<code>mem</code>对象，所以这些对象在它们出现的所有地方被共享。然而，有时会为这些变量创建单独的，但是相等的对象。

     <p><a name="index-g_t_0040code_007basm_005foperands_007d_002c-RTL-sharing-2304"></a><li><!-- When a single @code{asm} statement has multiple output operands, a -->
<!-- distinct @code{asm_operands} expression is made for each output operand. -->
<!-- However, these all share the vector which contains the sequence of input -->
<!-- operands.  This sharing is used later on to test whether two -->
<!-- @code{asm_operands} expressions come from the same statement, so all -->
<!-- optimizations must carefully preserve the sharing if they copy the -->
<!-- vector at all. -->
当一个单独的<code>asm</code>语句具有多个输出操作数时，会为每一个输出数创建一个不同的<code>asm_operands</code>表达式。然后，这些表达式都共享包含着输入操作数序列的向量。这是为了之后用于测试两个<code>asm_operands</code>表达式是否来自同一语句，所以，所有的优化当进行复制整个向量时，必须仔细保持共享。

     <li><!-- No RTL object appears in more than one place in the RTL structure -->
<!-- except as described above.  Many passes of the compiler rely on this -->
<!-- by assuming that they can modify RTL objects in place without unwanted -->
<!-- side-effects on other insns. -->
除了上面描述的以外，在RTL结构体中没有其它RTL对象会出现多次。编译器的许多遍扫描，都是依赖于这样的假设，即它们能在一个地方修改RTL对象，并且不会对其它insn产生不需要的副作用。

     <p><a name="index-unshare_005fall_005frtl-2305"></a><li><!-- During initial RTL generation, shared structure is freely introduced. -->
<!-- After all the RTL for a function has been generated, all shared -->
<!-- structure is copied by @code{unshare_all_rtl} in @file{emit-rtl.c}, -->
<!-- after which the above rules are guaranteed to be followed. -->
在最初的RTL生成过程中，可以随意使用共享结构。当一个函数的所有RTL都被生成之后，所有的共享结构体都被<samp><span class="file">emit-rtl.c</span></samp>中的<code>unshare_all_rtl</code>进行复制，之后，将保证上面的规则会被遵循。

     <p><a name="index-copy_005frtx_005fif_005fshared-2306"></a><li><!-- During the combiner pass, shared structure within an insn can exist -->
<!-- temporarily.  However, the shared structure is copied before the -->
<!-- combiner is finished with the insn.  This is done by calling -->
<!-- @code{copy_rtx_if_shared}, which is a subroutine of -->
<!-- @code{unshare_all_rtl}. -->
在合并阶段，共享结构体可以在insn中临时存在。但是，在insn的合并完成之前，共享结构会被复制，通过调用<code>unshare_all_rtl</code>的子程序<code>copy_rtx_if_shared</code>。

 </ul>

<!-- @node Reading RTL -->
<!-- @section Reading RTL -->
 </body></html>

