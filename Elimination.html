<html lang="zh">
<head>
<title>Elimination - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="prev" href="Frame-Registers.html#Frame-Registers" title="Frame Registers">
<link rel="next" href="Stack-Arguments.html#Stack-Arguments" title="Stack Arguments">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Elimination"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Stack-Arguments.html#Stack-Arguments">Stack Arguments</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Frame-Registers.html#Frame-Registers">Frame Registers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>
<hr>
</div>

<h4 class="subsection">17.10.5 消除帧指针和参数指针</h4>

<!-- prevent bad page break with this line -->
<!-- This is about eliminating the frame pointer and arg pointer. -->
<p>这些是关于消除帧指针和参数指针的。

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_FRAME_POINTER_REQUIRED</b> (<var>void</var>)<var><a name="index-TARGET_005fFRAME_005fPOINTER_005fREQUIRED-4114"></a></var><br>
<blockquote><p>This target hook should return <code>true</code> if a function must have and use
a frame pointer.  This target hook is called in the reload pass.  If its return
value is <code>true</code> the function will have a frame pointer.

      <p>This target hook can in principle examine the current function and decide
according to the facts, but on most machines the constant <code>false</code> or the
constant <code>true</code> suffices.  Use <code>false</code> when the machine allows code
to be generated with no frame pointer, and doing so saves some time or space. 
Use <code>true</code> when there is no possible advantage to avoiding a frame
pointer.

      <p>In certain cases, the compiler does not know how to produce valid code
without a frame pointer.  The compiler recognizes those cases and
automatically gives the function a frame pointer regardless of what
<code>TARGET_FRAME_POINTER_REQUIRED</code> returns.  You don't need to worry about
them.

      <p>In a function that does not require a frame pointer, the frame pointer
register can be allocated for ordinary usage, unless you mark it as a
fixed register.  See <code>FIXED_REGISTERS</code> for more information.

      <p>Default return value is <code>false</code>. 
</p></blockquote></div>

 <p><a name="index-get_005fframe_005fsize-4115"></a>

<div class="defun">
&mdash; Macro: <b>INITIAL_FRAME_POINTER_OFFSET</b> (<var>depth-var</var>)<var><a name="index-INITIAL_005fFRAME_005fPOINTER_005fOFFSET-4116"></a></var><br>
<blockquote><!-- A C statement to store in the variable @var{depth-var} the difference -->
     <!-- between the frame pointer and the stack pointer values immediately after -->
     <!-- the function prologue.  The value would be computed from information -->
     <!-- such as the result of @code{get_frame_size ()} and the tables of -->
     <!-- registers @code{regs_ever_live} and @code{call_used_regs}. -->
      <p>一条C语句，用来紧接着函数序言之后，将帧指针和栈指针值的差存储在<var>depth-var</var>中。该值应该通过像<code>get_frame_size ()</code>这样的结果信息以及寄存器表<code>regs_ever_live</code>和<code>call_used_regs</code>中被计算。

     <!-- If @code{ELIMINABLE_REGS} is defined, this macro will be not be used and -->
     <!-- need not be defined.  Otherwise, it must be defined even if -->
     <!-- @code{TARGET_FRAME_POINTER_REQUIRED} always returns true; in that -->
     <!-- case, you may set @var{depth-var} to anything. -->
      <p>如果<code>ELIMINABLE_REGS</code>被定义，则该宏将不被使用并不需要被定义。否则，其必须被定义，即使<code>FRAME_POINTER_REQUIRED</code>被定义为总是为真；这这种情况下，你可以设置<var>depth-var</var>为任何值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ELIMINABLE_REGS</b><var><a name="index-ELIMINABLE_005fREGS-4117"></a></var><br>
<blockquote><!-- If defined, this macro specifies a table of register pairs used to -->
     <!-- eliminate unneeded registers that point into the stack frame.  If it is not -->
     <!-- defined, the only elimination attempted by the compiler is to replace -->
     <!-- references to the frame pointer with references to the stack pointer. -->
      <p>如果被定义，则该宏指定了一个寄存器双对的表，用于消除不需要的指向栈帧的寄存器。如果没有被定义，则编译器唯一尝试去做的消除是将对帧指针的引用替换为对栈指针的引用。

     <!-- The definition of this macro is a list of structure initializations, each -->
     <!-- of which specifies an original and replacement register. -->
      <p>该宏的定义为一个结构体初始化列表，每个指定了最初的和替换后的寄存器。

     <!-- On some machines, the position of the argument pointer is not known until -->
     <!-- the compilation is completed.  In such a case, a separate hard register -->
     <!-- must be used for the argument pointer.  This register can be eliminated by -->
     <!-- replacing it with either the frame pointer or the argument pointer, -->
     <!-- depending on whether or not the frame pointer has been eliminated. -->
      <p>在一些机器上，参数指针的位置直到编译结束时才知道。这种情况下，一个单独的硬件寄存器必须用于参数指针。该寄存器可以通过替换为帧指针或者参数指针来消除，这取决于帧指针是否已经被消除。

     <!-- In this case, you might specify: -->
      <p>这种情况下，你可能会指定：

     <pre class="smallexample">          #define ELIMINABLE_REGS  \
          {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
           {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
           {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
</pre>
      <!-- Note that the elimination of the argument pointer with the stack pointer is -->
     <!-- specified first since that is the preferred elimination. -->
      <p>注意首先指定的是使用栈指针来消除参数指针，因为这是首选的消除方式。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CAN_ELIMINATE</b> (<var>const int from_reg, const int to_reg</var>)<var><a name="index-TARGET_005fCAN_005fELIMINATE-4118"></a></var><br>
<blockquote><p>This target hook should returns <code>true</code> if the compiler is allowed to
try to replace register number <var>from_reg</var> with register number
<var>to_reg</var>.  This target hook need only be defined if <code>ELIMINABLE_REGS</code>
is defined, and will usually be <code>true</code>, since most of the cases
preventing register elimination are things that the compiler already
knows about.

      <p>Default return value is <code>true</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INITIAL_ELIMINATION_OFFSET</b> (<var>from-reg, to-reg, offset-var</var>)<var><a name="index-INITIAL_005fELIMINATION_005fOFFSET-4119"></a></var><br>
<blockquote><!-- This macro is similar to @code{INITIAL_FRAME_POINTER_OFFSET}.  It -->
     <!-- specifies the initial difference between the specified pair of -->
     <!-- registers.  This macro must be defined if @code{ELIMINABLE_REGS} is -->
     <!-- defined. -->
      <p>该宏类似于<code>INITIAL_FRAME_POINTER_OFFSET</code>。其指定了被指定的寄存器双对的初始差。该宏必须被定义，如果<code>ELIMINABLE_REGS</code>被定义。
</p></blockquote></div>

<!-- @node Stack Arguments -->
<!-- @subsection Passing Function Arguments on the Stack -->
 </body></html>

