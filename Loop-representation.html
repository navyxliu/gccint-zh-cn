<html lang="zh">
<head>
<title>Loop representation - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Loop-Analysis-and-Representation.html#Loop-Analysis-and-Representation" title="Loop Analysis and Representation">
<link rel="next" href="Loop-querying.html#Loop-querying" title="Loop querying">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Loop-representation"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Loop-querying.html#Loop-querying">Loop querying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Loop-Analysis-and-Representation.html#Loop-Analysis-and-Representation">Loop Analysis and Representation</a>
<hr>
</div>

<h3 class="section">14.1 循环表示</h3>

<p><a name="index-Loop-representation-3120"></a><a name="index-Loop-analysis-3121"></a>
<!-- This chapter describes the representation of loops in GCC, and functions -->
<!-- that can be used to build, modify and analyze this representation.  Most -->
<!-- of the interfaces and data structures are declared in @file{cfgloop.h}. -->
<!-- At the moment, loop structures are analyzed and this information is -->
<!-- updated only by the optimization passes that deal with loops, but some -->
<!-- efforts are being made to make it available throughout most of the -->
<!-- optimization passes. -->
这章描述了GCC中循环的表示，以及可以用来构建，修改和分析这些表示的函数。大多数接口和数据结构都在<samp><span class="file">cfgloop.h</span></samp>中声明。目前，只是由处理循环的优化过程来分析这些循环结构和更新这些信息，不过正在做一些努力，使得其在大多数优化过程中都可用。

<!-- In general, a natural loop has one entry block (header) and possibly -->
<!-- several back edges (latches) leading to the header from the inside of -->
<!-- the loop.  Loops with several latches may appear if several loops share -->
<!-- a single header, or if there is a branching in the middle of the loop. -->
<!-- The representation of loops in GCC however allows only loops with a -->
<!-- single latch.  During loop analysis, headers of such loops are split and -->
<!-- forwarder blocks are created in order to disambiguate their structures. -->
<!-- Heuristic based on profile information and structure of the induction -->
<!-- variables in the loops is used to determine whether the latches -->
<!-- correspond to sub-loops or to control flow in a single loop.  This means -->
<!-- that the analysis sometimes changes the CFG, and if you run it in the -->
<!-- middle of an optimization pass, you must be able to deal with the new -->
<!-- blocks.  You may avoid CFG changes by passing -->
<!-- @code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES} flag to the loop discovery, -->
<!-- note however that most other loop manipulation functions will not work -->
<!-- correctly for loops with multiple latch edges (the functions that only -->
<!-- query membership of blocks to loops and subloop relationships, or -->
<!-- enumerate and test loop exits, can be expected to work). -->
 <p>通常，一个自然的循环会具有一个入口块（header），以及可能多个的从循环内部通向header的回边（latch）。如果多个循环共享单个 header，或者在循环中间有个分支跳转，则可能会出现带有多个latch的循环。然而GCC中对循环的表示只允许具有单个latch。在循环分析过程中，为了消除循环结构的歧义，这样的循环的header会被拆分，并创建前向的块。基于profile信息的heuristic，以及循环中的归纳变量的结构被用来判定latches是否与子循环相关，还是与单个循环中的控制流相关。这意味着分析有时候会改变CFG，并且如果你在一个优化过程的中间运行了该分析，则必须能够处理新的块。可以通过传递<code>LOOPS_MAY_HAVE_MULTIPLE_LATCHES</code>标记来避免CFG改变，但是要注意，对于具有多个latch边的循环，大多其它的循环操作函数将无法正确工作（只有查询块成员与循环和子循环关系的，或者枚举和测试循环出口的函数能够工作）。

<!-- Body of the loop is the set of blocks that are dominated by its header, -->
<!-- and reachable from its latch against the direction of edges in CFG@.  The -->
<!-- loops are organized in a containment hierarchy (tree) such that all the -->
<!-- loops immediately contained inside loop L are the children of L in the -->
<!-- tree.  This tree is represented by the @code{struct loops} structure. -->
<!-- The root of this tree is a fake loop that contains all blocks in the -->
<!-- function.  Each of the loops is represented in a @code{struct loop} -->
<!-- structure.  Each loop is assigned an index (@code{num} field of the -->
<!-- @code{struct loop} structure), and the pointer to the loop is stored in -->
<!-- the corresponding field of the @code{larray} vector in the loops -->
<!-- structure.  The indices do not have to be continuous, there may be -->
<!-- empty (@code{NULL}) entries in the @code{larray} created by deleting -->
<!-- loops.  Also, there is no guarantee on the relative order of a loop -->
<!-- and its subloops in the numbering.  The index of a loop never changes. -->
 <p>循环体是由header支配的一组基本块，并且可以通过回边沿着CFG中边的方向达到。循环使用树的层次结构来组织，直接包含在循环L中的所有循环在树中都为L的子节点。该树由<code>struct loops</code>结构体表示。该树的根是一个假循环，包含了函数中的所有块。每个循环都由<code>struct loop</code>结构体表示。每个循环都被赋予一个索引（<code>struct loop</code>结构体的<code>num</code>域），并且指向循环的指针被存在<code>struct loops</code>结构体中的<code>larray</code>向量的对应域里。索引不必是连续的，<code>larray</code>中可能会有空项（<code>NULL</code>），是由删除循环产生的。而且不保证索引的数字与循环和子循环有关系。循环的索引不会改变。

<!-- The entries of the @code{larray} field should not be accessed directly. -->
<!-- The function @code{get_loop} returns the loop description for a loop with -->
<!-- the given index.  @code{number_of_loops} function returns number of -->
<!-- loops in the function.  To traverse all loops, use @code{FOR_EACH_LOOP} -->
<!-- macro.  The @code{flags} argument of the macro is used to determine -->
<!-- the direction of traversal and the set of loops visited.  Each loop is -->
<!-- guaranteed to be visited exactly once, regardless of the changes to the -->
<!-- loop tree, and the loops may be removed during the traversal.  The newly -->
<!-- created loops are never traversed, if they need to be visited, this -->
<!-- must be done separately after their creation.  The @code{FOR_EACH_LOOP} -->
<!-- macro allocates temporary variables.  If the @code{FOR_EACH_LOOP} loop -->
<!-- were ended using break or goto, they would not be released; -->
<!-- @code{FOR_EACH_LOOP_BREAK} macro must be used instead. -->
 <p>不要直接访问<code>larray</code>域中的项。函数<code>get_loop</code>返回给定索引的循环描述。<code>number_of_loops</code>函数返回函数中的循环数目。要遍历所有的循环，使用<code>FOR_EACH_LOOP</code>宏。宏的标记参数用来决定遍历的方向和要访问的循环集。不管循环树是否变化，以及在遍历过程中循环是否被移除，每个循环都保证只被访问一次。新创建的循环将不会被访问到，如果需要访问，这必须在它们创建之后单独进行。<code>FOR_EACH_LOOP</code>宏会分配临时变量，如果使用break或者goto终止了<code>FOR_EACH_LOOP</code>，它们将不会被释放；因此必须使用<code>FOR_EACH_LOOP_BREAK</code>宏。

<!-- Each basic block contains the reference to the innermost loop it belongs -->
<!-- to (@code{loop_father}).  For this reason, it is only possible to have -->
<!-- one @code{struct loops} structure initialized at the same time for each -->
<!-- CFG@.  The global variable @code{current_loops} contains the -->
<!-- @code{struct loops} structure.  Many of the loop manipulation functions -->
<!-- assume that dominance information is up-to-date. -->
 <p>每个基本块包含了对其所属的最内层循环的引用（<code>loop_father</code>）。基于这个原因，对每个CFG只可能有一个<code>struct loops</code>结构体在同一时间被初始化。全局变量<code>current_loops</code>包含了<code>struct loops</code>结构体。许多循环操作函数都假设dominance信息是最新的。

<!-- The loops are analyzed through @code{loop_optimizer_init} function.  The -->
<!-- argument of this function is a set of flags represented in an integer -->
<!-- bitmask.  These flags specify what other properties of the loop -->
<!-- structures should be calculated/enforced and preserved later: -->
 <p>通过<code>loop_optimizer_init</code>函数来分析循环。该函数的参数是一个标记集，使用整数位掩码表示。这些标记指定了循环结构体的其它哪些属性将在之后被计算/赋予，并且保留：

     <ul>
<!-- @item @code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES}: If this flag is set, no -->
<!-- changes to CFG will be performed in the loop analysis, in particular, -->
<!-- loops with multiple latch edges will not be disambiguated.  If a loop -->
<!-- has multiple latches, its latch block is set to NULL@.  Most of -->
<!-- the loop manipulation functions will not work for loops in this shape. -->
<!-- No other flags that require CFG changes can be passed to -->
<!-- loop_optimizer_init. -->
<li><code>LOOPS_MAY_HAVE_MULTIPLE_LATCHES</code>: 如果设置了该标记，循环分析将不会改变CFG，特别的，具有多个回边的循环将不会被消除歧义。如果循环具有多个回边，它的回边块被设为NULL。对于这种形式，大多循环操作函数将无法工作。
<!-- @item @code{LOOPS_HAVE_PREHEADERS}: Forwarder blocks are created in such -->
<!-- a way that each loop has only one entry edge, and additionally, the -->
<!-- source block of this entry edge has only one successor.  This creates a -->
<!-- natural place where the code can be moved out of the loop, and ensures -->
<!-- that the entry edge of the loop leads from its immediate super-loop. -->
<li><code>LOOPS_HAVE_PREHEADERS</code>: 创建前驱块的方法为，每个循环只有一个入口边，另外，这个入口边的源块只有一个后继。这就创建了一个自然的位置，使得代码能够被移出循环，并且保证循环的入口边由它的直接外循环进来。
<!-- @item @code{LOOPS_HAVE_SIMPLE_LATCHES}: Forwarder blocks are created to -->
<!-- force the latch block of each loop to have only one successor.  This -->
<!-- ensures that the latch of the loop does not belong to any of its -->
<!-- sub-loops, and makes manipulation with the loops significantly easier. -->
<!-- Most of the loop manipulation functions assume that the loops are in -->
<!-- this shape.  Note that with this flag, the ``normal'' loop without any -->
<!-- control flow inside and with one exit consists of two basic blocks. -->
<li><code>LOOPS_HAVE_SIMPLE_LATCHES</code>: 创建前驱块，从而使得每个循环的回边块只有一个后继。这就保证了循环的回边不属于任何子循环，并且使得对循环的操作变得非常容易。许多循环操作函数都假设循环是处于这种形式的。注意使用该标记时，其中没有任何控制流，且只有一个出口的“正常”循环，将包括两个基本块。
<!-- @item @code{LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS}: Basic blocks and -->
<!-- edges in the strongly connected components that are not natural loops -->
<!-- (have more than one entry block) are marked with -->
<!-- @code{BB_IRREDUCIBLE_LOOP} and @code{EDGE_IRREDUCIBLE_LOOP} flags.  The -->
<!-- flag is not set for blocks and edges that belong to natural loops that -->
<!-- are in such an irreducible region (but it is set for the entry and exit -->
<!-- edges of such a loop, if they lead to/from this region). -->
<li><code>LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS</code>: 强连通组件中的基本块和边，如果不是自然循环（具有多个入口块），将被<code>BB_IRREDUCIBLE_LOOP</code>和<code>EDGE_IRREDUCIBLE_LOOP</code>标记。在这样的不可消减区域中的块和边，如果属于自然循环的，则不被标记（但是会为进入和离开该区域的入口边和出口边做标记）。
<!-- @item @code{LOOPS_HAVE_RECORDED_EXITS}: The lists of exits are recorded -->
<!-- and updated for each loop.  This makes some functions (e.g., -->
<!-- @code{get_loop_exit_edges}) more efficient.  Some functions (e.g., -->
<!-- @code{single_exit}) can be used only if the lists of exits are -->
<!-- recorded. -->
<li><code>LOOPS_HAVE_RECORDED_EXITS</code>: 为每个循环记录并更新出口列表。这使得一些函数（如<code>get_loop_exit_edges</code>）更加有效。一些函数（如<code>single_exit</code>）只有在出口列表被记录的情况下才能用。
</ul>

<!-- These properties may also be computed/enforced later, using functions -->
<!-- @code{create_preheaders}, @code{force_single_succ_latches}, -->
<!-- @code{mark_irreducible_loops} and @code{record_loop_exits}. -->
 <p>这些属性也可以在之后使用函数<code>create_preheaders</code>, <code>force_single_succ_latches</code>,<code>mark_irreducible_loops</code>和<code>record_loop_exits</code>来求得/赋予。

<!-- The memory occupied by the loops structures should be freed with -->
<!-- @code{loop_optimizer_finalize} function. -->
 <p>循环结构体占用的内存应该在<code>loop_optimizer_finalize</code>函数中被释放。

<!-- The CFG manipulation functions in general do not update loop structures. -->
<!-- Specialized versions that additionally do so are provided for the most -->
<!-- common tasks.  On GIMPLE, @code{cleanup_tree_cfg_loop} function can be -->
<!-- used to cleanup CFG while updating the loops structures if -->
<!-- @code{current_loops} is set. -->
 <p>CFG操作函数通常不更新循环结构体。在GIMPLE上，如果设置了<code>current_loops</code>，则<code>cleanup_tree_cfg_loop</code>可以被用来在清除CFG的同时，更新循环结构体。

<!-- @node Loop querying -->
<!-- @section Loop querying -->
 </body></html>

