@c Copyright (C) 2002, 2010 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node Languages
@chapter GCC语言前端

The interface to front ends for languages in GCC, and in particular
the @code{tree} structure (@pxref{GENERIC}), was initially designed for
C, and many aspects of it are still somewhat biased towards C and
C-like languages.  It is, however, reasonably well suited to other
procedural languages, and front ends for many such languages have been
written for GCC@.

GCC的前端接口，尤其是@code{tree}结构(@pxref{GENERIC})，刚开始的时候是针对C设计的，
而且迄今为止还是或多或少的偏向于C和类C的语言。但是它也适合其它的过程式语言，
并且已经有了不少这样的语言实现了GCC的前端。

Writing a compiler as a front end for GCC, rather than compiling
directly to assembler or generating C code which is then compiled by
GCC, has several advantages:

实现一个GCC前端编译器而不是直接把源语言编译成汇编代码，或是转换成C代码之后再交由GCC处理，
有如下好处：

@itemize @bullet
@item 实现成GCC前端，可以直接使用已有的大量GCC后端。
@item 实现成GCC前端，可以直接使用已有的所有优化。有些优化，像是别名分析，
直接把源语言编译成树结构要比先转换成C代码再用GCC处理效果更好。
@item 实现成GCC前端可以提供更好的编译信息支持。
@end itemize

Because of the advantages of writing a compiler as a GCC front end,
GCC front ends have also been created for languages very different
from those for which GCC was designed, such as the declarative
logic/functional language Mercury.  For these reasons, it may also be
useful to implement compilers created for specialized purposes (for
example, as part of a research project) as GCC front ends.

鉴于编译成GCC前端的诸多好处，许多和GCC设计初衷迥异的语言也实现了GCC前端，像是Mercury，
一个声明式逻辑/函数式语言（declarative logic/functional language）。
基于这些原因，把用于特殊目的（例如研究项目）编译器实现成GCC前端可能也是很有好处的。

