<html lang="zh">
<head>
<title>LCSSA - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Loop-Analysis-and-Representation.html#Loop-Analysis-and-Representation" title="Loop Analysis and Representation">
<link rel="prev" href="Loop-manipulation.html#Loop-manipulation" title="Loop manipulation">
<link rel="next" href="Scalar-evolutions.html#Scalar-evolutions" title="Scalar evolutions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="LCSSA"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Scalar-evolutions.html#Scalar-evolutions">Scalar evolutions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Loop-manipulation.html#Loop-manipulation">Loop manipulation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Loop-Analysis-and-Representation.html#Loop-Analysis-and-Representation">Loop Analysis and Representation</a>
<hr>
</div>

<h3 class="section">14.4 循环封闭的SSA形式</h3>

<p><a name="index-LCSSA-3124"></a><a name="index-Loop_002dclosed-SSA-form-3125"></a>
<!-- Throughout the loop optimizations on tree level, one extra condition is -->
<!-- enforced on the SSA form:  No SSA name is used outside of the loop in -->
<!-- that it is defined.  The SSA form satisfying this condition is called -->
<!-- ``loop-closed SSA form'' - LCSSA@.  To enforce LCSSA, PHI nodes must be -->
<!-- created at the exits of the loops for the SSA names that are used -->
<!-- outside of them.  Only the real operands (not virtual SSA names) are -->
<!-- held in LCSSA, in order to save memory. -->
在整个树级的循环优化过程中，SSA形式需要有一个额外的加强条件：没有SSA名字在它所定义的循环之外被使用。满足这样条件的SSA形式称作“循环封闭的SSA形式”-LCSSA。为了形成LCSSA，对于在循环外使用SSA名字的，必须在循环的出口创建PHI节点。为了节省内存，在LCSSA中只支持实际的操作数（不包括虚拟SSA名）。

<!-- There are various benefits of LCSSA: -->
 <p>LCSSA有许多好处：

<!-- @itemize -->
<!-- @item Many optimizations (value range analysis, final value -->
<!-- replacement) are interested in the values that are defined in the loop -->
<!-- and used outside of it, i.e., exactly those for that we create new PHI -->
<!-- nodes. -->
<!-- @item In induction variable analysis, it is not necessary to specify the -->
<!-- loop in that the analysis should be performed - the scalar evolution -->
<!-- analysis always returns the results with respect to the loop in that the -->
<!-- SSA name is defined. -->
<!-- @item It makes updating of SSA form during loop transformations simpler. -->
<!-- Without LCSSA, operations like loop unrolling may force creation of PHI -->
<!-- nodes arbitrarily far from the loop, while in LCSSA, the SSA form can be -->
<!-- updated locally.  However, since we only keep real operands in LCSSA, we -->
<!-- cannot use this advantage (we could have local updating of real -->
<!-- operands, but it is not much more efficient than to use generic SSA form -->
<!-- updating for it as well; the amount of changes to SSA is the same). -->
<!-- @end itemize -->
     <ul>
<li>许多优化（值范围分析，最终值替换）都对在循环中定义的而在循环外使用的值感兴趣，即，对那些我们创建的新PHI节点。
<li>在归约变量分析中，没有必要指定将要执行分析的循环——标量演化分析总是返回SSA名字被定义的循环。
<li>它使得循环转换中更新SSA形式变得更简单。没有LCSSA的话，像循环展开这样的操作可能会强迫创建距离循环任意远的PHI节点，然而使用LCSSA的话，SSA形式能够被局部更新。不过，由于我们只是在LCSSA中保持真实的操作书，所以我们不能使用这个好处（我们本来能够局部更新真实操作数，但是这样并不比使用通用SSA形式更新更有效；对SSA的改动是相同的）。
</ul>

<!-- However, it also means LCSSA must be updated.  This is usually -->
<!-- straightforward, unless you create a new value in loop and use it -->
<!-- outside, or unless you manipulate loop exit edges (functions are -->
<!-- provided to make these manipulations simple). -->
<!-- @code{rewrite_into_loop_closed_ssa} is used to rewrite SSA form to -->
<!-- LCSSA, and @code{verify_loop_closed_ssa} to check that the invariant of -->
<!-- LCSSA is preserved. -->
 <p>不管怎样，这还意味着LCSSA必须被更新。这通常是很直白的，除非你在循环中创建了一个新值，并在外面使用，或者除非你操作了循环出口边（有函数被提供使得这些操作变得简单）。<code>rewrite_into_loop_closed_ssa</code>用来将SSA形式重写为 LCSSA，<code>verify_loop_closed_ssa</code>用来检查LCSSA所保持的不变性。

<!-- @node Scalar evolutions -->
<!-- @section Scalar evolutions -->
 </body></html>

