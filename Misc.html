<html lang="zh">
<head>
<title>Misc - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Named-Address-Spaces.html#Named-Address-Spaces" title="Named Address Spaces">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Misc"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Named-Address-Spaces.html#Named-Address-Spaces">Named Address Spaces</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.31 其它参数</h3>

<p><a name="index-parameters_002c-miscellaneous-4786"></a>
<!-- prevent bad page break with this line -->
<!-- Here are several miscellaneous parameters. -->
这是一些其它参数。

<div class="defun">
&mdash; Macro: <b>HAS_LONG_COND_BRANCH</b><var><a name="index-HAS_005fLONG_005fCOND_005fBRANCH-4787"></a></var><br>
<blockquote><!-- Define this boolean macro to indicate whether or not your architecture -->
     <!-- has conditional branches that can span all of memory.  It is used in -->
     <!-- conjunction with an optimization that partitions hot and cold basic -->
     <!-- blocks into separate sections of the executable.  If this macro is -->
     <!-- set to false, gcc will convert any conditional branches that attempt -->
     <!-- to cross between sections into unconditional branches or indirect jumps. -->
      <p>定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的条件分支转换为无条件分支或间接跳转。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HAS_LONG_UNCOND_BRANCH</b><var><a name="index-HAS_005fLONG_005fUNCOND_005fBRANCH-4788"></a></var><br>
<blockquote><!-- Define this boolean macro to indicate whether or not your architecture -->
     <!-- has unconditional branches that can span all of memory.  It is used in -->
     <!-- conjunction with an optimization that partitions hot and cold basic -->
     <!-- blocks into separate sections of the executable.  If this macro is -->
     <!-- set to false, gcc will convert any unconditional branches that attempt -->
     <!-- to cross between sections into indirect jumps. -->
      <p>定义该布尔值的宏用来指示你的体系结构是否具有可以跨越所有内存的无条件分支。
它用于将可执行程序hot和cold基本块分割到单独的段的优化。
如果该宏被设为false，则gcc将任何穿越段的无条件分支转换为间接跳转。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_VECTOR_MODE</b><var><a name="index-CASE_005fVECTOR_005fMODE-4789"></a></var><br>
<blockquote><!-- An alias for a machine mode name.  This is the machine mode that -->
     <!-- elements of a jump-table should have. -->
      <p>机器模式名字的一个别名。这是跳转表（jump-table）的元素应该具有的机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_VECTOR_SHORTEN_MODE</b> (<var>min_offset, max_offset, body</var>)<var><a name="index-CASE_005fVECTOR_005fSHORTEN_005fMODE-4790"></a></var><br>
<blockquote><!-- Optional: return the preferred mode for an @code{addr_diff_vec} -->
     <!-- when the minimum and maximum offset are known.  If you define this, -->
     <!-- it enables extra code in branch shortening to deal with @code{addr_diff_vec}. -->
     <!-- To make this work, you also have to define @code{INSN_ALIGN} and -->
     <!-- make the alignment for @code{addr_diff_vec} explicit. -->
     <!-- The @var{body} argument is provided so that the offset_unsigned and scale -->
     <!-- flags can be updated. -->
      <p>可选的：当最小值和最大值位移已知时，返回<code>addr_diff_vec</code>的首选机器模式。
如果定义了该宏，这使得在分支缩短中增加了额外的代码来处理<code>addr_diff_vec</code>。
要使其工作，还必须要定义<code>INSN_ALIGN</code>，
并且显示的对<code>addr_diff_vec</code>进行对齐。参数<var>body</var>被提供，
使得可以更新<code>offset_unsigned</code>和标量标记。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_VECTOR_PC_RELATIVE</b><var><a name="index-CASE_005fVECTOR_005fPC_005fRELATIVE-4791"></a></var><br>
<blockquote><!-- Define this macro to be a C expression to indicate when jump-tables -->
     <!-- should contain relative addresses.  You need not define this macro if -->
     <!-- jump-tables never contain relative addresses, or jump-tables should -->
     <!-- contain relative addresses only when @option{-fPIC} or @option{-fPIC} -->
     <!-- is in effect. -->
      <p>定义该宏为一个C表达式，来指示跳转表什么时候应该包含相对地址。
你不需要定义该宏，如果跳转表从来不包含相对地址，
或者跳转表只在<samp><span class="option">-fPIC</span></samp>或者<samp><span class="option">-fPIC</span></samp>有效时才包含相对地址。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: unsigned int <b>TARGET_CASE_VALUES_THRESHOLD</b> (<var>void</var>)<var><a name="index-TARGET_005fCASE_005fVALUES_005fTHRESHOLD-4792"></a></var><br>
<blockquote><!-- This function return the smallest number of different values for which it -->
     <!-- is best to use a jump-table instead of a tree of conditional branches. -->
     <!-- The default is four for machines with a @code{casesi} instruction and -->
     <!-- five otherwise.  This is best for most machines. -->
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>CASE_USE_BIT_TESTS</b><var><a name="index-CASE_005fUSE_005fBIT_005fTESTS-4793"></a></var><br>
<blockquote><!-- Define this macro to be a C expression to indicate whether C switch -->
     <!-- statements may be implemented by a sequence of bit tests.  This is -->
     <!-- advantageous on processors that can efficiently implement left shift -->
     <!-- of 1 by the number of bits held in a register, but inappropriate on -->
     <!-- targets that would require a loop.  By default, this macro returns -->
     <!-- @code{true} if the target defines an @code{ashlsi3} pattern, and -->
     <!-- @code{false} otherwise. -->
      <p>定义该宏为一个C表达式，来指示C switch语句是否可以通过位测试序列来实现。
这在可以通过寄存器中的位数来有效实现左移1位的处理器上很有利，
但不适合需要循环的target。缺省下，该宏返回<code>true</code>，
如果target定义了<code>ashlsi3</code>指令模式，否则返回<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WORD_REGISTER_OPERATIONS</b><var><a name="index-WORD_005fREGISTER_005fOPERATIONS-4794"></a></var><br>
<blockquote><!-- Define this macro if operations between registers with integral mode -->
     <!-- smaller than a word are always performed on the entire register. -->
     <!-- Most RISC machines have this property and most CISC machines do not. -->
      <p>定义该宏，如果整数机器模式的小于一个字的寄存器间的运算总是在整个寄存器中执行。
大多数RISC机器具有这个属性，大多数CISC机器不具有。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LOAD_EXTEND_OP</b> (<var>mem_mode</var>)<var><a name="index-LOAD_005fEXTEND_005fOP-4795"></a></var><br>
<blockquote><!-- Define this macro to be a C expression indicating when insns that read -->
     <!-- memory in @var{mem_mode}, an integral mode narrower than a word, set the -->
     <!-- bits outside of @var{mem_mode} to be either the sign-extension or the -->
     <!-- zero-extension of the data read.  Return @code{SIGN_EXTEND} for values -->
     <!-- of @var{mem_mode} for which the -->
     <!-- insn sign-extends, @code{ZERO_EXTEND} for which it zero-extends, and -->
     <!-- @code{UNKNOWN} for other modes. -->
      <p>定义该宏为一个C表达式，
指示当insn使用比一个字窄的的整数模式的<var>mem_mode</var>模式读取内存时，
将读取的数据的<var>mem_mode</var>外的位进行符号扩展或者零扩展。
返回<code>SIGN_EXTEND</code>，对于那些要符号扩展的insn，
返回<code>ZERO_EXTEND</code>对那些零扩展的，对于其它的机器模式返回<code>UNKNOWN</code>。

     <!-- This macro is not called with @var{mem_mode} non-integral or with a width -->
     <!-- greater than or equal to @code{BITS_PER_WORD}, so you may return any -->
     <!-- value in this case.  Do not define this macro if it would always return -->
     <!-- @code{UNKNOWN}.  On machines where this macro is defined, you will normally -->
     <!-- define it as the constant @code{SIGN_EXTEND} or @code{ZERO_EXTEND}. -->
      <p>该宏不会被非整型的，或者宽度大于等于<code>BITS_PER_WORD</code>的<var>mem_mode</var>调用，
所以对于这种情况你可以返回任何值。如果总是返回<code>UNKNOWN</code>，则不要定义该宏。
在定义该宏的机器上，你通常要定义其为常量<code>SIGN_EXTEND</code>或者<code>ZERO_EXTEND</code>。

     <!-- You may return a non-@code{UNKNOWN} value even if for some hard registers -->
     <!-- the sign extension is not performed, if for the @code{REGNO_REG_CLASS} -->
     <!-- of these hard registers @code{CANNOT_CHANGE_MODE_CLASS} returns nonzero -->
     <!-- when the @var{from} mode is @var{mem_mode} and the @var{to} mode is any -->
     <!-- integral mode larger than this but not larger than @code{word_mode}. -->
      <p>你可以返回一个非<code>UNKNOWN</code>的值，即使对于一些硬件寄存器并没有执行符号扩展，如果对于这些硬件寄存器的<code>REGNO_REG_CLASS</code>，当<var>from</var>机器模式为<var>mem_mode</var>，并且<var>to</var>机器模式为任何大于其但是不大于<code>word_mode</code>的整形机器模式的时候，<code>CANNOT_CHANGE_MODE_CLASS</code>返回非零。

     <!-- You must return @code{UNKNOWN} if for some hard registers that allow this -->
     <!-- mode, @code{CANNOT_CHANGE_MODE_CLASS} says that they cannot change to -->
     <!-- @code{word_mode}, but that they can change to another integral mode that -->
     <!-- is larger then @var{mem_mode} but still smaller than @code{word_mode}. -->
      <p>你必须返回<code>UNKNOWN</code>，如果一些硬件寄存器允许该机器模式，<code>CANNOT_CHANGE_MODE_CLASS</code>说它们不能变成<code>word_mode</code>，但是它们可以变成其它大于<var>mem_mode</var>且仍然小于<code>word_mode</code>的整形机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SHORT_IMMEDIATES_SIGN_EXTEND</b><var><a name="index-SHORT_005fIMMEDIATES_005fSIGN_005fEXTEND-4796"></a></var><br>
<blockquote><!-- Define this macro if loading short immediate values into registers sign -->
     <!-- extends. -->
      <p>定义该宏，如果将short立即数加载到寄存器中要进行符号扩展。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FIXUNS_TRUNC_LIKE_FIX_TRUNC</b><var><a name="index-FIXUNS_005fTRUNC_005fLIKE_005fFIX_005fTRUNC-4797"></a></var><br>
<blockquote><!-- Define this macro if the same instructions that convert a floating -->
     <!-- point number to a signed fixed point number also convert validly to an -->
     <!-- unsigned one. -->
      <p>定义该宏，如果将浮点数转换为有符号定点数的指令，
同样可以有效的转换为无符号的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: unsigned int <b>TARGET_MIN_DIVISIONS_FOR_RECIP_MUL</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fMIN_005fDIVISIONS_005fFOR_005fRECIP_005fMUL-4798"></a></var><br>
<blockquote><!-- When @option{-ffast-math} is in effect, GCC tries to optimize -->
     <!-- divisions by the same divisor, by turning them into multiplications by -->
     <!-- the reciprocal.  This target hook specifies the minimum number of divisions -->
     <!-- that should be there for GCC to perform the optimization for a variable -->
     <!-- of mode @var{mode}.  The default implementation returns 3 if the machine -->
     <!-- has an instruction for the division, and 2 if it does not. -->
      <p>当<samp><span class="option">-ffast-math</span></samp>有效时，GCC尝试使用相同的除数来优化除法，
通过将它们转换为乘以倒数的方式。
缺省实现返回3，如果机器具有除法指令，否则为2。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_MAX</b><var><a name="index-MOVE_005fMAX-4799"></a></var><br>
<blockquote><!-- The maximum number of bytes that a single instruction can move quickly -->
     <!-- between memory and registers or between two memory locations. -->
      <p>单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_MOVE_MAX</b><var><a name="index-MAX_005fMOVE_005fMAX-4800"></a></var><br>
<blockquote><!-- The maximum number of bytes that a single instruction can move quickly -->
     <!-- between memory and registers or between two memory locations.  If this -->
     <!-- is undefined, the default is @code{MOVE_MAX}.  Otherwise, it is the -->
     <!-- constant value that is the largest value that @code{MOVE_MAX} can have -->
     <!-- at run-time. -->
      <p>单个指令可以在内存和寄存器间，或者两个内存位置间快速移动的最大字节数。
如果没有定义，则缺省为<code>MOVE_MAX</code>。
否则，其为<code>MOVE_MAX</code>在运行时可以具有的最大常数值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SHIFT_COUNT_TRUNCATED</b><var><a name="index-SHIFT_005fCOUNT_005fTRUNCATED-4801"></a></var><br>
<blockquote><!-- A C expression that is nonzero if on this machine the number of bits -->
     <!-- actually used for the count of a shift operation is equal to the number -->
     <!-- of bits needed to represent the size of the object being shifted.  When -->
     <!-- this macro is nonzero, the compiler will assume that it is safe to omit -->
     <!-- a sign-extend, zero-extend, and certain bitwise `and' instructions that -->
     <!-- truncates the count of a shift operation.  On machines that have -->
     <!-- instructions that act on bit-fields at variable positions, which may -->
     <!-- include `bit test' instructions, a nonzero @code{SHIFT_COUNT_TRUNCATED} -->
     <!-- also enables deletion of truncations of the values that serve as -->
     <!-- arguments to bit-field instructions. -->
      <p>一个C表达式，为非零，如果在该机器上，实际用于计算移位运算的位数等同于，用来表示被移位的对象大小的位数。当该宏为非零的时候，编译器将假设可以安全的忽略掉对移位运算的计数进行截取的有符号扩展，零扩展和按位与指令。在一些机器上，具有指令可以作用于可变位置的位域，其可能会包含‘位测试’指令，非零的<code>SHIFT_COUNT_TRUNCATED</code>还可以使得作为位域指令参数的值的截取运算。

     <!-- If both types of instructions truncate the count (for shifts) and -->
     <!-- position (for bit-field operations), or if no variable-position bit-field -->
     <!-- instructions exist, you should define this macro. -->
      <p>如果指令会截取计数（对于位移运算）和位置（对于位域运算），或者如果没有可变位置的位域指令存在，则你应该定义该宏。

     <!-- However, on some machines, such as the 80386 and the 680x0, truncation -->
     <!-- only applies to shift operations and not the (real or pretended) -->
     <!-- bit-field operations.  Define @code{SHIFT_COUNT_TRUNCATED} to be zero on -->
     <!-- such machines.  Instead, add patterns to the @file{md} file that include -->
     <!-- the implied truncation of the shift instructions. -->
      <p>然而，在一些机器上，例如80386和680x0，截取操作只应用在移位运算上，而不在位域运算上。在这样的机器上，定义<code>SHIFT_COUNT_TRUNCATED</code>为零。可替代的，在<samp><span class="file">md</span></samp>文件中增加指令模式，包含对移位指令隐式的截取操作。

     <!-- You need not define this macro if it would always have the value of zero. -->
      <p>如果其值总是为零，则不需要定义该宏。
</p></blockquote></div>

 <p><a name="TARGET_005fSHIFT_005fTRUNCATION_005fMASK"></a>

<div class="defun">
&mdash; Target Hook: unsigned HOST_WIDE_INT <b>TARGET_SHIFT_TRUNCATION_MASK</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fSHIFT_005fTRUNCATION_005fMASK-4802"></a></var><br>
<blockquote><!-- TARGET_SHIFT_TRUNCATION_MASK (enum machine_mode @var{mode}) -->
     <!-- This function describes how the standard shift patterns for @var{mode} -->
     <!-- deal with shifts by negative amounts or by more than the width of the mode. -->
     <!-- @xref{shift patterns}. -->
      <p>该函数描述了标准的移位指令模式，对于<var>mode</var>，如何处理负的数量或者大于机器模式宽度的数量的移位。
参见<a href="shift-patterns.html#shift-patterns">shift patterns</a>.

     <!-- On many machines, the shift patterns will apply a mask @var{m} to the -->
     <!-- shift count, meaning that a fixed-width shift of @var{x} by @var{y} is -->
     <!-- equivalent to an arbitrary-width shift of @var{x} by @var{y & m}.  If -->
     <!-- this is true for mode @var{mode}, the function should return @var{m}, -->
     <!-- otherwise it should return 0.  A return value of 0 indicates that no -->
     <!-- particular behavior is guaranteed. -->
      <p>在许多机器上，移位指令模式将会应用一个掩码<var>m</var>到移位计数上，意味着将<var>x</var>固定宽度移位<var>y</var>等价于对<var>x</var>任意宽度移位<var>y &amp; m</var>。如果这对机器模式<var>mode</var>为真，则函数应该返回<var>m</var>，否则应该返回0。返回值0意味着不保证特定的行为。

     <!-- Note that, unlike @code{SHIFT_COUNT_TRUNCATED}, this function does -->
     <!-- @emph{not} apply to general shift rtxes; it applies only to instructions -->
     <!-- that are generated by the named shift patterns. -->
      <p>注意，不像<code>SHIFT_COUNT_TRUNCATED</code>，该函数不应用到通用的移位rtx上；其只应用到由命名移位指令模式生成的指令上。

     <!-- The default implementation of this function returns -->
     <!-- @code{GET_MODE_BITSIZE (@var{mode}) - 1} if @code{SHIFT_COUNT_TRUNCATED} -->
     <!-- and 0 otherwise.  This definition is always safe, but if -->
     <!-- @code{SHIFT_COUNT_TRUNCATED} is false, and some shift patterns -->
     <!-- nevertheless truncate the shift count, you may get better code -->
     <!-- by overriding it. -->
      <p>该函数的缺省实现返回<code>GET_MODE_BITSIZE (</code><var>mode</var><code>) - 1</code>，如果<code>SHIFT_COUNT_TRUNCATED</code>，否则为0。该定义总是安全的，但是如果<code>SHIFT_COUNT_TRUNCATED</code>为假，并且一些移位指令模式还是截取移位计数，则你可以通过重写覆盖该宏来获得更好的代码。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TRULY_NOOP_TRUNCATION</b> (<var>outprec, inprec</var>)<var><a name="index-TRULY_005fNOOP_005fTRUNCATION-4803"></a></var><br>
<blockquote><!-- A C expression which is nonzero if on this machine it is safe to -->
     <!-- ``convert'' an integer of @var{inprec} bits to one of @var{outprec} -->
     <!-- bits (where @var{outprec} is smaller than @var{inprec}) by merely -->
     <!-- operating on it as if it had only @var{outprec} bits. -->
      <p>一个C表达式，其为非零，如果在该机器上，将<var>inprec</var>个位数的整数转换成<var>outprec</var>个位数（<var>outprec</var>比<var>inprec</var>小），通过简单的认为其只具有<var>outprec</var>个位。

     <!-- On many machines, this expression can be 1. -->
      <p>在许多机器上，该表达式可以为1。

     <!-- rearranged this, removed the phrase "it is reported that".  this was -->
     <!-- to fix an overfull hbox.  -mew 10feb93 -->
      <p>When <code>TRULY_NOOP_TRUNCATION</code> returns 1 for a pair of sizes for
modes for which <code>MODES_TIEABLE_P</code> is 0, suboptimal code can result. 
If this is the case, making <code>TRULY_NOOP_TRUNCATION</code> return 0 in
such cases may improve things. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_MODE_REP_EXTENDED</b> (<var>enum machine_mode mode, enum machine_mode rep_mode</var>)<var><a name="index-TARGET_005fMODE_005fREP_005fEXTENDED-4804"></a></var><br>
<blockquote><!-- The representation of an integral mode can be such that the values -->
     <!-- are always extended to a wider integral mode.  Return -->
     <!-- @code{SIGN_EXTEND} if values of @var{mode} are represented in -->
     <!-- sign-extended form to @var{rep_mode}.  Return @code{UNKNOWN} -->
     <!-- otherwise.  (Currently, none of the targets use zero-extended -->
     <!-- representation this way so unlike @code{LOAD_EXTEND_OP}, -->
     <!-- @code{TARGET_MODE_REP_EXTENDED} is expected to return either -->
     <!-- @code{SIGN_EXTEND} or @code{UNKNOWN}.  Also no target extends -->
     <!-- @var{mode} to @var{rep_mode} so that @var{rep_mode} is not the next -->
     <!-- widest integral mode and currently we take advantage of this fact.) -->
      <p>整型机器模式可以表示为一个值，其总是被扩展为更宽的整型模式。返回<code>SIGN_EXTEND</code>，如果机器模式为<var>mode</var>的值被表示为有符号扩展成<var>rep_mode</var>的形式。否则，返回<code>UNKNOWN</code>。（目前，没有目标机使用零扩展表示，所以不像<code>LOAD_EXTEND_OP</code>，<code>TARGET_MODE_REP_EXTENDED</code>被期望返回<code>SIGN_EXTEND</code>或者<code>UNKNOWN</code>。而且没有目标机将<var>mode</var>扩展为<var>mode_rep</var>，以至于<var>mode_rep</var>不是下一个最宽的整型机器模式，目前，我们利用了这个事实。）

     <!-- Similarly to @code{LOAD_EXTEND_OP} you may return a non-@code{UNKNOWN} -->
     <!-- value even if the extension is not performed on certain hard registers -->
     <!-- as long as for the @code{REGNO_REG_CLASS} of these hard registers -->
     <!-- @code{CANNOT_CHANGE_MODE_CLASS} returns nonzero. -->
      <p>类似于<code>LOAD_EXTEND_OP</code>，你可以返回一个非<code>UNKNOWN</code>的值，即使扩展在特定硬件寄存器上没有被执行，只要对于这些硬件寄存器的<code>REGNO_REG_CLASS</code>，<code>CANNOT_CHANGE_MODE_CLASS</code>返回非零。

     <!-- Note that @code{TARGET_MODE_REP_EXTENDED} and @code{LOAD_EXTEND_OP} -->
     <!-- describe two related properties.  If you define -->
     <!-- @code{TARGET_MODE_REP_EXTENDED (mode, word_mode)} you probably also want -->
     <!-- to define @code{LOAD_EXTEND_OP (mode)} to return the same type of -->
     <!-- extension. -->
      <p>注意，<code>TARGET_MODE_REP_EXTENDED</code>和<code>LOAD_EXTEND_OP</code>描述了两个相关联的属性。如果你定义了<code>TARGET_MODE_REP_EXTENDED (mode, word_mode)</code>，你可能还要定义<code>LOAD_EXTEND_OP (mode)</code>，来返回相同类型的扩展。

     <!-- In order to enforce the representation of @code{mode}, -->
     <!-- @code{TRULY_NOOP_TRUNCATION} should return false when truncating to -->
     <!-- @code{mode}. -->
      <p>为了加强<code>mode</code>的表示，当截取成<code>mode</code>时，<code>TRULY_NOOP_TRUNCATION</code>应该返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STORE_FLAG_VALUE</b><var><a name="index-STORE_005fFLAG_005fVALUE-4805"></a></var><br>
<blockquote><!-- A C expression describing the value returned by a comparison operator -->
     <!-- with an integral mode and stored by a store-flag instruction -->
     <!-- (@samp{cstore@var{mode}4}) when the condition is true.  This description must -->
     <!-- apply to @emph{all} the @samp{cstore@var{mode}4} patterns and all the -->
     <!-- comparison operators whose results have a @code{MODE_INT} mode. -->
      <p>一个C表达式，描述了整型机器模式的比较运算符返回的值，并且当条件为真时由存储标记指令(&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;)存储。该描述必须应用到所有的&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;指令模式，并且所有比较运算的结果必须具有<code>MODE_INT</code>机器模式。

     <!-- A value of 1 or @minus{}1 means that the instruction implementing the -->
     <!-- comparison operator returns exactly 1 or @minus{}1 when the comparison is true -->
     <!-- and 0 when the comparison is false.  Otherwise, the value indicates -->
     <!-- which bits of the result are guaranteed to be 1 when the comparison is -->
     <!-- true.  This value is interpreted in the mode of the comparison -->
     <!-- operation, which is given by the mode of the first operand in the -->
     <!-- @samp{cstore@var{mode}4} pattern.  Either the low bit or the sign bit of -->
     <!-- @code{STORE_FLAG_VALUE} be on.  Presently, only those bits are used by -->
     <!-- the compiler. -->
      <p>值为1或者-1，意味着实现比较运算的指令当比较为真时返回确切的1或者-1，当比较为假时返回0。否则，值会表示当比较为真时结果的哪些位保证为1。该值按照比较运算的机器模式来解析，其由&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo;指令模式中的第一个操作数的机器模式给出。目前，编译器只用到了<code>STORE_FLAG_VALUE</code>的低位或者符号位。

     <!-- If @code{STORE_FLAG_VALUE} is neither 1 or @minus{}1, the compiler will -->
     <!-- generate code that depends only on the specified bits.  It can also -->
     <!-- replace comparison operators with equivalent operations if they cause -->
     <!-- the required bits to be set, even if the remaining bits are undefined. -->
     <!-- For example, on a machine whose comparison operators return an -->
     <!-- @code{SImode} value and where @code{STORE_FLAG_VALUE} is defined as -->
     <!-- @samp{0x80000000}, saying that just the sign bit is relevant, the -->
     <!-- expression -->
      <p>如果<code>STORE_FLAG_VALUE</code>不为1或者-1，则编译器将生成只依赖特定位的代码。其还可以用等价的运算来替换比较运算，如果它们会造成需要的位被设置，即使其它位没有被定义。例如，在比较运算返回一个<code>SImode</code>值的机器上，其<code>STORE_FLAG_VALUE</code>被定义为&lsquo;<samp><span class="samp">0x80000000</span></samp>&rsquo;，说明只有符号位是相关的，表达式

     <pre class="smallexample">          (ne:SI (and:SI <var>x</var> (const_int <var>power-of-2</var>)) (const_int 0))
</pre>
      <p class="noindent"><!-- can be converted to -->
可以被转换为

     <pre class="smallexample">          (ashift:SI <var>x</var> (const_int <var>n</var>))
</pre>
      <p class="noindent"><!-- where @var{n} is the appropriate shift count to move the bit being -->
<!-- tested into the sign bit. -->

      <p>其中<var>n</var>为适当的移位计数，用来将被测试的位移送到符号位。

     <!-- There is no way to describe a machine that always sets the low-order bit -->
     <!-- for a true value, but does not guarantee the value of any other bits, -->
     <!-- but we do not know of any machine that has such an instruction.  If you -->
     <!-- are trying to port GCC to such a machine, include an instruction to -->
     <!-- perform a logical-and of the result with 1 in the pattern for the -->
     <!-- comparison operators and let us know at @email{gcc@@gcc.gnu.org}. -->
      <p>没有办法来描述，一个机器对于真值，总是设置低顺序的位，而不保证其它位的值。但是，我们不知道是否有机器具有这样的指令。如果你正在尝试将GCC移植到这样的机器上，那么可以在比较运算的指令模式中，包含一条指令来执行将结果和1进行逻辑与，并且通过<a href="mailto:gcc@gcc.gnu.org">gcc@gcc.gnu.org</a>让我们知道。

     <!-- Often, a machine will have multiple instructions that obtain a value -->
     <!-- from a comparison (or the condition codes).  Here are rules to guide the -->
     <!-- choice of value for @code{STORE_FLAG_VALUE}, and hence the instructions -->
     <!-- to be used: -->
      <p>通常，机器将具有多个指令，从比较（或者条件代码）中获得一个值。这里有一些规则用来指导对<code>STORE_FLAG_VALUE</code>的值的选择，以及要使用的指令：

     <!-- @itemize @bullet -->
     <!-- @item -->
     <!-- Use the shortest sequence that yields a valid definition for -->
     <!-- @code{STORE_FLAG_VALUE}.  It is more efficient for the compiler to -->
     <!-- ``normalize'' the value (convert it to, e.g., 1 or 0) than for the -->
     <!-- comparison operators to do so because there may be opportunities to -->
     <!-- combine the normalization with other operations. -->
     <!-- @item -->
     <!-- For equal-length sequences, use a value of 1 or @minus{}1, with @minus{}1 being -->
     <!-- slightly preferred on machines with expensive jumps and 1 preferred on -->
     <!-- other machines. -->
     <!-- @item -->
     <!-- As a second choice, choose a value of @samp{0x80000001} if instructions -->
     <!-- exist that set both the sign and low-order bits but do not define the -->
     <!-- others. -->
     <!-- @item -->
     <!-- Otherwise, use a value of @samp{0x80000000}. -->
     <!-- @end itemize -->
          <ul>
<li>使用最短的序列，产生<code>STORE_FLAG_VALUE</code>的有效定义。对编译器来说，将值正常化（例如，将其转成1或者0）要比进行比较运算更有效，因为可能会有一些机会来合并其它的正常化运算。

          <li>对于等长的序列，使用值1或者－1。在跳转代价比较高的机器上，一般会倾向于－1，其它一些机器喜欢用1。

          <li>作为第二种选择，选择值&lsquo;<samp><span class="samp">0x80000001</span></samp>&rsquo;，如果存在指令，同时设置符号位和低顺序位，但是不定义其它位。

          <li>否则，使用值&lsquo;<samp><span class="samp">0x80000000</span></samp>&rsquo;。
</ul>

     <!-- Many machines can produce both the value chosen for -->
     <!-- @code{STORE_FLAG_VALUE} and its negation in the same number of -->
     <!-- instructions.  On those machines, you should also define a pattern for -->
     <!-- those cases, e.g., one matching -->
      <p>许多机器可以同时产生供<code>STORE_FLAG_VALUE</code>选择的值，以及同样数量指令的取反。在那些机器上，你应该还定义这些情况的指令模式，例如，

     <pre class="smallexample">          (set <var>A</var> (neg:<var>m</var> (ne:<var>m</var> <var>B</var> <var>C</var>)))
</pre>
      <!-- Some machines can also perform @code{and} or @code{plus} operations on -->
     <!-- condition code values with less instructions than the corresponding -->
     <!-- @samp{cstore@var{mode}4} insn followed by @code{and} or @code{plus}.  On those -->
     <!-- machines, define the appropriate patterns.  Use the names @code{incscc} -->
     <!-- and @code{decscc}, respectively, for the patterns which perform -->
     <!-- @code{plus} or @code{minus} operations on condition code values.  See -->
     <!-- @file{rs6000.md} for some examples.  The GNU Superoptimizer can be used to -->
     <!-- find such instruction sequences on other machines. -->
      <p>一些机器还可以在条件代码值上，执行<code>and</code>或者<code>plus</code>运算，使用少于相应的&lsquo;<samp><span class="samp">s</span><var>cond</var></samp>&rsquo; insn后跟随<code>and</code>或者<code>plus</code>的指令数目。在这些机器上，需要定义适当的指令模式。分别使用名字<code>incscc</code>和<code>decscc</code>，对于在条件代码值上执行<code>plus</code>或者<code>minus</code>运算的指令模式。参见<samp><span class="file">rs6000.md</span></samp>中的一些例子。可以使用GNU Superoptimizer来在其它机器上查找这样的指令序列。

     <!-- If this macro is not defined, the default value, 1, is used.  You need -->
     <!-- not define @code{STORE_FLAG_VALUE} if the machine has no store-flag -->
     <!-- instructions, or if the value generated by these instructions is 1. -->
      <p>如果该宏没有被定义，则使用缺省的值1。你不需要定义<code>STORE_FLAG_VALUE</code>，如果机器没有存储标记的指令，或者如果这些指令生成的值为1。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FLOAT_STORE_FLAG_VALUE</b> (<var>mode</var>)<var><a name="index-FLOAT_005fSTORE_005fFLAG_005fVALUE-4806"></a></var><br>
<blockquote><!-- A C expression that gives a nonzero @code{REAL_VALUE_TYPE} value that is -->
     <!-- returned when comparison operators with floating-point results are true. -->
     <!-- Define this macro on machines that have comparison operations that return -->
     <!-- floating-point values.  If there are no such operations, do not define -->
     <!-- this macro. -->
      <p>一个C表达式，给出一个非零的<code>REAL_VALUE_TYPE</code>值，当浮点比较运算的结果为真时返回该值。在一些机器上，具有返回浮点值的比较运算，可以定义该宏。如果没有这样的运算，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>VECTOR_STORE_FLAG_VALUE</b> (<var>mode</var>)<var><a name="index-VECTOR_005fSTORE_005fFLAG_005fVALUE-4807"></a></var><br>
<blockquote><!-- A C expression that gives a rtx representing the nonzero true element -->
     <!-- for vector comparisons.  The returned rtx should be valid for the inner -->
     <!-- mode of @var{mode} which is guaranteed to be a vector mode.  Define -->
     <!-- this macro on machines that have vector comparison operations that -->
     <!-- return a vector result.  If there are no such operations, do not define -->
     <!-- this macro.  Typically, this macro is defined as @code{const1_rtx} or -->
     <!-- @code{constm1_rtx}.  This macro may return @code{NULL_RTX} to prevent -->
     <!-- the compiler optimizing such vector comparison operations for the -->
     <!-- given mode. -->
      <p>一个C表达式，给出一个rtx，表示向量比较中非零的真元素。返回的rtx应该对于<var>mode</var>的内部机器模式是有效的，<var>mode</var>为一个向量机器模式。定义该宏，在一些机器上，具有返回向量结果的向量比较运算。如果没有这样的运算，则不要定义该宏。通常，该宏被定义为<code>const1_rtx</code>或者<code>constm1_rtx</code>。该宏可以返回<code>NULL_RTX</code>，来阻止编译器优化给定的机器模式的向量比较运算。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CLZ_DEFINED_VALUE_AT_ZERO</b> (<var>mode, value</var>)<var><a name="index-CLZ_005fDEFINED_005fVALUE_005fAT_005fZERO-4808"></a></var><br>
&mdash; Macro: <b>CTZ_DEFINED_VALUE_AT_ZERO</b> (<var>mode, value</var>)<var><a name="index-CTZ_005fDEFINED_005fVALUE_005fAT_005fZERO-4809"></a></var><br>
<blockquote><!-- A C expression that indicates whether the architecture defines a value -->
     <!-- for @code{clz} or @code{ctz} with a zero operand. -->
     <!-- A result of @code{0} indicates the value is undefined. -->
     <!-- If the value is defined for only the RTL expression, the macro should -->
     <!-- evaluate to @code{1}; if the value applies also to the corresponding optab -->
     <!-- entry (which is normally the case if it expands directly into -->
     <!-- the corresponding RTL), then the macro should evaluate to @code{2}. -->
     <!-- In the cases where the value is defined, @var{value} should be set to -->
     <!-- this value. -->
      <p>一个C表达式，指示体系机构是否为<code>clz</code>或者<code>ctz</code>在操作数为零时，定义了值。结果为<code>0</code>，表示值未被定义。如果值只被定义为RTL表达式，则宏应该求值为<code>1</code>；如果还应用到相应的optab项（其通常情况为直接扩展为相应的RTL），则宏应该求值为<code>2</code>。在值被定义的情况下，<var>value</var>应该被设置为该值。

     <!-- If this macro is not defined, the value of @code{clz} or -->
     <!-- @code{ctz} at zero is assumed to be undefined. -->
      <p>如果该宏没有被定义，则<code>clz</code>或者<code>ctz</code>在操作数为零时，被认为未定义。

     <!-- This macro must be defined if the target's expansion for @code{ffs} -->
     <!-- relies on a particular value to get correct results.  Otherwise it -->
     <!-- is not necessary, though it may be used to optimize some corner cases, and -->
     <!-- to provide a default expansion for the @code{ffs} optab. -->
      <p>该宏必须被定义，如果目标机对<code>ffs</code>的扩展，依赖于特定的值，以获得正确的结果。否则，没有必要，虽然其可以用于优化一些边角的情况，并且为<code>ffs</code> optab提供缺省的扩展。

     <!-- Note that regardless of this macro the ``definedness'' of @code{clz} -->
     <!-- and @code{ctz} at zero do @emph{not} extend to the builtin functions -->
     <!-- visible to the user.  Thus one may be free to adjust the value at will -->
     <!-- to match the target expansion of these operations without fear of -->
     <!-- breaking the API@. -->
      <p>注意，不论该宏是否定义，<code>clz</code>和<code>ctz</code>在操作数为0时的定义，都不会被扩展为用户可见的内建函数。因此，可以任意调整该值，来匹配对这些运算的目标机扩展，而无需担心会破坏API。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>Pmode</b><var><a name="index-Pmode-4810"></a></var><br>
<blockquote><!-- An alias for the machine mode for pointers.  On most machines, define -->
     <!-- this to be the integer mode corresponding to the width of a hardware -->
     <!-- pointer; @code{SImode} on 32-bit machine or @code{DImode} on 64-bit machines. -->
     <!-- On some machines you must define this to be one of the partial integer -->
     <!-- modes, such as @code{PSImode}. -->
      <p>指针的机器模式别名。在大多数机器上，定义该宏为整型机器模式，对应于硬件指针宽度；32位机器上为<code>SImode</code>，64位机器上为<code>DImode</code>。在一些机器上，你必须定义该宏为部分整型机器模式，例如<code>PSImode</code>。

     <!-- The width of @code{Pmode} must be at least as large as the value of -->
     <!-- @code{POINTER_SIZE}.  If it is not equal, you must define the macro -->
     <!-- @code{POINTERS_EXTEND_UNSIGNED} to specify how pointers are extended -->
     <!-- to @code{Pmode}. -->
      <p><code>Pmode</code>的宽度必须至少与<code>POINTER_SIZE</code>的值一样大。如果不相等，你必须定义宏<code>POINTERS_EXTEND_UNSIGNED</code>来描述指针如何被扩展为<code>Pmode</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_MODE</b><var><a name="index-FUNCTION_005fMODE-4811"></a></var><br>
<blockquote><!-- An alias for the machine mode used for memory references to functions -->
     <!-- being called, in @code{call} RTL expressions.  On most CISC machines, -->
     <!-- where an instruction can begin at any byte address, this should be -->
     <!-- @code{QImode}.  On most RISC machines, where all instructions have fixed -->
     <!-- size and alignment, this should be a mode with the same size and alignment -->
     <!-- as the machine instruction words - typically @code{SImode} or @code{HImode}. -->
      <p>机器模式的别名，在<code>call</code> RTL表达式中，用于被调用函数的内存引用。在大多数CISC机器上，指令可以起始于任意字节地址，这应该为<code>QImode</code>。在大多RISC机器上，所有的指令都具有固定的大小和对齐方式，这应该为与机器指令字具有相同大小和对齐的机器模式，通常为<code>SImode</code>或者<code>HImode</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STDC_0_IN_SYSTEM_HEADERS</b><var><a name="index-STDC_005f0_005fIN_005fSYSTEM_005fHEADERS-4812"></a></var><br>
<blockquote><!-- In normal operation, the preprocessor expands @code{__STDC__} to the -->
     <!-- constant 1, to signify that GCC conforms to ISO Standard C@.  On some -->
     <!-- hosts, like Solaris, the system compiler uses a different convention, -->
     <!-- where @code{__STDC__} is normally 0, but is 1 if the user specifies -->
     <!-- strict conformance to the C Standard. -->
      <p>正常的操作中，预处理器会将<code>__STDC__</code>扩展为常量1，来表明GCC遵循ISO标准C。在一些主机上，例如Solaris，系统编译器使用不同的约定，<code>__STDC__</code>通常为0，但是如果用户指出要严格遵循C标准时为1。

     <!-- Defining @code{STDC_0_IN_SYSTEM_HEADERS} makes GNU CPP follows the host -->
     <!-- convention when processing system header files, but when processing user -->
     <!-- files @code{__STDC__} will always expand to 1. -->
      <p>定义<code>STDC_0_IN_SYSTEM_HEADERS</code>使得GNU CPP遵循主机的约定，当处理系统头文件时，但是，当处理用户文件时<code>__STDC__</code>将总是被扩展为1。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_IMPLICIT_EXTERN_C</b><var><a name="index-NO_005fIMPLICIT_005fEXTERN_005fC-4813"></a></var><br>
<blockquote><!-- Define this macro if the system header files support C++ as well as C@. -->
     <!-- This macro inhibits the usual method of using system header files in -->
     <!-- C++, which is to pretend that the file's contents are enclosed in -->
     <!-- @samp{extern "C" @{@dots{}@}}. -->
      <p>定义该宏，如果系统头文件支持C++，也支持C。该宏抑制了通常在C++中使用系统头文件的方法，即假设文件的内容包含在&lsquo;<samp><span class="samp">extern "C" {...}</span></samp>&rsquo;中。
</p></blockquote></div>

 <p><a name="index-g_t_0023pragma-4814"></a><a name="index-pragma-4815"></a>

<div class="defun">
&mdash; Macro: <b>REGISTER_TARGET_PRAGMAS</b> ()<var><a name="index-REGISTER_005fTARGET_005fPRAGMAS-4816"></a></var><br>
<blockquote><!-- Define this macro if you want to implement any target-specific pragmas. -->
     <!-- If defined, it is a C expression which makes a series of calls to -->
     <!-- @code{c_register_pragma} or @code{c_register_pragma_with_expansion} -->
     <!-- for each pragma.  The macro may also do any -->
     <!-- setup required for the pragmas. -->
      <p>定义该宏，如果你想实现任何目标机特定的pragma。如果被定义，其为一个C表达式，为每个pragma使用一系列的对<code>c_register_pragma</code>或者<code>c_register_pragma_with_expansion</code>调用。该宏还可以做任何pragma所要求的设置。

     <!-- The primary reason to define this macro is to provide compatibility with -->
     <!-- other compilers for the same target.  In general, we discourage -->
     <!-- definition of target-specific pragmas for GCC@. -->
      <p>定义该宏的主要原因是提供相同目标机上，与其它编译器的兼容性。大体上，我们不鼓励为GCC定义目标机特定的pragma。

     <!-- If the pragma can be implemented by attributes then you should consider -->
     <!-- defining the target hook @samp{TARGET_INSERT_ATTRIBUTES} as well. -->
      <p>如果pragma可以通过attribute属性来实现，则你也应该考虑定义目标机钩子&lsquo;<samp><span class="samp">TARGET_INSERT_ATTRIBUTES</span></samp>&rsquo;。

     <!-- Preprocessor macros that appear on pragma lines are not expanded.  All -->
     <!-- @samp{#pragma} directives that do not match any registered pragma are -->
     <!-- silently ignored, unless the user specifies @option{-Wunknown-pragmas}. -->
      <p>出现在pragma行中的预处理器宏不被扩展。所有不匹配被注册的&lsquo;<samp><span class="samp">#pragma</span></samp>&rsquo;指令，将被安静的忽略，除非用户指定<samp><span class="option">-Wunknown-pragmas</span></samp>。
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>c_register_pragma</b> (<var>const char *space, const char *name, void </var>(<var>*callback</var>) (<var>struct cpp_reader *</var>))<var><a name="index-c_005fregister_005fpragma-4817"></a></var><br>
&mdash; Function: void <b>c_register_pragma_with_expansion</b> (<var>const char *space, const char *name, void </var>(<var>*callback</var>) (<var>struct cpp_reader *</var>))<var><a name="index-c_005fregister_005fpragma_005fwith_005fexpansion-4818"></a></var><br>
<blockquote>
     <!-- Each call to @code{c_register_pragma} or -->
     <!-- @code{c_register_pragma_with_expansion} establishes one pragma.  The -->
     <!-- @var{callback} routine will be called when the preprocessor encounters a -->
     <!-- pragma of the form -->
      <p>每个对<code>c_register_pragma</code>或者<code>c_register_pragma_with_expansion</code>的调用，都建立了一个pragma。当预处理器遇到一个形式为

     <pre class="smallexample">          #pragma [<var>space</var>] <var>name</var> ...
</pre>
      <p>的pragma，则<var>callback</var>函数将被调用。

     <!-- @var{space} is the case-sensitive namespace of the pragma, or -->
     <!-- @code{NULL} to put the pragma in the global namespace.  The callback -->
     <!-- routine receives @var{pfile} as its first argument, which can be passed -->
     <!-- on to cpplib's functions if necessary.  You can lex tokens after the -->
     <!-- @var{name} by calling @code{pragma_lex}.  Tokens that are not read by the -->
     <!-- callback will be silently ignored.  The end of the line is indicated by -->
     <!-- a token of type @code{CPP_EOF}.  Macro expansion occurs on the -->
     <!-- arguments of pragmas registered with -->
     <!-- @code{c_register_pragma_with_expansion} but not on the arguments of -->
     <!-- pragmas registered with @code{c_register_pragma}. -->
      <p><var>space</var>为大小写敏感的pragma命名空间，或者为<code>NULL</code>，将gragma放在全局命名空间中。回调函数接受<var>pfile</var>作为第一个参数，如果需要其可以被传递给cpplib的函数。你可以通过调用<code>pragma_lex</code>，来词法分析<var>name</var>之后的token。没有被回调函数读入的token将被安静的忽略。行尾由类型为<code>CPP_EOF</code>的token来指示。宏扩展发生在使用<code>c_register_pragma_with_expansion</code>注册的pragma的参数上，但不在使用<code>c_register_pragma</code>注册的pragma的参数上。

     <!-- Note that the use of @code{pragma_lex} is specific to the C and C++ -->
     <!-- compilers.  It will not work in the Java or Fortran compilers, or any -->
     <!-- other language compilers for that matter.  Thus if @code{pragma_lex} is going -->
     <!-- to be called from target-specific code, it must only be done so when -->
     <!-- building the C and C++ compilers.  This can be done by defining the -->
     <!-- variables @code{c_target_objs} and @code{cxx_target_objs} in the -->
     <!-- target entry in the @file{config.gcc} file.  These variables should name -->
     <!-- the target-specific, language-specific object file which contains the -->
     <!-- code that uses @code{pragma_lex}.  Note it will also be necessary to add a -->
     <!-- rule to the makefile fragment pointed to by @code{tmake_file} that shows -->
     <!-- how to build this object file. -->
      <p>注意，使用<code>pragma_lex</code>是特定于C和C++编译器的。其在Java或者Fortran编译器上，或者其它语言编译器上无法工作。因此，如果<code>pragma_lex</code>准备从目标机特定代码中被调用，其必须只在构建C和C++编译器的时候执行。这可以通过在<samp><span class="file">config.gcc</span></samp>文件中的目标机项中，定义变量<code>c_target_objs</code>和<code>cxx_target_objs</code>来实现。这些变量应该命名目标机特定的，语言特定的对象文件，其包含了使用<code>pragma_lex</code>的代码。注意，还有必要增加一个规则到由<code>tmake_file</code>指定的makefile片断中，来显示如何构建该目标文件。
</p></blockquote></div>

 <p><a name="index-g_t_0023pragma-4819"></a><a name="index-pragma-4820"></a>

<div class="defun">
&mdash; Macro: <b>HANDLE_SYSV_PRAGMA</b><var><a name="index-HANDLE_005fSYSV_005fPRAGMA-4821"></a></var><br>
<blockquote><!-- Define this macro (to a value of 1) if you want the System V style -->
     <!-- pragmas @samp{#pragma pack(<n>)} and @samp{#pragma weak <name> -->
     <!-- [=<value>]} to be supported by gcc. -->
      <p>定义该宏（值为1），如果你想gcc支持System V风格的pragma &lsquo;<samp><span class="samp">#pragma pack(&lt;n&gt;)</span></samp>&rsquo;和&lsquo;<samp><span class="samp">#pragma weak &lt;name&gt; [=&lt;value&gt;]</span></samp>&rsquo;。

     <!-- The pack pragma specifies the maximum alignment (in bytes) of fields -->
     <!-- within a structure, in much the same way as the @samp{__aligned__} and -->
     <!-- @samp{__packed__} @code{__attribute__}s do.  A pack value of zero resets -->
     <!-- the behavior to the default. -->
      <p>pack pragma描述了结构体中域的最大对齐方式（以字节为单位），很大程度上等同于使用&lsquo;<samp><span class="samp">__aligned__</span></samp>&rsquo;和&lsquo;<samp><span class="samp">__packed__</span></samp>&rsquo; <code>__attribute__</code>。pack值为零，会将行为重置为缺省。

     <!-- A subtlety for Microsoft Visual C/C++ style bit-field packing -->
     <!-- (e.g.@: -mms-bitfields) for targets that support it: -->
     <!-- When a bit-field is inserted into a packed record, the whole size -->
     <!-- of the underlying type is used by one or more same-size adjacent -->
     <!-- bit-fields (that is, if its long:3, 32 bits is used in the record, -->
     <!-- and any additional adjacent long bit-fields are packed into the same -->
     <!-- chunk of 32 bits.  However, if the size changes, a new field of that -->
     <!-- size is allocated). -->
      <p>对于目标机支持的微软Visual C/C++风格的位域打包（例如-mms-bitfields），其微妙之处在于：当位域被插入到一个打包了的记录中时，则底层类型的整个大小会被一个或多个相同大小临近的位域使用（也就是说，如果为long:3，则记录会使用32位，任何额外的临近的long位域将被打包到32位块中。然而，如果大小改变了，则会分配一个新的同样大小的域）。

     <!-- If both MS bit-fields and @samp{__attribute__((packed))} are used, -->
     <!-- the latter will take precedence.  If @samp{__attribute__((packed))} is -->
     <!-- used on a single field when MS bit-fields are in use, it will take -->
     <!-- precedence for that field, but the alignment of the rest of the structure -->
     <!-- may affect its placement. -->
      <p>如果MS位域和&lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo;都被使用，则后者优先。如果当在使用MS位域的时候，&lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo;被用于一个单独的域，则对于该域是优先的，但是结构体的其它部分的对齐方式会影响它的放置。

     <!-- The weak pragma only works if @code{SUPPORTS_WEAK} and -->
     <!-- @code{ASM_WEAKEN_LABEL} are defined.  If enabled it allows the creation -->
     <!-- of specifically named weak labels, optionally with a value. -->
      <p>weak pragma只有当<code>SUPPORTS_WEAK</code>和<code>ASM_WEAKEN_LABEL</code>被定义时，才工作。如果可用，其允许创建特殊命名的弱标号，以及可选的值。
</p></blockquote></div>

 <p><a name="index-g_t_0023pragma-4822"></a><a name="index-pragma-4823"></a>

<div class="defun">
&mdash; Macro: <b>HANDLE_PRAGMA_PACK_PUSH_POP</b><var><a name="index-HANDLE_005fPRAGMA_005fPACK_005fPUSH_005fPOP-4824"></a></var><br>
<blockquote><!-- Define this macro (to a value of 1) if you want to support the Win32 -->
     <!-- style pragmas @samp{#pragma pack(push[,@var{n}])} and @samp{#pragma -->
     <!-- pack(pop)}.  The @samp{pack(push,[@var{n}])} pragma specifies the maximum -->
     <!-- alignment (in bytes) of fields within a structure, in much the same way as -->
     <!-- the @samp{__aligned__} and @samp{__packed__} @code{__attribute__}s do.  A -->
     <!-- pack value of zero resets the behavior to the default.  Successive -->
     <!-- invocations of this pragma cause the previous values to be stacked, so -->
     <!-- that invocations of @samp{#pragma pack(pop)} will return to the previous -->
     <!-- value. -->
      <p>定义该宏（值为1），如果你想支持Win32风格的pragmas &lsquo;<samp><span class="samp">#pragma pack(push[,</span><var>n</var><span class="samp">])</span></samp>&rsquo; and &lsquo;<samp><span class="samp">#pragma pack(pop)</span></samp>&rsquo;。&lsquo;<samp><span class="samp">pack(push,[</span><var>n</var><span class="samp">])</span></samp>&rsquo; pragma指定结构体内的域的最大对齐方式（按字节），等同于使用&lsquo;<samp><span class="samp">__aligned__</span></samp>&rsquo; 和 &lsquo;<samp><span class="samp">__packed__</span></samp>&rsquo; <code>__attribute__</code>。如果pack值为0，则会将行为重置为缺省情况。连续的调用该pragma会造成先前的值被压栈，所以调用&lsquo;<samp><span class="samp">#pragma pack(pop)</span></samp>&rsquo;会返回先前的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HANDLE_PRAGMA_PACK_WITH_EXPANSION</b><var><a name="index-HANDLE_005fPRAGMA_005fPACK_005fWITH_005fEXPANSION-4825"></a></var><br>
<blockquote><!-- Define this macro if macros should be expanded in the -->
     <!-- arguments of @samp{#pragma pack}. -->
      <p>定义该宏，如果在&lsquo;<samp><span class="samp">#pragma pack</span></samp>&rsquo;中的参数宏应该被扩展。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_HANDLE_PRAGMA_EXTERN_PREFIX</b><var><a name="index-TARGET_005fHANDLE_005fPRAGMA_005fEXTERN_005fPREFIX-4826"></a></var><br>
<blockquote><p>True if <code>#pragma extern_prefix</code> is to be supported. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_DEFAULT_PACK_STRUCT</b><var><a name="index-TARGET_005fDEFAULT_005fPACK_005fSTRUCT-4827"></a></var><br>
<blockquote><!-- If your target requires a structure packing default other than 0 (meaning -->
     <!-- the machine default), define this macro to the necessary value (in bytes). -->
     <!-- This must be a value that would also be valid to use with -->
     <!-- @samp{#pragma pack()} (that is, a small power of two). -->
      <p>如果你的目标机要求结构体缺省的打包方式不是0（意味着机器缺省方式），则定义该宏为必要的值（以字节为单位）。该值必须还对于&lsquo;<samp><span class="samp">#pragma pack()</span></samp>&rsquo;有效（也就是说，2的小的幂数）。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DOLLARS_IN_IDENTIFIERS</b><var><a name="index-DOLLARS_005fIN_005fIDENTIFIERS-4828"></a></var><br>
<blockquote><!-- Define this macro to control use of the character @samp{$} in -->
     <!-- identifier names for the C family of languages.  0 means @samp{$} is -->
     <!-- not allowed by default; 1 means it is allowed.  1 is the default; -->
     <!-- there is no need to define this macro in that case. -->
      <p>定义该宏，来控制C语言家族，标识符名字中对字符&lsquo;<samp><span class="samp">$</span></samp>&rsquo;的使用。0意味着缺省不允许使用&lsquo;<samp><span class="samp">$</span></samp>&rsquo;；1意味着允许。缺省为1；对于这种情况，不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_DOLLAR_IN_LABEL</b><var><a name="index-NO_005fDOLLAR_005fIN_005fLABEL-4829"></a></var><br>
<blockquote><!-- Define this macro if the assembler does not accept the character -->
     <!-- @samp{$} in label names.  By default constructors and destructors in -->
     <!-- G++ have @samp{$} in the identifiers.  If this macro is defined, -->
     <!-- @samp{.} is used instead. -->
      <p>定义该宏，如果汇编器不接受标号名字中的&lsquo;<samp><span class="samp">$</span></samp>&rsquo;。缺省的，G++的构造函数和析构函数会在标识符中使用&lsquo;<samp><span class="samp">$</span></samp>&rsquo;。如果该宏被定义，则使用&lsquo;<samp><span class="samp">.</span></samp>&rsquo;来替代。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_DOT_IN_LABEL</b><var><a name="index-NO_005fDOT_005fIN_005fLABEL-4830"></a></var><br>
<blockquote><!-- Define this macro if the assembler does not accept the character -->
     <!-- @samp{.} in label names.  By default constructors and destructors in G++ -->
     <!-- have names that use @samp{.}.  If this macro is defined, these names -->
     <!-- are rewritten to avoid @samp{.}. -->
      <p>定义该宏，如果汇编器不接受标号名字中的&lsquo;<samp><span class="samp">.</span></samp>&rsquo;。缺省的，G++的构造函数和析构函数的名字会使用&lsquo;<samp><span class="samp">.</span></samp>&rsquo;。如果该宏被定义，则这些名字被重写，以避免出现&lsquo;<samp><span class="samp">.</span></samp>&rsquo;。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INSN_SETS_ARE_DELAYED</b> (<var>insn</var>)<var><a name="index-INSN_005fSETS_005fARE_005fDELAYED-4831"></a></var><br>
<blockquote><!-- Define this macro as a C expression that is nonzero if it is safe for the -->
     <!-- delay slot scheduler to place instructions in the delay slot of @var{insn}, -->
     <!-- even if they appear to use a resource set or clobbered in @var{insn}. -->
     <!-- @var{insn} is always a @code{jump_insn} or an @code{insn}; GCC knows that -->
     <!-- every @code{call_insn} has this behavior.  On machines where some @code{insn} -->
     <!-- or @code{jump_insn} is really a function call and hence has this behavior, -->
     <!-- you should define this macro. -->
      <p>定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在<var>insn</var>的延迟槽中是安全的，即使它们可能会使用<var>insn</var>设置或者破坏的一个资源。<var>insn</var>总是一个<code>jump_insn</code>或者<code>insn</code>；GCC知道每个<code>call_insn</code>具有这种行为。在一些机器上，一些<code>insn</code>或者<code>jump_insn</code>确实为一个函数调用，因此也具有这种行为，你应该定义该宏。

     <!-- You need not define this macro if it would always return zero. -->
      <p>如果其总是返回零，则不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INSN_REFERENCES_ARE_DELAYED</b> (<var>insn</var>)<var><a name="index-INSN_005fREFERENCES_005fARE_005fDELAYED-4832"></a></var><br>
<blockquote><!-- Define this macro as a C expression that is nonzero if it is safe for the -->
     <!-- delay slot scheduler to place instructions in the delay slot of @var{insn}, -->
     <!-- even if they appear to set or clobber a resource referenced in @var{insn}. -->
     <!-- @var{insn} is always a @code{jump_insn} or an @code{insn}.  On machines where -->
     <!-- some @code{insn} or @code{jump_insn} is really a function call and its operands -->
     <!-- are registers whose use is actually in the subroutine it calls, you should -->
     <!-- define this macro.  Doing so allows the delay slot scheduler to move -->
     <!-- instructions which copy arguments into the argument registers into the delay -->
     <!-- slot of @var{insn}. -->
      <p>定义该宏为一个C表达式，其为非零，如果对于延迟槽调度器，将指令放在<var>insn</var>的延迟槽中是安全的，即使它们可能会设置或者破坏<var>insn</var>使用的一个资源。<var>insn</var>总是一个<code>jump_insn</code>或者<code>insn</code>。在一些机器上，一些<code>insn</code>或者<code>jump_insn</code>确实为一个函数调用，并且其操作数为寄存器，实际是在其调用的子函数中使用，你应该定义该宏。这使得延迟槽调度器将复制参数到参数寄存器的指令移送到<var>insn</var>的延迟槽中。

     <!-- You need not define this macro if it would always return zero. -->
      <p>如果其总是返回零，则不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MULTIPLE_SYMBOL_SPACES</b><var><a name="index-MULTIPLE_005fSYMBOL_005fSPACES-4833"></a></var><br>
<blockquote><!-- Define this macro as a C expression that is nonzero if, in some cases, -->
     <!-- global symbols from one translation unit may not be bound to undefined -->
     <!-- symbols in another translation unit without user intervention.  For -->
     <!-- instance, under Microsoft Windows symbols must be explicitly imported -->
     <!-- from shared libraries (DLLs). -->
      <p>定义该宏为一个C表达式，其为非零，如果对于一些情况，没有用户的介入，一个转换单元中的全局符号可能不会被发现为另一个转换单元中的未定义的符号。例如，在Microsoft Windows下，符号必须被从共享库（DLL）中显式的导入。

     <!-- You need not define this macro if it would always evaluate to zero. -->
      <p>如果其总是为零，则不需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_MD_ASM_CLOBBERS</b> (<var>tree outputs, tree inputs, tree clobbers</var>)<var><a name="index-TARGET_005fMD_005fASM_005fCLOBBERS-4834"></a></var><br>
<blockquote><!-- This target hook should add to @var{clobbers} @code{STRING_CST} trees for -->
     <!-- any hard regs the port wishes to automatically clobber for an asm. -->
     <!-- It should return the result of the last @code{tree_cons} used to add a -->
     <!-- clobber.  The @var{outputs}, @var{inputs} and @var{clobber} lists are the -->
     <!-- corresponding parameters to the asm and may be inspected to avoid -->
     <!-- clobbering a register that is an input or output of the asm.  You can use -->
     <!-- @code{tree_overlaps_hard_reg_set}, declared in @file{tree.h}, to test -->
     <!-- for overlap with regards to asm-declared registers. -->
      <p>该目标钩子将移植平台希望一个asm可以自动破坏的硬件寄存器增加到<var>clobbers</var> <code>STRING_CST</code> tree中。其应该返回最后一个用于增加一个破坏者的<code>tree_cons</code>。<var>outputs</var>, <var>inputs</var> 和 <var>clobber</var>为asm的相应的参数，可以用来检查以避免破坏asm的输入或者输出寄存器。你可以使用<samp><span class="file">tree.h</span></samp>中声明的<code>tree_overlaps_hard_reg_set</code>来测试是否与asm声明的寄存器有重叠。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MATH_LIBRARY</b><var><a name="index-MATH_005fLIBRARY-4835"></a></var><br>
<blockquote><!-- Define this macro as a C string constant for the linker argument to link -->
     <!-- in the system math library, minus the initial @samp{"-l"}, or -->
     <!-- @samp{""} if the target does not have a -->
     <!-- separate math library. -->
      <p>定义该宏为一个C字符串常量，为连接器的参数，作为系统数学库连接，或者&lsquo;<samp><span class="samp">""</span></samp>&rsquo;，如果目标机没有单独的数学库。

     <!-- You need only define this macro if the default of @samp{"m"} is wrong. -->
      <p>只有当缺省的&lsquo;<samp><span class="samp">"-lm"</span></samp>&rsquo;有错误时，才需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBRARY_PATH_ENV</b><var><a name="index-LIBRARY_005fPATH_005fENV-4836"></a></var><br>
<blockquote><!-- Define this macro as a C string constant for the environment variable that -->
     <!-- specifies where the linker should look for libraries. -->
      <p>定义该宏为一个C字符串常量，为一个环境变量，指定了连接器应该从哪里查找库。

     <!-- You need only define this macro if the default of @samp{"LIBRARY_PATH"} -->
     <!-- is wrong. -->
      <p>只有当缺省的&lsquo;<samp><span class="samp">"LIBRARY_PATH"</span></samp>&rsquo;有错误时，才需要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_POSIX_IO</b><var><a name="index-TARGET_005fPOSIX_005fIO-4837"></a></var><br>
<blockquote><!-- Define this macro if the target supports the following POSIX@ file -->
     <!-- functions, access, mkdir and  file locking with fcntl / F_SETLKW@. -->
     <!-- Defining @code{TARGET_POSIX_IO} will enable the test coverage code -->
     <!-- to use file locking when exiting a program, which avoids race conditions -->
     <!-- if the program has forked. It will also create directories at run-time -->
     <!-- for cross-profiling. -->
      <p>定义该宏，如果目标机支持下列POSIX文件函数，access, mkdir和使用fcntl / F_SETLKW的文件加锁。其还在运行时为交叉profiling创建目录。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_CONDITIONAL_EXECUTE</b><var><a name="index-MAX_005fCONDITIONAL_005fEXECUTE-4838"></a></var><br>
<blockquote><!-- A C expression for the maximum number of instructions to execute via -->
     <!-- conditional execution instructions instead of a branch.  A value of -->
     <!-- @code{BRANCH_COST}+1 is the default if the machine does not use cc0, and -->
     <!-- 1 if it does use cc0. -->
      <p>一个C表达式，为通过条件执行指令来替代分支的最大指令数。值<code>BRANCH_COST</code>+1为缺省值，如果机器没有使用cc0，如果使用了cc0，则为1。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_TESTS</b> (<var>ce_info, true_expr, false_expr</var>)<var><a name="index-IFCVT_005fMODIFY_005fTESTS-4839"></a></var><br>
<blockquote><!-- Used if the target needs to perform machine-dependent modifications on the -->
     <!-- conditionals used for turning basic blocks into conditionally executed code. -->
     <!-- @var{ce_info} points to a data structure, @code{struct ce_if_block}, which -->
     <!-- contains information about the currently processed blocks.  @var{true_expr} -->
     <!-- and @var{false_expr} are the tests that are used for converting the -->
     <!-- then-block and the else-block, respectively.  Set either @var{true_expr} or -->
     <!-- @var{false_expr} to a null pointer if the tests cannot be converted. -->
      <p>使用该宏，如果目标机需要在将基本块转为条件执行代码时，对条件进行机器相关的修改。<var>ce_info</var>指向一个数据结构，<code>struct ce_if_block</code>，其包含了关于当前被处理的块的信息。<var>true_expr</var>和<var>false_expr</var>为测试，分别用于转换then-block和else-block。如果测试不能被转换，则将<var>true_expr</var>或者<var>false_expr</var>设置为空指针。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_MULTIPLE_TESTS</b> (<var>ce_info, bb, true_expr, false_expr</var>)<var><a name="index-IFCVT_005fMODIFY_005fMULTIPLE_005fTESTS-4840"></a></var><br>
<blockquote><!-- Like @code{IFCVT_MODIFY_TESTS}, but used when converting more complicated -->
     <!-- if-statements into conditions combined by @code{and} and @code{or} operations. -->
     <!-- @var{bb} contains the basic block that contains the test that is currently -->
     <!-- being processed and about to be turned into a condition. -->
      <p>类似于<code>IFCVT_MODIFY_TESTS</code>，不过用于将更加复杂的if语句转换为由<code>and</code>和<code>or</code>运算组合的条件。<var>bb</var>包含的基本块，包含了当前被处理的测试，并将被转换为一个条件。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_INSN</b> (<var>ce_info, pattern, insn</var>)<var><a name="index-IFCVT_005fMODIFY_005fINSN-4841"></a></var><br>
<blockquote><!-- A C expression to modify the @var{PATTERN} of an @var{INSN} that is to -->
     <!-- be converted to conditional execution format.  @var{ce_info} points to -->
     <!-- a data structure, @code{struct ce_if_block}, which contains information -->
     <!-- about the currently processed blocks. -->
      <p>一个C表达式，来修改<var>INSN</var>的<var>PATTERN</var>，其将被转换为一个条件执行的格式。<var>ce_info</var>指向一个数据结构，<code>struct ce_if_block</code>，其包含了关于当前被处理的块的信息。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_FINAL</b> (<var>ce_info</var>)<var><a name="index-IFCVT_005fMODIFY_005fFINAL-4842"></a></var><br>
<blockquote><!-- A C expression to perform any final machine dependent modifications in -->
     <!-- converting code to conditional execution.  The involved basic blocks -->
     <!-- can be found in the @code{struct ce_if_block} structure that is pointed -->
     <!-- to by @var{ce_info}. -->
      <p>一个C表达式，用来执行在将代码转换为条件执行时，任何最终机器相关的修改。涉及到的基本块可以在由<var>ce_info</var>指向的<code>struct ce_if_block</code>结构体中找到。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_MODIFY_CANCEL</b> (<var>ce_info</var>)<var><a name="index-IFCVT_005fMODIFY_005fCANCEL-4843"></a></var><br>
<blockquote><!-- A C expression to cancel any machine dependent modifications in -->
     <!-- converting code to conditional execution.  The involved basic blocks -->
     <!-- can be found in the @code{struct ce_if_block} structure that is pointed -->
     <!-- to by @var{ce_info}. -->
      <p>一个C表达式，用来取消在将代码转换为条件执行时，任何机器相关的修改。涉及到的基本块可以在由<var>ce_info</var>指向的<code>struct ce_if_block</code>结构体中找到。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_INIT_EXTRA_FIELDS</b> (<var>ce_info</var>)<var><a name="index-IFCVT_005fINIT_005fEXTRA_005fFIELDS-4844"></a></var><br>
<blockquote><!-- A C expression to initialize any extra fields in a @code{struct ce_if_block} -->
     <!-- structure, which are defined by the @code{IFCVT_EXTRA_FIELDS} macro. -->
      <p>一个C表达式，来初始化任何<code>struct ce_if_block</code>结构体中额外的域，其通过<code>IFCVT_EXTRA_FIELDS</code>宏来定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>IFCVT_EXTRA_FIELDS</b><var><a name="index-IFCVT_005fEXTRA_005fFIELDS-4845"></a></var><br>
<blockquote><!-- If defined, it should expand to a set of field declarations that will be -->
     <!-- added to the @code{struct ce_if_block} structure.  These should be initialized -->
     <!-- by the @code{IFCVT_INIT_EXTRA_FIELDS} macro. -->
      <p>如果被定义，其应该扩展为一个域声明集合，其将被增加到<code>struct ce_if_block</code>结构体中。这些应该通过<code>IFCVT_INIT_EXTRA_FIELDS</code>宏来初始化。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_MACHINE_DEPENDENT_REORG</b> (<var>void</var>)<var><a name="index-TARGET_005fMACHINE_005fDEPENDENT_005fREORG-4846"></a></var><br>
<blockquote><!-- If non-null, this hook performs a target-specific pass over the -->
     <!-- instruction stream.  The compiler will run it at all optimization levels, -->
     <!-- just before the point at which it normally does delayed-branch scheduling. -->
      <p>如果非空，则该钩子对指令流执行目标机特定的编译过程。编译器将在所有优化级别上执行该过程，就在其通常执行延迟分支调度之前的地方。

     <!-- The exact purpose of the hook varies from target to target.  Some use -->
     <!-- it to do transformations that are necessary for correctness, such as -->
     <!-- laying out in-function constant pools or avoiding hardware hazards. -->
     <!-- Others use it as an opportunity to do some machine-dependent optimizations. -->
      <p>该钩子的确切目的因目标机不同而不同。一些用来为了正确性执行必要的转换，例如布局函数常量池，或者避免硬件冒险。其它用来作为机器相关的优化。

     <!-- You need not implement the hook if it has nothing to do.  The default -->
     <!-- definition is null. -->
      <p>如果没有什么可做的，则不需要实现该钩子。缺省定义为空。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_INIT_BUILTINS</b> (<var>void</var>)<var><a name="index-TARGET_005fINIT_005fBUILTINS-4847"></a></var><br>
<blockquote><!-- Define this hook if you have any machine-specific built-in functions -->
     <!-- that need to be defined.  It should be a function that performs the -->
     <!-- necessary setup. -->
      <p>定义该钩子，如果你有任何需要被定义的机器特定的内建函数。其应该为一个函数，执行必要的设置。

     <!-- Machine specific built-in functions can be useful to expand special machine -->
     <!-- instructions that would otherwise not normally be generated because -->
     <!-- they have no equivalent in the source language (for example, SIMD vector -->
     <!-- instructions or prefetch instructions). -->
      <p>机器特定的内建函数可以用于扩展特定的机器指令，否则其通常不会被生成，因为在源语言中没有等价的对应（例如，SIMD向量指令或者预取指令）。

     <!-- To create a built-in function, call the function -->
     <!-- @code{lang_hooks.builtin_function} -->
     <!-- which is defined by the language front end.  You can use any type nodes set -->
     <!-- up by @code{build_common_tree_nodes} and @code{build_common_tree_nodes_2}; -->
     <!-- only language front ends that use those two functions will call -->
     <!-- @samp{TARGET_INIT_BUILTINS}. -->
      <p>要创建一个内建函数，调用函数<code>lang_hooks.builtin_function</code>，其由语言前端定义。你可以使用任何由<code>build_common_tree_nodes</code>和<code>build_common_tree_nodes_2</code>建立的类型节点；只有使用这两个函数的语言前端会调用&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_BUILTIN_DECL</b> (<var>unsigned code, bool initialize_p</var>)<var><a name="index-TARGET_005fBUILTIN_005fDECL-4848"></a></var><br>
<blockquote><p>Define this hook if you have any machine-specific built-in functions
that need to be defined.  It should be a function that returns the
builtin function declaration for the builtin function code <var>code</var>. 
If there is no such builtin and it cannot be initialized at this time
if <var>initialize_p</var> is true the function should return <code>NULL_TREE</code>. 
If <var>code</var> is out of range the function should return
<code>error_mark_node</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_EXPAND_BUILTIN</b> (<var>tree exp, rtx target, rtx subtarget, enum machine_mode mode, int ignore</var>)<var><a name="index-TARGET_005fEXPAND_005fBUILTIN-4849"></a></var><br>
<blockquote><!-- Expand a call to a machine specific built-in function that was set up by -->
     <!-- @samp{TARGET_INIT_BUILTINS}.  @var{exp} is the expression for the -->
     <!-- function call; the result should go to @var{target} if that is -->
     <!-- convenient, and have mode @var{mode} if that is convenient. -->
     <!-- @var{subtarget} may be used as the target for computing one of -->
     <!-- @var{exp}'s operands.  @var{ignore} is nonzero if the value is to be -->
     <!-- ignored.  This function should return the result of the call to the -->
     <!-- built-in function. -->
      <p>扩展由&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;建立的对一个机器特定的内建函数的调用。<var>exp</var>为函数调用的表达式；如果方便的话，结果应该放到<var>target</var>，并且具有机器模式<var>mode</var>。<var>subtarget</var>可以用作目标，来计算<var>exp</var>的操作数。<var>ignore</var>为非零，如果值将被忽略。该函数应该返回调用内建函数的结果。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_RESOLVE_OVERLOADED_BUILTIN</b> (<var>unsigned int loc, tree fndecl, void *arglist</var>)<var><a name="index-TARGET_005fRESOLVE_005fOVERLOADED_005fBUILTIN-4850"></a></var><br>
<blockquote><!-- Select a replacement for a machine specific built-in function that -->
     <!-- was set up by @samp{TARGET_INIT_BUILTINS}.  This is done -->
     <!-- @emph{before} regular type checking, and so allows the target to -->
     <!-- implement a crude form of function overloading.  @var{fndecl} is the -->
     <!-- declaration of the built-in function.  @var{arglist} is the list of -->
     <!-- arguments passed to the built-in function.  The result is a -->
     <!-- complete expression that implements the operation, usually -->
     <!-- another @code{CALL_EXPR}. -->
     <!-- @var{arglist} really has type @samp{VEC(tree,gc)*} -->
      <p>为&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;建立的机器特定内建函数选择一个替身。这发生在常规的类型检查之前，因此允许目标机来实现函数重载的粗糙形式。<var>fndecl</var>为内建函数的声明。<var>arglist</var>为传递给内建函数的参数列表。结果为一个完全表达式，实现了该运算，通常为另一个<code>CALL_EXPR</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_FOLD_BUILTIN</b> (<var>tree fndecl, int n_args, tree *argp, bool ignore</var>)<var><a name="index-TARGET_005fFOLD_005fBUILTIN-4851"></a></var><br>
<blockquote><!-- Fold a call to a machine specific built-in function that was set up by -->
     <!-- @samp{TARGET_INIT_BUILTINS}.  @var{fndecl} is the declaration of the -->
     <!-- built-in function.  @var{n_args} is the number of arguments passed to -->
     <!-- the function; the arguments themselves are pointed to by @var{argp}. -->
     <!-- The result is another tree containing a simplified expression for the -->
     <!-- call's result.  If @var{ignore} is true the value will be ignored. -->
      <p>将&lsquo;<samp><span class="samp">TARGET_INIT_BUILTINS</span></samp>&rsquo;建立的机器特定的内建函数的调用进行折叠。<var>fndecl</var>为内建函数的声明。<var>arglist</var>为传递给内建函数的参数列表。结果为另一个tree，包含了一个简化的表达式，为调用的结果。如果<var>ignore</var>为真，则值将被忽略。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_WITHIN_DOLOOP</b> (<var>const_rtx insn</var>)<var><a name="index-TARGET_005fINVALID_005fWITHIN_005fDOLOOP-4852"></a></var><br>
<blockquote><!-- Take an instruction in @var{insn} and return NULL if it is valid within a -->
     <!-- low-overhead loop, otherwise return a string explaining why doloop -->
     <!-- could not be applied. -->
      <p>接受一个指令<var>insn</var>，如果其在一个低开销循环中有效，则返回NULL，否则返回一个字符串说明为什么不能应用doloop。

     <!-- Many targets use special registers for low-overhead looping. For any -->
     <!-- instruction that clobbers these this function should return a string indicating -->
     <!-- the reason why the doloop could not be applied. -->
     <!-- By default, the RTL loop optimizer does not use a present doloop pattern for -->
     <!-- loops containing function calls or branch on table instructions. -->
      <p>许多目标机使用特定的寄存器，用于低开销循环。对于任何破坏这些的指令，该函数应该返回一个字符串，指出不能应用doloop的原因。缺省的，RTL循环优化不对包含函数调用或者表指令分支的循环，使用现有的doloop指令模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MD_CAN_REDIRECT_BRANCH</b> (<var>branch1, branch2</var>)<var><a name="index-MD_005fCAN_005fREDIRECT_005fBRANCH-4853"></a></var><br>
<blockquote><!-- Take a branch insn in @var{branch1} and another in @var{branch2}. -->
     <!-- Return true if redirecting @var{branch1} to the destination of -->
     <!-- @var{branch2} is possible. -->
      <p>接受一个分支insn <var>branch1</var>和另一个<var>branch2</var>。返回真，如果将<var>branch1</var>重定向到<var>branch2</var>的目的地是可能的。

     <!-- On some targets, branches may have a limited range.  Optimizing the -->
     <!-- filling of delay slots can result in branches being redirected, and this -->
     <!-- may in turn cause a branch offset to overflow. -->
      <p>在一些目标机上，分支可能具有有限的范围。优化延迟槽的填充，可以导致分支可以被重定向，反过来也可能会造成一个分支的偏移量溢出。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_COMMUTATIVE_P</b> (<var>const_rtx x, int outer_code</var>)<var><a name="index-TARGET_005fCOMMUTATIVE_005fP-4854"></a></var><br>
<blockquote><!-- This target hook returns @code{true} if @var{x} is considered to be commutative. -->
     <!-- Usually, this is just COMMUTATIVE_P (@var{x}), but the HP PA doesn't consider -->
     <!-- PLUS to be commutative inside a MEM@.  @var{outer_code} is the rtx code -->
     <!-- of the enclosing rtl, if known, otherwise it is UNKNOWN. -->
      <p>该目标钩子返回<code>true</code>，如果<var>x</var>被认为是可交换的。通常，这就是COMMUTATIVE_P (<var>x</var>)。但是HP PA不认为PLUS在MEM中是可交换的。<var>outer_code</var>为包含rtl的rtx代码，如果知道，否则为UNKNOWN。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_ALLOCATE_INITIAL_VALUE</b> (<var>rtx hard_reg</var>)<var><a name="index-TARGET_005fALLOCATE_005fINITIAL_005fVALUE-4855"></a></var><br>
<blockquote><!-- When the initial value of a hard register has been copied in a pseudo -->
     <!-- register, it is often not necessary to actually allocate another register -->
     <!-- to this pseudo register, because the original hard register or a stack slot -->
     <!-- it has been saved into can be used.  @code{TARGET_ALLOCATE_INITIAL_VALUE} -->
     <!-- is called at the start of register allocation once for each hard register -->
     <!-- that had its initial value copied by using -->
     <!-- @code{get_func_hard_reg_initial_val} or @code{get_hard_reg_initial_val}. -->
     <!-- Possible values are @code{NULL_RTX}, if you don't want -->
     <!-- to do any special allocation, a @code{REG} rtx-that would typically be -->
     <!-- the hard register itself, if it is known not to be clobbered-or a -->
     <!-- @code{MEM}. -->
     <!-- If you are returning a @code{MEM}, this is only a hint for the allocator; -->
     <!-- it might decide to use another register anyways. -->
     <!-- You may use @code{current_function_leaf_function} in the hook, functions -->
     <!-- that use @code{REG_N_SETS}, to determine if the hard -->
     <!-- register in question will not be clobbered. -->
     <!-- The default value of this hook is @code{NULL}, which disables any special -->
     <!-- allocation. -->
      <p>当硬件寄存器的初始值已经被复制到伪寄存器中，通常没有必要为该伪寄存器分配另一个寄存器，因为可以使用原始的硬件寄存器或者被保存到的栈槽。在寄存器分配的起始处，<code>TARGET_ALLOCATE_INITIAL_VALUE</code>针对每个其初始值使用<code>get_func_hard_reg_initial_val</code>或者<code>get_hard_reg_initial_val</code>复制过的，硬件寄存器被调用一次。可能的值为，<code>NULL_RTX</code>如果你不想做任何特殊的分配，一个<code>REG</code> rtx——其通常为硬件寄存器本身，如果知道其不会被破坏——或者一个<code>MEM</code>。如果返回一个<code>MEM</code>，这只是一个给分配器的提示；其仍然有可能会决定用另一个寄存器。你可以在钩子中使用<code>current_function_leaf_function</code>，用来确定被询问的硬件寄存器是否会被破坏。该钩子的缺省值为<code>NULL</code>，其禁止了任何特殊的分配。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_UNSPEC_MAY_TRAP_P</b> (<var>const_rtx x, unsigned flags</var>)<var><a name="index-TARGET_005fUNSPEC_005fMAY_005fTRAP_005fP-4856"></a></var><br>
<blockquote><!-- This target hook returns nonzero if @var{x}, an @code{unspec} or -->
     <!-- @code{unspec_volatile} operation, might cause a trap.  Targets can use -->
     <!-- this hook to enhance precision of analysis for @code{unspec} and -->
     <!-- @code{unspec_volatile} operations.  You may call @code{may_trap_p_1} -->
     <!-- to analyze inner elements of @var{x} in which case @var{flags} should be -->
     <!-- passed along. -->
      <p>该目标钩子返回非零，如果<var>x</var>，一个<code>unspec</code>或者<code>unspec_volatile</code>运算，可能会造成一个陷阱。目标机可以使用该钩子来加强对<code>unspec</code>和<code>unspec_volatile</code>运算的分析的精确性。你可以调用<code>may_trap_p_1</code>来分析<var>x</var>的内部元素，这种情况下，也应该传递<var>flags</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SET_CURRENT_FUNCTION</b> (<var>tree decl</var>)<var><a name="index-TARGET_005fSET_005fCURRENT_005fFUNCTION-4857"></a></var><br>
<blockquote><!-- The compiler invokes this hook whenever it changes its current function -->
     <!-- context (@code{cfun}).  You can define this function if -->
     <!-- the back end needs to perform any initialization or reset actions on a -->
     <!-- per-function basis.  For example, it may be used to implement function -->
     <!-- attributes that affect register usage or code generation patterns. -->
     <!-- The argument @var{decl} is the declaration for the new function context, -->
     <!-- and may be null to indicate that the compiler has left a function context -->
     <!-- and is returning to processing at the top level. -->
     <!-- The default hook function does nothing. -->
      <p>编译器每当改变当前函数上下文(<code>cfun</code>)时，便会调用该钩子。你可以定义该函数，如果后端需要基于每个函数执行任何初始化或者重置行为。例如，其可以用来实现函数属性，影响寄存器的使用或者代码生成指令模式。参数<var>decl</var>为新的函数上下文的声明，可以为空，表示编译器已经离开函数上下文，要返回顶层去处理。缺省钩子函数不做任何事情。

     <!-- GCC sets @code{cfun} to a dummy function context during initialization of -->
     <!-- some parts of the back end.  The hook function is not invoked in this -->
     <!-- situation; you need not worry about the hook being invoked recursively, -->
     <!-- or when the back end is in a partially-initialized state. -->
     <!-- @code{cfun} might be @code{NULL} to indicate processing at top level, -->
     <!-- outside of any function scope. -->
      <p>GCC将<code>cfun</code>设置为一个哑的函数上下文，在初始化后端一些部分的时候。钩子函数在这种情况下不会被调用；你不需要担心钩子函数被递归调用，或者当后端处于部分初始化的状态。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OBJECT_SUFFIX</b><var><a name="index-TARGET_005fOBJECT_005fSUFFIX-4858"></a></var><br>
<blockquote><!-- Define this macro to be a C string representing the suffix for object -->
     <!-- files on your target machine.  If you do not define this macro, GCC will -->
     <!-- use @samp{.o} as the suffix for object files. -->
      <p>定义该宏为C字符串，表示在你的目标机器上，对象文件的后缀。如果没有定义该宏，则GCC会使用&lsquo;<samp><span class="samp">.o</span></samp>&rsquo;作为目标文件的后缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_EXECUTABLE_SUFFIX</b><var><a name="index-TARGET_005fEXECUTABLE_005fSUFFIX-4859"></a></var><br>
<blockquote><!-- Define this macro to be a C string representing the suffix to be -->
     <!-- automatically added to executable files on your target machine.  If you -->
     <!-- do not define this macro, GCC will use the null string as the suffix for -->
     <!-- executable files. -->
      <p>定义该宏为C字符串，表示在你的目标机器上，为可执行文件自动增加的后缀。如果没有定义该宏，GCC将为可执行文件使用空字符串作为后缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>COLLECT_EXPORT_LIST</b><var><a name="index-COLLECT_005fEXPORT_005fLIST-4860"></a></var><br>
<blockquote><!-- If defined, @code{collect2} will scan the individual object files -->
     <!-- specified on its command line and create an export list for the linker. -->
     <!-- Define this macro for systems like AIX, where the linker discards -->
     <!-- object files that are not referenced from @code{main} and uses export -->
     <!-- lists. -->
      <p>如果被定义，<code>collect2</code>将在其命令行中扫描单独的目标文件，并为连接器创建一个导出列表。为AIX这样的系统定义该宏，并使用导出列表，其连接器会丢弃没有从<code>main</code>中引用的对象文件。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MODIFY_JNI_METHOD_CALL</b> (<var>mdecl</var>)<var><a name="index-MODIFY_005fJNI_005fMETHOD_005fCALL-4861"></a></var><br>
<blockquote><!-- Define this macro to a C expression representing a variant of the -->
     <!-- method call @var{mdecl}, if Java Native Interface (JNI) methods -->
     <!-- must be invoked differently from other methods on your target. -->
     <!-- For example, on 32-bit Microsoft Windows, JNI methods must be invoked using -->
     <!-- the @code{stdcall} calling convention and this macro is then -->
     <!-- defined as this expression: -->
      <p>定义该宏为一个C表达式，表示方法调用<var>mdecl</var>的一个变种，如果Java Native Interface (JNI)方法必须通过你目标机上其它方法来调用。例如，在32位Microsoft Windows上，JNI方法必须使用<code>stdcall</code>调用约定来调用，该宏则被定义为如下表达式：

     <pre class="smallexample">          build_type_attribute_variant (<var>mdecl</var>,
                                        build_tree_list
                                        (get_identifier ("stdcall"),
                                         NULL))
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CANNOT_MODIFY_JUMPS_P</b> (<var>void</var>)<var><a name="index-TARGET_005fCANNOT_005fMODIFY_005fJUMPS_005fP-4862"></a></var><br>
<blockquote><!-- This target hook returns @code{true} past the point in which new jump -->
     <!-- instructions could be created.  On machines that require a register for -->
     <!-- every jump such as the SHmedia ISA of SH5, this point would typically be -->
     <!-- reload, so this target hook should be defined to a function such as: -->
      <p>该目标钩子在一个点之后返回<code>true</code>，该处应该创建新的跳转指令。在一些机器上，对每个跳转都要求使用寄存器，例如SH5的SHmedia ISA，该点通常为重载，所以该目标钩子应该被定义为这样的函数：

     <pre class="smallexample">          static bool
          cannot_modify_jumps_past_reload_p ()
          {
            return (reload_completed || reload_in_progress);
          }
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Target Hook: reg_class_t <b>TARGET_BRANCH_TARGET_REGISTER_CLASS</b> (<var>void</var>)<var><a name="index-TARGET_005fBRANCH_005fTARGET_005fREGISTER_005fCLASS-4863"></a></var><br>
<blockquote><!-- This target hook returns a register class for which branch target register -->
     <!-- optimizations should be applied.  All registers in this class should be -->
     <!-- usable interchangeably.  After reload, registers in this class will be -->
     <!-- re-allocated and loads will be hoisted out of loops and be subjected -->
     <!-- to inter-block scheduling. -->
      <p>该目标钩子返回一个寄存器类，分支目标寄存器优化将会应用在该类别上。该类别中的所有寄存器应该是可以互换使用的。重载之后，该类别中的寄存器将被重新分配，并且加载将被悬挂在循环之外，从属于块间调度。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED</b> (<var>bool after_prologue_epilogue_gen</var>)<var><a name="index-TARGET_005fBRANCH_005fTARGET_005fREGISTER_005fCALLEE_005fSAVED-4864"></a></var><br>
<blockquote><!-- Branch target register optimization will by default exclude callee-saved -->
     <!-- registers -->
     <!-- that are not already live during the current function; if this target hook -->
     <!-- returns true, they will be included.  The target code must than make sure -->
     <!-- that all target registers in the class returned by -->
     <!-- @samp{TARGET_BRANCH_TARGET_REGISTER_CLASS} that might need saving are -->
     <!-- saved.  @var{after_prologue_epilogue_gen} indicates if prologues and -->
     <!-- epilogues have already been generated.  Note, even if you only return -->
     <!-- true when @var{after_prologue_epilogue_gen} is false, you still are likely -->
     <!-- to have to make special provisions in @code{INITIAL_ELIMINATION_OFFSET} -->
     <!-- to reserve space for caller-saved target registers. -->
      <p>分支目标寄存器优化，缺省的会将，被调用者保存的寄存器排除在外，其在当前函数中已经是不活跃的。如果目标钩子返回真，它们将被包含进来。目标代码必须确保在由&lsquo;<samp><span class="samp">TARGET_BRANCH_TARGET_REGISTER_CLASS</span></samp>&rsquo;返回的类别中的所有寄存器，如果需要保存的，会被保存。<var>after_prologue_epilogue_gen</var>指出是否序言和尾声已经被生成。注意，即使你只当<var>after_prologue_epilogue_gen</var>为假时返回真，你还可能要在<code>INITIAL_ELIMINATION_OFFSET</code>做出特定的预防，来为调用者保存的目标寄存器保留空间。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_HAVE_CONDITIONAL_EXECUTION</b> (<var>void</var>)<var><a name="index-TARGET_005fHAVE_005fCONDITIONAL_005fEXECUTION-4865"></a></var><br>
<blockquote><p>This target hook returns true if the target supports conditional execution. 
This target hook is required only when the target has several different
modes and they have different conditional execution capability, such as ARM. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: unsigned <b>TARGET_LOOP_UNROLL_ADJUST</b> (<var>unsigned nunroll, struct loop *loop</var>)<var><a name="index-TARGET_005fLOOP_005fUNROLL_005fADJUST-4866"></a></var><br>
<blockquote><p>This target hook returns a new value for the number of times <var>loop</var>
should be unrolled. The parameter <var>nunroll</var> is the number of times
the loop is to be unrolled. The parameter <var>loop</var> is a pointer to
the loop, which is going to be checked for unrolling. This target hook
is required only when the target has special constraints like maximum
number of memory accesses. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>POWI_MAX_MULTS</b><var><a name="index-POWI_005fMAX_005fMULTS-4867"></a></var><br>
<blockquote><p>If defined, this macro is interpreted as a signed integer C expression
that specifies the maximum number of floating point multiplications
that should be emitted when expanding exponentiation by an integer
constant inline.  When this value is defined, exponentiation requiring
more than this number of multiplications is implemented by calling the
system library's <code>pow</code>, <code>powf</code> or <code>powl</code> routines. 
The default value places no upper bound on the multiplication count. 
如果被定义，该宏被解析为一个有符号整型C表达式，描述了浮点乘法的最大数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>TARGET_EXTRA_INCLUDES</b> (<var>const char *sysroot, const char *iprefix, int stdinc</var>)<var><a name="index-TARGET_005fEXTRA_005fINCLUDES-4868"></a></var><br>
<blockquote><!-- This target hook should register any extra include files for the -->
     <!-- target.  The parameter @var{stdinc} indicates if normal include files -->
     <!-- are present.  The parameter @var{sysroot} is the system root directory. -->
     <!-- The parameter @var{iprefix} is the prefix for the gcc directory. -->
      <p>该钩子用于记录目标机的任何额外的include文件。参数<var>stdinc</var>指示是否存在通常的include文件。参数<var>sysroot</var>为系统根目录。参数<var>iprefix</var>为gcc目录的前缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>TARGET_EXTRA_PRE_INCLUDES</b> (<var>const char *sysroot, const char *iprefix, int stdinc</var>)<var><a name="index-TARGET_005fEXTRA_005fPRE_005fINCLUDES-4869"></a></var><br>
<blockquote><!-- This target hook should register any extra include files for the -->
     <!-- target before any standard headers.  The parameter @var{stdinc} -->
     <!-- indicates if normal include files are present.  The parameter -->
     <!-- @var{sysroot} is the system root directory.  The parameter -->
     <!-- @var{iprefix} is the prefix for the gcc directory. -->
      <p>该钩子用于记录目标机的任何先于标准头文件之前的include文件。参数<var>stdinc</var>指示是否存在通常的include文件。参数<var>sysroot</var>为系统根目录。参数<var>iprefix</var>为gcc目录的前缀。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>TARGET_OPTF</b> (<var>char *path</var>)<var><a name="index-TARGET_005fOPTF-4870"></a></var><br>
<blockquote><!-- This target hook should register special include paths for the target. -->
     <!-- The parameter @var{path} is the include to register.  On Darwin -->
     <!-- systems, this is used for Framework includes, which have semantics -->
     <!-- that are different from @option{-I}. -->
      <p>该目标机钩子用来记录目标机特殊的include路径。参数<var>path</var>为要记录的include。在Darwin系统上，被用于Framework include，其语义与<samp><span class="option">-I</span></samp>有所不同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>bool</b><var> TARGET_USE_LOCAL_THUNK_ALIAS_P </var>(<var>tree fndecl</var>)<var><a name="index-bool-4871"></a></var><br>
<blockquote><!-- This target macro returns @code{true} if it is safe to use a local alias -->
     <!-- for a virtual function @var{fndecl} when constructing thunks, -->
     <!-- @code{false} otherwise.  By default, the macro returns @code{true} for all -->
     <!-- functions, if a target supports aliases (i.e.@: defines -->
     <!-- @code{ASM_OUTPUT_DEF}), @code{false} otherwise, -->
      <p>该目标机钩子返回<code>true</code>，如果当为虚函数构造thunk时，使用局部别名是安全的，否则为<code>false</code>。缺省的，钩子对所有函数返回<code>true</code>，如果目标机支持别名（即：定义了<code>ASM_OUTPUT_DEF</code>），否则<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_FORMAT_TYPES</b><var><a name="index-TARGET_005fFORMAT_005fTYPES-4872"></a></var><br>
<blockquote><!-- If defined, this macro is the name of a global variable containing -->
     <!-- target-specific format checking information for the @option{-Wformat} -->
     <!-- option.  The default is to have no target-specific format checks. -->
      <p>如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式检查信息，针对<samp><span class="option">-Wformat</span></samp>选项。缺省为没有目标机特定的格式检查。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_N_FORMAT_TYPES</b><var><a name="index-TARGET_005fN_005fFORMAT_005fTYPES-4873"></a></var><br>
<blockquote><!-- If defined, this macro is the number of entries in -->
     <!-- @code{TARGET_FORMAT_TYPES}. -->
      <p>如果被定义，则该宏为<code>TARGET_FORMAT_TYPES</code>中的项数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OVERRIDES_FORMAT_ATTRIBUTES</b><var><a name="index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES-4874"></a></var><br>
<blockquote><!-- If defined, this macro is the name of a global variable containing -->
     <!-- target-specific format overrides for the @option{-Wformat} option. The -->
     <!-- default is to have no target-specific format overrides. If defined, -->
     <!-- @code{TARGET_FORMAT_TYPES} must be defined, too. -->
      <p>如果被定义，则该宏为全局变量的名字，其包含了目标机特定的格式，用来覆盖<samp><span class="option">-Wformat</span></samp>选项。缺省为没有目标机特定的格式覆盖。如果被定义，则<code>TARGET_FORMAT_TYPES</code>也必须被定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OVERRIDES_FORMAT_ATTRIBUTES_COUNT</b><var><a name="index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES_005fCOUNT-4875"></a></var><br>
<blockquote><!-- If defined, this macro specifies the number of entries in -->
     <!-- @code{TARGET_OVERRIDES_FORMAT_ATTRIBUTES}. -->
      <p>如果被定义，该宏描述<code>TARGET_OVERRIDES_FORMAT_ATTRIBUTES</code>中的项数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_OVERRIDES_FORMAT_INIT</b><var><a name="index-TARGET_005fOVERRIDES_005fFORMAT_005fINIT-4876"></a></var><br>
<blockquote><!-- If defined, this macro specifies the optional initialization -->
     <!-- routine for target specific customizations of the system printf -->
     <!-- and scanf formatter settings. -->
      <p>如果被定义，则该宏描述可选的初始化程序，用于目标机特定的系统printf和scanf格式设置。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_RELAXED_ORDERING</b><var><a name="index-TARGET_005fRELAXED_005fORDERING-4877"></a></var><br>
<blockquote><!-- If set to @code{true}, means that the target's memory model does not -->
     <!-- guarantee that loads which do not depend on one another will access -->
     <!-- main memory in the order of the instruction stream; if ordering is -->
     <!-- important, an explicit memory barrier must be used.  This is true of -->
     <!-- many recent processors which implement a policy of ``relaxed,'' -->
     <!-- ``weak,'' or ``release'' memory consistency, such as Alpha, PowerPC, -->
     <!-- and ia64.  The default is @code{false}. -->
      <p>如果设置为<code>true</code>，则意味着目标机的内存模型不保证，没有依赖关系的加载操作会按照指令流的顺序来访问主存；如果顺序很重要，那么必须使用显式的内存栅栏。这对许多现在的处理器是这样的，例如Alpha, PowerPC和ia64，其实现了关于内存一致性的&ldquo;relaxed,&rdquo; &ldquo;weak,&rdquo; 或 &ldquo;release&rdquo;策略。缺省为<code>false</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN</b> (<var>const_tree typelist, const_tree funcdecl, const_tree val</var>)<var><a name="index-TARGET_005fINVALID_005fARG_005fFOR_005fUNPROTOTYPED_005fFN-4878"></a></var><br>
<blockquote><!-- TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN (const_tree @var{typelist}, const_tree @var{funcdecl}, const_tree @var{val}) -->
     <!-- If defined, this macro returns the diagnostic message when it is -->
     <!-- illegal to pass argument @var{val} to function @var{funcdecl} -->
     <!-- with prototype @var{typelist}. -->
      <p>如果被定义，则当传递参数<var>val</var>给函数原型为<var>typelist</var>的函数<var>funcdecl</var>是非法的时候，该宏会返回诊断信息。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_CONVERSION</b> (<var>const_tree fromtype, const_tree totype</var>)<var><a name="index-TARGET_005fINVALID_005fCONVERSION-4879"></a></var><br>
<blockquote><!-- If defined, this macro returns the diagnostic message when it is -->
     <!-- invalid to convert from @var{fromtype} to @var{totype}, or @code{NULL} -->
     <!-- if validity should be determined by the front end. -->
      <p>如果被定义，则当从<var>fromtype</var>转换成<var>totype</var>是无效的时候，该宏会返回诊断信息，或者返回<code>NULL</code>，如果有效性应该由前端来确定。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_UNARY_OP</b> (<var>int op, const_tree type</var>)<var><a name="index-TARGET_005fINVALID_005fUNARY_005fOP-4880"></a></var><br>
<blockquote><!-- If defined, this macro returns the diagnostic message when it is -->
     <!-- invalid to apply operation @var{op} (where unary plus is denoted by -->
     <!-- @code{CONVERT_EXPR}) to an operand of type @var{type}, or @code{NULL} -->
     <!-- if validity should be determined by the front end. -->
      <p>如果被定义，则当在类型为<var>type</var>的操作数上执行<var>op</var>（一元的加号通过<code>CONVERT_EXPR</code>来表示）是无效的时候，该宏会返回诊断信息，或者返回<code>NULL</code>，如果有效性应该由前端来确定。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_BINARY_OP</b> (<var>int op, const_tree type1, const_tree type2</var>)<var><a name="index-TARGET_005fINVALID_005fBINARY_005fOP-4881"></a></var><br>
<blockquote><!-- If defined, this macro returns the diagnostic message when it is -->
     <!-- invalid to apply operation @var{op} to operands of types @var{type1} -->
     <!-- and @var{type2}, or @code{NULL} if validity should be determined by -->
     <!-- the front end. -->
      <p>如果被定义，则当在类型为<var>type1</var>和<var>type2</var>的操作数上执行<var>op</var>是无效的时候，该宏会返回诊断信息，或者返回<code>NULL</code>，如果有效性应该由前端来确定。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_PARAMETER_TYPE</b> (<var>const_tree type</var>)<var><a name="index-TARGET_005fINVALID_005fPARAMETER_005fTYPE-4882"></a></var><br>
<blockquote><p>If defined, this macro returns the diagnostic message when it is
invalid for functions to include parameters of type <var>type</var>,
or <code>NULL</code> if validity should be determined by
the front end.  This is currently used only by the C and C++ front ends. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_INVALID_RETURN_TYPE</b> (<var>const_tree type</var>)<var><a name="index-TARGET_005fINVALID_005fRETURN_005fTYPE-4883"></a></var><br>
<blockquote><p>If defined, this macro returns the diagnostic message when it is
invalid for functions to have return type <var>type</var>,
or <code>NULL</code> if validity should be determined by
the front end.  This is currently used only by the C and C++ front ends. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_PROMOTED_TYPE</b> (<var>const_tree type</var>)<var><a name="index-TARGET_005fPROMOTED_005fTYPE-4884"></a></var><br>
<blockquote><p>If defined, this target hook returns the type to which values of
<var>type</var> should be promoted when they appear in expressions,
analogous to the integer promotions, or <code>NULL_TREE</code> to use the
front end's normal promotion rules.  This hook is useful when there are
target-specific types with special promotion rules. 
This is currently used only by the C and C++ front ends. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_CONVERT_TO_TYPE</b> (<var>tree type, tree expr</var>)<var><a name="index-TARGET_005fCONVERT_005fTO_005fTYPE-4885"></a></var><br>
<blockquote><p>If defined, this hook returns the result of converting <var>expr</var> to
<var>type</var>.  It should return the converted expression,
or <code>NULL_TREE</code> to apply the front end's normal conversion rules. 
This hook is useful when there are target-specific types with special
conversion rules. 
This is currently used only by the C and C++ front ends. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_USE_JCR_SECTION</b><var><a name="index-TARGET_005fUSE_005fJCR_005fSECTION-4886"></a></var><br>
<blockquote><!-- This macro determines whether to use the JCR section to register Java -->
     <!-- classes. By default, TARGET_USE_JCR_SECTION is defined to 1 if both -->
     <!-- SUPPORTS_WEAK and TARGET_HAVE_NAMED_SECTIONS are true, else 0. -->
      <p>该宏定义是否使用JCR段来记录Java类。缺省的，如果SUPPORTS_WEAK和TARGET_HAVE_NAMED_SECTIONS都为真，则TARGET_USE_JCR_SECTION被定义为1，否则为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>OBJC_JBLEN</b><var><a name="index-OBJC_005fJBLEN-4887"></a></var><br>
<blockquote><!-- This macro determines the size of the objective C jump buffer for the -->
     <!-- NeXT runtime. By default, OBJC_JBLEN is defined to an innocuous value. -->
      <p>该宏为NeXT运行时，确定objective C跳转缓存的大小。缺省的，OBJC_JBLEN被定义为一个无害的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_UNWIND_ATTRIBUTE</b><var><a name="index-LIBGCC2_005fUNWIND_005fATTRIBUTE-4888"></a></var><br>
<blockquote><!-- Define this macro if any target-specific attributes need to be attached -->
     <!-- to the functions in @file{libgcc} that provide low-level support for -->
     <!-- call stack unwinding.  It is used in declarations in @file{unwind-generic.h} -->
     <!-- and the associated definitions of those functions. -->
      <p>定义该宏，如果对于<samp><span class="file">libgcc</span></samp>中那些为调用栈展开（call stack unwinding）提供低级别支持的函数上，需要附加目标机特定的属性时。其被用在<samp><span class="file">unwind-generic.h</span></samp>中的声明和那些函数相关的定义中。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_UPDATE_STACK_BOUNDARY</b> (<var>void</var>)<var><a name="index-TARGET_005fUPDATE_005fSTACK_005fBOUNDARY-4889"></a></var><br>
<blockquote><!-- Define this macro to update the current function stack boundary if -->
     <!-- necessary. -->
      <p>如果需要，定义该宏来更新当前函数栈边界。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_GET_DRAP_RTX</b> (<var>void</var>)<var><a name="index-TARGET_005fGET_005fDRAP_005fRTX-4890"></a></var><br>
<blockquote><!-- This hook should return an rtx for Dynamic Realign Argument Pointer (DRAP) if a -->
     <!-- different argument pointer register is needed to access the function's -->
     <!-- argument list due to stack realignment.  Return @code{NULL} if no DRAP -->
     <!-- is needed. -->
      <p>定义该宏为动态重对齐参数指针（Dynamic Realign Argument Pointer）的rtx，如果当栈被对齐时，需要用不同的参数指针寄存器来访问函数的参数列表。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS</b> (<var>void</var>)<var><a name="index-TARGET_005fALLOCATE_005fSTACK_005fSLOTS_005fFOR_005fARGS-4891"></a></var><br>
<blockquote><!-- When optimization is disabled, this hook indicates whether or not -->
     <!-- arguments should be allocated to stack slots.  Normally, GCC allocates -->
     <!-- stacks slots for arguments when not optimizing in order to make -->
     <!-- debugging easier.  However, when a function is declared with -->
     <!-- @code{__attribute__((naked))}, there is no stack frame, and the compiler -->
     <!-- cannot safely move arguments from the registers in which they are passed -->
     <!-- to the stack.  Therefore, this hook should return true in general, but -->
     <!-- false for naked functions.  The default implementation always returns true. -->
      <p>当优化被禁止时，该钩子用来指示参数是否应该被分配到栈槽中。通常，GCC当不做优化时，会为参数分配栈槽，以便于调试。然而，当函数使用<code>__attribute__((naked))</code>声明时，将没有栈帧，因此编译器不能安全的将参数从用来传递它们的寄存器中移送到栈上。因此，该钩子通常应该返回真，但是对于裸露的函数应该返回假。缺省的实现总是返回真。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: unsigned HOST_WIDE_INT <b>TARGET_CONST_ANCHOR</b><var><a name="index-TARGET_005fCONST_005fANCHOR-4892"></a></var><br>
<blockquote><!-- On some architectures it can take multiple instructions to synthesize -->
     <!-- a constant.  If there is another constant already in a register that -->
     <!-- is close enough in value then it is preferable that the new constant -->
     <!-- is computed from this register using immediate addition or -->
     <!-- subtraction.  We accomplish this through CSE.  Besides the value of -->
     <!-- the constant we also add a lower and an upper constant anchor to the -->
     <!-- available expressions.  These are then queried when encountering new -->
     <!-- constants.  The anchors are computed by rounding the constant up and -->
     <!-- down to a multiple of the value of @code{TARGET_CONST_ANCHOR}. -->
     <!-- @code{TARGET_CONST_ANCHOR} should be the maximum positive value -->
     <!-- accepted by immediate-add plus one.  We currently assume that the -->
     <!-- value of @code{TARGET_CONST_ANCHOR} is a power of 2.  For example, on -->
     <!-- MIPS, where add-immediate takes a 16-bit signed value, -->
     <!-- @code{TARGET_CONST_ANCHOR} is set to @samp{0x8000}.  The default value -->
     <!-- is zero, which disables this optimization.  @end deftypevr -->
      <p>有的体系结构它采用多指令来合成一个常数。如果一个寄存器中已经存在和这个常数值相近的另一个常数，那么它会优先使用寄存器中的这个常数值通过加减运算来得到新常数。我们通过CSE来完成这个功能。除了常数的值，我们还对可用表达式增加上下浮动的锚常量(a lower and an upper constant anchor)。这些在碰到新常数时将会被用到。这些锚通过对 <code>TARGET_CONST_ANCHOR</code> 值的倍数进行舍入而计算得到。<code>TARGET_CONST_ANCHOR</code>的值应该是立即数加加1(immediate-add plus one)所能接受的最大正数。我们现在假设 <code>TARGET_CONST_ANCHOR</code> 是2的乘方。例如，在MIPS上，立即数加的立即数为16位有符号值，而 <code>TARGET_CONST_ANCHOR</code> 被设置为 &lsquo;<samp><span class="samp">0x8000</span></samp>&rsquo;。默认的值是0，也就是关掉了优化。
</p></blockquote></div>

<!-- Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, -->
<!-- 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009 -->
<!-- Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gccint.texi. -->
<!-- @node Host Config -->
<!-- @chapter Host Configuration -->
 </body></html>

