@c Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
@c 2009  Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Trees
@c ---------------------------------------------------------------------

@node Trees
@chapter Trees: C和C++前端使用的中间表示
@cindex Trees
@cindex C/C++ Internal Representation

这一章记述了GCC用来表示C和C++源程序的内部表示。当源程序为C或者C++时，
GCC解析程序，执行语义分析（包括生成错误消息），
然后产生在这里描述的中间表示。
该表示包含了一个对前端输入的整个转换单元的完全表示。
该表示然后由代码生成器处理，从而产生机器代码，
但是还可以用来创建源浏览器，智能编辑器，自动文本生成器，解析器，
以及任何其它处理C或C++代码所需的程序。

这一章解释了内部表示。特别是，记录了C和C++源结构的内部表示，
以及能够用来访问这些结构的宏，函数和变量。
C++的表示很大程度上为C前端使用的表示的超集。
只有一种C中使用的结构没有出现在C++前端，即GNU“嵌套函数”扩展。
许多这里记录的宏不在C中出现，因为相应的语言结构不出现在C 中。

如果你正在开发一个“后端”，一个代码生成器或一些其它工具，
使用了该表示，你可能偶然发现需要询问一些问题，
并且这些问题不好通过这里列出的函数和宏来回答。如果是这种情况，
可能GCC已经支持了你想要的功能，只不过接口并没有记录在这里。
在这种情况下，你应该询问GCC维护者（通过发邮件给@email{gcc@@gcc.gnu.org}），
关于记录你想要的功能。
同样，如果你发现你自己写的函数并不是直接处理你的后端，
而是可能对其他使用GCC前端的人有帮助，你应该将你的patch提交纳入GCC。

@menu
* 不足之处::        在该文档中没有涵盖的专题。
* Tree概述::        所有关于@code{tree}的。
* 类型::            基本类型和聚合类型。
* 作用域::          命名空间和类。
* 函数::            重载，函数体和连接。
* 声明::            类型声明和变量。
* 属性::            声明和类型属性。
* 表达式tree::      从@code{typeid}到@code{throw}。
@end menu

@c ---------------------------------------------------------------------
@c Deficiencies
@c ---------------------------------------------------------------------

@node 不足之处
@section 不足之处

该文档中有许多地方不完整并且有错误。目前，还只是一个@emph{初步的}文档。

@c ---------------------------------------------------------------------
@c Overview
@c ---------------------------------------------------------------------

@node Tree概述
@section 概述
@cindex tree
@findex TREE_CODE

内部表示使用的主要数据结构体为@code{tree}。
这些节点，即所有C类型的@code{tree}，有许多种类。
@code{tree}是一个指针类型，但是它所指向的对象可能会有不同的类型。
从现在开始，除非是在谈论实际的C类型@code{tree}，
我们提到的树都是指普通类型的。

可以通过@code{TREE_CODE}宏来得知特定的树是什么类型的节点。
许多宏以树作为输入，并以树作为输出返回。
然而，大多数宏需要特定的一种树节点作为输入。
换句话说，是有一个树的类型系统，但没有反应在C的类型系统中。

出于安全考虑，使用@option{--enable-checking}来配置GCC会很有用。
虽然这会导致显著的性能亏损（因为所有tree类型都会在运行时被检查），
并且因此在发行版中不合适，但在开发阶段会非常有帮助。

许多宏作为判定条件使用。许多并不是所有的这些判定条件都结束于@samp{_P}。
不要依赖于这些宏的结果类型会是特定的类型。
但是，你可以依赖于类型可以与@code{0}相比较，这个事实。所以，像这样的语句

@smallexample
if (TEST_P (t) && !TEST_P (y))
  x = 1;
@end smallexample
@noindent
和
@smallexample
int i = (TEST_P (t) != 0);
@end smallexample
@noindent
是合法的。现在返回@code{int}值的宏，将来可能被改为返回@code{tree}值，
或者其它指针。即使那些继续返回@code{int}的，也可能会由先前只返回0和1，
改为返回多个非0的代码。因此，不要将代码写成

@smallexample
if (TEST_P (t) == 1)
@end smallexample
@noindent
因为这样的代码不保证将来会正确工作。

不要使用这里描述的宏或者函数的返回值的地址。
特别是，不保证这些值是左值。

一般来说，宏的名字都是大写形式，而函数的名字都是完全小写的。
很少有例外的。
你应该假设任何完全由大写字母组成的宏或函数可能会对它的参数进行多次求值。
你可以假设完全由小写字母组成的宏或函数将会对它的参数只求一次值。

@code{error_mark_node}是一个特殊的树。它的树代码为@code{ERROR_MARK}，
但由于只有一个节点具有那个代码，
所以通常的做法是将树与@code{error_mark_node}进行比较。
（该测试只是一个指针相等的测试。）如果在前端处理中，有一个错误发生，
则标识@code{errorcount}将会被设置。如果前端遇到无法处理的代码，
则会给用户发送一个消息，并设置@code{sorrycount}。当这些标识被设置时，
则通常返回特定类型树的宏和函数，可能会替代的返回@code{error_mark_node}。
因此，如果你打算进行任何错误代码处理，
则必须准备好跟@code{error_mark_node}打交道。

有时，一个特定的树插槽slot（就像表达式的操作数，或声明里的特定域）
将被称为“为后端保留”。这些插槽用于存储RTL，当树被转换为RTL，被GCC后端使用时。
然而，如果没有进行那种处理（例如，如果前端被钩子转向给一个智能编辑器），
那么这些插槽就可以被使用了。

如果你遇到的情况不符合这个文档，如没有在这里提到的树节点的类型，
或记载的宏返回了不同的某一类型实体，那么你发现了一个bug ，要么是前端的，
要么是该文档的。请报告这些bug，以及是否有任何其他的bug。

@menu
* 宏和函数::      可以用于所有树的宏和函数。
* 标识符::        事物的名字。
* 容器::          列表和向量。
@end menu

@c ---------------------------------------------------------------------
@c Trees
@c ---------------------------------------------------------------------

@node 宏和函数
@subsection Trees
@cindex tree

目前还没有这一节的内容。

@c ---------------------------------------------------------------------
@c Identifiers
@c ---------------------------------------------------------------------

@node 标识符
@subsection 标识符
@cindex identifier
@cindex name
@tindex IDENTIFIER_NODE

@code{IDENTIFIER_NODE}表示了比标准C或C++关于标识符更略为一般的概念。
特别是，@code{IDENTIFIER_NODE}可以包含一个@samp{$}，或其它额外的字符。

不会有两个不同的@code{IDENTIFIER_NODE}表示同一个标识符。
因此，你可以使用指针相等的方式来比较@code{IDENTIFIER_NODE}，
而不必使用像strcmp这样的函数。

可以使用下列宏来访问标识符：

@ftable @code
@item IDENTIFIER_POINTER
标识符所表示的字符串，为一个@code{char*}。
该字符串总是以@code{NUL}结束，并且不包含嵌入的@code{NUL}字符。

@item IDENTIFIER_LENGTH
由@code{IDENTIFIER_POINTER}返回的字符串的长度，不包括结尾的@code{NUL}。
@code{IDENTIFIER_LENGTH (x)}的值总是与@code{strlen (IDENTIFIER_POINTER (x))}相同。

@item IDENTIFIER_OPNAME_P
该断言当标识符表示的是重载操作符的名字时有效。这种情况下，
不要依赖@code{IDENTIFIER_POINTER}或@code{IDENTIFIER_LENGTH}的内容。 

@item IDENTIFIER_TYPENAME_P
该断言当标识符表示的是用户定义的转换操作符的名字时有效。这种情况下，
@code{IDENTIFIER_NODE}的@code{TREE_TYPE}持有转换操作符转换后的类型。
@end ftable

@c ---------------------------------------------------------------------
@c Containers
@c ---------------------------------------------------------------------

@node 容器
@subsection 容器
@cindex container
@cindex list
@cindex vector
@tindex TREE_LIST
@tindex TREE_VEC
@findex TREE_PURPOSE
@findex TREE_VALUE
@findex TREE_VEC_LENGTH
@findex TREE_VEC_ELT

有两种通用容器数据结构可以直接用树节点表示。
@code{TREE_LIST}是一个单向链表，每个节点包含两个树。
每个节点都有@code{TREE_PURPOSE}和@code{TREE_VALUE}。
（很多时候，@code{TREE_PURPOSE}包含了某种tag，或补充信息，
而@code{TREE_VALUE}包含了大部分的有效载荷。在其他情况下，
@code{TREE_PURPOSE}只是一个@code{NULL_TREE}，而还有一些情况，
@code{TREE_PURPOSE}和@code{TREE_VALUE}是处于相等的状况。）
给定一个@code{TREE_LIST}节点，可以沿着@code{TREE_CHAIN}来找到下一个节点。
如果@code{TREE_CHAIN}为@code{NULL_TREE}时，则表示到达链表的结尾了。

@code{TREE_VEC}是一个简单的向量。@code{TREE_VEC_LENGTH}是一个整数（不是树），
给出了向量中节点的数目。节点本身通过宏@code{TREE_VEC_ELT}来访问，
其接受两个参数。第一个为要查询的@code{TREE_VEC}；
第二个为整数，指定了向量中的元素。元素索引从0开始。

@c ---------------------------------------------------------------------
@c Types
@c ---------------------------------------------------------------------

@node 类型
@section 类型
@cindex type
@cindex pointer
@cindex reference
@cindex fundamental type
@cindex array
@tindex VOID_TYPE
@tindex INTEGER_TYPE
@tindex TYPE_MIN_VALUE
@tindex TYPE_MAX_VALUE
@tindex REAL_TYPE
@tindex FIXED_POINT_TYPE
@tindex COMPLEX_TYPE
@tindex ENUMERAL_TYPE
@tindex BOOLEAN_TYPE
@tindex POINTER_TYPE
@tindex REFERENCE_TYPE
@tindex FUNCTION_TYPE
@tindex METHOD_TYPE
@tindex ARRAY_TYPE
@tindex RECORD_TYPE
@tindex UNION_TYPE
@tindex UNKNOWN_TYPE
@tindex OFFSET_TYPE
@tindex TYPENAME_TYPE
@tindex TYPEOF_TYPE
@findex CP_TYPE_QUALS
@findex TYPE_UNQUALIFIED
@findex TYPE_QUAL_CONST
@findex TYPE_QUAL_VOLATILE
@findex TYPE_QUAL_RESTRICT
@findex TYPE_MAIN_VARIANT
@cindex qualified type
@findex TYPE_SIZE
@findex TYPE_ALIGN
@findex TYPE_PRECISION
@findex TYPE_ARG_TYPES
@findex TYPE_METHOD_BASETYPE
@findex TYPE_PTRMEM_P
@findex TYPE_OFFSET_BASETYPE
@findex TREE_TYPE
@findex TYPE_CONTEXT
@findex TYPE_NAME
@findex TYPENAME_TYPE_FULLNAME
@findex TYPE_FIELDS
@findex TYPE_PTROBV_P
@findex TYPE_CANONICAL
@findex TYPE_STRUCTURAL_EQUALITY_P
@findex SET_TYPE_STRUCTURAL_EQUALITY

所有的类型都有相应的树节点。
但是不要假设一个树节点就是正好对应于一个类型。
经常有多个节点对应于相同的类型。

在大多数情况下，不同种类的类型具有不同的树代码。
（例如，指针类型使用@code{POINTER_TYPE}代码，
而数组使用@code{ARRAY_TYPE}代码。）但是，
指向成员函数的指针使用@code{RECORD_TYPE}代码。
因此，当写与特定类型相关联的@code{switch}语句时，
应该在@code{RECORD_TYPE} case标签下小心处理指向成员函数的指针。

在C++中，数组类型没有被限定，而是数组元素的类型被限定。
这种情况反映在中间表示中。这里描述的宏在应用到数组类型时，
将总是检验元素类型的限定符。（如果元素类型本身是一个数组，
则会递归执行只到找到非数组类型，并检验该类型的限定符）所以，
例如，@code{CP_TYPE_CONST_P}当表示具有七个@code{int}的数组时，
将持有@code{const int ()[7]}类型。

下列函数和宏处理cv-qualification的类型：

@ftable @code
@item CP_TYPE_QUALS
该宏返回应用到该类型的类型限定符集。
如果没有应用限定符则该值为@code{TYPE_UNQUALIFIED}。
如果类型是@code{const}的，则会设置@code{TYPE_QUAL_CONST}位。
如果类型是@code{volatile}的，则会设置@code{TYPE_QUAL_VOLATILE}位。
如果类型是@code{restrict}的，则会设置@code{TYPE_QUAL_RESTRICT}位。 

@item CP_TYPE_CONST_P
该宏当类型是@code{const}时有效。

@item CP_TYPE_VOLATILE_P
该宏当类型是@code{volatile}时有效。 

@item CP_TYPE_RESTRICT_P
该宏当类型是@code{restrict}时有效。 

@item CP_TYPE_CONST_NON_VOLATILE_P
该断言当类型是@code{const}的，但@emph{不是}@code{volatile}的时有效。
其它cv-qualifiers会被忽略，只测试@code{const}。 

@item TYPE_MAIN_VARIANT
该宏类型未限定的版本。可以用于一个未限定的类型，但这种情况下，
并不总是标识符函数。 
@end ftable

一些其它的宏和函数可用于所有的类型：
@ftable @code
@item TYPE_SIZE
类型表示所需要的位数，为一个@code{INTEGER_CST}。
对于不完全类型，@code{TYPE_SIZE}将为@code{NULL_TREE}。 

@item TYPE_ALIGN
类型的对齐位数，为一个@code{int}。 

@item TYPE_NAME
该宏返回类型的一个声明（按照@code{TYPE_DECL}的型式）。
（注意该宏不返回@code{IDENTIFIER_NODE}）
你可以查看@code{TYPE_DECL}的@code{DECL_NAME}来获得类型的实际的名字。
@code{TYPE_NAME}将为@code{NULL_TREE}，对于不是内建类型的，typedef的，
或者命名的class类型。

@item CP_INTEGRAL_TYPE
该断言有效，如果类型为一个整数类型。注意在C++中，枚举@emph{不是}整数类型。 

@item ARITHMETIC_TYPE_P
该断言有效，如果类型为一个整数类型（按照c++的观点）或者一个浮点类型。 

@item CLASS_TYPE_P
该断言有效，对于一个class类型。 

@item TYPE_BUILT_IN
该断言有效，对于一个内建类型。 

@item TYPE_PTRMEM_P
该断言有效，如果类型为一个指向数据成员的指针。 

@item TYPE_PTR_P
该断言有效，如果类型为一个指针，而指向者不是一个数据成员。 

@item TYPE_PTRFN_P
该断言有效，对于一个执行函数类型的指针。 

@item TYPE_PTROB_P
该断言有效，对于一个指向object类型的指针。
注意其对于指向object类型@code{void *}的通用指针无效。
你可以使用@code{TYPE_PTROBV_P}来测试指针是指向object类型，
同时也是@code{void *}。 

@item TYPE_CANONICAL
该宏为给定的类型节点返回“正则”类型。正则类型用于C++和Objective-C的前端，使得在@code{same_type_p}中，可以对两个类型进行高效的比较，从而提高性能：如果类型的@code{TYPE_CANONICAL}值相等，则类型是等价的；否则，类型不相等。关于正则类型的相等的概念，与在语言中类型相等的概念是一样的。例如，

当@code{TYPE_CANONICAL}为@code{NULL_TREE}，则对于给定的类型节点，没有正则类型。这种情况下，比较该类型和任何其它类型，需要编译器执行深入的，“结构化的”比较，来看两个类型节点是否具有相同的形式和属性。

节点的正则类型，在等价的类型类别中，总是最根本的类型。例如，@code{int}为其自己的正则类型。@code{int}的自定义类型@code{I}，将@code{int}作为它的正则类型。类似的，@code{I*}和自定义类型@code{IP}（定义为@code{I*}），将@code{int*}作为它们的正则类型。当构建一个新的类型节点时，要记着将@code{TYPE_CANONICAL}设置为合适的正则类型。如果新类型为一个复合类型（从其它类型中构建的），并且那些类型中的任意一个需要进行结构化相等，则使用@code{SET_TYPE_STRUCTURAL_EQUALITY}来确保新的类型也需要结构化相等。最后，如果出于某种原因，你不能确保@code{TYPE_CANONICAL}能指向正则类型，则使用@code{SET_TYPE_STRUCTURAL_EQUALITY}来确保新的类型，任何基于它构建的类型，则需要结构化相等。如果你怀疑正则类型系统进行了错误的类型比较，则将@code{--param verify-canonical-types=1}传给编译器，或者使用@code{--enable-checking}来configure，强制编译器基于结构化比较来验证它的正则类型比较；如果正则类型比较有出入，则编译器将打印出警告信息。

@item TYPE_STRUCTURAL_EQUALITY_P
当节点需要进行结构相等检查的时候，该断言成立，例如，当@code{TYPE_CANONICAL}为@code{NULL_TREE}时。

@item SET_TYPE_STRUCTURAL_EQUALITY
该宏规定给定的类型节点需要进行结构相等检查，例如，其将@code{TYPE_CANONICAL}设为@code{NULL_TREE}

@item same_type_p
该断言接受两个类型作为输入，如果它们为相同的类型，则判断成立。例如，如果一个类型为另一个类型的@code{typedef}，或者这两个都为同一个类型的@code{typedef}。如果作为输入给定的两个tree，只是简单的为另一个的复制，则该断言也成立；即，它们在源代码级别没有差别，但是，出于某种原因，在表示的时候进行了复制。不要用@code{==}（pointer equality）来比较类型；要用@code{same_type_p}。

@end ftable

下面详细介绍了各种类型，以及可以用来访问它们的宏。虽然有其它类型是在G++中用到，这里描述的类型将只是当你检查中间表示时会遇到的。

@table @code
@item VOID_TYPE
用于表示@code{void}类型。 

@item INTEGER_TYPE
用来表示跟中整数类型，包括@code{char}，@code{short}，@code{int}，@code{long}和@code{long long}。该代码不用于枚举类型和@code{bool}类型。@code{TYPE_PRECISION}为用于表示该类型的位数，是一个@code{unsigned int}。（注意，通常情况它的值与@code{TYPE_SIZE}不相同；假设有一个24位的整数类型，但是ABI要求32位的对齐方式。则，@code{TYPE_SIZE}将为一个@code{INTEGER_CST}，32，而@code{TYPE_PRECISION}为24。）如果@code{TYPE_UNSIGNED}成立，则整数类型为无符号的；否则为有符号的。

@code{TYPE_MIN_VALUE}为一个@code{INTEGER_CST}，是该类型可以表示的最小整数。类似的，@code{TYPE_MAX_VALUE}为一个@code{INTEGER_CST}，是该类型可以表示的最大整数。

@item REAL_TYPE
用来表示类型@code{float}，@code{double}和@code{long double}。跟@code{INTEGER_TYPE}的情况类型，用于浮点表示的位数由@code{TYPE_PRECISION}给出。

@item FIXED_POINT_TYPE
用来表示类型@code{short _Fract}, @code{_Fract}, @code{long _Fract}, @code{long long _Fract}, @code{short _Accum}, @code{_Accum}, @code{long _Accum}, 和 @code{long long _Accum}。跟@code{INTEGER_TYPE}的情况类型，用于定点表示的位数由@code{TYPE_PRECISION}给出。可能会有填充位，小数位和整数位。小数的位数由@code{TYPE_FBIT}给出，整数的位数由@code{TYPE_IBIT}给出。如果@code{TYPE_UNSIGNED}成立，则定点类型为无符号的；否则为有符号的。

如果@code{TYPE_SATURATING}成立，则定点类型为饱和的；否则不是饱和的。。

@item COMPLEX_TYPE
用来表示GCC内建的@code{__complex__}数据类型。@code{TREE_TYPE}为实部和虚部的类型。

@item ENUMERAL_TYPE
用于表示枚举类型。@code{TYPE_PRECISION}给出了用于表示该类型的位数（为一个@code{int}）。如果没有负数的枚举常量，则@code{TYPE_UNSIGNED}成立。最小和最大的枚举常量，可以分别使用@code{TYPE_MIN_VALUE}和@code{TYPE_MAX_VALUE}获得；每个宏都返回一个@code{INTEGER_CST}。

实际的枚举常量可以通过查看@code{TYPE_VALUES}来获得。该宏将返回一个@code{TREE_LIST}，包含了常量；@code{TREE_VALUE}将为一个@code{INTEGER_CST}，给出了赋予那个常量的值。这些常量将按照它们被声明的顺序出现。每个常量的@code{TREE_TYPE}，将为枚举类型本身的类型。

@item BOOLEAN_TYPE
用来表示@code{bool}类型。

@item POINTER_TYPE
用来表示指针类型，以及指向数据成员的指针类型。@code{TREE_TYPE}给出了所指向的类型。如果类型为一个指向数据成员的指针，则@code{TYPE_PTRMEM_P}成立。对于一个指向@samp{T X::*}形式的数据成员类型的指针，@code{TYPE_PTRMEM_CLASS_TYPE}将为类型@code{X}，而@code{TYPE_PTRMEM_POINTED_TO_TYPE}为类型@code{T}。

@item REFERENCE_TYPE
用来表示引用类型。@code{TREE_TYPE}给出了所引用的类型。

@item FUNCTION_TYPE
用来表示非成员函数和静态成员函数的类型。@code{TREE_TYPE}给出了函数的返回值类型。@code{TYPE_ARG_TYPES}为一个@code{TREE_LIST}，参数类型列表。该列表上的每个节点的@code{TREE_VALUE}为相应参数的类型；@code{TREE_PURPOSE}如果存在，则为缺省参数值的表达式。如果列表中的最后一个节点为@code{void_list_node}（一个@code{TREE_LIST}节点，其@code{TREE_VALUE}为@code{void_type_node}），则该类型的函数不接受可变参数。否则，它们是接受可变数目的参数。

注意，在C（而不是C++）中，一个声明如@code{void f()}的函数，为一个无函数原型的函数，其接受可变数目的参数；这样的函数的@code{TYPE_ARG_TYPES}将为@code{NULL}。

@item METHOD_TYPE
用来表示非静态成员函数的类型。像@code{FUNCTION_TYPE}一样，返回值由@code{TREE_TYPE}给出。@code{*this}的类型，即，这个函数成员所在的类的类型，由@code{TYPE_METHOD_BASETYPE}给出。@code{TYPE_ARG_TYPES}为参数列表，就像@code{FUNCTION_TYPE}一样，包含@code{this}参数。

@item ARRAY_TYPE
用于表示数组类型，@code{TREE_TYPE}给出了数组元素的类型。如果数组边界在类型中存在，则@code{TYPE_DOMAIN}为一个@code{INTEGER_TYPE}，它的@code{TYPE_MIN_VALUE}和@code{TYPE_MAX_VALUE}将分别为数组的下界和上界。@code{TYPE_MIN_VALUE}将总是为@code{INTEGER_CST}，0，而@code{TYPE_MAX_VALUE}将为数组元素数目减1，即可以用来索引数组元素的最大值。

@item RECORD_TYPE
用来表示@code{struct}和@code{class}类型，以及指向成员函数和其它语言中类似结构的指针。@code{TYPE_FIELDS}包含了该类型中包含的项，其可以为@code{FIELD_DECL}, @code{VAR_DECL}, @code{CONST_DECL}或@code{TYPE_DECL}。你不能假设类型中的域之间的顺序，以及它们是否有重叠。如果@code{TYPE_PTRMEMFUNC_P}成立，则该类型为一个指向成员（pointer-to-member）的类型。这种情况下，@code{TYPE_PTRMEMFUNC_FN_TYPE}为一个@code{POINTER_TYPE}，指向一个@code{METHOD_TYPE}。@code{METHOD_TYPE}为由pointer-to-member函数指向的函数的类型。如果@code{TYPE_PTRMEMFUNC_P}不成立，则该类型为一个class类型。更多信息，参见@pxref{类}。

@item UNION_TYPE
用来表示@code{union}类型。类似于@code{RECORD_TYPE}，只不过在@code{TYPE_FIELD}中的所有@code{FIELD_DECL}起始于0位。

@item QUAL_UNION_TYPE
用来表示Ada中的可变记录（variant record）的一部分。类似于@code{UNION_TYPE}，只不过每个@code{FIELD_DECL}具有一个@code{DECL_QUALIFIER}域，其包含了一个布尔表达式，用来指示该域是否在对象中存在。该类型将只有一个域，所以只有当@code{TYPE_FIELDS}中，先前的域中的表达式都不为零时，每个域的@code{DECL_QUALIFIER}才被求值。通常，这些表达式将使用@code{PLACEHOLDER_EXPR}引用外部对象的一个域。

@item UNKNOWN_TYPE
该节点用来表示一个类型，其信息不足以进行合理的处理。

@item OFFSET_TYPE
该节点用于表示一个pointer-to-data成员。对于一个数据成员@code{X::m}，则@code{TYPE_OFFSET_BASETYPE}为@code{X}，@code{TREE_TYPE}为 @code{m}类型.

@item TYPENAME_TYPE
用于表示@code{typename T::A}。@code{TYPE_CONTEXT}为@code{T}；@code{TYPE_NAME}为@code{A}的@code{IDENTIFIER_NODE}。如果类型通过模板id指定，则@code{TYPENAME_TYPE_FULLNAME}产生一个@code{TEMPLATE_ID_EXPR}。如果节点是被隐式的生成，用来支持隐式类型名扩展，则@code{TREE_TYPE}不为@code{NULL}；这种情况下，@code{TREE_TYPE}为基类的类型节点。

@item TYPEOF_TYPE
用于表示@code{__typeof__}扩展。@code{TYPE_FIELDS}为被表示的类型的表达式。 
@end table

有些变量，它们的值表示基本的类型。这包括：
@table @code
@item void_type_node
@code{void}节点。

@item integer_type_node
@code{int}节点。

@item unsigned_type_node.
@code{unsigned int}节点。

@item char_type_node.
@code{char}节点。
@end table
@noindent
有时使用@code{same_type_p}将这些变量和手头的类型进行比较会很有帮助。 

@c ---------------------------------------------------------------------
@c Scopes
@c ---------------------------------------------------------------------

@node 作用域
@section 作用域
@cindex namespace, class, scope

整个中间表示的根是变量@code{global_namespace}。
这是在C++源代码中由@code{::}描述的命名空间。
所有其它命名空间，类型，变量，函数等，都能够从这里开始查找而获得。

除了命名空间以外，C++中另一个高层次的作用域结构是类。
（在该手册中，术语@dfn{class}用来表示ANSI/ISO C++标准中的@code{class}类型；
这包括用@code{class}, @code{struct}和@code{union}关键字定义的类型。）

@menu
* 命名空间::     成员函数，类型等。
* 类::           成员，基类，友员等。
@end menu

@c ---------------------------------------------------------------------
@c Namespaces
@c ---------------------------------------------------------------------

@node 命名空间
@subsection 命名空间
@cindex namespace
@tindex NAMESPACE_DECL

命名空间由@code{NAMESPACE_DECL}节点表示。

然而，除了实际上是作为根表示以外，全局命名空间与其它命名空间没有区别。
因此，在下文中，我们描述的是普遍的命名空间，而不是特定的全局命名空间。

下列宏和函数可以用于@code{NAMESPACE_DECL}:

@ftable @code
@item DECL_NAME
该宏用于获得@code{IDENTIFIER_NODE}相应的命名空间的未限定名
（参见 @ref{标识符}）。
全局命名空间的名字为@samp{::}，虽然在C++中全局命名空间是没有名字的。
然而，你应该使用与@code{global_namespace}比较的方式，
而不是用@code{DECL_NAME}来确定命名空间是否为全局的。
一个未命名的命名空间，其 @code{DECL_NAME}等于@code{anonymous_namespace_name}。
在一个单独的转换单元中，所有未命名空间将具有同一名字。 

@item DECL_CONTEXT
该宏返回闭包的（enclosing）命名空间。
@code{global_namespace}的@code{DECL_CONTEXT}为@code{NULL_TREE}。 

@item DECL_NAMESPACE_ALIAS
如果该声明是一个命名空间的别名，
则@code{DECL_NAMESPACE_ALIAS}为该别名所针对的命名空间。

不要对别名命名空间尝试使用@code{cp_namespace_decls}。
相反的，沿着@code{DECL_NAMESPACE_ALIAS}链直到一个普通的，非别名的命名空间，
然后在那里调用@code{cp_namespace_decls}。

@item DECL_NAMESPACE_STD_P
该断言当命名空间为特殊的@code{::std}命名空间时有效。 

@item cp_namespace_decls
该函数将返回包含在命名空间中的声明，包括类型，重载函数，其它命名空间等等。
如果没有声明，该函数将返回@code{NULL_TREE}。
声明通过它们的@code{TREE_CHAIN}域连在一起。

虽然这个链表中的大多数实体将为声明，但也可能会出现@code{TREE_LIST}。
这种情况下，@code{TREE_VALUE}将为一个@code{OVERLOAD}。
@code{TREE_PURPOSE}的值未指定；后端应该忽略这个值。
至于由@code{cp_namespace_decls}返回的其它种类的声明，
@code{TREE_CHAIN}将会指向该链表中的下一个声明。

关于可以出现在该链表中的各种声明的更多信息，参见 @ref{声明}。
一些声明将不会出现在该链表中。
特别是，@code{FIELD_DECL}, @code{LABEL_DECL}和@code{PARM_DECL}节点。

该函数不能用于设置了@code{DECL_NAMESPACE_ALIAS}的命名空间。

@end ftable

@c ---------------------------------------------------------------------
@c Classes
@c ---------------------------------------------------------------------

@node 类
@subsection 类
@cindex class
@tindex RECORD_TYPE
@tindex UNION_TYPE
@findex CLASSTYPE_DECLARED_CLASS
@findex TYPE_BINFO
@findex BINFO_TYPE
@findex TYPE_FIELDS
@findex TYPE_VFIELD
@findex TYPE_METHODS

类的类型被表示为@code{RECORD_TYPE}或者@code{UNION_TYPE}。
使用@code{union}标签声明的类由@code{UNION_TYPE}来表示，
而使用@code{struct}或者@code{class}标签声明的类由@code{RECORD_TYPE}来表示。
可以使用@code{CLASSTYPE_DECLARED_CLASS}宏来判定一个特定类型是
@code{class}的还是@code{struct}的。
该宏只在类使用@code{class}标签声明时才为真。

几乎所有非函数的成员都在@code{TYPE_FIELDS}列表中。
给出一个成员，可以通过@code{TREE_CHAIN}来找到下一个。
不要依赖于在该链表中出现的域的顺序。链表中的所有节点将为@samp{DECL}节点。
@code{FIELD_DECL}用于表示非静态数据成员，@code{VAR_DECL}用于表示静态数据成员，
而@code{TYPE_DECL}用于表示类型。注意如果在类中声明了枚举类型，
则用于枚举常量的@code{CONST_DECL}将会出现在该链表中。
（当然，枚举类型的@code{TYPE_DECL}也会出现。）链表中没有基类的实体。
特别是，对于一个对象的基类部分“base-class portion”，没有@code{FIELD_DECL}。

@code{TYPE_VFIELD}是编译器生成的域用于指向虚函数表。
它有可能会出现在@code{TYPE_FIELDS}链表中。
然而，后端应该处理@code{TYPE_VFIELD}，
就像@code{TYPE_FIELDS}链表中所有其它实体一样。

函数成员在@code{TYPE_METHODS}链表中。
同样，后续成员可以通过@code{TREE_CHAIN}域来找到。
如果函数是重载的，每个重载函数都会出现；
@code{OVERLOAD}节点不会出现在@code{TYPE_METHODS}链表上。
隐式声明的函数（包括缺省构造函数，复制构造函数，赋值操作和析构函数）
也会出现在该链表中。

每个类都具有一个相关的@dfn{binfo}，其能够通过@code{TYPE_BINFO}获得。
Binfos用于表示基类。由@code{TYPE_BINFO}给出的binfo是退化情况，
让每个类被考虑为它自己的基类。

对基类型的访问可以通过@code{BINFO_BASE_ACCESS}。
这将产生@code{access_public_node}, @code{access_private_node}或
@code{access_protected_node}。
如果基类总是public的，@code{BINFO_BASE_ACCESSES}可以为@code{NULL}。

@code{BINFO_VIRTUAL_P}用于指定binfo是否为虚继承。
其它标识，@code{BINFO_MARKED_P}和
@code{BINFO_FLAG_1}到@code{BINFO_FLAG_6}可以用于语言特定用途。

下列宏可以用在表示class类型的树节点上。

@ftable @code
@item LOCAL_CLASS_P
该断言当是局部类时有效，即在函数体内声明的类。 

@item TYPE_POLYMORPHIC_P
该断言当类至少具有一个虚函数（声明的或者继承的）时有效。 

@item TYPE_HAS_DEFAULT_CONSTRUCTOR
该断言当参数表示具有缺省构造函数的class类型时有效。 

@item CLASSTYPE_HAS_MUTABLE
@itemx TYPE_HAS_MUTABLE_P
这些断言表示了一个class-type具有mutable数据成员。 

@item CLASSTYPE_NON_POD_P
该断言表示了不是POD的class-types。 

@item TYPE_HAS_NEW_OPERATOR
该断言表示一个class-type定义了@code{operator new}。

@item TYPE_HAS_ARRAY_NEW_OPERATOR
该断言表示一个class-type定义了@code{operator new[]}。

@item TYPE_OVERLOADS_CALL_EXPR
该断言表示class-type重载了函数调用@code{operator()}。

@item TYPE_OVERLOADS_ARRAY_REF
该断言表示class-type重载了@code{operator[]}。

@item TYPE_OVERLOADS_ARROW
该断言表示class-type重载了@code{operator->}。
@end ftable

@c ---------------------------------------------------------------------
@c Declarations
@c ---------------------------------------------------------------------

@node 声明
@section 声明
@cindex declaration
@cindex variable
@cindex type declaration
@tindex LABEL_DECL
@tindex CONST_DECL
@tindex TYPE_DECL
@tindex VAR_DECL
@tindex PARM_DECL
@tindex FIELD_DECL
@tindex NAMESPACE_DECL
@tindex RESULT_DECL
@tindex TEMPLATE_DECL
@tindex THUNK_DECL
@tindex USING_DECL
@findex THUNK_DELTA
@findex DECL_INITIAL
@findex DECL_SIZE
@findex DECL_ALIGN
@findex DECL_EXTERNAL
这一节涵盖了出现在内部表示中的各种声明。
函数声明（由@code{FUNCTION_DECL}节点表示）除外，其在@ref{函数}一节中描述。

@menu
* 关于声明的操作::  作用于声明的宏和函数。
* 内部结构::        声明节点是如何表示的。 
@end menu

@node 关于声明的操作
@subsection 关于声明的操作
一些宏可以用于任何种类的声明。这包括：
@ftable @code
@item DECL_NAME
该宏返回一个@code{IDENTIFIER_NODE}，给出了实体的名字。

@item TREE_TYPE
该宏返回被声明的实体的类型。

@item TREE_FILENAME
该宏返回被声明的实体所在的文件的名字，作为一个@code{char*}。对于由编译器隐式声明的实体（比如@code{__builtin_memcpy}），这将为字符串@code{"<internal>"}。

@item TREE_LINENO
该宏返回被声明的实体所在的行号，作为一个@code{int}。

@item DECL_ARTIFICIAL
该断言用来表示声明是否为编译器隐式产生的。例如，该断言可以用来存放一个隐式声明的成员函数，或者为一个class类型隐式生成的@code{TYPE_DECL}。回想一下在C++代码中：

@smallexample
struct S @{@};
@end smallexample
@noindent
大体上等价于C代码：
@smallexample
struct S @{@};
typedef struct S S;
@end smallexample
隐式生成的@code{typedef}声明由@code{TYPE_DECL}表示，在@code{DECL_ARTIFICIAL}中存放。

@item DECL_NAMESPACE_SCOPE_P
该断言用来表示实体是否在一个命名空间中被声明。

@item DECL_CLASS_SCOPE_P
该断言用来表示实体是否在一个class作用域中被声明。

@item DECL_FUNCTION_SCOPE_P
该断言用来表示实体是否在一个函数体中被声明。

@end ftable

各种类型的声明：
@table @code
@item LABEL_DECL
这些节点用于表示函数体内的标号。更多信息，可以参考@ref{函数}。这些节点只出现在块作用域（block scope）。

@item CONST_DECL
这些节点用于表示枚举常量。常量的值由@code{DECL_INITIAL}给出，为一个@code{INTEGER_CST}，并且和@code{CONST_DECL}的@code{TREE_TYPE}具有相同的类型，即@code{ENUMERAL_TYPE}。 

@item RESULT_DECL
这些节点表示函数的返回值。当@code{RESULT_DECL}被赋予一个值的时候，这表明该值将被函数通过按位拷贝的方式返回。就像对于@code{VAR_DECL}一样，你可以在@code{RESULT_DECL}上使用@code{DECL_SIZE}和@code{DECL_ALIGN}。

@item TYPE_DECL
这些节点表示@code{typedef}声明。@code{TREE_TYPE}为被声明的类型，其名字由@code{DECL_NAME}给出。有些情况下，没有相关联的名字。

@item VAR_DECL
这些节点表示具有命名空间或者块作用域的变量，以及静态数据成员。@code{DECL_SIZE}和@code{DECL_ALIGN}，类似于@code{TYPE_SIZE}和@code{TYPE_ALIGN}。对于声明，你应该总是使用@code{DECL_SIZE}和@code{DECL_ALIGN}，而不是由@code{TREE_TYPE}给定的@code{TYPE_SIZE}和@code{TYPE_ALIGN}，因为，可能会对变量应用了特定的属性，使其具有特定的大小和对齐方式。你可以使用断言@code{DECL_THIS_STATIC}或@code{DECL_THIS_EXTERN}来测试是否使用了存储类别说明符@code{static}或@code{extern}来声明一个变量。

如果该变量被初始化（并需要一个构造者），则@code{DECL_INITIAL}将为初始化者的表达式。初始化者将被求值，并按位复制到变量中。如果@code{DECL_INITIAL}为@code{error_mark_node}，则表明存在一个初始化者，只不过它由之后代码中的显式的语句给出；这将不需要进行按位复制。

GCC提供了一个扩展，允许自动变量或者全局变量，被放到特定的寄存器中。如果@code{DECL_REGISTER}存放了@code{VAR_DECL}，并且@code{DECL_ASSEMBLER_NAME}不等于@code{DECL_NAME}，则@code{VAR_DECL}是使用了该扩展。这种情况下，@code{DECL_ASSEMBLER_NAME}为存放变量的寄存器的名字。

@item PARM_DECL
用于表示一个函数的参数。这些节点可以作为@code{VAR_DECL}节点来看待。这些节点只出现在@code{FUNCTION_DECL}的@code{DECL_ARGUMENTS}中。

@code{PARM_DECL}的@code{DECL_ARG_TYPE}为，当值传给函数时实际使用的类型。其可以为一个比参数的@code{TREE_TYPE}更宽的类型；例如，原始类型可能为@code{short}，而@code{DECL_ARG_TYPE}为@code{int}。

@item FIELD_DECL
这些节点表示非静态数据成员。@code{DECL_SIZE}和@code{DECL_ALIGN}的行为，跟@code{VAR_DECL}节点的一样。在父记录（parent record）中的域的位置，由三个属性组合指定。@code{DECL_FIELD_OFFSET}为按字节计数的位置，

如果DECL_C_BIT_FIELD有效，则该域是一个位域。在位域中，DECL_BIT_FIELD_TYPE还包含了原始指定的类型，而DECL_TYPE可能是根据位域的大小，修改后具有更少精度的类型。

@item NAMESPACE_DECL
@xref{命名空间}.

@item TEMPLATE_DECL
这些节点用于表示类，函数和变量（静态数据成员）模板。@code{DECL_TEMPLATE_SPECIALIZATIONS}为一个@code{TREE_LIST}。列表中每个节点的@code{TREE_VALUE}为一个@code{TEMPLATE_DECL}或者@code{FUNCTION_DECL}，表示该模板的特列（包括实例）。后端可以安全的忽略@code{TEMPLATE_DECL}，但是应该检查特例列表中的@code{FUNCTION_DECL}，就像是普通的@code{FUNCTION_DECL}节点一样。

对于类模板，@code{DECL_TEMPLATE_INSTANTIATIONS}列表包含了实例。每个节点的@code{TREE_VALUE}为类的一个实例。@code{DECL_TEMPLATE_SPECIALIZATIONS}包含了类的部分特例。

@item USING_DECL
后端可以安全的忽略掉这些节点。

@end table

@node 内部结构
@subsection 内部结构

@code{DECL}节点在内部被表示为层次结构体。

@menu
* 目前的结构层次::     目前DECL节点的结构层次。
* 添加新的DECL节点类型:: 如何给前端添加一个新的DECL节点。
@end menu

@node 目前的结构层次
@subsubsection 目前的结构层次

@table @code

@item struct tree_decl_minimal
这是用于继承的最小结构体，从而使得@code{DECL}宏更加通用。
所包含的域为一个唯一的ID，源位置，上下文和名字。 

@item struct tree_decl_common
该结构体继承于@code{struct tree_decl_minimal}。
包含了大多@code{DECL}节点需要的域，像存储对齐信息，机器模式，大小和属性的域。 

@item struct tree_field_decl
该结构体继承于@code{struct tree_decl_common}。用于表示@code{FIELD_DECL}。

@item struct tree_label_decl
该结构体继承于@code{struct tree_decl_common}。用于表示@code{LABEL_DECL}。 

@item struct tree_translation_unit_decl
该结构体继承于@code{struct tree_decl_common}。
用于表示@code{TRANSLATION_UNIT_DECL}。 

@item struct tree_decl_with_rtl
该结构体继承于@code{struct tree_decl_common}。
包含了一个存储与@code{DECL}节点相关的低层次RTL。

@item struct tree_result_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{RESULT_DECL}。 

@item struct tree_const_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{CONST_DECL}。 

@item struct tree_parm_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{PARM_DECL}。 

@item struct tree_decl_with_vis
该结构体继承于@code{struct tree_decl_with_rtl}。
包含了存储可视性信息所需要的域，还有一个section名和汇编名。 

@item struct tree_var_decl
该结构体继承于@code{struct tree_decl_with_vis}。
用于表示@code{VAR_DECL}。

@item struct tree_function_decl
该结构体继承于@code{struct tree_decl_with_vis}。
用于表示@code{FUNCTION_DECL}。
@end table

@node 添加新的DECL节点类型
@subsubsection 添加新的DECL节点类型

增加一个新的@code{DECL}树包含下列步骤

@table @asis

@item 为@code{DECL}节点增加一个新的树代码
对于语言特定的@code{DECL}节点，在每个前端目录下有一个@file{.def}文件，用来添加树代码。对于属于中端一部分的@code{DECL}节点，代码应该添加到@file{tree.def}中。

@item 为@code{DECL}节点创建一个新的结构体类型
这些结构体应该继承于现有的层次结构体，方法是使用该结构体作为第一个成员。

@smallexample
struct tree_foo_decl
@{
   struct tree_decl_with_vis common;
@}
@end smallexample

将会创建一个名为@code{tree_foo_decl}的结构体，继承于@code{struct tree_decl_with_vis}。

对于语言特定的@code{DECL}节点，这个新的结构体类型应该放在合适的@file{.h}文件中。对于属于中端一部分的@code{DECL}节点，结构体类型应该在@file{tree.h}中。

@item 向树结构枚举中增加一个节点成员
出于垃圾搜集和动态检查的目的，每个@code{DECL}节点结构体类型需要具有一个唯一的枚举值用来指定它。对于语言特定的@code{DECL}节点，该新的枚举值应该在合适的.def文中。对于属于中端的@code{DECL}节点，枚举值在@file{treestruct.def}中指定。

@item 更新@code{union tree_node}
为了使得新的结构体类型可用，其必须被添加到@code{union tree_node}中。对于语言特定的@code{DECL}节点，一个新的项应该被添加到合适的@file{.h}文件中，形式如下 

@smallexample
  struct tree_foo_decl GTY ((tag ("TS_VAR_DECL"))) foo_decl;
@end smallexample

对于属于中端的@code{DECL}节点，额外的成员直接放在@file{tree.h}里的@code{union tree_node}中。
For @code{DECL} nodes that are part of the middle-end, the additional

@item 更新动态检查信息
为了能够检查访问@code{union tree_node}的一个命名部分是否合法，以及特定的@code{DECL}节点是否包含了枚举的@code{DECL}节点结构体，我们使用了一个简单的查找表。该查找表需要随着树结构层次一起更新，否则用于检查和包含的宏将会失败。

对于语言特定的@code{DECL}节点，它们是在合适的@file{.c}文件中的@code{init_ts}函数，用于初始化查找表。为新的@code{DECL}节点建立表格的代码应该添加到这里。对于每个表示继承层次的成员的@code{DECL}树代码和枚举值，如果树代码（直接或间接）继承于那个成员，则表应该包含1。因此，一个源于@code{struct decl_with_rtl}的，枚举值为@code{TS_FOO_DECL}的@code{FOO_DECL}节点，会使用下列方式来建立。

@smallexample
tree_contains_struct[FOO_DECL][TS_FOO_DECL] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_WRTL] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_COMMON] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_MINIMAL] = 1;
@end smallexample

对于属于中端的@code{DECL}节点，建表代码在@file{tree.c}中。

@item 增加访问任何新的域和标识的宏 

每个增加的域或标识，都应有一个宏用来访问它，并且执行适当的检查以保证访问的是正确类型的@code{DECL}。

这些宏通常采用下面的形式

@smallexample
#define FOO_DECL_FIELDNAME(NODE) FOO_DECL_CHECK(NODE)->foo_decl.fieldname
@end smallexample
但是，如果结构体只是更多结构体的一个基类，有时会使用下面的形式
@smallexample
#define BASE_STRUCT_CHECK(T) CONTAINS_STRUCT_CHECK(T, TS_BASE_STRUCT)
#define BASE_STRUCT_FIELDNAME(NODE) \
   (BASE_STRUCT_CHECK(NODE)->base_struct.fieldname
@end smallexample

@end table


@c ---------------------------------------------------------------------
@c Functions
@c ---------------------------------------------------------------------

@node 函数
@section 函数
@cindex function
@tindex FUNCTION_DECL
@tindex OVERLOAD
@findex OVL_CURRENT
@findex OVL_NEXT

函数由@code{FUNCTION_DECL}节点表示。
重载函数集有时通过一个@code{OVERLOAD}节点来表示。

@code{OVERLOAD}节点不是一个声明。
所以没有@samp{DECL_}宏用于@code{OVERLOAD}。
@code{OVERLOAD}节点类似于一个@code{TREE_LIST}。
使用@code{OVL_CURRENT}来获得@code{OVERLOAD}节点关联的函数；
使用@code{OVL_NEXT}来获得重载函数列表中下一个@code{OVERLOAD}节点。
宏@code{OVL_CURRENT}和@code{OVL_NEXT}实际上是多态的；
你可以用它们工作于@code{FUNCTION_DECL}节点上，就像在重载上一样。
在@code{FUNCTION_DECL}的情况下，@code{OVL_CURRENT}将总是返回函数本身，
@code{OVL_NEXT}将总是为@code{NULL_TREE}。

要确定函数的作用域，可以使用@code{DECL_CONTEXT}宏。
该宏将返回函数作为其成员的类（或者@code{RECORD_TYPE}或者@code{UNION_TYPE}）
或命名空间（@code{NAMESPACE_DECL}）。对于虚函数，
该宏返回函数被实际定义的类，而不是其声明所在的基类。

如果友函数定义在类的作用域里，
宏@code{DECL_FRIEND_CONTEXT}可以用来判定其定义所在的类。例如，在

@smallexample
class C @{ friend void f() @{@} @};
@end smallexample
@noindent
中，@code{f}的@code{DECL_CONTEXT}将为@code{global_namespace}，
而@code{C}的@code{DECL_FRIEND_CONTEXT}将为@code{RECORD_TYPE}。

在C中，函数的@code{DECL_CONTEXT}可能为另一个函数。
这表示正在使用GNU嵌套函数扩展功能。关于嵌套函数语法的详细内容，
参见GCC手册。嵌套函数可以引用其所包含的函数的局部变量。
这样的引用没有在树结构体里被显示的标记。
如果被引用@code{VAR_DECL}的@code{DECL_CONTEXT}与当前被处理的函数不相同，
并且@code{DECL_EXTERNAL}和@code{DECL_STATIC}都没有持有内容，
则该引用是针对包含的函数的局部变量，后端必须采取合适的行为。

@menu
* 函数基础::   函数名，连接等等。
* 函数体::     组成函数体的语句。
@end menu

@c ---------------------------------------------------------------------
@c Function Basics
@c ---------------------------------------------------------------------

@node 函数基础
@subsection 函数基础
@cindex constructor
@cindex destructor
@cindex copy constructor
@cindex assignment operator
@cindex linkage
@findex DECL_NAME
@findex DECL_ASSEMBLER_NAME
@findex TREE_PUBLIC
@findex DECL_LINKONCE_P
@findex DECL_FUNCTION_MEMBER_P
@findex DECL_CONSTRUCTOR_P
@findex DECL_DESTRUCTOR_P
@findex DECL_OVERLOADED_OPERATOR_P
@findex DECL_CONV_FN_P
@findex DECL_ARTIFICIAL
@findex DECL_GLOBAL_CTOR_P
@findex DECL_GLOBAL_DTOR_P
@findex GLOBAL_INIT_PRIORITY
@findex DECL_FUNCTION_SPECIFIC_TARGET
@findex DECL_FUNCTION_SPECIFIC_OPTIMIZATION

下列宏和函数能够用于@code{FUNCTION_DECL}:
@ftable @code
@item DECL_MAIN_P
该断言判断一个函数是否为程序的入口点@code{::code}。 

@item DECL_NAME
该宏返回函数未限定的名字，为一个@code{IDENTIFIER_NODE}。
对于一个函数模版的实例，@code{DECL_NAME}为模版的未限定名字，
而不是类似@code{f<int>}的东西。当用在编译器隐式生成的构造函数，
析构函数，重载操作符，或者类型转换符，或者任何函数时，
@code{DECL_NAME}的值未定义。关于可以用来区分这些情况的宏，参见下面。 

@item DECL_ASSEMBLER_NAME
该宏返回函数的mangled名字，也是一个@code{IDENTIFIER_NODE}。该名字没有包含前导的下划线。mangled名字在所有平台上按照相同的方式来计算；如果在特定的平台上，需要对目标文件格式进行特殊的处理，则后端需要负责执行那些修改。（当然，后端不应该修改@code{DECL_ASSEMBLER_NAME}）

使用@code{DECL_ASSEMBLER_NAME}将使得额外的内存被分配（用于实体的mangled名字），所以其应该只当生成汇编代码时被使用。其不应该在优化器中被使用，用于确定两个声明是否相同，即使一些现有的优化器确实采用了这种方式。这些使用将随着时间被移除。

@item DECL_EXTERNAL
该断言判断函数是否未定义。 

@item TREE_PUBLIC
该断言判断函数是否具有外部连接。 

@item DECL_LOCAL_FUNCTION_P
该断言判断函数是否声明在块作用域中，即使具有全局作用域。

@item DECL_ANTICIPATED
该断言判断函数是否为built-in函数，并且函数原形没有显示声明。 

@item DECL_EXTERN_C_FUNCTION_P
该断言判断函数是否声明为`@code{extern "C"}'函数。 

@item DECL_LINKONCE_P
该宏用来判断该函数是否会在不同的转换单元产生多个副本。
合并不同副本是连接器的责任。
模版实例是使用@code{DECL_LINKONCE_P}最常见的例子。
G++会在需要它们的所有转换单元里实例化模版，
然后依赖连接器去移除重复的实例。 

FIXME: 该宏还没有实现。

@item DECL_FUNCTION_MEMBER_P
该宏用来判断函数是否为一个类的成员，而不是命名空间的成员。 

@item DECL_STATIC_FUNCTION_P
该断言用来判断函数是否为一个静态成员函数。 

@item DECL_NONSTATIC_MEMBER_FUNCTION_P
该宏用来判断是否为一个非静态成员函数。 

@item DECL_CONST_MEMFUNC_P
该断言用来判断是否为@code{const}成员函数。 

@item DECL_VOLATILE_MEMFUNC_P
该断言用来判断是否为@code{volatile}成员函数。 

@item DECL_CONSTRUCTOR_P
该宏用来判断函数是否为一个构造函数。 

@item DECL_NONCONVERTING_P
该断言用来判断构造函数是否为一个非转换构造函数。 

@item DECL_COMPLETE_CONSTRUCTOR_P
该断言用来判断函数是否为完全类型的对象的构造函数。 

@item DECL_BASE_CONSTRUCTOR_P
该断言用来判断函数是否为一个基类的子对象的构造函数。 

@item DECL_COPY_CONSTRUCTOR_P
该断言用来判断函数是否为一个复制构造函数。 

@item DECL_DESTRUCTOR_P
该宏用来判断函数是否为一个析构函数。 

@item DECL_COMPLETE_DESTRUCTOR_P
该断言用来判断函数是否为一个完全类型的对象的析构函数。 

@item DECL_OVERLOADED_OPERATOR_P
该宏用来判断函数是否为一个重载操作符。 

@item DECL_CONV_FN_P
该宏用来判断函数是否为一个类型转换操作符。 

@item DECL_GLOBAL_CTOR_P
该断言用来判断函数是否为一个文件作用域的初始化函数。 

@item DECL_GLOBAL_DTOR_P
该断言用来判断函数是否为一个文件作用域的结束化函数。 

@item DECL_THUNK_P
该断言用来判断函数是否为一个thunk。

这些函数表示stub代码，用来调整@code{this}指针，然后跳转到另一个函数中。当从被跳转的函数中返回时，控制被直接传给调用者，不需要返回到thunk中。thunk的第一个参数总是为@code{this}指针；thunk应该将该值加上@code{THUNK_DELTA}。（@code{THUNK_DELTA}是一个@code{int}，而不是@code{INTEGER_CST}。）

然后，如果@code{THUNK_VCALL_OFFSET}（一个@code{INTEGER_CST}）是非零的，则被调整的@code{this}必须再次被调整。下面的伪代码给出了完整的计算：

@smallexample
this += THUNK_DELTA
if (THUNK_VCALL_OFFSET)
  this += (*((ptrdiff_t **) this))[THUNK_VCALL_OFFSET]
@end smallexample

最终，thunk应该跳转到由@code{DECL_INITIAL}给出的位置；这将总是一个函数地址的表达式。

@item DECL_NON_THUNK_FUNCTION_P
该断言用来判断函数@emph{不是}一个thunk函数。 

@item GLOBAL_INIT_PRIORITY
如果@code{DECL_GLOBAL_CTOR_P}或者@code{DECL_GLOBAL_DTOR_P}有效，则该宏给出了函数的初始优先级。连接器将设法安排@code{DECL_GLOBAL_CTOR_P}所保存的所有的函数在递增的顺序下运行，在@code{main}被调用之前。当程序退出时，@code{DECL_GLOBAL_DTOR_P}所保存的所有函数按照相反的顺序执行。

@item DECL_ARTIFICIAL
该宏保存了函数是否由编译器隐式的生成，而不是被显式的生成。
除了隐式的生成的类成员函数以外，该宏还保存了创建的特定函数，
用来实现静态初始化和析构，来计算运行时信息等等。 

@item DECL_ARGUMENTS
该宏返回函数第一个参数的@code{PARM_DECL}。
后续的@code{PARM_DECL}节点可以通过@code{TREE_CHAIN}来获得。

@item DECL_RESULT
该函数返回函数的@code{RESULT_DECL}。

@item TREE_TYPE
该宏返回函数的@code{FUNCTION_TYPE}或@code{METHOD_TYPE}。

@item TYPE_RAISES_EXCEPTIONS
该宏返回（成员）函数可以引起的异常列表。返回的列表，如果不是@code{NULL}，则为@code{TREE_VALUE}代表一个类型的节点组成。 

@item TYPE_NOTHROW_P
该断言用来判断是否是使用`@code{()}'形式来指定异常的参数。 

@item DECL_ARRAY_DELETE_OPERATOR_P
该断言用来判断函数是否为一个重载的@code{operator delete[]}。

@item DECL_FUNCTION_SPECIFIC_TARGET
该宏返回一个tree节点，存放了用于编译该特定函数的目标机选项，或者为@code{NULL_TREE}，如果是使用命令行中指定的目标机选项来编译该函数。

@item DECL_FUNCTION_SPECIFIC_OPTIMIZATION
该宏返回一个tree节点，存放了用于编译该特定函数的优化选项，或者为@code{NULL_TREE}，如果是使用命令行中指定的优化选项来编译该函数。

@end ftable

@c ---------------------------------------------------------------------
@c Function Bodies
@c ---------------------------------------------------------------------

@node 函数体
@subsection 函数体
@cindex function body
@cindex statements
@tindex BREAK_STMT
@tindex CLEANUP_STMT
@findex CLEANUP_DECL
@findex CLEANUP_EXPR
@tindex CONTINUE_STMT
@tindex DECL_STMT
@findex DECL_STMT_DECL
@tindex DO_STMT
@findex DO_BODY
@findex DO_COND
@tindex EMPTY_CLASS_EXPR
@tindex EXPR_STMT
@findex EXPR_STMT_EXPR
@tindex FOR_STMT
@findex FOR_INIT_STMT
@findex FOR_COND
@findex FOR_EXPR
@findex FOR_BODY
@tindex HANDLER
@tindex IF_STMT
@findex IF_COND
@findex THEN_CLAUSE
@findex ELSE_CLAUSE
@tindex RETURN_STMT
@findex RETURN_EXPR
@tindex SUBOBJECT
@findex SUBOBJECT_CLEANUP
@tindex SWITCH_STMT
@findex SWITCH_COND
@findex SWITCH_BODY
@tindex TRY_BLOCK
@findex TRY_STMTS
@findex TRY_HANDLERS
@findex HANDLER_PARMS
@findex HANDLER_BODY
@findex USING_STMT
@tindex WHILE_STMT
@findex WHILE_BODY
@findex WHILE_COND

在当前转换单元中定义的函数将会有一个非@code{NULL}的@code{DECL_INITIAL}。
但是，后端不应该使用@code{DECL_INITIAL}给出的该特定值。

宏@code{DECL_SAVED_TREE}将会给出完整的函数体。

@subsubsection 语句

C和C++前端，使用了对应于所有源级的语句构造的树节点。
这些都列举在这里，并附上能够用来获得它们的信息的各种宏的列表。
有一些宏能用于所有的语句：

@ftable @code
@item STMT_IS_FULL_EXPR_P
在C++里，语句通常构成“充分表达式（full expressions）”；
在语句中创建的临时事物会在声明完成时被销毁。
然而，G++有时通过语句来表示表达式；
这些语句将不会设置@code{STMT_IS_FULL_EXPR_P}。
在这样的语句中创建的临时事物将会在最内层设置了
@code{STMT_IS_FULL_EXPR_P}的语句退出时被销毁。
@end ftable

这里有一个各种语句节点的列表，以及访问它们的宏。
该文档描述了在非模板函数（包括模板函数的实例）中这些节点的用法。
在模板函数里，使用相同的节点，但是有时方法略有不同。

许多语句具有子语句。例如，一个@code{while}循环将会有一个循环体，
其本身也是一个语句。如果子语句是@code{NULL_TREE}，
则被认为相当于一个@code{;}组成的语句，即一个表达式语句，其中表达式为空。
一个子语句实际上可以为一个语句列表，通过它们的@code{TREE_CHAIN}连接一起。
所以，你应该总是通过循环所有的子语句来处理语句树，像这样：

@smallexample
void process_stmt (stmt)
     tree stmt;
@{
  while (stmt)
    @{
      switch (TREE_CODE (stmt))
        @{
        case IF_STMT:
          process_stmt (THEN_CLAUSE (stmt));
          /* @r{More processing here.}  */
          break;

        @dots{}
        @}

      stmt = TREE_CHAIN (stmt);
    @}
@}
@end smallexample
换句话说，虽然C++中@code{if}语句的@code{then}子句可以只是一个语句，
但中间表示有时会使用多个语句连接在一起。

@table @code
@item ASM_EXPR
用来表示一条内联的汇编语句。一条内联汇编语句形如： 
@smallexample
asm ("mov x, y");
@end smallexample
@code{ASM_STRING}宏将会为@code{"mov x, y"}返回一个@code{STRING_CST}节点。
如果原始的语句使用了扩展汇编语法，则@code{ASM_OUTPUTS}, 
@code{ASM_INPUTS}和@code{ASM_CLOBBERS}为用@code{STRING_CST}表示的语句的输出，
输入和clobber。扩展汇编语法形如：

@smallexample
asm ("fsinx %1,%0" : "=f" (result) : "f" (angle));
@end smallexample
第一个字符串是@code{ASM_STRING}，包含指令模板。
接下来的两个字符串分别是输出和输入。该语句没有clobbers。
这个例子表明，普通的汇编语句只是扩展汇编语句的一个特例；
它们没有限定符，输出，输入或者clobbers。
所有的字符串都为@code{NUL}结尾，并且不包含嵌入的@code{NUL}字符。

如果汇编语句被声明为@code{volatile}，或者语句不是扩展汇编语句，
因此是一个隐式的@code{volatile}，
则断言@code{ASM_VOLATILE_P}将会保存@code{ASM_EXPR}。

@item BREAK_STMT
用来表示一条@code{break}语句。没有额外的域。 

@item CASE_LABEL_EXPR
用来表示一个@code{case}标号，@code{case}标号的范围或者一个@code{default}标号。
如果@code{CASE_LOW}是@code{NULL_TREE}，则为一个@code{default}标号。
否则，如果@code{CASE_HIGH}是@code{NULL_TREE}，则为一个普通的@code{case}标号。
这种情况下，@code{CASE_LOW}是一个表达式，给出了标号的值。
@code{CASE_LOW}和@code{CASE_HIGH}都是@code{INTEGER_CST}节点。
这些值跟在@code{switch}语句中的条件表达式具有相同的类型。 

否则，如果同时定义了@code{CASE_LOW}和@code{CASE_HIGH}，则语句为一个@code{case}标号的范围。这样的语句源于允许用户使用如下形式的扩展：

@smallexample
case 2 ... 5:
@end smallexample
第一个值为@code{CASE_LOW}，第二个为@code{CASE_HIGH}。

@item CLEANUP_STMT
用来表示在封闭作用域的出口上执行的动作。
通常，这些动作是为局部对象调用析构函数，但是后端不能依靠这个事实。
如果这些节点确实是表示了这样的析构函数，
@code{CLEANUP_DECL}将为销毁的@code{VAR_DECL}。
否则@code{CLEANUP_DECL}为@code{NULL_TREE}。
无论哪种情况，@code{CLEANUP_EXPR}都是要被执行的表达式。
清除工作在作用域的出口被执行，
并且按照所遇到的@code{CLEANUP_STMT}的相反顺序进行。

@item CONTINUE_STMT
用来表示一条@code{continue}语句。没有额外的域。 

@item CTOR_STMT
用于标记构建函数体的起始（@code{CTOR_BEGIN_P}）或结尾（@code{CTOR_END_P}）。关于如何使用这些节点的更多信息，参见@code{SUBOBJECT}。 

@item DECL_STMT
用来表示一个局部声明。宏@code{DECL_STMT_DECL}可以用来获得整个声明。
该声明可以为一个@code{LABEL_DECL}，表示声明了一个局部标号。
（作为扩展，GCC允许声明具有作用域的标号。）
在C中，该声明可以为一个@code{FUNCTION_DECL}，表示使用GCC嵌套函数扩展。
更多信息，参见 @ref{函数}。

@item DO_STMT
用来表示@code{do}循环。循环体由@code{DO_BODY}给出，
终止条件由@code{DO_COND}给出。@code{do}语句的条件总是一个表达式。

@item EMPTY_CLASS_EXPR
用来表示类的临时对象。（所有这样的对象都是可互换的。）
@code{TREE_TYPE}表示对象的类型。 

@item EXPR_STMT
用来表示表达式语句。使用@code{EXPR_STMT_EXPR}来获得表达式。 

@item FOR_STMT
用来表示一条@code{for}语句。@code{FOR_INIT_STMT}是循环的初始语句。
@code{FOR_COND}是终止条件。
@code{FOR_INIT_STMT}是在每次循环迭代@code{FOR_COND}之前执行的表达式，
该表达式常常是增加计数器。循环体由@code{FOR_BODY}给出。
注意@code{FOR_INIT_STMT}和@code{FOR_BODY}返回语句，
而@code{FOR_COND}和@code{FOR_EXPR}返回表达式。

@item GOTO_EXPR
用来表示一条@code{goto}语句。
@code{GOTO_DESTINATION}通常为一个@code{LABEL_DECL}。
然而，如果使用了扩展的“computed goto”，将为一个随机表达式用来指示目的地。
该表达式总是具有一个指针类型。 

@item HANDLER
用来表示C++ @code{catch}块。@code{HANDLER_TYPE}是由该处理者捕捉的异常类型。
如果该处理者是针对所有类型的，则等于（指针等于）@code{NULL}。
@code{HANDLER_PARMS}是@code{catch}参数，是一个@code{DECL_STMT}。
@code{HANDLER_BODY}是块本身的代码。 

@item IF_STMT
用来表示一条@code{if}语句。@code{IF_COND}是表达式。
如果条件是一个@code{TREE_LIST}，
则@code{TREE_PURPOSE}是一条语句（通常为 @code{DECL_STMT}）。
每次评估条件的时候，都要执行该语句。
然后，@code{TREE_VALUE}应该作为条件表达式本身来使用。
该表示用来处理C++代码，如： 

@smallexample
if (int i = 7) @dots{}
@end smallexample

其中，在条件中声明了一个（或多个）新的局部变量。

@item LABEL_EXPR
用来表示一个标号。
可以通过@code{LABEL_EXPR_LABEL}宏获得该语句声明的@code{LABEL_DECL}。
可以通过@code{LABEL_DECL}的@code{DECL_NAME}获得给出的标号名字。

@item RETURN_STMT
用来表示一条@code{return}语句。@code{RETURN_EXPR}是返回的表达式，
其将会返回@code{NULL_TREE}，如果语句只是 
@smallexample
return;
@end smallexample

@item SUBOBJECT
在构造函数中，这些节点用来标记在某一点子对象被完全构造。如果，这一点之后，在遇到设置了@code{CTOR_END_P}的@code{CTOR_STMT}之前，有异常抛出，则必须执行@code{SUBOBJECT_CLEANUP}。清除工作必须按照它们出现的顺序反向执行。 

@item SWITCH_STMT
用来表示一个@code{switch}语句。
@code{SWITCH_STMT_COND}是发生@code{switch}的表达式。
更多关于条件表示的信息，参见@code{IF_STMT}文档。
@code{SWITCH_STMT_BODY}是@code{switch}语句主体。
@code{SWITCH_STMT_TYPE}是源代码中给出的@code{switch}表达式的，
在任何编译器转换之前的原始类型。

@item TRY_BLOCK
用来表示一个@code{try}块。@code{try}块的主体由@code{TRY_STMTS}给出。
每个@code{catch}块都是一个@code{HANDLER}节点。
第一个@code{handler}由 @code{TRY_HANDLERS}给出。
后续的@code{handlers}可以通过@code{TREE_CHAIN}获得。
@code{handler}的主体由@code{HANDLER_BODY}给出。

如果@code{CLEANUP_P}持有@code{TRY_BLOCK}，
则@code{TRY_HANDLERS}将不是一个@code{HANDLER}节点。
相反的，其将会是一个表达式，并且如果在@code{try}块中抛出异常时则被执行。
其必须在执行完那些代码之后再重新抛出异常。
并且，如果当表达式正在执行的时候，如果有异常抛出，则必须终止。

@item USING_STMT
用来表示@code{using}指示符。命名空间为一个NAMESPACE_DECL，
由@code{USING_STMT_NAMESPACE}给出。该节点在模板函数内部需要，
用来在实例化时实现@code{using}指示符。 

@item WHILE_STMT
用来表示一个@code{while}循环。@code{WHILE_COND}是循环的终止条件。
关于用来表示条件的更多信息，参见@code{IF_STMT}的文档。
 
@code{WHILE_BODY}是循环体。 
@end table

@c ---------------------------------------------------------------------
@c Attributes
@c ---------------------------------------------------------------------
@node 属性
@section 树中的属性
@cindex attributes

使用关键字@code{__attribute__}指定的属性，在内部作为@code{TREE_LIST}来表示。
@code{TREE_PURPOSE} ，作为一个@code{IDENTIFIER_NODE}，是属性的名字。
如果有参数的话，@code{TREE_VALUE}是一个属性参数的@code{TREE_LIST}，
或者在没有参数时，为@code{NULL_TREE}。
参数作为列表中的@code{TREE_VALUE}后继项存储，并且可以为标识符或者表达式。
属性的@code{TREE_CHAIN}是在属性列表中应用到同一声明或类型的下一个属性，
或者为@code{NULL_TREE}如果列表中没有更多的属性。

属性可以附加到声明和类型上；这些属性可以通过下列宏来访问。
所有的属性都通过这种方式存储，并且许多还对声明和类型，
或者其它内部编译器数据结构体，引起其它的变化。

@deftypefn {Tree Macro} tree DECL_ATTRIBUTES (tree @var{decl})
该宏返回声明@var{decl}上的属性。
@end deftypefn

@deftypefn {Tree Macro} tree TYPE_ATTRIBUTES (tree @var{type})
该宏返回类型@var{type}上的属性。
@end deftypefn

@c ---------------------------------------------------------------------
@c Expressions
@c ---------------------------------------------------------------------

@node 表达式tree
@section 表达式
@cindex expression
@findex TREE_TYPE
@findex TREE_OPERAND
@tindex INTEGER_CST
@findex TREE_INT_CST_HIGH
@findex TREE_INT_CST_LOW
@findex tree_int_cst_lt
@findex tree_int_cst_equal
@tindex REAL_CST
@tindex FIXED_CST
@tindex COMPLEX_CST
@tindex VECTOR_CST
@tindex STRING_CST
@findex TREE_STRING_LENGTH
@findex TREE_STRING_POINTER
@tindex PTRMEM_CST
@findex PTRMEM_CST_CLASS
@findex PTRMEM_CST_MEMBER
@tindex VAR_DECL
@tindex NEGATE_EXPR
@tindex ABS_EXPR
@tindex BIT_NOT_EXPR
@tindex TRUTH_NOT_EXPR
@tindex PREDECREMENT_EXPR
@tindex PREINCREMENT_EXPR
@tindex POSTDECREMENT_EXPR
@tindex POSTINCREMENT_EXPR
@tindex ADDR_EXPR
@tindex INDIRECT_REF
@tindex FIX_TRUNC_EXPR
@tindex FLOAT_EXPR
@tindex COMPLEX_EXPR
@tindex CONJ_EXPR
@tindex REALPART_EXPR
@tindex IMAGPART_EXPR
@tindex NON_LVALUE_EXPR
@tindex NOP_EXPR
@tindex CONVERT_EXPR
@tindex FIXED_CONVERT_EXPR
@tindex THROW_EXPR
@tindex LSHIFT_EXPR
@tindex RSHIFT_EXPR
@tindex BIT_IOR_EXPR
@tindex BIT_XOR_EXPR
@tindex BIT_AND_EXPR
@tindex TRUTH_ANDIF_EXPR
@tindex TRUTH_ORIF_EXPR
@tindex TRUTH_AND_EXPR
@tindex TRUTH_OR_EXPR
@tindex TRUTH_XOR_EXPR
@tindex POINTER_PLUS_EXPR
@tindex PLUS_EXPR
@tindex MINUS_EXPR
@tindex MULT_EXPR
@tindex RDIV_EXPR
@tindex TRUNC_DIV_EXPR
@tindex FLOOR_DIV_EXPR
@tindex CEIL_DIV_EXPR
@tindex ROUND_DIV_EXPR
@tindex TRUNC_MOD_EXPR
@tindex FLOOR_MOD_EXPR
@tindex CEIL_MOD_EXPR
@tindex ROUND_MOD_EXPR
@tindex EXACT_DIV_EXPR
@tindex ARRAY_REF
@tindex ARRAY_RANGE_REF
@tindex TARGET_MEM_REF
@tindex LT_EXPR
@tindex LE_EXPR
@tindex GT_EXPR
@tindex GE_EXPR
@tindex EQ_EXPR
@tindex NE_EXPR
@tindex ORDERED_EXPR
@tindex UNORDERED_EXPR
@tindex UNLT_EXPR
@tindex UNLE_EXPR
@tindex UNGT_EXPR
@tindex UNGE_EXPR
@tindex UNEQ_EXPR
@tindex LTGT_EXPR
@tindex MODIFY_EXPR
@tindex INIT_EXPR
@tindex COMPONENT_REF
@tindex COMPOUND_EXPR
@tindex COND_EXPR
@tindex CALL_EXPR
@tindex STMT_EXPR
@tindex BIND_EXPR
@tindex LOOP_EXPR
@tindex EXIT_EXPR
@tindex CLEANUP_POINT_EXPR
@tindex CONSTRUCTOR
@tindex COMPOUND_LITERAL_EXPR
@tindex SAVE_EXPR
@tindex TARGET_EXPR
@tindex AGGR_INIT_EXPR
@tindex VA_ARG_EXPR
@tindex CHANGE_DYNAMIC_TYPE_EXPR
@tindex OMP_PARALLEL
@tindex OMP_FOR
@tindex OMP_SECTIONS
@tindex OMP_SINGLE
@tindex OMP_SECTION
@tindex OMP_MASTER
@tindex OMP_ORDERED
@tindex OMP_CRITICAL
@tindex OMP_RETURN
@tindex OMP_CONTINUE
@tindex OMP_ATOMIC
@tindex OMP_CLAUSE
@tindex VEC_LSHIFT_EXPR
@tindex VEC_RSHIFT_EXPR
@tindex VEC_WIDEN_MULT_HI_EXPR
@tindex VEC_WIDEN_MULT_LO_EXPR
@tindex VEC_UNPACK_HI_EXPR
@tindex VEC_UNPACK_LO_EXPR
@tindex VEC_UNPACK_FLOAT_HI_EXPR
@tindex VEC_UNPACK_FLOAT_LO_EXPR
@tindex VEC_PACK_TRUNC_EXPR
@tindex VEC_PACK_SAT_EXPR
@tindex VEC_PACK_FIX_TRUNC_EXPR
@tindex VEC_EXTRACT_EVEN_EXPR 
@tindex VEC_EXTRACT_ODD_EXPR
@tindex VEC_INTERLEAVE_HIGH_EXPR
@tindex VEC_INTERLEAVE_LOW_EXPR

表达式的内部表示大多都很简单明了。但是，也有一些事实必须牢记。
尤其是，表达式“tree”实际上是一个有向无环图。（例如，
整个源程序中可能会有许多对常整数0的引用；这些将会由同一个表达式节点来表示。）
当然，你不要以此就认为某些种类的节点是共享的，也不要认为某些种类的节点没有被共享。

下列宏可以用于所有表达式节点：

@ftable @code
@item TREE_TYPE
返回表达式的类型。该值可能不是与原始程序中给出的表达式相同精度的类型。 
@end ftable

在下文中，有些节点可能总是期望具有@code{bool}类型，
但是被记载为具有整形或bool型。将来的某个时刻，
C前端可能也会使用该相同的中间表示，那时，这些节点当然会具有整数类型。
当然，这并不意味着暗示C++前端中这些节点不具有，或者不会具有整数类型。

下面，我们列出了各种表达式节点。除了特别注明的以外，
表达式的操作数都通过@code{TREE_OPERAND}宏来访问。
例如，要访问二元加法表达式@code{expr}的第一个操作数，使用：

@smallexample
TREE_OPERAND (expr, 0)
@end smallexample
@noindent

正如这个例子所示，操作数是从0开始索引的。

所有起始于@code{OMP_}的表达式，
表示使用的是OpenMp API @w{@uref{http://www.openmp.org/}}的directives和clauses。

下面的列表格首先介绍了常数，接着是一元表达式，然后是二元表达式，
以及各种其它类型的表达式：

@table @code
@item INTEGER_CST
这些节点表示整数常量。注意这些常量的类型通过@code{TREE_TYPE}来获得；
并不总是@code{int}型的。特别是，
@code{char}型常量使用@code{INTEGER_CST}节点表示。
整数常量@code{e}的值通过下面的方式给出
@smallexample
((TREE_INT_CST_HIGH (e) << HOST_BITS_PER_WIDE_INT)
+ TREE_INST_CST_LOW (e))
@end smallexample
@noindent
HOST_BITS_PER_WIDE_INT在所有的平台上最少为32。
@code{TREE_INT_CST_HIGH}和@code{TREE_INT_CST_LOW}都返回一个
@code{HOST_WIDE_INT}。
一个@code{INTEGER_CST}的值根据常量的类型而被解析为有符号或无符号的数。
一般来说，上面给出的表达式将会溢出，因此不要用来计算常量的值。

变量@code{integer_zero_node}是一个值为0的整数常量。类似的，
@code{integer_one_node}是值为1的整数常量。
变量@code{size_zero_node}和@code{size_one_node}比较类似，
只是具有@code{size_t}类型，而不是@code{int}。

函数@code{tree_int_cst_lt}是一个断言，当第一个参数小于第二个时有效。
两个常量被假设为具有相同的符号性（即，要么都是有符号的，要么都是无符号的。）
在作比较时，使用常量的全部宽度；并忽略掉通常的类型提升和转换规则。
类似的，@code{tree_int_cst_equal}在两个常熟相等时有效。
函数@code{tree_int_cst_sgn}返回常数的符号。根据常数是大于，等于，或小于0，
而返回值@code{1}, @code{0}或@code{-1}。此外，会顾及到常数类型的符号性；
无符号常数是永远小于0的，不论它的位模式如何。

@item REAL_CST

FIXME: 讨论如何获得该常量的表示，如何进行比较等等。 

@item FIXED_CST

这些节点表示定点常数。这些常量的类型通过@code{TREE_TYPE}获得。@code{TREE_FIXED_CST_PTR}指向struct fixed_value；@code{TREE_FIXED_CST}返回结构体本身。Struct fixed_value包含了具有2个HOST_BITS_PER_WIDE_INT大小的@code{data}，以及与@code{data}关联的定点机器模式@code{mode}。

@item COMPLEX_CST
这些节点用于表示复数常量，即@code{__complex__} ，其组成部分为常数节点。@code{TREE_REALPART}和@code{TREE_IMAGPART}返回相应的实部和虚部。 


@item VECTOR_CST
这些节点用于表示向量常数，其组成部分为常量节点。每个单独的常量节点或者是一个常整数节点，或者是一个双精度的常数节点。第一个操作数为常数节点的@code{TREE_LIST}，并可以通过@code{TREE_VECTOR_CST_ELTS}来访问。 


@item STRING_CST
这些节点表示字符串常量。@code{TREE_STRING_LENGTH}返回@code{int}型的字符串长度。@code{TREE_STRING_POINTER}是一个@code{char*}型，包含了字符串本身。字符串可以不是@code{NUL}结尾的，并且可以包含嵌入的@code{NUL}字符。因此，如果字符串的结尾存在@code{NUL}，则@code{TREE_STRING_LENGTH}也包括了结尾的NUL。

对于宽字符串常量，@code{TREE_STRING_LENGTH}为字符串的字节数，并且@code{TREE_STRING_POINTER}指向在目标系统上表示的，字符串的字节数组（即，符合目标大小端的整数系列）。宽字符串和非宽字符串常量，只区别于@code{STRING_CST}的@code{TREE_TYPE}。

FIXME: 当目标系统的字节与主机系统的字节宽度不同时，字符串的格式没有被很好的定义。


@item PTRMEM_CST
这些节点用来表示指向成员的指针（pointer-to-member）常量。@code{PTRMEM_CST_CLASS}是类的类型（或者为@code{RECORD_TYPE}，或者为@code{UNION_TYPE}），@code{PTRMEM_CST_MEMBER}是指向的对象的声明。注意@code{PTRMEM_CST_MEMBER}的@code{DECL_CONTEXT}一般有别于@code{PTRMEM_CST_CLASS}的。例如，给定： 
@smallexample
struct B @{ int i; @};
struct D : public B @{@};
int D::*dp = &D::i;
@end smallexample
@noindent
虽然@code{PTRMEM_CST_MEMBER}的@code{DECL_CONTEXT}是@code{B}，但是由于@code{B::i}是@code{B}的成员，而不是@code{D}的，所以@code{&D::i}的@code{PTRMEM_CST_CLASS}为@code{D}。


@item VAR_DECL

这些节点表示变量，包括静态数据成员。更多信息，参见@pxref{声明}。 


@item NEGATE_EXPR
这些节点表示对单个,整数或浮点类型的操作数，进行一元取负运算。取负运算结果的类型可以通过查看表达式的类型来决定。

该操作在有符号算术溢出时的行为，由@code{flag_wrapv}和@code{flag_trapv}变量来控制。

@item ABS_EXPR
这些节点表示单个操作数，整数和浮点类型的，的绝对值。这通常用于实现整数类型的内建@code{abs}，@code{labs}和@code{llabs}，以及浮点类型的@code{fabs}，@code{fabsf}和@code{fabsl}。abs操作的类型可以通过查看表达式的类型来决定。

该节点不用于复数类型。要表示复数的模或者复数abs，使用内建的@code{BUILT_IN_CABS}, @code{BUILT_IN_CABSF}或@code{BUILT_IN_CABSL}，这些被用于实现C99的内建函数@code{cabs}, @code{cabsf}和@code{cabsl}。

@item BIT_NOT_EXPR
这些节点表示按位求补运算，并总是具有整数型。唯一的操作数是要被求补的值。

@item TRUTH_NOT_EXPR
这些节点表示逻辑非，并总是具有整数（或布尔）类型。操作数是要求非的值。操作数的，以及结果的类型总是@code{BOOLEAN_TYPE}或@code{INTEGER_TYPE}。 

@item PREDECREMENT_EXPR
@itemx PREINCREMENT_EXPR
@itemx POSTDECREMENT_EXPR
@itemx POSTINCREMENT_EXPR
这些节点表示递增和递减表达式。单操作数的值将被计算，并且操作数递增或递减。在@code{PREDECREMENT_EXPR}和@code{PREINCREMENT_EXPR}的情况下，表达式的值是递增或递减之后的结果；在@code{POSTDECREMENT_EXPR}和@code{POSTINCREMENT_EXPR}的情况下，表达式的值是递增或递减发生前的值。操作数的值，跟结果的一样，将会是整数，布尔，或浮点的。

@item ADDR_EXPR
这些节点用于表示对象的地址。（这些表达式将总是具有指针或引用类型。）操作数或者为表达式，或者可以是一个声明。

作为扩展，GCC运行用户使用标号的地址。这种情况下，@code{ADDR_EXPR}的操作数将为@code{LABEL_DECL}。这样的表达式的类型是@code{void*}。

如果求址的对象不是左值，则创建一个临时的，并使用临时对象的地址。

@item INDIRECT_REF
这些节点用来表示由指针指向的对象。操作数是被dereferenced的指针；其总是具有指针或引用类型。 

@item FIX_TRUNC_EXPR
这些节点表示浮点值到整数的转换。单操作数将具有一个浮点类型，完整的表达式将具有整数（或布尔）类型。操作数向0方向舍入。

@item FLOAT_EXPR
这些节点表示整数（或布尔）值向浮点值的转换。单操作数将具有整数类型，而完整的表达式将具有浮点类型。

FIXME: 操作数是如何被舍入的？这是不是取决于@option{-mieee}？

@item COMPLEX_EXPR
这些节点用于表示通过两个相同类型（整数或实数）的表达式构造的复数。第一个操作数是实部，第二个操作数是虚部。 

@item CONJ_EXPR
这些节点表示它们的操作数的共轭（conjugate）。 

@item REALPART_EXPR
@itemx IMAGPART_EXPR
这些节点表示复数的相应实数和虚数部分。 

@item NON_LVALUE_EXPR
这些节点指示它们有且仅有的一个操作数不是左值的。后端可以将其作为单操作数来对待。 

@item NOP_EXPR
这些节点用于表示不需要任何代码生成的转换。例如，由@code{char*}到@code{int*}不需要任何代码生成；这样的转换被表示为一个@code{NOP_EXPR}。单操作数为要转换的表达式。从指针到引用的转换也被表示为@code{NOP_EXPR}。 

@item CONVERT_EXPR
这些节点类似于@code{NOP_EXPR}，不过用于可能会有代码生成的情况。例如，如果@code{int*}被转换为@code{int}，则可能会在一些平台上需要生成代码。这些节点从来不被用于C++特定的转换，例如在一个继承体系中不同的类的指针间的转换。这种情况下的任何调整，总是需要被显式的指出。类似的，用户定义的转换也不使用@code{CONVERT_EXPR}表示；相反的，而是显式的调用函数。

@item FIXED_CONVERT_EXPR
这些节点用于表示涉及定点值的转换。例如，从一个定点值到另一个定点值，从一个整数到一个定点值，从一个定点值到一个整数，从一个浮点值到一个定点值，或者从一个定点值到一个浮点值。

@item THROW_EXPR
这些节点表示@code{throw}表达式。单操作为一个表达式，其代码将被执行用于抛出异常。但是，在表达式中有一个隐式的动作没有表示出来；即调用 @code{__throw}。这个函数没有参数。如果使用了@code{setjmp}/@code{longjmp}异常，则相应的调用函数@code{__sjthrow}。通常GCC后端使用函数 @code{emit_throw}来生成该代码；你可以检查该函数看看都需要做什么。

@item LSHIFT_EXPR
@itemx RSHIFT_EXPR
这些节点分别表示左移和右移。第一个操作数为要移动的值；其将总是为整数类型。第二个操作数为表示移动位数的表达式。右移将作为算术移动，即，当表达式具有无符号类型则高位填充0，当表达式具有有符号类型则高位填充符号位。注意如果第二个操作数大于或等于第一个操作数的类型大小，则结果无定义。

@item BIT_IOR_EXPR
@itemx BIT_XOR_EXPR
@itemx BIT_AND_EXPR
这些节点分别表示位运算符“或”，“异或”，和“与”。所有操作数将总是为整数类型。 

@item TRUTH_ANDIF_EXPR
@itemx TRUTH_ORIF_EXPR
这些节点分别表示逻辑“与”和“或”。这些操作符不是严格的；即第二个操作数只在通过求值第一个操作数无法确定表达式的值的时候，才被计算求值。操作数和结果的类型总是为@code{BOOLEAN_TYPE}或@code{INTEGER_TYPE}。 

@item TRUTH_AND_EXPR
@itemx TRUTH_OR_EXPR
@itemx TRUTH_XOR_EXPR
这些节点表示逻辑与，或和异或。它们为严格的方式；所有参数都总是被计算求值。这在C或C++中没有对应的运算符，但是前端如果可以断定严格的方式没关系，则有时将会生成这些表达式。操作数和结果的类型总是为@code{BOOLEAN_TYPE}或@code{INTEGER_TYPE}。 

@itemx POINTER_PLUS_EXPR
该节点表示指针算术运算。第一个操作数总是为一个指针/引用类型。第二个操作数总是为一个与sizetype兼容的无符号整数类型。这是唯一的可以操作指针类型的二元算术运算。 

@itemx PLUS_EXPR
@itemx MINUS_EXPR
@itemx MULT_EXPR
这些节点表示不同的二元算术运算。分别为加法，减法和乘法。它们的操作数可以为整数或者浮点类型，但不会为一个是浮点类型的，而另一个是整数类型。

这些运算在有符号算术溢出时的行为，由变量@code{flag_wrapv}和@code{flag_trapv}来控制。

@item RDIV_EXPR
该节点表示一个浮点除法运算。 

@item TRUNC_DIV_EXPR
@itemx FLOOR_DIV_EXPR
@itemx CEIL_DIV_EXPR
@itemx ROUND_DIV_EXPR
这些节点表示返回整数结果的整数除法运算。@code{TRUNC_DIV_EXPR}向0方向舍入，@code{FLOOR_DIV_EXPR}向负无穷大舍入，@code{CEIL_DIV_EXPR}向正无穷大舍入，@code{ROUND_DIV_EXPR}向最近的整数舍入。C和C++中的整数除法为截断方式，即@code{TRUNC_DIV_EXPR}。

这些运算在有符号算术溢出时的行为，由变量@code{flag_wrapv}和@code{flag_trapv}来控制。

@item TRUNC_MOD_EXPR
@itemx FLOOR_MOD_EXPR
@itemx CEIL_MOD_EXPR
@itemx ROUND_MOD_EXPR

这些节点表示整数类型的求余或求模运算。两个操作数@code{a}和@code{b}的整型的模被定义为@code{a - (a/b)*b}，其中使用相应的除法操作符进行除法运算。因此，对于@code{TRUNC_MOD_EXPR}的定义，是假设使用了向零方向舍去的除法，即@code{TRUNC_DIV_EXPR}。C和C++中的整型求余，使用了舍去除法，即@code{TRUNC_MOD_EXPR}。


@item EXACT_DIV_EXPR
@code{EXACT_DIV_EXPR}用来表示整数除法，即分子已知为分母的确切的倍数。这使得后端可以从@code{TRUNC_DIV_EXPR},
@code{CEIL_DIV_EXPR}和@code{FLOOR_DIV_EXPR}中，为当前的目标机选择更快的运算。

@item ARRAY_REF
这些节点表示对数组的访问。第一个操作数为数组；第二个为索引。要计算被访问内存的地址，你必须要根据比例，用数组元素的类型大小来乘以索引。这些表达式的类型必须为数组元素的类型。第三和第四个操作数在gimplification之后使用，来表示下界和元素大小；但是不要直接使用它们，相应的，调用@code{array_ref_low_bound}和@code{array_ref_element_size}。

@item ARRAY_RANGE_REF
这些节点表示对数组的一个范围（或者说切片）的访问。操作数与@code{ARRAY_REF}相同，并具有相同的含义。这些表达式的类型必须是一个数组，其元素的类型与第一个操作数的类型相同。数组类型的范围决定了这些表达式访问的数据数目。

@item TARGET_MEM_REF
这些节点表示内存访问，并且其地址直接映射到目标体系结构的寻址模式。第一个参数为@code{TMR_SYMBOL}，并且必须为具有固定地址的对象的@code{VAR_DECL}。第二个参数为@code{TMR_BASE}，第三个为@code{TMR_INDEX}。第四个参数为@code{TMR_STEP}，并且必须为@code{INTEGER_CST}。第五个参数为@code{TMR_OFFSET}，并且必须为@code{INTEGER_CST}。如果相应的部分没有在地址中出现，则参数可以为NULL。@code{TARGET_MEM_REF}的地址通过下列方法来确定。

@smallexample
&TMR_SYMBOL + TMR_BASE + TMR_INDEX * TMR_STEP + TMR_OFFSET
@end smallexample

第六个参数为对原始内存访问的引用，其被保留下来，用于RTL别名分析。第七个参数为一个标记，表示tree级的别名分析的结果。

@item LT_EXPR
@itemx LE_EXPR
@itemx GT_EXPR
@itemx GE_EXPR
@itemx EQ_EXPR
@itemx NE_EXPR
这些节点表示小于，小于或等于，大于，大于或等于，等于，和不等于的比较运算符。第一个和第二个操作数或者都为整数类型，或者都为浮点类型。这些表达式的结果类型将总是为整数或布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

对于浮点类型比较运算，如果我们使用了IEEE NaN，并且任意一个操作数为NaN，则@code{NE_EXPR}总是返回真，而其余的运算符总是返回假。在一些目标机上，对于IEEE NaN，除了等于和不等于以外的其它比较运算，可能会生成一个浮点异常。

@item ORDERED_EXPR
@itemx UNORDERED_EXPR
这些节点表示non-trapping的有序和无序的比较运算。这些运算接受两个浮点操作数，并确定它们之间是有序的，还是无序的。如果有一个操作数为IEEE NaN，则它们的比较被定以为无序的，否则为有序的。这些表达式的结果类型将总是为整数或者布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

@item UNLT_EXPR
@itemx UNLE_EXPR
@itemx UNGT_EXPR
@itemx UNGE_EXPR
@itemx UNEQ_EXPR
@itemx LTGT_EXPR
这些节点表示无序比较运算符。这些运算接受两个浮点操作数，并分别确定它们之间是否为无序的，小于，小于或等于，大于，大于或等于，或者等于。例如，如果一个操作数为IEEE NaN，或者第一个操作数小于第二个，则@code{UNLT_EXPR}返回真。除了@code{LTGT_EXPR}可能会产生异常，其它的运算都保证不会产生浮点异常。这些表达式的结果类型将总是为整数或者布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

@item MODIFY_EXPR
这些节点表示赋值。左手边为第一个操作数，右手边为第二个操作数。左手边为一个@code{VAR_DECL}, @code{INDIRECT_REF}, @code{COMPONENT_REF}，或者其它左值。

这些节点不仅用来表示使用@samp{=}进行赋值，也用来表示复合赋值（像@samp{+=}），并将其转换成@samp{=}赋值。换句话说，对@samp{i += 3}的表示，看起来就像是对@samp{i = i + 3}的表示。

@item INIT_EXPR
这些节点就像@code{MODIFY_EXPR}一样，只不过用于一个变量被初始化的时候，而不是后续的赋值。这意味着，我们可以假设初始化的目标，没有在右手边被用于计算它自己的值；任何在右手边的计算中，对左手边的引用，其行为将是未定义。

@item COMPONENT_REF
这些节点表示对non-static数据成员的访问。第一个操作数为对象（而不是指向它的指针）；第二个操作数为数据成员的@code{FIELD_DECL}。第三个操作数表示域的字节偏移量，但不要直接使用；相应的，调用@code{component_ref_field_offset}。

@item COMPOUND_EXPR
这些节点表示逗号表达式。第一个操作数为表达式，其值被计算，并在求出第二个操作数的值之前丢掉。整个表达式的值为第二个操作数的值。

@item COND_EXPR
这些节点表示@code{?:}表达式。第一个操作数是布尔或者整数类型。如果其求解为非零值，则第二个操作数将被求值，并返回表达式的值。否则，第三个操作数将被求值，并将表达式的值返回。

第二个操作数必须与整个表达式具有相同的类型，除非它是要无条件的抛出一个异常或者调用一个不返回的函数，这种情况下，其将是void类型。第三个操作数也具有同样的约束。这使得数组的边界检查可以被方便的表示为@code{(i >= 0 && i < 10) ? i : abort()}。

作为GNU扩展，C语言前端允许@code{?:}运算符的第二个操作数可以在源程序中省略掉。例如，@code{x ? : 3}等价于@code{x ? x : 3}，假设@code{x}是一个没有副作用的表达式。但是，在tree的表示中，第二个操作数总是存在的，并且，如果第一个参数确实产生副作用的话，则其可能通过@code{SAVE_EXPR}来保护。

@item CALL_EXPR
这些节点用来表示对函数的调用，包括non-static成员函数。@code{CALL_EXPR}被实现为一个具有可变数目操作数的表达式节点。不要用@code{TREE_OPERAND}来获取这些操作数，最好是用针对@code{CALL_EXPR}节点的特定的访问宏和函数。

@code{CALL_EXPR_FN}返回一个调用函数的指针；其总是一个类型为@code{POINTER_TYPE}的表达式。

调用函数的参数数目由@code{call_expr_nargs}来返回，而参数本身可以使用@code{CALL_EXPR_ARG}宏来访问。参数从零开始，从左向右进行索引。你可以使用@code{FOR_EACH_CALL_EXPR_ARG}来迭代参数，例如：

@smallexample
tree call, arg;
call_expr_arg_iterator iter;
FOR_EACH_CALL_EXPR_ARG (arg, iter, call)
  /* arg is bound to successive arguments of call.  */
  @dots{};
@end smallexample

对于non-static成员函数，将会有一个对应于@code{this}指针的操作数。所有的参数都会有相应的表达式，即使函数使用缺省的参数声明，并且在调用的地方，一些参数没有被显式的提供。

@code{CALL_EXPR}还有一个@code{CALL_EXPR_STATIC_CHAIN}操作数，用于实现嵌套函数。如果没有嵌套函数，则为null。

@item STMT_EXPR
这些节点用于表示GCC的语句表达式扩展。语句表达式扩展，允许代码像这样：

@smallexample
int f() @{ return (@{ int j; j = 3; j + 7; @}); @}
@end smallexample

还句话说，一个语句序列可以出现在通常单个表达式出现的地方。@code{STMT_EXPR}节点表示这样的表达式。The @code{STMT_EXPR_STMT}给出了表达式中包含的语句。表达式的值为最后一条语句的值。更确切的说，为嵌套在@code{BIND_EXPR},
@code{TRY_FINALLY_EXPR}, 或@code{TRY_CATCH_EXPR}中的最后一条语句所计算出来的值。例如，

@smallexample
(@{ 3; @})
@end smallexample

值为@code{3}，而:

@smallexample
(@{ if (x) @{ 3; @} @})
@end smallexample

没有值。如果@code{STMT_EXPR}没有产生一个值，则类型为@code{void}。

@item BIND_EXPR
这些节点表示局部块。第一个操作数为变量的列表，通过它们的@code{TREE_CHAIN}域链接。这些将从不会要求被清除。这些变量的作用域就是@code{BIND_EXPR}的主体。@code{BIND_EXPR}的主体为第二个操作数。

@item LOOP_EXPR
这些节点表示“无限”循环。@code{LOOP_EXPR_BODY}表示循环体。其将被永远执行，除非遇到@code{EXIT_EXPR}。

@item EXIT_EXPR
这些节点表示从最近包含的@code{LOOP_EXPR}中条件退出。单个操作数为条件；如果非零，则循环将被退出。@code{EXIT_EXPR}将只是出现在@code{LOOP_EXPR}中。

@item CLEANUP_POINT_EXPR
这些节点表示full-expression。单个操作数为被求值的表达式。任何在表达式求值中通过创建临时对象所引起的析构调用，都应该在表达式求值之后立刻执行。

@item CONSTRUCTOR
这些节点表示大括号括起的，对结构体或者数组的初始化。第一个操作数被保留，用于后端。第二个操作数为@code{TREE_LIST}。如果@code{CONSTRUCTOR}的@code{TREE_TYPE}为一个@code{RECORD_TYPE}或者@code{UNION_TYPE}，则@code{TREE_LIST}中每个节点的@code{TREE_PURPOSE}将为一个@code{FIELD_DECL}，并且每个节点的@code{TREE_VALUE}将为初始化该域的表达式。

如果@code{CONSTRUCTOR}的@code{TREE_TYPE}为一个@code{ARRAY_TYPE}，则@code{TREE_LIST}中每个节点的@code{TREE_PURPOSE}将为一个@code{INTEGER_CST}，或者两个@code{INTEGER_CST}的@code{RANGE_EXPR}。单个@code{INTEGER_CST}指出了数组（从0开始索引）的哪个元素将被赋值。@code{RANGE_EXPR}指出了包含端点元素的一个范围将被初始化。这两种情况下，@code{TREE_VALUE}都对应初始化者。其值将对于@code{RANGE_EXPR}的每个元素都重新计算一次。如果@code{TREE_PURPOSE}是@code{NULL_TREE}，则初始化是针对下一个可用的数组元素。

在前端，你不要认为域是按照特定的顺序出现。但是，在中端，域必须按照声明的顺序出现。你不应该假设所有的域都被表示了。没有表示的域将被设置为0。

@item COMPOUND_LITERAL_EXPR
@findex COMPOUND_LITERAL_EXPR_DECL_STMT
@findex COMPOUND_LITERAL_EXPR_DECL
这些节点表示复合文字。
@code{COMPOUND_LITERAL_EXPR_DECL_STMT}为一个@code{DECL_STMT}，
包含了一个由复合文字表示的未命名对象的匿名@code{VAR_DECL}；
@code{VAR_DECL}的@code{DECL_INITIAL}是一个@code{CONSTRUCTOR}用来表示在
复合文字中大括号包围的初始值列表。
匿名的@code{VAR_DECL}还可以通过@code{COMPOUND_LITERAL_EXPR_DECL}宏直接访问。 

@item SAVE_EXPR
@code{SAVE_EXPR}表示一个被多次使用的表达式（可能会有副作用）。
副作用应该只在表达式第一次被求值时发生。后续的使用应该只是重用计算所得的值。
@code{SAVE_EXPR}的第一个操作数是要求值的表达式。
副作用应该在深度优先前续遍历表达式树，第一次遇到@code{SAVE_EXPR}时被执行。 

@item TARGET_EXPR
@code{TARGET_EXPR}表示一个临时对象。第一个操作数是临时变量@code{VAR_DECL}。
第二个操作数是临时变量的初始值。初始值将被求值，并且如果不是void型的，
则（按位）复制到临时变量中。如果初始值是void的，意味着将会自己执行初始化。 

很多时候，@code{TARGET_EXPR}会出现在赋值的右边，
或者作为逗号表达式的第二个操作数。 这种情况下，
我们说@code{TARGET_EXPR}是“normal”的；否则，我们说它是“orphaned”。
对于一个正常的@code{TARGET_EXPR}，临时变量应被视为赋值的左端的一个别名，
而不是一个新的临时变量。

@code{TARGET_EXPR}的第三个操作数，如果存在的话，
是临时变量的清理表达式（即析构调用）。如果该表达式是孤儿的，
则该表达式必须当包含它的语句是完整的时候被执行。
这些清理必须总是按照相反的顺序执行。
注意如果临时变量是在条件操作符的分支上创建的（即，
@code{COND_EXPR}的第二个或第三个操作数），
则清理必须只有在该分支实际被执行时才运行。

关于运行这些清理的更多信息，参见@code{STMT_IS_FULL_EXPR_P}。

@item AGGR_INIT_EXPR
@code{AGGR_INIT_EXPR}表示作为函数调用的返回值或者作为构造函数的结果的初始化。
@code{AGGR_INIT_EXPR}只作为充分表达式出现，
或作为@code{TARGET_EXPR}的第二个操作数。
@code{AGGR_INIT_EXPR}具有跟@code{CALL_EXPR}类似的表示。
可以使用@code{AGGR_INIT_EXPR_FN}和@code{AGGR_INIT_EXPR_ARG}宏来访问调用的函数，
以及传递的参数。

如果@code{AGGR_INIT_VIA_CTOR_P}持有@code{AGGR_INIT_EXPR}，
则初始化是通过一个构造函数进行的。@code{AGGR_INIT_EXPR_SLOT}操作数的地址，
其总是一个@code{VAR_DECL}，将被接受，并且该值替代参数列表中的第一个参数。

在这两种情况下，表达式都是void的。

@item VA_ARG_EXPR
该节点用来实现对C/C++可变参数列表机制的支持。
它表示了像@code{va_arg (ap, type)}这样的表达式。
它的@code{TREE_TYPE}用来产生@code{type}的树表示，
唯一的参数用来产生对@code{ap}的表示。 

@item CHANGE_DYNAMIC_TYPE_EXPR
指出了C++ placement new的特定别名需求。有两个操作数：类型和位置。
它表示该位置的动态类型被转换为指定的类型。
别名分析代码在做基于类型的别名分析时，需要考虑到这一点。 

@item OMP_PARALLEL

表示@code{#pragma omp parallel [clause1 @dots{} clauseN]}。具有四个操作数：

操作数@code{OMP_PARALLEL_BODY}在GENERIC和High GIMPLE形式中是有效的。
它包含了被所有线程执行的代码体。在GIMPLE下降过程中，
这个操作数变为@code{NULL}并且代码体被线性的输出在@code{OMP_PARALLEL}之后。

操作数@code{OMP_PARALLEL_CLAUSES}为与指令相关的子句列表。

操作数@code{OMP_PARALLEL_FN}由@code{pass_lower_omp}创建，
它包含了将要包含并行区域体的函数@code{FUNCTION_DECL}。

操作数@code{OMP_PARALLEL_DATA_ARG}也由@code{pass_lower_omp}创建。
如果有共享变量用于子线程间通讯，则该操作数将包含@code{VAR_DECL}，
其包含了所有共享的值和变量。

@item OMP_FOR

表示@code{#pragma omp for [clause1 @dots{} clauseN]}. 其具有5个操作数：

操作数OMP_FOR_BODY包含了循环体。

操作数OMP_FOR_CLAUSES为与指令相关的子句列表。

操作数OMP_FOR_INIT为VAR = N1形式的循环初始化代码。

操作数OMP_FOR_COND为@code{VAR @{<,>,<=,>=@} N2}形式的循环条件表达式。

操作数OMP_FOR_INCR为@code{VAR @{+=,-=@} INCR}形式的循环索引增量。

操作数OMP_FOR_PRE_BODY包含了来自操作数OMP_FOR_INIT, OMP_FOR_COND和OMP_FOR_INC的副作用代码。这些副作用为OMP_FOR块的一部分，但是必须在开始循环体之前被计算求值。

循环索引变量VAR必须为单个整数变量，其隐式的归每个线程私有。边界N1和N2，以及增量表达式INCR需要为循环不变量整数表达式，其不需要同步就可以被计算求值。按照标准，计算求值的顺序，频率和副作用都没有被指定。

@item OMP_SECTIONS

表示@code{#pragma omp sections [clause1 @dots{} clauseN]}。

操作数@code{OMP_SECTIONS_BODY}包含了section主体，
其依次包含了一个@code{OMP_SECTION}节点集合，
每个并发的section通过@code{#pragma omp section}来划分。

操作数@code{OMP_SECTIONS_CLAUSES}为与指令相关的子句列表。

@item OMP_SECTION

@code{OMP_SECTIONS}的Section定界符。 

@item OMP_SINGLE

表示@code{#pragma omp single}

操作数@code{OMP_SINGLE_BODY}包含了被单个线程执行的代码体。

操作数@code{OMP_SINGLE_CLAUSES}为与指令相关的子句列表。

@item OMP_MASTER

表示@code{#pragma omp master}。

操作数@code{OMP_MASTER_BODY}包含了被主控线程执行的代码体。

@item OMP_ORDERED

表示@code{#pragma omp ordered}。

操作数@code{OMP_ORDERED_BODY}包含了按照由循环索引变量所指示的顺序序列来执行的代码体。

@item OMP_CRITICAL

表示@code{#pragma omp critical [name]}。

操作数@code{OMP_CRITICAL_BODY}为临界section。

操作数@code{OMP_CRITICAL_NAME}为可选的用来标记临界section的标识符。

@item OMP_RETURN

这个并不表示任何OpenMP指令，它为一个人为标记用来指示OpenMP主体的结束。
其被用于流图（@code{tree-cfg.c}）和OpenMP区域构建代码（@code{omp-low.c}）。

@item OMP_CONTINUE

类似的，该指令不表示OpenMP指令，它被@code{OMP_FOR}和@code{OMP_SECTIONS}用于
标记代码需要循环到下一个迭代（例如@code{OMP_FOR}）或者下一个section
（例如@code{OMP_SECTIONS}）的地方。有一些情况，
@code{OMP_CONTINUE}被放在紧挨着@code{OMP_RETURN}之前。
但是，如果在循环体之后需要出现cleanups，
则它将被生成在@code{OMP_CONTINUE}和@code{OMP_RETURN}之间。 

@item OMP_ATOMIC

表示@code{#pragma omp atomic}。

操作数0是要被执行的原子操作的地址。

操作数1是要计算求值的表达式。gimplifier会尝试三种可供选择的代码生成策略。
只要可能，则会使用内建的原子更新。如果失败，
则会尝试进行比较-交换（compare-and-swap）循环。如果还是失败，
则会使用表达式附近的一个常规临界section。

@item OMP_CLAUSE

表示与@code{OMP_}指令相关的子句。子句使用@file{tree.h}中定义的子代码单独表示。
子句代码可以为：OMP_CLAUSE_PRIVATE, OMP_CLAUSE_SHARED, OMP_CLAUSE_FIRSTPRIVATE, OMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_COPYIN, OMP_CLAUSE_COPYPRIVATE, OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS, OMP_CLAUSE_SCHEDULE, OMP_CLAUSE_NOWAIT, OMP_CLAUSE_ORDERED, OMP_CLAUSE_DEFAULT, 和OMP_CLAUSE_REDUCTION。每个代码表示了相应的OpenMP子句。

与同一指令相关的子句通过@code{OMP_CLAUSE_CHAIN}链接在一起。
那些接受一个变量列表的子句被限制为只有一个，使用@code{OMP_CLAUSE_VAR}来访问。
因此，同一子句@code{C}下的多个变量需要被多个链接在一起的@code{C}子句表示。
这样可以有助于在编译过程中增加新的子句。

@item VEC_LSHIFT_EXPR
@item VEC_RSHIFT_EXPR
这些节点相应的表示整个向量的左移和右移。第一个操作数为要移动的向量；
其将总是为向量类型。第二个操作数是一个表达式，表示要移动的位数。
注意如果第二个操作数大于或等于第一个操作数的类型大小，则结果未定义。

@item VEC_WIDEN_MULT_HI_EXPR
@item VEC_WIDEN_MULT_LO_EXPR
这些节点分别表示两个输入向量的高部和低部的加宽向量乘法。
它们的操作数为包含同一整数类型的同一数目（@code{N}）元素的向量。
结果为一个包含整数类型的元素大小为两倍宽数目为一半的向量。
对于@code{VEC_WIDEN_MULT_HI_EXPR}，
两个向量的高@code{N/2}个元素相乘得到@code{N/2}个积的向量。
对于@code{VEC_WIDEN_MULT_LO_EXPR}，
两个向量的低@code{N/2}个元素相乘得到@code{N/2}个积的向量。 

@item VEC_UNPACK_HI_EXPR
@item VEC_UNPACK_LO_EXPR
这些节点分别表示拆分输入向量的高部和低部。
单操作数为一个包含同一整数或浮点类型的@code{N}个元素的向量。
结果为包含整数或者浮点类型的元素大小为两倍宽数目为一半的向量。
对于@code{VEC_UNPACK_HI_EXPR}，向量的高@code{N/2}个元素被提取并扩展（提升）。
对于@code{VEC_UNPACK_LO_EXPR}，向量的低@code{N/2}个元素被提取并扩展（提升）。 

@item VEC_UNPACK_FLOAT_HI_EXPR
@item VEC_UNPACK_FLOAT_LO_EXPR
这些节点分别表示拆分输入向量的高部和低部，并将值由定点转换为浮点。
单操作数为包含同一整数类型的@code{N}个元素的向量。
结果为包含浮点类型的元素大小为两倍宽数目为一半的向量。
对于@code{VEC_UNPACK_HI_EXPR}，向量的高@code{N/2}个元素被提取，转换并扩展。
对于@code{VEC_UNPACK_LO_EXPR}，向量的低@code{N/2}个元素被提取，转换并扩展。 

@item VEC_PACK_TRUNC_EXPR
该节点表示将两个输入向量的截断元素打包成输出向量。
输入操作数是包含同一整数或者浮点类型的相同数目元素的向量。
结果为包含整数或者浮点类型的元素大小为一半数目为两倍的向量。
两个向量的元素合并成输出向量。 

@item VEC_PACK_SAT_EXPR
该节点表示使用饱和方式（saturation）将两个输入向量的元素打包成输出向量。
输入操作数是包含了同一整数类型的相同数目元素的向量。
结果为一个包含整数类型的元素大小为一半数目为两倍的向量。
两个向量的元素合并成输出向量。 

@item VEC_PACK_FIX_TRUNC_EXPR
该节点表示将将两个输入向量的元素打包成输出向量，并将值由浮点转换为定点。
输入操作数是包含浮点类型的相同数目元素的向量。
结果为包含整数类型元素大小一半数目为两倍的向量。两个向量的元素合并成输出向量。 

@item VEC_EXTRACT_EVEN_EXPR
@item VEC_EXTRACT_ODD_EXPR
这些节点分别表示提取两个输入向量的偶数/奇数个元素。
它们的操作数和结果为包含同一类型的相同数目元素的向量。 

@item VEC_INTERLEAVE_HIGH_EXPR
@item VEC_INTERLEAVE_LOW_EXPR
这些节点分别表示交错合并两个输入向量的高/低元素。
操作数和结果为包含同一类型的相同数目（@code{N}）元素的向量。
对于@code{VEC_INTERLEAVE_HIGH_EXPR}，
第一个输入向量的高@code{N/2}个元素被第二个输入向量的高@code{N/2}个元素替换。
对于@code{VEC_INTERLEAVE_LOW_EXPR}，
第一个输入向量的低@code{N/2}个元素被第二个输入向量的低@code{N/2}个元素替换。 
@end table
