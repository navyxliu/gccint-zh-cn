@c Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
@c 2009  Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Trees
@c ---------------------------------------------------------------------

@node Trees
@chapter Trees: C和C++前端使用的中间表示
@cindex Trees
@cindex C/C++ Internal Representation

这一章记述了GCC用来表示C和C++源程序的内部表示。当源程序为C或者C++时，
GCC解析程序，执行语义分析（包括生成错误消息），
然后产生在这里描述的中间表示。
该表示包含了一个对前端输入的整个转换单元的完全表示。
该表示然后由代码生成器处理，从而产生机器代码，
但是还可以用来创建源浏览器，智能编辑器，自动文本生成器，解析器，
以及任何其它处理C或C++代码所需的程序。

这一章解释了内部表示。特别是，记录了C和C++源结构的内部表示，
以及能够用来访问这些结构的宏，函数和变量。
C++的表示很大程度上为C前端使用的表示的超集。
只有一种C中使用的结构没有出现在C++前端，即GNU“嵌套函数”扩展。
许多这里记录的宏不在C中出现，因为相应的语言结构不出现在C 中。

如果你正在开发一个“后端”，一个代码生成器或一些其它工具，
使用了该表示，你可能偶然发现需要询问一些问题，
并且这些问题不好通过这里列出的函数和宏来回答。如果是这种情况，
可能GCC已经支持了你想要的功能，只不过接口并没有记录在这里。
在这种情况下，你应该询问GCC维护者（通过发邮件给@email{gcc@@gcc.gnu.org}），
关于记录你想要的功能。
同样，如果你发现你自己写的函数并不是直接处理你的后端，
而是可能对其他使用GCC前端的人有帮助，你应该将你的patch提交纳入GCC。

@menu
* 不足之处::        在该文档中没有涵盖的专题。
* Tree概述::        所有关于@code{tree}的。
* 类型::            基本类型和聚合类型。
* 作用域::          命名空间和类。
* 函数::            重载，函数体和连接。
* 声明::            类型声明和变量。
* 属性::            声明和类型属性。
* 表达式tree::      从@code{typeid}到@code{throw}。
@end menu

@c ---------------------------------------------------------------------
@c Deficiencies
@c ---------------------------------------------------------------------

@node 不足之处
@section 不足之处

该文档中有许多地方不完整并且有错误。目前，还只是一个@emph{初步的}文档。

@c ---------------------------------------------------------------------
@c Overview
@c ---------------------------------------------------------------------

@node Tree概述
@section 概述
@cindex tree
@findex TREE_CODE

内部表示使用的主要数据结构体为@code{tree}。
这些节点，即所有C类型的@code{tree}，有许多种类。
@code{tree}是一个指针类型，但是它所指向的对象可能会有不同的类型。
从现在开始，除非是在谈论实际的C类型@code{tree}，
我们提到的树都是指普通类型的。

可以通过@code{TREE_CODE}宏来得知特定的树是什么类型的节点。
许多宏以树作为输入，并以树作为输出返回。
然而，大多数宏需要特定的一种树节点作为输入。
换句话说，是有一个树的类型系统，但没有反应在C的类型系统中。

出于安全考虑，使用@option{--enable-checking}来配置GCC会很有用。
虽然这会导致显著的性能亏损（因为所有tree类型都会在运行时被检查），
并且因此在发行版中不合适，但在开发阶段会非常有帮助。

许多宏作为判定条件使用。许多并不是所有的这些判定条件都结束于@samp{_P}。
不要依赖于这些宏的结果类型会是特定的类型。
但是，你可以依赖于类型可以与@code{0}相比较，这个事实。所以，像这样的语句

@smallexample
if (TEST_P (t) && !TEST_P (y))
  x = 1;
@end smallexample
@noindent
和
@smallexample
int i = (TEST_P (t) != 0);
@end smallexample
@noindent
是合法的。现在返回@code{int}值的宏，将来可能被改为返回@code{tree}值，
或者其它指针。即使那些继续返回@code{int}的，也可能会由先前只返回0和1，
改为返回多个非0的代码。因此，不要将代码写成

@smallexample
if (TEST_P (t) == 1)
@end smallexample
@noindent
因为这样的代码不保证将来会正确工作。

不要使用这里描述的宏或者函数的返回值的地址。
特别是，不保证这些值是左值。

一般来说，宏的名字都是大写形式，而函数的名字都是完全小写的。
很少有例外的。
你应该假设任何完全由大写字母组成的宏或函数可能会对它的参数进行多次求值。
你可以假设完全由小写字母组成的宏或函数将会对它的参数只求一次值。

@code{error_mark_node}是一个特殊的树。它的树代码为@code{ERROR_MARK}，
但由于只有一个节点具有那个代码，
所以通常的做法是将树与@code{error_mark_node}进行比较。
（该测试只是一个指针相等的测试。）如果在前端处理中，有一个错误发生，
则标识@code{errorcount}将会被设置。如果前端遇到无法处理的代码，
则会给用户发送一个消息，并设置@code{sorrycount}。当这些标识被设置时，
则通常返回特定类型树的宏和函数，可能会替代的返回@code{error_mark_node}。
因此，如果你打算进行任何错误代码处理，
则必须准备好跟@code{error_mark_node}打交道。

有时，一个特定的树插槽slot（就像表达式的操作数，或声明里的特定域）
将被称为“为后端保留”。这些插槽用于存储RTL，当树被转换为RTL，被GCC后端使用时。
然而，如果没有进行那种处理（例如，如果前端被钩子转向给一个智能编辑器），
那么这些插槽就可以被使用了。

如果你遇到的情况不符合这个文档，如没有在这里提到的树节点的类型，
或记载的宏返回了不同的某一类型实体，那么你发现了一个bug ，要么是前端的，
要么是该文档的。请报告这些bug，以及是否有任何其他的bug。

@menu
* 宏和函数::      可以用于所有树的宏和函数。
* 标识符::        事物的名字。
* 容器::          列表和向量。
@end menu

@c ---------------------------------------------------------------------
@c Trees
@c ---------------------------------------------------------------------

@node 宏和函数
@subsection Trees
@cindex tree

目前还没有这一节的内容。

@c ---------------------------------------------------------------------
@c Identifiers
@c ---------------------------------------------------------------------

@node 标识符
@subsection 标识符
@cindex identifier
@cindex name
@tindex IDENTIFIER_NODE

@code{IDENTIFIER_NODE}表示了比标准C或C++关于标识符更略为一般的概念。
特别是，@code{IDENTIFIER_NODE}可以包含一个@samp{$}，或其它额外的字符。

不会有两个不同的@code{IDENTIFIER_NODE}表示同一个标识符。
因此，你可以使用指针相等的方式来比较@code{IDENTIFIER_NODE}，
而不必使用像strcmp这样的函数。

可以使用下列宏来访问标识符：

@ftable @code
@item IDENTIFIER_POINTER
标识符所表示的字符串，为一个@code{char*}。
该字符串总是以@code{NUL}结束，并且不包含嵌入的@code{NUL}字符。

@item IDENTIFIER_LENGTH
由@code{IDENTIFIER_POINTER}返回的字符串的长度，不包括结尾的@code{NUL}。
@code{IDENTIFIER_LENGTH (x)}的值总是与@code{strlen (IDENTIFIER_POINTER (x))}相同。

@item IDENTIFIER_OPNAME_P
该断言当标识符表示的是重载操作符的名字时有效。这种情况下，
不要依赖@code{IDENTIFIER_POINTER}或@code{IDENTIFIER_LENGTH}的内容。 

@item IDENTIFIER_TYPENAME_P
该断言当标识符表示的是用户定义的转换操作符的名字时有效。这种情况下，
@code{IDENTIFIER_NODE}的@code{TREE_TYPE}持有转换操作符转换后的类型。
@end ftable

@c ---------------------------------------------------------------------
@c Containers
@c ---------------------------------------------------------------------

@node 容器
@subsection 容器
@cindex container
@cindex list
@cindex vector
@tindex TREE_LIST
@tindex TREE_VEC
@findex TREE_PURPOSE
@findex TREE_VALUE
@findex TREE_VEC_LENGTH
@findex TREE_VEC_ELT

有两种通用容器数据结构可以直接用树节点表示。
@code{TREE_LIST}是一个单向链表，每个节点包含两个树。
每个节点都有@code{TREE_PURPOSE}和@code{TREE_VALUE}。
（很多时候，@code{TREE_PURPOSE}包含了某种tag，或补充信息，
而@code{TREE_VALUE}包含了大部分的有效载荷。在其他情况下，
@code{TREE_PURPOSE}只是一个@code{NULL_TREE}，而还有一些情况，
@code{TREE_PURPOSE}和@code{TREE_VALUE}是处于相等的状况。）
给定一个@code{TREE_LIST}节点，可以沿着@code{TREE_CHAIN}来找到下一个节点。
如果@code{TREE_CHAIN}为@code{NULL_TREE}时，则表示到达链表的结尾了。

@code{TREE_VEC}是一个简单的向量。@code{TREE_VEC_LENGTH}是一个整数（不是树），
给出了向量中节点的数目。节点本身通过宏@code{TREE_VEC_ELT}来访问，
其接受两个参数。第一个为要查询的@code{TREE_VEC}；
第二个为整数，指定了向量中的元素。元素索引从0开始。

@c ---------------------------------------------------------------------
@c Types
@c ---------------------------------------------------------------------

@node 类型
@section 类型
@cindex type
@cindex pointer
@cindex reference
@cindex fundamental type
@cindex array
@tindex VOID_TYPE
@tindex INTEGER_TYPE
@tindex TYPE_MIN_VALUE
@tindex TYPE_MAX_VALUE
@tindex REAL_TYPE
@tindex FIXED_POINT_TYPE
@tindex COMPLEX_TYPE
@tindex ENUMERAL_TYPE
@tindex BOOLEAN_TYPE
@tindex POINTER_TYPE
@tindex REFERENCE_TYPE
@tindex FUNCTION_TYPE
@tindex METHOD_TYPE
@tindex ARRAY_TYPE
@tindex RECORD_TYPE
@tindex UNION_TYPE
@tindex UNKNOWN_TYPE
@tindex OFFSET_TYPE
@tindex TYPENAME_TYPE
@tindex TYPEOF_TYPE
@findex CP_TYPE_QUALS
@findex TYPE_UNQUALIFIED
@findex TYPE_QUAL_CONST
@findex TYPE_QUAL_VOLATILE
@findex TYPE_QUAL_RESTRICT
@findex TYPE_MAIN_VARIANT
@cindex qualified type
@findex TYPE_SIZE
@findex TYPE_ALIGN
@findex TYPE_PRECISION
@findex TYPE_ARG_TYPES
@findex TYPE_METHOD_BASETYPE
@findex TYPE_PTRMEM_P
@findex TYPE_OFFSET_BASETYPE
@findex TREE_TYPE
@findex TYPE_CONTEXT
@findex TYPE_NAME
@findex TYPENAME_TYPE_FULLNAME
@findex TYPE_FIELDS
@findex TYPE_PTROBV_P
@findex TYPE_CANONICAL
@findex TYPE_STRUCTURAL_EQUALITY_P
@findex SET_TYPE_STRUCTURAL_EQUALITY

所有的类型都有相应的树节点。
但是不要假设一个树节点就是正好对应于一个类型。
经常有多个节点对应于相同的类型。

在大多数情况下，不同种类的类型具有不同的树代码。
（例如，指针类型使用@code{POINTER_TYPE}代码，
而数组使用@code{ARRAY_TYPE}代码。）但是，
指向成员函数的指针使用@code{RECORD_TYPE}代码。
因此，当写与特定类型相关联的@code{switch}语句时，
应该在@code{RECORD_TYPE} case标签下小心处理指向成员函数的指针。

在C++中，数组类型没有被限定，而是数组元素的类型被限定。
这种情况反映在中间表示中。这里描述的宏在应用到数组类型时，
将总是检验元素类型的限定符。（如果元素类型本身是一个数组，
则会递归执行只到找到非数组类型，并检验该类型的限定符）所以，
例如，@code{CP_TYPE_CONST_P}当表示具有七个@code{int}的数组时，
将持有@code{const int ()[7]}类型。

下列函数和宏处理cv-qualification的类型：

@ftable @code
@item CP_TYPE_QUALS
该宏返回应用到该类型的类型限定符集。
如果没有应用限定符则该值为@code{TYPE_UNQUALIFIED}。
如果类型是@code{const}的，则会设置@code{TYPE_QUAL_CONST}位。
如果类型是@code{volatile}的，则会设置@code{TYPE_QUAL_VOLATILE}位。
如果类型是@code{restrict}的，则会设置@code{TYPE_QUAL_RESTRICT}位。 

@item CP_TYPE_CONST_P
该宏当类型是@code{const}时有效。

@item CP_TYPE_VOLATILE_P
该宏当类型是@code{volatile}时有效。 

@item CP_TYPE_RESTRICT_P
该宏当类型是@code{restrict}时有效。 

@item CP_TYPE_CONST_NON_VOLATILE_P
该断言当类型是@code{const}的，但@emph{不是}@code{volatile}的时有效。
其它cv-qualifiers会被忽略，只测试@code{const}。 

@item TYPE_MAIN_VARIANT
该宏类型未限定的版本。可以用于一个未限定的类型，但这种情况下，
并不总是标识符函数。 
@end ftable

一些其它的宏和函数可用于所有的类型：
@ftable @code
@item TYPE_SIZE
类型表示所需要的位数，为一个@code{INTEGER_CST}。
对于不完全类型，@code{TYPE_SIZE}将为@code{NULL_TREE}。 

@item TYPE_ALIGN
类型的对齐位数，为一个@code{int}。 

@item TYPE_NAME
该宏返回类型的一个声明（按照@code{TYPE_DECL}的型式）。
（注意该宏不返回@code{IDENTIFIER_NODE}）
你可以查看@code{TYPE_DECL}的@code{DECL_NAME}来获得类型的实际的名字。
@code{TYPE_NAME}将为@code{NULL_TREE}，对于不是内建类型的，typedef的，
或者命名的class类型。

@item CP_INTEGRAL_TYPE
该断言有效，如果类型为一个整数类型。注意在C++中，枚举@emph{不是}整数类型。 

@item ARITHMETIC_TYPE_P
该断言有效，如果类型为一个整数类型（按照c++的观点）或者一个浮点类型。 

@item CLASS_TYPE_P
该断言有效，对于一个class类型。 

@item TYPE_BUILT_IN
该断言有效，对于一个内建类型。 

@item TYPE_PTRMEM_P
该断言有效，如果类型为一个指向数据成员的指针。 

@item TYPE_PTR_P
该断言有效，如果类型为一个指针，而指向者不是一个数据成员。 

@item TYPE_PTRFN_P
该断言有效，对于一个执行函数类型的指针。 

@item TYPE_PTROB_P
该断言有效，对于一个指向object类型的指针。
注意其对于指向object类型@code{void *}的通用指针无效。
你可以使用@code{TYPE_PTROBV_P}来测试指针是指向object类型，
同时也是@code{void *}。 

@item TYPE_CANONICAL
This macro returns the ``canonical'' type for the given type
node. Canonical types are used to improve performance in the C++ and
Objective-C++ front ends by allowing efficient comparison between two
type nodes in @code{same_type_p}: if the @code{TYPE_CANONICAL} values
of the types are equal, the types are equivalent; otherwise, the types
are not equivalent. The notion of equivalence for canonical types is
the same as the notion of type equivalence in the language itself. For
instance,

When @code{TYPE_CANONICAL} is @code{NULL_TREE}, there is no canonical
type for the given type node. In this case, comparison between this
type and any other type requires the compiler to perform a deep,
``structural'' comparison to see if the two type nodes have the same
form and properties.

The canonical type for a node is always the most fundamental type in
the equivalence class of types. For instance, @code{int} is its own
canonical type. A typedef @code{I} of @code{int} will have @code{int}
as its canonical type. Similarly, @code{I*}@ and a typedef @code{IP}@
(defined to @code{I*}) will has @code{int*} as their canonical
type. When building a new type node, be sure to set
@code{TYPE_CANONICAL} to the appropriate canonical type. If the new
type is a compound type (built from other types), and any of those
other types require structural equality, use
@code{SET_TYPE_STRUCTURAL_EQUALITY} to ensure that the new type also
requires structural equality. Finally, if for some reason you cannot
guarantee that @code{TYPE_CANONICAL} will point to the canonical type,
use @code{SET_TYPE_STRUCTURAL_EQUALITY} to make sure that the new
type--and any type constructed based on it--requires structural
equality. If you suspect that the canonical type system is
miscomparing types, pass @code{--param verify-canonical-types=1} to
the compiler or configure with @code{--enable-checking} to force the
compiler to verify its canonical-type comparisons against the
structural comparisons; the compiler will then print any warnings if
the canonical types miscompare.

@item TYPE_STRUCTURAL_EQUALITY_P
This predicate holds when the node requires structural equality
checks, e.g., when @code{TYPE_CANONICAL} is @code{NULL_TREE}.

@item SET_TYPE_STRUCTURAL_EQUALITY
This macro states that the type node it is given requires structural
equality checks, e.g., it sets @code{TYPE_CANONICAL} to
@code{NULL_TREE}.

@item same_type_p
This predicate takes two types as input, and holds if they are the same
type.  For example, if one type is a @code{typedef} for the other, or
both are @code{typedef}s for the same type.  This predicate also holds if
the two trees given as input are simply copies of one another; i.e.,
there is no difference between them at the source level, but, for
whatever reason, a duplicate has been made in the representation.  You
should never use @code{==} (pointer equality) to compare types; always
use @code{same_type_p} instead.
@end ftable

Detailed below are the various kinds of types, and the macros that can
be used to access them.  Although other kinds of types are used
elsewhere in G++, the types described here are the only ones that you
will encounter while examining the intermediate representation.

@table @code
@item VOID_TYPE
用于表示@code{void}类型。 

@item INTEGER_TYPE
Used to represent the various integral types, including @code{char},
@code{short}, @code{int}, @code{long}, and @code{long long}.  This code
is not used for enumeration types, nor for the @code{bool} type.
The @code{TYPE_PRECISION} is the number of bits used in
the representation, represented as an @code{unsigned int}.  (Note that
in the general case this is not the same value as @code{TYPE_SIZE};
suppose that there were a 24-bit integer type, but that alignment
requirements for the ABI required 32-bit alignment.  Then,
@code{TYPE_SIZE} would be an @code{INTEGER_CST} for 32, while
@code{TYPE_PRECISION} would be 24.)  The integer type is unsigned if
@code{TYPE_UNSIGNED} holds; otherwise, it is signed.

The @code{TYPE_MIN_VALUE} is an @code{INTEGER_CST} for the smallest
integer that may be represented by this type.  Similarly, the
@code{TYPE_MAX_VALUE} is an @code{INTEGER_CST} for the largest integer
that may be represented by this type.

@item REAL_TYPE
Used to represent the @code{float}, @code{double}, and @code{long
double} types.  The number of bits in the floating-point representation
is given by @code{TYPE_PRECISION}, as in the @code{INTEGER_TYPE} case.

@item FIXED_POINT_TYPE
Used to represent the @code{short _Fract}, @code{_Fract}, @code{long
_Fract}, @code{long long _Fract}, @code{short _Accum}, @code{_Accum},
@code{long _Accum}, and @code{long long _Accum} types.  The number of bits
in the fixed-point representation is given by @code{TYPE_PRECISION},
as in the @code{INTEGER_TYPE} case.  There may be padding bits, fractional
bits and integral bits.  The number of fractional bits is given by
@code{TYPE_FBIT}, and the number of integral bits is given by @code{TYPE_IBIT}.
The fixed-point type is unsigned if @code{TYPE_UNSIGNED} holds; otherwise,
it is signed.
The fixed-point type is saturating if @code{TYPE_SATURATING} holds; otherwise,
it is not saturating.

@item COMPLEX_TYPE
Used to represent GCC built-in @code{__complex__} data types.  The
@code{TREE_TYPE} is the type of the real and imaginary parts.

@item ENUMERAL_TYPE
Used to represent an enumeration type.  The @code{TYPE_PRECISION} gives
(as an @code{int}), the number of bits used to represent the type.  If
there are no negative enumeration constants, @code{TYPE_UNSIGNED} will
hold.  The minimum and maximum enumeration constants may be obtained
with @code{TYPE_MIN_VALUE} and @code{TYPE_MAX_VALUE}, respectively; each
of these macros returns an @code{INTEGER_CST}.

The actual enumeration constants themselves may be obtained by looking
at the @code{TYPE_VALUES}.  This macro will return a @code{TREE_LIST},
containing the constants.  The @code{TREE_PURPOSE} of each node will be
an @code{IDENTIFIER_NODE} giving the name of the constant; the
@code{TREE_VALUE} will be an @code{INTEGER_CST} giving the value
assigned to that constant.  These constants will appear in the order in
which they were declared.  The @code{TREE_TYPE} of each of these
constants will be the type of enumeration type itself.

@item BOOLEAN_TYPE
用来表示@code{bool}类型。

@item POINTER_TYPE
Used to represent pointer types, and pointer to data member types.  The
@code{TREE_TYPE} gives the type to which this type points.  If the type
is a pointer to data member type, then @code{TYPE_PTRMEM_P} will hold.
For a pointer to data member type of the form @samp{T X::*},
@code{TYPE_PTRMEM_CLASS_TYPE} will be the type @code{X}, while
@code{TYPE_PTRMEM_POINTED_TO_TYPE} will be the type @code{T}.

@item REFERENCE_TYPE
Used to represent reference types.  The @code{TREE_TYPE} gives the type
to which this type refers.

@item FUNCTION_TYPE
Used to represent the type of non-member functions and of static member
functions.  The @code{TREE_TYPE} gives the return type of the function.
The @code{TYPE_ARG_TYPES} are a @code{TREE_LIST} of the argument types.
The @code{TREE_VALUE} of each node in this list is the type of the
corresponding argument; the @code{TREE_PURPOSE} is an expression for the
default argument value, if any.  If the last node in the list is
@code{void_list_node} (a @code{TREE_LIST} node whose @code{TREE_VALUE}
is the @code{void_type_node}), then functions of this type do not take
variable arguments.  Otherwise, they do take a variable number of
arguments.

Note that in C (but not in C++) a function declared like @code{void f()}
is an unprototyped function taking a variable number of arguments; the
@code{TYPE_ARG_TYPES} of such a function will be @code{NULL}.

@item METHOD_TYPE
Used to represent the type of a non-static member function.  Like a
@code{FUNCTION_TYPE}, the return type is given by the @code{TREE_TYPE}.
The type of @code{*this}, i.e., the class of which functions of this
type are a member, is given by the @code{TYPE_METHOD_BASETYPE}.  The
@code{TYPE_ARG_TYPES} is the parameter list, as for a
@code{FUNCTION_TYPE}, and includes the @code{this} argument.

@item ARRAY_TYPE
Used to represent array types.  The @code{TREE_TYPE} gives the type of
the elements in the array.  If the array-bound is present in the type,
the @code{TYPE_DOMAIN} is an @code{INTEGER_TYPE} whose
@code{TYPE_MIN_VALUE} and @code{TYPE_MAX_VALUE} will be the lower and
upper bounds of the array, respectively.  The @code{TYPE_MIN_VALUE} will
always be an @code{INTEGER_CST} for zero, while the
@code{TYPE_MAX_VALUE} will be one less than the number of elements in
the array, i.e., the highest value which may be used to index an element
in the array.

@item RECORD_TYPE
Used to represent @code{struct} and @code{class} types, as well as
pointers to member functions and similar constructs in other languages.
@code{TYPE_FIELDS} contains the items contained in this type, each of
which can be a @code{FIELD_DECL}, @code{VAR_DECL}, @code{CONST_DECL}, or
@code{TYPE_DECL}.  You may not make any assumptions about the ordering
of the fields in the type or whether one or more of them overlap.  If
@code{TYPE_PTRMEMFUNC_P} holds, then this type is a pointer-to-member
type.  In that case, the @code{TYPE_PTRMEMFUNC_FN_TYPE} is a
@code{POINTER_TYPE} pointing to a @code{METHOD_TYPE}.  The
@code{METHOD_TYPE} is the type of a function pointed to by the
pointer-to-member function.  If @code{TYPE_PTRMEMFUNC_P} does not hold,
this type is a class type.  For more information, see @pxref{Classes}.

@item UNION_TYPE
Used to represent @code{union} types.  Similar to @code{RECORD_TYPE}
except that all @code{FIELD_DECL} nodes in @code{TYPE_FIELD} start at
bit position zero.

@item QUAL_UNION_TYPE
Used to represent part of a variant record in Ada.  Similar to
@code{UNION_TYPE} except that each @code{FIELD_DECL} has a
@code{DECL_QUALIFIER} field, which contains a boolean expression that
indicates whether the field is present in the object.  The type will only
have one field, so each field's @code{DECL_QUALIFIER} is only evaluated
if none of the expressions in the previous fields in @code{TYPE_FIELDS}
are nonzero.  Normally these expressions will reference a field in the
outer object using a @code{PLACEHOLDER_EXPR}.

@item UNKNOWN_TYPE
This node is used to represent a type the knowledge of which is
insufficient for a sound processing.

@item OFFSET_TYPE
This node is used to represent a pointer-to-data member.  For a data
member @code{X::m} the @code{TYPE_OFFSET_BASETYPE} is @code{X} and the
@code{TREE_TYPE} is the type of @code{m}.

@item TYPENAME_TYPE
Used to represent a construct of the form @code{typename T::A}.  The
@code{TYPE_CONTEXT} is @code{T}; the @code{TYPE_NAME} is an
@code{IDENTIFIER_NODE} for @code{A}.  If the type is specified via a
template-id, then @code{TYPENAME_TYPE_FULLNAME} yields a
@code{TEMPLATE_ID_EXPR}.  The @code{TREE_TYPE} is non-@code{NULL} if the
node is implicitly generated in support for the implicit typename
extension; in which case the @code{TREE_TYPE} is a type node for the
base-class.

@item TYPEOF_TYPE
用于表示@code{__typeof__}扩展。@code{TYPE_FIELDS}为被表示的类型的表达式。 
@end table

有些变量，它们的值表示基本的类型。这包括：
@table @code
@item void_type_node
@code{void}节点。

@item integer_type_node
@code{int}节点。

@item unsigned_type_node.
@code{unsigned int}节点。

@item char_type_node.
@code{char}节点。
@end table
@noindent
有时使用@code{same_type_p}将这些变量和手头的类型进行比较会很有帮助。 

@c ---------------------------------------------------------------------
@c Scopes
@c ---------------------------------------------------------------------

@node 作用域
@section 作用域
@cindex namespace, class, scope

整个中间表示的根是变量@code{global_namespace}。
这是在C++源代码中由@code{::}描述的命名空间。
所有其它命名空间，类型，变量，函数等，都能够从这里开始查找而获得。

除了命名空间以外，C++中另一个高层次的作用域结构是类。
（在该手册中，术语@dfn{class}用来表示ANSI/ISO C++标准中的@code{class}类型；
这包括用@code{class}, @code{struct}和@code{union}关键字定义的类型。）

@menu
* 命名空间::     成员函数，类型等。
* 类::           成员，基类，友员等。
@end menu

@c ---------------------------------------------------------------------
@c Namespaces
@c ---------------------------------------------------------------------

@node 命名空间
@subsection 命名空间
@cindex namespace
@tindex NAMESPACE_DECL

命名空间由@code{NAMESPACE_DECL}节点表示。

然而，除了实际上是作为根表示以外，全局命名空间与其它命名空间没有区别。
因此，在下文中，我们描述的是普遍的命名空间，而不是特定的全局命名空间。

下列宏和函数可以用于@code{NAMESPACE_DECL}:

@ftable @code
@item DECL_NAME
该宏用于获得@code{IDENTIFIER_NODE}相应的命名空间的未限定名
（参见 @ref{标识符}）。
全局命名空间的名字为@samp{::}，虽然在C++中全局命名空间是没有名字的。
然而，你应该使用与@code{global_namespace}比较的方式，
而不是用@code{DECL_NAME}来确定命名空间是否为全局的。
一个未命名的命名空间，其 @code{DECL_NAME}等于@code{anonymous_namespace_name}。
在一个单独的转换单元中，所有未命名空间将具有同一名字。 

@item DECL_CONTEXT
该宏返回闭包的（enclosing）命名空间。
@code{global_namespace}的@code{DECL_CONTEXT}为@code{NULL_TREE}。 

@item DECL_NAMESPACE_ALIAS
如果该声明是一个命名空间的别名，
则@code{DECL_NAMESPACE_ALIAS}为该别名所针对的命名空间。

不要对别名命名空间尝试使用@code{cp_namespace_decls}。
相反的，沿着@code{DECL_NAMESPACE_ALIAS}链直到一个普通的，非别名的命名空间，
然后在那里调用@code{cp_namespace_decls}。

@item DECL_NAMESPACE_STD_P
该断言当命名空间为特殊的@code{::std}命名空间时有效。 

@item cp_namespace_decls
该函数将返回包含在命名空间中的声明，包括类型，重载函数，其它命名空间等等。
如果没有声明，该函数将返回@code{NULL_TREE}。
声明通过它们的@code{TREE_CHAIN}域连在一起。

虽然这个链表中的大多数实体将为声明，但也可能会出现@code{TREE_LIST}。
这种情况下，@code{TREE_VALUE}将为一个@code{OVERLOAD}。
@code{TREE_PURPOSE}的值未指定；后端应该忽略这个值。
至于由@code{cp_namespace_decls}返回的其它种类的声明，
@code{TREE_CHAIN}将会指向该链表中的下一个声明。

关于可以出现在该链表中的各种声明的更多信息，参见 @ref{声明}。
一些声明将不会出现在该链表中。
特别是，@code{FIELD_DECL}, @code{LABEL_DECL}和@code{PARM_DECL}节点。

该函数不能用于设置了@code{DECL_NAMESPACE_ALIAS}的命名空间。

@end ftable

@c ---------------------------------------------------------------------
@c Classes
@c ---------------------------------------------------------------------

@node 类
@subsection 类
@cindex class
@tindex RECORD_TYPE
@tindex UNION_TYPE
@findex CLASSTYPE_DECLARED_CLASS
@findex TYPE_BINFO
@findex BINFO_TYPE
@findex TYPE_FIELDS
@findex TYPE_VFIELD
@findex TYPE_METHODS

类的类型被表示为@code{RECORD_TYPE}或者@code{UNION_TYPE}。
使用@code{union}标签声明的类由@code{UNION_TYPE}来表示，
而使用@code{struct}或者@code{class}标签声明的类由@code{RECORD_TYPE}来表示。
可以使用@code{CLASSTYPE_DECLARED_CLASS}宏来判定一个特定类型是
@code{class}的还是@code{struct}的。
该宏只在类使用@code{class}标签声明时才为真。

几乎所有非函数的成员都在@code{TYPE_FIELDS}列表中。
给出一个成员，可以通过@code{TREE_CHAIN}来找到下一个。
不要依赖于在该链表中出现的域的顺序。链表中的所有节点将为@samp{DECL}节点。
@code{FIELD_DECL}用于表示非静态数据成员，@code{VAR_DECL}用于表示静态数据成员，
而@code{TYPE_DECL}用于表示类型。注意如果在类中声明了枚举类型，
则用于枚举常量的@code{CONST_DECL}将会出现在该链表中。
（当然，枚举类型的@code{TYPE_DECL}也会出现。）链表中没有基类的实体。
特别是，对于一个对象的基类部分“base-class portion”，没有@code{FIELD_DECL}。

@code{TYPE_VFIELD}是编译器生成的域用于指向虚函数表。
它有可能会出现在@code{TYPE_FIELDS}链表中。
然而，后端应该处理@code{TYPE_VFIELD}，
就像@code{TYPE_FIELDS}链表中所有其它实体一样。

函数成员在@code{TYPE_METHODS}链表中。
同样，后续成员可以通过@code{TREE_CHAIN}域来找到。
如果函数是重载的，每个重载函数都会出现；
@code{OVERLOAD}节点不会出现在@code{TYPE_METHODS}链表上。
隐式声明的函数（包括缺省构造函数，复制构造函数，赋值操作和析构函数）
也会出现在该链表中。

每个类都具有一个相关的@dfn{binfo}，其能够通过@code{TYPE_BINFO}获得。
Binfos用于表示基类。由@code{TYPE_BINFO}给出的binfo是退化情况，
让每个类被考虑为它自己的基类。

对基类型的访问可以通过@code{BINFO_BASE_ACCESS}。
这将产生@code{access_public_node}, @code{access_private_node}或
@code{access_protected_node}。
如果基类总是public的，@code{BINFO_BASE_ACCESSES}可以为@code{NULL}。

@code{BINFO_VIRTUAL_P}用于指定binfo是否为虚继承。
其它标识，@code{BINFO_MARKED_P}和
@code{BINFO_FLAG_1}到@code{BINFO_FLAG_6}可以用于语言特定用途。

下列宏可以用在表示class类型的树节点上。

@ftable @code
@item LOCAL_CLASS_P
该断言当是局部类时有效，即在函数体内声明的类。 

@item TYPE_POLYMORPHIC_P
该断言当类至少具有一个虚函数（声明的或者继承的）时有效。 

@item TYPE_HAS_DEFAULT_CONSTRUCTOR
该断言当参数表示具有缺省构造函数的class类型时有效。 

@item CLASSTYPE_HAS_MUTABLE
@itemx TYPE_HAS_MUTABLE_P
这些断言表示了一个class-type具有mutable数据成员。 

@item CLASSTYPE_NON_POD_P
该断言表示了不是POD的class-types。 

@item TYPE_HAS_NEW_OPERATOR
该断言表示一个class-type定义了@code{operator new}。

@item TYPE_HAS_ARRAY_NEW_OPERATOR
该断言表示一个class-type定义了@code{operator new[]}。

@item TYPE_OVERLOADS_CALL_EXPR
该断言表示class-type重载了函数调用@code{operator()}。

@item TYPE_OVERLOADS_ARRAY_REF
该断言表示class-type重载了@code{operator[]}。

@item TYPE_OVERLOADS_ARROW
该断言表示class-type重载了@code{operator->}。
@end ftable

@c ---------------------------------------------------------------------
@c Declarations
@c ---------------------------------------------------------------------

@node 声明
@section 声明
@cindex declaration
@cindex variable
@cindex type declaration
@tindex LABEL_DECL
@tindex CONST_DECL
@tindex TYPE_DECL
@tindex VAR_DECL
@tindex PARM_DECL
@tindex FIELD_DECL
@tindex NAMESPACE_DECL
@tindex RESULT_DECL
@tindex TEMPLATE_DECL
@tindex THUNK_DECL
@tindex USING_DECL
@findex THUNK_DELTA
@findex DECL_INITIAL
@findex DECL_SIZE
@findex DECL_ALIGN
@findex DECL_EXTERNAL
这一节涵盖了出现在内部表示中的各种声明。
函数声明（由@code{FUNCTION_DECL}节点表示）除外，其在@ref{函数}一节中描述。

@menu
* 关于声明的操作::  作用于声明的宏和函数。
* 内部结构::        声明节点是如何表示的。 
@end menu

@node 关于声明的操作
@subsection 关于声明的操作
一些宏可以用于任何种类的声明。这包括：
@ftable @code
@item DECL_NAME
This macro returns an @code{IDENTIFIER_NODE} giving the name of the
entity.

@item TREE_TYPE
This macro returns the type of the entity declared.

@item TREE_FILENAME
This macro returns the name of the file in which the entity was
declared, as a @code{char*}.  For an entity declared implicitly by the
compiler (like @code{__builtin_memcpy}), this will be the string
@code{"<internal>"}.

@item TREE_LINENO
This macro returns the line number at which the entity was declared, as
an @code{int}.

@item DECL_ARTIFICIAL
This predicate holds if the declaration was implicitly generated by the
compiler.  For example, this predicate will hold of an implicitly
declared member function, or of the @code{TYPE_DECL} implicitly
generated for a class type.  Recall that in C++ code like:
@smallexample
struct S @{@};
@end smallexample
@noindent
is roughly equivalent to C code like:
@smallexample
struct S @{@};
typedef struct S S;
@end smallexample
The implicitly generated @code{typedef} declaration is represented by a
@code{TYPE_DECL} for which @code{DECL_ARTIFICIAL} holds.

@item DECL_NAMESPACE_SCOPE_P
This predicate holds if the entity was declared at a namespace scope.

@item DECL_CLASS_SCOPE_P
This predicate holds if the entity was declared at a class scope.

@item DECL_FUNCTION_SCOPE_P
This predicate holds if the entity was declared inside a function
body.

@end ftable

The various kinds of declarations include:
@table @code
@item LABEL_DECL
These nodes are used to represent labels in function bodies.  For more
information, see @ref{Functions}.  These nodes only appear in block
scopes.

@item CONST_DECL
These nodes are used to represent enumeration constants.  The value of
the constant is given by @code{DECL_INITIAL} which will be an
@code{INTEGER_CST} with the same type as the @code{TREE_TYPE} of the
@code{CONST_DECL}, i.e., an @code{ENUMERAL_TYPE}.

@item RESULT_DECL
These nodes represent the value returned by a function.  When a value is
assigned to a @code{RESULT_DECL}, that indicates that the value should
be returned, via bitwise copy, by the function.  You can use
@code{DECL_SIZE} and @code{DECL_ALIGN} on a @code{RESULT_DECL}, just as
with a @code{VAR_DECL}.

@item TYPE_DECL
These nodes represent @code{typedef} declarations.  The @code{TREE_TYPE}
is the type declared to have the name given by @code{DECL_NAME}.  In
some cases, there is no associated name.

@item VAR_DECL
These nodes represent variables with namespace or block scope, as well
as static data members.  The @code{DECL_SIZE} and @code{DECL_ALIGN} are
analogous to @code{TYPE_SIZE} and @code{TYPE_ALIGN}.  For a declaration,
you should always use the @code{DECL_SIZE} and @code{DECL_ALIGN} rather
than the @code{TYPE_SIZE} and @code{TYPE_ALIGN} given by the
@code{TREE_TYPE}, since special attributes may have been applied to the
variable to give it a particular size and alignment.  You may use the
predicates @code{DECL_THIS_STATIC} or @code{DECL_THIS_EXTERN} to test
whether the storage class specifiers @code{static} or @code{extern} were
used to declare a variable.

If this variable is initialized (but does not require a constructor),
the @code{DECL_INITIAL} will be an expression for the initializer.  The
initializer should be evaluated, and a bitwise copy into the variable
performed.  If the @code{DECL_INITIAL} is the @code{error_mark_node},
there is an initializer, but it is given by an explicit statement later
in the code; no bitwise copy is required.

GCC provides an extension that allows either automatic variables, or
global variables, to be placed in particular registers.  This extension
is being used for a particular @code{VAR_DECL} if @code{DECL_REGISTER}
holds for the @code{VAR_DECL}, and if @code{DECL_ASSEMBLER_NAME} is not
equal to @code{DECL_NAME}.  In that case, @code{DECL_ASSEMBLER_NAME} is
the name of the register into which the variable will be placed.

@item PARM_DECL
Used to represent a parameter to a function.  Treat these nodes
similarly to @code{VAR_DECL} nodes.  These nodes only appear in the
@code{DECL_ARGUMENTS} for a @code{FUNCTION_DECL}.

The @code{DECL_ARG_TYPE} for a @code{PARM_DECL} is the type that will
actually be used when a value is passed to this function.  It may be a
wider type than the @code{TREE_TYPE} of the parameter; for example, the
ordinary type might be @code{short} while the @code{DECL_ARG_TYPE} is
@code{int}.

@item FIELD_DECL
These nodes represent non-static data members.  The @code{DECL_SIZE} and
@code{DECL_ALIGN} behave as for @code{VAR_DECL} nodes.  
The position of the field within the parent record is specified by a 
combination of three attributes.  @code{DECL_FIELD_OFFSET} is the position,
counting in bytes, of the @code{DECL_OFFSET_ALIGN}-bit sized word containing
the bit of the field closest to the beginning of the structure.  
@code{DECL_FIELD_BIT_OFFSET} is the bit offset of the first bit of the field
within this word; this may be nonzero even for fields that are not bit-fields,
since @code{DECL_OFFSET_ALIGN} may be greater than the natural alignment
of the field's type.

If @code{DECL_C_BIT_FIELD} holds, this field is a bit-field.  In a bit-field,
@code{DECL_BIT_FIELD_TYPE} also contains the type that was originally
specified for it, while DECL_TYPE may be a modified type with lesser precision,
according to the size of the bit field.

@item NAMESPACE_DECL
@xref{Namespaces}.

@item TEMPLATE_DECL

These nodes are used to represent class, function, and variable (static
data member) templates.  The @code{DECL_TEMPLATE_SPECIALIZATIONS} are a
@code{TREE_LIST}.  The @code{TREE_VALUE} of each node in the list is a
@code{TEMPLATE_DECL}s or @code{FUNCTION_DECL}s representing
specializations (including instantiations) of this template.  Back ends
can safely ignore @code{TEMPLATE_DECL}s, but should examine
@code{FUNCTION_DECL} nodes on the specializations list just as they
would ordinary @code{FUNCTION_DECL} nodes.

For a class template, the @code{DECL_TEMPLATE_INSTANTIATIONS} list
contains the instantiations.  The @code{TREE_VALUE} of each node is an
instantiation of the class.  The @code{DECL_TEMPLATE_SPECIALIZATIONS}
contains partial specializations of the class.

@item USING_DECL

Back ends can safely ignore these nodes.

@end table

@node 内部结构
@subsection 内部结构

@code{DECL}节点在内部被表示为层次结构体。

@menu
* 目前的结构层次::     目前DECL节点的结构层次。
* 添加新的DECL节点类型:: 如何给前端添加一个新的DECL节点。
@end menu

@node 目前的结构层次
@subsubsection 目前的结构层次

@table @code

@item struct tree_decl_minimal
这是用于继承的最小结构体，从而使得@code{DECL}宏更加通用。
所包含的域为一个唯一的ID，源位置，上下文和名字。 

@item struct tree_decl_common
该结构体继承于@code{struct tree_decl_minimal}。
包含了大多@code{DECL}节点需要的域，像存储对齐信息，机器模式，大小和属性的域。 

@item struct tree_field_decl
该结构体继承于@code{struct tree_decl_common}。用于表示@code{FIELD_DECL}。

@item struct tree_label_decl
该结构体继承于@code{struct tree_decl_common}。用于表示@code{LABEL_DECL}。 

@item struct tree_translation_unit_decl
该结构体继承于@code{struct tree_decl_common}。
用于表示@code{TRANSLATION_UNIT_DECL}。 

@item struct tree_decl_with_rtl
该结构体继承于@code{struct tree_decl_common}。
包含了一个存储与@code{DECL}节点相关的低层次RTL。

@item struct tree_result_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{RESULT_DECL}。 

@item struct tree_const_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{CONST_DECL}。 

@item struct tree_parm_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{PARM_DECL}。 

@item struct tree_decl_with_vis
该结构体继承于@code{struct tree_decl_with_rtl}。
包含了存储可视性信息所需要的域，还有一个section名和汇编名。 

@item struct tree_var_decl
该结构体继承于@code{struct tree_decl_with_vis}。
用于表示@code{VAR_DECL}。

@item struct tree_function_decl
该结构体继承于@code{struct tree_decl_with_vis}。
用于表示@code{FUNCTION_DECL}。
@end table

@node 添加新的DECL节点类型
@subsubsection 添加新的DECL节点类型

增加一个新的@code{DECL}树包含下列步骤

@table @asis

@item Add a new tree code for the @code{DECL} node
For language specific @code{DECL} nodes, there is a @file{.def} file
in each frontend directory where the tree code should be added.
For @code{DECL} nodes that are part of the middle-end, the code should
be added to @file{tree.def}.

@item Create a new structure type for the @code{DECL} node
These structures should inherit from one of the existing structures in
the language hierarchy by using that structure as the first member.

@smallexample
struct tree_foo_decl
@{
   struct tree_decl_with_vis common;
@}
@end smallexample

Would create a structure name @code{tree_foo_decl} that inherits from
@code{struct tree_decl_with_vis}.

For language specific @code{DECL} nodes, this new structure type
should go in the appropriate @file{.h} file.
For @code{DECL} nodes that are part of the middle-end, the structure
type should go in @file{tree.h}.

@item Add a member to the tree structure enumerator for the node
For garbage collection and dynamic checking purposes, each @code{DECL}
node structure type is required to have a unique enumerator value
specified with it.
For language specific @code{DECL} nodes, this new enumerator value
should go in the appropriate @file{.def} file.
For @code{DECL} nodes that are part of the middle-end, the enumerator
values are specified in @file{treestruct.def}.

@item Update @code{union tree_node}
In order to make your new structure type usable, it must be added to
@code{union tree_node}.
For language specific @code{DECL} nodes, a new entry should be added
to the appropriate @file{.h} file of the form
@smallexample
  struct tree_foo_decl GTY ((tag ("TS_VAR_DECL"))) foo_decl;
@end smallexample
For @code{DECL} nodes that are part of the middle-end, the additional
member goes directly into @code{union tree_node} in @file{tree.h}.

@item Update dynamic checking info
In order to be able to check whether accessing a named portion of
@code{union tree_node} is legal, and whether a certain @code{DECL} node
contains one of the enumerated @code{DECL} node structures in the
hierarchy, a simple lookup table is used.
This lookup table needs to be kept up to date with the tree structure
hierarchy, or else checking and containment macros will fail
inappropriately.

For language specific @code{DECL} nodes, their is an @code{init_ts}
function in an appropriate @file{.c} file, which initializes the lookup
table.
Code setting up the table for new @code{DECL} nodes should be added
there.
For each @code{DECL} tree code and enumerator value representing a
member of the inheritance  hierarchy, the table should contain 1 if
that tree code inherits (directly or indirectly) from that member.
Thus, a @code{FOO_DECL} node derived from @code{struct decl_with_rtl},
and enumerator value @code{TS_FOO_DECL}, would be set up as follows
@smallexample
tree_contains_struct[FOO_DECL][TS_FOO_DECL] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_WRTL] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_COMMON] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_MINIMAL] = 1;
@end smallexample

For @code{DECL} nodes that are part of the middle-end, the setup code
goes into @file{tree.c}.

@item Add macros to access any new fields and flags

Each added field or flag should have a macro that is used to access
it, that performs appropriate checking to ensure only the right type of
@code{DECL} nodes access the field.

These macros generally take the following form
@smallexample
#define FOO_DECL_FIELDNAME(NODE) FOO_DECL_CHECK(NODE)->foo_decl.fieldname
@end smallexample
However, if the structure is simply a base class for further
structures, something like the following should be used
@smallexample
#define BASE_STRUCT_CHECK(T) CONTAINS_STRUCT_CHECK(T, TS_BASE_STRUCT)
#define BASE_STRUCT_FIELDNAME(NODE) \
   (BASE_STRUCT_CHECK(NODE)->base_struct.fieldname
@end smallexample

@end table


@c ---------------------------------------------------------------------
@c Functions
@c ---------------------------------------------------------------------

@node 函数
@section 函数
@cindex function
@tindex FUNCTION_DECL
@tindex OVERLOAD
@findex OVL_CURRENT
@findex OVL_NEXT

函数由@code{FUNCTION_DECL}节点表示。
重载函数集有时通过一个@code{OVERLOAD}节点来表示。

@code{OVERLOAD}节点不是一个声明。
所以没有@samp{DECL_}宏用于@code{OVERLOAD}。
@code{OVERLOAD}节点类似于一个@code{TREE_LIST}。
使用@code{OVL_CURRENT}来获得@code{OVERLOAD}节点关联的函数；
使用@code{OVL_NEXT}来获得重载函数列表中下一个@code{OVERLOAD}节点。
宏@code{OVL_CURRENT}和@code{OVL_NEXT}实际上是多态的；
你可以用它们工作于@code{FUNCTION_DECL}节点上，就像在重载上一样。
在@code{FUNCTION_DECL}的情况下，@code{OVL_CURRENT}将总是返回函数本身，
@code{OVL_NEXT}将总是为@code{NULL_TREE}。

要确定函数的作用域，可以使用@code{DECL_CONTEXT}宏。
该宏将返回函数作为其成员的类（或者@code{RECORD_TYPE}或者@code{UNION_TYPE}）
或命名空间（@code{NAMESPACE_DECL}）。对于虚函数，
该宏返回函数被实际定义的类，而不是其声明所在的基类。

如果友函数定义在类的作用域里，
宏@code{DECL_FRIEND_CONTEXT}可以用来判定其定义所在的类。例如，在

@smallexample
class C @{ friend void f() @{@} @};
@end smallexample
@noindent
中，@code{f}的@code{DECL_CONTEXT}将为@code{global_namespace}，
而@code{C}的@code{DECL_FRIEND_CONTEXT}将为@code{RECORD_TYPE}。

在C中，函数的@code{DECL_CONTEXT}可能为另一个函数。
这表示正在使用GNU嵌套函数扩展功能。关于嵌套函数语法的详细内容，
参见GCC手册。嵌套函数可以引用其所包含的函数的局部变量。
这样的引用没有在树结构体里被显示的标记。
如果被引用@code{VAR_DECL}的@code{DECL_CONTEXT}与当前被处理的函数不相同，
并且@code{DECL_EXTERNAL}和@code{DECL_STATIC}都没有持有内容，
则该引用是针对包含的函数的局部变量，后端必须采取合适的行为。

@menu
* 函数基础::   函数名，连接等等。
* 函数体::     组成函数体的语句。
@end menu

@c ---------------------------------------------------------------------
@c Function Basics
@c ---------------------------------------------------------------------

@node 函数基础
@subsection 函数基础
@cindex constructor
@cindex destructor
@cindex copy constructor
@cindex assignment operator
@cindex linkage
@findex DECL_NAME
@findex DECL_ASSEMBLER_NAME
@findex TREE_PUBLIC
@findex DECL_LINKONCE_P
@findex DECL_FUNCTION_MEMBER_P
@findex DECL_CONSTRUCTOR_P
@findex DECL_DESTRUCTOR_P
@findex DECL_OVERLOADED_OPERATOR_P
@findex DECL_CONV_FN_P
@findex DECL_ARTIFICIAL
@findex DECL_GLOBAL_CTOR_P
@findex DECL_GLOBAL_DTOR_P
@findex GLOBAL_INIT_PRIORITY
@findex DECL_FUNCTION_SPECIFIC_TARGET
@findex DECL_FUNCTION_SPECIFIC_OPTIMIZATION

下列宏和函数能够用于@code{FUNCTION_DECL}:
@ftable @code
@item DECL_MAIN_P
该断言判断一个函数是否为程序的入口点@code{::code}。 

@item DECL_NAME
该宏返回函数未限定的名字，为一个@code{IDENTIFIER_NODE}。
对于一个函数模版的实例，@code{DECL_NAME}为模版的未限定名字，
而不是类似@code{f<int>}的东西。当用在编译器隐式生成的构造函数，
析构函数，重载操作符，或者类型转换符，或者任何函数时，
@code{DECL_NAME}的值未定义。关于可以用来区分这些情况的宏，参见下面。 

@item DECL_ASSEMBLER_NAME
This macro returns the mangled name of the function, also an
@code{IDENTIFIER_NODE}.  This name does not contain leading underscores
on systems that prefix all identifiers with underscores.  The mangled
name is computed in the same way on all platforms; if special processing
is required to deal with the object file format used on a particular
platform, it is the responsibility of the back end to perform those
modifications.  (Of course, the back end should not modify
@code{DECL_ASSEMBLER_NAME} itself.)

Using @code{DECL_ASSEMBLER_NAME} will cause additional memory to be
allocated (for the mangled name of the entity) so it should be used
only when emitting assembly code.  It should not be used within the
optimizers to determine whether or not two declarations are the same,
even though some of the existing optimizers do use it in that way.
These uses will be removed over time.

@item DECL_EXTERNAL
该断言判断函数是否未定义。 

@item TREE_PUBLIC
该断言判断函数是否具有外部连接。 

@item DECL_LOCAL_FUNCTION_P
该断言判断函数是否声明在块作用域中，即使具有全局作用域。

@item DECL_ANTICIPATED
该断言判断函数是否为built-in函数，并且函数原形没有显示声明。 

@item DECL_EXTERN_C_FUNCTION_P
该断言判断函数是否声明为`@code{extern "C"}'函数。 

@item DECL_LINKONCE_P
该宏用来判断该函数是否会在不同的转换单元产生多个副本。
合并不同副本是连接器的责任。
模版实例是使用@code{DECL_LINKONCE_P}最常见的例子。
G++会在需要它们的所有转换单元里实例化模版，
然后依赖连接器去移除重复的实例。 

FIXME: 该宏还没有实现。

@item DECL_FUNCTION_MEMBER_P
该宏用来判断函数是否为一个类的成员，而不是命名空间的成员。 

@item DECL_STATIC_FUNCTION_P
该断言用来判断函数是否为一个静态成员函数。 

@item DECL_NONSTATIC_MEMBER_FUNCTION_P
该宏用来判断是否为一个非静态成员函数。 

@item DECL_CONST_MEMFUNC_P
该断言用来判断是否为@code{const}成员函数。 

@item DECL_VOLATILE_MEMFUNC_P
该断言用来判断是否为@code{volatile}成员函数。 

@item DECL_CONSTRUCTOR_P
该宏用来判断函数是否为一个构造函数。 

@item DECL_NONCONVERTING_P
该断言用来判断构造函数是否为一个非转换构造函数。 

@item DECL_COMPLETE_CONSTRUCTOR_P
该断言用来判断函数是否为完全类型的对象的构造函数。 

@item DECL_BASE_CONSTRUCTOR_P
该断言用来判断函数是否为一个基类的子对象的构造函数。 

@item DECL_COPY_CONSTRUCTOR_P
该断言用来判断函数是否为一个复制构造函数。 

@item DECL_DESTRUCTOR_P
该宏用来判断函数是否为一个析构函数。 

@item DECL_COMPLETE_DESTRUCTOR_P
该断言用来判断函数是否为一个完全类型的对象的析构函数。 

@item DECL_OVERLOADED_OPERATOR_P
该宏用来判断函数是否为一个重载操作符。 

@item DECL_CONV_FN_P
该宏用来判断函数是否为一个类型转换操作符。 

@item DECL_GLOBAL_CTOR_P
该断言用来判断函数是否为一个文件作用域的初始化函数。 

@item DECL_GLOBAL_DTOR_P
该断言用来判断函数是否为一个文件作用域的结束化函数。 

@item DECL_THUNK_P
This predicate holds if the function is a thunk.

These functions represent stub code that adjusts the @code{this} pointer
and then jumps to another function.  When the jumped-to function
returns, control is transferred directly to the caller, without
returning to the thunk.  The first parameter to the thunk is always the
@code{this} pointer; the thunk should add @code{THUNK_DELTA} to this
value.  (The @code{THUNK_DELTA} is an @code{int}, not an
@code{INTEGER_CST}.)

Then, if @code{THUNK_VCALL_OFFSET} (an @code{INTEGER_CST}) is nonzero
the adjusted @code{this} pointer must be adjusted again.  The complete
calculation is given by the following pseudo-code:

@smallexample
this += THUNK_DELTA
if (THUNK_VCALL_OFFSET)
  this += (*((ptrdiff_t **) this))[THUNK_VCALL_OFFSET]
@end smallexample

Finally, the thunk should jump to the location given
by @code{DECL_INITIAL}; this will always be an expression for the
address of a function.

@item DECL_NON_THUNK_FUNCTION_P
该断言用来判断函数@emph{不是}一个thunk函数。 

@item GLOBAL_INIT_PRIORITY
如果DECL_GLOBAL_CTOR_P或者DECL_GLOBAL_DTOR_P有效，则该宏给出了函数的初始优先级。连接器将设法安排 DECL_GLOBAL_CTOR_P所保存的所有的函数在递增的顺序下运行，在main被调用之前。当程序退出时，DECL_GLOBAL_DTOR_P所保存的所有函数按照相反的顺序执行。

If either @code{DECL_GLOBAL_CTOR_P} or @code{DECL_GLOBAL_DTOR_P} holds,
then this gives the initialization priority for the function.  The
linker will arrange that all functions for which
@code{DECL_GLOBAL_CTOR_P} holds are run in increasing order of priority
before @code{main} is called.  When the program exits, all functions for
which @code{DECL_GLOBAL_DTOR_P} holds are run in the reverse order.

@item DECL_ARTIFICIAL
该宏保存了函数是否由编译器隐式的生成，而不是被显式的生成。
除了隐式的生成的类成员函数以外，该宏还保存了创建的特定函数，
用来实现静态初始化和析构，来计算运行时信息等等。 

@item DECL_ARGUMENTS
该宏返回函数第一个参数的@code{PARM_DECL}。
后续的@code{PARM_DECL}节点可以通过@code{TREE_CHAIN}来获得。

@item DECL_RESULT
该函数返回函数的@code{RESULT_DECL}。

@item TREE_TYPE
该宏返回函数的@code{FUNCTION_TYPE}或@code{METHOD_TYPE}。

@item TYPE_RAISES_EXCEPTIONS
该宏返回（成员）函数可以引起的异常列表。返回的列表，如果不是NULL，则为TREE_VALUE代表一个类型的节点组成。 
This macro returns the list of exceptions that a (member-)function can
raise.  The returned list, if non @code{NULL}, is comprised of nodes
whose @code{TREE_VALUE} represents a type.

@item TYPE_NOTHROW_P
该断言用来判断是否是使用`@code{()}'形式来指定异常的参数。 

@item DECL_ARRAY_DELETE_OPERATOR_P
该断言用来判断函数是否为一个重载的@code{operator delete[]}。

@item DECL_FUNCTION_SPECIFIC_TARGET
This macro returns a tree node that holds the target options that are
to be used to compile this particular function or @code{NULL_TREE} if
the function is to be compiled with the target options specified on
the command line.

@item DECL_FUNCTION_SPECIFIC_OPTIMIZATION
This macro returns a tree node that holds the optimization options
that are to be used to compile this particular function or
@code{NULL_TREE} if the function is to be compiled with the
optimization options specified on the command line.
@end ftable

@c ---------------------------------------------------------------------
@c Function Bodies
@c ---------------------------------------------------------------------

@node 函数体
@subsection 函数体
@cindex function body
@cindex statements
@tindex BREAK_STMT
@tindex CLEANUP_STMT
@findex CLEANUP_DECL
@findex CLEANUP_EXPR
@tindex CONTINUE_STMT
@tindex DECL_STMT
@findex DECL_STMT_DECL
@tindex DO_STMT
@findex DO_BODY
@findex DO_COND
@tindex EMPTY_CLASS_EXPR
@tindex EXPR_STMT
@findex EXPR_STMT_EXPR
@tindex FOR_STMT
@findex FOR_INIT_STMT
@findex FOR_COND
@findex FOR_EXPR
@findex FOR_BODY
@tindex HANDLER
@tindex IF_STMT
@findex IF_COND
@findex THEN_CLAUSE
@findex ELSE_CLAUSE
@tindex RETURN_STMT
@findex RETURN_EXPR
@tindex SUBOBJECT
@findex SUBOBJECT_CLEANUP
@tindex SWITCH_STMT
@findex SWITCH_COND
@findex SWITCH_BODY
@tindex TRY_BLOCK
@findex TRY_STMTS
@findex TRY_HANDLERS
@findex HANDLER_PARMS
@findex HANDLER_BODY
@findex USING_STMT
@tindex WHILE_STMT
@findex WHILE_BODY
@findex WHILE_COND

在当前转换单元中定义的函数将会有一个非@code{NULL}的@code{DECL_INITIAL}。
但是，后端不应该使用@code{DECL_INITIAL}给出的该特定值。

宏@code{DECL_SAVED_TREE}将会给出完整的函数体。

@subsubsection 语句

C和C++前端，使用了对应于所有源级的语句构造的树节点。
这些都列举在这里，并附上能够用来获得它们的信息的各种宏的列表。
有一些宏能用于所有的语句：

@ftable @code
@item STMT_IS_FULL_EXPR_P
在C++里，语句通常构成“充分表达式（full expressions）”；
在语句中创建的临时事物会在声明完成时被销毁。
然而，G++有时通过语句来表示表达式；
这些语句将不会设置@code{STMT_IS_FULL_EXPR_P}。
在这样的语句中创建的临时事物将会在最内层设置了
@code{STMT_IS_FULL_EXPR_P}的语句退出时被销毁。
@end ftable

这里有一个各种语句节点的列表，以及访问它们的宏。
该文档描述了在非模板函数（包括模板函数的实例）中这些节点的用法。
在模板函数里，使用相同的节点，但是有时方法略有不同。

许多语句具有子语句。例如，一个@code{while}循环将会有一个循环体，
其本身也是一个语句。如果子语句是@code{NULL_TREE}，
则被认为相当于一个@code{;}组成的语句，即一个表达式语句，其中表达式为空。
一个子语句实际上可以为一个语句列表，通过它们的@code{TREE_CHAIN}连接一起。
所以，你应该总是通过循环所有的子语句来处理语句树，像这样：

@smallexample
void process_stmt (stmt)
     tree stmt;
@{
  while (stmt)
    @{
      switch (TREE_CODE (stmt))
        @{
        case IF_STMT:
          process_stmt (THEN_CLAUSE (stmt));
          /* @r{More processing here.}  */
          break;

        @dots{}
        @}

      stmt = TREE_CHAIN (stmt);
    @}
@}
@end smallexample
换句话说，虽然C++中@code{if}语句的@code{then}子句可以只是一个语句，
但中间表示有时会使用多个语句连接在一起。

@table @code
@item ASM_EXPR
用来表示一条内联的汇编语句。一条内联汇编语句形如： 
@smallexample
asm ("mov x, y");
@end smallexample
@code{ASM_STRING}宏将会为@code{"mov x, y"}返回一个@code{STRING_CST}节点。
如果原始的语句使用了扩展汇编语法，则@code{ASM_OUTPUTS}, 
@code{ASM_INPUTS}和@code{ASM_CLOBBERS}为用@code{STRING_CST}表示的语句的输出，
输入和clobber。扩展汇编语法形如：

@smallexample
asm ("fsinx %1,%0" : "=f" (result) : "f" (angle));
@end smallexample
第一个字符串是@code{ASM_STRING}，包含指令模板。
接下来的两个字符串分别是输出和输入。该语句没有clobbers。
这个例子表明，普通的汇编语句只是扩展汇编语句的一个特例；
它们没有限定符，输出，输入或者clobbers。
所有的字符串都为@code{NUL}结尾，并且不包含嵌入的@code{NUL}字符。

如果汇编语句被声明为@code{volatile}，或者语句不是扩展汇编语句，
因此是一个隐式的@code{volatile}，
则断言@code{ASM_VOLATILE_P}将会保存@code{ASM_EXPR}。

@item BREAK_STMT
用来表示一条@code{break}语句。没有额外的域。 

@item CASE_LABEL_EXPR
用来表示一个@code{case}标号，@code{case}标号的范围或者一个@code{default}标号。
如果@code{CASE_LOW}是@code{NULL_TREE}，则为一个@code{default}标号。
否则，如果@code{CASE_HIGH}是@code{NULL_TREE}，则为一个普通的@code{case}标号。
这种情况下，@code{CASE_LOW}是一个表达式，给出了标号的值。
@code{CASE_LOW}和@code{CASE_HIGH}都是@code{INTEGER_CST}节点。
这些值跟在@code{switch}语句中的条件表达式具有相同的类型。 

否则，如果同时定义了@code{CASE_LOW}和@code{CASE_HIGH}，则语句为一个@code{case}标号的范围。这样的语句源于允许用户使用如下形式的扩展：

@smallexample
case 2 ... 5:
@end smallexample
第一个值为@code{CASE_LOW}，第二个为@code{CASE_HIGH}。

@item CLEANUP_STMT
用来表示在封闭作用域的出口上执行的动作。
通常，这些动作是为局部对象调用析构函数，但是后端不能依靠这个事实。
如果这些节点确实是表示了这样的析构函数，
@code{CLEANUP_DECL}将为销毁的@code{VAR_DECL}。
否则@code{CLEANUP_DECL}为@code{NULL_TREE}。
无论哪种情况，@code{CLEANUP_EXPR}都是要被执行的表达式。
清除工作在作用域的出口被执行，
并且按照所遇到的@code{CLEANUP_STMT}的相反顺序进行。

@item CONTINUE_STMT
用来表示一条@code{continue}语句。没有额外的域。 

@item CTOR_STMT
用于标记构建函数体的起始（@code{CTOR_BEGIN_P}）或结尾（@code{CTOR_END_P}）。关于如何使用这些节点的更多信息，参见@code{SUBOBJECT}。 

@item DECL_STMT
用来表示一个局部声明。宏@code{DECL_STMT_DECL}可以用来获得整个声明。
该声明可以为一个@code{LABEL_DECL}，表示声明了一个局部标号。
（作为扩展，GCC允许声明具有作用域的标号。）
在C中，该声明可以为一个@code{FUNCTION_DECL}，表示使用GCC嵌套函数扩展。
更多信息，参见 @ref{函数}。

@item DO_STMT
用来表示@code{do}循环。循环体由@code{DO_BODY}给出，
终止条件由@code{DO_COND}给出。@code{do}语句的条件总是一个表达式。

@item EMPTY_CLASS_EXPR
用来表示类的临时对象。（所有这样的对象都是可互换的。）
@code{TREE_TYPE}表示对象的类型。 

@item EXPR_STMT
用来表示表达式语句。使用@code{EXPR_STMT_EXPR}来获得表达式。 

@item FOR_STMT
用来表示一条@code{for}语句。@code{FOR_INIT_STMT}是循环的初始语句。
@code{FOR_COND}是终止条件。
@code{FOR_INIT_STMT}是在每次循环迭代@code{FOR_COND}之前执行的表达式，
该表达式常常是增加计数器。循环体由@code{FOR_BODY}给出。
注意@code{FOR_INIT_STMT}和@code{FOR_BODY}返回语句，
而@code{FOR_COND}和@code{FOR_EXPR}返回表达式。

@item GOTO_EXPR
用来表示一条@code{goto}语句。
@code{GOTO_DESTINATION}通常为一个@code{LABEL_DECL}。
然而，如果使用了扩展的“computed goto”，将为一个随机表达式用来指示目的地。
该表达式总是具有一个指针类型。 

@item HANDLER
用来表示C++ @code{catch}块。@code{HANDLER_TYPE}是由该处理者捕捉的异常类型。
如果该处理者是针对所有类型的，则等于（指针等于）@code{NULL}。
@code{HANDLER_PARMS}是@code{catch}参数，是一个@code{DECL_STMT}。
@code{HANDLER_BODY}是块本身的代码。 

@item IF_STMT
用来表示一条@code{if}语句。@code{IF_COND}是表达式。
如果条件是一个@code{TREE_LIST}，
则@code{TREE_PURPOSE}是一条语句（通常为 @code{DECL_STMT}）。
每次评估条件的时候，都要执行该语句。
然后，@code{TREE_VALUE}应该作为条件表达式本身来使用。
该表示用来处理C++代码，如： 

@smallexample
if (int i = 7) @dots{}
@end smallexample

其中，在条件中声明了一个（或多个）新的局部变量。

@item LABEL_EXPR
用来表示一个标号。
可以通过@code{LABEL_EXPR_LABEL}宏获得该语句声明的@code{LABEL_DECL}。
可以通过@code{LABEL_DECL}的@code{DECL_NAME}获得给出的标号名字。

@item RETURN_STMT
用来表示一条@code{return}语句。@code{RETURN_EXPR}是返回的表达式，
其将会返回@code{NULL_TREE}，如果语句只是 
@smallexample
return;
@end smallexample

@item SUBOBJECT
在构造函数中，这些节点用来标记在某一点子对象被完全构造。如果，这一点之后，在遇到设置了@code{CTOR_END_P}的@code{CTOR_STMT}之前，有异常抛出，则必须执行@code{SUBOBJECT_CLEANUP}。清除工作必须按照它们出现的顺序反向执行。 

@item SWITCH_STMT
用来表示一个@code{switch}语句。
@code{SWITCH_STMT_COND}是发生@code{switch}的表达式。
更多关于条件表示的信息，参见@code{IF_STMT}文档。
@code{SWITCH_STMT_BODY}是@code{switch}语句主体。
@code{SWITCH_STMT_TYPE}是源代码中给出的@code{switch}表达式的，
在任何编译器转换之前的原始类型。

@item TRY_BLOCK
用来表示一个@code{try}块。@code{try}块的主体由@code{TRY_STMTS}给出。
每个@code{catch}块都是一个@code{HANDLER}节点。
第一个@code{handler}由 @code{TRY_HANDLERS}给出。
后续的@code{handlers}可以通过@code{TREE_CHAIN}获得。
@code{handler}的主体由@code{HANDLER_BODY}给出。

如果@code{CLEANUP_P}持有@code{TRY_BLOCK}，
则@code{TRY_HANDLERS}将不是一个@code{HANDLER}节点。
相反的，其将会是一个表达式，并且如果在@code{try}块中抛出异常时则被执行。
其必须在执行完那些代码之后再重新抛出异常。
并且，如果当表达式正在执行的时候，如果有异常抛出，则必须终止。

@item USING_STMT
用来表示@code{using}指示符。命名空间为一个NAMESPACE_DECL，
由@code{USING_STMT_NAMESPACE}给出。该节点在模板函数内部需要，
用来在实例化时实现@code{using}指示符。 

@item WHILE_STMT
用来表示一个@code{while}循环。@code{WHILE_COND}是循环的终止条件。
关于用来表示条件的更多信息，参见@code{IF_STMT}的文档。
 
@code{WHILE_BODY}是循环体。 
@end table

@c ---------------------------------------------------------------------
@c Attributes
@c ---------------------------------------------------------------------
@node 属性
@section 树中的属性
@cindex attributes

使用关键字@code{__attribute__}指定的属性，在内部作为@code{TREE_LIST}来表示。
@code{TREE_PURPOSE} ，作为一个@code{IDENTIFIER_NODE}，是属性的名字。
如果有参数的话，@code{TREE_VALUE}是一个属性参数的@code{TREE_LIST}，
或者在没有参数时，为@code{NULL_TREE}。
参数作为列表中的@code{TREE_VALUE}后继项存储，并且可以为标识符或者表达式。
属性的@code{TREE_CHAIN}是在属性列表中应用到同一声明或类型的下一个属性，
或者为@code{NULL_TREE}如果列表中没有更多的属性。

属性可以附加到声明和类型上；这些属性可以通过下列宏来访问。
所有的属性都通过这种方式存储，并且许多还对声明和类型，
或者其它内部编译器数据结构体，引起其它的变化。

@deftypefn {Tree Macro} tree DECL_ATTRIBUTES (tree @var{decl})
该宏返回声明@var{decl}上的属性。
@end deftypefn

@deftypefn {Tree Macro} tree TYPE_ATTRIBUTES (tree @var{type})
该宏返回类型@var{type}上的属性。
@end deftypefn

@c ---------------------------------------------------------------------
@c Expressions
@c ---------------------------------------------------------------------

@node 表达式tree
@section Expressions
@cindex expression
@findex TREE_TYPE
@findex TREE_OPERAND
@tindex INTEGER_CST
@findex TREE_INT_CST_HIGH
@findex TREE_INT_CST_LOW
@findex tree_int_cst_lt
@findex tree_int_cst_equal
@tindex REAL_CST
@tindex FIXED_CST
@tindex COMPLEX_CST
@tindex VECTOR_CST
@tindex STRING_CST
@findex TREE_STRING_LENGTH
@findex TREE_STRING_POINTER
@tindex PTRMEM_CST
@findex PTRMEM_CST_CLASS
@findex PTRMEM_CST_MEMBER
@tindex VAR_DECL
@tindex NEGATE_EXPR
@tindex ABS_EXPR
@tindex BIT_NOT_EXPR
@tindex TRUTH_NOT_EXPR
@tindex PREDECREMENT_EXPR
@tindex PREINCREMENT_EXPR
@tindex POSTDECREMENT_EXPR
@tindex POSTINCREMENT_EXPR
@tindex ADDR_EXPR
@tindex INDIRECT_REF
@tindex FIX_TRUNC_EXPR
@tindex FLOAT_EXPR
@tindex COMPLEX_EXPR
@tindex CONJ_EXPR
@tindex REALPART_EXPR
@tindex IMAGPART_EXPR
@tindex NON_LVALUE_EXPR
@tindex NOP_EXPR
@tindex CONVERT_EXPR
@tindex FIXED_CONVERT_EXPR
@tindex THROW_EXPR
@tindex LSHIFT_EXPR
@tindex RSHIFT_EXPR
@tindex BIT_IOR_EXPR
@tindex BIT_XOR_EXPR
@tindex BIT_AND_EXPR
@tindex TRUTH_ANDIF_EXPR
@tindex TRUTH_ORIF_EXPR
@tindex TRUTH_AND_EXPR
@tindex TRUTH_OR_EXPR
@tindex TRUTH_XOR_EXPR
@tindex POINTER_PLUS_EXPR
@tindex PLUS_EXPR
@tindex MINUS_EXPR
@tindex MULT_EXPR
@tindex RDIV_EXPR
@tindex TRUNC_DIV_EXPR
@tindex FLOOR_DIV_EXPR
@tindex CEIL_DIV_EXPR
@tindex ROUND_DIV_EXPR
@tindex TRUNC_MOD_EXPR
@tindex FLOOR_MOD_EXPR
@tindex CEIL_MOD_EXPR
@tindex ROUND_MOD_EXPR
@tindex EXACT_DIV_EXPR
@tindex ARRAY_REF
@tindex ARRAY_RANGE_REF
@tindex TARGET_MEM_REF
@tindex LT_EXPR
@tindex LE_EXPR
@tindex GT_EXPR
@tindex GE_EXPR
@tindex EQ_EXPR
@tindex NE_EXPR
@tindex ORDERED_EXPR
@tindex UNORDERED_EXPR
@tindex UNLT_EXPR
@tindex UNLE_EXPR
@tindex UNGT_EXPR
@tindex UNGE_EXPR
@tindex UNEQ_EXPR
@tindex LTGT_EXPR
@tindex MODIFY_EXPR
@tindex INIT_EXPR
@tindex COMPONENT_REF
@tindex COMPOUND_EXPR
@tindex COND_EXPR
@tindex CALL_EXPR
@tindex STMT_EXPR
@tindex BIND_EXPR
@tindex LOOP_EXPR
@tindex EXIT_EXPR
@tindex CLEANUP_POINT_EXPR
@tindex CONSTRUCTOR
@tindex COMPOUND_LITERAL_EXPR
@tindex SAVE_EXPR
@tindex TARGET_EXPR
@tindex AGGR_INIT_EXPR
@tindex VA_ARG_EXPR
@tindex CHANGE_DYNAMIC_TYPE_EXPR
@tindex OMP_PARALLEL
@tindex OMP_FOR
@tindex OMP_SECTIONS
@tindex OMP_SINGLE
@tindex OMP_SECTION
@tindex OMP_MASTER
@tindex OMP_ORDERED
@tindex OMP_CRITICAL
@tindex OMP_RETURN
@tindex OMP_CONTINUE
@tindex OMP_ATOMIC
@tindex OMP_CLAUSE
@tindex VEC_LSHIFT_EXPR
@tindex VEC_RSHIFT_EXPR
@tindex VEC_WIDEN_MULT_HI_EXPR
@tindex VEC_WIDEN_MULT_LO_EXPR
@tindex VEC_UNPACK_HI_EXPR
@tindex VEC_UNPACK_LO_EXPR
@tindex VEC_UNPACK_FLOAT_HI_EXPR
@tindex VEC_UNPACK_FLOAT_LO_EXPR
@tindex VEC_PACK_TRUNC_EXPR
@tindex VEC_PACK_SAT_EXPR
@tindex VEC_PACK_FIX_TRUNC_EXPR
@tindex VEC_EXTRACT_EVEN_EXPR 
@tindex VEC_EXTRACT_ODD_EXPR
@tindex VEC_INTERLEAVE_HIGH_EXPR
@tindex VEC_INTERLEAVE_LOW_EXPR

The internal representation for expressions is for the most part quite
straightforward.  However, there are a few facts that one must bear in
mind.  In particular, the expression ``tree'' is actually a directed
acyclic graph.  (For example there may be many references to the integer
constant zero throughout the source program; many of these will be
represented by the same expression node.)  You should not rely on
certain kinds of node being shared, nor should you rely on certain kinds of
nodes being unshared.

The following macros can be used with all expression nodes:

@ftable @code
@item TREE_TYPE
Returns the type of the expression.  This value may not be precisely the
same type that would be given the expression in the original program.
@end ftable

In what follows, some nodes that one might expect to always have type
@code{bool} are documented to have either integral or boolean type.  At
some point in the future, the C front end may also make use of this same
intermediate representation, and at this point these nodes will
certainly have integral type.  The previous sentence is not meant to
imply that the C++ front end does not or will not give these nodes
integral type.

Below, we list the various kinds of expression nodes.  Except where
noted otherwise, the operands to an expression are accessed using the
@code{TREE_OPERAND} macro.  For example, to access the first operand to
a binary plus expression @code{expr}, use:

@smallexample
TREE_OPERAND (expr, 0)
@end smallexample
@noindent
As this example indicates, the operands are zero-indexed.

All the expressions starting with @code{OMP_} represent directives and
clauses used by the OpenMP API @w{@uref{http://www.openmp.org/}}.

The table below begins with constants, moves on to unary expressions,
then proceeds to binary expressions, and concludes with various other
kinds of expressions:

@table @code
@item INTEGER_CST
These nodes represent integer constants.  Note that the type of these
constants is obtained with @code{TREE_TYPE}; they are not always of type
@code{int}.  In particular, @code{char} constants are represented with
@code{INTEGER_CST} nodes.  The value of the integer constant @code{e} is
given by
@smallexample
((TREE_INT_CST_HIGH (e) << HOST_BITS_PER_WIDE_INT)
+ TREE_INST_CST_LOW (e))
@end smallexample
@noindent
HOST_BITS_PER_WIDE_INT is at least thirty-two on all platforms.  Both
@code{TREE_INT_CST_HIGH} and @code{TREE_INT_CST_LOW} return a
@code{HOST_WIDE_INT}.  The value of an @code{INTEGER_CST} is interpreted
as a signed or unsigned quantity depending on the type of the constant.
In general, the expression given above will overflow, so it should not
be used to calculate the value of the constant.

The variable @code{integer_zero_node} is an integer constant with value
zero.  Similarly, @code{integer_one_node} is an integer constant with
value one.  The @code{size_zero_node} and @code{size_one_node} variables
are analogous, but have type @code{size_t} rather than @code{int}.

The function @code{tree_int_cst_lt} is a predicate which holds if its
first argument is less than its second.  Both constants are assumed to
have the same signedness (i.e., either both should be signed or both
should be unsigned.)  The full width of the constant is used when doing
the comparison; the usual rules about promotions and conversions are
ignored.  Similarly, @code{tree_int_cst_equal} holds if the two
constants are equal.  The @code{tree_int_cst_sgn} function returns the
sign of a constant.  The value is @code{1}, @code{0}, or @code{-1}
according on whether the constant is greater than, equal to, or less
than zero.  Again, the signedness of the constant's type is taken into
account; an unsigned constant is never less than zero, no matter what
its bit-pattern.

@item REAL_CST

FIXME: Talk about how to obtain representations of this constant, do
comparisons, and so forth.

@item FIXED_CST

These nodes represent fixed-point constants.  The type of these constants
is obtained with @code{TREE_TYPE}.  @code{TREE_FIXED_CST_PTR} points to
to struct fixed_value;  @code{TREE_FIXED_CST} returns the structure itself.
Struct fixed_value contains @code{data} with the size of two
HOST_BITS_PER_WIDE_INT and @code{mode} as the associated fixed-point
machine mode for @code{data}.

@item COMPLEX_CST
These nodes are used to represent complex number constants, that is a
@code{__complex__} whose parts are constant nodes.  The
@code{TREE_REALPART} and @code{TREE_IMAGPART} return the real and the
imaginary parts respectively.

@item VECTOR_CST
These nodes are used to represent vector constants, whose parts are
constant nodes.  Each individual constant node is either an integer or a
double constant node.  The first operand is a @code{TREE_LIST} of the
constant nodes and is accessed through @code{TREE_VECTOR_CST_ELTS}.

@item STRING_CST
These nodes represent string-constants.  The @code{TREE_STRING_LENGTH}
returns the length of the string, as an @code{int}.  The
@code{TREE_STRING_POINTER} is a @code{char*} containing the string
itself.  The string may not be @code{NUL}-terminated, and it may contain
embedded @code{NUL} characters.  Therefore, the
@code{TREE_STRING_LENGTH} includes the trailing @code{NUL} if it is
present.

For wide string constants, the @code{TREE_STRING_LENGTH} is the number
of bytes in the string, and the @code{TREE_STRING_POINTER}
points to an array of the bytes of the string, as represented on the
target system (that is, as integers in the target endianness).  Wide and
non-wide string constants are distinguished only by the @code{TREE_TYPE}
of the @code{STRING_CST}.

FIXME: The formats of string constants are not well-defined when the
target system bytes are not the same width as host system bytes.

@item PTRMEM_CST
These nodes are used to represent pointer-to-member constants.  The
@code{PTRMEM_CST_CLASS} is the class type (either a @code{RECORD_TYPE}
or @code{UNION_TYPE} within which the pointer points), and the
@code{PTRMEM_CST_MEMBER} is the declaration for the pointed to object.
Note that the @code{DECL_CONTEXT} for the @code{PTRMEM_CST_MEMBER} is in
general different from the @code{PTRMEM_CST_CLASS}.  For example,
given:
@smallexample
struct B @{ int i; @};
struct D : public B @{@};
int D::*dp = &D::i;
@end smallexample
@noindent
The @code{PTRMEM_CST_CLASS} for @code{&D::i} is @code{D}, even though
the @code{DECL_CONTEXT} for the @code{PTRMEM_CST_MEMBER} is @code{B},
since @code{B::i} is a member of @code{B}, not @code{D}.

@item VAR_DECL

These nodes represent variables, including static data members.  For
more information, @pxref{Declarations}.

@item NEGATE_EXPR
These nodes represent unary negation of the single operand, for both
integer and floating-point types.  The type of negation can be
determined by looking at the type of the expression.

The behavior of this operation on signed arithmetic overflow is
controlled by the @code{flag_wrapv} and @code{flag_trapv} variables.

@item ABS_EXPR
These nodes represent the absolute value of the single operand, for
both integer and floating-point types.  This is typically used to
implement the @code{abs}, @code{labs} and @code{llabs} builtins for
integer types, and the @code{fabs}, @code{fabsf} and @code{fabsl}
builtins for floating point types.  The type of abs operation can
be determined by looking at the type of the expression.

This node is not used for complex types.  To represent the modulus
or complex abs of a complex value, use the @code{BUILT_IN_CABS},
@code{BUILT_IN_CABSF} or @code{BUILT_IN_CABSL} builtins, as used
to implement the C99 @code{cabs}, @code{cabsf} and @code{cabsl}
built-in functions.

@item BIT_NOT_EXPR
These nodes represent bitwise complement, and will always have integral
type.  The only operand is the value to be complemented.

@item TRUTH_NOT_EXPR
These nodes represent logical negation, and will always have integral
(or boolean) type.  The operand is the value being negated.  The type
of the operand and that of the result are always of @code{BOOLEAN_TYPE}
or @code{INTEGER_TYPE}.

@item PREDECREMENT_EXPR
@itemx PREINCREMENT_EXPR
@itemx POSTDECREMENT_EXPR
@itemx POSTINCREMENT_EXPR
These nodes represent increment and decrement expressions.  The value of
the single operand is computed, and the operand incremented or
decremented.  In the case of @code{PREDECREMENT_EXPR} and
@code{PREINCREMENT_EXPR}, the value of the expression is the value
resulting after the increment or decrement; in the case of
@code{POSTDECREMENT_EXPR} and @code{POSTINCREMENT_EXPR} is the value
before the increment or decrement occurs.  The type of the operand, like
that of the result, will be either integral, boolean, or floating-point.

@item ADDR_EXPR
These nodes are used to represent the address of an object.  (These
expressions will always have pointer or reference type.)  The operand may
be another expression, or it may be a declaration.

As an extension, GCC allows users to take the address of a label.  In
this case, the operand of the @code{ADDR_EXPR} will be a
@code{LABEL_DECL}.  The type of such an expression is @code{void*}.

If the object addressed is not an lvalue, a temporary is created, and
the address of the temporary is used.

@item INDIRECT_REF
These nodes are used to represent the object pointed to by a pointer.
The operand is the pointer being dereferenced; it will always have
pointer or reference type.

@item FIX_TRUNC_EXPR
These nodes represent conversion of a floating-point value to an
integer.  The single operand will have a floating-point type, while
the complete expression will have an integral (or boolean) type.  The
operand is rounded towards zero.

@item FLOAT_EXPR
These nodes represent conversion of an integral (or boolean) value to a
floating-point value.  The single operand will have integral type, while
the complete expression will have a floating-point type.

FIXME: How is the operand supposed to be rounded?  Is this dependent on
@option{-mieee}?

@item COMPLEX_EXPR
These nodes are used to represent complex numbers constructed from two
expressions of the same (integer or real) type.  The first operand is the
real part and the second operand is the imaginary part.

@item CONJ_EXPR
These nodes represent the conjugate of their operand.

@item REALPART_EXPR
@itemx IMAGPART_EXPR
These nodes represent respectively the real and the imaginary parts
of complex numbers (their sole argument).

@item NON_LVALUE_EXPR
These nodes indicate that their one and only operand is not an lvalue.
A back end can treat these identically to the single operand.

@item NOP_EXPR
These nodes are used to represent conversions that do not require any
code-generation.  For example, conversion of a @code{char*} to an
@code{int*} does not require any code be generated; such a conversion is
represented by a @code{NOP_EXPR}.  The single operand is the expression
to be converted.  The conversion from a pointer to a reference is also
represented with a @code{NOP_EXPR}.

@item CONVERT_EXPR
These nodes are similar to @code{NOP_EXPR}s, but are used in those
situations where code may need to be generated.  For example, if an
@code{int*} is converted to an @code{int} code may need to be generated
on some platforms.  These nodes are never used for C++-specific
conversions, like conversions between pointers to different classes in
an inheritance hierarchy.  Any adjustments that need to be made in such
cases are always indicated explicitly.  Similarly, a user-defined
conversion is never represented by a @code{CONVERT_EXPR}; instead, the
function calls are made explicit.

@item FIXED_CONVERT_EXPR
These nodes are used to represent conversions that involve fixed-point
values.  For example, from a fixed-point value to another fixed-point value,
from an integer to a fixed-point value, from a fixed-point value to an
integer, from a floating-point value to a fixed-point value, or from
a fixed-point value to a floating-point value.

@item THROW_EXPR
These nodes represent @code{throw} expressions.  The single operand is
an expression for the code that should be executed to throw the
exception.  However, there is one implicit action not represented in
that expression; namely the call to @code{__throw}.  This function takes
no arguments.  If @code{setjmp}/@code{longjmp} exceptions are used, the
function @code{__sjthrow} is called instead.  The normal GCC back end
uses the function @code{emit_throw} to generate this code; you can
examine this function to see what needs to be done.

@item LSHIFT_EXPR
@itemx RSHIFT_EXPR
These nodes represent left and right shifts, respectively.  The first
operand is the value to shift; it will always be of integral type.  The
second operand is an expression for the number of bits by which to
shift.  Right shift should be treated as arithmetic, i.e., the
high-order bits should be zero-filled when the expression has unsigned
type and filled with the sign bit when the expression has signed type.
Note that the result is undefined if the second operand is larger
than or equal to the first operand's type size.


@item BIT_IOR_EXPR
@itemx BIT_XOR_EXPR
@itemx BIT_AND_EXPR
These nodes represent bitwise inclusive or, bitwise exclusive or, and
bitwise and, respectively.  Both operands will always have integral
type.

@item TRUTH_ANDIF_EXPR
@itemx TRUTH_ORIF_EXPR
These nodes represent logical ``and'' and logical ``or'', respectively.
These operators are not strict; i.e., the second operand is evaluated
only if the value of the expression is not determined by evaluation of
the first operand.  The type of the operands and that of the result are
always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}.

@item TRUTH_AND_EXPR
@itemx TRUTH_OR_EXPR
@itemx TRUTH_XOR_EXPR
These nodes represent logical and, logical or, and logical exclusive or.
They are strict; both arguments are always evaluated.  There are no
corresponding operators in C or C++, but the front end will sometimes
generate these expressions anyhow, if it can tell that strictness does
not matter.  The type of the operands and that of the result are
always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}.

@itemx POINTER_PLUS_EXPR
This node represents pointer arithmetic.  The first operand is always
a pointer/reference type.  The second operand is always an unsigned
integer type compatible with sizetype.  This is the only binary
arithmetic operand that can operate on pointer types.

@itemx PLUS_EXPR
@itemx MINUS_EXPR
@itemx MULT_EXPR
These nodes represent various binary arithmetic operations.
Respectively, these operations are addition, subtraction (of the second
operand from the first) and multiplication.  Their operands may have
either integral or floating type, but there will never be case in which
one operand is of floating type and the other is of integral type.

The behavior of these operations on signed arithmetic overflow is
controlled by the @code{flag_wrapv} and @code{flag_trapv} variables.

@item RDIV_EXPR
This node represents a floating point division operation.

@item TRUNC_DIV_EXPR
@itemx FLOOR_DIV_EXPR
@itemx CEIL_DIV_EXPR
@itemx ROUND_DIV_EXPR
These nodes represent integer division operations that return an integer
result.  @code{TRUNC_DIV_EXPR} rounds towards zero, @code{FLOOR_DIV_EXPR}
rounds towards negative infinity, @code{CEIL_DIV_EXPR} rounds towards
positive infinity and @code{ROUND_DIV_EXPR} rounds to the closest integer.
Integer division in C and C++ is truncating, i.e.@: @code{TRUNC_DIV_EXPR}.

The behavior of these operations on signed arithmetic overflow, when
dividing the minimum signed integer by minus one, is controlled by the
@code{flag_wrapv} and @code{flag_trapv} variables.

@item TRUNC_MOD_EXPR
@itemx FLOOR_MOD_EXPR
@itemx CEIL_MOD_EXPR
@itemx ROUND_MOD_EXPR
These nodes represent the integer remainder or modulus operation.
The integer modulus of two operands @code{a} and @code{b} is
defined as @code{a - (a/b)*b} where the division calculated using
the corresponding division operator.  Hence for @code{TRUNC_MOD_EXPR}
this definition assumes division using truncation towards zero, i.e.@:
@code{TRUNC_DIV_EXPR}.  Integer remainder in C and C++ uses truncating
division, i.e.@: @code{TRUNC_MOD_EXPR}.

@item EXACT_DIV_EXPR
The @code{EXACT_DIV_EXPR} code is used to represent integer divisions where
the numerator is known to be an exact multiple of the denominator.  This
allows the backend to choose between the faster of @code{TRUNC_DIV_EXPR},
@code{CEIL_DIV_EXPR} and @code{FLOOR_DIV_EXPR} for the current target.

@item ARRAY_REF
These nodes represent array accesses.  The first operand is the array;
the second is the index.  To calculate the address of the memory
accessed, you must scale the index by the size of the type of the array
elements.  The type of these expressions must be the type of a component of
the array.  The third and fourth operands are used after gimplification
to represent the lower bound and component size but should not be used
directly; call @code{array_ref_low_bound} and @code{array_ref_element_size}
instead.

@item ARRAY_RANGE_REF
These nodes represent access to a range (or ``slice'') of an array.  The
operands are the same as that for @code{ARRAY_REF} and have the same
meanings.  The type of these expressions must be an array whose component
type is the same as that of the first operand.  The range of that array
type determines the amount of data these expressions access.

@item TARGET_MEM_REF
These nodes represent memory accesses whose address directly map to
an addressing mode of the target architecture.  The first argument
is @code{TMR_SYMBOL} and must be a @code{VAR_DECL} of an object with
a fixed address.  The second argument is @code{TMR_BASE} and the
third one is @code{TMR_INDEX}.  The fourth argument is
@code{TMR_STEP} and must be an @code{INTEGER_CST}.  The fifth
argument is @code{TMR_OFFSET} and must be an @code{INTEGER_CST}.
Any of the arguments may be NULL if the appropriate component
does not appear in the address.  Address of the @code{TARGET_MEM_REF}
is determined in the following way.

@smallexample
&TMR_SYMBOL + TMR_BASE + TMR_INDEX * TMR_STEP + TMR_OFFSET
@end smallexample

The sixth argument is the reference to the original memory access, which
is preserved for the purposes of the RTL alias analysis.  The seventh
argument is a tag representing the results of tree level alias analysis.

@item LT_EXPR
@itemx LE_EXPR
@itemx GT_EXPR
@itemx GE_EXPR
@itemx EQ_EXPR
@itemx NE_EXPR
These nodes represent the less than, less than or equal to, greater
than, greater than or equal to, equal, and not equal comparison
operators.  The first and second operand with either be both of integral
type or both of floating type.  The result type of these expressions
will always be of integral or boolean type.  These operations return
the result type's zero value for false, and the result type's one value
for true.

For floating point comparisons, if we honor IEEE NaNs and either operand
is NaN, then @code{NE_EXPR} always returns true and the remaining operators
always return false.  On some targets, comparisons against an IEEE NaN,
other than equality and inequality, may generate a floating point exception.

@item ORDERED_EXPR
@itemx UNORDERED_EXPR
These nodes represent non-trapping ordered and unordered comparison
operators.  These operations take two floating point operands and
determine whether they are ordered or unordered relative to each other.
If either operand is an IEEE NaN, their comparison is defined to be
unordered, otherwise the comparison is defined to be ordered.  The
result type of these expressions will always be of integral or boolean
type.  These operations return the result type's zero value for false,
and the result type's one value for true.

@item UNLT_EXPR
@itemx UNLE_EXPR
@itemx UNGT_EXPR
@itemx UNGE_EXPR
@itemx UNEQ_EXPR
@itemx LTGT_EXPR
These nodes represent the unordered comparison operators.
These operations take two floating point operands and determine whether
the operands are unordered or are less than, less than or equal to,
greater than, greater than or equal to, or equal respectively.  For
example, @code{UNLT_EXPR} returns true if either operand is an IEEE
NaN or the first operand is less than the second.  With the possible
exception of @code{LTGT_EXPR}, all of these operations are guaranteed
not to generate a floating point exception.  The result
type of these expressions will always be of integral or boolean type.
These operations return the result type's zero value for false,
and the result type's one value for true.

@item MODIFY_EXPR
These nodes represent assignment.  The left-hand side is the first
operand; the right-hand side is the second operand.  The left-hand side
will be a @code{VAR_DECL}, @code{INDIRECT_REF}, @code{COMPONENT_REF}, or
other lvalue.

These nodes are used to represent not only assignment with @samp{=} but
also compound assignments (like @samp{+=}), by reduction to @samp{=}
assignment.  In other words, the representation for @samp{i += 3} looks
just like that for @samp{i = i + 3}.

@item INIT_EXPR
These nodes are just like @code{MODIFY_EXPR}, but are used only when a
variable is initialized, rather than assigned to subsequently.  This
means that we can assume that the target of the initialization is not
used in computing its own value; any reference to the lhs in computing
the rhs is undefined.

@item COMPONENT_REF
These nodes represent non-static data member accesses.  The first
operand is the object (rather than a pointer to it); the second operand
is the @code{FIELD_DECL} for the data member.  The third operand represents
the byte offset of the field, but should not be used directly; call
@code{component_ref_field_offset} instead.

@item COMPOUND_EXPR
These nodes represent comma-expressions.  The first operand is an
expression whose value is computed and thrown away prior to the
evaluation of the second operand.  The value of the entire expression is
the value of the second operand.

@item COND_EXPR
These nodes represent @code{?:} expressions.  The first operand
is of boolean or integral type.  If it evaluates to a nonzero value,
the second operand should be evaluated, and returned as the value of the
expression.  Otherwise, the third operand is evaluated, and returned as
the value of the expression.

The second operand must have the same type as the entire expression,
unless it unconditionally throws an exception or calls a noreturn
function, in which case it should have void type.  The same constraints
apply to the third operand.  This allows array bounds checks to be
represented conveniently as @code{(i >= 0 && i < 10) ? i : abort()}.

As a GNU extension, the C language front-ends allow the second
operand of the @code{?:} operator may be omitted in the source.
For example, @code{x ? : 3} is equivalent to @code{x ? x : 3},
assuming that @code{x} is an expression without side-effects.
In the tree representation, however, the second operand is always
present, possibly protected by @code{SAVE_EXPR} if the first
argument does cause side-effects.

@item CALL_EXPR
These nodes are used to represent calls to functions, including
non-static member functions.  @code{CALL_EXPR}s are implemented as
expression nodes with a variable number of operands.  Rather than using
@code{TREE_OPERAND} to extract them, it is preferable to use the
specialized accessor macros and functions that operate specifically on
@code{CALL_EXPR} nodes.

@code{CALL_EXPR_FN} returns a pointer to the
function to call; it is always an expression whose type is a
@code{POINTER_TYPE}.

The number of arguments to the call is returned by @code{call_expr_nargs},
while the arguments themselves can be accessed with the @code{CALL_EXPR_ARG} 
macro.  The arguments are zero-indexed and numbered left-to-right.  
You can iterate over the arguments using @code{FOR_EACH_CALL_EXPR_ARG}, as in:

@smallexample
tree call, arg;
call_expr_arg_iterator iter;
FOR_EACH_CALL_EXPR_ARG (arg, iter, call)
  /* arg is bound to successive arguments of call.  */
  @dots{};
@end smallexample

For non-static
member functions, there will be an operand corresponding to the
@code{this} pointer.  There will always be expressions corresponding to
all of the arguments, even if the function is declared with default
arguments and some arguments are not explicitly provided at the call
sites.

@code{CALL_EXPR}s also have a @code{CALL_EXPR_STATIC_CHAIN} operand that
is used to implement nested functions.  This operand is otherwise null.

@item STMT_EXPR
These nodes are used to represent GCC's statement-expression extension.
The statement-expression extension allows code like this:
@smallexample
int f() @{ return (@{ int j; j = 3; j + 7; @}); @}
@end smallexample
In other words, an sequence of statements may occur where a single
expression would normally appear.  The @code{STMT_EXPR} node represents
such an expression.  The @code{STMT_EXPR_STMT} gives the statement
contained in the expression.  The value of the expression is the value
of the last sub-statement in the body.  More precisely, the value is the
value computed by the last statement nested inside @code{BIND_EXPR},
@code{TRY_FINALLY_EXPR}, or @code{TRY_CATCH_EXPR}.  For example, in:
@smallexample
(@{ 3; @})
@end smallexample
the value is @code{3} while in:
@smallexample
(@{ if (x) @{ 3; @} @})
@end smallexample
there is no value.  If the @code{STMT_EXPR} does not yield a value,
it's type will be @code{void}.

@item BIND_EXPR
These nodes represent local blocks.  The first operand is a list of
variables, connected via their @code{TREE_CHAIN} field.  These will
never require cleanups.  The scope of these variables is just the body
of the @code{BIND_EXPR}.  The body of the @code{BIND_EXPR} is the
second operand.

@item LOOP_EXPR
These nodes represent ``infinite'' loops.  The @code{LOOP_EXPR_BODY}
represents the body of the loop.  It should be executed forever, unless
an @code{EXIT_EXPR} is encountered.

@item EXIT_EXPR
These nodes represent conditional exits from the nearest enclosing
@code{LOOP_EXPR}.  The single operand is the condition; if it is
nonzero, then the loop should be exited.  An @code{EXIT_EXPR} will only
appear within a @code{LOOP_EXPR}.

@item CLEANUP_POINT_EXPR
These nodes represent full-expressions.  The single operand is an
expression to evaluate.  Any destructor calls engendered by the creation
of temporaries during the evaluation of that expression should be
performed immediately after the expression is evaluated.

@item CONSTRUCTOR
These nodes represent the brace-enclosed initializers for a structure or
array.  The first operand is reserved for use by the back end.  The
second operand is a @code{TREE_LIST}.  If the @code{TREE_TYPE} of the
@code{CONSTRUCTOR} is a @code{RECORD_TYPE} or @code{UNION_TYPE}, then
the @code{TREE_PURPOSE} of each node in the @code{TREE_LIST} will be a
@code{FIELD_DECL} and the @code{TREE_VALUE} of each node will be the
expression used to initialize that field.

If the @code{TREE_TYPE} of the @code{CONSTRUCTOR} is an
@code{ARRAY_TYPE}, then the @code{TREE_PURPOSE} of each element in the
@code{TREE_LIST} will be an @code{INTEGER_CST} or a @code{RANGE_EXPR} of
two @code{INTEGER_CST}s.  A single @code{INTEGER_CST} indicates which
element of the array (indexed from zero) is being assigned to.  A
@code{RANGE_EXPR} indicates an inclusive range of elements to
initialize.  In both cases the @code{TREE_VALUE} is the corresponding
initializer.  It is re-evaluated for each element of a
@code{RANGE_EXPR}.  If the @code{TREE_PURPOSE} is @code{NULL_TREE}, then
the initializer is for the next available array element.

In the front end, you should not depend on the fields appearing in any
particular order.  However, in the middle end, fields must appear in
declaration order.  You should not assume that all fields will be
represented.  Unrepresented fields will be set to zero.

@item COMPOUND_LITERAL_EXPR
@findex COMPOUND_LITERAL_EXPR_DECL_STMT
@findex COMPOUND_LITERAL_EXPR_DECL
These nodes represent ISO C99 compound literals.  The
@code{COMPOUND_LITERAL_EXPR_DECL_STMT} is a @code{DECL_STMT}
containing an anonymous @code{VAR_DECL} for
the unnamed object represented by the compound literal; the
@code{DECL_INITIAL} of that @code{VAR_DECL} is a @code{CONSTRUCTOR}
representing the brace-enclosed list of initializers in the compound
literal.  That anonymous @code{VAR_DECL} can also be accessed directly
by the @code{COMPOUND_LITERAL_EXPR_DECL} macro.

@item SAVE_EXPR

A @code{SAVE_EXPR} represents an expression (possibly involving
side-effects) that is used more than once.  The side-effects should
occur only the first time the expression is evaluated.  Subsequent uses
should just reuse the computed value.  The first operand to the
@code{SAVE_EXPR} is the expression to evaluate.  The side-effects should
be executed where the @code{SAVE_EXPR} is first encountered in a
depth-first preorder traversal of the expression tree.

@item TARGET_EXPR
A @code{TARGET_EXPR} represents a temporary object.  The first operand
is a @code{VAR_DECL} for the temporary variable.  The second operand is
the initializer for the temporary.  The initializer is evaluated and,
if non-void, copied (bitwise) into the temporary.  If the initializer
is void, that means that it will perform the initialization itself.

Often, a @code{TARGET_EXPR} occurs on the right-hand side of an
assignment, or as the second operand to a comma-expression which is
itself the right-hand side of an assignment, etc.  In this case, we say
that the @code{TARGET_EXPR} is ``normal''; otherwise, we say it is
``orphaned''.  For a normal @code{TARGET_EXPR} the temporary variable
should be treated as an alias for the left-hand side of the assignment,
rather than as a new temporary variable.

The third operand to the @code{TARGET_EXPR}, if present, is a
cleanup-expression (i.e., destructor call) for the temporary.  If this
expression is orphaned, then this expression must be executed when the
statement containing this expression is complete.  These cleanups must
always be executed in the order opposite to that in which they were
encountered.  Note that if a temporary is created on one branch of a
conditional operator (i.e., in the second or third operand to a
@code{COND_EXPR}), the cleanup must be run only if that branch is
actually executed.

See @code{STMT_IS_FULL_EXPR_P} for more information about running these
cleanups.

@item AGGR_INIT_EXPR
An @code{AGGR_INIT_EXPR} represents the initialization as the return
value of a function call, or as the result of a constructor.  An
@code{AGGR_INIT_EXPR} will only appear as a full-expression, or as the
second operand of a @code{TARGET_EXPR}.  @code{AGGR_INIT_EXPR}s have
a representation similar to that of @code{CALL_EXPR}s.  You can use
the @code{AGGR_INIT_EXPR_FN} and @code{AGGR_INIT_EXPR_ARG} macros to access
the function to call and the arguments to pass.

If @code{AGGR_INIT_VIA_CTOR_P} holds of the @code{AGGR_INIT_EXPR}, then
the initialization is via a constructor call.  The address of the
@code{AGGR_INIT_EXPR_SLOT} operand, which is always a @code{VAR_DECL},
is taken, and this value replaces the first argument in the argument
list.

In either case, the expression is void.

@item VA_ARG_EXPR
This node is used to implement support for the C/C++ variable argument-list
mechanism.  It represents expressions like @code{va_arg (ap, type)}.
Its @code{TREE_TYPE} yields the tree representation for @code{type} and
its sole argument yields the representation for @code{ap}.

@item CHANGE_DYNAMIC_TYPE_EXPR
Indicates the special aliasing required by C++ placement new.  It has
two operands: a type and a location.  It means that the dynamic type
of the location is changing to be the specified type.  The alias
analysis code takes this into account when doing type based alias
analysis.

@item OMP_PARALLEL

Represents @code{#pragma omp parallel [clause1 @dots{} clauseN]}. It
has four operands:

Operand @code{OMP_PARALLEL_BODY} is valid while in GENERIC and
High GIMPLE forms.  It contains the body of code to be executed
by all the threads.  During GIMPLE lowering, this operand becomes
@code{NULL} and the body is emitted linearly after
@code{OMP_PARALLEL}.

Operand @code{OMP_PARALLEL_CLAUSES} is the list of clauses
associated with the directive.

Operand @code{OMP_PARALLEL_FN} is created by
@code{pass_lower_omp}, it contains the @code{FUNCTION_DECL}
for the function that will contain the body of the parallel
region.

Operand @code{OMP_PARALLEL_DATA_ARG} is also created by
@code{pass_lower_omp}. If there are shared variables to be
communicated to the children threads, this operand will contain
the @code{VAR_DECL} that contains all the shared values and
variables.

@item OMP_FOR

Represents @code{#pragma omp for [clause1 @dots{} clauseN]}.  It
has 5 operands:

Operand @code{OMP_FOR_BODY} contains the loop body.

Operand @code{OMP_FOR_CLAUSES} is the list of clauses
associated with the directive.

Operand @code{OMP_FOR_INIT} is the loop initialization code of
the form @code{VAR = N1}.

Operand @code{OMP_FOR_COND} is the loop conditional expression
of the form @code{VAR @{<,>,<=,>=@} N2}.

Operand @code{OMP_FOR_INCR} is the loop index increment of the
form @code{VAR @{+=,-=@} INCR}.

Operand @code{OMP_FOR_PRE_BODY} contains side-effect code from
operands @code{OMP_FOR_INIT}, @code{OMP_FOR_COND} and
@code{OMP_FOR_INC}.  These side-effects are part of the
@code{OMP_FOR} block but must be evaluated before the start of
loop body.

The loop index variable @code{VAR} must be a signed integer variable,
which is implicitly private to each thread.  Bounds
@code{N1} and @code{N2} and the increment expression
@code{INCR} are required to be loop invariant integer
expressions that are evaluated without any synchronization. The
evaluation order, frequency of evaluation and side-effects are
unspecified by the standard.

@item OMP_SECTIONS

Represents @code{#pragma omp sections [clause1 @dots{} clauseN]}.

Operand @code{OMP_SECTIONS_BODY} contains the sections body,
which in turn contains a set of @code{OMP_SECTION} nodes for
each of the concurrent sections delimited by @code{#pragma omp
section}.

Operand @code{OMP_SECTIONS_CLAUSES} is the list of clauses
associated with the directive.

@item OMP_SECTION

Section delimiter for @code{OMP_SECTIONS}.

@item OMP_SINGLE

Represents @code{#pragma omp single}.

Operand @code{OMP_SINGLE_BODY} contains the body of code to be
executed by a single thread.

Operand @code{OMP_SINGLE_CLAUSES} is the list of clauses
associated with the directive.

@item OMP_MASTER

Represents @code{#pragma omp master}.

Operand @code{OMP_MASTER_BODY} contains the body of code to be
executed by the master thread.

@item OMP_ORDERED

Represents @code{#pragma omp ordered}.

Operand @code{OMP_ORDERED_BODY} contains the body of code to be
executed in the sequential order dictated by the loop index
variable.

@item OMP_CRITICAL

Represents @code{#pragma omp critical [name]}.

Operand @code{OMP_CRITICAL_BODY} is the critical section.

Operand @code{OMP_CRITICAL_NAME} is an optional identifier to
label the critical section.

@item OMP_RETURN

This does not represent any OpenMP directive, it is an artificial
marker to indicate the end of the body of an OpenMP@. It is used
by the flow graph (@code{tree-cfg.c}) and OpenMP region
building code (@code{omp-low.c}).

@item OMP_CONTINUE

Similarly, this instruction does not represent an OpenMP
directive, it is used by @code{OMP_FOR} and
@code{OMP_SECTIONS} to mark the place where the code needs to
loop to the next iteration (in the case of @code{OMP_FOR}) or
the next section (in the case of @code{OMP_SECTIONS}).

In some cases, @code{OMP_CONTINUE} is placed right before
@code{OMP_RETURN}.  But if there are cleanups that need to
occur right after the looping body, it will be emitted between
@code{OMP_CONTINUE} and @code{OMP_RETURN}.

@item OMP_ATOMIC

Represents @code{#pragma omp atomic}.

Operand 0 is the address at which the atomic operation is to be
performed.

Operand 1 is the expression to evaluate.  The gimplifier tries
three alternative code generation strategies.  Whenever possible,
an atomic update built-in is used.  If that fails, a
compare-and-swap loop is attempted.  If that also fails, a
regular critical section around the expression is used.

@item OMP_CLAUSE

Represents clauses associated with one of the @code{OMP_} directives.
Clauses are represented by separate sub-codes defined in
@file{tree.h}.  Clauses codes can be one of:
@code{OMP_CLAUSE_PRIVATE}, @code{OMP_CLAUSE_SHARED},
@code{OMP_CLAUSE_FIRSTPRIVATE},
@code{OMP_CLAUSE_LASTPRIVATE}, @code{OMP_CLAUSE_COPYIN},
@code{OMP_CLAUSE_COPYPRIVATE}, @code{OMP_CLAUSE_IF},
@code{OMP_CLAUSE_NUM_THREADS}, @code{OMP_CLAUSE_SCHEDULE},
@code{OMP_CLAUSE_NOWAIT}, @code{OMP_CLAUSE_ORDERED},
@code{OMP_CLAUSE_DEFAULT}, and @code{OMP_CLAUSE_REDUCTION}.  Each code
represents the corresponding OpenMP clause.

Clauses associated with the same directive are chained together
via @code{OMP_CLAUSE_CHAIN}. Those clauses that accept a list
of variables are restricted to exactly one, accessed with
@code{OMP_CLAUSE_VAR}.  Therefore, multiple variables under the
same clause @code{C} need to be represented as multiple @code{C} clauses
chained together.  This facilitates adding new clauses during
compilation.

@item VEC_LSHIFT_EXPR
@item VEC_RSHIFT_EXPR
These nodes represent whole vector left and right shifts, respectively.  
The first operand is the vector to shift; it will always be of vector type.  
The second operand is an expression for the number of bits by which to
shift.  Note that the result is undefined if the second operand is larger
than or equal to the first operand's type size.

@item VEC_WIDEN_MULT_HI_EXPR
@item VEC_WIDEN_MULT_LO_EXPR
These nodes represent widening vector multiplication of the high and low
parts of the two input vectors, respectively.  Their operands are vectors 
that contain the same number of elements (@code{N}) of the same integral type.  
The result is a vector that contains half as many elements, of an integral type 
whose size is twice as wide.  In the case of @code{VEC_WIDEN_MULT_HI_EXPR} the
high @code{N/2} elements of the two vector are multiplied to produce the
vector of @code{N/2} products. In the case of @code{VEC_WIDEN_MULT_LO_EXPR} the
low @code{N/2} elements of the two vector are multiplied to produce the
vector of @code{N/2} products.

@item VEC_UNPACK_HI_EXPR
@item VEC_UNPACK_LO_EXPR
These nodes represent unpacking of the high and low parts of the input vector,
respectively.  The single operand is a vector that contains @code{N} elements 
of the same integral or floating point type.  The result is a vector
that contains half as many elements, of an integral or floating point type
whose size is twice as wide.  In the case of @code{VEC_UNPACK_HI_EXPR} the
high @code{N/2} elements of the vector are extracted and widened (promoted).
In the case of @code{VEC_UNPACK_LO_EXPR} the low @code{N/2} elements of the
vector are extracted and widened (promoted).

@item VEC_UNPACK_FLOAT_HI_EXPR
@item VEC_UNPACK_FLOAT_LO_EXPR
These nodes represent unpacking of the high and low parts of the input vector,
where the values are converted from fixed point to floating point.  The
single operand is a vector that contains @code{N} elements of the same
integral type.  The result is a vector that contains half as many elements
of a floating point type whose size is twice as wide.  In the case of
@code{VEC_UNPACK_HI_EXPR} the high @code{N/2} elements of the vector are
extracted, converted and widened.  In the case of @code{VEC_UNPACK_LO_EXPR}
the low @code{N/2} elements of the vector are extracted, converted and widened.

@item VEC_PACK_TRUNC_EXPR
This node represents packing of truncated elements of the two input vectors
into the output vector.  Input operands are vectors that contain the same
number of elements of the same integral or floating point type.  The result
is a vector that contains twice as many elements of an integral or floating
point type whose size is half as wide. The elements of the two vectors are
demoted and merged (concatenated) to form the output vector.

@item VEC_PACK_SAT_EXPR
This node represents packing of elements of the two input vectors into the
output vector using saturation.  Input operands are vectors that contain
the same number of elements of the same integral type.  The result is a
vector that contains twice as many elements of an integral type whose size
is half as wide.  The elements of the two vectors are demoted and merged
(concatenated) to form the output vector.

@item VEC_PACK_FIX_TRUNC_EXPR
This node represents packing of elements of the two input vectors into the
output vector, where the values are converted from floating point
to fixed point.  Input operands are vectors that contain the same number
of elements of a floating point type.  The result is a vector that contains
twice as many elements of an integral type whose size is half as wide.  The
elements of the two vectors are merged (concatenated) to form the output
vector.

@item VEC_EXTRACT_EVEN_EXPR
@item VEC_EXTRACT_ODD_EXPR
These nodes represent extracting of the even/odd elements of the two input 
vectors, respectively. Their operands and result are vectors that contain the 
same number of elements of the same type.

@item VEC_INTERLEAVE_HIGH_EXPR
@item VEC_INTERLEAVE_LOW_EXPR
These nodes represent merging and interleaving of the high/low elements of the
two input vectors, respectively. The operands and the result are vectors that 
contain the same number of elements (@code{N}) of the same type.
In the case of @code{VEC_INTERLEAVE_HIGH_EXPR}, the high @code{N/2} elements of 
the first input vector are interleaved with the high @code{N/2} elements of the
second input vector. In the case of @code{VEC_INTERLEAVE_LOW_EXPR}, the low
@code{N/2} elements of the first input vector are interleaved with the low 
@code{N/2} elements of the second input vector.

@end table
