@c Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
@c 2009  Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Trees
@c ---------------------------------------------------------------------

@node Trees
@chapter Trees: C和C++前端使用的中间表示
@cindex Trees
@cindex C/C++ Internal Representation

这一章记述了GCC用来表示C和C++源程序的内部表示。当源程序为C或者C++时，
GCC解析程序，执行语义分析（包括生成错误消息），
然后产生在这里描述的中间表示。
该表示包含了一个对前端输入的整个转换单元的完全表示。
该表示然后由代码生成器处理，从而产生机器代码，
但是还可以用来创建源浏览器，智能编辑器，自动文本生成器，解析器，
以及任何其它处理C或C++代码所需的程序。

这一章解释了内部表示。特别是，记录了C和C++源结构的内部表示，
以及能够用来访问这些结构的宏，函数和变量。
C++的表示很大程度上为C前端使用的表示的超集。
只有一种C中使用的结构没有出现在C++前端，即GNU“嵌套函数”扩展。
许多这里记录的宏不在C中出现，因为相应的语言结构不出现在C 中。

如果你正在开发一个“后端”，一个代码生成器或一些其它工具，
使用了该表示，你可能偶然发现需要询问一些问题，
并且这些问题不好通过这里列出的函数和宏来回答。如果是这种情况，
可能GCC已经支持了你想要的功能，只不过接口并没有记录在这里。
在这种情况下，你应该询问GCC维护者（通过发邮件给@email{gcc@@gcc.gnu.org}），
关于记录你想要的功能。
同样，如果你发现你自己写的函数并不是直接处理你的后端，
而是可能对其他使用GCC前端的人有帮助，你应该将你的patch提交纳入GCC。

@menu
* 不足之处::        在该文档中没有涵盖的专题。
* Tree概述::        所有关于@code{tree}的。
* 类型::            基本类型和聚合类型。
* 作用域::          命名空间和类。
* 函数::            重载，函数体和连接。
* 声明::            类型声明和变量。
* 属性::            声明和类型属性。
* 表达式tree::      从@code{typeid}到@code{throw}。
@end menu

@c ---------------------------------------------------------------------
@c Deficiencies
@c ---------------------------------------------------------------------

@node 不足之处
@section 不足之处

该文档中有许多地方不完整并且有错误。目前，还只是一个@emph{初步的}文档。

@c ---------------------------------------------------------------------
@c Overview
@c ---------------------------------------------------------------------

@node Tree概述
@section 概述
@cindex tree
@findex TREE_CODE

内部表示使用的主要数据结构体为@code{tree}。
这些节点，即所有C类型的@code{tree}，有许多种类。
@code{tree}是一个指针类型，但是它所指向的对象可能会有不同的类型。
从现在开始，除非是在谈论实际的C类型@code{tree}，
我们提到的树都是指普通类型的。

可以通过@code{TREE_CODE}宏来得知特定的树是什么类型的节点。
许多宏以树作为输入，并以树作为输出返回。
然而，大多数宏需要特定的一种树节点作为输入。
换句话说，是有一个树的类型系统，但没有反应在C的类型系统中。

出于安全考虑，使用@option{--enable-checking}来配置GCC会很有用。
虽然这会导致显著的性能亏损（因为所有tree类型都会在运行时被检查），
并且因此在发行版中不合适，但在开发阶段会非常有帮助。

许多宏作为判定条件使用。许多并不是所有的这些判定条件都结束于@samp{_P}。
不要依赖于这些宏的结果类型会是特定的类型。
但是，你可以依赖于类型可以与@code{0}相比较，这个事实。所以，像这样的语句

@smallexample
if (TEST_P (t) && !TEST_P (y))
  x = 1;
@end smallexample
@noindent
和
@smallexample
int i = (TEST_P (t) != 0);
@end smallexample
@noindent
是合法的。现在返回@code{int}值的宏，将来可能被改为返回@code{tree}值，
或者其它指针。即使那些继续返回@code{int}的，也可能会由先前只返回0和1，
改为返回多个非0的代码。因此，不要将代码写成

@smallexample
if (TEST_P (t) == 1)
@end smallexample
@noindent
因为这样的代码不保证将来会正确工作。

不要使用这里描述的宏或者函数的返回值的地址。
特别是，不保证这些值是左值。

一般来说，宏的名字都是大写形式，而函数的名字都是完全小写的。
很少有例外的。
你应该假设任何完全由大写字母组成的宏或函数可能会对它的参数进行多次求值。
你可以假设完全由小写字母组成的宏或函数将会对它的参数只求一次值。

@code{error_mark_node}是一个特殊的树。它的树代码为@code{ERROR_MARK}，
但由于只有一个节点具有那个代码，
所以通常的做法是将树与@code{error_mark_node}进行比较。
（该测试只是一个指针相等的测试。）如果在前端处理中，有一个错误发生，
则标识@code{errorcount}将会被设置。如果前端遇到无法处理的代码，
则会给用户发送一个消息，并设置@code{sorrycount}。当这些标识被设置时，
则通常返回特定类型树的宏和函数，可能会替代的返回@code{error_mark_node}。
因此，如果你打算进行任何错误代码处理，
则必须准备好跟@code{error_mark_node}打交道。

有时，一个特定的树插槽slot（就像表达式的操作数，或声明里的特定域）
将被称为“为后端保留”。这些插槽用于存储RTL，当树被转换为RTL，被GCC后端使用时。
然而，如果没有进行那种处理（例如，如果前端被钩子转向给一个智能编辑器），
那么这些插槽就可以被使用了。

如果你遇到的情况不符合这个文档，如没有在这里提到的树节点的类型，
或记载的宏返回了不同的某一类型实体，那么你发现了一个bug ，要么是前端的，
要么是该文档的。请报告这些bug，以及是否有任何其他的bug。

@menu
* 宏和函数::      可以用于所有树的宏和函数。
* 标识符::        事物的名字。
* 容器::          列表和向量。
@end menu

@c ---------------------------------------------------------------------
@c Trees
@c ---------------------------------------------------------------------

@node 宏和函数
@subsection Trees
@cindex tree

目前还没有这一节的内容。

@c ---------------------------------------------------------------------
@c Identifiers
@c ---------------------------------------------------------------------

@node 标识符
@subsection 标识符
@cindex identifier
@cindex name
@tindex IDENTIFIER_NODE

@code{IDENTIFIER_NODE}表示了比标准C或C++关于标识符更略为一般的概念。
特别是，@code{IDENTIFIER_NODE}可以包含一个@samp{$}，或其它额外的字符。

不会有两个不同的@code{IDENTIFIER_NODE}表示同一个标识符。
因此，你可以使用指针相等的方式来比较@code{IDENTIFIER_NODE}，
而不必使用像strcmp这样的函数。

可以使用下列宏来访问标识符：

@ftable @code
@item IDENTIFIER_POINTER
标识符所表示的字符串，为一个@code{char*}。
该字符串总是以@code{NUL}结束，并且不包含嵌入的@code{NUL}字符。

@item IDENTIFIER_LENGTH
由@code{IDENTIFIER_POINTER}返回的字符串的长度，不包括结尾的@code{NUL}。
@code{IDENTIFIER_LENGTH (x)}的值总是与@code{strlen (IDENTIFIER_POINTER (x))}相同。

@item IDENTIFIER_OPNAME_P
该断言当标识符表示的是重载操作符的名字时有效。这种情况下，
不要依赖@code{IDENTIFIER_POINTER}或@code{IDENTIFIER_LENGTH}的内容。 

@item IDENTIFIER_TYPENAME_P
该断言当标识符表示的是用户定义的转换操作符的名字时有效。这种情况下，
@code{IDENTIFIER_NODE}的@code{TREE_TYPE}持有转换操作符转换后的类型。
@end ftable

@c ---------------------------------------------------------------------
@c Containers
@c ---------------------------------------------------------------------

@node 容器
@subsection 容器
@cindex container
@cindex list
@cindex vector
@tindex TREE_LIST
@tindex TREE_VEC
@findex TREE_PURPOSE
@findex TREE_VALUE
@findex TREE_VEC_LENGTH
@findex TREE_VEC_ELT

有两种通用容器数据结构可以直接用树节点表示。
@code{TREE_LIST}是一个单向链表，每个节点包含两个树。
每个节点都有@code{TREE_PURPOSE}和@code{TREE_VALUE}。
（很多时候，@code{TREE_PURPOSE}包含了某种tag，或补充信息，
而@code{TREE_VALUE}包含了大部分的有效载荷。在其他情况下，
@code{TREE_PURPOSE}只是一个@code{NULL_TREE}，而还有一些情况，
@code{TREE_PURPOSE}和@code{TREE_VALUE}是处于相等的状况。）
给定一个@code{TREE_LIST}节点，可以沿着@code{TREE_CHAIN}来找到下一个节点。
如果@code{TREE_CHAIN}为@code{NULL_TREE}时，则表示到达链表的结尾了。

@code{TREE_VEC}是一个简单的向量。@code{TREE_VEC_LENGTH}是一个整数（不是树），
给出了向量中节点的数目。节点本身通过宏@code{TREE_VEC_ELT}来访问，
其接受两个参数。第一个为要查询的@code{TREE_VEC}；
第二个为整数，指定了向量中的元素。元素索引从0开始。

@c ---------------------------------------------------------------------
@c Types
@c ---------------------------------------------------------------------

@node 类型
@section 类型
@cindex type
@cindex pointer
@cindex reference
@cindex fundamental type
@cindex array
@tindex VOID_TYPE
@tindex INTEGER_TYPE
@tindex TYPE_MIN_VALUE
@tindex TYPE_MAX_VALUE
@tindex REAL_TYPE
@tindex FIXED_POINT_TYPE
@tindex COMPLEX_TYPE
@tindex ENUMERAL_TYPE
@tindex BOOLEAN_TYPE
@tindex POINTER_TYPE
@tindex REFERENCE_TYPE
@tindex FUNCTION_TYPE
@tindex METHOD_TYPE
@tindex ARRAY_TYPE
@tindex RECORD_TYPE
@tindex UNION_TYPE
@tindex UNKNOWN_TYPE
@tindex OFFSET_TYPE
@tindex TYPENAME_TYPE
@tindex TYPEOF_TYPE
@findex CP_TYPE_QUALS
@findex TYPE_UNQUALIFIED
@findex TYPE_QUAL_CONST
@findex TYPE_QUAL_VOLATILE
@findex TYPE_QUAL_RESTRICT
@findex TYPE_MAIN_VARIANT
@cindex qualified type
@findex TYPE_SIZE
@findex TYPE_ALIGN
@findex TYPE_PRECISION
@findex TYPE_ARG_TYPES
@findex TYPE_METHOD_BASETYPE
@findex TYPE_PTRMEM_P
@findex TYPE_OFFSET_BASETYPE
@findex TREE_TYPE
@findex TYPE_CONTEXT
@findex TYPE_NAME
@findex TYPENAME_TYPE_FULLNAME
@findex TYPE_FIELDS
@findex TYPE_PTROBV_P
@findex TYPE_CANONICAL
@findex TYPE_STRUCTURAL_EQUALITY_P
@findex SET_TYPE_STRUCTURAL_EQUALITY

所有的类型都有相应的树节点。
但是不要假设一个树节点就是正好对应于一个类型。
经常有多个节点对应于相同的类型。

在大多数情况下，不同种类的类型具有不同的树代码。
（例如，指针类型使用@code{POINTER_TYPE}代码，
而数组使用@code{ARRAY_TYPE}代码。）但是，
指向成员函数的指针使用@code{RECORD_TYPE}代码。
因此，当写与特定类型相关联的@code{switch}语句时，
应该在@code{RECORD_TYPE} case标签下小心处理指向成员函数的指针。

在C++中，数组类型没有被限定，而是数组元素的类型被限定。
这种情况反映在中间表示中。这里描述的宏在应用到数组类型时，
将总是检验元素类型的限定符。（如果元素类型本身是一个数组，
则会递归执行只到找到非数组类型，并检验该类型的限定符）所以，
例如，@code{CP_TYPE_CONST_P}当表示具有七个@code{int}的数组时，
将持有@code{const int ()[7]}类型。

下列函数和宏处理cv-qualification的类型：

@ftable @code
@item CP_TYPE_QUALS
该宏返回应用到该类型的类型限定符集。
如果没有应用限定符则该值为@code{TYPE_UNQUALIFIED}。
如果类型是@code{const}的，则会设置@code{TYPE_QUAL_CONST}位。
如果类型是@code{volatile}的，则会设置@code{TYPE_QUAL_VOLATILE}位。
如果类型是@code{restrict}的，则会设置@code{TYPE_QUAL_RESTRICT}位。 

@item CP_TYPE_CONST_P
该宏当类型是@code{const}时有效。

@item CP_TYPE_VOLATILE_P
该宏当类型是@code{volatile}时有效。 

@item CP_TYPE_RESTRICT_P
该宏当类型是@code{restrict}时有效。 

@item CP_TYPE_CONST_NON_VOLATILE_P
该断言当类型是@code{const}的，但@emph{不是}@code{volatile}的时有效。
其它cv-qualifiers会被忽略，只测试@code{const}。 

@item TYPE_MAIN_VARIANT
该宏类型未限定的版本。可以用于一个未限定的类型，但这种情况下，
并不总是标识符函数。 
@end ftable

一些其它的宏和函数可用于所有的类型：
@ftable @code
@item TYPE_SIZE
类型表示所需要的位数，为一个@code{INTEGER_CST}。
对于不完全类型，@code{TYPE_SIZE}将为@code{NULL_TREE}。 

@item TYPE_ALIGN
类型的对齐位数，为一个@code{int}。 

@item TYPE_NAME
该宏返回类型的一个声明（按照@code{TYPE_DECL}的型式）。
（注意该宏不返回@code{IDENTIFIER_NODE}）
你可以查看@code{TYPE_DECL}的@code{DECL_NAME}来获得类型的实际的名字。
@code{TYPE_NAME}将为@code{NULL_TREE}，对于不是内建类型的，typedef的，
或者命名的class类型。

@item CP_INTEGRAL_TYPE
该断言有效，如果类型为一个整数类型。注意在C++中，枚举@emph{不是}整数类型。 

@item ARITHMETIC_TYPE_P
该断言有效，如果类型为一个整数类型（按照c++的观点）或者一个浮点类型。 

@item CLASS_TYPE_P
该断言有效，对于一个class类型。 

@item TYPE_BUILT_IN
该断言有效，对于一个内建类型。 

@item TYPE_PTRMEM_P
该断言有效，如果类型为一个指向数据成员的指针。 

@item TYPE_PTR_P
该断言有效，如果类型为一个指针，而指向者不是一个数据成员。 

@item TYPE_PTRFN_P
该断言有效，对于一个执行函数类型的指针。 

@item TYPE_PTROB_P
该断言有效，对于一个指向object类型的指针。
注意其对于指向object类型@code{void *}的通用指针无效。
你可以使用@code{TYPE_PTROBV_P}来测试指针是指向object类型，
同时也是@code{void *}。 

@item TYPE_CANONICAL
This macro returns the ``canonical'' type for the given type
node. Canonical types are used to improve performance in the C++ and
Objective-C++ front ends by allowing efficient comparison between two
type nodes in @code{same_type_p}: if the @code{TYPE_CANONICAL} values
of the types are equal, the types are equivalent; otherwise, the types
are not equivalent. The notion of equivalence for canonical types is
the same as the notion of type equivalence in the language itself. For
instance,

When @code{TYPE_CANONICAL} is @code{NULL_TREE}, there is no canonical
type for the given type node. In this case, comparison between this
type and any other type requires the compiler to perform a deep,
``structural'' comparison to see if the two type nodes have the same
form and properties.

The canonical type for a node is always the most fundamental type in
the equivalence class of types. For instance, @code{int} is its own
canonical type. A typedef @code{I} of @code{int} will have @code{int}
as its canonical type. Similarly, @code{I*}@ and a typedef @code{IP}@
(defined to @code{I*}) will has @code{int*} as their canonical
type. When building a new type node, be sure to set
@code{TYPE_CANONICAL} to the appropriate canonical type. If the new
type is a compound type (built from other types), and any of those
other types require structural equality, use
@code{SET_TYPE_STRUCTURAL_EQUALITY} to ensure that the new type also
requires structural equality. Finally, if for some reason you cannot
guarantee that @code{TYPE_CANONICAL} will point to the canonical type,
use @code{SET_TYPE_STRUCTURAL_EQUALITY} to make sure that the new
type--and any type constructed based on it--requires structural
equality. If you suspect that the canonical type system is
miscomparing types, pass @code{--param verify-canonical-types=1} to
the compiler or configure with @code{--enable-checking} to force the
compiler to verify its canonical-type comparisons against the
structural comparisons; the compiler will then print any warnings if
the canonical types miscompare.

@item TYPE_STRUCTURAL_EQUALITY_P
This predicate holds when the node requires structural equality
checks, e.g., when @code{TYPE_CANONICAL} is @code{NULL_TREE}.

@item SET_TYPE_STRUCTURAL_EQUALITY
This macro states that the type node it is given requires structural
equality checks, e.g., it sets @code{TYPE_CANONICAL} to
@code{NULL_TREE}.

@item same_type_p
This predicate takes two types as input, and holds if they are the same
type.  For example, if one type is a @code{typedef} for the other, or
both are @code{typedef}s for the same type.  This predicate also holds if
the two trees given as input are simply copies of one another; i.e.,
there is no difference between them at the source level, but, for
whatever reason, a duplicate has been made in the representation.  You
should never use @code{==} (pointer equality) to compare types; always
use @code{same_type_p} instead.
@end ftable

Detailed below are the various kinds of types, and the macros that can
be used to access them.  Although other kinds of types are used
elsewhere in G++, the types described here are the only ones that you
will encounter while examining the intermediate representation.

@table @code
@item VOID_TYPE
用于表示@code{void}类型。 

@item INTEGER_TYPE
Used to represent the various integral types, including @code{char},
@code{short}, @code{int}, @code{long}, and @code{long long}.  This code
is not used for enumeration types, nor for the @code{bool} type.
The @code{TYPE_PRECISION} is the number of bits used in
the representation, represented as an @code{unsigned int}.  (Note that
in the general case this is not the same value as @code{TYPE_SIZE};
suppose that there were a 24-bit integer type, but that alignment
requirements for the ABI required 32-bit alignment.  Then,
@code{TYPE_SIZE} would be an @code{INTEGER_CST} for 32, while
@code{TYPE_PRECISION} would be 24.)  The integer type is unsigned if
@code{TYPE_UNSIGNED} holds; otherwise, it is signed.

The @code{TYPE_MIN_VALUE} is an @code{INTEGER_CST} for the smallest
integer that may be represented by this type.  Similarly, the
@code{TYPE_MAX_VALUE} is an @code{INTEGER_CST} for the largest integer
that may be represented by this type.

@item REAL_TYPE
Used to represent the @code{float}, @code{double}, and @code{long
double} types.  The number of bits in the floating-point representation
is given by @code{TYPE_PRECISION}, as in the @code{INTEGER_TYPE} case.

@item FIXED_POINT_TYPE
Used to represent the @code{short _Fract}, @code{_Fract}, @code{long
_Fract}, @code{long long _Fract}, @code{short _Accum}, @code{_Accum},
@code{long _Accum}, and @code{long long _Accum} types.  The number of bits
in the fixed-point representation is given by @code{TYPE_PRECISION},
as in the @code{INTEGER_TYPE} case.  There may be padding bits, fractional
bits and integral bits.  The number of fractional bits is given by
@code{TYPE_FBIT}, and the number of integral bits is given by @code{TYPE_IBIT}.
The fixed-point type is unsigned if @code{TYPE_UNSIGNED} holds; otherwise,
it is signed.
The fixed-point type is saturating if @code{TYPE_SATURATING} holds; otherwise,
it is not saturating.

@item COMPLEX_TYPE
Used to represent GCC built-in @code{__complex__} data types.  The
@code{TREE_TYPE} is the type of the real and imaginary parts.

@item ENUMERAL_TYPE
Used to represent an enumeration type.  The @code{TYPE_PRECISION} gives
(as an @code{int}), the number of bits used to represent the type.  If
there are no negative enumeration constants, @code{TYPE_UNSIGNED} will
hold.  The minimum and maximum enumeration constants may be obtained
with @code{TYPE_MIN_VALUE} and @code{TYPE_MAX_VALUE}, respectively; each
of these macros returns an @code{INTEGER_CST}.

The actual enumeration constants themselves may be obtained by looking
at the @code{TYPE_VALUES}.  This macro will return a @code{TREE_LIST},
containing the constants.  The @code{TREE_PURPOSE} of each node will be
an @code{IDENTIFIER_NODE} giving the name of the constant; the
@code{TREE_VALUE} will be an @code{INTEGER_CST} giving the value
assigned to that constant.  These constants will appear in the order in
which they were declared.  The @code{TREE_TYPE} of each of these
constants will be the type of enumeration type itself.

@item BOOLEAN_TYPE
用来表示@code{bool}类型。

@item POINTER_TYPE
Used to represent pointer types, and pointer to data member types.  The
@code{TREE_TYPE} gives the type to which this type points.  If the type
is a pointer to data member type, then @code{TYPE_PTRMEM_P} will hold.
For a pointer to data member type of the form @samp{T X::*},
@code{TYPE_PTRMEM_CLASS_TYPE} will be the type @code{X}, while
@code{TYPE_PTRMEM_POINTED_TO_TYPE} will be the type @code{T}.

@item REFERENCE_TYPE
Used to represent reference types.  The @code{TREE_TYPE} gives the type
to which this type refers.

@item FUNCTION_TYPE
Used to represent the type of non-member functions and of static member
functions.  The @code{TREE_TYPE} gives the return type of the function.
The @code{TYPE_ARG_TYPES} are a @code{TREE_LIST} of the argument types.
The @code{TREE_VALUE} of each node in this list is the type of the
corresponding argument; the @code{TREE_PURPOSE} is an expression for the
default argument value, if any.  If the last node in the list is
@code{void_list_node} (a @code{TREE_LIST} node whose @code{TREE_VALUE}
is the @code{void_type_node}), then functions of this type do not take
variable arguments.  Otherwise, they do take a variable number of
arguments.

Note that in C (but not in C++) a function declared like @code{void f()}
is an unprototyped function taking a variable number of arguments; the
@code{TYPE_ARG_TYPES} of such a function will be @code{NULL}.

@item METHOD_TYPE
Used to represent the type of a non-static member function.  Like a
@code{FUNCTION_TYPE}, the return type is given by the @code{TREE_TYPE}.
The type of @code{*this}, i.e., the class of which functions of this
type are a member, is given by the @code{TYPE_METHOD_BASETYPE}.  The
@code{TYPE_ARG_TYPES} is the parameter list, as for a
@code{FUNCTION_TYPE}, and includes the @code{this} argument.

@item ARRAY_TYPE
Used to represent array types.  The @code{TREE_TYPE} gives the type of
the elements in the array.  If the array-bound is present in the type,
the @code{TYPE_DOMAIN} is an @code{INTEGER_TYPE} whose
@code{TYPE_MIN_VALUE} and @code{TYPE_MAX_VALUE} will be the lower and
upper bounds of the array, respectively.  The @code{TYPE_MIN_VALUE} will
always be an @code{INTEGER_CST} for zero, while the
@code{TYPE_MAX_VALUE} will be one less than the number of elements in
the array, i.e., the highest value which may be used to index an element
in the array.

@item RECORD_TYPE
Used to represent @code{struct} and @code{class} types, as well as
pointers to member functions and similar constructs in other languages.
@code{TYPE_FIELDS} contains the items contained in this type, each of
which can be a @code{FIELD_DECL}, @code{VAR_DECL}, @code{CONST_DECL}, or
@code{TYPE_DECL}.  You may not make any assumptions about the ordering
of the fields in the type or whether one or more of them overlap.  If
@code{TYPE_PTRMEMFUNC_P} holds, then this type is a pointer-to-member
type.  In that case, the @code{TYPE_PTRMEMFUNC_FN_TYPE} is a
@code{POINTER_TYPE} pointing to a @code{METHOD_TYPE}.  The
@code{METHOD_TYPE} is the type of a function pointed to by the
pointer-to-member function.  If @code{TYPE_PTRMEMFUNC_P} does not hold,
this type is a class type.  For more information, see @pxref{Classes}.

@item UNION_TYPE
Used to represent @code{union} types.  Similar to @code{RECORD_TYPE}
except that all @code{FIELD_DECL} nodes in @code{TYPE_FIELD} start at
bit position zero.

@item QUAL_UNION_TYPE
Used to represent part of a variant record in Ada.  Similar to
@code{UNION_TYPE} except that each @code{FIELD_DECL} has a
@code{DECL_QUALIFIER} field, which contains a boolean expression that
indicates whether the field is present in the object.  The type will only
have one field, so each field's @code{DECL_QUALIFIER} is only evaluated
if none of the expressions in the previous fields in @code{TYPE_FIELDS}
are nonzero.  Normally these expressions will reference a field in the
outer object using a @code{PLACEHOLDER_EXPR}.

@item UNKNOWN_TYPE
This node is used to represent a type the knowledge of which is
insufficient for a sound processing.

@item OFFSET_TYPE
This node is used to represent a pointer-to-data member.  For a data
member @code{X::m} the @code{TYPE_OFFSET_BASETYPE} is @code{X} and the
@code{TREE_TYPE} is the type of @code{m}.

@item TYPENAME_TYPE
Used to represent a construct of the form @code{typename T::A}.  The
@code{TYPE_CONTEXT} is @code{T}; the @code{TYPE_NAME} is an
@code{IDENTIFIER_NODE} for @code{A}.  If the type is specified via a
template-id, then @code{TYPENAME_TYPE_FULLNAME} yields a
@code{TEMPLATE_ID_EXPR}.  The @code{TREE_TYPE} is non-@code{NULL} if the
node is implicitly generated in support for the implicit typename
extension; in which case the @code{TREE_TYPE} is a type node for the
base-class.

@item TYPEOF_TYPE
用于表示@code{__typeof__}扩展。@code{TYPE_FIELDS}为被表示的类型的表达式。 
@end table

有些变量，它们的值表示基本的类型。这包括：
@table @code
@item void_type_node
@code{void}节点。

@item integer_type_node
@code{int}节点。

@item unsigned_type_node.
@code{unsigned int}节点。

@item char_type_node.
@code{char}节点。
@end table
@noindent
有时使用@code{same_type_p}将这些变量和手头的类型进行比较会很有帮助。 

@c ---------------------------------------------------------------------
@c Scopes
@c ---------------------------------------------------------------------

@node 作用域
@section 作用域
@cindex namespace, class, scope

整个中间表示的根是变量@code{global_namespace}。
这是在C++源代码中由@code{::}描述的命名空间。
所有其它命名空间，类型，变量，函数等，都能够从这里开始查找而获得。

除了命名空间以外，C++中另一个高层次的作用域结构是类。
（在该手册中，术语@dfn{class}用来表示ANSI/ISO C++标准中的@code{class}类型；
这包括用@code{class}, @code{struct}和@code{union}关键字定义的类型。）

@menu
* 命名空间::     成员函数，类型等。
* 类::           成员，基类，友员等。
@end menu

@c ---------------------------------------------------------------------
@c Namespaces
@c ---------------------------------------------------------------------

@node 命名空间
@subsection 命名空间
@cindex namespace
@tindex NAMESPACE_DECL

命名空间由@code{NAMESPACE_DECL}节点表示。

然而，除了实际上是作为根表示以外，全局命名空间与其它命名空间没有区别。
因此，在下文中，我们描述的是普遍的命名空间，而不是特定的全局命名空间。

下列宏和函数可以用于@code{NAMESPACE_DECL}:

@ftable @code
@item DECL_NAME
该宏用于获得@code{IDENTIFIER_NODE}相应的命名空间的未限定名
（参见 @ref{标识符}）。
全局命名空间的名字为@samp{::}，虽然在C++中全局命名空间是没有名字的。
然而，你应该使用与@code{global_namespace}比较的方式，
而不是用@code{DECL_NAME}来确定命名空间是否为全局的。
一个未命名的命名空间，其 @code{DECL_NAME}等于@code{anonymous_namespace_name}。
在一个单独的转换单元中，所有未命名空间将具有同一名字。 

@item DECL_CONTEXT
该宏返回闭包的（enclosing）命名空间。
@code{global_namespace}的@code{DECL_CONTEXT}为@code{NULL_TREE}。 

@item DECL_NAMESPACE_ALIAS
如果该声明是一个命名空间的别名，
则@code{DECL_NAMESPACE_ALIAS}为该别名所针对的命名空间。

不要对别名命名空间尝试使用@code{cp_namespace_decls}。
相反的，沿着@code{DECL_NAMESPACE_ALIAS}链直到一个普通的，非别名的命名空间，
然后在那里调用@code{cp_namespace_decls}。

@item DECL_NAMESPACE_STD_P
该断言当命名空间为特殊的@code{::std}命名空间时有效。 

@item cp_namespace_decls
该函数将返回包含在命名空间中的声明，包括类型，重载函数，其它命名空间等等。
如果没有声明，该函数将返回@code{NULL_TREE}。
声明通过它们的@code{TREE_CHAIN}域连在一起。

虽然这个链表中的大多数实体将为声明，但也可能会出现@code{TREE_LIST}。
这种情况下，@code{TREE_VALUE}将为一个@code{OVERLOAD}。
@code{TREE_PURPOSE}的值未指定；后端应该忽略这个值。
至于由@code{cp_namespace_decls}返回的其它种类的声明，
@code{TREE_CHAIN}将会指向该链表中的下一个声明。

关于可以出现在该链表中的各种声明的更多信息，参见 @ref{声明}。
一些声明将不会出现在该链表中。
特别是，@code{FIELD_DECL}, @code{LABEL_DECL}和@code{PARM_DECL}节点。

该函数不能用于设置了@code{DECL_NAMESPACE_ALIAS}的命名空间。

@end ftable

@c ---------------------------------------------------------------------
@c Classes
@c ---------------------------------------------------------------------

@node 类
@subsection 类
@cindex class
@tindex RECORD_TYPE
@tindex UNION_TYPE
@findex CLASSTYPE_DECLARED_CLASS
@findex TYPE_BINFO
@findex BINFO_TYPE
@findex TYPE_FIELDS
@findex TYPE_VFIELD
@findex TYPE_METHODS

类的类型被表示为@code{RECORD_TYPE}或者@code{UNION_TYPE}。
使用@code{union}标签声明的类由@code{UNION_TYPE}来表示，
而使用@code{struct}或者@code{class}标签声明的类由@code{RECORD_TYPE}来表示。
可以使用@code{CLASSTYPE_DECLARED_CLASS}宏来判定一个特定类型是
@code{class}的还是@code{struct}的。
该宏只在类使用@code{class}标签声明时才为真。

几乎所有非函数的成员都在@code{TYPE_FIELDS}列表中。
给出一个成员，可以通过@code{TREE_CHAIN}来找到下一个。
不要依赖于在该链表中出现的域的顺序。链表中的所有节点将为@samp{DECL}节点。
@code{FIELD_DECL}用于表示非静态数据成员，@code{VAR_DECL}用于表示静态数据成员，
而@code{TYPE_DECL}用于表示类型。注意如果在类中声明了枚举类型，
则用于枚举常量的@code{CONST_DECL}将会出现在该链表中。
（当然，枚举类型的@code{TYPE_DECL}也会出现。）链表中没有基类的实体。
特别是，对于一个对象的基类部分“base-class portion”，没有@code{FIELD_DECL}。

@code{TYPE_VFIELD}是编译器生成的域用于指向虚函数表。
它有可能会出现在@code{TYPE_FIELDS}链表中。
然而，后端应该处理@code{TYPE_VFIELD}，
就像@code{TYPE_FIELDS}链表中所有其它实体一样。

函数成员在@code{TYPE_METHODS}链表中。
同样，后续成员可以通过@code{TREE_CHAIN}域来找到。
如果函数是重载的，每个重载函数都会出现；
@code{OVERLOAD}节点不会出现在@code{TYPE_METHODS}链表上。
隐式声明的函数（包括缺省构造函数，复制构造函数，赋值操作和析构函数）
也会出现在该链表中。

每个类都具有一个相关的@dfn{binfo}，其能够通过@code{TYPE_BINFO}获得。
Binfos用于表示基类。由@code{TYPE_BINFO}给出的binfo是退化情况，
让每个类被考虑为它自己的基类。

对基类型的访问可以通过@code{BINFO_BASE_ACCESS}。
这将产生@code{access_public_node}, @code{access_private_node}或
@code{access_protected_node}。
如果基类总是public的，@code{BINFO_BASE_ACCESSES}可以为@code{NULL}。

@code{BINFO_VIRTUAL_P}用于指定binfo是否为虚继承。
其它标识，@code{BINFO_MARKED_P}和
@code{BINFO_FLAG_1}到@code{BINFO_FLAG_6}可以用于语言特定用途。

下列宏可以用在表示class类型的树节点上。

@ftable @code
@item LOCAL_CLASS_P
该断言当是局部类时有效，即在函数体内声明的类。 

@item TYPE_POLYMORPHIC_P
该断言当类至少具有一个虚函数（声明的或者继承的）时有效。 

@item TYPE_HAS_DEFAULT_CONSTRUCTOR
该断言当参数表示具有缺省构造函数的class类型时有效。 

@item CLASSTYPE_HAS_MUTABLE
@itemx TYPE_HAS_MUTABLE_P
这些断言表示了一个class-type具有mutable数据成员。 

@item CLASSTYPE_NON_POD_P
该断言表示了不是POD的class-types。 

@item TYPE_HAS_NEW_OPERATOR
该断言表示一个class-type定义了@code{operator new}。

@item TYPE_HAS_ARRAY_NEW_OPERATOR
该断言表示一个class-type定义了@code{operator new[]}。

@item TYPE_OVERLOADS_CALL_EXPR
该断言表示class-type重载了函数调用@code{operator()}。

@item TYPE_OVERLOADS_ARRAY_REF
该断言表示class-type重载了@code{operator[]}。

@item TYPE_OVERLOADS_ARROW
该断言表示class-type重载了@code{operator->}。
@end ftable

@c ---------------------------------------------------------------------
@c Declarations
@c ---------------------------------------------------------------------

@node 声明
@section 声明
@cindex declaration
@cindex variable
@cindex type declaration
@tindex LABEL_DECL
@tindex CONST_DECL
@tindex TYPE_DECL
@tindex VAR_DECL
@tindex PARM_DECL
@tindex FIELD_DECL
@tindex NAMESPACE_DECL
@tindex RESULT_DECL
@tindex TEMPLATE_DECL
@tindex THUNK_DECL
@tindex USING_DECL
@findex THUNK_DELTA
@findex DECL_INITIAL
@findex DECL_SIZE
@findex DECL_ALIGN
@findex DECL_EXTERNAL
这一节涵盖了出现在内部表示中的各种声明。
函数声明（由@code{FUNCTION_DECL}节点表示）除外，其在@ref{函数}一节中描述。

@menu
* 关于声明的操作::  作用于声明的宏和函数。
* 内部结构::        声明节点是如何表示的。 
@end menu

@node 关于声明的操作
@subsection 关于声明的操作
一些宏可以用于任何种类的声明。这包括：
@ftable @code
@item DECL_NAME
This macro returns an @code{IDENTIFIER_NODE} giving the name of the
entity.

@item TREE_TYPE
This macro returns the type of the entity declared.

@item TREE_FILENAME
This macro returns the name of the file in which the entity was
declared, as a @code{char*}.  For an entity declared implicitly by the
compiler (like @code{__builtin_memcpy}), this will be the string
@code{"<internal>"}.

@item TREE_LINENO
This macro returns the line number at which the entity was declared, as
an @code{int}.

@item DECL_ARTIFICIAL
This predicate holds if the declaration was implicitly generated by the
compiler.  For example, this predicate will hold of an implicitly
declared member function, or of the @code{TYPE_DECL} implicitly
generated for a class type.  Recall that in C++ code like:
@smallexample
struct S @{@};
@end smallexample
@noindent
is roughly equivalent to C code like:
@smallexample
struct S @{@};
typedef struct S S;
@end smallexample
The implicitly generated @code{typedef} declaration is represented by a
@code{TYPE_DECL} for which @code{DECL_ARTIFICIAL} holds.

@item DECL_NAMESPACE_SCOPE_P
This predicate holds if the entity was declared at a namespace scope.

@item DECL_CLASS_SCOPE_P
This predicate holds if the entity was declared at a class scope.

@item DECL_FUNCTION_SCOPE_P
This predicate holds if the entity was declared inside a function
body.

@end ftable

The various kinds of declarations include:
@table @code
@item LABEL_DECL
These nodes are used to represent labels in function bodies.  For more
information, see @ref{Functions}.  These nodes only appear in block
scopes.

@item CONST_DECL
These nodes are used to represent enumeration constants.  The value of
the constant is given by @code{DECL_INITIAL} which will be an
@code{INTEGER_CST} with the same type as the @code{TREE_TYPE} of the
@code{CONST_DECL}, i.e., an @code{ENUMERAL_TYPE}.

@item RESULT_DECL
These nodes represent the value returned by a function.  When a value is
assigned to a @code{RESULT_DECL}, that indicates that the value should
be returned, via bitwise copy, by the function.  You can use
@code{DECL_SIZE} and @code{DECL_ALIGN} on a @code{RESULT_DECL}, just as
with a @code{VAR_DECL}.

@item TYPE_DECL
These nodes represent @code{typedef} declarations.  The @code{TREE_TYPE}
is the type declared to have the name given by @code{DECL_NAME}.  In
some cases, there is no associated name.

@item VAR_DECL
These nodes represent variables with namespace or block scope, as well
as static data members.  The @code{DECL_SIZE} and @code{DECL_ALIGN} are
analogous to @code{TYPE_SIZE} and @code{TYPE_ALIGN}.  For a declaration,
you should always use the @code{DECL_SIZE} and @code{DECL_ALIGN} rather
than the @code{TYPE_SIZE} and @code{TYPE_ALIGN} given by the
@code{TREE_TYPE}, since special attributes may have been applied to the
variable to give it a particular size and alignment.  You may use the
predicates @code{DECL_THIS_STATIC} or @code{DECL_THIS_EXTERN} to test
whether the storage class specifiers @code{static} or @code{extern} were
used to declare a variable.

If this variable is initialized (but does not require a constructor),
the @code{DECL_INITIAL} will be an expression for the initializer.  The
initializer should be evaluated, and a bitwise copy into the variable
performed.  If the @code{DECL_INITIAL} is the @code{error_mark_node},
there is an initializer, but it is given by an explicit statement later
in the code; no bitwise copy is required.

GCC provides an extension that allows either automatic variables, or
global variables, to be placed in particular registers.  This extension
is being used for a particular @code{VAR_DECL} if @code{DECL_REGISTER}
holds for the @code{VAR_DECL}, and if @code{DECL_ASSEMBLER_NAME} is not
equal to @code{DECL_NAME}.  In that case, @code{DECL_ASSEMBLER_NAME} is
the name of the register into which the variable will be placed.

@item PARM_DECL
Used to represent a parameter to a function.  Treat these nodes
similarly to @code{VAR_DECL} nodes.  These nodes only appear in the
@code{DECL_ARGUMENTS} for a @code{FUNCTION_DECL}.

The @code{DECL_ARG_TYPE} for a @code{PARM_DECL} is the type that will
actually be used when a value is passed to this function.  It may be a
wider type than the @code{TREE_TYPE} of the parameter; for example, the
ordinary type might be @code{short} while the @code{DECL_ARG_TYPE} is
@code{int}.

@item FIELD_DECL
These nodes represent non-static data members.  The @code{DECL_SIZE} and
@code{DECL_ALIGN} behave as for @code{VAR_DECL} nodes.  
The position of the field within the parent record is specified by a 
combination of three attributes.  @code{DECL_FIELD_OFFSET} is the position,
counting in bytes, of the @code{DECL_OFFSET_ALIGN}-bit sized word containing
the bit of the field closest to the beginning of the structure.  
@code{DECL_FIELD_BIT_OFFSET} is the bit offset of the first bit of the field
within this word; this may be nonzero even for fields that are not bit-fields,
since @code{DECL_OFFSET_ALIGN} may be greater than the natural alignment
of the field's type.

If @code{DECL_C_BIT_FIELD} holds, this field is a bit-field.  In a bit-field,
@code{DECL_BIT_FIELD_TYPE} also contains the type that was originally
specified for it, while DECL_TYPE may be a modified type with lesser precision,
according to the size of the bit field.

@item NAMESPACE_DECL
@xref{Namespaces}.

@item TEMPLATE_DECL

These nodes are used to represent class, function, and variable (static
data member) templates.  The @code{DECL_TEMPLATE_SPECIALIZATIONS} are a
@code{TREE_LIST}.  The @code{TREE_VALUE} of each node in the list is a
@code{TEMPLATE_DECL}s or @code{FUNCTION_DECL}s representing
specializations (including instantiations) of this template.  Back ends
can safely ignore @code{TEMPLATE_DECL}s, but should examine
@code{FUNCTION_DECL} nodes on the specializations list just as they
would ordinary @code{FUNCTION_DECL} nodes.

For a class template, the @code{DECL_TEMPLATE_INSTANTIATIONS} list
contains the instantiations.  The @code{TREE_VALUE} of each node is an
instantiation of the class.  The @code{DECL_TEMPLATE_SPECIALIZATIONS}
contains partial specializations of the class.

@item USING_DECL

Back ends can safely ignore these nodes.

@end table

@node 内部结构
@subsection 内部结构

@code{DECL}节点在内部被表示为层次结构体。

@menu
* 目前的结构层次::     目前DECL节点的结构层次。
* 添加新的DECL节点类型:: 如何给前端添加一个新的DECL节点。
@end menu

@node 目前的结构层次
@subsubsection 目前的结构层次

@table @code

@item struct tree_decl_minimal
这是用于继承的最小结构体，从而使得@code{DECL}宏更加通用。
所包含的域为一个唯一的ID，源位置，上下文和名字。 

@item struct tree_decl_common
该结构体继承于@code{struct tree_decl_minimal}。
包含了大多@code{DECL}节点需要的域，像存储对齐信息，机器模式，大小和属性的域。 

@item struct tree_field_decl
该结构体继承于@code{struct tree_decl_common}。用于表示@code{FIELD_DECL}。

@item struct tree_label_decl
该结构体继承于@code{struct tree_decl_common}。用于表示@code{LABEL_DECL}。 

@item struct tree_translation_unit_decl
该结构体继承于@code{struct tree_decl_common}。
用于表示@code{TRANSLATION_UNIT_DECL}。 

@item struct tree_decl_with_rtl
该结构体继承于@code{struct tree_decl_common}。
包含了一个存储与@code{DECL}节点相关的低层次RTL。

@item struct tree_result_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{RESULT_DECL}。 

@item struct tree_const_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{CONST_DECL}。 

@item struct tree_parm_decl
该结构体继承于@code{struct tree_decl_with_rtl}。
用于表示@code{PARM_DECL}。 

@item struct tree_decl_with_vis
该结构体继承于@code{struct tree_decl_with_rtl}。
包含了存储可视性信息所需要的域，还有一个section名和汇编名。 

@item struct tree_var_decl
该结构体继承于@code{struct tree_decl_with_vis}。
用于表示@code{VAR_DECL}。

@item struct tree_function_decl
该结构体继承于@code{struct tree_decl_with_vis}。
用于表示@code{FUNCTION_DECL}。
@end table

@node 添加新的DECL节点类型
@subsubsection 添加新的DECL节点类型

增加一个新的@code{DECL}树包含下列步骤

@table @asis

@item Add a new tree code for the @code{DECL} node
For language specific @code{DECL} nodes, there is a @file{.def} file
in each frontend directory where the tree code should be added.
For @code{DECL} nodes that are part of the middle-end, the code should
be added to @file{tree.def}.

@item Create a new structure type for the @code{DECL} node
These structures should inherit from one of the existing structures in
the language hierarchy by using that structure as the first member.

@smallexample
struct tree_foo_decl
@{
   struct tree_decl_with_vis common;
@}
@end smallexample

Would create a structure name @code{tree_foo_decl} that inherits from
@code{struct tree_decl_with_vis}.

For language specific @code{DECL} nodes, this new structure type
should go in the appropriate @file{.h} file.
For @code{DECL} nodes that are part of the middle-end, the structure
type should go in @file{tree.h}.

@item Add a member to the tree structure enumerator for the node
For garbage collection and dynamic checking purposes, each @code{DECL}
node structure type is required to have a unique enumerator value
specified with it.
For language specific @code{DECL} nodes, this new enumerator value
should go in the appropriate @file{.def} file.
For @code{DECL} nodes that are part of the middle-end, the enumerator
values are specified in @file{treestruct.def}.

@item Update @code{union tree_node}
In order to make your new structure type usable, it must be added to
@code{union tree_node}.
For language specific @code{DECL} nodes, a new entry should be added
to the appropriate @file{.h} file of the form
@smallexample
  struct tree_foo_decl GTY ((tag ("TS_VAR_DECL"))) foo_decl;
@end smallexample
For @code{DECL} nodes that are part of the middle-end, the additional
member goes directly into @code{union tree_node} in @file{tree.h}.

@item Update dynamic checking info
In order to be able to check whether accessing a named portion of
@code{union tree_node} is legal, and whether a certain @code{DECL} node
contains one of the enumerated @code{DECL} node structures in the
hierarchy, a simple lookup table is used.
This lookup table needs to be kept up to date with the tree structure
hierarchy, or else checking and containment macros will fail
inappropriately.

For language specific @code{DECL} nodes, their is an @code{init_ts}
function in an appropriate @file{.c} file, which initializes the lookup
table.
Code setting up the table for new @code{DECL} nodes should be added
there.
For each @code{DECL} tree code and enumerator value representing a
member of the inheritance  hierarchy, the table should contain 1 if
that tree code inherits (directly or indirectly) from that member.
Thus, a @code{FOO_DECL} node derived from @code{struct decl_with_rtl},
and enumerator value @code{TS_FOO_DECL}, would be set up as follows
@smallexample
tree_contains_struct[FOO_DECL][TS_FOO_DECL] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_WRTL] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_COMMON] = 1;
tree_contains_struct[FOO_DECL][TS_DECL_MINIMAL] = 1;
@end smallexample

For @code{DECL} nodes that are part of the middle-end, the setup code
goes into @file{tree.c}.

@item Add macros to access any new fields and flags

Each added field or flag should have a macro that is used to access
it, that performs appropriate checking to ensure only the right type of
@code{DECL} nodes access the field.

These macros generally take the following form
@smallexample
#define FOO_DECL_FIELDNAME(NODE) FOO_DECL_CHECK(NODE)->foo_decl.fieldname
@end smallexample
However, if the structure is simply a base class for further
structures, something like the following should be used
@smallexample
#define BASE_STRUCT_CHECK(T) CONTAINS_STRUCT_CHECK(T, TS_BASE_STRUCT)
#define BASE_STRUCT_FIELDNAME(NODE) \
   (BASE_STRUCT_CHECK(NODE)->base_struct.fieldname
@end smallexample

@end table


@c ---------------------------------------------------------------------
@c Functions
@c ---------------------------------------------------------------------

@node 函数
@section 函数
@cindex function
@tindex FUNCTION_DECL
@tindex OVERLOAD
@findex OVL_CURRENT
@findex OVL_NEXT

函数由@code{FUNCTION_DECL}节点表示。
重载函数集有时通过一个@code{OVERLOAD}节点来表示。

@code{OVERLOAD}节点不是一个声明。
所以没有@samp{DECL_}宏用于@code{OVERLOAD}。
@code{OVERLOAD}节点类似于一个@code{TREE_LIST}。
使用@code{OVL_CURRENT}来获得@code{OVERLOAD}节点关联的函数；
使用@code{OVL_NEXT}来获得重载函数列表中下一个@code{OVERLOAD}节点。
宏@code{OVL_CURRENT}和@code{OVL_NEXT}实际上是多态的；
你可以用它们工作于@code{FUNCTION_DECL}节点上，就像在重载上一样。
在@code{FUNCTION_DECL}的情况下，@code{OVL_CURRENT}将总是返回函数本身，
@code{OVL_NEXT}将总是为@code{NULL_TREE}。

要确定函数的作用域，可以使用@code{DECL_CONTEXT}宏。
该宏将返回函数作为其成员的类（或者@code{RECORD_TYPE}或者@code{UNION_TYPE}）
或命名空间（@code{NAMESPACE_DECL}）。对于虚函数，
该宏返回函数被实际定义的类，而不是其声明所在的基类。

如果友函数定义在类的作用域里，
宏@code{DECL_FRIEND_CONTEXT}可以用来判定其定义所在的类。例如，在

@smallexample
class C @{ friend void f() @{@} @};
@end smallexample
@noindent
中，@code{f}的@code{DECL_CONTEXT}将为@code{global_namespace}，
而@code{C}的@code{DECL_FRIEND_CONTEXT}将为@code{RECORD_TYPE}。

在C中，函数的@code{DECL_CONTEXT}可能为另一个函数。
这表示正在使用GNU嵌套函数扩展功能。关于嵌套函数语法的详细内容，
参见GCC手册。嵌套函数可以引用其所包含的函数的局部变量。
这样的引用没有在树结构体里被显示的标记。
如果被引用@code{VAR_DECL}的@code{DECL_CONTEXT}与当前被处理的函数不相同，
并且@code{DECL_EXTERNAL}和@code{DECL_STATIC}都没有持有内容，
则该引用是针对包含的函数的局部变量，后端必须采取合适的行为。

@menu
* 函数基础::   函数名，连接等等。
* 函数体::     组成函数体的语句。
@end menu

@c ---------------------------------------------------------------------
@c Function Basics
@c ---------------------------------------------------------------------

@node 函数基础
@subsection 函数基础
@cindex constructor
@cindex destructor
@cindex copy constructor
@cindex assignment operator
@cindex linkage
@findex DECL_NAME
@findex DECL_ASSEMBLER_NAME
@findex TREE_PUBLIC
@findex DECL_LINKONCE_P
@findex DECL_FUNCTION_MEMBER_P
@findex DECL_CONSTRUCTOR_P
@findex DECL_DESTRUCTOR_P
@findex DECL_OVERLOADED_OPERATOR_P
@findex DECL_CONV_FN_P
@findex DECL_ARTIFICIAL
@findex DECL_GLOBAL_CTOR_P
@findex DECL_GLOBAL_DTOR_P
@findex GLOBAL_INIT_PRIORITY
@findex DECL_FUNCTION_SPECIFIC_TARGET
@findex DECL_FUNCTION_SPECIFIC_OPTIMIZATION

下列宏和函数能够用于@code{FUNCTION_DECL}:
@ftable @code
@item DECL_MAIN_P
该断言判断一个函数是否为程序的入口点@code{::code}。 

@item DECL_NAME
该宏返回函数未限定的名字，为一个@code{IDENTIFIER_NODE}。
对于一个函数模版的实例，@code{DECL_NAME}为模版的未限定名字，
而不是类似@code{f<int>}的东西。当用在编译器隐式生成的构造函数，
析构函数，重载操作符，或者类型转换符，或者任何函数时，
@code{DECL_NAME}的值未定义。关于可以用来区分这些情况的宏，参见下面。 

@item DECL_ASSEMBLER_NAME
This macro returns the mangled name of the function, also an
@code{IDENTIFIER_NODE}.  This name does not contain leading underscores
on systems that prefix all identifiers with underscores.  The mangled
name is computed in the same way on all platforms; if special processing
is required to deal with the object file format used on a particular
platform, it is the responsibility of the back end to perform those
modifications.  (Of course, the back end should not modify
@code{DECL_ASSEMBLER_NAME} itself.)

Using @code{DECL_ASSEMBLER_NAME} will cause additional memory to be
allocated (for the mangled name of the entity) so it should be used
only when emitting assembly code.  It should not be used within the
optimizers to determine whether or not two declarations are the same,
even though some of the existing optimizers do use it in that way.
These uses will be removed over time.

@item DECL_EXTERNAL
该断言判断函数是否未定义。 

@item TREE_PUBLIC
该断言判断函数是否具有外部连接。 

@item DECL_LOCAL_FUNCTION_P
该断言判断函数是否声明在块作用域中，即使具有全局作用域。

@item DECL_ANTICIPATED
该断言判断函数是否为built-in函数，并且函数原形没有显示声明。 

@item DECL_EXTERN_C_FUNCTION_P
该断言判断函数是否声明为`@code{extern "C"}'函数。 

@item DECL_LINKONCE_P
该宏用来判断该函数是否会在不同的转换单元产生多个副本。
合并不同副本是连接器的责任。
模版实例是使用@code{DECL_LINKONCE_P}最常见的例子。
G++会在需要它们的所有转换单元里实例化模版，
然后依赖连接器去移除重复的实例。 

FIXME: 该宏还没有实现。

@item DECL_FUNCTION_MEMBER_P
该宏用来判断函数是否为一个类的成员，而不是命名空间的成员。 

@item DECL_STATIC_FUNCTION_P
该断言用来判断函数是否为一个静态成员函数。 

@item DECL_NONSTATIC_MEMBER_FUNCTION_P
该宏用来判断是否为一个非静态成员函数。 

@item DECL_CONST_MEMFUNC_P
该断言用来判断是否为@code{const}成员函数。 

@item DECL_VOLATILE_MEMFUNC_P
该断言用来判断是否为@code{volatile}成员函数。 

@item DECL_CONSTRUCTOR_P
该宏用来判断函数是否为一个构造函数。 

@item DECL_NONCONVERTING_P
该断言用来判断构造函数是否为一个非转换构造函数。 

@item DECL_COMPLETE_CONSTRUCTOR_P
该断言用来判断函数是否为完全类型的对象的构造函数。 

@item DECL_BASE_CONSTRUCTOR_P
该断言用来判断函数是否为一个基类的子对象的构造函数。 

@item DECL_COPY_CONSTRUCTOR_P
该断言用来判断函数是否为一个复制构造函数。 

@item DECL_DESTRUCTOR_P
该宏用来判断函数是否为一个析构函数。 

@item DECL_COMPLETE_DESTRUCTOR_P
该断言用来判断函数是否为一个完全类型的对象的析构函数。 

@item DECL_OVERLOADED_OPERATOR_P
该宏用来判断函数是否为一个重载操作符。 

@item DECL_CONV_FN_P
该宏用来判断函数是否为一个类型转换操作符。 

@item DECL_GLOBAL_CTOR_P
该断言用来判断函数是否为一个文件作用域的初始化函数。 

@item DECL_GLOBAL_DTOR_P
该断言用来判断函数是否为一个文件作用域的结束化函数。 

@item DECL_THUNK_P
This predicate holds if the function is a thunk.

These functions represent stub code that adjusts the @code{this} pointer
and then jumps to another function.  When the jumped-to function
returns, control is transferred directly to the caller, without
returning to the thunk.  The first parameter to the thunk is always the
@code{this} pointer; the thunk should add @code{THUNK_DELTA} to this
value.  (The @code{THUNK_DELTA} is an @code{int}, not an
@code{INTEGER_CST}.)

Then, if @code{THUNK_VCALL_OFFSET} (an @code{INTEGER_CST}) is nonzero
the adjusted @code{this} pointer must be adjusted again.  The complete
calculation is given by the following pseudo-code:

@smallexample
this += THUNK_DELTA
if (THUNK_VCALL_OFFSET)
  this += (*((ptrdiff_t **) this))[THUNK_VCALL_OFFSET]
@end smallexample

Finally, the thunk should jump to the location given
by @code{DECL_INITIAL}; this will always be an expression for the
address of a function.

@item DECL_NON_THUNK_FUNCTION_P
该断言用来判断函数@emph{不是}一个thunk函数。 

@item GLOBAL_INIT_PRIORITY
如果DECL_GLOBAL_CTOR_P或者DECL_GLOBAL_DTOR_P有效，则该宏给出了函数的初始优先级。连接器将设法安排 DECL_GLOBAL_CTOR_P所保存的所有的函数在递增的顺序下运行，在main被调用之前。当程序退出时，DECL_GLOBAL_DTOR_P所保存的所有函数按照相反的顺序执行。

If either @code{DECL_GLOBAL_CTOR_P} or @code{DECL_GLOBAL_DTOR_P} holds,
then this gives the initialization priority for the function.  The
linker will arrange that all functions for which
@code{DECL_GLOBAL_CTOR_P} holds are run in increasing order of priority
before @code{main} is called.  When the program exits, all functions for
which @code{DECL_GLOBAL_DTOR_P} holds are run in the reverse order.

@item DECL_ARTIFICIAL
该宏保存了函数是否由编译器隐式的生成，而不是被显式的生成。
除了隐式的生成的类成员函数以外，该宏还保存了创建的特定函数，
用来实现静态初始化和析构，来计算运行时信息等等。 

@item DECL_ARGUMENTS
该宏返回函数第一个参数的@code{PARM_DECL}。
后续的@code{PARM_DECL}节点可以通过@code{TREE_CHAIN}来获得。

@item DECL_RESULT
该函数返回函数的@code{RESULT_DECL}。

@item TREE_TYPE
该宏返回函数的@code{FUNCTION_TYPE}或@code{METHOD_TYPE}。

@item TYPE_RAISES_EXCEPTIONS
该宏返回（成员）函数可以引起的异常列表。返回的列表，如果不是NULL，则为TREE_VALUE代表一个类型的节点组成。 
This macro returns the list of exceptions that a (member-)function can
raise.  The returned list, if non @code{NULL}, is comprised of nodes
whose @code{TREE_VALUE} represents a type.

@item TYPE_NOTHROW_P
该断言用来判断是否是使用`@code{()}'形式来指定异常的参数。 

@item DECL_ARRAY_DELETE_OPERATOR_P
该断言用来判断函数是否为一个重载的@code{operator delete[]}。

@item DECL_FUNCTION_SPECIFIC_TARGET
This macro returns a tree node that holds the target options that are
to be used to compile this particular function or @code{NULL_TREE} if
the function is to be compiled with the target options specified on
the command line.

@item DECL_FUNCTION_SPECIFIC_OPTIMIZATION
This macro returns a tree node that holds the optimization options
that are to be used to compile this particular function or
@code{NULL_TREE} if the function is to be compiled with the
optimization options specified on the command line.
@end ftable

@c ---------------------------------------------------------------------
@c Function Bodies
@c ---------------------------------------------------------------------

@node 函数体
@subsection 函数体
@cindex function body
@cindex statements
@tindex BREAK_STMT
@tindex CLEANUP_STMT
@findex CLEANUP_DECL
@findex CLEANUP_EXPR
@tindex CONTINUE_STMT
@tindex DECL_STMT
@findex DECL_STMT_DECL
@tindex DO_STMT
@findex DO_BODY
@findex DO_COND
@tindex EMPTY_CLASS_EXPR
@tindex EXPR_STMT
@findex EXPR_STMT_EXPR
@tindex FOR_STMT
@findex FOR_INIT_STMT
@findex FOR_COND
@findex FOR_EXPR
@findex FOR_BODY
@tindex HANDLER
@tindex IF_STMT
@findex IF_COND
@findex THEN_CLAUSE
@findex ELSE_CLAUSE
@tindex RETURN_STMT
@findex RETURN_EXPR
@tindex SUBOBJECT
@findex SUBOBJECT_CLEANUP
@tindex SWITCH_STMT
@findex SWITCH_COND
@findex SWITCH_BODY
@tindex TRY_BLOCK
@findex TRY_STMTS
@findex TRY_HANDLERS
@findex HANDLER_PARMS
@findex HANDLER_BODY
@findex USING_STMT
@tindex WHILE_STMT
@findex WHILE_BODY
@findex WHILE_COND

在当前转换单元中定义的函数将会有一个非@code{NULL}的@code{DECL_INITIAL}。
但是，后端不应该使用@code{DECL_INITIAL}给出的该特定值。

宏@code{DECL_SAVED_TREE}将会给出完整的函数体。

@subsubsection 语句

C和C++前端，使用了对应于所有源级的语句构造的树节点。
这些都列举在这里，并附上能够用来获得它们的信息的各种宏的列表。
有一些宏能用于所有的语句：

@ftable @code
@item STMT_IS_FULL_EXPR_P
在C++里，语句通常构成“充分表达式（full expressions）”；
在语句中创建的临时事物会在声明完成时被销毁。
然而，G++有时通过语句来表示表达式；
这些语句将不会设置@code{STMT_IS_FULL_EXPR_P}。
在这样的语句中创建的临时事物将会在最内层设置了
@code{STMT_IS_FULL_EXPR_P}的语句退出时被销毁。
@end ftable

这里有一个各种语句节点的列表，以及访问它们的宏。
该文档描述了在非模板函数（包括模板函数的实例）中这些节点的用法。
在模板函数里，使用相同的节点，但是有时方法略有不同。

许多语句具有子语句。例如，一个@code{while}循环将会有一个循环体，
其本身也是一个语句。如果子语句是@code{NULL_TREE}，
则被认为相当于一个@code{;}组成的语句，即一个表达式语句，其中表达式为空。
一个子语句实际上可以为一个语句列表，通过它们的@code{TREE_CHAIN}连接一起。
所以，你应该总是通过循环所有的子语句来处理语句树，像这样：

@smallexample
void process_stmt (stmt)
     tree stmt;
@{
  while (stmt)
    @{
      switch (TREE_CODE (stmt))
        @{
        case IF_STMT:
          process_stmt (THEN_CLAUSE (stmt));
          /* @r{More processing here.}  */
          break;

        @dots{}
        @}

      stmt = TREE_CHAIN (stmt);
    @}
@}
@end smallexample
换句话说，虽然C++中@code{if}语句的@code{then}子句可以只是一个语句，
但中间表示有时会使用多个语句连接在一起。

@table @code
@item ASM_EXPR
用来表示一条内联的汇编语句。一条内联汇编语句形如： 
@smallexample
asm ("mov x, y");
@end smallexample
@code{ASM_STRING}宏将会为@code{"mov x, y"}返回一个@code{STRING_CST}节点。
如果原始的语句使用了扩展汇编语法，则@code{ASM_OUTPUTS}, 
@code{ASM_INPUTS}和@code{ASM_CLOBBERS}为用@code{STRING_CST}表示的语句的输出，
输入和clobber。扩展汇编语法形如：

@smallexample
asm ("fsinx %1,%0" : "=f" (result) : "f" (angle));
@end smallexample
第一个字符串是@code{ASM_STRING}，包含指令模板。
接下来的两个字符串分别是输出和输入。该语句没有clobbers。
这个例子表明，普通的汇编语句只是扩展汇编语句的一个特例；
它们没有限定符，输出，输入或者clobbers。
所有的字符串都为@code{NUL}结尾，并且不包含嵌入的@code{NUL}字符。

如果汇编语句被声明为@code{volatile}，或者语句不是扩展汇编语句，
因此是一个隐式的@code{volatile}，
则断言@code{ASM_VOLATILE_P}将会保存@code{ASM_EXPR}。

@item BREAK_STMT
用来表示一条@code{break}语句。没有额外的域。 

@item CASE_LABEL_EXPR
用来表示一个@code{case}标号，@code{case}标号的范围或者一个@code{default}标号。
如果@code{CASE_LOW}是@code{NULL_TREE}，则为一个@code{default}标号。
否则，如果@code{CASE_HIGH}是@code{NULL_TREE}，则为一个普通的@code{case}标号。
这种情况下，@code{CASE_LOW}是一个表达式，给出了标号的值。
@code{CASE_LOW}和@code{CASE_HIGH}都是@code{INTEGER_CST}节点。
这些值跟在@code{switch}语句中的条件表达式具有相同的类型。 

否则，如果同时定义了@code{CASE_LOW}和@code{CASE_HIGH}，则语句为一个@code{case}标号的范围。这样的语句源于允许用户使用如下形式的扩展：

@smallexample
case 2 ... 5:
@end smallexample
第一个值为@code{CASE_LOW}，第二个为@code{CASE_HIGH}。

@item CLEANUP_STMT
用来表示在封闭作用域的出口上执行的动作。
通常，这些动作是为局部对象调用析构函数，但是后端不能依靠这个事实。
如果这些节点确实是表示了这样的析构函数，
@code{CLEANUP_DECL}将为销毁的@code{VAR_DECL}。
否则@code{CLEANUP_DECL}为@code{NULL_TREE}。
无论哪种情况，@code{CLEANUP_EXPR}都是要被执行的表达式。
清除工作在作用域的出口被执行，
并且按照所遇到的@code{CLEANUP_STMT}的相反顺序进行。

@item CONTINUE_STMT
用来表示一条@code{continue}语句。没有额外的域。 

@item CTOR_STMT
用于标记构建函数体的起始（@code{CTOR_BEGIN_P}）或结尾（@code{CTOR_END_P}）。关于如何使用这些节点的更多信息，参见@code{SUBOBJECT}。 

@item DECL_STMT
用来表示一个局部声明。宏@code{DECL_STMT_DECL}可以用来获得整个声明。
该声明可以为一个@code{LABEL_DECL}，表示声明了一个局部标号。
（作为扩展，GCC允许声明具有作用域的标号。）
在C中，该声明可以为一个@code{FUNCTION_DECL}，表示使用GCC嵌套函数扩展。
更多信息，参见 @ref{函数}。

@item DO_STMT
用来表示@code{do}循环。循环体由@code{DO_BODY}给出，
终止条件由@code{DO_COND}给出。@code{do}语句的条件总是一个表达式。

@item EMPTY_CLASS_EXPR
用来表示类的临时对象。（所有这样的对象都是可互换的。）
@code{TREE_TYPE}表示对象的类型。 

@item EXPR_STMT
用来表示表达式语句。使用@code{EXPR_STMT_EXPR}来获得表达式。 

@item FOR_STMT
用来表示一条@code{for}语句。@code{FOR_INIT_STMT}是循环的初始语句。
@code{FOR_COND}是终止条件。
@code{FOR_INIT_STMT}是在每次循环迭代@code{FOR_COND}之前执行的表达式，
该表达式常常是增加计数器。循环体由@code{FOR_BODY}给出。
注意@code{FOR_INIT_STMT}和@code{FOR_BODY}返回语句，
而@code{FOR_COND}和@code{FOR_EXPR}返回表达式。

@item GOTO_EXPR
用来表示一条@code{goto}语句。
@code{GOTO_DESTINATION}通常为一个@code{LABEL_DECL}。
然而，如果使用了扩展的“computed goto”，将为一个随机表达式用来指示目的地。
该表达式总是具有一个指针类型。 

@item HANDLER
用来表示C++ @code{catch}块。@code{HANDLER_TYPE}是由该处理者捕捉的异常类型。
如果该处理者是针对所有类型的，则等于（指针等于）@code{NULL}。
@code{HANDLER_PARMS}是@code{catch}参数，是一个@code{DECL_STMT}。
@code{HANDLER_BODY}是块本身的代码。 

@item IF_STMT
用来表示一条@code{if}语句。@code{IF_COND}是表达式。
如果条件是一个@code{TREE_LIST}，
则@code{TREE_PURPOSE}是一条语句（通常为 @code{DECL_STMT}）。
每次评估条件的时候，都要执行该语句。
然后，@code{TREE_VALUE}应该作为条件表达式本身来使用。
该表示用来处理C++代码，如： 

@smallexample
if (int i = 7) @dots{}
@end smallexample

其中，在条件中声明了一个（或多个）新的局部变量。

@item LABEL_EXPR
用来表示一个标号。
可以通过@code{LABEL_EXPR_LABEL}宏获得该语句声明的@code{LABEL_DECL}。
可以通过@code{LABEL_DECL}的@code{DECL_NAME}获得给出的标号名字。

@item RETURN_STMT
用来表示一条@code{return}语句。@code{RETURN_EXPR}是返回的表达式，
其将会返回@code{NULL_TREE}，如果语句只是 
@smallexample
return;
@end smallexample

@item SUBOBJECT
在构造函数中，这些节点用来标记在某一点子对象被完全构造。如果，这一点之后，在遇到设置了@code{CTOR_END_P}的@code{CTOR_STMT}之前，有异常抛出，则必须执行@code{SUBOBJECT_CLEANUP}。清除工作必须按照它们出现的顺序反向执行。 

@item SWITCH_STMT
用来表示一个@code{switch}语句。
@code{SWITCH_STMT_COND}是发生@code{switch}的表达式。
更多关于条件表示的信息，参见@code{IF_STMT}文档。
@code{SWITCH_STMT_BODY}是@code{switch}语句主体。
@code{SWITCH_STMT_TYPE}是源代码中给出的@code{switch}表达式的，
在任何编译器转换之前的原始类型。

@item TRY_BLOCK
用来表示一个@code{try}块。@code{try}块的主体由@code{TRY_STMTS}给出。
每个@code{catch}块都是一个@code{HANDLER}节点。
第一个@code{handler}由 @code{TRY_HANDLERS}给出。
后续的@code{handlers}可以通过@code{TREE_CHAIN}获得。
@code{handler}的主体由@code{HANDLER_BODY}给出。

如果@code{CLEANUP_P}持有@code{TRY_BLOCK}，
则@code{TRY_HANDLERS}将不是一个@code{HANDLER}节点。
相反的，其将会是一个表达式，并且如果在@code{try}块中抛出异常时则被执行。
其必须在执行完那些代码之后再重新抛出异常。
并且，如果当表达式正在执行的时候，如果有异常抛出，则必须终止。

@item USING_STMT
用来表示@code{using}指示符。命名空间为一个NAMESPACE_DECL，
由@code{USING_STMT_NAMESPACE}给出。该节点在模板函数内部需要，
用来在实例化时实现@code{using}指示符。 

@item WHILE_STMT
用来表示一个@code{while}循环。@code{WHILE_COND}是循环的终止条件。
关于用来表示条件的更多信息，参见@code{IF_STMT}的文档。
 
@code{WHILE_BODY}是循环体。 
@end table

@c ---------------------------------------------------------------------
@c Attributes
@c ---------------------------------------------------------------------
@node 属性
@section 树中的属性
@cindex attributes

使用关键字@code{__attribute__}指定的属性，在内部作为@code{TREE_LIST}来表示。
@code{TREE_PURPOSE} ，作为一个@code{IDENTIFIER_NODE}，是属性的名字。
如果有参数的话，@code{TREE_VALUE}是一个属性参数的@code{TREE_LIST}，
或者在没有参数时，为@code{NULL_TREE}。
参数作为列表中的@code{TREE_VALUE}后继项存储，并且可以为标识符或者表达式。
属性的@code{TREE_CHAIN}是在属性列表中应用到同一声明或类型的下一个属性，
或者为@code{NULL_TREE}如果列表中没有更多的属性。

属性可以附加到声明和类型上；这些属性可以通过下列宏来访问。
所有的属性都通过这种方式存储，并且许多还对声明和类型，
或者其它内部编译器数据结构体，引起其它的变化。

@deftypefn {Tree Macro} tree DECL_ATTRIBUTES (tree @var{decl})
该宏返回声明@var{decl}上的属性。
@end deftypefn

@deftypefn {Tree Macro} tree TYPE_ATTRIBUTES (tree @var{type})
该宏返回类型@var{type}上的属性。
@end deftypefn

@c ---------------------------------------------------------------------
@c Expressions
@c ---------------------------------------------------------------------

@node 表达式tree
@section 表达式
@cindex expression
@findex TREE_TYPE
@findex TREE_OPERAND
@tindex INTEGER_CST
@findex TREE_INT_CST_HIGH
@findex TREE_INT_CST_LOW
@findex tree_int_cst_lt
@findex tree_int_cst_equal
@tindex REAL_CST
@tindex FIXED_CST
@tindex COMPLEX_CST
@tindex VECTOR_CST
@tindex STRING_CST
@findex TREE_STRING_LENGTH
@findex TREE_STRING_POINTER
@tindex PTRMEM_CST
@findex PTRMEM_CST_CLASS
@findex PTRMEM_CST_MEMBER
@tindex VAR_DECL
@tindex NEGATE_EXPR
@tindex ABS_EXPR
@tindex BIT_NOT_EXPR
@tindex TRUTH_NOT_EXPR
@tindex PREDECREMENT_EXPR
@tindex PREINCREMENT_EXPR
@tindex POSTDECREMENT_EXPR
@tindex POSTINCREMENT_EXPR
@tindex ADDR_EXPR
@tindex INDIRECT_REF
@tindex FIX_TRUNC_EXPR
@tindex FLOAT_EXPR
@tindex COMPLEX_EXPR
@tindex CONJ_EXPR
@tindex REALPART_EXPR
@tindex IMAGPART_EXPR
@tindex NON_LVALUE_EXPR
@tindex NOP_EXPR
@tindex CONVERT_EXPR
@tindex FIXED_CONVERT_EXPR
@tindex THROW_EXPR
@tindex LSHIFT_EXPR
@tindex RSHIFT_EXPR
@tindex BIT_IOR_EXPR
@tindex BIT_XOR_EXPR
@tindex BIT_AND_EXPR
@tindex TRUTH_ANDIF_EXPR
@tindex TRUTH_ORIF_EXPR
@tindex TRUTH_AND_EXPR
@tindex TRUTH_OR_EXPR
@tindex TRUTH_XOR_EXPR
@tindex POINTER_PLUS_EXPR
@tindex PLUS_EXPR
@tindex MINUS_EXPR
@tindex MULT_EXPR
@tindex RDIV_EXPR
@tindex TRUNC_DIV_EXPR
@tindex FLOOR_DIV_EXPR
@tindex CEIL_DIV_EXPR
@tindex ROUND_DIV_EXPR
@tindex TRUNC_MOD_EXPR
@tindex FLOOR_MOD_EXPR
@tindex CEIL_MOD_EXPR
@tindex ROUND_MOD_EXPR
@tindex EXACT_DIV_EXPR
@tindex ARRAY_REF
@tindex ARRAY_RANGE_REF
@tindex TARGET_MEM_REF
@tindex LT_EXPR
@tindex LE_EXPR
@tindex GT_EXPR
@tindex GE_EXPR
@tindex EQ_EXPR
@tindex NE_EXPR
@tindex ORDERED_EXPR
@tindex UNORDERED_EXPR
@tindex UNLT_EXPR
@tindex UNLE_EXPR
@tindex UNGT_EXPR
@tindex UNGE_EXPR
@tindex UNEQ_EXPR
@tindex LTGT_EXPR
@tindex MODIFY_EXPR
@tindex INIT_EXPR
@tindex COMPONENT_REF
@tindex COMPOUND_EXPR
@tindex COND_EXPR
@tindex CALL_EXPR
@tindex STMT_EXPR
@tindex BIND_EXPR
@tindex LOOP_EXPR
@tindex EXIT_EXPR
@tindex CLEANUP_POINT_EXPR
@tindex CONSTRUCTOR
@tindex COMPOUND_LITERAL_EXPR
@tindex SAVE_EXPR
@tindex TARGET_EXPR
@tindex AGGR_INIT_EXPR
@tindex VA_ARG_EXPR
@tindex CHANGE_DYNAMIC_TYPE_EXPR
@tindex OMP_PARALLEL
@tindex OMP_FOR
@tindex OMP_SECTIONS
@tindex OMP_SINGLE
@tindex OMP_SECTION
@tindex OMP_MASTER
@tindex OMP_ORDERED
@tindex OMP_CRITICAL
@tindex OMP_RETURN
@tindex OMP_CONTINUE
@tindex OMP_ATOMIC
@tindex OMP_CLAUSE
@tindex VEC_LSHIFT_EXPR
@tindex VEC_RSHIFT_EXPR
@tindex VEC_WIDEN_MULT_HI_EXPR
@tindex VEC_WIDEN_MULT_LO_EXPR
@tindex VEC_UNPACK_HI_EXPR
@tindex VEC_UNPACK_LO_EXPR
@tindex VEC_UNPACK_FLOAT_HI_EXPR
@tindex VEC_UNPACK_FLOAT_LO_EXPR
@tindex VEC_PACK_TRUNC_EXPR
@tindex VEC_PACK_SAT_EXPR
@tindex VEC_PACK_FIX_TRUNC_EXPR
@tindex VEC_EXTRACT_EVEN_EXPR 
@tindex VEC_EXTRACT_ODD_EXPR
@tindex VEC_INTERLEAVE_HIGH_EXPR
@tindex VEC_INTERLEAVE_LOW_EXPR

表达式的内部表示大多都很简单明了。但是，也有一些事实必须牢记。
尤其是，表达式“tree”实际上是一个有向无环图。（例如，
整个源程序中可能会有许多对常整数0的引用；这些将会由同一个表达式节点来表示。）
当然，你不要以此就认为某些种类的节点是共享的，也不要认为某些种类的节点没有被共享。

下列宏可以用于所有表达式节点：

@ftable @code
@item TREE_TYPE
返回表达式的类型。该值可能不是与原始程序中给出的表达式相同精度的类型。 
@end ftable

在下文中，有些节点可能总是期望具有@code{bool}类型，
但是被记载为具有整形或bool型。将来的某个时刻，
C前端可能也会使用该相同的中间表示，那时，这些节点当然会具有整数类型。
当然，这并不意味着暗示C++前端中这些节点不具有，或者不会具有整数类型。

下面，我们列出了各种表达式节点。除了特别注明的以外，
表达式的操作数都通过@code{TREE_OPERAND}宏来访问。
例如，要访问二元加法表达式@code{expr}的第一个操作数，使用：

@smallexample
TREE_OPERAND (expr, 0)
@end smallexample
@noindent

正如这个例子所示，操作数是从0开始索引的。

所有起始于@code{OMP_}的表达式，
表示使用的是OpenMp API @w{@uref{http://www.openmp.org/}}的directives和clauses。

下面的列表格首先介绍了常数，接着是一元表达式，然后是二元表达式，
以及各种其它类型的表达式：

@table @code
@item INTEGER_CST
这些节点表示整数常量。注意这些常量的类型通过@code{TREE_TYPE}来获得；
并不总是@code{int}型的。特别是，
@code{char}型常量使用@code{INTEGER_CST}节点表示。
整数常量@code{e}的值通过下面的方式给出
@smallexample
((TREE_INT_CST_HIGH (e) << HOST_BITS_PER_WIDE_INT)
+ TREE_INST_CST_LOW (e))
@end smallexample
@noindent
HOST_BITS_PER_WIDE_INT在所有的平台上最少为32。
@code{TREE_INT_CST_HIGH}和@code{TREE_INT_CST_LOW}都返回一个
@code{HOST_WIDE_INT}。
一个@code{INTEGER_CST}的值根据常量的类型而被解析为有符号或无符号的数。
一般来说，上面给出的表达式将会溢出，因此不要用来计算常量的值。

变量@code{integer_zero_node}是一个值为0的整数常量。类似的，
@code{integer_one_node}是值为1的整数常量。
变量@code{size_zero_node}和@code{size_one_node}比较类似，
只是具有@code{size_t}类型，而不是@code{int}。

函数@code{tree_int_cst_lt}是一个断言，当第一个参数小于第二个时有效。
两个常量被假设为具有相同的符号性（即，要么都是有符号的，要么都是无符号的。）
在作比较时，使用常量的全部宽度；并忽略掉通常的类型提升和转换规则。
类似的，@code{tree_int_cst_equal}在两个常熟相等时有效。
函数@code{tree_int_cst_sgn}返回常数的符号。根据常数是大于，等于，或小于0，
而返回值@code{1}, @code{0}或@code{-1}。此外，会顾及到常数类型的符号性；
无符号常数是永远小于0的，不论它的位模式如何。

@item REAL_CST

FIXME: 讨论如何获得该常量的表示，如何进行比较等等。 

@item FIXED_CST

这些节点表示定点常数。这些常量的类型通过@code{TREE_TYPE}获得。@code{TREE_FIXED_CST_PTR}指向struct fixed_value；@code{TREE_FIXED_CST}返回结构体本身。Struct fixed_value包含了具有2个HOST_BITS_PER_WIDE_INT大小的@code{data}，以及与@code{data}关联的定点机器模式@code{mode}。

@item COMPLEX_CST
这些节点用于表示复数常量，即@code{__complex__} ，其组成部分为常数节点。@code{TREE_REALPART}和@code{TREE_IMAGPART}返回相应的实部和虚部。 


@item VECTOR_CST
这些节点用于表示向量常数，其组成部分为常量节点。每个单独的常量节点或者是一个常整数节点，或者是一个双精度的常数节点。第一个操作数为常数节点的@code{TREE_LIST}，并可以通过@code{TREE_VECTOR_CST_ELTS}来访问。 


@item STRING_CST
这些节点表示字符串常量。@code{TREE_STRING_LENGTH}返回@code{int}型的字符串长度。@code{TREE_STRING_POINTER}是一个@code{char*}型，包含了字符串本身。字符串可以不是@code{NUL}结尾的，并且可以包含嵌入的@code{NUL}字符。因此，如果字符串的结尾存在@code{NUL}，则@code{TREE_STRING_LENGTH}也包括了结尾的NUL。

对于宽字符串常量，@code{TREE_STRING_LENGTH}为字符串的字节数，并且@code{TREE_STRING_POINTER}指向在目标系统上表示的，字符串的字节数组（即，符合目标大小端的整数系列）。宽字符串和非宽字符串常量，只区别于@code{STRING_CST}的@code{TREE_TYPE}。

FIXME: 当目标系统的字节与主机系统的字节宽度不同时，字符串的格式没有被很好的定义。


@item PTRMEM_CST
这些节点用来表示指向成员的指针（pointer-to-member）常量。@code{PTRMEM_CST_CLASS}是类的类型（或者为@code{RECORD_TYPE}，或者为@code{UNION_TYPE}），@code{PTRMEM_CST_MEMBER}是指向的对象的声明。注意@code{PTRMEM_CST_MEMBER}的@code{DECL_CONTEXT}一般有别于@code{PTRMEM_CST_CLASS}的。例如，给定： 
@smallexample
struct B @{ int i; @};
struct D : public B @{@};
int D::*dp = &D::i;
@end smallexample
@noindent
虽然@code{PTRMEM_CST_MEMBER}的@code{DECL_CONTEXT}是@code{B}，但是由于@code{B::i}是@code{B}的成员，而不是@code{D}的，所以@code{&D::i}的@code{PTRMEM_CST_CLASS}为@code{D}。


@item VAR_DECL

这些节点表示变量，包括静态数据成员。更多信息，参见@pxref{Declarations}。 


@item NEGATE_EXPR
这些节点表示对单个操作数，整数和浮点类型的，进行一元取负运算。取负的类型可以通过查看表达式的类型来决定。

该操作在有符号算术溢出时的行为，由flag_wrapv和flag_trapv变量控制。
These nodes represent unary negation of the single operand, for both
integer and floating-point types.  The type of negation can be
determined by looking at the type of the expression.

The behavior of this operation on signed arithmetic overflow is
controlled by the @code{flag_wrapv} and @code{flag_trapv} variables.

@item ABS_EXPR
这些节点表示单个操作数，整数和浮点类型的，的绝对值。这通常用于实现整数类型的内建abs，labs和llabs，以及浮点类型的fabs，fabsf和fabsl。abs操作的类型可以通过查看表达式的类型来决定。

该节点不用于复数类型。要表示复数的模或者复数abs，使用内建的BUILT_IN_CABS, BUILT_IN_CABSF or BUILT_IN_CABSL，这些被用于实现C99的内建函数cabs, cabsf和cabsl。
These nodes represent the absolute value of the single operand, for
both integer and floating-point types.  This is typically used to
implement the @code{abs}, @code{labs} and @code{llabs} builtins for
integer types, and the @code{fabs}, @code{fabsf} and @code{fabsl}
builtins for floating point types.  The type of abs operation can
be determined by looking at the type of the expression.

This node is not used for complex types.  To represent the modulus
or complex abs of a complex value, use the @code{BUILT_IN_CABS},
@code{BUILT_IN_CABSF} or @code{BUILT_IN_CABSL} builtins, as used
to implement the C99 @code{cabs}, @code{cabsf} and @code{cabsl}
built-in functions.

@item BIT_NOT_EXPR
这些节点表示按位求补运算，并总是具有整数型。唯一的操作数是要被求补的值。
These nodes represent bitwise complement, and will always have integral
type.  The only operand is the value to be complemented.

@item TRUTH_NOT_EXPR
这些节点表示逻辑非，并总是具有整数（或布尔）类型。操作数是要求非的值。操作数的，以及结果的类型总是BOOLEAN_TYPE或INTEGER_TYPE。 
These nodes represent logical negation, and will always have integral
(or boolean) type.  The operand is the value being negated.  The type
of the operand and that of the result are always of @code{BOOLEAN_TYPE}
or @code{INTEGER_TYPE}.

@item PREDECREMENT_EXPR
@itemx PREINCREMENT_EXPR
@itemx POSTDECREMENT_EXPR
@itemx POSTINCREMENT_EXPR
这些节点表示递增和递减表达式。单操作数的值将被计算，并且操作数递增或递减。在PREDECREMENT_EXPR和 PREINCREMENT_EXPR的情况下，表达式的值是递增或递减之后的结果；在POSTDECREMENT_EXPR和 POSTINCREMENT_EXPR的情况下，表达式的值是递增或递减发生前的值。操作数的值，跟结果的一样，将会是整数，布尔，或浮点的。
These nodes represent increment and decrement expressions.  The value of
the single operand is computed, and the operand incremented or
decremented.  In the case of @code{PREDECREMENT_EXPR} and
@code{PREINCREMENT_EXPR}, the value of the expression is the value
resulting after the increment or decrement; in the case of
@code{POSTDECREMENT_EXPR} and @code{POSTINCREMENT_EXPR} is the value
before the increment or decrement occurs.  The type of the operand, like
that of the result, will be either integral, boolean, or floating-point.

@item ADDR_EXPR
这些节点用于表示对象的地址。（这些表达式将总是具有指针或引用类型。）操作数或者为表达式，或者可以是一个声明。

作为扩展，GCC运行用户使用标号的地址。这种情况下，ADDR_EXPR的操作数将为LABEL_DECL。这样的表达式的类型是void*。

如果求址的对象不是左值，则创建一个临时的，并使用临时对象的地址。
These nodes are used to represent the address of an object.  (These
expressions will always have pointer or reference type.)  The operand may
be another expression, or it may be a declaration.

As an extension, GCC allows users to take the address of a label.  In
this case, the operand of the @code{ADDR_EXPR} will be a
@code{LABEL_DECL}.  The type of such an expression is @code{void*}.

If the object addressed is not an lvalue, a temporary is created, and
the address of the temporary is used.

@item INDIRECT_REF
这些节点用来表示由指针指向的对象。操作数是被dereferenced的指针；其总是具有指针或引用类型。 
These nodes are used to represent the object pointed to by a pointer.
The operand is the pointer being dereferenced; it will always have
pointer or reference type.

@item FIX_TRUNC_EXPR
这些节点表示浮点值到整数的转换。单操作数将具有一个浮点类型，完整的表达式将具有整数（或布尔）类型。操作数向0方向舍入。
These nodes represent conversion of a floating-point value to an
integer.  The single operand will have a floating-point type, while
the complete expression will have an integral (or boolean) type.  The
operand is rounded towards zero.

@item FLOAT_EXPR
这些节点表示整数（或布尔）值向浮点值的转换。单操作数将具有整数类型，而完整的表达式将具有浮点类型。

FIXME: 操作数是如何被舍入的？这是不是取决于-mieee？
These nodes represent conversion of an integral (or boolean) value to a
floating-point value.  The single operand will have integral type, while
the complete expression will have a floating-point type.

FIXME: How is the operand supposed to be rounded?  Is this dependent on
@option{-mieee}?

@item COMPLEX_EXPR
这些节点用于表示通过两个相同类型（整数或实数）的表达式构造的复数。第一个操作数是实部，第二个操作数是虚部。 
These nodes are used to represent complex numbers constructed from two
expressions of the same (integer or real) type.  The first operand is the
real part and the second operand is the imaginary part.

@item CONJ_EXPR
这些节点表示它们的操作数的共轭（conjugate）。 
These nodes represent the conjugate of their operand.

@item REALPART_EXPR
@itemx IMAGPART_EXPR
这些节点表示复数的相应实数和虚数部分。 
These nodes represent respectively the real and the imaginary parts
of complex numbers (their sole argument).

@item NON_LVALUE_EXPR
这些节点指示它们有且仅有的一个操作数不是左值的。后端可以将其作为单操作数来对待。 
These nodes indicate that their one and only operand is not an lvalue.
A back end can treat these identically to the single operand.

@item NOP_EXPR
这些节点用于表示不需要任何代码生成的转换。例如，由char*到int*不需要任何代码生成；这样的转换被表示为一个NOP_EXPR。单操作数为要转换的表达式。从指针到引用的转换也被表示为NOP_EXPR。 
These nodes are used to represent conversions that do not require any
code-generation.  For example, conversion of a @code{char*} to an
@code{int*} does not require any code be generated; such a conversion is
represented by a @code{NOP_EXPR}.  The single operand is the expression
to be converted.  The conversion from a pointer to a reference is also
represented with a @code{NOP_EXPR}.

@item CONVERT_EXPR
这些节点类似于NOP_EXPR，不过用于可能会有代码生成的情况。例如，如果int*被转换为int，则可能会在一些平台上需要生成代码。这些节点从来不被用于C++特定的转换，例如在一个继承体系中不同的类的指针间的转换。这种情况下的任何调整，总是需要被显式的指出。类似的，用户定义的转换也不使用 CONVERT_EXPR表示；相反的，而是显式的调用函数。
These nodes are similar to @code{NOP_EXPR}s, but are used in those
situations where code may need to be generated.  For example, if an
@code{int*} is converted to an @code{int} code may need to be generated
on some platforms.  These nodes are never used for C++-specific
conversions, like conversions between pointers to different classes in
an inheritance hierarchy.  Any adjustments that need to be made in such
cases are always indicated explicitly.  Similarly, a user-defined
conversion is never represented by a @code{CONVERT_EXPR}; instead, the
function calls are made explicit.

@item FIXED_CONVERT_EXPR
These nodes are used to represent conversions that involve fixed-point
values.  For example, from a fixed-point value to another fixed-point value,
from an integer to a fixed-point value, from a fixed-point value to an
integer, from a floating-point value to a fixed-point value, or from
a fixed-point value to a floating-point value.

@item THROW_EXPR
这些节点表示throw表达式。单操作为一个表达式，其代码将被执行用于抛出异常。但是，在表达式中有一个隐式的动作没有表示出来；即调用 __throw。这个函数没有参数。如果使用了setjmp/longjmp异常，则相应的调用函数__sjthrow。通常GCC后端使用函数 emit_throw来生成该代码；你可以检查该函数看看都需要做什么。
These nodes represent @code{throw} expressions.  The single operand is
an expression for the code that should be executed to throw the
exception.  However, there is one implicit action not represented in
that expression; namely the call to @code{__throw}.  This function takes
no arguments.  If @code{setjmp}/@code{longjmp} exceptions are used, the
function @code{__sjthrow} is called instead.  The normal GCC back end
uses the function @code{emit_throw} to generate this code; you can
examine this function to see what needs to be done.

@item LSHIFT_EXPR
@itemx RSHIFT_EXPR
这些节点分别表示左移和右移。第一个操作数为要移动的值；其将总是为整数类型。第二个操作数为表示移动位数的表达式。右移将作为算术移动，即，当表达式具有无符号类型则高位填充0，当表达式具有有符号类型则高位填充符号位。注意如果第二个操作数大于或等于第一个操作数的类型大小，则结果无定义。
These nodes represent left and right shifts, respectively.  The first
operand is the value to shift; it will always be of integral type.  The
second operand is an expression for the number of bits by which to
shift.  Right shift should be treated as arithmetic, i.e., the
high-order bits should be zero-filled when the expression has unsigned
type and filled with the sign bit when the expression has signed type.
Note that the result is undefined if the second operand is larger
than or equal to the first operand's type size.


@item BIT_IOR_EXPR
@itemx BIT_XOR_EXPR
@itemx BIT_AND_EXPR
这些节点分别表示位运算符“或”，“异或”，和“与”。所有操作数将总是为整数类型。 
These nodes represent bitwise inclusive or, bitwise exclusive or, and
bitwise and, respectively.  Both operands will always have integral
type.

@item TRUTH_ANDIF_EXPR
@itemx TRUTH_ORIF_EXPR
这些节点分别表示逻辑“与”和“或”。这些操作符不是严格的；即第二个操作数只在通过求值第一个操作数无法确定表达式的值的时候，才被计算求值。操作数和结果的类型总是为BOOLEAN_TYPE或INTEGER_TYPE。 
These nodes represent logical ``and'' and logical ``or'', respectively.
These operators are not strict; i.e., the second operand is evaluated
only if the value of the expression is not determined by evaluation of
the first operand.  The type of the operands and that of the result are
always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}.

@item TRUTH_AND_EXPR
@itemx TRUTH_OR_EXPR
@itemx TRUTH_XOR_EXPR
这些节点表示逻辑与，或和异或。它们为严格的方式；所有参数都总是被计算求值。这在C或C++中没有对应的运算符，但是前端如果可以断定严格的方式没关系，则有时将会生成这些表达式。操作数和结果的类型总是为BOOLEAN_TYPE或INTEGER_TYPE。 
These nodes represent logical and, logical or, and logical exclusive or.
They are strict; both arguments are always evaluated.  There are no
corresponding operators in C or C++, but the front end will sometimes
generate these expressions anyhow, if it can tell that strictness does
not matter.  The type of the operands and that of the result are
always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}.

@itemx POINTER_PLUS_EXPR
该节点表示指针算术运算。第一个操作数总是为一个指针/引用类型。第二个操作数总是为一个与sizetype兼容的无符号整数类型。这是唯一的可以操作指针类型的二元算术运算。 
This node represents pointer arithmetic.  The first operand is always
a pointer/reference type.  The second operand is always an unsigned
integer type compatible with sizetype.  This is the only binary
arithmetic operand that can operate on pointer types.

@itemx PLUS_EXPR
@itemx MINUS_EXPR
@itemx MULT_EXPR
这些节点表示不同的二元算术运算。分别为加法，减法和乘法。它们的操作数可以为整数或者浮点类型，但不会为一个是浮点类型的，而另一个是整数类型。

这些运算在有符号算术溢出时的行为，由变量flag_wrapv和flag_trapv来控制。
These nodes represent various binary arithmetic operations.
Respectively, these operations are addition, subtraction (of the second
operand from the first) and multiplication.  Their operands may have
either integral or floating type, but there will never be case in which
one operand is of floating type and the other is of integral type.

The behavior of these operations on signed arithmetic overflow is
controlled by the @code{flag_wrapv} and @code{flag_trapv} variables.

@item RDIV_EXPR
该节点表示一个浮点除法运算。 
This node represents a floating point division operation.

@item TRUNC_DIV_EXPR
@itemx FLOOR_DIV_EXPR
@itemx CEIL_DIV_EXPR
@itemx ROUND_DIV_EXPR
这些节点表示返回整数结果的整数除法运算。TRUNC_DIV_EXPR向0方向舍入，FLOOR_DIV_EXPR向负无穷大舍入，CEIL_DIV_EXPR向正无穷大舍入，ROUND_DIV_EXPR向最近的整数舍入。C和C++中的整数除法为截断方式，即 TRUNC_DIV_EXPR。

这些运算在有符号算术溢出时的行为，由变量flag_wrapv和flag_trapv来控制。
These nodes represent integer division operations that return an integer
result.  @code{TRUNC_DIV_EXPR} rounds towards zero, @code{FLOOR_DIV_EXPR}
rounds towards negative infinity, @code{CEIL_DIV_EXPR} rounds towards
positive infinity and @code{ROUND_DIV_EXPR} rounds to the closest integer.
Integer division in C and C++ is truncating, i.e.@: @code{TRUNC_DIV_EXPR}.

The behavior of these operations on signed arithmetic overflow, when
dividing the minimum signed integer by minus one, is controlled by the
@code{flag_wrapv} and @code{flag_trapv} variables.

@item TRUNC_MOD_EXPR
@itemx FLOOR_MOD_EXPR
@itemx CEIL_MOD_EXPR
@itemx ROUND_MOD_EXPR

这些节点表示整数类型的求余或求模运算。两个操作数@code{a}和@code{b}的整型的模被定义为@code{a - (a/b)*b}，其中使用相应的除法操作符进行除法运算。因此，对于@code{TRUNC_MOD_EXPR}的定义，是假设使用了向零方向舍去的除法，即@code{TRUNC_DIV_EXPR}。C和C++中的整型求余，使用了舍去除法，即@code{TRUNC_MOD_EXPR}。


@item EXACT_DIV_EXPR
@code{EXACT_DIV_EXPR}用来表示整数除法，即分子已知为分母的确切的倍数。这使得后端可以从@code{TRUNC_DIV_EXPR},
@code{CEIL_DIV_EXPR}和@code{FLOOR_DIV_EXPR}中，为当前的目标机选择更快的运算。

@item ARRAY_REF
这些节点表示对数组的访问。第一个操作数为数组；第二个为索引。要计算被访问内存的地址，你必须要根据比例，用数组元素的类型大小来乘以索引。这些表达式的类型必须为数组元素的类型。第三和第四个操作数在gimplification之后使用，来表示下界和元素大小；但是不要直接使用它们，相应的，调用@code{array_ref_low_bound}和@code{array_ref_element_size}。

@item ARRAY_RANGE_REF
这些节点表示对数组的一个范围（或者说切片）的访问。操作数与@code{ARRAY_REF}相同，并具有相同的含义。这些表达式的类型必须是一个数组，其元素的类型与第一个操作数的类型相同。数组类型的范围决定了这些表达式访问的数据数目。

@item TARGET_MEM_REF
这些节点表示内存访问，并且其地址直接映射到目标体系结构的寻址模式。第一个参数为@code{TMR_SYMBOL}，并且必须为具有固定地址的对象的@code{VAR_DECL}。第二个参数为@code{TMR_BASE}，第三个为@code{TMR_INDEX}。第四个参数为@code{TMR_STEP}，并且必须为@code{INTEGER_CST}。第五个参数为@code{TMR_OFFSET}，并且必须为@code{INTEGER_CST}。如果相应的部分没有在地址中出现，则参数可以为NULL。@code{TARGET_MEM_REF}的地址通过下列方法来确定。

@smallexample
&TMR_SYMBOL + TMR_BASE + TMR_INDEX * TMR_STEP + TMR_OFFSET
@end smallexample

第六个参数为对原始内存访问的引用，其被保留下来，用于RTL别名分析。第七个参数为一个标记，表示tree级的别名分析的结果。

@item LT_EXPR
@itemx LE_EXPR
@itemx GT_EXPR
@itemx GE_EXPR
@itemx EQ_EXPR
@itemx NE_EXPR
这些节点表示小于，小于或等于，大于，大于或等于，等于，和不等于的比较运算符。第一个和第二个操作数或者都为整数类型，或者都为浮点类型。这些表达式的结果类型将总是为整数或布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

对于浮点类型比较运算，如果我们使用了IEEE NaN，并且任意一个操作数为NaN，则@code{NE_EXPR}总是返回真，而其余的运算符总是返回假。在一些目标机上，对于IEEE NaN，除了等于和不等于以外的其它比较运算，可能会生成一个浮点异常。

@item ORDERED_EXPR
@itemx UNORDERED_EXPR
这些节点表示non-trapping的有序和无序的比较运算。这些运算接受两个浮点操作数，并确定它们之间是有序的，还是无序的。如果有一个操作数为IEEE NaN，则它们的比较被定以为无序的，否则为有序的。这些表达式的结果类型将总是为整数或者布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

@item UNLT_EXPR
@itemx UNLE_EXPR
@itemx UNGT_EXPR
@itemx UNGE_EXPR
@itemx UNEQ_EXPR
@itemx LTGT_EXPR
These nodes represent the unordered comparison operators.
These operations take two floating point operands and determine whether
the operands are unordered or are less than, less than or equal to,
greater than, greater than or equal to, or equal respectively.  For
example, @code{UNLT_EXPR} returns true if either operand is an IEEE
NaN or the first operand is less than the second.  With the possible
exception of @code{LTGT_EXPR}, all of these operations are guaranteed
not to generate a floating point exception.  The result
type of these expressions will always be of integral or boolean type.
These operations return the result type's zero value for false,
and the result type's one value for true.

@item MODIFY_EXPR
These nodes represent assignment.  The left-hand side is the first
operand; the right-hand side is the second operand.  The left-hand side
will be a @code{VAR_DECL}, @code{INDIRECT_REF}, @code{COMPONENT_REF}, or
other lvalue.

These nodes are used to represent not only assignment with @samp{=} but
also compound assignments (like @samp{+=}), by reduction to @samp{=}
assignment.  In other words, the representation for @samp{i += 3} looks
just like that for @samp{i = i + 3}.

@item INIT_EXPR
These nodes are just like @code{MODIFY_EXPR}, but are used only when a
variable is initialized, rather than assigned to subsequently.  This
means that we can assume that the target of the initialization is not
used in computing its own value; any reference to the lhs in computing
the rhs is undefined.

@item COMPONENT_REF
These nodes represent non-static data member accesses.  The first
operand is the object (rather than a pointer to it); the second operand
is the @code{FIELD_DECL} for the data member.  The third operand represents
the byte offset of the field, but should not be used directly; call
@code{component_ref_field_offset} instead.

@item COMPOUND_EXPR
These nodes represent comma-expressions.  The first operand is an
expression whose value is computed and thrown away prior to the
evaluation of the second operand.  The value of the entire expression is
the value of the second operand.

@item COND_EXPR
These nodes represent @code{?:} expressions.  The first operand
is of boolean or integral type.  If it evaluates to a nonzero value,
the second operand should be evaluated, and returned as the value of the
expression.  Otherwise, the third operand is evaluated, and returned as
the value of the expression.

The second operand must have the same type as the entire expression,
unless it unconditionally throws an exception or calls a noreturn
function, in which case it should have void type.  The same constraints
apply to the third operand.  This allows array bounds checks to be
represented conveniently as @code{(i >= 0 && i < 10) ? i : abort()}.

As a GNU extension, the C language front-ends allow the second
operand of the @code{?:} operator may be omitted in the source.
For example, @code{x ? : 3} is equivalent to @code{x ? x : 3},
assuming that @code{x} is an expression without side-effects.
In the tree representation, however, the second operand is always
present, possibly protected by @code{SAVE_EXPR} if the first
argument does cause side-effects.

@item CALL_EXPR
These nodes are used to represent calls to functions, including
non-static member functions.  @code{CALL_EXPR}s are implemented as
expression nodes with a variable number of operands.  Rather than using
@code{TREE_OPERAND} to extract them, it is preferable to use the
specialized accessor macros and functions that operate specifically on
@code{CALL_EXPR} nodes.

@code{CALL_EXPR_FN} returns a pointer to the
function to call; it is always an expression whose type is a
@code{POINTER_TYPE}.

The number of arguments to the call is returned by @code{call_expr_nargs},
while the arguments themselves can be accessed with the @code{CALL_EXPR_ARG} 
macro.  The arguments are zero-indexed and numbered left-to-right.  
You can iterate over the arguments using @code{FOR_EACH_CALL_EXPR_ARG}, as in:

@smallexample
tree call, arg;
call_expr_arg_iterator iter;
FOR_EACH_CALL_EXPR_ARG (arg, iter, call)
  /* arg is bound to successive arguments of call.  */
  @dots{};
@end smallexample

For non-static
member functions, there will be an operand corresponding to the
@code{this} pointer.  There will always be expressions corresponding to
all of the arguments, even if the function is declared with default
arguments and some arguments are not explicitly provided at the call
sites.

@code{CALL_EXPR}s also have a @code{CALL_EXPR_STATIC_CHAIN} operand that
is used to implement nested functions.  This operand is otherwise null.

@item STMT_EXPR
These nodes are used to represent GCC's statement-expression extension.
The statement-expression extension allows code like this:
@smallexample
int f() @{ return (@{ int j; j = 3; j + 7; @}); @}
@end smallexample
In other words, an sequence of statements may occur where a single
expression would normally appear.  The @code{STMT_EXPR} node represents
such an expression.  The @code{STMT_EXPR_STMT} gives the statement
contained in the expression.  The value of the expression is the value
of the last sub-statement in the body.  More precisely, the value is the
value computed by the last statement nested inside @code{BIND_EXPR},
@code{TRY_FINALLY_EXPR}, or @code{TRY_CATCH_EXPR}.  For example, in:
@smallexample
(@{ 3; @})
@end smallexample
the value is @code{3} while in:
@smallexample
(@{ if (x) @{ 3; @} @})
@end smallexample
there is no value.  If the @code{STMT_EXPR} does not yield a value,
it's type will be @code{void}.

@item BIND_EXPR
These nodes represent local blocks.  The first operand is a list of
variables, connected via their @code{TREE_CHAIN} field.  These will
never require cleanups.  The scope of these variables is just the body
of the @code{BIND_EXPR}.  The body of the @code{BIND_EXPR} is the
second operand.

@item LOOP_EXPR
These nodes represent ``infinite'' loops.  The @code{LOOP_EXPR_BODY}
represents the body of the loop.  It should be executed forever, unless
an @code{EXIT_EXPR} is encountered.

@item EXIT_EXPR
These nodes represent conditional exits from the nearest enclosing
@code{LOOP_EXPR}.  The single operand is the condition; if it is
nonzero, then the loop should be exited.  An @code{EXIT_EXPR} will only
appear within a @code{LOOP_EXPR}.

@item CLEANUP_POINT_EXPR
These nodes represent full-expressions.  The single operand is an
expression to evaluate.  Any destructor calls engendered by the creation
of temporaries during the evaluation of that expression should be
performed immediately after the expression is evaluated.

@item CONSTRUCTOR
These nodes represent the brace-enclosed initializers for a structure or
array.  The first operand is reserved for use by the back end.  The
second operand is a @code{TREE_LIST}.  If the @code{TREE_TYPE} of the
@code{CONSTRUCTOR} is a @code{RECORD_TYPE} or @code{UNION_TYPE}, then
the @code{TREE_PURPOSE} of each node in the @code{TREE_LIST} will be a
@code{FIELD_DECL} and the @code{TREE_VALUE} of each node will be the
expression used to initialize that field.

If the @code{TREE_TYPE} of the @code{CONSTRUCTOR} is an
@code{ARRAY_TYPE}, then the @code{TREE_PURPOSE} of each element in the
@code{TREE_LIST} will be an @code{INTEGER_CST} or a @code{RANGE_EXPR} of
two @code{INTEGER_CST}s.  A single @code{INTEGER_CST} indicates which
element of the array (indexed from zero) is being assigned to.  A
@code{RANGE_EXPR} indicates an inclusive range of elements to
initialize.  In both cases the @code{TREE_VALUE} is the corresponding
initializer.  It is re-evaluated for each element of a
@code{RANGE_EXPR}.  If the @code{TREE_PURPOSE} is @code{NULL_TREE}, then
the initializer is for the next available array element.

In the front end, you should not depend on the fields appearing in any
particular order.  However, in the middle end, fields must appear in
declaration order.  You should not assume that all fields will be
represented.  Unrepresented fields will be set to zero.

@item COMPOUND_LITERAL_EXPR
@findex COMPOUND_LITERAL_EXPR_DECL_STMT
@findex COMPOUND_LITERAL_EXPR_DECL
这些节点表示复合文字。
@code{COMPOUND_LITERAL_EXPR_DECL_STMT}为一个@code{DECL_STMT}，
包含了一个由复合文字表示的未命名对象的匿名@code{VAR_DECL}；
@code{VAR_DECL}的@code{DECL_INITIAL}是一个@code{CONSTRUCTOR}用来表示在
复合文字中大括号包围的初始值列表。
匿名的@code{VAR_DECL}还可以通过@code{COMPOUND_LITERAL_EXPR_DECL}宏直接访问。 

@item SAVE_EXPR
@code{SAVE_EXPR}表示一个被多次使用的表达式（可能会有副作用）。
副作用应该只在表达式第一次被求值时发生。后续的使用应该只是重用计算所得的值。
@code{SAVE_EXPR}的第一个操作数是要求值的表达式。
副作用应该在深度优先前续遍历表达式树，第一次遇到@code{SAVE_EXPR}时被执行。 

@item TARGET_EXPR
@code{TARGET_EXPR}表示一个临时对象。第一个操作数是临时变量@code{VAR_DECL}。
第二个操作数是临时变量的初始值。初始值将被求值，并且如果不是void型的，
则（按位）复制到临时变量中。如果初始值是void的，意味着将会自己执行初始化。 

很多时候，@code{TARGET_EXPR}会出现在赋值的右边，
或者作为逗号表达式的第二个操作数。 这种情况下，
我们说@code{TARGET_EXPR}是“normal”的；否则，我们说它是“orphaned”。
对于一个正常的@code{TARGET_EXPR}，临时变量应被视为赋值的左端的一个别名，
而不是一个新的临时变量。

@code{TARGET_EXPR}的第三个操作数，如果存在的话，
是临时变量的清理表达式（即析构调用）。如果该表达式是孤儿的，
则该表达式必须当包含它的语句是完整的时候被执行。
这些清理必须总是按照相反的顺序执行。
注意如果临时变量是在条件操作符的分支上创建的（即，
@code{COND_EXPR}的第二个或第三个操作数），
则清理必须只有在该分支实际被执行时才运行。

关于运行这些清理的更多信息，参见@code{STMT_IS_FULL_EXPR_P}。

@item AGGR_INIT_EXPR
@code{AGGR_INIT_EXPR}表示作为函数调用的返回值或者作为构造函数的结果的初始化。
@code{AGGR_INIT_EXPR}只作为充分表达式出现，
或作为@code{TARGET_EXPR}的第二个操作数。
@code{AGGR_INIT_EXPR}具有跟@code{CALL_EXPR}类似的表示。
可以使用@code{AGGR_INIT_EXPR_FN}和@code{AGGR_INIT_EXPR_ARG}宏来访问调用的函数，
以及传递的参数。

如果@code{AGGR_INIT_VIA_CTOR_P}持有@code{AGGR_INIT_EXPR}，
则初始化是通过一个构造函数进行的。@code{AGGR_INIT_EXPR_SLOT}操作数的地址，
其总是一个@code{VAR_DECL}，将被接受，并且该值替代参数列表中的第一个参数。

在这两种情况下，表达式都是void的。

@item VA_ARG_EXPR
该节点用来实现对C/C++可变参数列表机制的支持。
它表示了像@code{va_arg (ap, type)}这样的表达式。
它的@code{TREE_TYPE}用来产生@code{type}的树表示，
唯一的参数用来产生对@code{ap}的表示。 

@item CHANGE_DYNAMIC_TYPE_EXPR
指出了C++ placement new的特定别名需求。有两个操作数：类型和位置。
它表示该位置的动态类型被转换为指定的类型。
别名分析代码在做基于类型的别名分析时，需要考虑到这一点。 

@item OMP_PARALLEL

表示@code{#pragma omp parallel [clause1 @dots{} clauseN]}。具有四个操作数：

操作数@code{OMP_PARALLEL_BODY}在GENERIC和High GIMPLE形式中是有效的。
它包含了被所有线程执行的代码体。在GIMPLE下降过程中，
这个操作数变为@code{NULL}并且代码体被线性的输出在@code{OMP_PARALLEL}之后。

操作数@code{OMP_PARALLEL_CLAUSES}为与指令相关的子句列表。

操作数@code{OMP_PARALLEL_FN}由@code{pass_lower_omp}创建，
它包含了将要包含并行区域体的函数@code{FUNCTION_DECL}。

操作数@code{OMP_PARALLEL_DATA_ARG}也由@code{pass_lower_omp}创建。
如果有共享变量用于子线程间通讯，则该操作数将包含@code{VAR_DECL}，
其包含了所有共享的值和变量。

@item OMP_FOR

表示#pragma omp for [clause1 ... clauseN]. 其具有5个操作数：

操作数OMP_FOR_BODY包含了循环体。

操作数OMP_FOR_CLAUSES为与指令相关的子句列表。

操作数OMP_FOR_INIT为VAR = N1形式的循环初始化代码。

操作数OMP_FOR_COND为VAR {<,>,<=,>=} N2形式的循环条件表达式。

操作数OMP_FOR_INCR为VAR {+=,-=} INCR形式的循环索引增量。

操作数OMP_FOR_PRE_BODY包含了来自操作数OMP_FOR_INIT, OMP_FOR_COND和OMP_FOR_INC的副作用代码。这些副作用为OMP_FOR块的一部分，但是必须在开始循环体之前被计算求值。

循环索引变量VAR必须为单个整数变量，其隐式的归每个线程私有。边界N1和N2，以及增量表达式INCR需要为循环不变量整数表达式，其不需要同步就可以被计算求值。按照标准，计算求值的顺序，频率和副作用都没有被指定。

@item OMP_SECTIONS

表示@code{#pragma omp sections [clause1 @dots{} clauseN]}。

操作数@code{OMP_SECTIONS_BODY}包含了section主体，
其依次包含了一个@code{OMP_SECTION}节点集合，
每个并发的section通过@code{#pragma omp section}来划分。

操作数@code{OMP_SECTIONS_CLAUSES}为与指令相关的子句列表。

@item OMP_SECTION

@code{OMP_SECTIONS}的Section定界符。 

@item OMP_SINGLE

表示@code{#pragma omp single}

操作数@code{OMP_SINGLE_BODY}包含了被单个线程执行的代码体。

操作数@code{OMP_SINGLE_CLAUSES}为与指令相关的子句列表。

@item OMP_MASTER

表示@code{#pragma omp master}。

操作数@code{OMP_MASTER_BODY}包含了被主控线程执行的代码体。

@item OMP_ORDERED

表示@code{#pragma omp ordered}。

操作数@code{OMP_ORDERED_BODY}包含了按照由循环索引变量所指示的顺序序列来执行的代码体。

@item OMP_CRITICAL

表示@code{#pragma omp critical [name]}。

操作数@code{OMP_CRITICAL_BODY}为临界section。

操作数@code{OMP_CRITICAL_NAME}为可选的用来标记临界section的标识符。

@item OMP_RETURN

这个并不表示任何OpenMP指令，它为一个人为标记用来指示OpenMP主体的结束。
其被用于流图（@code{tree-cfg.c}）和OpenMP区域构建代码（@code{omp-low.c}）。

@item OMP_CONTINUE

类似的，该指令不表示OpenMP指令，它被@code{OMP_FOR}和@code{OMP_SECTIONS}用于
标记代码需要循环到下一个迭代（例如@code{OMP_FOR}）或者下一个section
（例如@code{OMP_SECTIONS}）的地方。有一些情况，
@code{OMP_CONTINUE}被放在紧挨着@code{OMP_RETURN}之前。
但是，如果在循环体之后需要出现cleanups，
则它将被生成在@code{OMP_CONTINUE}和@code{OMP_RETURN}之间。 

@item OMP_ATOMIC

表示@code{#pragma omp atomic}。

操作数0是要被执行的原子操作的地址。

操作数1是要计算求值的表达式。gimplifier会尝试三种可供选择的代码生成策略。
只要可能，则会使用内建的原子更新。如果失败，
则会尝试进行比较-交换（compare-and-swap）循环。如果还是失败，
则会使用表达式附近的一个常规临界section。

@item OMP_CLAUSE

表示与@code{OMP_}指令相关的子句。子句使用@file{tree.h}中定义的子代码单独表示。
子句代码可以为：OMP_CLAUSE_PRIVATE, OMP_CLAUSE_SHARED, OMP_CLAUSE_FIRSTPRIVATE, OMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_COPYIN, OMP_CLAUSE_COPYPRIVATE, OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS, OMP_CLAUSE_SCHEDULE, OMP_CLAUSE_NOWAIT, OMP_CLAUSE_ORDERED, OMP_CLAUSE_DEFAULT, 和OMP_CLAUSE_REDUCTION。每个代码表示了相应的OpenMP子句。

与同一指令相关的子句通过@code{OMP_CLAUSE_CHAIN}链接在一起。
那些接受一个变量列表的子句被限制为只有一个，使用@code{OMP_CLAUSE_VAR}来访问。
因此，同一子句@code{C}下的多个变量需要被多个链接在一起的@code{C}子句表示。
这样可以有助于在编译过程中增加新的子句。

@item VEC_LSHIFT_EXPR
@item VEC_RSHIFT_EXPR
这些节点相应的表示整个向量的左移和右移。第一个操作数为要移动的向量；
其将总是为向量类型。第二个操作数是一个表达式，表示要移动的位数。
注意如果第二个操作数大于或等于第一个操作数的类型大小，则结果未定义。

@item VEC_WIDEN_MULT_HI_EXPR
@item VEC_WIDEN_MULT_LO_EXPR
这些节点分别表示两个输入向量的高部和低部的加宽向量乘法。
它们的操作数为包含同一整数类型的同一数目（@code{N}）元素的向量。
结果为一个包含整数类型的元素大小为两倍宽数目为一半的向量。
对于@code{VEC_WIDEN_MULT_HI_EXPR}，
两个向量的高@code{N/2}个元素相乘得到@code{N/2}个积的向量。
对于@code{VEC_WIDEN_MULT_LO_EXPR}，
两个向量的低@code{N/2}个元素相乘得到@code{N/2}个积的向量。 

@item VEC_UNPACK_HI_EXPR
@item VEC_UNPACK_LO_EXPR
这些节点分别表示拆分输入向量的高部和低部。
单操作数为一个包含同一整数或浮点类型的@code{N}个元素的向量。
结果为包含整数或者浮点类型的元素大小为两倍宽数目为一半的向量。
对于@code{VEC_UNPACK_HI_EXPR}，向量的高@code{N/2}个元素被提取并扩展（提升）。
对于@code{VEC_UNPACK_LO_EXPR}，向量的低@code{N/2}个元素被提取并扩展（提升）。 

@item VEC_UNPACK_FLOAT_HI_EXPR
@item VEC_UNPACK_FLOAT_LO_EXPR
这些节点分别表示拆分输入向量的高部和低部，并将值由定点转换为浮点。
单操作数为包含同一整数类型的@code{N}个元素的向量。
结果为包含浮点类型的元素大小为两倍宽数目为一半的向量。
对于@code{VEC_UNPACK_HI_EXPR}，向量的高@code{N/2}个元素被提取，转换并扩展。
对于@code{VEC_UNPACK_LO_EXPR}，向量的低@code{N/2}个元素被提取，转换并扩展。 

@item VEC_PACK_TRUNC_EXPR
该节点表示将两个输入向量的截断元素打包成输出向量。
输入操作数是包含同一整数或者浮点类型的相同数目元素的向量。
结果为包含整数或者浮点类型的元素大小为一半数目为两倍的向量。
两个向量的元素合并成输出向量。 

@item VEC_PACK_SAT_EXPR
该节点表示使用饱和方式（saturation）将两个输入向量的元素打包成输出向量。
输入操作数是包含了同一整数类型的相同数目元素的向量。
结果为一个包含整数类型的元素大小为一半数目为两倍的向量。
两个向量的元素合并成输出向量。 

@item VEC_PACK_FIX_TRUNC_EXPR
该节点表示将将两个输入向量的元素打包成输出向量，并将值由浮点转换为定点。
输入操作数是包含浮点类型的相同数目元素的向量。
结果为包含整数类型元素大小一半数目为两倍的向量。两个向量的元素合并成输出向量。 

@item VEC_EXTRACT_EVEN_EXPR
@item VEC_EXTRACT_ODD_EXPR
这些节点分别表示提取两个输入向量的偶数/奇数个元素。
它们的操作数和结果为包含同一类型的相同数目元素的向量。 

@item VEC_INTERLEAVE_HIGH_EXPR
@item VEC_INTERLEAVE_LOW_EXPR
这些节点分别表示交错合并两个输入向量的高/低元素。
操作数和结果为包含同一类型的相同数目（@code{N}）元素的向量。
对于@code{VEC_INTERLEAVE_HIGH_EXPR}，
第一个输入向量的高@code{N/2}个元素被第二个输入向量的高@code{N/2}个元素替换。
对于@code{VEC_INTERLEAVE_LOW_EXPR}，
第一个输入向量的低@code{N/2}个元素被第二个输入向量的低@code{N/2}个元素替换。 
@end table
