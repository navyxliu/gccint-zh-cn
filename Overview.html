<html lang="zh">
<head>
<title>Overview - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Machine-Desc.html#Machine-Desc" title="Machine Desc">
<link rel="next" href="Patterns.html#Patterns" title="Patterns">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Overview"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Patterns.html#Patterns">Patterns</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Machine-Desc.html#Machine-Desc">Machine Desc</a>
<hr>
</div>

<h3 class="section">16.1 概述机器描述是如何被使用的</h3>

<!-- There are three main conversions that happen in the compiler: -->
<p>编译器中有三个主要的转换：

     <ol type=1 start=1>

     <li><!-- The front end reads the source code and builds a parse tree. -->
前端读取源代码并建立解析树。

     <li><!-- The parse tree is used to generate an RTL insn list based on named -->
<!-- instruction patterns. -->
基于命名的指令模式，解析树被用来生成RTL insn列表。

     <li><!-- The insn list is matched against the RTL templates to produce assembler -->
<!-- code. -->
insn列表被用来匹配RTL模板，产生汇编代码。

      </ol>

<!-- For the generate pass, only the names of the insns matter, from either a -->
<!-- named @code{define_insn} or a @code{define_expand}.  The compiler will -->
<!-- choose the pattern with the right name and apply the operands according -->
<!-- to the documentation later in this chapter, without regard for the RTL -->
<!-- template or operand constraints.  Note that the names the compiler looks -->
<!-- for are hard-coded in the compiler-it will ignore unnamed patterns and -->
<!-- patterns with names it doesn't know about, but if you don't provide a -->
<!-- named pattern it needs, it will abort. -->
 <p>生成过程，只与insn的名字有关系，包括命名的 <code>define_insn</code> 或者 <code>define_expand</code>。编译器会选择恰当名字的模式，并且根据这章后面的文档来使用 操作数，而不需要关心RTL模板或者操作数constraint。注意，编译器所寻找的名字是被硬编码 进编译器中的——它将忽略未命名的模式和名字无法识别的模式，但是，如果你没有提供所 需要的命名模式，它将异常中断（abort）。

<!-- If a @code{define_insn} is used, the template given is inserted into the -->
<!-- insn list.  If a @code{define_expand} is used, one of three things -->
<!-- happens, based on the condition logic.  The condition logic may manually -->
<!-- create new insns for the insn list, say via @code{emit_insn()}, and -->
<!-- invoke @code{DONE}.  For certain named patterns, it may invoke @code{FAIL} to tell the -->
<!-- compiler to use an alternate way of performing that task.  If it invokes -->
<!-- neither @code{DONE} nor @code{FAIL}, the template given in the pattern -->
<!-- is inserted, as if the @code{define_expand} were a @code{define_insn}. -->
 <p>如果使用了 <code>define_insn</code> ，所给出的模版将会被插入到insn列表中。如果使用了 <code>define_expand</code> ，将会发生三种情况之一，取决于条件逻辑。条件逻辑可以手动为 insn列表创建一个新的insn，并且调用 <code>DONE</code>。对于某些命名模式，它可以调用 <code>FAIL</code> 来告诉编译器使用一种备用方式完成任务。如果既没有调用DONE也没有调用 <code>FAIL</code>，在模式中所给出的模版将会被插入，就像 <code>define_insn</code>一样。

<!-- Once the insn list is generated, various optimization passes convert, -->
<!-- replace, and rearrange the insns in the insn list.  This is where the -->
<!-- @code{define_split} and @code{define_peephole} patterns get used, for -->
<!-- example. -->
 <p>一旦生成insn列表，各种优化过程便在insn列表中转换，替代和重排insn。例如， <code>define_split</code> 和 <code>define_peephole</code> 模式便在这里被使用。

<!-- Finally, the insn list's RTL is matched up with the RTL templates in the -->
<!-- @code{define_insn} patterns, and those patterns are used to emit the -->
<!-- final assembly code.  For this purpose, each named @code{define_insn} -->
<!-- acts like it's unnamed, since the names are ignored. -->
 <p>最后，insn列表的RTL被用来匹配 <code>define_insn</code> 模式中的RTL模版，并且那些模式 被用来生成最终的汇编代码。这时，由于不需要关心名字，所以每个命名的 <code>define_insn</code>跟没有命名没有区别。

<!-- @node Patterns -->
<!-- @section Everything about Instruction Patterns -->
<!-- @cindex patterns -->
<!-- @cindex instruction patterns -->
 </body></html>

