<html lang="zh">
<head>
<title>define_peephole - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Peephole-Definitions.html#Peephole-Definitions" title="Peephole Definitions">
<link rel="next" href="define_005fpeephole2.html#define_005fpeephole2" title="define_peephole2">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="define_peephole"></a>
<a name="define_005fpeephole"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="define_005fpeephole2.html#define_005fpeephole2">define_peephole2</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Peephole-Definitions.html#Peephole-Definitions">Peephole Definitions</a>
<hr>
</div>

<h4 class="subsection">16.18.1 RTL到文本的窥孔优化器</h4>

<p><a name="index-define_005fpeephole-3620"></a>
<!-- @need 1000 -->
<!-- A definition looks like this: -->
<!-- @smallexample -->
<!-- (define_peephole -->
<!-- [@var{insn-pattern-1} -->
<!-- @var{insn-pattern-2} -->
<!-- @dots{}] -->
<!-- "@var{condition}" -->
<!-- "@var{template}" -->
<!-- "@var{optional-insn-attributes}") -->
<!-- @end smallexample -->
定义的形式如下：

<pre class="smallexample">     (define_peephole
       [<var>insn-pattern-1</var>
        <var>insn-pattern-2</var>
        ...]
       "<var>condition</var>"
       "<var>template</var>"
       "<var>optional-insn-attributes</var>")
</pre>
 <!-- @noindent -->
<!-- The last string operand may be omitted if you are not using any -->
<!-- machine-specific information in this machine description.  If present, -->
<!-- it must obey the same rules as in a @code{define_insn}. -->
<!-- In this skeleton, @var{insn-pattern-1} and so on are patterns to match -->
<!-- consecutive insns.  The optimization applies to a sequence of insns when -->
<!-- @var{insn-pattern-1} matches the first one, @var{insn-pattern-2} matches -->
<!-- the next, and so on. -->
<p class="noindent">如果没有在该机器描述中使用任何机器特定的信息，
则可以省略掉最后的字符串操作数。
如果有，则其必须遵守在<code>define_insn</code>中相同的规则。

 <p>该结构中，<var>insn-pattern-1</var>等为匹配连续insn的指令模式。
当<var>insn-pattern-1</var>匹配第一个insn，
<var>insn-pattern-2</var>匹配下一个，等等依次类推的情况时，
则会将优化应用到该insn序列。

<!-- Each of the insns matched by a peephole must also match a -->
<!-- @code{define_insn}.  Peepholes are checked only at the last stage just -->
<!-- before code generation, and only optionally.  Therefore, any insn which -->
<!-- would match a peephole but no @code{define_insn} will cause a crash in code -->
<!-- generation in an unoptimized compilation, or at various optimization -->
<!-- stages. -->
<!-- The operands of the insns are matched with @code{match_operands}, -->
<!-- @code{match_operator}, and @code{match_dup}, as usual.  What is not -->
<!-- usual is that the operand numbers apply to all the insn patterns in the -->
<!-- definition.  So, you can check for identical operands in two insns by -->
<!-- using @code{match_operand} in one insn and @code{match_dup} in the -->
<!-- other. -->
 <p>每个由窥孔匹配的insn也必须匹配一个<code>define_insn</code>。
窥孔只在代码生成前的最后阶段被检查，并且只是可选的。
因此，在一个未优化的编译中，或者不同的优化阶段中，
任何匹配窥孔但是不匹配<code>define_insn</code>的将会在代码生成时造成崩溃。

 <p>和通常一样，insn的操作数使用<code>match_operands</code>,
<code>match_operator</code>和<code>match_dup</code>来匹配。
不同的是，操作数编号应用在定义的所有insn指令模式中。所以，
你可以通过一个insn中的<code>match_operand</code>和另一个insn中的<code>match_dup</code>，
来在两个insn中检查相同的操作数。

<!-- The operand constraints used in @code{match_operand} patterns do not have -->
<!-- any direct effect on the applicability of the peephole, but they will -->
<!-- be validated afterward, so make sure your constraints are general enough -->
<!-- to apply whenever the peephole matches.  If the peephole matches -->
<!-- but the constraints are not satisfied, the compiler will crash. -->
<!-- It is safe to omit constraints in all the operands of the peephole; or -->
<!-- you can write constraints which serve as a double-check on the criteria -->
<!-- previously tested. -->
<!-- Once a sequence of insns matches the patterns, the @var{condition} is -->
<!-- checked.  This is a C expression which makes the final decision whether to -->
<!-- perform the optimization (we do so if the expression is nonzero).  If -->
<!-- @var{condition} is omitted (in other words, the string is empty) then the -->
<!-- optimization is applied to every sequence of insns that matches the -->
<!-- patterns. -->
<!-- The defined peephole optimizations are applied after register allocation -->
<!-- is complete.  Therefore, the peephole definition can check which -->
<!-- operands have ended up in which kinds of registers, just by looking at -->
<!-- the operands. -->
 <p>用于<code>match_operand</code>指令模式的操作数constraint对窥孔的适用性没有任何直接的影响，
不过它们将会在后面被验证，所以要确信当窥孔匹配时，你的constraint要足够通用。
如果窥孔匹配，但constraint却不满足，则编译器将崩溃。

 <p>将窥孔中的所有操作数的constraint省略掉是安全的；
或者你可以编写constraint作为之前测试过的标准的二次检查。

 <p>一旦insn序列匹配指令模式，则<code>condition</code>将被检查。
这是一个C表达式，用于对是否执行优化来做最后的决定
（如果表达式非0时，我们这样做）。
如果<code>condition</code>被省略掉（换句话说，字符串为空）
则优化会被应用到每个匹配指令模式的insn序列。

 <p>定义的窥孔优化在寄存器分配完成之后应用。
因此，窥孔定义可以只是查看操作数，便能检查哪些操作数结束于哪种寄存器。

<!-- @findex prev_active_insn -->
<!-- The way to refer to the operands in @var{condition} is to write -->
<!-- @code{operands[@var{i}]} for operand number @var{i} (as matched by -->
<!-- @code{(match_operand @var{i} @dots{})}).  Use the variable @code{insn} -->
<!-- to refer to the last of the insns being matched; use -->
<!-- @code{prev_active_insn} to find the preceding insns. -->
 <p><a name="index-prev_005factive_005finsn-3621"></a>在条件中引用操作数的方式为对操作数编号<var>i</var>编写<code>operands[</code><var>i</var><code>]</code>
（匹配于<code>(match_operand </code><var>i</var><code> ...)</code>）。
使用变量<code>insn</code>来引用正在被匹配的insns的最后一个insn；
使用<code>prev_active_insn</code>来找到先前的insns。

<!-- @findex dead_or_set_p -->
<!-- When optimizing computations with intermediate results, you can use -->
<!-- @var{condition} to match only when the intermediate results are not used -->
<!-- elsewhere.  Use the C expression @code{dead_or_set_p (@var{insn}, -->
<!-- @var{op})}, where @var{insn} is the insn in which you expect the value -->
<!-- to be used for the last time (from the value of @code{insn}, together -->
<!-- with use of @code{prev_nonnote_insn}), and @var{op} is the intermediate -->
<!-- value (from @code{operands[@var{i}]}). -->
<!-- Applying the optimization means replacing the sequence of insns with one -->
<!-- new insn.  The @var{template} controls ultimate output of assembler code -->
<!-- for this combined insn.  It works exactly like the template of a -->
<!-- @code{define_insn}.  Operand numbers in this template are the same ones -->
<!-- used in matching the original sequence of insns. -->
<!-- The result of a defined peephole optimizer does not need to match any of -->
<!-- the insn patterns in the machine description; it does not even have an -->
<!-- opportunity to match them.  The peephole optimizer definition itself serves -->
<!-- as the insn pattern to control how the insn is output. -->
<!-- Defined peephole optimizers are run as assembler code is being output, -->
<!-- so the insns they produce are never combined or rearranged in any way. -->
<!-- Here is an example, taken from the 68000 machine description: -->
 <p><a name="index-dead_005for_005fset_005fp-3622"></a>当正在优化中间结果计算时，
你可以使用条件来匹配只有当中间结果不在其它地方被使用的情况。
使用C表达式<code>dead_or_set_p (</code><var>insn</var><code>, </code><var>op</var><code>)</code>，
其中<var>insn</var>为你所期望其值为最后一次被使用的insn，
以及<var>op</var>为中间值（来自<code>operands[</code><var>i</var><code>]</code>）。

 <p>应用优化，意味着将insn序列替换为新的insn。
<var>template</var>控制了针对该组合insn的最终汇编代码输出。
就像<code>define_insn</code>模板所做的一样。
该模板中的操作数编号与用于要匹配的原始insn序列中的相同。

 <p>被定义的窥孔优化器的结果不需要匹配机器描述中的任何insn模式；
它甚至没有机会来匹配它们。窥孔优化器定义本身是作为insn模式，
用来控制insn如何输出。

 <p>被定义的窥孔优化器被作为汇编代码运行输出，
所以它们产生的insns不再被组合或重排。

 <p>这里有一个例子，来自68000机器描述：

<pre class="smallexample">     (define_peephole
       [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
        (set (match_operand:DF 0 "register_operand" "=f")
             (match_operand:DF 1 "register_operand" "ad"))]
       "FP_REG_P (operands[0]) &amp;&amp; ! FP_REG_P (operands[1])"
     {
       rtx xoperands[2];
       xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);
     #ifdef MOTOROLA
       output_asm_insn ("move.l %1,(sp)", xoperands);
       output_asm_insn ("move.l %1,-(sp)", operands);
       return "fmove.d (sp)+,%0";
     #else
       output_asm_insn ("movel %1,sp@", xoperands);
       output_asm_insn ("movel %1,sp@-", operands);
       return "fmoved sp@+,%0";
     #endif
     })
</pre>
 <!-- @need 1000 -->
<!-- The effect of this optimization is to change -->
 <p>该优化的效果是将

<!-- @smallexample -->
<!-- @group -->
<!-- jbsr _foobar -->
<!-- addql #4,sp -->
<!-- movel d1,sp@@- -->
<!-- movel d0,sp@@- -->
<!-- fmoved sp@@+,fp0 -->
<!-- @end group -->
<!-- @end smallexample -->
<!-- @noindent -->
<!-- into -->
<!-- @smallexample -->
<!-- @group -->
<!-- jbsr _foobar -->
<!-- movel d1,sp@@ -->
<!-- movel d0,sp@@- -->
<!-- fmoved sp@@+,fp0 -->
<!-- @end group -->
<!-- @end smallexample -->
<pre class="smallexample">     jbsr _foobar
     addql #4,sp
     movel d1,sp@-
     movel d0,sp@-
     fmoved sp@+,fp0
</pre>
 <p class="noindent">转换为

<pre class="smallexample">     jbsr _foobar
     movel d1,sp@
     movel d0,sp@-
     fmoved sp@+,fp0
</pre>
 <!-- @ignore -->
<!-- @findex CC_REVERSED -->
<!-- If a peephole matches a sequence including one or more jump insns, you must -->
<!-- take account of the flags such as @code{CC_REVERSED} which specify that the -->
<!-- condition codes are represented in an unusual manner.  The compiler -->
<!-- automatically alters any ordinary conditional jumps which occur in such -->
<!-- situations, but the compiler cannot alter jumps which have been replaced by -->
<!-- peephole optimizations.  So it is up to you to alter the assembler code -->
<!-- that the peephole produces.  Supply C code to write the assembler output, -->
<!-- and in this C code check the condition code status flags and change the -->
<!-- assembler code as appropriate. -->
<!-- @end ignore -->
<!-- @var{insn-pattern-1} and so on look @emph{almost} like the second -->
<!-- operand of @code{define_insn}.  There is one important difference: the -->
<!-- second operand of @code{define_insn} consists of one or more RTX's -->
<!-- enclosed in square brackets.  Usually, there is only one: then the same -->
<!-- action can be written as an element of a @code{define_peephole}.  But -->
<!-- when there are multiple actions in a @code{define_insn}, they are -->
<!-- implicitly enclosed in a @code{parallel}.  Then you must explicitly -->
<!-- write the @code{parallel}, and the square brackets within it, in the -->
<!-- @code{define_peephole}.  Thus, if an insn pattern looks like this, -->
 <p><var>insn-pattern-1</var>等看起来与<code>define_insn</code>的第二个操作数非常相似。
不过有一个重要的不同：<code>define_insn</code>的第二个操作数包含了一个或多个RTX，
使用方括号包裹。通常，只有一个：
那么相同的动作则可以写成<code>define_peephole</code>的一个元素。
但是，当在<code>define_insn</code>中有多个动作时，它们被隐式的由<code>parallel</code>包裹。
则你必须在<code>define_peephole</code>中，显式的写出<code>parallel</code>，以及里面的方括号。
因此，如果一个insn的指令模式如下，

<pre class="smallexample">     (define_insn "divmodsi4"
       [(set (match_operand:SI 0 "general_operand" "=d")
             (div:SI (match_operand:SI 1 "general_operand" "0")
                     (match_operand:SI 2 "general_operand" "dmsK")))
        (set (match_operand:SI 3 "general_operand" "=d")
             (mod:SI (match_dup 1) (match_dup 2)))]
       "TARGET_68020"
       "divsl%.l %2,%3:%0")
</pre>
 <p class="noindent"><!-- then the way to mention this insn in a peephole is as follows: -->
则在窥孔中提及该insn的方法为：

<pre class="smallexample">     (define_peephole
       [...
        (parallel
         [(set (match_operand:SI 0 "general_operand" "=d")
               (div:SI (match_operand:SI 1 "general_operand" "0")
                       (match_operand:SI 2 "general_operand" "dmsK")))
          (set (match_operand:SI 3 "general_operand" "=d")
               (mod:SI (match_dup 1) (match_dup 2)))])
        ...]
       ...)
</pre>
 <!-- @node define_peephole2 -->
<!-- @subsection RTL to RTL Peephole Optimizers -->
 </body></html>

