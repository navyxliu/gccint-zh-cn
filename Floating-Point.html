<html lang="zh">
<head>
<title>Floating Point - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Debugging-Info.html#Debugging-Info" title="Debugging Info">
<link rel="next" href="Mode-Switching.html#Mode-Switching" title="Mode Switching">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Floating-Point"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Mode-Switching.html#Mode-Switching">Mode Switching</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Debugging-Info.html#Debugging-Info">Debugging Info</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.23 交叉编译和浮点</h3>

<p><a name="index-cross-compilation-and-floating-point-4697"></a><a name="index-floating-point-and-cross-compilation-4698"></a>
<!-- While all modern machines use twos-complement representation for integers, -->
<!-- there are a variety of representations for floating point numbers.  This -->
<!-- means that in a cross-compiler the representation of floating point numbers -->
<!-- in the compiled program may be different from that used in the machine -->
<!-- doing the compilation. -->
虽然所有现代机器都使用二进制补码来表示整数，但对于浮点数却有不同的表示。
这意味着在交叉编译器中，
被编译的程序中的浮点数的表示可能与执行编译的机器上的表示不相同。

<!-- Because different representation systems may offer different amounts of -->
<!-- range and precision, all floating point constants must be represented in -->
<!-- the target machine's format.  Therefore, the cross compiler cannot -->
<!-- safely use the host machine's floating point arithmetic; it must emulate -->
<!-- the target's arithmetic.  To ensure consistency, GCC always uses -->
<!-- emulation to work with floating point values, even when the host and -->
<!-- target floating point formats are identical. -->
 <p>因为不同的表示方式可能会提供不同的取值范围和精度，
所以所有的浮点常量必须被表示成target机器的格式。
因此，交叉编译器不能使用host机器的浮点算术；其必须模拟target的算术运算。
为了确保一致性，GCC总是使用模拟方式来处理浮点值，
即使host和target的浮点格式相同。

<!-- The following macros are provided by @file{real.h} for the compiler to -->
<!-- use.  All parts of the compiler which generate or optimize -->
<!-- floating-point calculations must use these macros.  They may evaluate -->
<!-- their operands more than once, so operands must not have side effects. -->
 <p>下列宏由<samp><span class="file">real.h</span></samp>提供给编译器使用。
编译器的生成或者优化浮点计算的所有部分必须使用这些宏。
它们可能会计算操作数多次，所以操作数一定不要有副作用。

<div class="defun">
&mdash; Macro: <b>REAL_VALUE_TYPE</b><var><a name="index-REAL_005fVALUE_005fTYPE-4699"></a></var><br>
<blockquote><!-- The C data type to be used to hold a floating point value in the target -->
     <!-- machine's format.  Typically this is a @code{struct} containing an -->
     <!-- array of @code{HOST_WIDE_INT}, but all code should treat it as an opaque -->
     <!-- quantity. -->
      <p>C数据类型，用于存放target机器格式的浮点值。
通常为一个包含<code>HOST_WIDE_INT</code>型数组的结构体，
但是所有的代码应该将其作为不透明的量。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>REAL_VALUES_EQUAL</b> (<var>REAL_VALUE_TYPE x, REAL_VALUE_TYPE y</var>)<var><a name="index-REAL_005fVALUES_005fEQUAL-4700"></a></var><br>
<blockquote><!-- Compares for equality the two values, @var{x} and @var{y}.  If the target -->
     <!-- floating point format supports negative zeroes and/or NaNs, -->
     <!-- @samp{REAL_VALUES_EQUAL (-0.0, 0.0)} is true, and -->
     <!-- @samp{REAL_VALUES_EQUAL (NaN, NaN)} is false. -->
      <p>比较两个值是否相等，<var>x</var>和<var>y</var>。如果target浮点格式支持负0和/或NaN，
则&lsquo;<samp><span class="samp">REAL_VALUES_EQUAL (-0.0, 0.0)</span></samp>&rsquo; 为真,
&lsquo;<samp><span class="samp">REAL_VALUES_EQUAL (NaN, NaN)</span></samp>&rsquo;为假。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>REAL_VALUES_LESS</b> (<var>REAL_VALUE_TYPE x, REAL_VALUE_TYPE y</var>)<var><a name="index-REAL_005fVALUES_005fLESS-4701"></a></var><br>
<blockquote><!-- Tests whether @var{x} is less than @var{y}. -->
      <p>测试<var>x</var>是否小于<var>y</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: HOST_WIDE_INT <b>REAL_VALUE_FIX</b> (<var>REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fFIX-4702"></a></var><br>
<blockquote><!-- Truncates @var{x} to a signed integer, rounding toward zero. -->
      <p>将<var>x</var>截取为有符号整数，向0舍入。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: unsigned HOST_WIDE_INT <b>REAL_VALUE_UNSIGNED_FIX</b> (<var>REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fUNSIGNED_005fFIX-4703"></a></var><br>
<blockquote><!-- Truncates @var{x} to an unsigned integer, rounding toward zero.  If -->
     <!-- @var{x} is negative, returns zero. -->
      <p>将<var>x</var>截取为无符号整数，向0舍入。如果<var>x</var>为负，则返回0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: REAL_VALUE_TYPE <b>REAL_VALUE_ATOF</b> (<var>const char *string, enum machine_mode mode</var>)<var><a name="index-REAL_005fVALUE_005fATOF-4704"></a></var><br>
<blockquote><!-- Converts @var{string} into a floating point number in the target machine's -->
     <!-- representation for mode @var{mode}.  This routine can handle both -->
     <!-- decimal and hexadecimal floating point constants, using the syntax -->
     <!-- defined by the C language for both. -->
      <p>将<var>string</var>转换为target机器模式<var>mode</var>所表示的浮点数。
该程序可以处理十进制和十六进制的浮点常量，使用C语言定义的语法。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>REAL_VALUE_NEGATIVE</b> (<var>REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fNEGATIVE-4705"></a></var><br>
<blockquote><!-- Returns 1 if @var{x} is negative (including negative zero), 0 otherwise. -->
      <p>如果<var>x</var>为负数（包括负零），返回1，否则0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>REAL_VALUE_ISINF</b> (<var>REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fISINF-4706"></a></var><br>
<blockquote><!-- Determines whether @var{x} represents infinity (positive or negative). -->
      <p>确定<var>x</var>是否表示无穷（正的或负的）。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>REAL_VALUE_ISNAN</b> (<var>REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fISNAN-4707"></a></var><br>
<blockquote><!-- Determines whether @var{x} represents a ``NaN'' (not-a-number). -->
      <p>确定<var>x</var>是否表示“NaN” (not-a-number)。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>REAL_ARITHMETIC</b> (<var>REAL_VALUE_TYPE output, enum tree_code code, REAL_VALUE_TYPE x, REAL_VALUE_TYPE y</var>)<var><a name="index-REAL_005fARITHMETIC-4708"></a></var><br>
<blockquote><!-- Calculates an arithmetic operation on the two floating point values -->
     <!-- @var{x} and @var{y}, storing the result in @var{output} (which must be a -->
     <!-- variable). -->
      <p>计算一个算术运算对浮点值<var>x</var>和<var>y</var>，将结果存到<var>output</var>（其必须为一个变量）中。

     <!-- The operation to be performed is specified by @var{code}.  Only the -->
     <!-- following codes are supported: @code{PLUS_EXPR}, @code{MINUS_EXPR}, -->
     <!-- @code{MULT_EXPR}, @code{RDIV_EXPR}, @code{MAX_EXPR}, @code{MIN_EXPR}. -->
      <p>要执行的运算由<var>code</var>指定。只有下列代码被支持：<code>PLUS_EXPR</code>, <code>MINUS_EXPR</code>, <code>MULT_EXPR</code>, <code>RDIV_EXPR</code>, <code>MAX_EXPR</code>, <code>MIN_EXPR</code>。

     <!-- If @code{REAL_ARITHMETIC} is asked to evaluate division by zero and the -->
     <!-- target's floating point format cannot represent infinity, it will call -->
     <!-- @code{abort}.  Callers should check for this situation first, using -->
     <!-- @code{MODE_HAS_INFINITIES}.  @xref{Storage Layout}. -->
      <p>如果<code>REAL_ARITHMETIC</code>被要求计算除0，并且target的浮点格式不能表示无穷，则会调用<code>abort</code>。调用者应该首先检查这种情况，使用<code>MODE_HAS_INFINITIES</code>。参见<a href="Storage-Layout.html#Storage-Layout">Storage Layout</a>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: REAL_VALUE_TYPE <b>REAL_VALUE_NEGATE</b> (<var>REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fNEGATE-4709"></a></var><br>
<blockquote><!-- Returns the negative of the floating point value @var{x}. -->
      <p>返回浮点值<var>x</var>的负数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: REAL_VALUE_TYPE <b>REAL_VALUE_ABS</b> (<var>REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fABS-4710"></a></var><br>
<blockquote><!-- Returns the absolute value of @var{x}. -->
      <p>返回<var>x</var>的绝对值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: REAL_VALUE_TYPE <b>REAL_VALUE_TRUNCATE</b> (<var>REAL_VALUE_TYPE mode, enum machine_mode x</var>)<var><a name="index-REAL_005fVALUE_005fTRUNCATE-4711"></a></var><br>
<blockquote><!-- Truncates the floating point value @var{x} to fit in @var{mode}.  The -->
     <!-- return value is still a full-size @code{REAL_VALUE_TYPE}, but it has an -->
     <!-- appropriate bit pattern to be output as a floating constant whose -->
     <!-- precision accords with mode @var{mode}. -->
      <p>将浮点值<var>x</var>截取为适合<var>mode</var>。返回值仍然是<code>REAL_VALUE_TYPE</code>，但是具有一个合适的位模式，其精度根据模式<var>mode</var>来输出浮点常量。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>REAL_VALUE_TO_INT</b> (<var>HOST_WIDE_INT low, HOST_WIDE_INT high, REAL_VALUE_TYPE x</var>)<var><a name="index-REAL_005fVALUE_005fTO_005fINT-4712"></a></var><br>
<blockquote><!-- Converts a floating point value @var{x} into a double-precision integer -->
     <!-- which is then stored into @var{low} and @var{high}.  If the value is not -->
     <!-- integral, it is truncated. -->
      <p>转换浮点值<var>x</var>为双精度整数，存储到<var>low</var>和<var>high</var>中。如果值不是整形的，则进行截取。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: void <b>REAL_VALUE_FROM_INT</b> (<var>REAL_VALUE_TYPE x, HOST_WIDE_INT low, HOST_WIDE_INT high, enum machine_mode mode</var>)<var><a name="index-REAL_005fVALUE_005fFROM_005fINT-4713"></a></var><br>
<blockquote><!-- Converts a double-precision integer found in @var{low} and @var{high}, -->
     <!-- into a floating point value which is then stored into @var{x}.  The -->
     <!-- value is truncated to fit in mode @var{mode}. -->
      <p>转换在<var>low</var>和<var>high</var>中的一个双精度整数为浮点值，其被存储在<var>x</var>中。值被截取以适合机器模式<var>mode</var>。
</p></blockquote></div>

<!-- @node Mode Switching -->
<!-- @section Mode Switching Instructions -->
 </body></html>

