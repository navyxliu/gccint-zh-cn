@c markers: CROSSREF BUG TODO

@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
@c 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@c Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node Passes
@chapter 编译器的Passes和相关文件
@cindex passes and files of the compiler
@cindex files and passes of the compiler
@cindex compiler passes and files

@en This chapter is dedicated to giving an overview of the optimization and
@en code generation passes of the compiler.  In the process, it describes
@en some of the language front end interface, though this description is no
@en where near complete.
这章综述了编译器的优化和代码产生@term{pass}。

@menu
* 语法分析@term{pass}::        语言前端将文本转换为机器字节。
* Gimplification过程::  将机器字节转换为可以优化的形式。
* 过程管理器::          序列化优化过程。
* Tree-SSA过程::        基于高级表示上的优化。
* RTL过程::             基于低级表示上的优化。
@end menu

@node 语法分析过程
@section 语法分析过程
@cindex GENERIC
@findex lang_hooks.parse_file
语言前端只被调用一次，通过@code{lang_hooks.parse_file}，
用来解析整个输入。语言前端可以使用任何被认为合适的中间语言表示。
C前端使用了GENERIC树，以及在@file{c-common.def}中定义的
（double handful of）语言特定的树代码。
Fortran前端使用了完全不同的私有表示。

@cindex GIMPLE
@cindex gimplification
@cindex gimplifier
@cindex language-independent intermediate representation
@cindex intermediate representation lowering
@cindex lowering, language-dependent intermediate representation
在某个地方，
前端必须将其使用的表示转换为编译器中语言独立的部分能够理解的表示。
目前的实现采用了两种形式。C前端在函数编译完之前，
手动的对每个函数调用gimplifier，
并且使用gimplifier回调函数将语言特定的树代码直接转换为GIMPLE。
Fortran前端将私有表示转换为 GENERIC，之后当函数编译完时，
再降低为GIMPLE。选择哪种途径可能取决于GENERIC（及其扩展）
是否能够很好的匹配源语言，以及是否需要解析数据结构。

BUG：Gimplification必须在nested function lowering之前进行，
并且nested function lowering必须在将数据传给cgraph之前，由前端完成。

TODO：Cgraph应该控制nested function lowering。并且只会在确定最外层函数被使用时才调用。

TODO：Cgraph需要一个gimplify_function回调函数。
并且在下列情况下会被调用：(1)确定函数被使用，
(2)为了兑现用户指定的警告选项，需要多次的编译，
(3)语言本身表明了在gimplification进行前，语义分析会不完整。
嗯。。。听起来有点过度复杂。或许我们应该总是进行前端的gimplify；
大多数情况，这只是一个函数调用。

前端需要将所有函数的定义和顶层的声明传给中端，
以至于它们能被编译和生成目标文件。对于一个简单的程序语言，
顶层的每个声明和定义都能找到，因此这样做非常方便。
另外，对于生成函数代码和生成完全的调试信息，也有差别。
对于函数代码，唯一必须的是将函数和数据定义传给中端。
对于完全的调试信息，函数，数据和类型的声明也都需要被传递。

@findex rest_of_decl_compilation
@findex rest_of_type_compilation
@findex cgraph_finalize_function
任何情况下，如果前端需要每个完全的顶层函数或数据声明，
则每个数据定义应该传给@code{rest_of_decl_compilation}。
每个完全的类型定义应该传给@code{rest_of_type_compilation}。
每个函数定义应给传给@code{cgraph_finalize_function}。

中端根据自己的选择，将会立即生成函数和数据的定义，
或者放入队列中以便后面的处理。

@node Gimplification过程
@section Gimplification过程

@cindex gimplification
@cindex GIMPLE
@dfn{Gimplification}是一个离奇的术语，
用来表示将函数的中间表示转换为GIMPLE语言的过程。
The term stuck，所以像“gimplification”, “gimplify”, 
“gimplifier” 等类似的单词会分布在这部分代码中。

@cindex GENERIC
当然，尽管前端可以选择直接生成GIMPLE，但如果这样，
则处理起来可能会有些复杂，除非前端使用的中间语言非常简单。
通常生成GENERIC树以及其扩展会相对容易些，
并且让语言独立的gimplifier来多大部分的工作。

@findex gimplify_function_tree
@findex gimplify_expr
@findex lang_hooks.gimplify_expr
这个过程的主入口点是@code{gimplify_function_tree}，
位于@file{gimplify.c}中。我们从这里处理整个函数，
依次的对每条语句进行gimplify。
这个过程的主要工作是@code{gimplify_expr}。
几乎每个处理都需要经过这里一次，
并且我们是从这里来调用@code{lang_hooks.gimplify_expr}回调的。

回调函数应该考虑检查表达式，
并且当表达式不是一个需要注意的语言特定的结构，
则返回@code{GS_UNHANDLES}。
否则，应该通过某种方式修改表达式使得可以产生合法的GIMPLE。
如果回调函数确定已经完全转换，并且表达式是合法的GIMPLE，
则应该返回@code{GS_ALL_DONE}。
否则，应该返回@code{GS_OK}，这将会使得表达式会被再次处理。
如果回调函数在转换过程中遇到一个错误
（因为前端依赖于gimplification处理来完成语义检测），
则应该返回@code{GS_ERROR}。

@node 过程管理器
@section 过程管理器

过程管理器在@file{passes.c}，
@file{tree-optimize.c}和@file{tree-pass.h}中。
它的工作是按照正确的顺序来运行所有单独的过程，
并且处理应用到每个过程的标准薄记（standard bookkeeping）。

工作原理是每个过程定义了一个结构体，
用来表示我们需要知道的关于该过程的每件事情——应该什么运行，
应该如何运行，需要什么中间语言或者附加的数据结构。
我们按照某种特定的运行顺序来注册过程，
过程管理器来安排所有的事情都按正确的顺序发生。

目前实际的实现并不是完全做到了理论上所描述的。
命令行开关和@code{timevar_id_t}枚举还必须定义在其它地方。
过程管理器。。。不管怎样，现在的实现是有用的，比没有强。

TODO：描述由过程管理器建立的全局变量，以及对一个新的过程应该如何使用。

@node Tree-SSA过程
@section Tree-SSA过程

下面简要描述了经过gimplification之后的树优化过程，以及所在的源文件。

@itemize @bullet
@item 删除无用语句（Remove useless statements） 

该过程对gimple代码进行非常简单的扫描，识别出明显的死代码并删除。
我们在这里做的一些事情包括，简化具有不变条件的@code{if}语句，
删除对显然不会抛出异常的代码所做的异常处理，
删除不含有变量的词法绑定（lexical bindings），以及其它各种简单的清除。
这是为了能够快速的去掉一些显而易见的东西，而不是等到后面去花费更多的功夫。
该过程在@file{tree-cfg.c}中，并且由@code{pass_remove_useless_stmts}来描述。

@item Mudflap声明注册（Mudflap declaration registration） 

如果启用了mudflap（参见@ref{Optimize Options,,-fmudflap -fmudflapth -fmudflapir,gcc,Using the GNU Compiler Collection (GCC)}
我们便产生代码来记录一些使用mudflap运行时的变量声明。特别的，
运行时会跟踪这些变量声明的生命期，将它们的地址记录下来，
或者哪些边界在编译时不知道（@code{extern}）。
该过程生成新的异常处理结构（@code{try}/@code{finally}），
因此必须在它们下降之前运行。另外，
该过程enqueque生命期扩展为整个程序的静态变量声明。
过程位于@file{tree-mudflap.c}中，并由@code{pass_mudflap_1}来描述。

@item OpenMP下降（OpenMP lowering） 

如果启用了OpenMP生成（@option{-fopenmp}），该过程将OpenMP结构下降为GIMPLE。

OpenMP结构下降涉及到为使用数据共享子句映射的局部变量创建替代表达式，
揭示最可能同步指令的控制流，以及增加region标记来帮助控制流图的创建。
该过程位于@file{omp-low.c}中，并由@code{pass_lower_omp}来描述。

@item OpenMP扩展（OpenMP expansion）

如果启用了OpenMP生成（@option{-fopenmp}），
该过程将并行region扩展为由线程库调用的它们自己的函数。
过程位于@file{omp-low.c}中，并由@code{pass_expand_omp}来描述。

@item 控制流下降（Lower control flow） 

该过程压平（flatten）@code{if}语句（@code{COND_EXPR}），
并将词法绑定（@code{BIND_EXPR}）移到行外。在该过程之后，
所有@code{if}语句将会有确切的两条@code{goto}语句在@code{then}和@code{else}处。
每条语句的词法绑定信息将在@code{TREE_BLOCK}中找到，
而不是由@code{BIND_EXPR}下的它的位置来推算出。
该过程可以在@file{gimple-low.c}中找到，并由@code{pass_lower_cf}来描述。

@item 异常处理控制流下降（Lower exception handling control flow） 

该过程将高级别的异常处理结构（@code{TRY_FINALLY_EXPR}和@code{TRY_CATCH_EXPR}）
转换为能显示表示控制流相关的形式。该过程之后，@code{lookup_stmt_eh_region}将会
为任何可能具有EH控制流语义的语句返回一个非负数；对于确切的语义可以检查
@code{tree_can_throw_internal}或@code{tree_can_throw_external}。
确切的控制流可以从@code{foreach_reachable_handler}中提取。
EH region嵌套树在@file{except.h}和@file{except.c}中定义。
下降过程本身在@file{tree-eh.c}中，并由@code{pass_lower_eh}来描述。

@item 构建控制流图（Build the control flow graph）

该过程将函数分解为基本块，并创建所有相连的边。它位于@file{tree-cfg.c}中，
并由@code{pass_build_cfg}描述。

@item 找到所有被引用的变量（Find all referenced variables） 

该过程遍历整个函数，并将函数中所有被引用的变量搜集到一个数组中，
@code{referenced_vars}。每个变量在数组中的索引被用作函数中这个变量的UID。
SSA重写程序需要用到该数据。过程位于@file{tree-dfa.c}中，
并由@code{pass_referenced_vars}来描述。

@item 进入静态单赋值形式（Enter static single assignment form） 

该过程将函数重写为SSA形式。该过程之后，
所有@code{is_gimple_reg}变量将通过@code{SSA_NAME}来引用，
并且所有其它变量将由@code{VDEFS}和@code{VUSES}来注解；对于每个基本块，
PHI节点将会在需要的时候被插入。该过程位于@file{tree-ssa.c}中，
并由@code{pass_build_ssa}来描述。

@item 未初始化变量警告（Warn for uninitialized variables） 

该过程扫描函数，寻找使用缺省定义的@code{SSA_NAME}。对于非参数变量，
这样的使用是未初始化的。该过程运行两次，优化前和优化后。第一次过程中，
我们只警告肯定是未初始化的；在第二次过程中，我们警告可能未初始化的。
过程位于@file{tree-ssa.c}中，并由@code{pass_early_warn_uninitialized}和
@code{pass_late_warn_uninitialized}定义。

@item 死代码消除（Dead code elimination） 

该过程扫描函数来寻找没有副作用，且结果没有被使用的语句。它不进行内存活跃分析，
所以任何存储在内存中值都被认为是被使用的。该过程在整个优化处理中被运行多次。
它位于@file{tree-ssa-dce.c}中，并由@code{pass_dce}来描述。

@item dominator优化（Dominator optimizations） 

该过程执行平凡的基于dominator的复制和常量传播，表达式简化，以及跳转线程化。
它在整个优化处理中被运行多次。它位于@file{tree-ssa-dom.c}中，
并由pass_dominator来描述。
@code{pass_dominator}.

@item 单用变量向前传播（Forward propagation of single-use variables） 

该过程尝试移除冗余计算，通过将只使用一次的变量替换为使用它们的表达式，
并查看是否得到的结果可以被简化。它位于@file{tree-ssa-forwprop.c}中，
并由@code{pass_forwprop}来描述。

@item 复制重名命（Copy Renaming） 

该过程尝试改变涉及复制操作的编译器临时对象的名字，例如SSA->normal。
当编译器临时对象是用户变量复制时，它还将编译器临时对象重命名为用户变量，
使得可以更好的使用用户符号。它位于@file{tree-ssa-copyrename.c}中，
并由@code{pass_copyrename}来描述。

@item PHI节点优化（PHI node optimizations） 

该过程识别可以被表示为条件表达式的PHI输入，并将它们重写成线形的代码。
它位于@file{tree-ssa-phiopt.c}中，并由@code{pass_phiopt}来描述。

@item 可能别名优化（May-alias optimization） 

该过程执行一个流敏感基于SSA指向的分析。所得的may-alias, must-alias和escape分析
信息用来将变量从内存中可寻址的对象提升为可以被重命名为SSA形式的无别名变量。
我们还为非可命名的聚合体更新@code{VDEF}/@code{VUSE}内存标记，
使得可以获得较少的错误。过程位于@file{tree-ssa-alias.c}中，
并由@code{pass_may_alias}来描述。

进程间的指向信息位于@file{tree-ssa-structalias.c}中，
并由@code{pass_ipa_pta}来描述。

@item Profiling

该过程重写函数，用于搜集运行时块和评估profiling数据。
这些数据可以反馈给随后的编译器运行，这样就可以进行基于预期执行频率的优化。
过程位于@file{predict.c}中，并由@code{pass_profile}来描述。

@item 复数算术运算下降（Lower complex arithmetic） 

该过程将复数算术运算重写为各部分的标量算术运算。
过程位于@file{tree-complex.c}中，并由@code{pass_lower_complex}来描述。

@item 聚合体标量替换（Scalar replacement of aggregates） 

该过程将适当的非别名局部聚合体变量重写为一个标量集合。
所得的标量变量被重写成SSA形式，这样就允许后面的优化过程来做更好的工作。
过程位于@file{tree-sra.c}中，并由@code{pass_sra}来描述。

@item 死存储消除（Dead store elimination） 

该过程消除死存储，即存储到内存中，而该内存被随后的另一个存储操作重新写入，
并且之间没有加载操作。过程位于@file{tree-ssa-dse.c}中，
并由@code{pass_dse}来描述。

@item 尾递归消除（Tail recursion elimination） 

该过程将所有的尾递归转换到一个循环中。它位于@file{tree-tailcall.c}中，
并由@code{pass_tail_recursion}来描述。

@item 向前存储移动（Forward store motion） 

该过程将存储和赋值操作下沉到流图中接近它的使用点。
过程位于@file{tree-ssa-sink.c}中，并由@code{pass_sink_code}来描述。

@item 部分冗余消除（Partial redundancy elimination） 

该过程消除部分冗余计算，同时执行加载移动。过程位于@file{tree-ssa-pre.c}中，
并由@code{pass_pre}来描述。

如果设置了@option{-funsafe-math-optimizations}，则在部分冗余消除前，
GCC尝试通过倒数方式将除法转换为乘法。过程位于@file{tree-ssa-math-opts.c}中，
并由@code{pass_cse_reciprocal}来描述。

@item 完全冗余消除（Full redundancy elimination） 

这是一个较简单的PRE形式，只消除在所有路径上产生的冗余。
它位于@file{tree-ssa-pre.c}中，并由@code{pass_fre}来描述。

@item 循环优化（Loop optimization） 

该过程的主驱动程序位于@file{tree-ssa-loop.c}中，并且由@code{pass_loop}来描述。

该过程执行的优化为：

循环不变量移动。该过程只移动在rtl级难以处理的不变量（函数调用，
扩展成非平凡insn序列的操作）。使用@option{-funswitch-loops}时，
它还将不变的条件操作数移到循环外面，
使得我们能够在循环外提过程中只需要进行平凡不变量分析。该过程还包括存储移动。
该过程在@file{tree-ssa-loop-im.c}中实现。

正规归纳变量创建。该过程为循环迭代次数创建一个简单计数器，
并使用它来替换循环的退出条件，以用于当一个复杂的分析需要确定迭代次数的时候。
之后的优化便可以容易的确定迭代次数。
该过程在@file{tree-ssa-loop-ivcanon.c}中实现。

规约变量优化。该过程执行标准的规约变量优化，包括强度缩减，规约变量合并，
以及规约变量消除。该过程在@file{tree-ssa-loop-ivopts.c}中实现。

循环外提。该过程将不变的条件跳转移到循环外面。为了达到这一点，
对于每种可能的条件跳转结果都会创建一个循环副本。
该过程在@file{tree-ssa-loop-unswitch.c}中实现。
该过程应该最终替代在@file{loop-unswitch.c}中的rtl级的循环外提，
但是目前rtl级的过程还不是完全多余的，是因为还缺少tree级的别名分析。

这些优化还用到了@file{tree-ssa-loop-manip.c}, @file{cfgloop.c}, 
@file{cfgloopanal.c}和@file{cfgloopmanip.c}中的各种函数。

向量化。该过程将循环由标量类型操作转换为向量类型操作。跨越循环迭代的数据并行被利用，将数据元素从连续的迭代中组合成一个向量，对它们并行的操作。取决于可用的目标机的支持，循环在概念上按照因子@code{VF}（vectorization factor）被展开。

自动并行化。该过程将循环迭代空间拆分到几个线程来运行。该过程在tree-parloops.c中实现。

@item 用于向量化的Tree级if转换 （Tree level if-conversion for vectorizer） 

该过程对简单的循环应用if转换，以助于向量化。我们识别可以if转换的循环，
并将基本块合并到一个大块中。想法是将循环表现为这样的形式，
使得向量化能够对语句和可用的向量操作进行一一映射。
该patch在GIMPLE级重新引入了COND_EXPR。该过程位于@file{tree-if-conv.c}中，
并由@code{pass_if_conversion}来描述。

@item 条件常量传播（Conditional constant propagation）

该过程松弛一个点阵值用于识别那些即使在条件分支中也肯定是常数的。
该过程位于@file{tree-ssa-ccp.c}中，并由@code{pass_ccp}来描述。

一个相关的工作于内存加载和存储，而不只是寄存器值的过程，
位于@file{tree-ssa-ccp.c}中，并由@code{pass_store_ccp}来描述。

@item 条件复制传播（Conditional copy propagation） 

这类似于常量传播，不过点阵值是与“copy-of”相关的。它消除代码中的冗余复制。
该过程位于@file{tree-ssa-copy.c}中，并由@code{pass_copy_prop}来描述。

一个相关的工作于内存复制而不只是寄存器复制的过程，位于@file{tree-ssa-copy.c}中，
并由@code{pass_store_copy_prop}来描述。

@item 值范围传播（Value range propagation） 

该转换类似于常量传播，只不过它是传播已知值的范围，而不是传播单个常数值。
该实现基于Patterson的范围传播算法（Accurate Static Branch Prediction by Value Range Propagation, J. R. C. Patterson, PLDI '95）。
相对于Patterson的算法，该实现没有传播分支可能性，也没有对SSA名使用多个范围。
这意味着现在的实现不能用于分支预测（虽然并不难实现）。
该过程位于@file{tree-vrp.c}中，并由@code{pass_vrp}来描述。

@item 折叠built-in函数（Folding built-in functions） 

该过程适当的简化built-in函数，使用常量参数或者可推算出的字符串长度。
它位于@file{tree-ssa-ccp.c}中，并由@code{pass_fold_builtins}来描述。

@item 拆分临界边（Split critical edges） 

该过程识别出临界边，并插入空基本块来将其转换为非临界的。
该过程位于@file{tree-cfg.c}，并由@code{pass_split_crit_edges}描述。

@item 控制依赖死代码消除（Control dependence dead code elimination） 

该过程是死代码消除的较强形式，能够消除不必要的控制流程语句。
它位于@file{tree-ssa-dce.c}中，并由@code{pass_cd_dce}来描述。

@item 尾调用消除（Tail call elimination） 

该过程识别可以被重写为跳转的函数调用。这里没有进行实际的代码转换，
不过却解决了数据流和控制流的问题。代码转换需要目标机支持，因此被推迟到RTL级。
同时，@code{CALL_EXPR_TAILCALL}被设置，以用来指示可能性。
该过程位于@file{tree-tailcall.c}中，并且由@code{pass_tail_calls}来描述。
RTL转换由@file{calls.c}中的@code{fixup_tail_calls}来处理。

@item 对函数没有返回值的警告（Warn for function return without value） 

对于非void型的函数，该过程定位没有指定一个值的返回语句，并产生一个警告。
这样的语句可能是在函数结束处。该过程在最后运行，
这样我们能够更多可能的去检验这些语句是不可达的。其位于@file{tree-cfg.c}中，
并由@code{pass_warn_function_return}来描述。

@item Mudflap语句注解（Mudflap statement annotation）

如果启用了mudflap，我们便重写一些内存访问代码以确保内存访问是正确的。特别的，
涉及到指针废除的表达式（INDIRECT_REF, ARRARY_REF等等）被替代为检查选择地址范围
的代码，而不是mudflap运行时数据库的有效域。该检查包括一个内联的对直接映射缓存
的查找，基于对指针值的shift/mask操作，和对运行时的回滚函数调用。
该过程位于@file{tree-mudflap.c}中，并由@code{pass_mudflap_2}来描述。

@item 离开静态单赋值形式（Leave static single assignment form） 

该过程重写函数使得其处于正常形式。同时，我们尽可能的消去单一使用的临时对象，
这样中间语言就不再是GIMPLE了，而是GENERIC。该过程位于@file{tree-outof-ssa.c}中，
并且由@code{pass_del_ssa}来描述。

@item 合并PHI节点（Merge PHI nodes that feed into one another） 

这是CFG清除过程的一部分。它试图将PHI节点从前部CFG块合并到另一个带有PHI节点的块。
该过程位于@file{tree-cfgcleanup.c}中，并由@code{pass_merge_phi}来描述。

@item 返回值优化（Return value optimization）

如果函数总是返回同一局部变量，并且那个局部变量是一个聚合类型，
则变量将由函数返回值来替换（即函数的DECL_RESULT）。
这相当于作用于GIMPLE的C++命名返回值优化。该过程位于@file{tree-nrv.c}中，
并且由@code{pass_nrv}来描述。

@item 返回槽优化（Return slot optimization） 

如果函数返回一个内存对象，并且像@code{var = foo()}这样被调用，
该过程尝试改变调用，使得@code{var}的地址传送给调用者，以避免一次额外的内存复制。
该过程位于@code{tree-nrv.c}中，并由@code{pass_return_slot}来描述。

@item 优化调用@code{__builtin_object_size}（Optimize calls to @code{__builtin_object_size}）

这是一个类似于CCP的传播过程，其试图移除对@code{__builtin_object_size}的调用，
当对象的大小能够在编译时计算出的时候。该过程位于@file{tree-object-size.c}中，
并有@code{pass_object_sizes}来描述。

@item 循环不变量移动（Loop invariant motion） 

该过程将昂贵的循环不变量计算移出循环。该过程位于@file{tree-ssa-loop.c}中，
并由@code{pass_lim}来描述。

@item 循环嵌套优化（Loop nest optimizations） 

这是一类工作于循环嵌套的循环转换。它包括循环变换（loop interchange），scaling，
skewing和逆转（reversal），并且它们用来配合。
该过程位于@file{tree-loop-linear.c}中，并由@code{pass_linear_transform}来描述。

@item 空循环移除（Removal of empty loops）

该过程移除不含代码的循环。该过程位于@file{tree-ssa-loop-ivcanon.c}中，
并由@code{pass_empty_loop}来描述。

@item 小循环展开（Unrolling of small loops） 

该过程将迭代次数很少的循环完全展开。该过程位于@file{tree-ssa-loop-ivcanon.c}中，
并由@code{pass_complete_unroll}来描述。

@item 预测公约（Predictive commoning） 

该过程使代码可以重用先前循环迭代的计算，特别是对内存的加载和存贮。
该过程位于@file{tree-predcom.c}中，并由@code{pass_predcom}来描述。

@item 数组预取（Array prefetching） 

该过程为循环中的数组引用产生预提取指令。
过程位于@file{tree-ssa-loop-prefetch.c}中，并由@code{pass_loop_prefetch}来描述。

@item 重组（Reassociation） 

该过程将算术表达式重写为可以进行优化的形式，例如冗余消除和向量化。
过程位于@file{tree-ssa-reassoc.c}中，并由@code{pass_reassoc}来描述。

@item 优化@code{stdarg}函数 

该过程设法避免在@code{stdarg}函数入口处将寄存器参数保存到栈中。
如果函数不使用任何@code{va_start}宏，则没有寄存器需要被保存。
如果使用了@code{va_start}宏，@code{va_list}变量的使用范围不超出该函数，
则只需要保存将在@code{va_arg}宏中使用的寄存器。例如，
如果@code{va_arg}在函数中只用于整数类型，则不需要保存浮点寄存器。
该过程位于@code{tree-stdarg.c}中，并由@code{pass_stdarg}来描述。

@end itemize

@node RTL过程
@section RTL过程

下面简要描述了tree优化之后所运行的rtl生成和优化过程。

@itemize @bullet
@item RTL生成 

实现RTL生成的源文件包括
@file{stmt.c},
@file{calls.c},
@file{expr.c},
@file{explow.c},
@file{expmed.c},
@file{function.c},
@file{optabs.c}和@file{emit-rtl.c}。
该过程还用到了由@code{genemit}程序通过机器描述生成的@file{insn-emit.c}文件。
该过程使用头文件@file{expr.h}来交互信息。

@findex genflags
@findex gencodes
由程序@code{genflags}和@code{gencodes}通过机器描述来生成的头文件
@file{insn-flags.h}和@file{insn-codes.h}，告诉了该过程哪些标准名字可用，
以及哪些模式与它们对应。

@item 生成异常处理着陆架（Generate exception handling landing pads） 

该过程生成用来管理异常处理库程序和函数中的异常处理器之间通讯的粘合机制（glue）。
由异常处理库调用的函数的入口点，被称作着陆架（@dfn{landing pads}）。
该过程的代码位于@file{except.c}中。

@item 清除控制流图（Cleanup control flow graph）

该过程去除不可达代码，对跳转到下一条指令（jumps to next），
连续跳转（jumps to jump），交叉跳转（jumps across jumps）等情况进行简化。
该过程被运行多次。出于历史原因，该过程有时被称为“跳转优化过程”。
该过程的主要代码在@file{cfgcleanup.c}中，
还有一些辅助程序在@file{cfgrtl.c}和@file{jump.c}中。

@item 单定义值的向前传播（Forward propagation of single-def values） 

该过程尝试通过替换来自单一定义的变量，并观察结果是否能够被简化的方式，
来去除冗余计算。它执行了复制传播和寻址模式选择。该过程运行两次，
并只在第二次的时候将值传播到循环中。它位于@file{fwprop.c}中。

@item 公共子表达式消除（Common subexpression elimination） 

该过程去除基本块中的冗余计算，并且根据代价来优化寻址模式。该过程运行两次。
源代码位于@file{cse.c}中。

@item 全局公共子表达式消除（Global common subexpression elimination） 

该过程执行两种不同类型的GCSE，取决于你是否在优化代码大小（基于LCM的GCSE趋向于通
过增加代码大小来获得速度，而基于Morel- Renvoise的GCSE则不是）。当优化代码大小时
，使用Morel-Renvoise Partial Redundancy Elimination（部分冗余消除）来做GCSE，
并不尝试将不变量移到循环之外——这留到循环优化过程。如果进行MR PRE，
则还会进行代码提升（code hoisting），（也称为code unification），
还有加载移动（load motion）。如果你在优化速度，则会进行基于LCM
（lazy code motion）的GCSE。LCM是基于Knoop, Ruthing和Steffen的工作。
基于LCM的GCSE也会进行循环不变量代码移动。当优化速度时，
我们还执行加载和存储移动。不管使用哪一种类型的GCSE，
该过程都还执行全局常量传播和复制传播。该过程的源代码为@file{gcse.c}，
LCM程序在@file{lcm.c}中。

@item 循环优化（Loop optimization） 

该过程执行几个循环相关的优化。源文件@file{cfgloopanal.c}和@file{cfgloopmanip.c}
包含了通用的循环分析和操作代码。循环结构体的初始化和完成（finalization）
由@file{loop-init.c}处理。循环不变量移动过程在@file{loop-invariant.c}中实现。
基本块级的优化—— unrolling,peeling和unswitching——在@file{loop-unswitch.c}和
@file{loop-unroll.c}中实现。@file{loop-doloop.c}是关于使用特定的机器相关结构来
替代循环退出条件的处理。

@item 跳转迂回（Jump bypassing） 

该过程是GCSE的激进形式，通过传播常数到条件分支指令中来转换函数的控制流图。
该过程的源文件为@file{gcse.c}。

@item If转换（If conversion） 
该过程尝试使用产生比较指令和条件移送指令的算术的布尔值，来替换条件分支和附近的赋值。在重载之后最近的调用中，当目标机支持的时候，其将生成断言指令。该过程位于@file{ifcvt.c}。

@item Web构造（Web construction） 

该过程拆分为独立的使用每个伪寄存器。这能够提高其它转换过程的效率，
例如CSE或者寄存器分配。源文件为@file{web.c}。

@item 生命期分析（Life analysis） 

该过程计算在程序的每个点上哪些伪寄存器是活跃的，
并且使第一条指令使用一个值来指向计算值的指令。
然后它删除结果从来不会被使用的计算，
并且将内存引用和加减指令组合为自动增量或者自动减量寻址。
该过程位于@file{flow.c}中。

@item 指令合并（Instruction combination） 

该过程尝试去将数据流相关的两条或者三条指令组合并为单一指令。它通过替代，
使用代数简化结果的方式来为指令合并RTL表达式，然后尝试去将结果跟机器描述匹配。
该过程位于@file{combine.c}。

@item 寄存器移动（Register movement） 

该过程寻找这样的情况，即当匹配约束条件时会迫使指令需要重载，
并且这个重载为一个寄存器到寄存器的move操作。
然后它尝试改变指令使用的寄存器来避免move指令。该过程位于@file{regmove.c}中。

@item 优化模式转换（Optimize mode switching） 

该过程寻找这样的指令，即需要处理器处于特定的模式（mode），
然后将模式改变的数目减到最少。这些模式是什么以及应用于什么完全是目标机特定的。
源代码位于@file{mode-switching.c}中。

@cindex modulo scheduling
@cindex sms, swing, software pipelining
@item 模调度（Modulo scheduling） 

该过程查看内部循环并且通过复合不同的迭代来重排它们的指令。
模调度在指令调度之后立即被执行。该过程位于@file{modulo-sched.c}。

@item 指令调度（Instruction scheduling）

该过程寻找这样的指令，其输出在后来的指令中不会用到。在RISC机器上，
内存加载和浮点指令经常会有这样的特征。
它重新排序基本块中的指令以尝试将定义和使用分开，从而避免引起流水线阻塞。
该过程执行两次，分别在寄存器分配之前和之后。
该过程位于@file{haifa-sched.c}, @file{sched-deps.c}, @file{sched-ebb.c}, 
@file{sched-rgn.c}和@file{sched-vis.c}中。

@item 寄存器分配（Register allocation） 

这些过程确保所有伪寄存器都被去除，或者通过给它们分配硬件寄存器，
或者使用等价表达式来替换（例如常数），或者将它们放在栈中。这由几个子过程来完成：

@itemize @bullet
@item
寄存器移送优化。该过程进行一些简单的RTL代码转换，来改进后续的寄存器分配。源文件为@file{regmove.c}。

@item
集成寄存器分配(@acronym{IRA})。其被称作集成的，是因为合并，寄存器活跃范围拆分，以及硬件寄存器优先选定，都在图着色中被执行。其还更好的与重载过程集合在一起。寄存器分配或者重载所溢出的伪寄存器还有机会来获得硬件寄存器，如果重载从硬件寄存器中赶出了一些伪寄存器。寄存器分配可以帮助选择更好的伪寄存器来溢出，基于它们的活跃返回，并且合并为溢出的伪寄存器所分配的栈槽。IRA为一个区域的寄存器分配，如果只有一个区域，则其被转换成Chaitin-Briggs寄存器分配。缺省的IRA使用寄存器压力来选择区域，不过用户可以强制其使用一个区域或者对应于所有循环的多个区域。

寄存器分配的源文件为@file{ira.c}, @file{ira-build.c},
@file{ira-costs.c}, @file{ira-conflicts.c}, @file{ira-color.c},
@file{ira-emit.c}, @file{ira-lives}，以及头文件@file{ira.h}和@file{ira-int.h}，用于在分配器和编译器其它部分，以及IRA文件之间的交互。

@cindex reloading
@item
重载（reloading）。该过程使用分配的硬件寄存器编号来重新为伪寄存器编号。
没有获得硬件寄存器的伪寄存器被分配到栈槽中。然后寻找那些由于无法放入寄存器，
或者放入错误类型寄存器所引起的无效指令。
通过将有问题的值临时重载到寄存器中来修复这些指令，并生成辅助的指令进行复制。

重载过程还可选的消除帧指针，
以及插入指令来保存和恢复调用破坏掉的（call-clobbered）寄存器。

源文件为@file{reload.c}和@file{reload1.c}，
还有用于信息交互的头文件@file{reload.h}。
@end itemize

@item 基本块重新排序（Basic block reordering） 

该过程实现了profile指导的代码安置（code positioning）。如果profile信息不可用，
便会执行不同类型的静态分析来作出通常通过profile反馈（IE执行频率，分支可能性等）
而得出的预测。其在@file{bb-reorder.c}中实现，不同的预测程序在@file{predict.c}中。

@item 变量跟踪（Variable tracking） 

该过程计算变量在代码中的每个位置（position）所被存储的到的地方，
并生成注解到RTL代码中来描述变量位置(location)。
如果调试信息格式支持位置列表(location lists)的话，
便会根据这些注解来生成位置列表到调试信息中。

@item 延迟分支调度（Delayed branch scheduling）

该可选的过程尝试去找到能够放在其它指令，通常是跳转或者调用指令，
的延迟槽中的指令。源文件名为@file{reorg.c}。

@item 分支缩短（Branch shortening） 

许多RISC机器上，分支指令有一个限制范围。因此，较长的指令序列必须用于长分支。
在这个过程中，编译器计算出指令间的距离有多长，
并且对于每个分支是否使用普通指令或者交长的指令序列。

@item 寄存器到栈的转换（Register-to-stack conversion） 

将一些硬件寄存器的使用转换为一个寄存器栈的使用可以在这里完成。目前，
该过程只支持Intel 80387协处理器的浮点寄存器。源文件名为@file{reg-stack.c}。

@item Final过程

该过程输出函数的汇编代码。源文件为@file{final.c}和@file{insn-output.c}，
后者由工具@file{genoutput}通过机器描述自动生成。
头文件@file{conditions.h}用于这些文件间的信息交互。如果启用了mudflap，
延迟声明和可寻址常量（如字符串文字）的队列将由@code{mudflap_finish_file}处理
成一个调用mudflap运行时的综合构造器函数。

@item 调试信息输出

该过程在Final过程之后运行，
是因为它必须为没有获得硬件寄存器的伪寄存器输出栈槽偏移量。源文件包括，
用于DBX符号表格式的@file{dbxout.c}，用于SDB符号表格式的@file{sdbout.c}，
用于DWARF符号表格式的@file{dwarfout.c}，
用于DWARF2符号表格式的@file{dwarf2out.c}和@file{dwarf2asm.c}，
以及用于VMS调试符号表格式的@file{vmsdbgout.c}。
@end itemize
