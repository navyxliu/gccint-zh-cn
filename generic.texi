@c Copyright (c) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c GENERIC
@c ---------------------------------------------------------------------

@node GENERIC
@chapter GENERIC
@cindex GENERIC

GENERIC的目的是简单的提供一个使用tree来表示整个函数的语言无关的方式。为此，之前需要为后端增加一些新的tree代码，但是大多数东西都已经存在。如果你可以使用@code{gcc/tree.def}中的代码来表示，则其即为GENERIC。

早期，有一个很大的争论，关于如何在tree IL级别来考虑语句。在GENERIC中，一条语句被定义为任意的表达式，其值，如果存在，被忽略。语句总是设置@code{TREE_SIDE_EFFECTS}，不过一个非语句的表达式也可以具有副作用。例如，@code{CALL_EXPR}。


对于一些局部优化，可以在函数的GENERIC形式上进行工作；的确，被改写的tree内联在GENERIC上可以很好的工作，不过目前编译器是在下降到GIMPLE（一个严格的形式，在下节有描述）之后，才执行内联的。确实，目前前端是在移交给@code{tree_rest_of_compilation}之前，来执行该下降，不过这看起来不太优雅。


如果有必要，前端可以在其GENERIC表示中使用一些语言相关的tree代码，只要其提供一个钩子，将它们转换成GIMPLE，并且不要期望它们可以与任何（假象的）运行在转换成GIMPLE之前的优化器一起工作。当解析C和C++时使用的中间表示，看起来非常像GENERIC，不过C和C++ gimplifier钩子会将其作为输入，并输出GIMPLE。

@menu
* 语句::
@end menu

@node 语句
@section 语句
@cindex Statements

大多数GIMPLE语句为赋值语句，由@code{GIMPLE_ASSIGN}来表示。没有其它C表达式可以出现在语句级别；对一个volatile对象的引用被转换成一个@code{GIMPLE_ASSIGN}。

还有几个复杂语句的变体。

@menu
* 块::
* 语句序列::
* 空语句::
* 跳转::
* 清除::
@end menu

@node 块
@subsection 块
@cindex Blocks

块作用域和它们声明的变量，在GENERIC中使用@code{BIND_EXPR}代码来表示。这在之前的GCC版本中被主要表示为C语句表达式扩展。

块中的变量按照声明的顺序被搜集到@code{BIND_EXPR_VARS}中。任何运行时的初始化被从@code{DECL_INITIAL}中移出，并移送到控制块中的一条语句。当从C或者C++进行gimplifying的时候，该初始化用来替换@code{DECL_STMT}。

可变长度的数组（VLA）使得该处理变得复杂，因为它们的大小经常是一个块中早前被初始化的变量。为了进行处理，我们目前将块在那个点进行拆分，将VLA移送到一个新的，内部的@code{BIND_EXPR}。该策略在将来可能会改变。

C++程序通常包含比源代码中语法块更多的@code{BIND_EXPR}，因为多个C++构造函数具有隐式的与它们相关联的作用域。另一方面，虽然C++前端使用伪作用域来处理析构函数对对象的清除，这些并不被转换成GIMPLE形式；在相同级别上的多个声明使用相同的@code{BIND_EXPR}。

@node 语句序列
@subsection 语句序列
@cindex Statement Sequences
同一嵌套级别的多个语句被搜集到一个@code{STATEMENT_LIST}中。语句列表使用@samp{tree-iterator.h}中的接口来进行修改和遍历。

@node 空语句
@subsection 空语句
@cindex Empty Statements
没有作用效果的语句会尽可能的被丢弃。但是如果它们嵌套在另一个结构中，并且出于某种原因该结构不能被丢弃，则使用空语句来替换，通过@code{build_empty_stmt}来生成。起初，所有的空语句是共享的，但是这在实际中产生了许多麻烦。

空语句被表示为@code{(void)0}。

@node 跳转
@subsection 跳转
@cindex Jumps
其它的跳转由@code{GOTO_EXPR}或者@code{RETURN_EXPR}表示。

@code{GOTO_EXPR}的操作数必须为一个标号或者一个包含跳转地址的变量。

@code{RETURN_EXPR}的操作数为@code{NULL_TREE}，@code{RESULT_DECL}，或者@code{MODIFY_EXPR}，其用来设置返回值。将@code{MODIFY_EXPR}移送到一个单独的语句会好些，不过@code{expand_return}中的特定的return语义使得有些困难。这在将来可能会发生，可能会通过将大部分逻辑移送到@code{expand_assignment}中。

@node 清除
@subsection 清除
@cindex Cleanups

Destructors for local C++ objects and similar dynamic cleanups are
represented in GIMPLE by a @code{TRY_FINALLY_EXPR}.
@code{TRY_FINALLY_EXPR} has two operands, both of which are a sequence
of statements to execute.  The first sequence is executed.  When it
completes the second sequence is executed.

The first sequence may complete in the following ways:

@enumerate

@item Execute the last statement in the sequence and fall off the
end.

@item Execute a goto statement (@code{GOTO_EXPR}) to an ordinary
label outside the sequence.

@item Execute a return statement (@code{RETURN_EXPR}).

@item Throw an exception.  This is currently not explicitly represented in
GIMPLE.

@end enumerate

The second sequence is not executed if the first sequence completes by
calling @code{setjmp} or @code{exit} or any other function that does
not return.  The second sequence is also not executed if the first
sequence completes via a non-local goto or a computed goto (in general
the compiler does not know whether such a goto statement exits the
first sequence or not, so we assume that it doesn't).

After the second sequence is executed, if it completes normally by
falling off the end, execution continues wherever the first sequence
would have continued, by falling off the end, or doing a goto, etc.

@code{TRY_FINALLY_EXPR} complicates the flow graph, since the cleanup
needs to appear on every edge out of the controlled block; this
reduces the freedom to move code across these edges.  Therefore, the
EH lowering pass which runs before most of the optimization passes
eliminates these expressions by explicitly adding the cleanup to each
edge.  Rethrowing the exception is represented using @code{RESX_EXPR}.
