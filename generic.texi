@c Copyright (c) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c GENERIC
@c ---------------------------------------------------------------------

@node GENERIC
@chapter GENERIC
@cindex GENERIC

GENERIC的目的是简单的提供一个使用tree来表示整个函数的语言无关的方式。为此，之前需要为后端增加一些新的tree代码，但是大多数东西都已经存在。如果你可以使用@code{gcc/tree.def}中的代码来表示，则其即为GENERIC。

早期，有一个很大的争论，关于如何在tree IL级别来考虑语句。在GENERIC中，一条语句被定义为任意的表达式，其值，如果存在，被忽略。语句总是设置@code{TREE_SIDE_EFFECTS}，不过一个非语句的表达式也可以具有副作用。例如，@code{CALL_EXPR}。


对于一些局部优化，可以在函数的GENERIC形式上进行工作；的确，被改写的tree内联在GENERIC上可以很好的工作，不过目前编译器是在下降到GIMPLE（一个严格的形式，在下节有描述）之后，才执行内联的。确实，目前前端是在移交给@code{tree_rest_of_compilation}之前，来执行该下降，不过这看起来不太优雅。


如果有必要，前端可以在其GENERIC表示中使用一些语言相关的tree代码，只要其提供一个钩子，将它们转换成GIMPLE，并且不要期望它们可以与任何（假象的）运行在转换成GIMPLE之前的优化器一起工作。当解析C和C++时使用的中间表示，看起来非常像GENERIC，不过C和C++ gimplifier钩子会将其作为输入，并输出GIMPLE。

@menu
* 语句::
@end menu

@node 语句
@section 语句
@cindex Statements

大多数GIMPLE语句为赋值语句，由@code{GIMPLE_ASSIGN}来表示。没有其它C表达式可以出现在语句级别；对一个volatile对象的引用被转换成一个@code{GIMPLE_ASSIGN}。

还有几个复杂语句的变体。

@menu
* 块::
* 语句序列::
* 空语句::
* 跳转::
* 清除::
@end menu

@node 块
@subsection 块
@cindex Blocks

块作用域和它们声明的变量，在GENERIC中使用@code{BIND_EXPR}代码来表示。这在之前的GCC版本中被主要表示为C语句表达式扩展。

块中的变量按照声明的顺序被搜集到@code{BIND_EXPR_VARS}中。任何运行时的初始化被从@code{DECL_INITIAL}中移出，并移送到控制块中的一条语句。当从C或者C++进行gimplifying的时候，该初始化用来替换@code{DECL_STMT}。

可变长度的数组（VLA）使得该处理变得复杂，因为它们的大小经常是一个块中早前被初始化的变量。为了进行处理，我们目前将块在那个点进行拆分，将VLA移送到一个新的，内部的@code{BIND_EXPR}。该策略在将来可能会改变。

C++程序通常包含比源代码中语法块更多的@code{BIND_EXPR}，因为多个C++构造函数具有隐式的与它们相关联的作用域。另一方面，虽然C++前端使用伪作用域来处理析构函数对对象的清除，这些并不被转换成GIMPLE形式；在相同级别上的多个声明使用相同的@code{BIND_EXPR}。

@node 语句序列
@subsection 语句序列
@cindex Statement Sequences
同一嵌套级别的多个语句被搜集到一个@code{STATEMENT_LIST}中。语句列表使用@samp{tree-iterator.h}中的接口来进行修改和遍历。

@node 空语句
@subsection 空语句
@cindex Empty Statements
没有作用效果的语句会尽可能的被丢弃。但是如果它们嵌套在另一个结构中，并且出于某种原因该结构不能被丢弃，则使用空语句来替换，通过@code{build_empty_stmt}来生成。起初，所有的空语句是共享的，但是这在实际中产生了许多麻烦。

空语句被表示为@code{(void)0}。

@node 跳转
@subsection 跳转
@cindex Jumps
其它的跳转由@code{GOTO_EXPR}或者@code{RETURN_EXPR}表示。

@code{GOTO_EXPR}的操作数必须为一个标号或者一个包含跳转地址的变量。

@code{RETURN_EXPR}的操作数为@code{NULL_TREE}，@code{RESULT_DECL}，或者@code{MODIFY_EXPR}，其用来设置返回值。将@code{MODIFY_EXPR}移送到一个单独的语句会好些，不过@code{expand_return}中的特定的return语义使得有些困难。这在将来可能会发生，可能会通过将大部分逻辑移送到@code{expand_assignment}中。

@node 清除
@subsection 清除
@cindex Cleanups
对于C++局部对象的析构，以及类似的动态清除操作在GIMPLE中通过一个@code{TRY_FINALLY_EXPR}来表示。@code{TRY_FINALLY_EXPR}有两个操作数，均为要执行的语句序列。第一个序列会被执行。当其执行完毕时，第二个序列会被执行。

第一个序列可以按照下列方式来执行完毕：

@enumerate

@item 执行了序列中的最后一条语句，并结束。

@item 执行一个goto语句(@code{GOTO_EXPR})，跳到序列之外的一个普通标号。 t

@item 执行一个return语句(@code{RETURN_EXPR})。

@item 抛出一个异常。这在当前没有用GIMPLE显式的表示。

@end enumerate

如果第一个序列通过调用@code{setjmp}或@code{exit}，或者其它不返回的函数，来执行完毕，则第二个序列不会被执行。如果第一个序列通过一个非局部goto或者一个计算goto（总的来说，编译器不知道这样一个goto语句是否会退出第一个序列，所以我们假设其没有退出）来执行完毕，则第二个序列也不会被执行。

第二个序列被执行完之后，如果其正常的执行到结尾，并结束，则只要第一个序列被继续执行，其也会被继续。

@code{TRY_FINALLY_EXPR}使流图变得复杂，因为清除工作需要在流出控制块的每条边上都出现；这就减少了将代码跨越这些边进行移动的自由。因此，运行于大多数优化过程之前的EH下降过程，通过显式的增加对每个边的清除操作，来消除这些表达式。再次抛出异常使用@code{RESX_EXPR}来表示。

