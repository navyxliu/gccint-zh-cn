<html lang="zh">
<head>
<title>Parsing pass - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Passes.html#Passes" title="Passes">
<link rel="next" href="Gimplification-pass.html#Gimplification-pass" title="Gimplification pass">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Parsing-pass"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Gimplification-pass.html#Gimplification-pass">Gimplification pass</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Passes.html#Passes">Passes</a>
<hr>
</div>

<h3 class="section">9.1 语法分析pass</h3>

<p><a name="index-GENERIC-1671"></a><a name="index-lang_005fhooks_002eparse_005ffile-1672"></a><!-- The language front end is invoked only once, via -->
<!-- @code{lang_hooks.parse_file}, to parse the entire input.  The language -->
<!-- front end may use any intermediate language representation deemed -->
<!-- appropriate.  The C front end uses GENERIC trees (CROSSREF), plus -->
<!-- a double handful of language specific tree codes defined in -->
<!-- @file{c-common.def}.  The Fortran front end uses a completely different -->
<!-- private representation. -->
语言前端只被调用一次，通过<code>lang_hooks.parse_file</code>，用来解析整个输入。语言前端可以使用任何被认为合适的中间语言表示。C前端使用了GENERIC树，以及在<samp><span class="file">c-common.def</span></samp>中定义的（double handful of）语言特定的树代码。Fortran前端使用了完全不同的私有表示。

 <p><a name="index-GIMPLE-1673"></a><a name="index-gimplification-1674"></a><a name="index-gimplifier-1675"></a><a name="index-language_002dindependent-intermediate-representation-1676"></a><a name="index-intermediate-representation-lowering-1677"></a><a name="index-lowering_002c-language_002ddependent-intermediate-representation-1678"></a><!-- At some point the front end must translate the representation used in the -->
<!-- front end to a representation understood by the language-independent -->
<!-- portions of the compiler.  Current practice takes one of two forms. -->
<!-- The C front end manually invokes the gimplifier (CROSSREF) on each function, -->
<!-- and uses the gimplifier callbacks to convert the language-specific tree -->
<!-- nodes directly to GIMPLE (CROSSREF) before passing the function off to -->
<!-- be compiled. -->
<!-- The Fortran front end converts from a private representation to GENERIC, -->
<!-- which is later lowered to GIMPLE when the function is compiled.  Which -->
<!-- route to choose probably depends on how well GENERIC (plus extensions) -->
<!-- can be made to match up with the source language and necessary parsing -->
<!-- data structures. -->
在某个地方，前端必须将其使用的表示转换为编译器中语言独立的部分能够理解的表示。目前的实现采用了两种形式。C前端在函数编译完之前，手动的对每个函数调用gimplifier，并且使用gimplifier回调函数将语言特定的树代码直接转换为GIMPLE。Fortran前端将私有表示转换为 GENERIC，之后当函数编译完时，再降低为GIMPLE。选择哪种途径可能取决于GENERIC（及其扩展）是否能够很好的匹配源语言，以及是否需要解析数据结构。

<!-- BUG: Gimplification must occur before nested function lowering, -->
<!-- and nested function lowering must be done by the front end before -->
<!-- passing the data off to cgraph. -->
 <p>BUG：Gimplification必须在nested function lowering之前进行，并且nested function lowering必须在将数据传给cgraph之前，由前端完成。

<!-- TODO: Cgraph should control nested function lowering.  It would -->
<!-- only be invoked when it is certain that the outer-most function -->
<!-- is used. -->
 <p>TODO：Cgraph应该控制nested function lowering。并且只会在确定最外层函数被使用时才调用。

<!-- TODO: Cgraph needs a gimplify_function callback.  It should be -->
<!-- invoked when (1) it is certain that the function is used, (2) -->
<!-- warning flags specified by the user require some amount of -->
<!-- compilation in order to honor, (3) the language indicates that -->
<!-- semantic analysis is not complete until gimplification occurs. -->
<!-- Hum@dots{} this sounds overly complicated.  Perhaps we should just -->
<!-- have the front end gimplify always; in most cases it's only one -->
<!-- function call. -->
 <p>TODO：Cgraph需要一个gimplify_function回调函数。并且在下列情况下会被调用：(1)确定函数被使用，(2)为了兑现用户指定的警告选项，需要多次的编译，(3)语言本身表明了在gimplification进行前，语义分析会不完整。嗯。。。听起来有点过度复杂。或许我们应该总是进行前端的gimplify；大多数情况，这只是一个函数调用。

<!-- The front end needs to pass all function definitions and top level -->
<!-- declarations off to the middle-end so that they can be compiled and -->
<!-- emitted to the object file.  For a simple procedural language, it is -->
<!-- usually most convenient to do this as each top level declaration or -->
<!-- definition is seen.  There is also a distinction to be made between -->
<!-- generating functional code and generating complete debug information. -->
<!-- The only thing that is absolutely required for functional code is that -->
<!-- function and data @emph{definitions} be passed to the middle-end.  For -->
<!-- complete debug information, function, data and type declarations -->
<!-- should all be passed as well. -->
 <p>前端需要将所有函数的定义和顶层的声明传给中端，以至于它们能被编译和生成目标文件。对于一个简单的程序语言，顶层的每个声明和定义都能找到，因此这样做非常方便。另外，对于生成函数代码和生成完全的调试信息，也有差别。对于函数代码，唯一必须的是将函数和数据定义传给中端。对于完全的调试信息，函数，数据和类型的声明也都需要被传递。

 <p><a name="index-rest_005fof_005fdecl_005fcompilation-1679"></a><a name="index-rest_005fof_005ftype_005fcompilation-1680"></a><a name="index-cgraph_005ffinalize_005ffunction-1681"></a><!-- In any case, the front end needs each complete top-level function or -->
<!-- data declaration, and each data definition should be passed to -->
<!-- @code{rest_of_decl_compilation}.  Each complete type definition should -->
<!-- be passed to @code{rest_of_type_compilation}.  Each function definition -->
<!-- should be passed to @code{cgraph_finalize_function}. -->
任何情况下，如果前端需要每个完全的顶层函数或数据声明，则每个数据定义应该传给<code>rest_of_decl_compilation</code>。每个完全的类型定义应该传给<code>rest_of_type_compilation</code>。每个函数定义应给传给<code>cgraph_finalize_function</code>。

<!-- TODO: I know rest_of_compilation currently has all sorts of -->
<!-- RTL generation semantics.  I plan to move all code generation -->
<!-- bits (both Tree and RTL) to compile_function.  Should we hide -->
<!-- cgraph from the front ends and move back to rest_of_compilation -->
<!-- as the official interface?  Possibly we should rename all three -->
<!-- interfaces such that the names match in some meaningful way and -->
<!-- that is more descriptive than "rest_of". -->
 <p>TODO: 我知道 rest_of_compilation 目前有各種跟 RTL generation 有關的語意。我打算將所有和 code generation 相關的部分 (包括 Tree 和 RTL) 移至 compile_function。我們是否應該要將 cgraph 從前端隱藏起來，並以 rest_of_compilation 做為正式的介面? 或許我們應該要以較有意義的名稱重新命名這三個介面，而非僅以 "rest_of" 命名。
<!-- The middle-end will, at its option, emit the function and data -->
<!-- definitions immediately or queue them for later processing. -->
中端根据自己的选择，将会立即生成函数和数据的定义，或者放入队列中以便后面的处理。

<!-- @node Gimplification pass -->
<!-- @section Gimplification pass -->
 </body></html>

