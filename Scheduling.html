<html lang="zh">
<head>
<title>Scheduling - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Costs.html#Costs" title="Costs">
<link rel="next" href="Sections.html#Sections" title="Sections">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Scheduling"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Sections.html#Sections">Sections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Costs.html#Costs">Costs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.18 调整指令调度器</h3>

<!-- The instruction scheduler may need a fair amount of machine-specific -->
<!-- adjustment in order to produce good code.  GCC provides several target -->
<!-- hooks for this purpose.  It is usually enough to define just a few of -->
<!-- them: try the first ones in this list first. -->
<p>指令调度器可能需要一些机器特定的调整，来产生好的代码。GCC为此提供了几个target钩子。通常定义它们的一部分就足够了：先尝试该列表中最前面的。

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_ISSUE_RATE</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fISSUE_005fRATE-4366"></a></var><br>
<blockquote><!-- This hook returns the maximum number of instructions that can ever -->
     <!-- issue at the same time on the target machine.  The default is one. -->
     <!-- Although the insn scheduler can define itself the possibility of issue -->
     <!-- an insn on the same cycle, the value can serve as an additional -->
     <!-- constraint to issue insns on the same simulated processor cycle (see -->
     <!-- hooks @samp{TARGET_SCHED_REORDER} and @samp{TARGET_SCHED_REORDER2}). -->
     <!-- This value must be constant over the entire compilation.  If you need -->
     <!-- it to vary depending on what the instructions are, you must use -->
     <!-- @samp{TARGET_SCHED_VARIABLE_ISSUE}. -->
      <p>该钩子返回在target机器上同一时间可以发射的最大指令数目。缺省为1。
虽然insn调度器本身可以定义同一周期发射一个insn的可能能性，
但该值可以作为额外的约束，用于相同模拟处理器周期的insn发射
（参见钩子&lsquo;<samp><span class="samp">TARGET_SCHED_REORDER</span></samp>&rsquo;和&lsquo;<samp><span class="samp">TARGET_SCHED_REORDER2</span></samp>&rsquo;）。
该值在整个编译过程中必须为常量。如果你需要其依赖指令是什么而变化，
则必须使用&lsquo;<samp><span class="samp">TARGET_SCHED_VARIABLE_ISSUE</span></samp>&rsquo;。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_VARIABLE_ISSUE</b> (<var>FILE *file, int verbose, rtx insn, int more</var>)<var><a name="index-TARGET_005fSCHED_005fVARIABLE_005fISSUE-4367"></a></var><br>
<blockquote><!-- This hook is executed by the scheduler after it has scheduled an insn -->
     <!-- from the ready list.  It should return the number of insns which can -->
     <!-- still be issued in the current cycle.  The default is -->
     <!-- @samp{@w{@var{more} - 1}} for insns other than @code{CLOBBER} and -->
     <!-- @code{USE}, which normally are not counted against the issue rate. -->
     <!-- You should define this hook if some insns take more machine resources -->
     <!-- than others, so that fewer insns can follow them in the same cycle. -->
     <!-- @var{file} is either a null pointer, or a stdio stream to write any -->
     <!-- debug output to.  @var{verbose} is the verbose level provided by -->
     <!-- @option{-fsched-verbose-@var{n}}.  @var{insn} is the instruction that -->
     <!-- was scheduled. -->
      <p>该钩子在调度器从就绪列表中调度了一个insn之后被执行。
其应该返回在当前周期仍然可以被发射的insn数目。
对于<code>CLOBBER</code>和<code>USE</code>之外的insn，缺省为&lsquo;<samp><var>more</var><span class="samp">&nbsp;-&nbsp;1<!-- /@w --></span></samp>&rsquo;，
其通常不根据发射频率来计数。你应该定义该钩子，
如果一些insn比其它的需要更多的机器资源，
使得在同一周期它们后面可以跟随较少的insn。<var>file</var>或者为一个null指针，
或者一个stdio流，用来写入调试输出。
<var>verbose</var>为<samp><span class="option">-fsched-verbose-</span><var>n</var></samp>提供的详细级别。
<var>insn</var>为被调度的指针。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_ADJUST_COST</b> (<var>rtx insn, rtx link, rtx dep_insn, int cost</var>)<var><a name="index-TARGET_005fSCHED_005fADJUST_005fCOST-4368"></a></var><br>
<blockquote><!-- This function corrects the value of @var{cost} based on the -->
     <!-- relationship between @var{insn} and @var{dep_insn} through the -->
     <!-- dependence @var{link}.  It should return the new value.  The default -->
     <!-- is to make no adjustment to @var{cost}.  This can be used for example -->
     <!-- to specify to the scheduler using the traditional pipeline description -->
     <!-- that an output- or anti-dependence does not incur the same cost as a -->
     <!-- data-dependence.  If the scheduler using the automaton based pipeline -->
     <!-- description, the cost of anti-dependence is zero and the cost of -->
     <!-- output-dependence is maximum of one and the difference of latency -->
     <!-- times of the first and the second insns.  If these values are not -->
     <!-- acceptable, you could use the hook to modify them too.  See also -->
     <!-- @pxref{Processor pipeline description}. -->
      <p>该函数根据<var>insn</var>和<var>dep_insn</var>通过依赖链接的关系来更正<var>cost</var>值。
其应该返回新的值。缺省为不对<var>cost</var>进行调整。
例如这可以用于指定调度器使用传统的流水线描述，
即输出或反向依赖不产生与数据依赖相同的代价。
如果调度器使用基于流水线描述的自动机，则反向依赖的代码为0，
输出依赖的代价为1和第一个insn与第二个insn之间的延迟时间的最大值。
如果这些值无法接受，你应该使用该钩子来修改它们。参见<a href="Processor-pipeline-description.html#Processor-pipeline-description">Processor pipeline description</a>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_ADJUST_PRIORITY</b> (<var>rtx insn, int priority</var>)<var><a name="index-TARGET_005fSCHED_005fADJUST_005fPRIORITY-4369"></a></var><br>
<blockquote><!-- This hook adjusts the integer scheduling priority @var{priority} of -->
     <!-- @var{insn}.  It should return the new priority.  Increase the priority to -->
     <!-- execute @var{insn} earlier, reduce the priority to execute @var{insn} -->
     <!-- later.  Do not define this hook if you do not need to adjust the -->
     <!-- scheduling priorities of insns. -->
      <p>该钩子调整<var>insn</var>的整数调度有限级<var>priority</var>。其应该返回新的priority。
增加优先级来提前执行<var>insn</var>，减少优先级来推迟执行<var>insn</var>。
如果不需要调整insn的调度优先级，则不需要定义该钩子。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_REORDER</b> (<var>FILE *file, int verbose, rtx *ready, int *n_readyp, int clock</var>)<var><a name="index-TARGET_005fSCHED_005fREORDER-4370"></a></var><br>
<blockquote><!-- This hook is executed by the scheduler after it has scheduled the ready -->
     <!-- list, to allow the machine description to reorder it (for example to -->
     <!-- combine two small instructions together on @samp{VLIW} machines). -->
     <!-- @var{file} is either a null pointer, or a stdio stream to write any -->
     <!-- debug output to.  @var{verbose} is the verbose level provided by -->
     <!-- @option{-fsched-verbose-@var{n}}.  @var{ready} is a pointer to the ready -->
     <!-- list of instructions that are ready to be scheduled.  @var{n_readyp} is -->
     <!-- a pointer to the number of elements in the ready list.  The scheduler -->
     <!-- reads the ready list in reverse order, starting with -->
     <!-- @var{ready}[@var{*n_readyp} @minus{} 1] and going to @var{ready}[0].  @var{clock} -->
     <!-- is the timer tick of the scheduler.  You may modify the ready list and -->
     <!-- the number of ready insns.  The return value is the number of insns that -->
     <!-- can issue this cycle; normally this is just @code{issue_rate}.  See also -->
     <!-- @samp{TARGET_SCHED_REORDER2}. -->
      <p>该钩子在调度器调度完就绪列表后被执行，
以允许机器描述来重新排序（例如在&lsquo;<samp><span class="samp">VLIW</span></samp>&rsquo;机器上，将两个小指令合并一起）。
<var>file</var>或者为一个null指针，或者一个stdio流，用来写入调试输出。
<var>verbose</var>为<samp><span class="option">-fsched-verbose-</span><var>n</var></samp>提供的详细级别。
<var>ready</var>为指向已经被调度的指令就绪列表的指针。
<var>n_readyp</var>为指向在就绪列表中的元素个数的指针。
调度器按照相反的顺序读取就绪列表，从<var>ready</var>[<var>*n_readyp</var>-1]开始，
到<var>ready</var>[0]。<var>clock</var>为调度器的时钟tick。你可以修改就绪列表和insn。
返回值为这个周期可以发射的insn数；这通常只是为<code>issue_rate</code>。
参见&lsquo;<samp><span class="samp">TARGET_SCHED_REORDER2</span></samp>&rsquo;。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_REORDER2</b> (<var>FILE *file, int verbose, rtx *ready, int *n_readyp, int clock</var>)<var><a name="index-TARGET_005fSCHED_005fREORDER2-4371"></a></var><br>
<blockquote><!-- Like @samp{TARGET_SCHED_REORDER}, but called at a different time.  That -->
     <!-- function is called whenever the scheduler starts a new cycle.  This one -->
     <!-- is called once per iteration over a cycle, immediately after -->
     <!-- @samp{TARGET_SCHED_VARIABLE_ISSUE}; it can reorder the ready list and -->
     <!-- return the number of insns to be scheduled in the same cycle.  Defining -->
     <!-- this hook can be useful if there are frequent situations where -->
     <!-- scheduling one insn causes other insns to become ready in the same -->
     <!-- cycle.  These other insns can then be taken into account properly. -->
      <p>类似于&lsquo;<samp><span class="samp">TARGET_SCHED_REORDER</span></samp>&rsquo;，只不过在不同的时间被调用。
该函数每当调度器开始一个新的周期时被调用。其在每个周期都被调用一次，
紧跟在&lsquo;<samp><span class="samp">TARGET_SCHED_VARIABLE_ISSUE</span></samp>&rsquo;之后；
其可以重排就绪列表并返回在同一周期被调度的insn数目。
如果常常调度一个insn会引起其他insn可以在同一周期就绪，则定义该钩子会很有用。
这样其它insn便可以被适当的考虑进来。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK</b> (<var>rtx head, rtx tail</var>)<var><a name="index-TARGET_005fSCHED_005fDEPENDENCIES_005fEVALUATION_005fHOOK-4372"></a></var><br>
<blockquote><!-- This hook is called after evaluation forward dependencies of insns in -->
     <!-- chain given by two parameter values (@var{head} and @var{tail} -->
     <!-- correspondingly) but before insns scheduling of the insn chain.  For -->
     <!-- example, it can be used for better insn classification if it requires -->
     <!-- analysis of dependencies.  This hook can use backward and forward -->
     <!-- dependencies of the insn scheduler because they are already -->
     <!-- calculated. -->
      <p>该钩子在由两个参数值给出的链中向前评估完insn的依赖关系之后，
但在insn链的调度之前被调用。例如，其可以被用于更好的insn分类，
如果其需要依赖分析。该钩子可以使用insn调度器的向后和向前依赖，
因为它们已经被计算好了。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_INIT</b> (<var>FILE *file, int verbose, int max_ready</var>)<var><a name="index-TARGET_005fSCHED_005fINIT-4373"></a></var><br>
<blockquote><!-- This hook is executed by the scheduler at the beginning of each block of -->
     <!-- instructions that are to be scheduled.  @var{file} is either a null -->
     <!-- pointer, or a stdio stream to write any debug output to.  @var{verbose} -->
     <!-- is the verbose level provided by @option{-fsched-verbose-@var{n}}. -->
     <!-- @var{max_ready} is the maximum number of insns in the current scheduling -->
     <!-- region that can be live at the same time.  This can be used to allocate -->
     <!-- scratch space if it is needed, e.g.@: by @samp{TARGET_SCHED_REORDER}. -->
      <p>该钩子在每个要被调度的指令块的起始处被调用。<var>file</var>或者为一个null指针，
或者一个stdio流，用来写入调试输出。
<var>verbose</var>为<samp><span class="option">-fsched-verbose-</span><var>n</var></samp>提供的详细级别。
<var>max_ready</var>为在当前调度域中可以同时活跃的insn最大数。
这可以用来分配需要的草稿空间，例如，&lsquo;<samp><span class="samp">TARGET_SCHED_REORDER</span></samp>&rsquo;。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FINISH</b> (<var>FILE *file, int verbose</var>)<var><a name="index-TARGET_005fSCHED_005fFINISH-4374"></a></var><br>
<blockquote><!-- This hook is executed by the scheduler at the end of each block of -->
     <!-- instructions that are to be scheduled.  It can be used to perform -->
     <!-- cleanup of any actions done by the other scheduling hooks.  @var{file} -->
     <!-- is either a null pointer, or a stdio stream to write any debug output -->
     <!-- to.  @var{verbose} is the verbose level provided by -->
     <!-- @option{-fsched-verbose-@var{n}}. -->
      <p>该钩子在每个要被调度的指令块的起始处被调用。
其可以用于执行清除由其它调度钩子完成的任何动作。<var>file</var>或者为一个null指针，
或者一个stdio流，用来写入调试输出。
<var>verbose</var>为<samp><span class="option">-fsched-verbose-</span><var>n</var></samp>提供的详细级别。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_INIT_GLOBAL</b> (<var>FILE *file, int verbose, int old_max_uid</var>)<var><a name="index-TARGET_005fSCHED_005fINIT_005fGLOBAL-4375"></a></var><br>
<blockquote><!-- This hook is executed by the scheduler after function level initializations. -->
     <!-- @var{file} is either a null pointer, or a stdio stream to write any debug output to. -->
     <!-- @var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}. -->
     <!-- @var{old_max_uid} is the maximum insn uid when scheduling begins. -->
      <p>该钩子在函数级初始化的时候被调度器执行。<var>file</var>或者为一个null指针，
或者一个stdio流，用来写入调试输出。
<var>verbose</var>为<samp><span class="option">-fsched-verbose-</span><var>n</var></samp>提供的详细级别。
<var>old_max_uid</var>为调度开始时，最大的insn uid。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FINISH_GLOBAL</b> (<var>FILE *file, int verbose</var>)<var><a name="index-TARGET_005fSCHED_005fFINISH_005fGLOBAL-4376"></a></var><br>
<blockquote><!-- This is the cleanup hook corresponding to @code{TARGET_SCHED_INIT_GLOBAL}. -->
     <!-- @var{file} is either a null pointer, or a stdio stream to write any debug output to. -->
     <!-- @var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}. -->
      <p>这是一个清除钩子，对应于<code>TARGET_SCHED_INIT_GLOBAL</code>。
<var>file</var>或者为一个null指针，或者一个stdio流，用来写入调试输出。
<var>verbose</var>为<samp><span class="option">-fsched-verbose-</span><var>n</var></samp>提供的详细级别。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_SCHED_DFA_PRE_CYCLE_INSN</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fDFA_005fPRE_005fCYCLE_005fINSN-4377"></a></var><br>
<blockquote><!-- The hook returns an RTL insn.  The automaton state used in the -->
     <!-- pipeline hazard recognizer is changed as if the insn were scheduled -->
     <!-- when the new simulated processor cycle starts.  Usage of the hook may -->
     <!-- simplify the automaton pipeline description for some @acronym{VLIW} -->
     <!-- processors.  If the hook is defined, it is used only for the automaton -->
     <!-- based pipeline description.  The default is not to change the state -->
     <!-- when the new simulated processor cycle starts. -->
      <p>该钩子返回一个RTL insn。流水线冒险识别器中的自动机状态，
按照当新的模拟处理器周期开始，insn被调度的样子被改变。
该钩子的用法可以简化一些<acronym>VLIW</acronym>处理器的自动机流水线描述。
如果钩子被定义，其只用于基于自动机的流水线描述。缺省为不改变状态，
当新的模拟处理器周期开始时。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fINIT_005fDFA_005fPRE_005fCYCLE_005fINSN-4378"></a></var><br>
<blockquote><!-- The hook can be used to initialize data used by the previous hook. -->
      <p>该钩子可以用于初始化先前的钩子所使用的数据。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_SCHED_DFA_POST_CYCLE_INSN</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fDFA_005fPOST_005fCYCLE_005fINSN-4379"></a></var><br>
<blockquote><!-- The hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used -->
     <!-- to changed the state as if the insn were scheduled when the new -->
     <!-- simulated processor cycle finishes. -->
      <p>该钩子与&lsquo;<samp><span class="samp">TARGET_SCHED_DFA_PRE_CYCLE_INSN</span></samp>&rsquo;类似，但用于改变状态，
按照当新的模拟处理器周期结束时insn被调度的方式。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fINIT_005fDFA_005fPOST_005fCYCLE_005fINSN-4380"></a></var><br>
<blockquote><!-- The hook is analogous to @samp{TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN} but -->
     <!-- used to initialize data used by the previous hook. -->
      <p>该钩子与&lsquo;<samp><span class="samp">TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN</span></samp>&rsquo;类似，
但用于初始化先前的钩子所使用的数据。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fDFA_005fPRE_005fADVANCE_005fCYCLE-4381"></a></var><br>
<blockquote><!-- The hook to notify target that the current simulated cycle is about to finish. -->
     <!-- The hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used -->
     <!-- to change the state in more complicated situations - e.g., when advancing -->
     <!-- state on a single insn is not enough. -->
      <p>该钩子用来通报target，当前模拟周期将要完成。
该钩子类似于&lsquo;<samp><span class="samp">TARGET_SCHED_DFA_PRE_CYCLE_INSN</span></samp>&rsquo;，
但用于在更复杂的情况下改变状态，例如当在一个单独的insn上前移一个状态并不足够时。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_DFA_POST_ADVANCE_CYCLE</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fDFA_005fPOST_005fADVANCE_005fCYCLE-4382"></a></var><br>
<blockquote><!-- The hook to notify target that new simulated cycle has just started. -->
     <!-- The hook is analogous to @samp{TARGET_SCHED_DFA_POST_CYCLE_INSN} but used -->
     <!-- to change the state in more complicated situations - e.g., when advancing -->
     <!-- state on a single insn is not enough. -->
      <p>该钩子用来通报target，新的模拟周期刚刚开始。
该钩子类似于&lsquo;<samp><span class="samp">TARGET_SCHED_DFA_POST_CYCLE_INSN</span></samp>&rsquo;，
但用于在更复杂的情况下改变状态，例如当在一个单独的insn上前移一个状态并不足够时。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fDFA_005fLOOKAHEAD-4383"></a></var><br>
<blockquote><!-- This hook controls better choosing an insn from the ready insn queue -->
     <!-- for the @acronym{DFA}-based insn scheduler.  Usually the scheduler -->
     <!-- chooses the first insn from the queue.  If the hook returns a positive -->
     <!-- value, an additional scheduler code tries all permutations of -->
     <!-- @samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()} -->
     <!-- subsequent ready insns to choose an insn whose issue will result in -->
     <!-- maximal number of issued insns on the same cycle.  For the -->
     <!-- @acronym{VLIW} processor, the code could actually solve the problem of -->
     <!-- packing simple insns into the @acronym{VLIW} insn.  Of course, if the -->
     <!-- rules of @acronym{VLIW} packing are described in the automaton. -->
      <p>对于基于<acronym>DFA</acronym>的insn调度器，该钩子可以用来控制从insn就绪队列中，更好的选择一个insn。通常，调度器是从队列中选择第一个insn。但是，如果该钩子返回一个正值，则会有额外的调度器代码来尝试&lsquo;<samp><span class="samp">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()</span></samp>&rsquo;的所有排列组合，来选择一个insn，使得发射该insn将在同一周期产生最大的insn发射数。对于<acronym>VLIW</acronym>处理器，该代码实际上能够解决将简单insn打包成<acronym>VLIW</acronym> insn的问题。当然，<acronym>VLIW</acronym>打包规则需要在自动机中有描述。

     <!-- This code also could be used for superscalar @acronym{RISC} -->
     <!-- processors.  Let us consider a superscalar @acronym{RISC} processor -->
     <!-- with 3 pipelines.  Some insns can be executed in pipelines @var{A} or -->
     <!-- @var{B}, some insns can be executed only in pipelines @var{B} or -->
     <!-- @var{C}, and one insn can be executed in pipeline @var{B}.  The -->
     <!-- processor may issue the 1st insn into @var{A} and the 2nd one into -->
     <!-- @var{B}.  In this case, the 3rd insn will wait for freeing @var{B} -->
     <!-- until the next cycle.  If the scheduler issues the 3rd insn the first, -->
     <!-- the processor could issue all 3 insns per cycle. -->
      <p>该代码还能用于超标量<acronym>RISC</acronym>处理器。让我们考虑一个具有3级流水线的超标量<acronym>RISC</acronym>处理器。一些insn可以在流水线<var>A</var>或<var>B</var>中被执行，一些insn只能在流水线<var>B</var>或<var>C</var>中执行，并且有一个insn可以在流水线<var>B</var>中被执行。处理器可以发射第一个insn到<var>A</var>，第二个到<var>B</var>。这种情况下，第三个insn将会等待释放<var>B</var>，直到下一个周期。如果调度器先发射第三个insn，则处理器可以一个周期发射所有的3个insn。

     <!-- Actually this code demonstrates advantages of the automaton based -->
     <!-- pipeline hazard recognizer.  We try quickly and easy many insn -->
     <!-- schedules to choose the best one. -->
      <p>实际上该代码证明了基于自动机的流水线冒险识别器的优点。我们最快且最容易的尝试许多种insn调度，并选择最好的一种。

     <!-- The default is no multipass scheduling. -->
      <p>缺省为不进行多遍指令调度。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD</b> (<var>rtx insn</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fDFA_005fLOOKAHEAD_005fGUARD-4384"></a></var><br>
<blockquote><!-- This hook controls what insns from the ready insn queue will be -->
     <!-- considered for the multipass insn scheduling.  If the hook returns -->
     <!-- zero for @var{insn}, the insn will be not chosen to -->
     <!-- be issued. -->
      <p>该钩子控制了对于多遍insn调度，就绪insn队列中的什么样的insn将被考虑。
如果钩子返回0，对于最为参数传递的insn，则insn将不被选择发射。

     <!-- The default is that any ready insns can be chosen to be issued. -->
      <p>缺省为所有的就绪insn都可以被选择发射。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN</b> (<var>void *data, char *ready_try, int n_ready, bool first_cycle_insn_p</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fBEGIN-4385"></a></var><br>
<blockquote><p>This hook prepares the target backend for a new round of multipass
scheduling. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE</b> (<var>void *data, char *ready_try, int n_ready, rtx insn, const void *prev_data</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fISSUE-4386"></a></var><br>
<blockquote><p>This hook is called when multipass scheduling evaluates instruction INSN. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK</b> (<var>const void *data, char *ready_try, int n_ready</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fBACKTRACK-4387"></a></var><br>
<blockquote><p>This is called when multipass scheduling backtracks from evaluation of
an instruction. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END</b> (<var>const void *data</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fEND-4388"></a></var><br>
<blockquote><p>This hook notifies the target about the result of the concluded current
round of multipass scheduling. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT</b> (<var>void *data</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fINIT-4389"></a></var><br>
<blockquote><p>This hook initializes target-specific data used in multipass scheduling. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI</b> (<var>void *data</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fFINI-4390"></a></var><br>
<blockquote><p>This hook finalizes target-specific data used in multipass scheduling. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_DFA_NEW_CYCLE</b> (<var>FILE *dump, int verbose, rtx insn, int last_clock, int clock, int *sort_p</var>)<var><a name="index-TARGET_005fSCHED_005fDFA_005fNEW_005fCYCLE-4391"></a></var><br>
<blockquote><!-- This hook is called by the insn scheduler before issuing @var{insn} -->
     <!-- on cycle @var{clock}.  If the hook returns nonzero, -->
     <!-- @var{insn} is not issued on this processor cycle.  Instead, -->
     <!-- the processor cycle is advanced.  If *@var{sort_p} -->
     <!-- is zero, the insn ready queue is not sorted on the new cycle -->
     <!-- start as usually.  @var{dump} and @var{verbose} specify the file and -->
     <!-- verbosity level to use for debugging output. -->
     <!-- @var{last_clock} and @var{clock} are, respectively, the -->
     <!-- processor cycle on which the previous insn has been issued, -->
     <!-- and the current processor cycle. -->
      <p>该钩子在给定的周期，在发射作为第三个参数传递的insn之前被insn调度器调用。
如果钩子返回非零，则insn在给定的处理器周期将不被发射。替代的，
处理器周期将前移。如果最后一个参数的值为0，
则insn就绪队列没有在新的周期开始时按照通常的方式被排序。
第一个参数传递了调试输出的文件。第二个参数传递了调试输出的详细级别。
第四个和第五个参数值分别对应于之前insn被发射的处理器周期，以及当前处理器周期。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SCHED_IS_COSTLY_DEPENDENCE</b> (<var>struct _dep *_dep, int cost, int distance</var>)<var><a name="index-TARGET_005fSCHED_005fIS_005fCOSTLY_005fDEPENDENCE-4392"></a></var><br>
<blockquote><!-- This hook is used to define which dependences are considered costly by -->
     <!-- the target, so costly that it is not advisable to schedule the insns that -->
     <!-- are involved in the dependence too close to one another.  The parameters -->
     <!-- to this hook are as follows:  The first parameter @var{_dep} is the dependence -->
     <!-- being evaluated.  The second parameter @var{cost} is the cost of the -->
     <!-- dependence as estimated by the scheduler, and the third -->
     <!-- parameter @var{distance} is the distance in cycles between the two insns. -->
     <!-- The hook returns @code{true} if considering the distance between the two -->
     <!-- insns the dependence between them is considered costly by the target, -->
     <!-- and @code{false} otherwise. -->
      <p>该钩子用于定义哪种依赖被target认为是具有昂贵代价的，
以至于将insn调度成依赖太近是不明智的。参数为：
第一个参数<var>_dep</var>为被评估的依赖。第二个参数<var>cost</var>为依赖的代价，
第三个参数<var>distance</var>为两个insn的周期距离。钩子返回<code>true</code>，
如果考虑两个insn间的距离，它们间的依赖被 target认为是昂贵的，
否则为<code>false</code>。

     <!-- Defining this hook can be useful in multiple-issue out-of-order machines, -->
     <!-- where (a) it's practically hopeless to predict the actual data/resource -->
     <!-- delays, however: (b) there's a better chance to predict the actual grouping -->
     <!-- that will be formed, and (c) correctly emulating the grouping can be very -->
     <!-- important.  In such targets one may want to allow issuing dependent insns -->
     <!-- closer to one another-i.e., closer than the dependence distance;  however, -->
     <!-- not in cases of ``costly dependences'', which this hooks allows to define. -->
      <p>在多发射，乱序机器上，定义该钩子可以有用，
（a）实际中是无法预测真实的数据/资源延迟，
但是（b）有一个更好的机会来预测实际要被执行的组，
并且（c）正确模拟分组会非常重要。在这样的target上，
可能想要允许发射距离较近的依赖insn，即，比依赖距离近；
但是对于“昂贵的依赖”不这样做，这样就可以定义该钩子。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_H_I_D_EXTENDED</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fH_005fI_005fD_005fEXTENDED-4393"></a></var><br>
<blockquote><!-- This hook is called by the insn scheduler after emitting a new instruction to -->
     <!-- the instruction stream.  The hook notifies a target backend to extend its -->
     <!-- per instruction data structures. -->
      <p>该钩子在输出一个新的指令到指令流之后被insn调度器调用。
钩子通知target后端来延伸它的每个指令的数据结构。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void * <b>TARGET_SCHED_ALLOC_SCHED_CONTEXT</b> (<var>void</var>)<var><a name="index-TARGET_005fSCHED_005fALLOC_005fSCHED_005fCONTEXT-4394"></a></var><br>
<blockquote><p>Return a pointer to a store large enough to hold target scheduling context. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_INIT_SCHED_CONTEXT</b> (<var>void *tc, bool clean_p</var>)<var><a name="index-TARGET_005fSCHED_005fINIT_005fSCHED_005fCONTEXT-4395"></a></var><br>
<blockquote><p>Initialize store pointed to by <var>tc</var> to hold target scheduling context. 
It <var>clean_p</var> is true then initialize <var>tc</var> as if scheduler is at the
beginning of the block.  Otherwise, copy the current context into <var>tc</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_SET_SCHED_CONTEXT</b> (<var>void *tc</var>)<var><a name="index-TARGET_005fSCHED_005fSET_005fSCHED_005fCONTEXT-4396"></a></var><br>
<blockquote><p>Copy target scheduling context pointed to by <var>tc</var> to the current context. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_CLEAR_SCHED_CONTEXT</b> (<var>void *tc</var>)<var><a name="index-TARGET_005fSCHED_005fCLEAR_005fSCHED_005fCONTEXT-4397"></a></var><br>
<blockquote><p>Deallocate internal data in target scheduling context pointed to by <var>tc</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_FREE_SCHED_CONTEXT</b> (<var>void *tc</var>)<var><a name="index-TARGET_005fSCHED_005fFREE_005fSCHED_005fCONTEXT-4398"></a></var><br>
<blockquote><p>Deallocate a store for target scheduling context pointed to by <var>tc</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_SPECULATE_INSN</b> (<var>rtx insn, int request, rtx *new_pat</var>)<var><a name="index-TARGET_005fSCHED_005fSPECULATE_005fINSN-4399"></a></var><br>
<blockquote><!-- This hook is called by the insn scheduler when @var{insn} has only -->
     <!-- speculative dependencies and therefore can be scheduled speculatively. -->
     <!-- The hook is used to check if the pattern of @var{insn} has a speculative -->
     <!-- version and, in case of successful check, to generate that speculative -->
     <!-- pattern.  The hook should return 1, if the instruction has a speculative form, -->
     <!-- or @minus{}1, if it doesn't.  @var{request} describes the type of requested -->
     <!-- speculation.  If the return value equals 1 then @var{new_pat} is assigned -->
     <!-- the generated speculative pattern. -->
      <p>该钩子当<var>insn</var>只有投机依赖，并因此可以被投机的调度时，被调用。
钩子用于检查<var>insn</var>的指令模式是否具有一个投机版本，并且如果检查成功，
则生成那个投机模式。钩子应该返回1，如果具有投机形式，或者-1，如果不具有。
<var>request</var>描述了请求投机的类型。如果返回值等于1，
则<var>new_pat</var>被赋值为生成的投机指令模式。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SCHED_NEEDS_BLOCK_P</b> (<var>int dep_status</var>)<var><a name="index-TARGET_005fSCHED_005fNEEDS_005fBLOCK_005fP-4400"></a></var><br>
<blockquote><!-- This hook is called by the insn scheduler during generation of recovery code -->
     <!-- for @var{insn}.  It should return @code{true}, if the corresponding check -->
     <!-- instruction should branch to recovery code, or @code{false} otherwise. -->
      <p>该钩子在为<var>insn</var>生成恢复代码时，被insn调度器调用。其应该返回<code>true</code>，
如果相应的检查指令应该分支跳转到回复代码，否则为<code>false</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_SCHED_GEN_SPEC_CHECK</b> (<var>rtx insn, rtx label, int mutate_p</var>)<var><a name="index-TARGET_005fSCHED_005fGEN_005fSPEC_005fCHECK-4401"></a></var><br>
<blockquote><!-- This hook is called by the insn scheduler to generate a pattern for recovery -->
     <!-- check instruction.  If @var{mutate_p} is zero, then @var{insn} is a -->
     <!-- speculative instruction for which the check should be generated. -->
     <!-- @var{label} is either a label of a basic block, where recovery code should -->
     <!-- be emitted, or a null pointer, when requested check doesn't branch to -->
     <!-- recovery code (a simple check).  If @var{mutate_p} is nonzero, then -->
     <!-- a pattern for a branchy check corresponding to a simple check denoted by -->
     <!-- @var{insn} should be generated.  In this case @var{label} can't be null. -->
      <p>该钩子被insn调度器调用，来为恢复检查指令产生一个指令模式。
如果<var>mutate_p</var>为0，则<var>insn</var>为一个投机指令，对此应该生成检查。
<var>label</var>或者为一个基本快的标号，恢复代码应该被生成的地方，
或者为一个null指针，当请求的检查没有分支到恢复代码（简单的检查）。
如果<var>mutate_p</var>为非 0，
则由<var>insn</var>注解的对应于一个简单检查的指令模式应该被生成。
这种情况下，<var>label</var>不能为null。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC</b> (<var>const_rtx insn</var>)<var><a name="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fDFA_005fLOOKAHEAD_005fGUARD_005fSPEC-4402"></a></var><br>
<blockquote><!-- This hook is used as a workaround for -->
     <!-- @samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD} not being -->
     <!-- called on the first instruction of the ready list.  The hook is used to -->
     <!-- discard speculative instructions that stand first in the ready list from -->
     <!-- being scheduled on the current cycle.  If the hook returns @code{false}, -->
     <!-- @var{insn} will not be chosen to be issued. -->
     <!-- For non-speculative instructions, -->
     <!-- the hook should always return @code{true}.  For example, in the ia64 backend -->
     <!-- the hook is used to cancel data speculative insns when the ALAT table -->
     <!-- is nearly full. -->
      <p>该钩子用于在就绪列表中第一个指令上没有调用&lsquo;<samp><span class="samp">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD</span></samp>&rsquo;的情况。
钩子用于丢弃从当前周期调度的起始于就绪列表的投机指令。对于非投机指令，
钩子应该总是返回非零。例如，在ia64后端，钩子用于取消数据投机insn，
当ALAT表将满时。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_SET_SCHED_FLAGS</b> (<var>struct spec_info_def *spec_info</var>)<var><a name="index-TARGET_005fSCHED_005fSET_005fSCHED_005fFLAGS-4403"></a></var><br>
<blockquote><!-- This hook is used by the insn scheduler to find out what features should be -->
     <!-- enabled/used. -->
     <!-- The structure *@var{spec_info} should be filled in by the target. -->
     <!-- The structure describes speculation types that can be used in the scheduler. -->
      <p>该钩子被insn调度器用于查找什么特点应该被启用。结构体<var>spec_info</var>应该由target来填充。该结构体描述了调度器中可以使用的投机类型。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_SMS_RES_MII</b> (<var>struct ddg *g</var>)<var><a name="index-TARGET_005fSCHED_005fSMS_005fRES_005fMII-4404"></a></var><br>
<blockquote><!-- This hook is called by the swing modulo scheduler to calculate a -->
     <!-- resource-based lower bound which is based on the resources available in -->
     <!-- the machine and the resources required by each instruction.  The target -->
     <!-- backend can use @var{g} to calculate such bound.  A very simple lower -->
     <!-- bound will be used in case this hook is not implemented: the total number -->
     <!-- of instructions divided by the issue rate. -->
      <p>该钩子被swing modulo调度器调用，来计算基于资源的下界，
其基于在机器上可用的资源以及每个指令要求的资源。
target后端可以使用<var>g</var>来计算这个边界。如果没有实现该钩子，
则会使用一个非常简单的下界：指令总数除以发射率。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SCHED_DISPATCH</b> (<var>rtx insn, int x</var>)<var><a name="index-TARGET_005fSCHED_005fDISPATCH-4405"></a></var><br>
<blockquote><p>This hook is called by Haifa Scheduler.  It returns true if dispatch scheduling
is supported in hardware and the condition specified in the parameter is true. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SCHED_DISPATCH_DO</b> (<var>rtx insn, int x</var>)<var><a name="index-TARGET_005fSCHED_005fDISPATCH_005fDO-4406"></a></var><br>
<blockquote><p>This hook is called by Haifa Scheduler.  It performs the operation specified
in its second parameter. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SCHED_EXPOSED_PIPELINE</b><var><a name="index-TARGET_005fSCHED_005fEXPOSED_005fPIPELINE-4407"></a></var><br>
<blockquote><p>True if the processor has an exposed pipeline, which means that not just
the order of instructions is important for correctness when scheduling, but
also the latencies of operations. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_SCHED_REASSOCIATION_WIDTH</b> (<var>unsigned int opc, enum machine_mode mode</var>)<var><a name="index-TARGET_005fSCHED_005fREASSOCIATION_005fWIDTH-4408"></a></var><br>
<blockquote><p>This hook is called by tree reassociator to determine a level of
parallelism required in output calculations chain. 
</p></blockquote></div>

<!-- @node Sections -->
<!-- @section Dividing the Output into Sections (Texts, Data, @dots{}) -->
 </body></html>

