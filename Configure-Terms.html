<html lang="zh">
<head>
<title>Configure Terms - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Source-Tree.html#Source-Tree" title="Source Tree">
<link rel="next" href="Top-Level.html#Top-Level" title="Top Level">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Configure-Terms"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Top-Level.html#Top-Level">Top Level</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Source-Tree.html#Source-Tree">Source Tree</a>
<hr>
</div>

<h3 class="section">6.1 配置术语和历史</h3>

<p><a name="index-configure-terms-1662"></a><a name="index-canadian-1663"></a>
<!-- The configure and build process has a long and colorful history, and can -->
<!-- be confusing to anyone who doesn't know why things are the way they are. -->
<!-- While there are other documents which describe the configuration process -->
<!-- in detail, here are a few things that everyone working on GCC should -->
<!-- know. -->
配置和构建过程有着悠久灿烂的历史，如果不清楚其缘由，很容易使人迷惑不解。
虽然有另外的文献详细描述了配置过程，这里还是给出了一些从事GCC工作都应该
了解的内容。

<!-- There are three system names that the build knows about: the machine you -->
<!-- are building on (@dfn{build}), the machine that you are building for -->
<!-- (@dfn{host}), and the machine that GCC will produce code for -->
<!-- (@dfn{target}).  When you configure GCC, you specify these with -->
<!-- @option{-build=}, @option{-host=}, and @option{-target=}. -->
 <p>构建程序要知道三个系统名称：构建时所使用的机器（<dfn>build</dfn>），构建完成
后将使用的机器（<dfn>host</dfn>），以及GCC未来生成代码所要运行的机器（<dfn>target</dfn>）。
在配置GCC时，通过 <samp><span class="option">--build=</span></samp>, <samp><span class="option">--host=</span></samp>, <samp><span class="option">--target=</span></samp>
来指定这些系统名称。

<!-- Specifying the host without specifying the build should be avoided, as -->
<!-- @command{configure} may (and once did) assume that the host you specify -->
<!-- is also the build, which may not be true. -->
 <p>要避免只指定host而不指定build，因为 <samp><span class="command">configure</span></samp> 程序可能会认为
你所指定的host和build相同（曾经发生过），而实际上可能并非如此。

<!-- If build, host, and target are all the same, this is called a -->
<!-- @dfn{native}.  If build and host are the same but target is different, -->
<!-- this is called a @dfn{cross}.  If build, host, and target are all -->
<!-- different this is called a @dfn{canadian} (for obscure reasons dealing -->
<!-- with Canada's political party and the background of the person working -->
<!-- on the build at that time).  If host and target are the same, but build -->
<!-- is different, you are using a cross-compiler to build a native for a -->
<!-- different system.  Some people call this a @dfn{host-x-host}, -->
<!-- @dfn{crossed native}, or @dfn{cross-built native}.  If build and target -->
<!-- are the same, but host is different, you are using a cross compiler to -->
<!-- build a cross compiler that produces code for the machine you're -->
<!-- building on.  This is rare, so there is no common way of describing it. -->
<!-- There is a proposal to call this a @dfn{crossback}. -->
 <p>我们把build, host和target都相同的情况叫做 <dfn>native</dfn>（本地的）。如果
build和host相同，但target不同，就叫做 <dfn>cross</dfn>（交叉的）。 build,
host和target都不同的情况则被称为 <dfn>canadian</dfn> （加拿大的——用来暗指加
拿大政党状况与当时从事构建工作的人的背景类似）。如果host和 target相同，
但build不同，则表明你在使用交叉编译器来为一个不同的系统构建本地编译器。
有些人把这称为 <dfn>host-x-host</dfn>，<dfn>crossed native</dfn>（交叉的本地的），
或 <dfn>cross-built native</dfn>(交叉构建的本地的）。如果build和target相同，
但host不同，则表明你在使用交叉编译器来构建一个产生构建时所在机器代码的
交叉编译器。这种情况很少见，所以没有通用的方式来描述它。有人建议称之为
<dfn>crossback</dfn>。

<!-- If build and host are the same, the GCC you are building will also be -->
<!-- used to build the target libraries (like @code{libstdc++}).  If build and host -->
<!-- are different, you must have already built and installed a cross -->
<!-- compiler that will be used to build the target libraries (if you -->
<!-- configured with @option{-target=foo-bar}, this compiler will be called -->
<!-- @command{foo-bar-gcc}). -->
 <p>如果build和host相同，则正要构建的GCC还会被用于构建目标库（比如
<code>libstdc++</code>）。如果build和host不同，那么必须事先构建和安装一个交叉
编译器，用于构建目标库（如果使用的配置为 <samp><span class="option">--target=foo-bar</span></samp>，这个
编译器就叫做 <samp><span class="command">foo-bar-gcc</span></samp>）。

<!-- In the case of target libraries, the machine you're building for is the -->
<!-- machine you specified with @option{-target}.  So, build is the machine -->
<!-- you're building on (no change there), host is the machine you're -->
<!-- building for (the target libraries are built for the target, so host is -->
<!-- the target you specified), and target doesn't apply (because you're not -->
<!-- building a compiler, you're building libraries).  The configure/make -->
<!-- process will adjust these variables as needed.  It also sets -->
<!-- @code{$with_cross_host} to the original @option{-host} value in case you -->
<!-- need it. -->
 <p>对于目标库的情况，你所构建的目标机器就是通过 <samp><span class="option">--target</span></samp> 指定的
机器。所以，build就是在上面进行构建的机器（这没有什么不同），host就是
为其构建的机器（目标库是为target构建的，所以host也就是所指定的target），
同时无需使用target（因为不是在构建编译器，而是在构建库）。configure/make
过程会在必要时调整这些变量。它还会把 <code>$with_cross_host</code> 设置成
<samp><span class="option">--host</span></samp> 的初始值，以供不时之需。

<!-- The @code{libiberty} support library is built up to three times: once -->
<!-- for the host, once for the target (even if they are the same), and once -->
<!-- for the build if build and host are different.  This allows it to be -->
<!-- used by all programs which are generated in the course of the build -->
<!-- process. -->
 <p>支持库 <code>libiberty</code> 最多会被构建三次：一次针对host，一次针对target
（即使二者相同），如果build和host不同，还会针对build再构建一次。这样支
持库libiberty就可以被构建过程中生成的所有程序使用了。

<!-- @node Top Level -->
<!-- @section Top Level Source Directory -->
 </body></html>

