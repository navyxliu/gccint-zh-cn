<html lang="zh">
<head>
<title>Type Layout - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Storage-Layout.html#Storage-Layout" title="Storage Layout">
<link rel="next" href="Registers.html#Registers" title="Registers">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Type-Layout"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Registers.html#Registers">Registers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Storage-Layout.html#Storage-Layout">Storage Layout</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.6 源语言的数据类型布局</h3>

<!-- These macros define the sizes and other characteristics of the standard -->
<!-- basic data types used in programs being compiled.  Unlike the macros in -->
<!-- the previous section, these apply to specific features of C and related -->
<!-- languages, rather than to fundamental aspects of storage layout. -->
<p>这些宏定义了在被编译的程序中使用的标准基础数据类型的大小和其它特征。不像前一章节中的宏，这些是应用到C和相关语言上的特定特征，而不是存储布局的基础方面。

<div class="defun">
&mdash; Macro: <b>INT_TYPE_SIZE</b><var><a name="index-INT_005fTYPE_005fSIZE-3877"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{int} on the -->
     <!-- target machine.  If you don't define this, the default is one word. -->
      <p>一个C表达式，为目标机器上类型<code>int</code>的位大小。如果没有定义，缺省为一个字。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SHORT_TYPE_SIZE</b><var><a name="index-SHORT_005fTYPE_005fSIZE-3878"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{short} on the -->
     <!-- target machine.  If you don't define this, the default is half a word. -->
     <!-- (If this would be less than one storage unit, it is rounded up to one -->
     <!-- unit.) -->
      <p>一个C表达式，为目标机器上类型<code>short</code>的位大小。如果没有定义，缺省为半个字。（如果比一个存储单元小，则会向上舍入为一个单元。）
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LONG_TYPE_SIZE</b><var><a name="index-LONG_005fTYPE_005fSIZE-3879"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{long} on the -->
     <!-- target machine.  If you don't define this, the default is one word. -->
      <p>一个C表达式，为目标机器上类型<code>long</code>的位大小。如果没有定义，缺省为一个字。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ADA_LONG_TYPE_SIZE</b><var><a name="index-ADA_005fLONG_005fTYPE_005fSIZE-3880"></a></var><br>
<blockquote><!-- On some machines, the size used for the Ada equivalent of the type -->
     <!-- @code{long} by a native Ada compiler differs from that used by C@.  In -->
     <!-- that situation, define this macro to be a C expression to be used for -->
     <!-- the size of that type.  If you don't define this, the default is the -->
     <!-- value of @code{LONG_TYPE_SIZE}. -->
      <p>在一些机器上，本地Ada编译器使用的类型<code>long</code>的大小与C使用的不相同。这种情况下，定义该宏为一个C表达式用于那个类型的大小。如果没有定义，则缺省为<code>LONG_TYPE_SIZE</code>的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LONG_LONG_TYPE_SIZE</b><var><a name="index-LONG_005fLONG_005fTYPE_005fSIZE-3881"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{long long} on the -->
     <!-- target machine.  If you don't define this, the default is two -->
     <!-- words.  If you want to support GNU Ada on your machine, the value of this -->
     <!-- macro must be at least 64. -->
      <p>一个C表达式，为目标机器上类型<code>long long</code>的位大小。如果没有定义，缺省为两个字。如果你想在你的机器上支持GNU Ada，则该宏的值最少必须为64。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CHAR_TYPE_SIZE</b><var><a name="index-CHAR_005fTYPE_005fSIZE-3882"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{char} on the -->
     <!-- target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT}. -->
      <p>一个C表达式，为目标机器上类型<code>char</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BOOL_TYPE_SIZE</b><var><a name="index-BOOL_005fTYPE_005fSIZE-3883"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the C++ type @code{bool} and -->
     <!-- C99 type @code{_Bool} on the target machine.  If you don't define -->
     <!-- this, and you probably shouldn't, the default is @code{CHAR_TYPE_SIZE}. -->
      <p>一个C表达式，为目标机器上C++类型<code>bool</code>和C99类型<code>_Bool</code>的位大小。如果没有定义，并且通常不会定义，缺省为<code>CHAR_TYPE_SIZE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FLOAT_TYPE_SIZE</b><var><a name="index-FLOAT_005fTYPE_005fSIZE-3884"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{float} on the -->
     <!-- target machine.  If you don't define this, the default is one word. -->
      <p>一个C表达式，为目标机器上类型<code>float</code>的位大小。如果没有定义，缺省为一个字。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DOUBLE_TYPE_SIZE</b><var><a name="index-DOUBLE_005fTYPE_005fSIZE-3885"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{double} on the -->
     <!-- target machine.  If you don't define this, the default is two -->
     <!-- words. -->
      <p>一个C表达式，为目标机器上类型<code>double</code>的位大小。如果没有定义，缺省为两个字。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LONG_DOUBLE_TYPE_SIZE</b><var><a name="index-LONG_005fDOUBLE_005fTYPE_005fSIZE-3886"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{long double} on -->
     <!-- the target machine.  If you don't define this, the default is two -->
     <!-- words. -->
      <p>一个C表达式，为目标机器上类型<code>long double</code>的位大小。如果没有定义，缺省为两个字。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SHORT_FRACT_TYPE_SIZE</b><var><a name="index-SHORT_005fFRACT_005fTYPE_005fSIZE-3887"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{short _Fract} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT}. -->
      <p>一个C表达式，为目标机器上类型<code>short _Fract</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FRACT_TYPE_SIZE</b><var><a name="index-FRACT_005fTYPE_005fSIZE-3888"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{_Fract} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT * 2}. -->
      <p>一个C表达式，为目标机器上类型<code>_Fract</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT * 2</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LONG_FRACT_TYPE_SIZE</b><var><a name="index-LONG_005fFRACT_005fTYPE_005fSIZE-3889"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{long _Fract} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT * 4}. -->
      <p>一个C表达式，为目标机器上类型<code>long _Fract</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT * 4</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LONG_LONG_FRACT_TYPE_SIZE</b><var><a name="index-LONG_005fLONG_005fFRACT_005fTYPE_005fSIZE-3890"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{long long _Fract} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT * 8}. -->
      <p>一个C表达式，为目标机器上类型<code>long long _Fract</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT * 8</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SHORT_ACCUM_TYPE_SIZE</b><var><a name="index-SHORT_005fACCUM_005fTYPE_005fSIZE-3891"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{short _Accum} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT * 2}. -->
      <p>一个C表达式，为目标机器上类型<code>short _Accum</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT * 2</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ACCUM_TYPE_SIZE</b><var><a name="index-ACCUM_005fTYPE_005fSIZE-3892"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{_Accum} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT * 4}. -->
      <p>一个C表达式，为目标机器上类型<code>_Accum</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT * 4</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LONG_ACCUM_TYPE_SIZE</b><var><a name="index-LONG_005fACCUM_005fTYPE_005fSIZE-3893"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{long _Accum} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT * 8}. -->
      <p>一个C表达式，为目标机器上类型<code>long _Accum</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT * 8</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LONG_LONG_ACCUM_TYPE_SIZE</b><var><a name="index-LONG_005fLONG_005fACCUM_005fTYPE_005fSIZE-3894"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the type @code{long long _Accum} on -->
     <!-- the target machine.  If you don't define this, the default is -->
     <!-- @code{BITS_PER_UNIT * 16}. -->
      <p>一个C表达式，为目标机器上类型<code>long long _Accum</code>的位大小。如果没有定义，缺省为<code>BITS_PER_UNIT * 16</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</b><var><a name="index-LIBGCC2_005fLONG_005fDOUBLE_005fTYPE_005fSIZE-3895"></a></var><br>
<blockquote><!-- Define this macro if @code{LONG_DOUBLE_TYPE_SIZE} is not constant or -->
     <!-- if you want routines in @file{libgcc2.a} for a size other than -->
     <!-- @code{LONG_DOUBLE_TYPE_SIZE}.  If you don't define this, the -->
     <!-- default is @code{LONG_DOUBLE_TYPE_SIZE}. -->
      <p>定义该宏，如果<code>LONG_DOUBLE_TYPE_SIZE</code>不是常量或者如果你想让<samp><span class="file">libgcc2.a</span></samp>中具有大小不是<code>LONG_DOUBLE_TYPE_SIZE</code>的程序。如果没有定义，缺省为<code>LONG_DOUBLE_TYPE_SIZE</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_HAS_DF_MODE</b><var><a name="index-LIBGCC2_005fHAS_005fDF_005fMODE-3896"></a></var><br>
<blockquote><!-- Define this macro if neither @code{DOUBLE_TYPE_SIZE} nor -->
     <!-- @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is -->
     <!-- @code{DFmode} but you want @code{DFmode} routines in @file{libgcc2.a} -->
     <!-- anyway.  If you don't define this and either @code{DOUBLE_TYPE_SIZE} -->
     <!-- or @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is 64 then the default is 1, -->
     <!-- otherwise it is 0. -->
      <p>定义该宏，如果<code>DOUBLE_TYPE_SIZE</code>和<code>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</code>都不是<code>DFmode</code>，但是你还想让<samp><span class="file">libgcc2.a</span></samp>中具有<code>DFmode</code>的程序。如果没有定义，并且<code>DOUBLE_TYPE_SIZE</code>或<code>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</code>为64，则缺省为1，否则为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_HAS_XF_MODE</b><var><a name="index-LIBGCC2_005fHAS_005fXF_005fMODE-3897"></a></var><br>
<blockquote><!-- Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not -->
     <!-- @code{XFmode} but you want @code{XFmode} routines in @file{libgcc2.a} -->
     <!-- anyway.  If you don't define this and @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} -->
     <!-- is 80 then the default is 1, otherwise it is 0. -->
      <p>定义该宏，如果<code>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</code>不是<code>XFmode</code>，但是你还想让<samp><span class="file">libgcc2.a</span></samp>中具有<code>XFmode</code>的程序。如果没有定义，并且<code>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</code>为80，则缺省为1，否则为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_HAS_TF_MODE</b><var><a name="index-LIBGCC2_005fHAS_005fTF_005fMODE-3898"></a></var><br>
<blockquote><!-- Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not -->
     <!-- @code{TFmode} but you want @code{TFmode} routines in @file{libgcc2.a} -->
     <!-- anyway.  If you don't define this and @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} -->
     <!-- is 128 then the default is 1, otherwise it is 0. -->
      <p>定义该宏，如果<code>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</code>不是<code>TFmode</code>，但是你还想让<samp><span class="file">libgcc2.a</span></samp>中具有<code>TFmode</code>的程序。如果没有定义，并且<code>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</code>为128，则缺省为1，否则为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_GNU_PREFIX</b><var><a name="index-LIBGCC2_005fGNU_005fPREFIX-3899"></a></var><br>
<blockquote><p>This macro corresponds to the <code>TARGET_LIBFUNC_GNU_PREFIX</code> target
hook and should be defined if that hook is overriden to be true.  It
causes function names in libgcc to be changed to use a <code>__gnu_</code>
prefix for their name rather than the default <code>__</code>.  A port which
uses this macro should also arrange to use <samp><span class="file">t-gnu-prefix</span></samp> in
the libgcc <samp><span class="file">config.host</span></samp>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SF_SIZE</b><var><a name="index-SF_005fSIZE-3900"></a></var><br>
&mdash; Macro: <b>DF_SIZE</b><var><a name="index-DF_005fSIZE-3901"></a></var><br>
&mdash; Macro: <b>XF_SIZE</b><var><a name="index-XF_005fSIZE-3902"></a></var><br>
&mdash; Macro: <b>TF_SIZE</b><var><a name="index-TF_005fSIZE-3903"></a></var><br>
<blockquote><!-- Define these macros to be the size in bits of the mantissa of -->
     <!-- @code{SFmode}, @code{DFmode}, @code{XFmode} and @code{TFmode} values, -->
     <!-- if the defaults in @file{libgcc2.h} are inappropriate.  By default, -->
     <!-- @code{FLT_MANT_DIG} is used for @code{SF_SIZE}, @code{LDBL_MANT_DIG} -->
     <!-- for @code{XF_SIZE} and @code{TF_SIZE}, and @code{DBL_MANT_DIG} or -->
     <!-- @code{LDBL_MANT_DIG} for @code{DF_SIZE} according to whether -->
     <!-- @code{DOUBLE_TYPE_SIZE} or -->
     <!-- @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is 64. -->
      <p>定义这些宏为<code>SFmode</code>, <code>DFmode</code>, <code>XFmode</code>和<code>TFmode</code>值的尾数位大小，如果在<samp><span class="file">libgcc2.h</span></samp>中的缺省定义不合适。缺省的，<code>FLT_MANT_DIG</code>用于<code>SF_SIZE</code>, <code>LDBL_MANT_DIG</code>用于<code>XF_SIZE</code>和<code>TF_SIZE</code>，并且<code>DBL_MANT_DIG</code>或<code>LDBL_MANT_DIG</code>用于<code>DF_SIZE</code>，根据<code>DOUBLE_TYPE_SIZE</code>或<code>LIBGCC2_LONG_DOUBLE_TYPE_SIZE</code>是否为64。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_FLT_EVAL_METHOD</b><var><a name="index-TARGET_005fFLT_005fEVAL_005fMETHOD-3904"></a></var><br>
<blockquote><!-- A C expression for the value for @code{FLT_EVAL_METHOD} in @file{float.h}, -->
     <!-- assuming, if applicable, that the floating-point control word is in its -->
     <!-- default state.  If you do not define this macro the value of -->
     <!-- @code{FLT_EVAL_METHOD} will be zero. -->
      <p>一个C表达式，为<samp><span class="file">float.h</span></samp>中的<code>FLT_EVAL_METHOD</code>的值。如果没有定义，则<code>FLT_EVAL_METHOD</code>的值将为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WIDEST_HARDWARE_FP_SIZE</b><var><a name="index-WIDEST_005fHARDWARE_005fFP_005fSIZE-3905"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the widest floating-point format -->
     <!-- supported by the hardware.  If you define this macro, you must specify a -->
     <!-- value less than or equal to the value of @code{LONG_DOUBLE_TYPE_SIZE}. -->
     <!-- If you do not define this macro, the value of @code{LONG_DOUBLE_TYPE_SIZE} -->
     <!-- is the default. -->
      <p>一个C表达式，为硬件支持的最宽浮点格式的位数。如果定义该宏，则必须指定一个小于或等于<code>LONG_DOUBLE_TYPE_SIZE</code>的值。如果没有定义，则缺省为<code>LONG_DOUBLE_TYPE_SIZE</code>的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DEFAULT_SIGNED_CHAR</b><var><a name="index-DEFAULT_005fSIGNED_005fCHAR-3906"></a></var><br>
<blockquote><!-- An expression whose value is 1 or 0, according to whether the type -->
     <!-- @code{char} should be signed or unsigned by default.  The user can -->
     <!-- always override this default with the options @option{-fsigned-char} -->
     <!-- and @option{-funsigned-char}. -->
      <p>一个表达式，其值为1或者0，根据类型<code>char</code>缺省应该为有符号的还是无符号的。用户总是可以使用选项<samp><span class="option">-fsigned-char</span></samp>和<samp><span class="option">-funsigned-char</span></samp>来覆盖该缺省定义。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_DEFAULT_SHORT_ENUMS</b> (<var>void</var>)<var><a name="index-TARGET_005fDEFAULT_005fSHORT_005fENUMS-3907"></a></var><br>
<blockquote><!-- This target hook should return true if the compiler should give an -->
     <!-- @code{enum} type only as many bytes as it takes to represent the range -->
     <!-- of possible values of that type.  It should return false if all -->
     <!-- @code{enum} types should be allocated like @code{int}. -->
      <p>该target钩子应该返回真，如果编译器应该为<code>enum</code>类型设置为可以表示该类型值范围的字节数。其应该返回假，如果所有的<code>enum</code>类型应该按照<code>int</code>类型的方式来分配。

     <!-- The default is to return false. -->
      <p>缺省为返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SIZE_TYPE</b><var><a name="index-SIZE_005fTYPE-3908"></a></var><br>
<blockquote><!-- A C expression for a string describing the name of the data type to use -->
     <!-- for size values.  The typedef name @code{size_t} is defined using the -->
     <!-- contents of the string. -->
      <p>一个C表达式，为一个字符串描述了用于size值的数据类型名。typedef名<code>size_t</code>使用该字符串的内容来定义。

     <!-- The string can contain more than one keyword.  If so, separate them with -->
     <!-- spaces, and write first any length keyword, then @code{unsigned} if -->
     <!-- appropriate, and finally @code{int}.  The string must exactly match one -->
     <!-- of the data type names defined in the function -->
     <!-- @code{init_decl_processing} in the file @file{c-decl.c}.  You may not -->
     <!-- omit @code{int} or change the order-that would cause the compiler to -->
     <!-- crash on startup. -->
      <p>字符串可以包含多一个的关键字。如果是这样，则将它们使用空格分开，首先是任意长度的关键字，然后是合适<code>unsigned</code> 的，最后是<code>int</code>。字符串必须显示的匹配文件<samp><span class="file">c-decl.c</span></samp>中函数<code>init_decl_processing</code>中定义的数据类型名。不可以省略掉<code>int</code>或者改变顺序，这将会使编译器在启动时崩溃。

     <!-- If you don't define this macro, the default is @code{"long unsigned -->
     <!-- int"}. -->
      <p>如果没有定义，缺省为<code>"long unsigned int"</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PTRDIFF_TYPE</b><var><a name="index-PTRDIFF_005fTYPE-3909"></a></var><br>
<blockquote><!-- A C expression for a string describing the name of the data type to use -->
     <!-- for the result of subtracting two pointers.  The typedef name -->
     <!-- @code{ptrdiff_t} is defined using the contents of the string.  See -->
     <!-- @code{SIZE_TYPE} above for more information. -->
      <p>一个C表达式，为一个字符串，描述了用于两个指针相减的结果的数据类型名。typedef名<code>ptrdiff_t</code>使用该字符串的内容来定义。更多信息，参见上面的<code>SIZE_TYPE</code>。

     <!-- If you don't define this macro, the default is @code{"long int"}. -->
      <p>如果没有定义，则缺省为<code>"long int"</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WCHAR_TYPE</b><var><a name="index-WCHAR_005fTYPE-3910"></a></var><br>
<blockquote><!-- A C expression for a string describing the name of the data type to use -->
     <!-- for wide characters.  The typedef name @code{wchar_t} is defined using -->
     <!-- the contents of the string.  See @code{SIZE_TYPE} above for more -->
     <!-- information. -->
      <p>一个C表达式，为一个字符串，描述了用于宽字符的数据类型名。typedef名<code>wchar_t</code>使用该字符串的内容来定义。更多信息，参见上面的<code>SIZE_TYPE</code>。

     <!-- If you don't define this macro, the default is @code{"int"}. -->
      <p>如果没有定义，则缺省为<code>"int"</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WCHAR_TYPE_SIZE</b><var><a name="index-WCHAR_005fTYPE_005fSIZE-3911"></a></var><br>
<blockquote><!-- A C expression for the size in bits of the data type for wide -->
     <!-- characters.  This is used in @code{cpp}, which cannot make use of -->
     <!-- @code{WCHAR_TYPE}. -->
      <p>一个C表达式，为宽字符数据类型的位数。这用于不能使用<code>WCHAR_TYPE</code>的<code>cpp</code>中。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WINT_TYPE</b><var><a name="index-WINT_005fTYPE-3912"></a></var><br>
<blockquote><!-- A C expression for a string describing the name of the data type to -->
     <!-- use for wide characters passed to @code{printf} and returned from -->
     <!-- @code{getwc}.  The typedef name @code{wint_t} is defined using the -->
     <!-- contents of the string.  See @code{SIZE_TYPE} above for more -->
     <!-- information. -->
      <p>一个C表达式，为一个字符串，描述了传递给<code>printf</code>并且从<code>getwc</code>中返回的宽字符数据类型名。typedef名<code>wint_t</code>使用该字符串的内容来定义。更多信息，参见上面的<code>SIZE_TYPE</code>。

     <!-- If you don't define this macro, the default is @code{"unsigned int"}. -->
      <p>如果没有定义，则缺省为<code>"unsigned int"</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INTMAX_TYPE</b><var><a name="index-INTMAX_005fTYPE-3913"></a></var><br>
<blockquote><!-- A C expression for a string describing the name of the data type that -->
     <!-- can represent any value of any standard or extended signed integer type. -->
     <!-- The typedef name @code{intmax_t} is defined using the contents of the -->
     <!-- string.  See @code{SIZE_TYPE} above for more information. -->
      <p>一个C表达式，为一个字符串，描述了可以表示任何标准或者扩展的有符号整数类型值的数据类型名。typedef名<code>intmax_t</code>使用该字符串的内容来定义。更多信息，参见上面的<code>SIZE_TYPE</code>。

     <!-- If you don't define this macro, the default is the first of -->
     <!-- @code{"int"}, @code{"long int"}, or @code{"long long int"} that has as -->
     <!-- much precision as @code{long long int}. -->
      <p>如果没有定义，则缺省为<code>"int"</code>, <code>"long int"</code>或<code>"long long int"</code>中第一个与<code>long long int</code>具有相同精度的字符串。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>UINTMAX_TYPE</b><var><a name="index-UINTMAX_005fTYPE-3914"></a></var><br>
<blockquote><!-- A C expression for a string describing the name of the data type that -->
     <!-- can represent any value of any standard or extended unsigned integer -->
     <!-- type.  The typedef name @code{uintmax_t} is defined using the contents -->
     <!-- of the string.  See @code{SIZE_TYPE} above for more information. -->
      <p>一个C表达式，为一个字符串，描述了可以表示任何标准或者扩展的无符号整数类型值的数据类型名。typedef名<code>uintmax_t</code>使用该字符串的内容来定义。更多信息，参见上面的<code>SIZE_TYPE</code>。

     <!-- If you don't define this macro, the default is the first of -->
     <!-- @code{"unsigned int"}, @code{"long unsigned int"}, or @code{"long long -->
     <!-- unsigned int"} that has as much precision as @code{long long unsigned -->
     <!-- int}. -->
      <p>如果没有定义，则缺省为<code>"unsigned int"</code>, <code>"long unsigned int"</code>或<code>"long long unsigned int"</code>中第一个与<code>long long unsigned int</code>具有相同精度的字符串。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SIG_ATOMIC_TYPE</b><var><a name="index-SIG_005fATOMIC_005fTYPE-3915"></a></var><br>
&mdash; Macro: <b>INT8_TYPE</b><var><a name="index-INT8_005fTYPE-3916"></a></var><br>
&mdash; Macro: <b>INT16_TYPE</b><var><a name="index-INT16_005fTYPE-3917"></a></var><br>
&mdash; Macro: <b>INT32_TYPE</b><var><a name="index-INT32_005fTYPE-3918"></a></var><br>
&mdash; Macro: <b>INT64_TYPE</b><var><a name="index-INT64_005fTYPE-3919"></a></var><br>
&mdash; Macro: <b>UINT8_TYPE</b><var><a name="index-UINT8_005fTYPE-3920"></a></var><br>
&mdash; Macro: <b>UINT16_TYPE</b><var><a name="index-UINT16_005fTYPE-3921"></a></var><br>
&mdash; Macro: <b>UINT32_TYPE</b><var><a name="index-UINT32_005fTYPE-3922"></a></var><br>
&mdash; Macro: <b>UINT64_TYPE</b><var><a name="index-UINT64_005fTYPE-3923"></a></var><br>
&mdash; Macro: <b>INT_LEAST8_TYPE</b><var><a name="index-INT_005fLEAST8_005fTYPE-3924"></a></var><br>
&mdash; Macro: <b>INT_LEAST16_TYPE</b><var><a name="index-INT_005fLEAST16_005fTYPE-3925"></a></var><br>
&mdash; Macro: <b>INT_LEAST32_TYPE</b><var><a name="index-INT_005fLEAST32_005fTYPE-3926"></a></var><br>
&mdash; Macro: <b>INT_LEAST64_TYPE</b><var><a name="index-INT_005fLEAST64_005fTYPE-3927"></a></var><br>
&mdash; Macro: <b>UINT_LEAST8_TYPE</b><var><a name="index-UINT_005fLEAST8_005fTYPE-3928"></a></var><br>
&mdash; Macro: <b>UINT_LEAST16_TYPE</b><var><a name="index-UINT_005fLEAST16_005fTYPE-3929"></a></var><br>
&mdash; Macro: <b>UINT_LEAST32_TYPE</b><var><a name="index-UINT_005fLEAST32_005fTYPE-3930"></a></var><br>
&mdash; Macro: <b>UINT_LEAST64_TYPE</b><var><a name="index-UINT_005fLEAST64_005fTYPE-3931"></a></var><br>
&mdash; Macro: <b>INT_FAST8_TYPE</b><var><a name="index-INT_005fFAST8_005fTYPE-3932"></a></var><br>
&mdash; Macro: <b>INT_FAST16_TYPE</b><var><a name="index-INT_005fFAST16_005fTYPE-3933"></a></var><br>
&mdash; Macro: <b>INT_FAST32_TYPE</b><var><a name="index-INT_005fFAST32_005fTYPE-3934"></a></var><br>
&mdash; Macro: <b>INT_FAST64_TYPE</b><var><a name="index-INT_005fFAST64_005fTYPE-3935"></a></var><br>
&mdash; Macro: <b>UINT_FAST8_TYPE</b><var><a name="index-UINT_005fFAST8_005fTYPE-3936"></a></var><br>
&mdash; Macro: <b>UINT_FAST16_TYPE</b><var><a name="index-UINT_005fFAST16_005fTYPE-3937"></a></var><br>
&mdash; Macro: <b>UINT_FAST32_TYPE</b><var><a name="index-UINT_005fFAST32_005fTYPE-3938"></a></var><br>
&mdash; Macro: <b>UINT_FAST64_TYPE</b><var><a name="index-UINT_005fFAST64_005fTYPE-3939"></a></var><br>
&mdash; Macro: <b>INTPTR_TYPE</b><var><a name="index-INTPTR_005fTYPE-3940"></a></var><br>
&mdash; Macro: <b>UINTPTR_TYPE</b><var><a name="index-UINTPTR_005fTYPE-3941"></a></var><br>
<blockquote><p>C expressions for the standard types <code>sig_atomic_t</code>,
<code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>,
<code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code>,
<code>int_least8_t</code>, <code>int_least16_t</code>, <code>int_least32_t</code>,
<code>int_least64_t</code>, <code>uint_least8_t</code>, <code>uint_least16_t</code>,
<code>uint_least32_t</code>, <code>uint_least64_t</code>, <code>int_fast8_t</code>,
<code>int_fast16_t</code>, <code>int_fast32_t</code>, <code>int_fast64_t</code>,
<code>uint_fast8_t</code>, <code>uint_fast16_t</code>, <code>uint_fast32_t</code>,
<code>uint_fast64_t</code>, <code>intptr_t</code>, and <code>uintptr_t</code>.  See
<code>SIZE_TYPE</code> above for more information.

      <p>If any of these macros evaluates to a null pointer, the corresponding
type is not supported; if GCC is configured to provide
<code>&lt;stdint.h&gt;</code> in such a case, the header provided may not conform
to C99, depending on the type in question.  The defaults for all of
these macros are null pointers. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_PTRMEMFUNC_VBIT_LOCATION</b><var><a name="index-TARGET_005fPTRMEMFUNC_005fVBIT_005fLOCATION-3942"></a></var><br>
<blockquote><p>The C++ compiler represents a pointer-to-member-function with a struct
that looks like:

     <pre class="smallexample">            struct {
              union {
                void (*fn)();
                ptrdiff_t vtable_index;
              };
              ptrdiff_t delta;
            };
</pre>
      <p class="noindent">The C++ compiler must use one bit to indicate whether the function that
will be called through a pointer-to-member-function is virtual. 
Normally, we assume that the low-order bit of a function pointer must
always be zero.  Then, by ensuring that the vtable_index is odd, we can
distinguish which variant of the union is in use.  But, on some
platforms function pointers can be odd, and so this doesn't work.  In
that case, we use the low-order bit of the <code>delta</code> field, and shift
the remainder of the <code>delta</code> field to the left.

      <p>GCC will automatically make the right selection about where to store
this bit using the <code>FUNCTION_BOUNDARY</code> setting for your platform. 
However, some platforms such as ARM/Thumb have <code>FUNCTION_BOUNDARY</code>
set such that functions always start at even addresses, but the lowest
bit of pointers to functions indicate whether the function at that
address is in ARM or Thumb mode.  If this is the case of your
architecture, you should define this macro to
<code>ptrmemfunc_vbit_in_delta</code>.

      <p>In general, you should not have to define this macro.  On architectures
in which function addresses are always even, according to
<code>FUNCTION_BOUNDARY</code>, GCC will automatically define this macro to
<code>ptrmemfunc_vbit_in_pfn</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_VTABLE_USES_DESCRIPTORS</b><var><a name="index-TARGET_005fVTABLE_005fUSES_005fDESCRIPTORS-3943"></a></var><br>
<blockquote><p>Normally, the C++ compiler uses function pointers in vtables.  This
macro allows the target to change to use &ldquo;function descriptors&rdquo;
instead.  Function descriptors are found on targets for whom a
function pointer is actually a small data structure.  Normally the
data structure consists of the actual code address plus a data
pointer to which the function's data is relative.

      <p>If vtables are used, the value of this macro should be the number
of words that the function descriptor occupies. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_VTABLE_ENTRY_ALIGN</b><var><a name="index-TARGET_005fVTABLE_005fENTRY_005fALIGN-3944"></a></var><br>
<blockquote><p>By default, the vtable entries are void pointers, the so the alignment
is the same as pointer alignment.  The value of this macro specifies
the alignment of the vtable entry in bits.  It should be defined only
when special alignment is necessary. */
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_VTABLE_DATA_ENTRY_DISTANCE</b><var><a name="index-TARGET_005fVTABLE_005fDATA_005fENTRY_005fDISTANCE-3945"></a></var><br>
<blockquote><p>There are a few non-descriptor entries in the vtable at offsets below
zero.  If these entries must be padded (say, to preserve the alignment
specified by <code>TARGET_VTABLE_ENTRY_ALIGN</code>), set this to the number
of words in each data entry. 
</p></blockquote></div>

<!-- @node Registers -->
<!-- @section Register Usage -->
 </body></html>

