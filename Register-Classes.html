<html lang="zh">
<head>
<title>Register Classes - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Registers.html#Registers" title="Registers">
<link rel="next" href="Old-Constraints.html#Old-Constraints" title="Old Constraints">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Register-Classes"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Old-Constraints.html#Old-Constraints">Old Constraints</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Registers.html#Registers">Registers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.8 寄存器类别</h3>

<p><a name="index-register-class-definitions-4000"></a><a name="index-class-definitions_002c-register-4001"></a>
<!-- On many machines, the numbered registers are not all equivalent. -->
<!-- For example, certain registers may not be allowed for indexed addressing; -->
<!-- certain registers may not be allowed in some instructions.  These machine -->
<!-- restrictions are described to the compiler using @dfn{register classes}. -->
在许多机器上，编号寄存器并不都是等价的。例如，一些寄存器不可以用作索引寻址；一些寄存器不可以用于某些指令。这些机器限制通过使用寄存器类别(<dfn>register classes</dfn>)来描述。

<!-- You define a number of register classes, giving each one a name and saying -->
<!-- which of the registers belong to it.  Then you can specify register classes -->
<!-- that are allowed as operands to particular instruction patterns. -->
 <p>你定义一些寄存器类别，给出每个类别的名字并指出哪些寄存器属于它。然后，你可以指定哪些寄存器类别对于特定的指令模式可以作为操作数来使用。

 <p><a name="index-ALL_005fREGS-4002"></a><a name="index-NO_005fREGS-4003"></a><!-- In general, each register will belong to several classes.  In fact, one -->
<!-- class must be named @code{ALL_REGS} and contain all the registers.  Another -->
<!-- class must be named @code{NO_REGS} and contain no registers.  Often the -->
<!-- union of two classes will be another class; however, this is not required. -->
总的来说，每个寄存器将属于多个类别。实际上，必须有一个名为<code>ALL_REGS</code>的类别，包含所有的寄存器。另外必须有一个名为<code>NO_REGS</code>的类别，不包含寄存器。通常两个类别的并集将成为另一个类别；但并不这么要求。

 <p><a name="index-GENERAL_005fREGS-4004"></a><!-- One of the classes must be named @code{GENERAL_REGS}.  There is nothing -->
<!-- terribly special about the name, but the operand constraint letters -->
<!-- @samp{r} and @samp{g} specify this class.  If @code{GENERAL_REGS} is -->
<!-- the same as @code{ALL_REGS}, just define it as a macro which expands -->
<!-- to @code{ALL_REGS}. -->
其中一个类别必须名为<code>GENERAL_REGS</code>。该名字没有什么特殊的，但是操作数约束字母&lsquo;<samp><span class="samp">r</span></samp>&rsquo;和&lsquo;<samp><span class="samp">g</span></samp>&rsquo;专门指定该类别。如果<code>GENERAL_REGS</code>与<code>ALL_REGS</code>相同，则可以将其定义为扩展成<code>ALL_REGS</code>的宏。

<!-- Order the classes so that if class @var{x} is contained in class @var{y} -->
<!-- then @var{x} has a lower class number than @var{y}. -->
 <p>对类别进行排序，使得如果类别<var>x</var>包含在类别<var>y</var>中，则<var>x</var>具有比<var>y</var>更低的类别编号。

<!-- The way classes other than @code{GENERAL_REGS} are specified in operand -->
<!-- constraints is through machine-dependent operand constraint letters. -->
<!-- You can define such letters to correspond to various classes, then use -->
<!-- them in operand constraints. -->
 <p>在操作数约束中指定<code>GENERAL_REGS</code>之外的类别的方法，是通过机器相关的约束字母。你可以定义该字母来对应于不同的类别，然后在操作数约束中使用它们。

 <p>You must define the narrowest register classes for allocatable
registers, so that each class either has no subclasses, or that for
some mode, the move cost between registers within the class is
cheaper than moving a register in the class to or from memory
(参见<a href="Costs.html#Costs">Costs</a>).

<!-- You should define a class for the union of two classes whenever some -->
<!-- instruction allows both classes.  For example, if an instruction allows -->
<!-- either a floating point (coprocessor) register or a general register for a -->
<!-- certain operand, you should define a class @code{FLOAT_OR_GENERAL_REGS} -->
<!-- which includes both of them.  Otherwise you will get suboptimal code, -->
<!-- or even internal compiler errors when reload cannot find a register in the -->
<!-- class computed via @code{reg_class_subunion}. -->
 <p>只要有指令同时允许两个类别，就应该定义一个它们的并集的类别。例如，如果对于一个特定的操作数，有一条指令允许一个浮点（协处理器）寄存器或者一个通用寄存器，则应该定义一个类别<code>FLOAT_OR_GENERAL_REGS</code>，其包含它们两。否则你不会得到最优的代码，甚至当reload无法在通过<code>reg_class_subunion</code>所计算的类别中找到一个寄存器时，还会产生编译器内部错误。

<!-- You must also specify certain redundant information about the register -->
<!-- classes: for each class, which classes contain it and which ones are -->
<!-- contained in it; for each pair of classes, the largest class contained -->
<!-- in their union. -->
 <p>你还必须指定寄存器类别相关的冗余信息：对于每个类别，有哪些类别包含它以及哪些被它包含；对于每一对类别，它们的并集所包含的最大类别。

<!-- When a value occupying several consecutive registers is expected in a -->
<!-- certain class, all the registers used must belong to that class. -->
<!-- Therefore, register classes cannot be used to enforce a requirement for -->
<!-- a register pair to start with an even-numbered register.  The way to -->
<!-- specify this requirement is with @code{HARD_REGNO_MODE_OK}. -->
 <p>当一个值占用多个连续的位于特定类别的寄存器时，所有被使用的寄存器必须属于那个类别。因此，寄存器类别不能用于要求寄存器对起始于偶数编号的寄存器。用来指定该要求的方法是使用<code>HARD_REGNO_MODE_OK</code>。

<!-- Register classes used for input-operands of bitwise-and or shift -->
<!-- instructions have a special requirement: each such class must have, for -->
<!-- each fixed-point machine mode, a subclass whose registers can transfer that -->
<!-- mode to or from memory.  For example, on some machines, the operations for -->
<!-- single-byte values (@code{QImode}) are limited to certain registers.  When -->
<!-- this is so, each register class that is used in a bitwise-and or shift -->
<!-- instruction must have a subclass consisting of registers from which -->
<!-- single-byte values can be loaded or stored.  This is so that -->
<!-- @code{PREFERRED_RELOAD_CLASS} can always have a possible value to return. -->
 <p>用于按位与或者移位指令的操作数的寄存器类别具有特殊的要求：对于每个定点机器模式，每个这样的类必须具有一个子类，它的寄存器可以按照该机器模式与内存进行传送值。例如，在一些机器上，对于单字节值的操作（<code>QImode</code>）被限制为特定的寄存器。这样的话，每个用于按位与或者移位指令的寄存器类别必须具有一个子类，组成它的寄存器可以用来加载或存储单字节值。这使得<code>PREFERRED_RELOAD_CLASS</code>总是具有一个可以返回的值。

<div class="defun">
&mdash; Data type: <b>enum reg_class</b><var><a name="index-enum-reg_005fclass-4005"></a></var><br>
<blockquote><!-- An enumerated type that must be defined with all the register class names -->
     <!-- as enumerated values.  @code{NO_REGS} must be first.  @code{ALL_REGS} -->
     <!-- must be the last register class, followed by one more enumerated value, -->
     <!-- @code{LIM_REG_CLASSES}, which is not a register class but rather -->
     <!-- tells how many classes there are. -->
      <p>一个枚举类型，必须使用所有的寄存器类别名作为枚举值来定义。<code>NO_REGS</code>必须位于最前面。<code>ALL_REGS</code>必须为最后一个寄存器类别，后面再跟随一个枚举值，<code>LIM_REG_CLASSES</code>，其不是一个寄存器类别，但是用来告诉有多少个类别。

     <!-- Each register class has a number, which is the value of casting -->
     <!-- the class name to type @code{int}.  The number serves as an index -->
     <!-- in many of the tables described below. -->
      <p>每个寄存器类别具有一个编号，其为将类别名映射到<code>int</code>类型的值。编号在下面描述的许多表中用作索引。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>N_REG_CLASSES</b><var><a name="index-N_005fREG_005fCLASSES-4006"></a></var><br>
<blockquote><!-- The number of distinct register classes, defined as follows: -->
      <p>不同寄存器类别的数目，定义为:

     <pre class="smallexample">          #define N_REG_CLASSES (int) LIM_REG_CLASSES
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>REG_CLASS_NAMES</b><var><a name="index-REG_005fCLASS_005fNAMES-4007"></a></var><br>
<blockquote><!-- An initializer containing the names of the register classes as C string -->
     <!-- constants.  These names are used in writing some of the debugging dumps. -->
      <p>一个初始化值，包含了作为C字符串常量的寄存器类别的名字。这些名字用于书写一些调试转储。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REG_CLASS_CONTENTS</b><var><a name="index-REG_005fCLASS_005fCONTENTS-4008"></a></var><br>
<blockquote><!-- An initializer containing the contents of the register classes, as integers -->
     <!-- which are bit masks.  The @var{n}th integer specifies the contents of class -->
     <!-- @var{n}.  The way the integer @var{mask} is interpreted is that -->
     <!-- register @var{r} is in the class if @code{@var{mask} & (1 << @var{r})} is 1. -->
      <p>一个初始化值，以位掩码的方式来描述寄存器类别的内容。第<var>n</var>个整数指定了类别<var>n</var>的内容。整数<var>mask</var>的解析方式为：如果<var>mask</var><code> &amp; (1 &lt;&lt; </code><var>r</var><code>)</code>为1，则寄存器<var>r</var>在该类别中。

     <!-- When the machine has more than 32 registers, an integer does not suffice. -->
     <!-- Then the integers are replaced by sub-initializers, braced groupings containing -->
     <!-- several integers.  Each sub-initializer must be suitable as an initializer -->
     <!-- for the type @code{HARD_REG_SET} which is defined in @file{hard-reg-set.h}. -->
     <!-- In this situation, the first integer in each sub-initializer corresponds to -->
     <!-- registers 0 through 31, the second integer to registers 32 through 63, and -->
     <!-- so on. -->
      <p>当机器具有多于32个寄存器的时候，一个整数还不能满足。这时整数被替换为由大括号包裹的多个整数的子初始化值。每个子初始化值必须适合在<samp><span class="file">hard-reg-set.h</span></samp>中定义的类型<code>HARD_REG_SET</code>。在这种情况下，每个子初始化值的第一个整数对应于寄存器0到31，第二个对应于32到63，等等。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGNO_REG_CLASS</b> (<var>regno</var>)<var><a name="index-REGNO_005fREG_005fCLASS-4009"></a></var><br>
<blockquote><!-- A C expression whose value is a register class containing hard register -->
     <!-- @var{regno}.  In general there is more than one such class; choose a class -->
     <!-- which is @dfn{minimal}, meaning that no smaller class also contains the -->
     <!-- register. -->
      <p>一个C表达式，其值为包含了硬件寄存器<var>regno</var>的寄存器类别。总的来说，会有不止一个这样的类别；选择最小的那个，即没有更小的类别包含该寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BASE_REG_CLASS</b><var><a name="index-BASE_005fREG_005fCLASS-4010"></a></var><br>
<blockquote><!-- A macro whose definition is the name of the class to which a valid -->
     <!-- base register must belong.  A base register is one used in an address -->
     <!-- which is the register value plus a displacement. -->
      <p>一个宏，它的定义为有效的基址寄存器必须属于的类别名字。基址寄存器用于由寄存器的值加上一个偏移量来表示的地址中。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MODE_BASE_REG_CLASS</b> (<var>mode</var>)<var><a name="index-MODE_005fBASE_005fREG_005fCLASS-4011"></a></var><br>
<blockquote><!-- This is a variation of the @code{BASE_REG_CLASS} macro which allows -->
     <!-- the selection of a base register in a mode dependent manner.  If -->
     <!-- @var{mode} is VOIDmode then it should return the same value as -->
     <!-- @code{BASE_REG_CLASS}. -->
      <p>这是宏<code>BASE_REG_CLASS</code>的变体，其允许在机器模式相关的方式下选择基址寄存器。如果<var>mode</var>为VOIDmode，则其应该返回根<code>BASE_REG_CLASS</code>同样的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MODE_BASE_REG_REG_CLASS</b> (<var>mode</var>)<var><a name="index-MODE_005fBASE_005fREG_005fREG_005fCLASS-4012"></a></var><br>
<blockquote><!-- A C expression whose value is the register class to which a valid -->
     <!-- base register must belong in order to be used in a base plus index -->
     <!-- register address.  You should define this macro if base plus index -->
     <!-- addresses have different requirements than other base register uses. -->
      <p>一个C表达式，其值为有效的基址寄存器必须属于的类别名字，且用于一个基址寄存器加上索引寄存器的地址中。你应该定义该宏，如果表示为基址寄存器加上索引寄存器的地址具有不同于其它基址寄存器的用法要求时。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MODE_CODE_BASE_REG_CLASS</b> (<var>mode, outer_code, index_code</var>)<var><a name="index-MODE_005fCODE_005fBASE_005fREG_005fCLASS-4013"></a></var><br>
<blockquote><!-- A C expression whose value is the register class to which a valid -->
     <!-- base register must belong.  @var{outer_code} and @var{index_code} define the -->
     <!-- context in which the base register occurs.  @var{outer_code} is the code of -->
     <!-- the immediately enclosing expression (@code{MEM} for the top level of an -->
     <!-- address, @code{ADDRESS} for something that occurs in an -->
     <!-- @code{address_operand}).  @var{index_code} is the code of the corresponding -->
     <!-- index expression if @var{outer_code} is @code{PLUS}; @code{SCRATCH} otherwise. -->
      <p>一个C表达式，其值为有效的基址寄存器必须属于的类别名字。<var>outer_code</var>和<var>index_code</var>定义了基址寄存器出现的上下文。<var>outer_code</var>为。<var>index_code</var>为相应的索引表达式的代码，如果<var>outer_code</var>为<code>PLUS</code>；否则为<code>SCRATCH</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INDEX_REG_CLASS</b><var><a name="index-INDEX_005fREG_005fCLASS-4014"></a></var><br>
<blockquote><!-- A macro whose definition is the name of the class to which a valid -->
     <!-- index register must belong.  An index register is one used in an -->
     <!-- address where its value is either multiplied by a scale factor or -->
     <!-- added to another register (as well as added to a displacement). -->
      <p>一个C表达式，其值为有效的索引寄存器必须属于的类别名字。索引寄存器为一个用于地址中的寄存器，它的值用于乘于一个标量因子或者加上另一个寄存器（也可以加上一个偏移量）。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGNO_OK_FOR_BASE_P</b> (<var>num</var>)<var><a name="index-REGNO_005fOK_005fFOR_005fBASE_005fP-4015"></a></var><br>
<blockquote><!-- A C expression which is nonzero if register number @var{num} is -->
     <!-- suitable for use as a base register in operand addresses. -->
     <!-- Like @code{TARGET_LEGITIMATE_ADDRESS_P}, this macro should also -->
     <!-- define a strict and a non-strict variant.  Both variants behave -->
     <!-- the same for hard register; for pseudos, the strict variant will -->
     <!-- pass only those that have been allocated to a valid hard registers, -->
     <!-- while the non-strict variant will pass all pseudos. -->
      <p>一个C表达式，其为非0，如果寄存器编号<var>num</var>适合在操作数地址中作为基址寄存器使用。其可以为一个合适的硬件寄存器，或者一个已经被分配了这样的硬件寄存器的伪寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGNO_MODE_OK_FOR_BASE_P</b> (<var>num, mode</var>)<var><a name="index-REGNO_005fMODE_005fOK_005fFOR_005fBASE_005fP-4016"></a></var><br>
<blockquote><!-- A C expression that is just like @code{REGNO_OK_FOR_BASE_P}, except that -->
     <!-- that expression may examine the mode of the memory reference in -->
     <!-- @var{mode}.  You should define this macro if the mode of the memory -->
     <!-- reference affects whether a register may be used as a base register.  If -->
     <!-- you define this macro, the compiler will use it instead of -->
     <!-- @code{REGNO_OK_FOR_BASE_P}.  The mode may be @code{VOIDmode} for -->
     <!-- addresses that appear outside a @code{MEM}, i.e., as an -->
     <!-- @code{address_operand}. -->
      <p>一个C表达式，类似于<code>REGNO_OK_FOR_BASE_P</code>，除了表达式可以检查内存引用的机器模式<var>mode</var>。你应该定义该宏，如果内存引用的机器模式影响了一个寄存器是否可以作为基址寄存器使用。如果你定义了该宏，则编译器将使用它来替代<code>REGNO_OK_FOR_BASE_P</code>。对于出现在<code>MEM</code>之外的地址，即作为一个<code>address_operand</code>，mode可以为<code>VOIDmode</code>。

     <!-- This macro also has strict and non-strict variants. -->
      <p>该宏具有strict和non-strict两个变型。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGNO_MODE_OK_FOR_REG_BASE_P</b> (<var>num, mode</var>)<var><a name="index-REGNO_005fMODE_005fOK_005fFOR_005fREG_005fBASE_005fP-4017"></a></var><br>
<blockquote><!-- A C expression which is nonzero if register number @var{num} is suitable for -->
     <!-- use as a base register in base plus index operand addresses, accessing -->
     <!-- memory in mode @var{mode}.  It may be either a suitable hard register or a -->
     <!-- pseudo register that has been allocated such a hard register.  You should -->
     <!-- define this macro if base plus index addresses have different requirements -->
     <!-- than other base register uses. -->
      <p>一个C表达式，其为非0，如果寄存器编号<var>num</var>适合在表示为基址加索引的地址中作为一个基址寄存器使用，并通过模式<var>mode</var>来访问。其可以为一个合适的硬件寄存器，或者一个已经被分配了这样的硬件寄存器的伪寄存器。你应该定义该宏，如果表示为基址寄存器加上索引寄存器的地址具有不同于其它基址寄存器的用法要求时。

     <!-- Use of this macro is deprecated; please use the more general -->
     <!-- @code{REGNO_MODE_CODE_OK_FOR_BASE_P}. -->
      <p>不赞成使用该宏；请使用更加通用的<code>REGNO_MODE_CODE_OK_FOR_BASE_P</code>。

     <!-- This macro also has strict and non-strict variants. -->
      <p>该宏具有strict和non-strict两个变型。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGNO_MODE_CODE_OK_FOR_BASE_P</b> (<var>num, mode, outer_code, index_code</var>)<var><a name="index-REGNO_005fMODE_005fCODE_005fOK_005fFOR_005fBASE_005fP-4018"></a></var><br>
<blockquote><!-- A C expression that is just like @code{REGNO_MODE_OK_FOR_BASE_P}, except -->
     <!-- that that expression may examine the context in which the register -->
     <!-- appears in the memory reference.  @var{outer_code} is the code of the -->
     <!-- immediately enclosing expression (@code{MEM} if at the top level of the -->
     <!-- address, @code{ADDRESS} for something that occurs in an -->
     <!-- @code{address_operand}).  @var{index_code} is the code of the -->
     <!-- corresponding index expression if @var{outer_code} is @code{PLUS}; -->
     <!-- @code{SCRATCH} otherwise.  The mode may be @code{VOIDmode} for addresses -->
     <!-- that appear outside a @code{MEM}, i.e., as an @code{address_operand}. -->
      <p>一个C表达式，类似于<code>REGNO_MODE_OK_FOR_BASE_P</code>，除了表达式可以检查寄存器出现内存引用中的上下文。<var>outer_code</var>为。<var>index_code</var>为相应的索引表达式的代码，如果<var>outer_code</var>为<code>PLUS</code>；否则为<code>SCRATCH</code>。对于出现在<code>MEM</code>之外的地址，即作为一个<code>address_operand</code>，mode可以为<code>VOIDmode</code>。

     <!-- This macro also has strict and non-strict variants. -->
      <p>该宏具有strict和non-strict两个变型。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REGNO_OK_FOR_INDEX_P</b> (<var>num</var>)<var><a name="index-REGNO_005fOK_005fFOR_005fINDEX_005fP-4019"></a></var><br>
<blockquote><!-- A C expression which is nonzero if register number @var{num} is -->
     <!-- suitable for use as an index register in operand addresses.  It may be -->
     <!-- either a suitable hard register or a pseudo register that has been -->
     <!-- allocated such a hard register. -->
      <p>一个C表达式，其为非0，如果寄存器编号<var>num</var>适合作为索引寄存器用于操作数地址中。其可以为一个合适的硬件寄存器或者一个已经被分配了这样的硬件寄存器的伪寄存器。

     <!-- The difference between an index register and a base register is that -->
     <!-- the index register may be scaled.  If an address involves the sum of -->
     <!-- two registers, neither one of them scaled, then either one may be -->
     <!-- labeled the ``base'' and the other the ``index''; but whichever -->
     <!-- labeling is used must fit the machine's constraints of which registers -->
     <!-- may serve in each capacity.  The compiler will try both labelings, -->
     <!-- looking for one that is valid, and will reload one or both registers -->
     <!-- only if neither labeling works. -->
      <p>索引寄存器和基址寄存器的区别是，索引寄存器可以被标量化。如果一个地址包含了两个寄存器的和，并且都不被标量化，则一个可以被标签为“base” 另一个为“index”；但是使用哪个标签，必须要适合机器的约束。编译器将尝试两种标签方式，来查找有效的一种，并且当两种方式都无法工作时，重载一个或两个寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: reg_class_t <b>TARGET_PREFERRED_RENAME_CLASS</b> (<var>reg_class_t rclass</var>)<var><a name="index-TARGET_005fPREFERRED_005fRENAME_005fCLASS-4020"></a></var><br>
<blockquote><!-- A target hook that places additional preference on the register class to use when it is necessary to rename a register in class @var{rclass} to another class, or perhaps @var{NO_REGS}, if no preferred register class is found or hook @code{preferred_rename_class} is not implemented. Sometimes returning a more restrictive class makes better code.  For example, on ARM, thumb-2 instructions using @code{LO_REGS} may be smaller than instructions using @code{GENERIC_REGS}.  By returning @code{LO_REGS} from @code{preferred_rename_class}, code size can be reduced. -->
      <p>一个目标钩子，当把一个寄存器类别<var>rclass</var>重命名为另外一个寄存器类别的时候，会优先选择一些寄存器类别，或者，如果没有优先选择的寄存器类别被发现或者<code>preferred_rename_class</code>钩子没有实现，也被重命名为<var>NO_REGS</var>。有些时候，这个钩子返回一个更加严格的寄存器类别，可能产生更好的代码。例如，在ARM平台，使用寄存器类别<code>LO_REGS</code>的thumb-2指令可能比使用寄存器类别<code>GENERIC_REGS</code>的指令更小。通过从<code>preferred_rename_class</code>返回寄存器类别<code>LO_REGS</code>，代码体积可能会减小。

      </blockquote></div>

<div class="defun">
&mdash; Target Hook: reg_class_t <b>TARGET_PREFERRED_RELOAD_CLASS</b> (<var>rtx x, reg_class_t rclass</var>)<var><a name="index-TARGET_005fPREFERRED_005fRELOAD_005fCLASS-4021"></a></var><br>
<blockquote><!-- A target hook that places additional restrictions on the register class -->
     <!-- to use when it is necessary to copy value @var{x} into a register in class -->
     <!-- @var{rclass}.  The value is a register class; perhaps @var{rclass}, or perhaps -->
     <!-- another, smaller class. -->
      <p>一个目标钩子，当需要将值<var>x</var>复制到类别为<var>rclass</var>的寄存器中时，其用来对要使用的寄存器类别进行额外的限制。返回值为一个寄存器类别；可能为<var>rclass</var>，也可能为其它更小的类别。

     <!-- The default version of this hook always returns value of @code{rclass} argument. -->
      <p>该钩子的缺省版本总是返回参数值<code>rclass</code>。

     <!-- Sometimes returning a more restrictive class makes better code.  For -->
     <!-- example, on the 68000, when @var{x} is an integer constant that is in range -->
     <!-- for a @samp{moveq} instruction, the value of this macro is always -->
     <!-- @code{DATA_REGS} as long as @var{rclass} includes the data registers. -->
     <!-- Requiring a data register guarantees that a @samp{moveq} will be used. -->
      <p>有时候返回一个更加有限制的类别可以生成更好的代码。例如，在68000上，当<var>x</var>为一个值范围适合&lsquo;<samp><span class="samp">moveq</span></samp>&rsquo;指令的整数常量时，只要<var>rclass</var>包含数据寄存器，则该宏的值总是为<code>DATA_REGS</code>。这种要求为一个数据寄存器的做法，可以确保&lsquo;<samp><span class="samp">moveq</span></samp>&rsquo;会被使用。

     <!-- One case where @code{TARGET_PREFERRED_RELOAD_CLASS} must not return -->
     <!-- @var{rclass} is if @var{x} is a legitimate constant which cannot be -->
     <!-- loaded into some register class.  By returning @code{NO_REGS} you can -->
     <!-- force @var{x} into a memory location.  For example, rs6000 can load -->
     <!-- immediate values into general-purpose registers, but does not have an -->
     <!-- instruction for loading an immediate value into a floating-point -->
     <!-- register, so @code{TARGET_PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when -->
     <!-- @var{x} is a floating-point constant.  If the constant can't be loaded -->
     <!-- into any kind of register, code generation will be better if -->
     <!-- @code{TARGET_LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead -->
     <!-- of using @code{TARGET_PREFERRED_RELOAD_CLASS}. -->
      <p>一种<code>PREFERRED_RELOAD_CLASS</code>必须不返回<var>rclass</var>的情况为，如果<var>x</var>为一个合法常量，且不能被加载到某个寄存器类别中。通过返回<code>NO_REGS</code>，你可以强迫<var>x</var>被放入内存中。例如，rs6000可以加载立即数到通用寄存器中，但是没有指令可以加载立即数到浮点寄存器中，所以当<var>x</var>为一个浮点常量时，<code>PREFERRED_RELOAD_CLASS</code>返回<code>NO_REGS</code>。如果常量不能被加载到任何种类的寄存器中，则通过<code>TARGET_LEGITIMATE_CONSTANT_P</code>使常量为非法的，而不是使用<code>PREFERRED_RELOAD_CLASS</code>，将会生成更好的代码。

     <!-- If an insn has pseudos in it after register allocation, reload will go -->
     <!-- through the alternatives and call repeatedly @code{TARGET_PREFERRED_RELOAD_CLASS} -->
     <!-- to find the best one.  Returning @code{NO_REGS}, in this case, makes -->
     <!-- reload add a @code{!} in front of the constraint: the x86 back-end uses -->
     <!-- this feature to discourage usage of 387 registers when math is done in -->
     <!-- the SSE registers (and vice versa). -->
      <p>如果一个insn在寄存器分配之后具有伪寄存器，则重载将遍历所有可选项并反复调用<code>PREFERRED_RELOAD_CLASS</code>来找到最好的一个。在这种情况下，如果返回<code>NO_REGS</code>，会使得重载在约束前增加一个<code>!</code>：x86后端使用了该特点，当在SSE寄存器中进行算术运算时，会不鼓励对387寄存器的使用（反之亦然）。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PREFERRED_RELOAD_CLASS</b> (<var>x, class</var>)<var><a name="index-PREFERRED_005fRELOAD_005fCLASS-4022"></a></var><br>
<blockquote><!-- A C expression that places additional restrictions on the register class -->
     <!-- to use when it is necessary to copy value @var{x} into a register in class -->
     <!-- @var{class}.  The value is a register class; perhaps @var{class}, or perhaps -->
     <!-- another, smaller class.  On many machines, the following definition is -->
     <!-- safe: -->
      <p>一个C表达式，当需要将值<var>x</var>复制到类别为<var>rclass</var>的寄存器中时，其用来对要使用的寄存器类别进行额外的限制。返回值为一个寄存器类别；可能为<var>rclass</var>，也可能为其它更小的类别。在许多机器上，下列定义是安全的：

     <pre class="smallexample">          #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS
</pre>
      <!-- Sometimes returning a more restrictive class makes better code.  For -->
     <!-- example, on the 68000, when @var{x} is an integer constant that is in range -->
     <!-- for a @samp{moveq} instruction, the value of this macro is always -->
     <!-- @code{DATA_REGS} as long as @var{class} includes the data registers. -->
     <!-- Requiring a data register guarantees that a @samp{moveq} will be used. -->
      <p>有时候返回一个更加有限制的类别可以生成更好的代码。例如，在68000上，当<var>x</var>为一个值范围适合&lsquo;<samp><span class="samp">moveq</span></samp>&rsquo;指令的整数常量时，只要<var>rclass</var>包含数据寄存器，则该宏的值总是为<code>DATA_REGS</code>。这种要求为一个数据寄存器的做法，可以确保&lsquo;<samp><span class="samp">moveq</span></samp>&rsquo;会被使用。

     <!-- One case where @code{PREFERRED_RELOAD_CLASS} must not return -->
     <!-- @var{class} is if @var{x} is a legitimate constant which cannot be -->
     <!-- loaded into some register class.  By returning @code{NO_REGS} you can -->
     <!-- force @var{x} into a memory location.  For example, rs6000 can load -->
     <!-- immediate values into general-purpose registers, but does not have an -->
     <!-- instruction for loading an immediate value into a floating-point -->
     <!-- register, so @code{PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when -->
     <!-- @var{x} is a floating-point constant.  If the constant can't be loaded -->
     <!-- into any kind of register, code generation will be better if -->
     <!-- @code{TARGET_LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead -->
     <!-- of using @code{PREFERRED_RELOAD_CLASS}. -->
      <p>一种<code>PREFERRED_RELOAD_CLASS</code>必须不返回<var>rclass</var>的情况为，如果<var>x</var>为一个合法常量，且不能被加载到某个寄存器类别中。通过返回<code>NO_REGS</code>，你可以强迫<var>x</var>被放入内存中。例如，rs6000可以加载立即数到通用寄存器中，但是没有指令可以加载立即数到浮点寄存器中，所以当<var>x</var>为一个浮点常量时，<code>PREFERRED_RELOAD_CLASS</code>返回<code>NO_REGS</code>。如果常量不能被加载到任何种类的寄存器中，则通过<code>TARGET_LEGITIMATE_CONSTANT_P</code>使常量为非法的，而不是使用<code>PREFERRED_RELOAD_CLASS</code>，将会生成更好的代码。

     <!-- If an insn has pseudos in it after register allocation, reload will go -->
     <!-- through the alternatives and call repeatedly @code{PREFERRED_RELOAD_CLASS} -->
     <!-- to find the best one.  Returning @code{NO_REGS}, in this case, makes -->
     <!-- reload add a @code{!} in front of the constraint: the x86 back-end uses -->
     <!-- this feature to discourage usage of 387 registers when math is done in -->
     <!-- the SSE registers (and vice versa). -->
      <p>如果一个insn在寄存器分配之后具有伪寄存器，则重载将遍历所有可选项并反复调用<code>PREFERRED_RELOAD_CLASS</code>来找到最好的一个。在这种情况下，如果返回<code>NO_REGS</code>，会使得重载在约束前增加一个<code>!</code>：x86后端使用了该特点，当在SSE寄存器中进行算术运算时，会不鼓励对387寄存器的使用（反之亦然）。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: reg_class_t <b>TARGET_PREFERRED_OUTPUT_RELOAD_CLASS</b> (<var>rtx x, reg_class_t rclass</var>)<var><a name="index-TARGET_005fPREFERRED_005fOUTPUT_005fRELOAD_005fCLASS-4023"></a></var><br>
<blockquote><!-- Like @code{TARGET_PREFERRED_RELOAD_CLASS}, but for output reloads instead of -->
     <!-- input reloads. -->
      <p>类似于<code>TARGET_PREFERRED_RELOAD_CLASS</code>，但是用于输出重载而不是输入重载。

     <!-- The default version of this hook always returns value of @code{rclass} -->
     <!-- argument. -->
      <p>该钩子的缺省版本总是返回参数值<code>rclass</code>。

     <!-- You can also use @code{TARGET_PREFERRED_OUTPUT_RELOAD_CLASS} to discourage -->
     <!-- reload from using some alternatives, like @code{TARGET_PREFERRED_RELOAD_CLASS}. -->
      <p>类似于<code>TARGET_PREFERRED_RELOAD_CLASS</code>，你还可以使用<code>TARGET_PREFERRED_OUTPUT_RELOAD_CLASS</code>来不鼓励使用一些可选项进行重载。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIMIT_RELOAD_CLASS</b> (<var>mode, class</var>)<var><a name="index-LIMIT_005fRELOAD_005fCLASS-4024"></a></var><br>
<blockquote><!-- A C expression that places additional restrictions on the register class -->
     <!-- to use when it is necessary to be able to hold a value of mode -->
     <!-- @var{mode} in a reload register for which class @var{class} would -->
     <!-- ordinarily be used. -->
      <p>一个C表达式，用于当需要在类别为<var>class</var>的重载寄存器中存放机器模式为<var>mode</var>的值的时候，对寄存器类别实施额外的限制。

     <!-- Unlike @code{PREFERRED_RELOAD_CLASS}, this macro should be used when -->
     <!-- there are certain modes that simply can't go in certain reload classes. -->
      <p>不像<code>PREFERRED_RELOAD_CLASS</code>，该宏应该用于当有特定的机器模式不能简单的放入特定的重载类别中的时候。

     <!-- The value is a register class; perhaps @var{class}, or perhaps another, -->
     <!-- smaller class. -->
      <p>值为一个寄存器类别；可能为<var>class</var>，或者其它更小的类别。

     <!-- Don't define this macro unless the target machine has limitations which -->
     <!-- require the macro to do something nontrivial. -->
      <p>除非目标机器具有一些限制，需要使用该宏来做一些事情，否则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: reg_class_t <b>TARGET_SECONDARY_RELOAD</b> (<var>bool in_p, rtx x, reg_class_t reload_class, enum machine_mode reload_mode, secondary_reload_info *sri</var>)<var><a name="index-TARGET_005fSECONDARY_005fRELOAD-4025"></a></var><br>
<blockquote><!-- Many machines have some registers that cannot be copied directly to or -->
     <!-- from memory or even from other types of registers.  An example is the -->
     <!-- @samp{MQ} register, which on most machines, can only be copied to or -->
     <!-- from general registers, but not memory.  Below, we shall be using the -->
     <!-- term 'intermediate register' when a move operation cannot be performed -->
     <!-- directly, but has to be done by copying the source into the intermediate -->
     <!-- register first, and then copying the intermediate register to the -->
     <!-- destination.  An intermediate register always has the same mode as -->
     <!-- source and destination.  Since it holds the actual value being copied, -->
     <!-- reload might apply optimizations to re-use an intermediate register -->
     <!-- and eliding the copy from the source when it can determine that the -->
     <!-- intermediate register still holds the required value. -->
      <p>许多机器具有一些寄存器，其不能直接和内存之间，甚至不能和其它类型的寄存器之间进行复制。例如&lsquo;<samp><span class="samp">MQ</span></samp>&rsquo;寄存器，在大多数机器上，只能与通用寄存器之间直接进行复制，而不能和内存之间直接进行复制。下面，我们将用到术语‘中间寄存器（intermediate register）’。当一个move操作不能直接执行，则必须首先通过将源复制到中间寄存器中，然后再从中间寄存器复制到目的。中间寄存器总是具有与源和目的相同的机器模式。由于其存放了被复制的实际的值，所以，当它可以确定中间寄存器还保留着所需要的值的时候，重载可以进行优化来重用一个中间寄存器，并且省略掉从源进行复制的操作。

     <!-- Another kind of secondary reload is required on some machines which -->
     <!-- allow copying all registers to and from memory, but require a scratch -->
     <!-- register for stores to some memory locations (e.g., those with symbolic -->
     <!-- address on the RT, and those with certain symbolic address on the SPARC -->
     <!-- when compiling PIC)@.  Scratch registers need not have the same mode -->
     <!-- as the value being copied, and usually hold a different value than -->
     <!-- that being copied.  Special patterns in the md file are needed to -->
     <!-- describe how the copy is performed with the help of the scratch register; -->
     <!-- these patterns also describe the number, register class(es) and mode(s) -->
     <!-- of the scratch register(s). -->
      <p>另一种需要执行二次重载的情况是，在一些机器上，其允许所有的寄存器和内存之间进行复制，但要求一个草稿（scratch）寄存器来存储一些内存的位置（例如，在RT上那些具有符号地址的，以及在SPARC上当编译PIC时那些具有特定符号地址的）。草稿寄存器不需要与被复制的值具有相同的机器模式，并且通常保留一个不同的值。在md文件中需要特殊的指令模式来描述复制在草稿寄存器的帮助下如何执行；这些指令模式还描述了草稿寄存器的编号，寄存器类别和机器模式。

     <!-- In some cases, both an intermediate and a scratch register are required. -->
      <p>在一些情况下，会同时需要中间寄存器和草稿寄存器。

     <!-- For input reloads, this target hook is called with nonzero @var{in_p}, -->
     <!-- and @var{x} is an rtx that needs to be copied to a register of class -->
     <!-- @var{reload_class} in @var{reload_mode}.  For output reloads, this target -->
     <!-- hook is called with zero @var{in_p}, and a register of class @var{reload_class} -->
     <!-- needs to be copied to rtx @var{x} in @var{reload_mode}. -->
      <p>对于输入重载，调用该目标钩子时，使用非零的<var>in_p</var>，并且<var>x</var>为一个rtx，其需要被复制到一个类别为<var>reload_class</var>，机器模式为<var>reload_mode</var>的寄存器中。对于输出重载，调用该目标钩子时，使用值为0的<var>in_p</var>，以及一个类别为<var>reload_class</var>的寄存器，其需要被复制到机器模式为<var>reload_mode</var>的rtx <var>x</var>中。

     <!-- If copying a register of @var{reload_class} from/to @var{x} requires -->
     <!-- an intermediate register, the hook @code{secondary_reload} should -->
     <!-- return the register class required for this intermediate register. -->
     <!-- If no intermediate register is required, it should return NO_REGS. -->
     <!-- If more than one intermediate register is required, describe the one -->
     <!-- that is closest in the copy chain to the reload register. -->
      <p>如果在类别为<var>reload_class</var>的寄存器和<var>x</var>之间直接进行复制需要一个中间寄存器，则钩子<code>secondary_reload</code>应该返回一个该中间寄存器所需要的寄存器类别。如果不需要中间寄存器，则其应该返回NO_REGS。如果需要多个中间寄存器，则描述在复制链中最近的那个。

     <!-- If scratch registers are needed, you also have to describe how to -->
     <!-- perform the copy from/to the reload register to/from this -->
     <!-- closest intermediate register.  Or if no intermediate register is -->
     <!-- required, but still a scratch register is needed, describe the -->
     <!-- copy  from/to the reload register to/from the reload operand @var{x}. -->
      <p>如果需要草稿寄存器，则还要描述如何在重载寄存器和这个最近的中间寄存器之间直接进行复制。或者如果不需要中间寄存器，但仍然需要一个草稿寄存器，则描述重载寄存器和重载操作数<var>x</var>之间的复制。

     <!-- You do this by setting @code{sri->icode} to the instruction code of a pattern -->
     <!-- in the md file which performs the move.  Operands 0 and 1 are the output -->
     <!-- and input of this copy, respectively.  Operands from operand 2 onward are -->
     <!-- for scratch operands.  These scratch operands must have a mode, and a -->
     <!-- single-register-class -->
     <!-- @c [later: or memory] -->
     <!-- output constraint. -->
      <p>为此，你需要设置<code>sri-&gt;icode</code>为在md文件中执行move的指令模式的代码。操作数0和1分别为该复制的输出和输入。从2以后的操作数为草稿操作数。这些草稿操作数必须具有机器模式并且一个single-register-class的输出约束。

     <!-- When an intermediate register is used, the @code{secondary_reload} -->
     <!-- hook will be called again to determine how to copy the intermediate -->
     <!-- register to/from the reload operand @var{x}, so your hook must also -->
     <!-- have code to handle the register class of the intermediate operand. -->
      <p>当使用中间寄存器的时候，<code>secondary_reload</code>钩子将会被再次调用，来确定如何在中间寄存器和重载操作数之间进行复制，所以你的钩子必须还要具有处理中间操作数的寄存器类别的代码。

     <!-- [For later: maybe we'll allow multi-alternative reload patterns - -->
     <!-- the port maintainer could name a mov<mode> pattern that has clobbers - -->
     <!-- and match the constraints of input and output to determine the required -->
     <!-- alternative.  A restriction would be that constraints used to match -->
     <!-- against reloads registers would have to be written as register class -->
     <!-- constraints, or we need a new target macro / hook that tells us if an -->
     <!-- arbitrary constraint can match an unknown register of a given class. -->
     <!-- Such a macro / hook would also be useful in other places.] -->
     <!-- @var{x} might be a pseudo-register or a @code{subreg} of a -->
     <!-- pseudo-register, which could either be in a hard register or in memory. -->
     <!-- Use @code{true_regnum} to find out; it will return @minus{}1 if the pseudo is -->
     <!-- in memory and the hard register number if it is in a register. -->
      <p><var>x</var>可以为伪寄存器或者一个伪寄存器的<code>subreg</code>，其可以为一个硬件寄存器或者在内存中。使用<code>true_regnum</code>来查看；其将返回-1如果伪寄存器在内存中，以及硬件寄存器编号，如果其在一个寄存器中。

     <!-- Scratch operands in memory (constraint @code{"=m"} / @code{"=&m"}) are -->
     <!-- currently not supported.  For the time being, you will have to continue -->
     <!-- to use @code{SECONDARY_MEMORY_NEEDED} for that purpose. -->
      <p>在内存中的草稿操作数（约束<code>"=m"</code> / <code>"=&amp;m"</code>）目前不被支持。为此，目前你必须继续使用<code>SECONDARY_MEMORY_NEEDED</code>。

     <!-- @code{copy_cost} also uses this target hook to find out how values are -->
     <!-- copied.  If you want it to include some extra cost for the need to allocate -->
     <!-- (a) scratch register(s), set @code{sri->extra_cost} to the additional cost. -->
     <!-- Or if two dependent moves are supposed to have a lower cost than the sum -->
     <!-- of the individual moves due to expected fortuitous scheduling and/or special -->
     <!-- forwarding logic, you can set @code{sri->extra_cost} to a negative amount. -->
      <p><code>copy_cost</code>还是要该target钩子来查找值如何被复制。如果你想让其包含像分配草稿寄存器所需要的额外代价，则可以设置<code>sri-&gt;extra_cost</code>为额外代价。或者如果两个相关move会具有比两个单个move之和的代价要低，则可以设置<code>sri-&gt;extra_cost</code>为一个负数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SECONDARY_RELOAD_CLASS</b> (<var>class, mode, x</var>)<var><a name="index-SECONDARY_005fRELOAD_005fCLASS-4026"></a></var><br>
&mdash; Macro: <b>SECONDARY_INPUT_RELOAD_CLASS</b> (<var>class, mode, x</var>)<var><a name="index-SECONDARY_005fINPUT_005fRELOAD_005fCLASS-4027"></a></var><br>
&mdash; Macro: <b>SECONDARY_OUTPUT_RELOAD_CLASS</b> (<var>class, mode, x</var>)<var><a name="index-SECONDARY_005fOUTPUT_005fRELOAD_005fCLASS-4028"></a></var><br>
<blockquote><!-- These macros are obsolete, new ports should use the target hook -->
     <!-- @code{TARGET_SECONDARY_RELOAD} instead. -->
      <p>这些宏已经被废弃了，新的移植应该使用目标钩子<code>TARGET_SECONDARY_RELOAD</code>。

     <!-- These are obsolete macros, replaced by the @code{TARGET_SECONDARY_RELOAD} -->
     <!-- target hook.  Older ports still define these macros to indicate to the -->
     <!-- reload phase that it may -->
     <!-- need to allocate at least one register for a reload in addition to the -->
     <!-- register to contain the data.  Specifically, if copying @var{x} to a -->
     <!-- register @var{class} in @var{mode} requires an intermediate register, -->
     <!-- you were supposed to define @code{SECONDARY_INPUT_RELOAD_CLASS} to return the -->
     <!-- largest register class all of whose registers can be used as -->
     <!-- intermediate registers or scratch registers. -->
     <!-- If copying a register @var{class} in @var{mode} to @var{x} requires an -->
     <!-- intermediate or scratch register, @code{SECONDARY_OUTPUT_RELOAD_CLASS} -->
     <!-- was supposed to be defined be defined to return the largest register -->
     <!-- class required.  If the -->
     <!-- requirements for input and output reloads were the same, the macro -->
     <!-- @code{SECONDARY_RELOAD_CLASS} should have been used instead of defining both -->
     <!-- macros identically. -->
     <!-- The values returned by these macros are often @code{GENERAL_REGS}. -->
     <!-- Return @code{NO_REGS} if no spare register is needed; i.e., if @var{x} -->
     <!-- can be directly copied to or from a register of @var{class} in -->
     <!-- @var{mode} without requiring a scratch register.  Do not define this -->
     <!-- macro if it would always return @code{NO_REGS}. -->
     <!-- If a scratch register is required (either with or without an -->
     <!-- intermediate register), you were supposed to define patterns for -->
     <!-- @samp{reload_in@var{m}} or @samp{reload_out@var{m}}, as required -->
     <!-- (@pxref{Standard Names}.  These patterns, which were normally -->
     <!-- implemented with a @code{define_expand}, should be similar to the -->
     <!-- @samp{mov@var{m}} patterns, except that operand 2 is the scratch -->
     <!-- register. -->
     <!-- These patterns need constraints for the reload register and scratch -->
     <!-- register that -->
     <!-- contain a single register class.  If the original reload register (whose -->
     <!-- class is @var{class}) can meet the constraint given in the pattern, the -->
     <!-- value returned by these macros is used for the class of the scratch -->
     <!-- register.  Otherwise, two additional reload registers are required. -->
     <!-- Their classes are obtained from the constraints in the insn pattern. -->
     <!-- @var{x} might be a pseudo-register or a @code{subreg} of a -->
     <!-- pseudo-register, which could either be in a hard register or in memory. -->
     <!-- Use @code{true_regnum} to find out; it will return @minus{}1 if the pseudo is -->
     <!-- in memory and the hard register number if it is in a register. -->
     <!-- These macros should not be used in the case where a particular class of -->
     <!-- registers can only be copied to memory and not to another class of -->
     <!-- registers.  In that case, secondary reload registers are not needed and -->
     <!-- would not be helpful.  Instead, a stack location must be used to perform -->
     <!-- the copy and the @code{mov@var{m}} pattern should use memory as an -->
     <!-- intermediate storage.  This case often occurs between floating-point and -->
     <!-- general registers. -->
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>SECONDARY_MEMORY_NEEDED</b> (<var>class1, class2, m</var>)<var><a name="index-SECONDARY_005fMEMORY_005fNEEDED-4029"></a></var><br>
<blockquote><!-- Certain machines have the property that some registers cannot be copied -->
     <!-- to some other registers without using memory.  Define this macro on -->
     <!-- those machines to be a C expression that is nonzero if objects of mode -->
     <!-- @var{m} in registers of @var{class1} can only be copied to registers of -->
     <!-- class @var{class2} by storing a register of @var{class1} into memory -->
     <!-- and loading that memory location into a register of @var{class2}. -->
      <p>一些机器要求某些寄存器必须借助内存才能与其它寄存器之间进行复制。在那些机器上，定义该宏为一个C表达式，如果在类别为<var>class1</var>的寄存器中机器模式为<var>m</var>的对象，只能通过将<var>class1</var>的寄存器存储到内存中并且将内存位置加载到<var>class2</var>的寄存中，则为非0。

     <!-- Do not define this macro if its value would always be zero. -->
      <p>如果其值总是为0，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SECONDARY_MEMORY_NEEDED_RTX</b> (<var>mode</var>)<var><a name="index-SECONDARY_005fMEMORY_005fNEEDED_005fRTX-4030"></a></var><br>
<blockquote><!-- Normally when @code{SECONDARY_MEMORY_NEEDED} is defined, the compiler -->
     <!-- allocates a stack slot for a memory location needed for register copies. -->
     <!-- If this macro is defined, the compiler instead uses the memory location -->
     <!-- defined by this macro. -->
      <p>通常当<code>SECONDARY_MEMORY_NEEDED</code>被定义时，编译器会为寄存器复制所需要的内存位置分配一个栈槽。如果该宏被定义，则编译器会使用该宏定义的内存位置。

     <!-- Do not define this macro if you do not define -->
     <!-- @code{SECONDARY_MEMORY_NEEDED}. -->
      <p>如果没有定义<code>SECONDARY_MEMORY_NEEDED</code>，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SECONDARY_MEMORY_NEEDED_MODE</b> (<var>mode</var>)<var><a name="index-SECONDARY_005fMEMORY_005fNEEDED_005fMODE-4031"></a></var><br>
<blockquote><!-- When the compiler needs a secondary memory location to copy between two -->
     <!-- registers of mode @var{mode}, it normally allocates sufficient memory to -->
     <!-- hold a quantity of @code{BITS_PER_WORD} bits and performs the store and -->
     <!-- load operations in a mode that many bits wide and whose class is the -->
     <!-- same as that of @var{mode}. -->
      <p>当编译器在机器模式为<var>mode</var>的寄存器之间进行复制需要一个次级内存位置的时候，其通常会分配足够的内存来存放<code>BITS_PER_WORD</code>个位，并且执行该位数宽度的，机器模式为<var>mode</var>的存储和加载操作。

     <!-- This is right thing to do on most machines because it ensures that all -->
     <!-- bits of the register are copied and prevents accesses to the registers -->
     <!-- in a narrower mode, which some machines prohibit for floating-point -->
     <!-- registers. -->
      <p>这在大多数机器上是正确的，因为其确保寄存器的所有位被复制并且阻止对寄存器按照较窄的机器模式来访问，在一些机器上，这对于浮点寄存器通常是禁止的。

     <!-- However, this default behavior is not correct on some machines, such as -->
     <!-- the DEC Alpha, that store short integers in floating-point registers -->
     <!-- differently than in integer registers.  On those machines, the default -->
     <!-- widening will not work correctly and you must define this macro to -->
     <!-- suppress that widening in some cases.  See the file @file{alpha.h} for -->
     <!-- details. -->
      <p>然而，该缺省行为在一些机器上是不正确的，例如DEC Alpha，其在浮点寄存器中存储short整数与在整数寄存器中是不同的。在那些机器上，缺省的宽度将不正确，你必须定义该宏来抑制这种宽度。详情参见<samp><span class="file">alpha.h</span></samp>文件。

     <!-- Do not define this macro if you do not define -->
     <!-- @code{SECONDARY_MEMORY_NEEDED} or if widening @var{mode} to a mode that -->
     <!-- is @code{BITS_PER_WORD} bits wide is correct for your machine. -->
      <p>如果没有定义，或者如果<code>BITS_PER_WORD</code>个位数的宽度是正确的，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CLASS_LIKELY_SPILLED_P</b> (<var>reg_class_t rclass</var>)<var><a name="index-TARGET_005fCLASS_005fLIKELY_005fSPILLED_005fP-4032"></a></var><br>
<blockquote><!-- A target hook which returns @code{true} if pseudos that have been assigned -->
     <!-- to registers of class @var{rclass} would likely be spilled because -->
     <!-- registers of @var{rclass} are needed for spill registers. -->
      <p>一个目标钩子，如果伪寄存器已经被分配成类别为<var>rclass</var>的寄存器，在当类别为<var>rclass</var>的寄存器需要用作溢出寄存器的时候，该伪寄存器很可能被溢出，则返回<code>true</code>。

     <!-- The default version of this target hook returns @code{true} if @var{rclass} -->
     <!-- has exactly one register and @code{false} otherwise.  On most machines, this -->
     <!-- default should be used.  Only use this target hook to some other expression -->
     <!-- if pseudos allocated by @file{local-alloc.c} end up in memory because their -->
     <!-- hard registers were needed for spill registers.  If this target hook returns -->
     <!-- @code{false} for those classes, those pseudos will only be allocated by -->
     <!-- @file{global.c}, which knows how to reallocate the pseudo to another -->
     <!-- register.  If there would not be another register available for reallocation, -->
     <!-- you should not change the implementation of this target hook since -->
     <!-- the only effect of such implementation would be to slow down register -->
     <!-- allocation. -->
      </blockquote></div>

<div class="defun">
&mdash; Target Hook: unsigned char <b>TARGET_CLASS_MAX_NREGS</b> (<var>reg_class_t rclass, enum machine_mode mode</var>)<var><a name="index-TARGET_005fCLASS_005fMAX_005fNREGS-4033"></a></var><br>
<blockquote><p>A target hook returns the maximum number of consecutive registers
of class <var>rclass</var> needed to hold a value of mode <var>mode</var>.

      <p>This is closely related to the macro <code>HARD_REGNO_NREGS</code>.  In fact,
the value returned by <code>TARGET_CLASS_MAX_NREGS (</code><var>rclass</var><code>,
</code><var>mode</var><code>)</code> target hook should be the maximum value of
<code>HARD_REGNO_NREGS (</code><var>regno</var><code>, </code><var>mode</var><code>)</code> for all <var>regno</var>
values in the class <var>rclass</var>.

      <p>This target hook helps control the handling of multiple-word values
in the reload pass.

      <p>The default version of this target hook returns the size of <var>mode</var>
in words. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CLASS_MAX_NREGS</b> (<var>class, mode</var>)<var><a name="index-CLASS_005fMAX_005fNREGS-4034"></a></var><br>
<blockquote><!-- A C expression for the maximum number of consecutive registers -->
     <!-- of class @var{class} needed to hold a value of mode @var{mode}. -->
      <p>一个C表达式，为需要存放机器模式为<var>mode</var>的值所需要的连续的类别为<var>class</var>的寄存器的最大数。

     <!-- This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact, -->
     <!-- the value of the macro @code{CLASS_MAX_NREGS (@var{class}, @var{mode})} -->
     <!-- should be the maximum value of @code{HARD_REGNO_NREGS (@var{regno}, -->
     <!-- @var{mode})} for all @var{regno} values in the class @var{class}. -->
      <p>这与宏<code>HARD_REGNO_NREGS</code>很相近。实际上，宏<code>CLASS_MAX_NREGS (</code><var>class</var><code>, </code><var>mode</var><code>)</code>的值应该为<code>HARD_REGNO_NREGS (</code><var>regno</var><code>,</code><var>mode</var><code>)</code>的最大值。

     <!-- This macro helps control the handling of multiple-word values -->
     <!-- in the reload pass. -->
      <p>该宏有助于在reload pass中处理多个字的值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CANNOT_CHANGE_MODE_CLASS</b> (<var>from, to, class</var>)<var><a name="index-CANNOT_005fCHANGE_005fMODE_005fCLASS-4035"></a></var><br>
<blockquote><!-- If defined, a C expression that returns nonzero for a @var{class} for which -->
     <!-- a change from mode @var{from} to mode @var{to} is invalid. -->
      <p>如果被定义，则为一个C表达式。当<var>class</var>不能从机器模式<var>from</var>转变成<var>to</var>的时候，其返回非0。

     <!-- For the example, loading 32-bit integer or floating-point objects into -->
     <!-- floating-point registers on the Alpha extends them to 64 bits. -->
     <!-- Therefore loading a 64-bit object and then storing it as a 32-bit object -->
     <!-- does not store the low-order 32 bits, as would be the case for a normal -->
     <!-- register.  Therefore, @file{alpha.h} defines @code{CANNOT_CHANGE_MODE_CLASS} -->
     <!-- as below: -->
      <p>例如，在Alpha上加载32位的整数或者浮点对象到浮点寄存器中，会将其扩展为64位。因此加载一个64位的对象，然后将其存储为32位对象时，将不会保存低32位。因此，<samp><span class="file">alpha.h</span></samp>定义<code>CANNOT_CHANGE_MODE_CLASS</code>为：

     <pre class="smallexample">          #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \
            (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \
             ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)
</pre>
      </blockquote></div>

<!-- @node Old Constraints -->
<!-- @section Obsolete Macros for Defining Constraints -->
 </body></html>

