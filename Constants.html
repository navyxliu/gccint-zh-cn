<html lang="zh">
<head>
<title>Constants - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="Machine-Modes.html#Machine-Modes" title="Machine Modes">
<link rel="next" href="Regs-and-Memory.html#Regs-and-Memory" title="Regs and Memory">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Constants"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Regs-and-Memory.html#Regs-and-Memory">Regs and Memory</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Machine-Modes.html#Machine-Modes">Machine Modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.7 常量表达式类型</h3>

<p><a name="index-RTL-constants-1975"></a><a name="index-RTL-constant-expression-types-1976"></a>
<!-- The simplest RTL expressions are those that represent constant values. -->
最简单的RTL表达式是那些对常数值的表示。

     
<a name="index-const_005fint-1977"></a>
<dl><dt><code>(const_int </code><var>i</var><code>)</code><dd><!-- This type of expression represents the integer value @var{i}.  @var{i} -->
<!-- is customarily accessed with the macro @code{INTVAL} as in -->
<!-- @code{INTVAL (@var{exp})}, which is equivalent to @code{XWINT (@var{exp}, 0)}. -->
这类表达式表示整数值<var>i</var>。<var>i</var>通常通过宏<code>INTVAL</code>来访问，<code>INTVAL (</code><var>exp</var><code>)</code>相当于<code>XWINT (</code><var>exp</var><code>, 0)</code>。

     <!-- Constants generated for modes with fewer bits than @code{HOST_WIDE_INT} -->
     <!-- must be sign extended to full width (e.g., with @code{gen_int_mode}). -->
     <p>为模式所生成的常量如果位数小于<code>HOST_WIDE_INT</code>，则必须符号扩展为全部宽度（例如，<code>gen_int_mode</code>）。

     <p><a name="index-const0_005frtx-1978"></a><a name="index-const1_005frtx-1979"></a><a name="index-const2_005frtx-1980"></a><a name="index-constm1_005frtx-1981"></a><!-- There is only one expression object for the integer value zero; it is -->
<!-- the value of the variable @code{const0_rtx}.  Likewise, the only -->
<!-- expression for integer value one is found in @code{const1_rtx}, the only -->
<!-- expression for integer value two is found in @code{const2_rtx}, and the -->
<!-- only expression for integer value negative one is found in -->
<!-- @code{constm1_rtx}.  Any attempt to create an expression of code -->
<!-- @code{const_int} and value zero, one, two or negative one will return -->
<!-- @code{const0_rtx}, @code{const1_rtx}, @code{const2_rtx} or -->
<!-- @code{constm1_rtx} as appropriate. -->
只有一个表达式对象表示整数值0；是变量<code>const0_rtx</code>的值。同样的，整数值1的唯一表达式为<code>const1_rtx</code>，整数值2的唯一表达式为<code>const2_rtx</code>，负1的唯一表达式为<code>constm1_rtx</code>。任何试图去创建值为0，1，2或者-1的<code>const_int</code>都会返回相应的<code>const0_rtx</code>, <code>const1_rtx</code>, <code>const2_rtx</code>或者<code>constm1_rtx</code>。

     <p><a name="index-const_005ftrue_005frtx-1982"></a><!-- Similarly, there is only one object for the integer whose value is -->
<!-- @code{STORE_FLAG_VALUE}.  It is found in @code{const_true_rtx}.  If -->
<!-- @code{STORE_FLAG_VALUE} is one, @code{const_true_rtx} and -->
<!-- @code{const1_rtx} will point to the same object.  If -->
<!-- @code{STORE_FLAG_VALUE} is @minus{}1, @code{const_true_rtx} and -->
<!-- @code{constm1_rtx} will point to the same object. -->
类似的，只有一个对象表示值为<code>STORE_FLAG_VALUE</code>的整数，其为<code>const_true_rtx</code>。如果<code>STORE_FLAG_VALUE</code>为1，则<code>const_true_rtx</code>和<code>const1_rtx</code>将会指向同一对象。如果<code>STORE_FLAG_VALUE</code>为-1，<code>const_true_rtx</code>和<code>constm1_rtx</code>将会指向同一对象。

     <p><a name="index-const_005fdouble-1983"></a><br><dt><code>(const_double:</code><var>m</var> <var>i0</var> <var>i1</var><code> ...)</code><dd><!-- Represents either a floating-point constant of mode @var{m} or an -->
<!-- integer constant too large to fit into @code{HOST_BITS_PER_WIDE_INT} -->
<!-- bits but small enough to fit within twice that number of bits (GCC -->
<!-- does not provide a mechanism to represent even larger constants).  In -->
<!-- the latter case, @var{m} will be @code{VOIDmode}. -->
表示或者为一个模式为<var>m</var>的浮点常量，或者为一个超过<code>HOST_BITS_PER_WIDE_INT</code>位的，但是小于其两倍的位数的整数常量（GCC并没有提供表示更大的常量的机制）。对于后者，<var>m</var>将为<code>VOIDmode</code>。

     <p><a name="index-CONST_005fDOUBLE_005fLOW-1984"></a><!-- If @var{m} is @code{VOIDmode}, the bits of the value are stored in -->
<!-- @var{i0} and @var{i1}.  @var{i0} is customarily accessed with the macro -->
<!-- @code{CONST_DOUBLE_LOW} and @var{i1} with @code{CONST_DOUBLE_HIGH}. -->
如果<var>m</var>为<code>VOIDmode</code>，则值的位数存储在<var>i0</var>和<var>i1</var>中。<var>i0</var>使用宏<code>CONST_DOUBLE_LOW</code>来访问，<var>i1</var>使用<code>CONST_DOUBLE_HIGH</code>。

     <!-- If the constant is floating point (regardless of its precision), then -->
     <!-- the number of integers used to store the value depends on the size of -->
     <!-- @code{REAL_VALUE_TYPE} (@pxref{Floating Point}).  The integers -->
     <!-- represent a floating point number, but not precisely in the target -->
     <!-- machine's or host machine's floating point format.  To convert them to -->
     <!-- the precise bit pattern used by the target machine, use the macro -->
     <!-- @code{REAL_VALUE_TO_TARGET_DOUBLE} and friends (@pxref{Data Output}). -->
     <p>如果常量为浮点（不管是什么精度），则用于存储值得整数数目取决于<code>REAL_VALUE_TYPE</code>的大小（参见<a href="Floating-Point.html#Floating-Point">Floating Point</a>）。整数表示一个浮点数，但是不如target机器的或者host机器的浮点格式那么精确。要将它们转换为target机器使用的精确的位模式，使用宏<code>REAL_VALUE_TO_TARGET_DOUBLE</code>等（参见<a href="Data-Output.html#Data-Output">Data Output</a>）。

     <p><a name="index-const_005ffixed-1985"></a><br><dt><code>(const_fixed:</code><var>m</var><code> ...)</code><dd><!-- Represents a fixed-point constant of mode @var{m}. -->
<!-- The operand is a data structure of type @code{struct fixed_value} and -->
<!-- is accessed with the macro @code{CONST_FIXED_VALUE}.  The high part of -->
<!-- data is accessed with @code{CONST_FIXED_VALUE_HIGH}; the low part is -->
<!-- accessed with @code{CONST_FIXED_VALUE_LOW}. -->
表示一个机器模式为<var>m</var>定点常量。操作数是一个类型为<code>struct fixed_value</code>数据结构，并使用宏<code>CONST_FIXED_VALUE</code>来访问。数据的高部分使用<code>CONST_FIXED_VALUE_HIGH</code>来访问；低部分使用<code>CONST_FIXED_VALUE_LOW</code>来访问。

     <p><a name="index-const_005fvector-1986"></a><br><dt><code>(const_vector:</code><var>m</var><code> [</code><var>x0</var> <var>x1</var><code> ...])</code><dd><!-- Represents a vector constant.  The square brackets stand for the vector -->
<!-- containing the constant elements.  @var{x0}, @var{x1} and so on are -->
<!-- the @code{const_int}, @code{const_double} or @code{const_fixed} elements. -->
表示一个向量常量。方括号代表向量包含的常量元素。<var>x0</var>，<var>x1</var>等等为<code>const_int</code>，<code>const_double</code>或者<code>const_fixed</code>元素。

     <!-- The number of units in a @code{const_vector} is obtained with the macro -->
     <!-- @code{CONST_VECTOR_NUNITS} as in @code{CONST_VECTOR_NUNITS (@var{v})}. -->
     <p>在<code>const_vector</code>中的单元数可以通过宏<code>CONST_VECTOR_NUNITS</code>来获得，形如<code>CONST_VECTOR_NUNITS (</code><var>v</var><code>)</code>。

     <!-- Individual elements in a vector constant are accessed with the macro -->
     <!-- @code{CONST_VECTOR_ELT} as in @code{CONST_VECTOR_ELT (@var{v}, @var{n})} -->
     <!-- where @var{v} is the vector constant and @var{n} is the element -->
     <!-- desired. -->
     <p>在向量常量中的单个元素使用宏<code>CONST_VECTOR_ELT</code>来访问，形如<code>CONST_VECTOR_ELT (</code><var>v</var><code>, </code><var>n</var><code>)</code>，其中<var>v</var>为向量常量，<var>n</var>为要访问的元素编号。

     <p><a name="index-const_005fstring-1987"></a><br><dt><code>(const_string </code><var>str</var><code>)</code><dd><!-- Represents a constant string with value @var{str}.  Currently this is -->
<!-- used only for insn attributes (@pxref{Insn Attributes}) since constant -->
<!-- strings in C are placed in memory. -->
表示一个具有值<var>str</var>的常量字符串。目前这只用于insn属性（参见<a href="Insn-Attributes.html#Insn-Attributes">Insn Attributes</a>），因为C中的常量字符串存放在内存中。

     <p><a name="index-symbol_005fref-1988"></a><br><dt><code>(symbol_ref:</code><var>mode</var> <var>symbol</var><code>)</code><dd><!-- Represents the value of an assembler label for data.  @var{symbol} is -->
<!-- a string that describes the name of the assembler label.  If it starts -->
<!-- with a @samp{*}, the label is the rest of @var{symbol} not including -->
<!-- the @samp{*}.  Otherwise, the label is @var{symbol}, usually prefixed -->
<!-- with @samp{_}. -->
表示引用数据的汇编标号的值。<var>symbol</var>为一个字符串，描述了汇编标号的名字。如果其起始于&lsquo;<samp><span class="samp">*</span></samp>&rsquo;，则标号为<var>symbol</var>不包含&lsquo;<samp><span class="samp">*</span></samp>&rsquo;的其余部分。否则，标号为<var>symbol</var>，通常具有前缀&lsquo;<samp><span class="samp">_</span></samp>&rsquo;。

     <!-- The @code{symbol_ref} contains a mode, which is usually @code{Pmode}. -->
     <!-- Usually that is the only mode for which a symbol is directly valid. -->
     <p><code>symbol_ref</code>包含一个机器模式，其通常为<code>Pmode</code>。通常这是唯一的使得符号有效的机器模式。

     <p><a name="index-label_005fref-1989"></a><br><dt><code>(label_ref:</code><var>mode</var> <var>label</var><code>)</code><dd><!-- Represents the value of an assembler label for code.  It contains one -->
<!-- operand, an expression, which must be a @code{code_label} or a @code{note} -->
<!-- of type @code{NOTE_INSN_DELETED_LABEL} that appears in the instruction -->
<!-- sequence to identify the place where the label should go. -->
表示引用代码的汇编标号的值。其包含一个操作数，一个表达式，其必须为一个<code>code_label</code>或者一个<code>NOTE_INSN_DELETED_LABEL</code>类型的<code>note</code>，其出现在指令序列中，来标识标号应该处于的位置。

     <!-- The reason for using a distinct expression type for code label -->
     <!-- references is so that jump optimization can distinguish them. -->
     <p>对于代码标号引用，使用一个不同的表达式类型的原因是跳转优化可以区分它们。

     <!-- The @code{label_ref} contains a mode, which is usually @code{Pmode}. -->
     <!-- Usually that is the only mode for which a label is directly valid. -->
     <p><code>label_ref</code>包含了一个机器模式，其通常为<code>Pmode</code>。通常这是唯一的使得标号有效的机器模式。

     <p><a name="index-const-1990"></a><br><dt><code>(const:</code><var>m</var> <var>exp</var><code>)</code><dd><!-- Represents a constant that is the result of an assembly-time -->
<!-- arithmetic computation.  The operand, @var{exp}, is an expression that -->
<!-- contains only constants (@code{const_int}, @code{symbol_ref} and -->
<!-- @code{label_ref} expressions) combined with @code{plus} and -->
<!-- @code{minus}.  However, not all combinations are valid, since the -->
<!-- assembler cannot do arbitrary arithmetic on relocatable symbols. -->
表示一个常量，其为汇编时算术计算的结果。操作数<var>exp</var>，为一个表达式，只包含了<code>plus</code>和<code>minus</code>组合的常量（<code>const_int</code>, <code>symbol_ref</code> 和 <code>label_ref</code>表达式）。然而，并不是所有的组合都是有效的，因为汇编器不能对重定位符号做任意的算术运算。

     <p><var>m</var> should be <code>Pmode</code>. 
<var>m</var>应该为<code>Pmode</code>。

     <p><a name="index-high-1991"></a><br><dt><code>(high:</code><var>m</var> <var>exp</var><code>)</code><dd><!-- Represents the high-order bits of @var{exp}, usually a -->
<!-- @code{symbol_ref}.  The number of bits is machine-dependent and is -->
<!-- normally the number of bits specified in an instruction that initializes -->
<!-- the high order bits of a register.  It is used with @code{lo_sum} to -->
<!-- represent the typical two-instruction sequence used in RISC machines to -->
<!-- reference a global memory location. -->
表示<var>exp</var>的高位，通常为一个<code>symbol_ref</code>。位数是机器相关的并且通常为初始化一个寄存器的高位的指令所指定的位数。其和<code>lo_sum</code>一起使用来表示典型的用于RISC机器的双指令序列来引用一个全局内存位置。

     <!-- @var{m} should be @code{Pmode}. -->
     <p><var>m</var>应该为<code>Pmode</code>。

 </dl>

 <p><a name="index-CONST0_005fRTX-1992"></a><a name="index-CONST1_005fRTX-1993"></a><a name="index-CONST2_005fRTX-1994"></a><!-- The macro @code{CONST0_RTX (@var{mode})} refers to an expression with -->
<!-- value 0 in mode @var{mode}.  If mode @var{mode} is of mode class -->
<!-- @code{MODE_INT}, it returns @code{const0_rtx}.  If mode @var{mode} is of -->
<!-- mode class @code{MODE_FLOAT}, it returns a @code{CONST_DOUBLE} -->
<!-- expression in mode @var{mode}.  Otherwise, it returns a -->
<!-- @code{CONST_VECTOR} expression in mode @var{mode}.  Similarly, the macro -->
<!-- @code{CONST1_RTX (@var{mode})} refers to an expression with value 1 in -->
<!-- mode @var{mode} and similarly for @code{CONST2_RTX}.  The -->
<!-- @code{CONST1_RTX} and @code{CONST2_RTX} macros are undefined -->
<!-- for vector modes. -->
宏<code>CONST0_RTX (</code><var>mode</var><code>)</code>指定一个具有值0，机器模式为<var>mode</var>的表达式。如果<var>mode</var>为<code>MODE_INT</code>类别，则返回<code>const0_rtx</code>。如果<var>mode</var>为 <code>MODE_FLOAT</code>类别，则返回模式为<var>mode</var>的表达式<code>CONST_DOUBLE</code>。否则，其返回一个模式为<var>mode</var>的表达式<code>CONST_VECTOR</code>。类似的，宏<code>CONST1_RTX (</code><var>mode</var><code>)</code>指定一个具有值1，机器模式为<var>mode</var>的表达式，类似的对于<code>CONST2_RTX</code>。宏<code>CONST1_RTX</code>和<code>CONST2_RTX</code>对于向量模式没有定义。

<!-- @node Regs and Memory -->
<!-- @section Registers and Memory -->
 </body></html>

