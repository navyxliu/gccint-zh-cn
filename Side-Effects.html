<html lang="zh">
<head>
<title>Side Effects - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="RTL-Declarations.html#RTL-Declarations" title="RTL Declarations">
<link rel="next" href="Incdec.html#Incdec" title="Incdec">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Side-Effects"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Incdec.html#Incdec">Incdec</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="RTL-Declarations.html#RTL-Declarations">RTL Declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.15 副作用表达式</h3>

<p><a name="index-RTL-side-effect-expressions-2183"></a>
<!-- The expression codes described so far represent values, not actions. -->
<!-- But machine instructions never produce values; they are meaningful -->
<!-- only for their side effects on the state of the machine.  Special -->
<!-- expression codes are used to represent side effects. -->
目前为止，所描述的表达式代码都是用来表示一个值，而不是操作。但是机器指令是不会产生值的，而只是通过副作用来改变机器状态。特定的表达式代码被用来表示副作用。

<!-- The body of an instruction is always one of these side effect codes; -->
<!-- the codes described above, which represent values, appear only as -->
<!-- the operands of these. -->
 <p>一条指令的主体，总是这些副作用代码之一；上面描述的表示值的代码，只是作为操作数出现在其中。

     
<a name="index-set-2184"></a>
<dl><dt><code>(set </code><var>lval</var> <var>x</var><code>)</code><dd><!-- Represents the action of storing the value of @var{x} into the place -->
<!-- represented by @var{lval}.  @var{lval} must be an expression -->
<!-- representing a place that can be stored in: @code{reg} (or @code{subreg}, -->
<!-- @code{strict_low_part} or @code{zero_extract}), @code{mem}, @code{pc}, -->
<!-- @code{parallel}, or @code{cc0}. -->
表示将<var>x</var>的值存放到由<var>lval</var>表示的地方。<var>lval</var>必须是表示可以用来存放的地方的表达式：<code>reg</code>（或者<code>subreg</code>，<code>strict_low_part</code>或者<code>zero_extract</code>），<code>mem</code>，<code>pc</code>，<code>parallel</code>或者<code>cc0</code>。

     <!-- If @var{lval} is a @code{reg}, @code{subreg} or @code{mem}, it has a -->
     <!-- machine mode; then @var{x} must be valid for that mode. -->
     <p>如果<var>lval</var>是一个<code>reg</code>，<code>subreg</code>或者<code>mem</code>，其具有一个机器模式；则<var>x</var>必须对这种模式有效。

     <p>If <var>lval</var> is a <code>reg</code> whose machine mode is less than the full
width of the register, then it means that the part of the register
specified by the machine mode is given the specified value and the
rest of the register receives an undefined value.  Likewise, if
<var>lval</var> is a <code>subreg</code> whose machine mode is narrower than
the mode of the register, the rest of the register can be changed in
an undefined way.

     <!-- If @var{lval} is a @code{strict_low_part} of a subreg, then the part -->
     <!-- of the register specified by the machine mode of the @code{subreg} is -->
     <!-- given the value @var{x} and the rest of the register is not changed. -->
     <p>如果<var>lval</var>是一个<code>subreg</code>的<code>strict_low_part</code>，则由<code>subreg</code>的机器模式所指定的寄存器的那部分被赋予值<var>x</var>，而寄存器的其它部分不变。

     <!-- If @var{lval} is a @code{zero_extract}, then the referenced part of -->
     <!-- the bit-field (a memory or register reference) specified by the -->
     <!-- @code{zero_extract} is given the value @var{x} and the rest of the -->
     <!-- bit-field is not changed.  Note that @code{sign_extract} can not -->
     <!-- appear in @var{lval}. -->
     <p>如果<var>lval</var>是一个<code>zero_extract</code>，则由<code>zero_extract</code>指定的相关位域（内存或者寄存器相关的），被赋予值<var>x</var>，而其它位域不变。注意<code>sign_extract</code>不能出现在<var>lval</var>中。

     <!-- If @var{lval} is @code{(cc0)}, it has no machine mode, and @var{x} may -->
     <!-- be either a @code{compare} expression or a value that may have any mode. -->
     <!-- The latter case represents a ``test'' instruction.  The expression -->
     <!-- @code{(set (cc0) (reg:@var{m} @var{n}))} is equivalent to -->
     <!-- @code{(set (cc0) (compare (reg:@var{m} @var{n}) (const_int 0)))}. -->
     <!-- Use the former expression to save space during the compilation. -->
     <p>如果<var>lval</var>是<code>(cc0)</code>，其没有机器模式，并且<var>x</var>可以为一个<code>compare</code>表达式或者任意模式的值。后者情况表示是一个“test”指令。表达式<code>(set (cc0) (reg:</code><var>m</var> <var>n</var><code>))</code> 等价于<code>(set (cc0) (compare (reg:</code><var>m</var> <var>n</var><code>)))</code>。在编译过程中可以使用前一个表达式来节省空间。

     <!-- If @var{lval} is a @code{parallel}, it is used to represent the case of -->
     <!-- a function returning a structure in multiple registers.  Each element -->
     <!-- of the @code{parallel} is an @code{expr_list} whose first operand is a -->
     <!-- @code{reg} and whose second operand is a @code{const_int} representing the -->
     <!-- offset (in bytes) into the structure at which the data in that register -->
     <!-- corresponds.  The first element may be null to indicate that the structure -->
     <!-- is also passed partly in memory. -->
     <p>如果<var>lval</var>是一个<code>parallel</code>，其用来表示一个函数通过多个寄存器来返回一个结构体的情况。<code>parallel</code>中的每一个元素是一个<code>expr_list</code>，其第一个操作数是一个<code>reg</code>，并且第二个操作数是一个<code>const_int</code>，表示相应寄存器的数据在结构体中的偏移量（以字节为单位）。第一个元素也可能为null，用来指示结构体也有一部分是在内存中传递的。

     <p><a name="index-jump-instructions-and-_0040code_007bset_007d-2185"></a><a name="index-g_t_0040code_007bif_005fthen_005felse_007d-usage-2186"></a><!-- If @var{lval} is @code{(pc)}, we have a jump instruction, and the -->
<!-- possibilities for @var{x} are very limited.  It may be a -->
<!-- @code{label_ref} expression (unconditional jump).  It may be an -->
<!-- @code{if_then_else} (conditional jump), in which case either the -->
<!-- second or the third operand must be @code{(pc)} (for the case which -->
<!-- does not jump) and the other of the two must be a @code{label_ref} -->
<!-- (for the case which does jump).  @var{x} may also be a @code{mem} or -->
<!-- @code{(plus:SI (pc) @var{y})}, where @var{y} may be a @code{reg} or a -->
<!-- @code{mem}; these unusual patterns are used to represent jumps through -->
<!-- branch tables. -->
如果<var>lval</var>是<code>(pc)</code>，则为一个跳转指令，并且<var>x</var>只有几种可能。其可能为一个<code>label_ref</code>表达式（无条件跳转）。可能为一个<code>if_then_else</code>（条件跳转），这种情况下，第二个或者第三个操作数必须是<code>(pc)</code>（用于不进行跳转的情况），并且另外两个必须是一个<code>label_ref</code>（用于进行跳转的情况）。<var>x</var>也可以是一个<code>mem</code>或者<code>(plus:SI (pc) </code><var>y</var><code>)</code>, 其中y可以为一个<code>reg</code>或者<code>mem</code>；这些独特的模式用来表示通过分支表来进行跳转。

     <!-- If @var{lval} is neither @code{(cc0)} nor @code{(pc)}, the mode of -->
     <!-- @var{lval} must not be @code{VOIDmode} and the mode of @var{x} must be -->
     <!-- valid for the mode of @var{lval}. -->
     <p>如果<var>lval</var>即不是<code>(cc0)</code>也不是<code>(pc)</code>,则<var>lval</var>的模式一定不是<code>VOIDmode</code>，并且<var>x</var>的模式必须对于<var>lval</var>的模式有效。

     <p><a name="index-SET_005fDEST-2187"></a><a name="index-SET_005fSRC-2188"></a><!-- @var{lval} is customarily accessed with the @code{SET_DEST} macro and -->
<!-- @var{x} with the @code{SET_SRC} macro. -->
<var>lval</var>通常通过<code>SET_DEST</code>宏来访问，<var>x</var>通常使用<code>SET_SRC</code>宏。

     <p><a name="index-return-2189"></a><br><dt><code>(return)</code><dd><!-- As the sole expression in a pattern, represents a return from the -->
<!-- current function, on machines where this can be done with one -->
<!-- instruction, such as VAXen.  On machines where a multi-instruction -->
<!-- ``epilogue'' must be executed in order to return from the function, -->
<!-- returning is done by jumping to a label which precedes the epilogue, and -->
<!-- the @code{return} expression code is never used. -->
在指令模式中作为单独的表达式，表示从当前函数的一个返回，在一些机器上，可以使用一条指令来完成，例如VAXen。在一些机器上，为了从函数中返回，包括多条指令的尾声必须被执行，则返回操作，通过跳转到一个位于尾声之前的标号来完成，并且不使用<code>return</code>表达式代码。

     <!-- Inside an @code{if_then_else} expression, represents the value to be -->
     <!-- placed in @code{pc} to return to the caller. -->
     <p>在<code>if_then_else</code>表达式中，表示放在<code>pc</code>中的，返回给调用者的值。

     <!-- Note that an insn pattern of @code{(return)} is logically equivalent to -->
     <!-- @code{(set (pc) (return))}, but the latter form is never used. -->
     <p>注意，指令模式为<code>(return)</code>的insn，在逻辑上等价于<code>(set (pc) (return))</code>，但是不使用后者的形式。

     <p><a name="index-simple_005freturn-2190"></a><br><dt><code>(simple_return)</code><dd>Like <code>(return)</code>, but truly represents only a function return, while
<code>(return)</code> may represent an insn that also performs other functions
of the function epilogue.  Like <code>(return)</code>, this may also occur in
conditional jumps.

     <p><a name="index-call-2191"></a><br><dt><code>(call </code><var>function</var> <var>nargs</var><code>)</code><dd><!-- Represents a function call.  @var{function} is a @code{mem} expression -->
<!-- whose address is the address of the function to be called. -->
<!-- @var{nargs} is an expression which can be used for two purposes: on -->
<!-- some machines it represents the number of bytes of stack argument; on -->
<!-- others, it represents the number of argument registers. -->
表示一个函数调用。<var>function</var>为一个<code>mem</code>表达式，其地址为被调用的函数的地址。<var>nargs</var>为一个表达式，其可以用于两个目的：在一些机器上，其表示栈参数的字节数目；在其它机器上，其表示参数寄存器的数目。

     <!-- Each machine has a standard machine mode which @var{function} must -->
     <!-- have.  The machine description defines macro @code{FUNCTION_MODE} to -->
     <!-- expand into the requisite mode name.  The purpose of this mode is to -->
     <!-- specify what kind of addressing is allowed, on machines where the -->
     <!-- allowed kinds of addressing depend on the machine mode being -->
     <!-- addressed. -->
     <p>每个机器具有一个标准的，<var>function</var>必须具有的机器模式。机器描述定义了宏<code>FUNCTION_MODE</code>，来扩展为需要的模式名。在一些机器上，所允许的寻址方式取决于被寻址的机器模式，则该机器模式的用途是来描述，允许什么样的寻址。

     <p><a name="index-clobber-2192"></a><br><dt><code>(clobber </code><var>x</var><code>)</code><dd><!-- Represents the storing or possible storing of an unpredictable, -->
<!-- undescribed value into @var{x}, which must be a @code{reg}, -->
<!-- @code{scratch}, @code{parallel} or @code{mem} expression. -->
表示一个不可预期的存储或者可能的存储，将不可描述的值存储到<var>x</var>，其必须为一个<code>reg</code>，<code>scratch</code>, <code>parallel</code> 或者 <code>mem</code>表达式。

     <!-- One place this is used is in string instructions that store standard -->
     <!-- values into particular hard registers.  It may not be worth the -->
     <!-- trouble to describe the values that are stored, but it is essential to -->
     <!-- inform the compiler that the registers will be altered, lest it -->
     <!-- attempt to keep data in them across the string instruction. -->
     <p>可以用在字符串指令中，将标准的值存储到特定的硬件寄存器中。不需要去描述被存储的值，只用来告诉编译器寄存器被修改了，以免其尝试在字符串指令中保持数据。

     <!-- If @var{x} is @code{(mem:BLK (const_int 0))} or -->
     <!-- @code{(mem:BLK (scratch))}, it means that all memory -->
     <!-- locations must be presumed clobbered.  If @var{x} is a @code{parallel}, -->
     <!-- it has the same meaning as a @code{parallel} in a @code{set} expression. -->
     <p>如果<var>x</var>为<code>(mem:BLK (const_int 0))</code>或者<code>(mem:BLK (scratch))</code>，则意味着所有的内存位置必须假设被破坏。如果<var>x</var>为一个<code>parallel</code>，其具有与<code>set</code>表达式中的<code>parallel</code>相同的含义。

     <!-- Note that the machine description classifies certain hard registers as -->
     <!-- ``call-clobbered''.  All function call instructions are assumed by -->
     <!-- default to clobber these registers, so there is no need to use -->
     <!-- @code{clobber} expressions to indicate this fact.  Also, each function -->
     <!-- call is assumed to have the potential to alter any memory location, -->
     <!-- unless the function is declared @code{const}. -->
     <p>注意，机器描述将特定的硬件寄存器归类为“call-clobbered”。所有函数调用指令都被假设为，缺省的，会破坏这些寄存器，所以不需要使用<code>clobber</code>表达式来表示这些。而且，每个函数调用都被假设为潜在的修改任何内存位置，除非函数被声明为<code>const</code>。

     <!-- If the last group of expressions in a @code{parallel} are each a -->
     <!-- @code{clobber} expression whose arguments are @code{reg} or -->
     <!-- @code{match_scratch} (@pxref{RTL Template}) expressions, the combiner -->
     <!-- phase can add the appropriate @code{clobber} expressions to an insn it -->
     <!-- has constructed when doing so will cause a pattern to be matched. -->
     <p>如果在<code>parallel</code>中的最后一组表达式为<code>clobber</code>表达式，其参数为<code>reg</code>或者<code>match_scratch</code>（参见<a href="RTL-Template.html#RTL-Template">RTL Template</a>）表达式，则合并阶段可以向构建的insn中增加适当的<code>clobber</code>表达式，当这样可以使得指令模式被匹配。

     <!-- This feature can be used, for example, on a machine that whose multiply -->
     <!-- and add instructions don't use an MQ register but which has an -->
     <!-- add-accumulate instruction that does clobber the MQ register.  Similarly, -->
     <!-- a combined instruction might require a temporary register while the -->
     <!-- constituent instructions might not. -->
     <p>例如，该特点可以用在，乘法和加法指令不使用MQ寄存器，但具有一个加法累加指令，而且破坏MQ寄存器的机器上。类似的，被合并的指令可能需要临时的寄存器，而成员指令则不需要。

     <!-- When a @code{clobber} expression for a register appears inside a -->
     <!-- @code{parallel} with other side effects, the register allocator -->
     <!-- guarantees that the register is unoccupied both before and after that -->
     <!-- insn if it is a hard register clobber.  For pseudo-register clobber, -->
     <!-- the register allocator and the reload pass do not assign the same hard -->
     <!-- register to the clobber and the input operands if there is an insn -->
     <!-- alternative containing the @samp{&} constraint (@pxref{Modifiers}) for -->
     <!-- the clobber and the hard register is in register classes of the -->
     <!-- clobber in the alternative.  You can clobber either a specific hard -->
     <!-- register, a pseudo register, or a @code{scratch} expression; in the -->
     <!-- latter two cases, GCC will allocate a hard register that is available -->
     <!-- there for use as a temporary. -->
     <p>当寄存器的<code>clobber</code>表达式，出现在具有其它副作用的<code>parallel</code>中，如果是硬件寄存器，则寄存器分配者来确保在insn之前和之后，该寄存器都不会被占用。对于伪寄存器的破坏，寄存器分配者和重载过程，不对clobber分配相同的硬件寄存器，以及输入操作数。你可以破坏一个特定的硬件寄存器，一个伪寄存器，或者一个<code>scratch</code>表达式；在后两种情况下，GCC将会分配一个硬件寄存器，临时使用。

     <!-- For instructions that require a temporary register, you should use -->
     <!-- @code{scratch} instead of a pseudo-register because this will allow the -->
     <!-- combiner phase to add the @code{clobber} when required.  You do this by -->
     <!-- coding (@code{clobber} (@code{match_scratch} @dots{})).  If you do -->
     <!-- clobber a pseudo register, use one which appears nowhere else-generate -->
     <!-- a new one each time.  Otherwise, you may confuse CSE@. -->
     <p>对于需要临时寄存器的指令，应该使用<code>scratch</code>，而不是伪寄存器，因为这将使得合并阶段可以在需要的时候增加<code>clobber</code>。方式为(<code>clobber</code> (<code>match_scratch</code> <small class="dots">...</small>))。如果确实是破坏了一个伪寄存器，则使用没有出现在其它地方的伪寄存器，每次生成一个新的。否则，你可能会使CSE（公共子表达式消除）迷惑。

     <!-- There is one other known use for clobbering a pseudo register in a -->
     <!-- @code{parallel}: when one of the input operands of the insn is also -->
     <!-- clobbered by the insn.  In this case, using the same pseudo register in -->
     <!-- the clobber and elsewhere in the insn produces the expected results. -->
     <p>还有一种在<code>parallel</code>中破坏伪寄存器的用法：当insn的输入操作数也被insn破坏。这种情况下，使用相同的伪寄存器。

     <p><a name="index-use-2193"></a><br><dt><code>(use </code><var>x</var><code>)</code><dd><!-- Represents the use of the value of @var{x}.  It indicates that the -->
<!-- value in @var{x} at this point in the program is needed, even though -->
<!-- it may not be apparent why this is so.  Therefore, the compiler will -->
<!-- not attempt to delete previous instructions whose only effect is to -->
<!-- store a value in @var{x}.  @var{x} must be a @code{reg} expression. -->
表示对<var>x</var>值的使用。其表示<var>x</var>中的值在程序的这个点上是被需要的，即使可能不清楚为什么。因此，如果先前的执行的作用只是将一个值存储在<var>x</var>中，则编译器将不会尝试将其删除。<var>x</var>必须为一个<code>reg</code>表达式。

     <!-- In some situations, it may be tempting to add a @code{use} of a -->
     <!-- register in a @code{parallel} to describe a situation where the value -->
     <!-- of a special register will modify the behavior of the instruction. -->
     <!-- A hypothetical example might be a pattern for an addition that can -->
     <!-- either wrap around or use saturating addition depending on the value -->
     <!-- of a special control register: -->
     <p>在一些情况下，可能会想到，在<code>parallel</code>中增加一个对寄存器的<code>use</code>，来描述特定寄存器的值将会影响指令的行为。一个假定的例子为，对于一个加法指令模式，其可以根据特定的控制寄存器的值来执行环绕或者饱和加法：

     <pre class="smallexample">          (parallel [(set (reg:SI 2) (unspec:SI [(reg:SI 3)
                                                 (reg:SI 4)] 0))
                     (use (reg:SI 1))])
</pre>
     <p class="noindent"><!-- This will not work, several of the optimizers only look at expressions -->
<!-- locally; it is very likely that if you have multiple insns with -->
<!-- identical inputs to the @code{unspec}, they will be optimized away even -->
<!-- if register 1 changes in between. -->
这将不会工作，一些优化器将只查看局部的表达式；很可能如果你有多个具有针对<code>unspec</code>相同输入的insn，它们将被优化掉，即使寄存器1中间有所改变。

     <!-- This means that @code{use} can @emph{only} be used to describe -->
     <!-- that the register is live.  You should think twice before adding -->
     <!-- @code{use} statements, more often you will want to use @code{unspec} -->
     <!-- instead.  The @code{use} RTX is most commonly useful to describe that -->
     <!-- a fixed register is implicitly used in an insn.  It is also safe to use -->
     <!-- in patterns where the compiler knows for other reasons that the result -->
     <!-- of the whole pattern is variable, such as @samp{movmem@var{m}} or -->
     <!-- @samp{call} patterns. -->
     <p>这意味着，<code>use</code>只能被用于描述寄存器是活跃的。在增加<code>use</code>语句时，你应该多思考一下，通常，你将会使用<code>unspec</code>来替代。<code>use</code> RTX最常用于描述一个隐式的用于insn的固定寄存器。还可以安全的用于，编译器知道整个指令模式的结果是可变的，这样的指令模式中，例如&lsquo;<samp><span class="samp">movmem</span><var>m</var></samp>&rsquo;或者&lsquo;<samp><span class="samp">call</span></samp>&rsquo;。

     <!-- During the reload phase, an insn that has a @code{use} as pattern -->
     <!-- can carry a reg_equal note.  These @code{use} insns will be deleted -->
     <!-- before the reload phase exits. -->
     <p>在重载阶段，具有<code>use</code>指令模式的insn可以附带一个reg_equal注解。这些<code>use</code> insn将在重载阶段退出之前被删除。

     <!-- During the delayed branch scheduling phase, @var{x} may be an insn. -->
     <!-- This indicates that @var{x} previously was located at this place in the -->
     <!-- code and its data dependencies need to be taken into account.  These -->
     <!-- @code{use} insns will be deleted before the delayed branch scheduling -->
     <!-- phase exits. -->
     <p>在延迟分支调度阶段，<var>x</var>可以为一个insn。这表示<var>x</var>之前曾经在该位置被定位，它的数据依赖需要被考虑。这些<code>use</code> insn将在延迟分支调度阶段退出之前被删除。

     <p><a name="index-parallel-2194"></a><br><dt><code>(parallel [</code><var>x0</var> <var>x1</var><code> ...])</code><dd><!-- Represents several side effects performed in parallel.  The square -->
<!-- brackets stand for a vector; the operand of @code{parallel} is a -->
<!-- vector of expressions.  @var{x0}, @var{x1} and so on are individual -->
<!-- side effect expressions-expressions of code @code{set}, @code{call}, -->
<!-- @code{return}, @code{simple_return},  @code{clobber} or @code{use}. -->
表示并行执行多个副作用。方括号表示一个向量；<code>parallel</code>的操作数为向量表达式。<var>x0</var>, <var>x1</var>等等为单独的副作用表达式，<code>set</code>, <code>call</code>, <code>return</code>, <code>simple_return</code>, <code>clobber</code> 或 <code>use</code>。

     <!-- ``In parallel'' means that first all the values used in the individual -->
     <!-- side-effects are computed, and second all the actual side-effects are -->
     <!-- performed.  For example, -->
     <p>“并行”意味着，首先所有在单个副作用中使用的值将被计算，然后，所有实际的副作用被执行。例如，

     <pre class="smallexample">          (parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
                     (set (mem:SI (reg:SI 1)) (reg:SI 1))])
</pre>
     <p class="noindent"><!-- says unambiguously that the values of hard register 1 and the memory -->
<!-- location addressed by it are interchanged.  In both places where -->
<!-- @code{(reg:SI 1)} appears as a memory address it refers to the value -->
<!-- in register 1 @emph{before} the execution of the insn. -->
清楚的说明了，将硬件寄存器1的值与其所寻址的内存中的值进行交换。在<code>(reg:SI 1)</code>作为内存地址出现的两个地方，其都是使用执行insn之前，在寄存器1中的值。

     <!-- It follows that it is @emph{incorrect} to use @code{parallel} and -->
     <!-- expect the result of one @code{set} to be available for the next one. -->
     <!-- For example, people sometimes attempt to represent a jump-if-zero -->
     <!-- instruction this way: -->
     <p>从而，如果使用<code>parallel</code>，并且期望<code>set</code>的值，可以用于下一个<code>set</code>，则是不正确的。例如，人们有时候尝试用这种方式来表示，为零则跳转的指令：

     <pre class="smallexample">          (parallel [(set (cc0) (reg:SI 34))
                     (set (pc) (if_then_else
                                  (eq (cc0) (const_int 0))
                                  (label_ref ...)
                                  (pc)))])
</pre>
     <p class="noindent"><!-- But this is incorrect, because it says that the jump condition depends -->
<!-- on the condition code value @emph{before} this instruction, not on the -->
<!-- new value that is set by this instruction. -->
但这是不正确的，因为其说明了跳转条件取决于，该指令之前的条件代码的值，而不是被该指令设置后的新值。

     <p><a name="index-peephole-optimization_002c-RTL-representation-2195"></a><!-- Peephole optimization, which takes place together with final assembly -->
<!-- code output, can produce insns whose patterns consist of a @code{parallel} -->
<!-- whose elements are the operands needed to output the resulting -->
<!-- assembler code-often @code{reg}, @code{mem} or constant expressions. -->
<!-- This would not be well-formed RTL at any other stage in compilation, -->
<!-- but it is ok then because no further optimization remains to be done. -->
<!-- However, the definition of the macro @code{NOTICE_UPDATE_CC}, if -->
<!-- any, must deal with such insns if you define any peephole optimizations. -->
与最后的汇编代码输出一起执行的窥孔优化，可以产生由<code>parallel</code>组成的insn，其元素为需要输出汇编代码的操作数，通常为<code>reg</code>, <code>mem</code>或者常量表达式。这在其它编译阶段，将不是一个好的RTL形式，但是在这里是可以的，因为已经没有其它的优化了。然而，宏<code>NOTICE_UPDATE_CC</code>的定义，如果存在，如果定义了窥孔优化，则需要处理这样的insn。

     <p><a name="index-cond_005fexec-2196"></a><br><dt><code>(cond_exec [</code><var>cond</var> <var>expr</var><code>])</code><dd><!-- Represents a conditionally executed expression.  The @var{expr} is -->
<!-- executed only if the @var{cond} is nonzero.  The @var{cond} expression -->
<!-- must not have side-effects, but the @var{expr} may very well have -->
<!-- side-effects. -->
表示一个条件执行表达式。只有当<var>cond</var>为非零时，<var>expr</var>才被执行。<var>cond</var>表达式不能具有副作用，但是<var>expr</var>可以。

     <p><a name="index-sequence-2197"></a><br><dt><code>(sequence [</code><var>insns</var><code> ...])</code><dd><!-- Represents a sequence of insns.  Each of the @var{insns} that appears -->
<!-- in the vector is suitable for appearing in the chain of insns, so it -->
<!-- must be an @code{insn}, @code{jump_insn}, @code{call_insn}, -->
<!-- @code{code_label}, @code{barrier} or @code{note}. -->
表示一个insn序列。每个出现在向量中的<var>insns</var>，都适合出现在insn链中，所以其必须为<code>insn</code>, <code>jump_insn</code>, <code>call_insn</code>, <code>code_label</code>, <code>barrier</code> 或 <code>note</code>。

     <!-- A @code{sequence} RTX is never placed in an actual insn during RTL -->
     <!-- generation.  It represents the sequence of insns that result from a -->
     <!-- @code{define_expand} @emph{before} those insns are passed to -->
     <!-- @code{emit_insn} to insert them in the chain of insns.  When actually -->
     <!-- inserted, the individual sub-insns are separated out and the -->
     <!-- @code{sequence} is forgotten. -->
     <p>在RTL生成过程中，不会在实际的insn中放入<code>sequence</code> RTX。其表示<code>define_expand</code>产生的insn序列，用来传递给<code>emit_insn</code>，从而将它们插入到insn链中。当实际被插入的时候，单独的子insn将被分离出来，<code>sequence</code>将被忽略掉。

     <!-- After delay-slot scheduling is completed, an insn and all the insns that -->
     <!-- reside in its delay slots are grouped together into a @code{sequence}. -->
     <!-- The insn requiring the delay slot is the first insn in the vector; -->
     <!-- subsequent insns are to be placed in the delay slot. -->
     <p>当延迟槽调度完成之后，insn和所有位于其延迟槽中的insn被组成一个<code>sequence</code>。需要延迟槽的insn为向量中的第一个insn；后续的insn为将被放在延迟槽中的insn。

     <!-- @code{INSN_ANNULLED_BRANCH_P} is set on an insn in a delay slot to -->
     <!-- indicate that a branch insn should be used that will conditionally annul -->
     <!-- the effect of the insns in the delay slots.  In such a case, -->
     <!-- @code{INSN_FROM_TARGET_P} indicates that the insn is from the target of -->
     <!-- the branch and should be executed only if the branch is taken; otherwise -->
     <!-- the insn should be executed only if the branch is not taken. -->
     <!-- @xref{Delay Slots}. -->
     <p><code>INSN_ANNULLED_BRANCH_P</code>用来表示分支insn将会有条件的取消延迟槽中的insn的效果。这种情况下，<code>INSN_FROM_TARGET_P</code>表示insn是来自分支的目标，并且只有当进行分支时，其才被执行；否则，insn只有当不进行分支时才被执行。参见<a href="Delay-Slots.html#Delay-Slots">Delay Slots</a>.

 </dl>

<!-- These expression codes appear in place of a side effect, as the body of -->
<!-- an insn, though strictly speaking they do not always describe side -->
<!-- effects as such: -->
 <p>这些表达式代码出现在副作用的地方，作为insn的主体，虽然严格的讲，它们并不总是描述副作用：

     
<a name="index-asm_005finput-2198"></a>
<dl><dt><code>(asm_input </code><var>s</var><code>)</code><dd><!-- Represents literal assembler code as described by the string @var{s}. -->
表示文字的汇编代码，通过字符串<var>s</var>来描述。

     <p><a name="index-unspec-2199"></a><a name="index-unspec_005fvolatile-2200"></a><br><dt><code>(unspec [</code><var>operands</var><code> ...] </code><var>index</var><code>)</code><dt><code>(unspec_volatile [</code><var>operands</var><code> ...] </code><var>index</var><code>)</code><dd><!-- Represents a machine-specific operation on @var{operands}.  @var{index} -->
<!-- selects between multiple machine-specific operations. -->
<!-- @code{unspec_volatile} is used for volatile operations and operations -->
<!-- that may trap; @code{unspec} is used for other operations. -->
表示一个机器特定的针对<var>operands</var>的操作。<var>index</var>在多个机器特定的操作之间进行选择。<code>unspec_volatile</code>用于volatile操作，并且可以有陷阱；<code>unspec</code>用于其它操作。

     <!-- These codes may appear inside a @code{pattern} of an -->
     <!-- insn, inside a @code{parallel}, or inside an expression. -->
     <p>这些代码可以出现在insn的<code>pattern</code>中，<code>parallel</code>中，或者表达式中。

     <p><a name="index-addr_005fvec-2201"></a><br><dt><code>(addr_vec:</code><var>m</var><code> [</code><var>lr0</var> <var>lr1</var><code> ...])</code><dd><!-- Represents a table of jump addresses.  The vector elements @var{lr0}, -->
<!-- etc., are @code{label_ref} expressions.  The mode @var{m} specifies -->
<!-- how much space is given to each address; normally @var{m} would be -->
<!-- @code{Pmode}. -->
表示跳转地址表。向量元素<var>lr0</var>等等，为<code>label_ref</code>表达式。机器模式<var>m</var>描述了为每个地址给定了多少空间；通常<var>m</var>为<code>Pmode</code>。

     <p><a name="index-addr_005fdiff_005fvec-2202"></a><br><dt><code>(addr_diff_vec:</code><var>m</var> <var>base</var><code> [</code><var>lr0</var> <var>lr1</var><code> ...] </code><var>min</var> <var>max</var> <var>flags</var><code>)</code><dd><!-- Represents a table of jump addresses expressed as offsets from -->
<!-- @var{base}.  The vector elements @var{lr0}, etc., are @code{label_ref} -->
<!-- expressions and so is @var{base}.  The mode @var{m} specifies how much -->
<!-- space is given to each address-difference.  @var{min} and @var{max} -->
<!-- are set up by branch shortening and hold a label with a minimum and a -->
<!-- maximum address, respectively.  @var{flags} indicates the relative -->
<!-- position of @var{base}, @var{min} and @var{max} to the containing insn -->
<!-- and of @var{min} and @var{max} to @var{base}.  See rtl.def for details. -->
表示一个跳转地址表，表示为<var>base</var>的偏移量。向量元素<var>lr0</var>等等，为<code>label_ref</code>表达式，<var>base</var>也是。机器模式<var>m</var>描述了为每个地址偏移给定的空间大小。<var>min</var>和<var>max</var>由分支缩短过程设置，分别存放了一个具有最小地址和最大地址的标号。详情参见rtl.def。

     <p><a name="index-prefetch-2203"></a><br><dt><code>(prefetch:</code><var>m</var> <var>addr</var> <var>rw</var> <var>locality</var><code>)</code><dd><!-- Represents prefetch of memory at address @var{addr}. -->
<!-- Operand @var{rw} is 1 if the prefetch is for data to be written, 0 otherwise; -->
<!-- targets that do not support write prefetches should treat this as a normal -->
<!-- prefetch. -->
<!-- Operand @var{locality} specifies the amount of temporal locality; 0 if there -->
<!-- is none or 1, 2, or 3 for increasing levels of temporal locality; -->
<!-- targets that do not support locality hints should ignore this. -->
表示对地址为<var>addr</var>的内存进行预取。如果预取的数据将被写，则操作数为<var>rw</var>，否则为0；不支持写预取的目标机，应该将其作为一个普通的预取。操作数<var>locality</var>描述了时间局部性的数量；如果没有，则为0，否则按照时间局部性的递增级别，依次为1，2或者3；不支持局部性暗示的目标机，应该忽略该项。

     <!-- This insn is used to minimize cache-miss latency by moving data into a -->
     <!-- cache before it is accessed.  It should use only non-faulting data prefetch -->
     <!-- instructions. -->
     <p>该insn用于最小化cache-miss的延迟，通过在访问数据之前将其移送到cache中。其应该只用于非故障的数据预取指令。

 </dl>

<!-- @node Incdec -->
<!-- @section Embedded Side-Effects on Addresses -->
 </body></html>

