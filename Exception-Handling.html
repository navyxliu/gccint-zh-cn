<html lang="zh">
<head>
<title>Exception Handling - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="prev" href="Frame-Layout.html#Frame-Layout" title="Frame Layout">
<link rel="next" href="Stack-Checking.html#Stack-Checking" title="Stack Checking">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Exception-Handling"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Stack-Checking.html#Stack-Checking">Stack Checking</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Frame-Layout.html#Frame-Layout">Frame Layout</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>
<hr>
</div>

<h4 class="subsection">17.10.2 对异常处理的支持</h4>

<p><a name="index-exception-handling-4076"></a>

<div class="defun">
&mdash; Macro: <b>EH_RETURN_DATA_REGNO</b> (<var>N</var>)<var><a name="index-EH_005fRETURN_005fDATA_005fREGNO-4077"></a></var><br>
<blockquote><!-- A C expression whose value is the @var{N}th register number used for -->
     <!-- data by exception handlers, or @code{INVALID_REGNUM} if fewer than -->
     <!-- @var{N} registers are usable. -->
      <p>一个C表达式，其值为第<var>N</var>个寄存器的编号，用于异常处理的数据，或者为<code>INVALID_REGNUM</code>，如果小于<var>N</var>个寄存器可用。

     <!-- The exception handling library routines communicate with the exception -->
     <!-- handlers via a set of agreed upon registers.  Ideally these registers -->
     <!-- should be call-clobbered; it is possible to use call-saved registers, -->
     <!-- but may negatively impact code size.  The target must support at least -->
     <!-- 2 data registers, but should define 4 if there are enough free registers. -->
      <p>异常处理库程序与异常处理者通过一套协定好的寄存器来通讯。理想的，这些寄存器应该为调用破坏的；可以使用调用保存的寄存器，但可能会对代码大小产生负影响。target必须支持至少两个数据寄存器，但如果有足够的可用的寄存器，则应该定义为4。

     <!-- You must define this macro if you want to support call frame exception -->
     <!-- handling like that provided by DWARF 2. -->
      <p>你必须定义该宏，如果你想支持像DWARF 2提供的调用帧异常处理。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EH_RETURN_STACKADJ_RTX</b><var><a name="index-EH_005fRETURN_005fSTACKADJ_005fRTX-4078"></a></var><br>
<blockquote><!-- A C expression whose value is RTL representing a location in which -->
     <!-- to store a stack adjustment to be applied before function return. -->
     <!-- This is used to unwind the stack to an exception handler's call frame. -->
     <!-- It will be assigned zero on code paths that return normally. -->
      <p>一个C表达式，其值为RTL，表示一个位置，用来存储栈调整，在函数返回前应用。这用于unwind栈到一个异常处理的调用帧中。其将被赋予0在通常的返回代码路径上。

     <!-- Typically this is a call-clobbered hard register that is otherwise -->
     <!-- untouched by the epilogue, but could also be a stack slot. -->
      <p>通常这是一个调用破坏的硬件寄存器，但也可以为一个栈槽。

     <!-- Do not define this macro if the stack pointer is saved and restored -->
     <!-- by the regular prolog and epilog code in the call frame itself; in -->
     <!-- this case, the exception handling library routines will update the -->
     <!-- stack location to be restored in place.  Otherwise, you must define -->
     <!-- this macro if you want to support call frame exception handling like -->
     <!-- that provided by DWARF 2. -->
      <p>不要定义该宏，如果栈指针在调用帧本身通过序言和尾声来保存和恢复时；这种情况下，异常处理库函数将更新栈位置并保存。否则，你必须定义该宏，如果你想支持调用帧异常处理，就像DWARF2提供的那样。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EH_RETURN_HANDLER_RTX</b><var><a name="index-EH_005fRETURN_005fHANDLER_005fRTX-4079"></a></var><br>
<blockquote><!-- A C expression whose value is RTL representing a location in which -->
     <!-- to store the address of an exception handler to which we should -->
     <!-- return.  It will not be assigned on code paths that return normally. -->
      <p>一个C表达式，其值为一个RTL，表示一个位置，用来存储我们应该返回的异常处理的地址。其在通常的返回的代码路径上将不被赋值。

     <!-- Typically this is the location in the call frame at which the normal -->
     <!-- return address is stored.  For targets that return by popping an -->
     <!-- address off the stack, this might be a memory address just below -->
     <!-- the @emph{target} call frame rather than inside the current call -->
     <!-- frame.  If defined, @code{EH_RETURN_STACKADJ_RTX} will have already -->
     <!-- been assigned, so it may be used to calculate the location of the -->
     <!-- target call frame. -->
      <p>通常这是在调用帧中通常返回地址存储的位置。对于通过在栈中弹出地址的target，这可以为一个内存地址，就在target调用帧的下面，而不是在当前调用帧中。如果被定义，<code>EH_RETURN_STACKADJ_RTX</code>将已经被赋值，所以其可以用于计算target调用帧的位置。

     <!-- Some targets have more complex requirements than storing to an -->
     <!-- address calculable during initial code generation.  In that case -->
     <!-- the @code{eh_return} instruction pattern should be used instead. -->
      <p>一些target具有更加复杂的要求，比在初始化代码生成阶段存储到地址中。这种情况下，要替代的使用<code>eh_return</code>指令模式。

     <!-- If you want to support call frame exception handling, you must -->
     <!-- define either this macro or the @code{eh_return} instruction pattern. -->
      <p>如果你想支持调用帧异常处理，你必须定义该宏或者<code>eh_return</code>指令模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>RETURN_ADDR_OFFSET</b><var><a name="index-RETURN_005fADDR_005fOFFSET-4080"></a></var><br>
<blockquote><!-- If defined, an integer-valued C expression for which rtl will be generated -->
     <!-- to add it to the exception handler address before it is searched in the -->
     <!-- exception handling tables, and to subtract it again from the address before -->
     <!-- using it to return to the exception handler. -->
      <p>如果定义，则为一个整数值的C表达式，并会为此生成rtl来加上异常处理地址，在其在异常处理表中搜索之前，并且再减去它，在用它来返回到异常处理之前。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_PREFERRED_EH_DATA_FORMAT</b> (<var>code, global</var>)<var><a name="index-ASM_005fPREFERRED_005fEH_005fDATA_005fFORMAT-4081"></a></var><br>
<blockquote><!-- This macro chooses the encoding of pointers embedded in the exception -->
     <!-- handling sections.  If at all possible, this should be defined such -->
     <!-- that the exception handling section will not require dynamic relocations, -->
     <!-- and so may be read-only. -->
      <p>该宏选择在异常处理section中嵌入的指针的解码。如果尽可能，该宏应该被定义，这样异常处理section将不会要求进行动态重定位，并可以为只读的。

     <!-- @var{code} is 0 for data, 1 for code labels, 2 for function pointers. -->
     <!-- @var{global} is true if the symbol may be affected by dynamic relocations. -->
     <!-- The macro should return a combination of the @code{DW_EH_PE_*} defines -->
     <!-- as found in @file{dwarf2.h}. -->
      <p><var>code</var>为0，对于数据，1对于代码标号，2对于函数指针。<var>global</var>为真，如果符号可以由动态重定位影响。宏应该返回在<samp><span class="file">dwarf2.h</span></samp>中可以找到的<code>DW_EH_PE_*</code>的组合。

     <!-- If this macro is not defined, pointers will not be encoded but -->
     <!-- represented directly. -->
      <p>如果该宏没有定义，则指针将不被解码，而是直接表示。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX</b> (<var>file, encoding, size, addr, done</var>)<var><a name="index-ASM_005fMAYBE_005fOUTPUT_005fENCODED_005fADDR_005fRTX-4082"></a></var><br>
<blockquote><!-- This macro allows the target to emit whatever special magic is required -->
     <!-- to represent the encoding chosen by @code{ASM_PREFERRED_EH_DATA_FORMAT}. -->
     <!-- Generic code takes care of pc-relative and indirect encodings; this must -->
     <!-- be defined if the target uses text-relative or data-relative encodings. -->
      <p>该宏允许target生成特定的magic，用于表示<code>ASM_PREFERRED_EH_DATA_FORMAT</code>选择的encoding。通常代码考虑pc-relative和indirect解码；如果target使用text-relative或者data-relative解码，则必须定义该宏。

     <!-- This is a C statement that branches to @var{done} if the format was -->
     <!-- handled.  @var{encoding} is the format chosen, @var{size} is the number -->
     <!-- of bytes that the format occupies, @var{addr} is the @code{SYMBOL_REF} -->
     <!-- to be emitted. -->
      <p>这是一个C语句，如果格式被处理，则执行分支跳转。<var>encoding</var>为选择的格式，<var>size</var>为格式占用的字节数，<var>addr</var>为生成的<code>SYMBOL_REF</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MD_FALLBACK_FRAME_STATE_FOR</b> (<var>context, fs</var>)<var><a name="index-MD_005fFALLBACK_005fFRAME_005fSTATE_005fFOR-4083"></a></var><br>
<blockquote><!-- This macro allows the target to add CPU and operating system specific -->
     <!-- code to the call-frame unwinder for use when there is no unwind data -->
     <!-- available.  The most common reason to implement this macro is to unwind -->
     <!-- through signal frames. -->
      <p>该宏允许target增加CPU和操作系统特定代码到call-frame unwinder，用于当没有unwind数据可用时。最常见的原因是实现该宏来通过signal帧来unwind。

     <!-- This macro is called from @code{uw_frame_state_for} in -->
     <!-- @file{unwind-dw2.c}, @file{unwind-dw2-xtensa.c} and -->
     <!-- @file{unwind-ia64.c}.  @var{context} is an @code{_Unwind_Context}; -->
     <!-- @var{fs} is an @code{_Unwind_FrameState}.  Examine @code{context->ra} -->
     <!-- for the address of the code being executed and @code{context->cfa} for -->
     <!-- the stack pointer value.  If the frame can be decoded, the register -->
     <!-- save addresses should be updated in @var{fs} and the macro should -->
     <!-- evaluate to @code{_URC_NO_REASON}.  If the frame cannot be decoded, -->
     <!-- the macro should evaluate to @code{_URC_END_OF_STACK}. -->
      <p>该宏由<samp><span class="file">unwind-dw2.c</span></samp>, <samp><span class="file">unwind-dw2-xtensa.c</span></samp>和<samp><span class="file">unwind-ia64.c</span></samp>中的<code>uw_frame_state_for</code>调用。<var>context</var>为一个<code>_Unwind_Context</code>；<var>fs</var>为一个<code>_Unwind_FrameState</code>。检查<code>context-&gt;ra</code>来得到被执行的代码的地址，检查<code>context-&gt;cfa</code>来得到栈指针的值。如果帧可以被解码，则寄存器保存地址应该在<var>fs</var>中更新，并且宏应该求值为<code>_URC_NO_REASON</code>。如果帧不能被解码，则宏应该求解为<code>_URC_END_OF_STACK</code>。

     <!-- For proper signal handling in Java this macro is accompanied by -->
     <!-- @code{MAKE_THROW_FRAME}, defined in @file{libjava/include/*-signal.h} headers. -->
      <p>对于java中合适的信号处理，该宏通过<code>MAKE_THROW_FRAME</code>来应用，在<samp><span class="file">libjava/include/*-signal.h</span></samp>中定义。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MD_HANDLE_UNWABI</b> (<var>context, fs</var>)<var><a name="index-MD_005fHANDLE_005fUNWABI-4084"></a></var><br>
<blockquote><!-- This macro allows the target to add operating system specific code to the -->
     <!-- call-frame unwinder to handle the IA-64 @code{.unwabi} unwinding directive, -->
     <!-- usually used for signal or interrupt frames. -->
      <p>该宏允许target增加操作系统特定的代码到调用帧unwinder，来处理IA-64 <code>.unwabi</code> unwinding伪指令，通常用于signal或者interrrupt帧。

     <!-- This macro is called from @code{uw_update_context} in @file{unwind-ia64.c}. -->
     <!-- @var{context} is an @code{_Unwind_Context}; -->
     <!-- @var{fs} is an @code{_Unwind_FrameState}.  Examine @code{fs->unwabi} -->
     <!-- for the abi and context in the @code{.unwabi} directive.  If the -->
     <!-- @code{.unwabi} directive can be handled, the register save addresses should -->
     <!-- be updated in @var{fs}. -->
      <p>该宏由<samp><span class="file">unwind-ia64.c</span></samp>中的<code>uw_update_context</code>调用。<var>context</var>为一个<code>_Unwind_Context</code>；<var>fs</var>为一个<code>_Unwind_FrameState</code>。检查<code>fs-&gt;unwabi</code>来得到abi。如果<code>.unwabi</code>伪指令可以被处理，则寄存器保存地址应该在<var>fs</var>中更新。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_USES_WEAK_UNWIND_INFO</b><var><a name="index-TARGET_005fUSES_005fWEAK_005fUNWIND_005fINFO-4085"></a></var><br>
<blockquote><!-- A C expression that evaluates to true if the target requires unwind -->
     <!-- info to be given comdat linkage.  Define it to be @code{1} if comdat -->
     <!-- linkage is necessary.  The default is @code{0}. -->
      <p>一个C表达式，计算为真，如果target需要unwind info给定comdat linkage。定义其为<code>1</code>，如果comdat linkage有必要。缺省为<code>0</code>。
</p></blockquote></div>

<!-- @node Stack Checking -->
<!-- @subsection Specifying How Stack Checking is Done -->
 </body></html>

