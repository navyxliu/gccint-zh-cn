@c Copyright (c) 2008, 2009 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node GIMPLE
@chapter GIMPLE
@cindex GIMPLE

GIMPLE为一个三地址表示，通过将GENERIC表达式分解成不超过3个操作数（有些情况例外，比如函数调用）的元组。虽然我们已经做过一些不同的选择，但GIMPLE在很大程度上受McGill大学的McCAT编译器项目中使用的SIMPLE IL的影响。有一点，SIMPLE不支持@code{goto}。

临时对象被引入，用来存放计算复杂表达式所需要的中间值。另外，GENERIC中所有的控制结构被下降为条件跳转，词法作用域被移除，异常区域被转换成一个异常区域tree。

将GENERIC转换成GIMPLE的编译器过程，被称作@samp{gimplifier}。@samp{gimplifier}按递归的方式进行工作，从原始的GENERIC表达式生成GIMPLE元组。

早期用于GIMPLE表示的实现策略为，使用与前端表示解析树相同的内部数据结构。这会简化实现，因为我们可以利用现存的功能和接口。然而，与抽象语法树（AST）相比，GIMPLE是一个更加严格的表示，因此其不需要tree数据结构所提供的完整复杂的结构。

函数的GENERIC表示被存放在所关联的@code{FUNCTION_DECL} tree结点的@code{DECL_SAVED_TREE}域。其通过调用@code{gimplify_function_tree}来转换成GIMPLE。

如果前端想在tree表示中包含语言特定的tree代码，并提供给后端，则其必须提供一个@code{LANG_HOOKS_GIMPLIFY_EXPR}的定义，其知道如果将前端的tree转换成GIMPLE。通常这样的钩子会涉及许多相同的代码，用来将前端tree扩展成RTL。该函数可以返回被完全下降的GIMPLE，或者可以返回GENERIC tree并让主gimplifier将它们下降；这通常会更简单些。没有被完全下降的GIMPLE被称为``High GIMPLE''，由@code{pass_lower_cf}过程之前的IL组成。High GIMPLE包含一些容器语句，例如词法作用域（由@code{GIMPLE_BIND}来表示），以及嵌套表达式（例如，@code{GIMPLE_TRY}）。而``Low GIMPLE''将所有隐式的控制跳转或者异常表达式都直接暴露成IL和EH区域tree。

C和C++前端目前直接从前端tree转换成GIMPLE，并将其交给后端，而不是首先转换成GENERIC。它们的gimplifier钩子知道所有的@code{_STMT}结点，以及如何将它们转成GENERIC形式。在genericization过程中有一些工作，应该首先被运行，但是@code{STMT_EXPR}的存在意味着，为了将所有的C语句转换成GENERIC，则需要遍历整个tree，所以一起下降会更简单些。如果有人写了一个优化过程，其在更高级别的tree上会工作的更好，则这在将来可能会有改变，但是目前所有的优化都是在GIMPLE上进行的。

你可以使用选项@option{-fdump-tree-gimple}来转储一个类C的GIMPLE表示形式。

@menu
* 元组表示::
* GIMPLE指令集::
* GIMPLE异常处理::
* Temporaries::
* 操作数::
* 操作GIMPLE语句::
* 元组特定访问方法::
* GIMPLE序列::
* 序列迭代器::
* 增加一个新的GIMPLE语句代码::
* 语句和操作数遍历::
@end menu

@node 元组表示
@section 元组表示
@cindex tuples

GIMPLE指令为可变大小的元组，并由两部分组成：一个描述指令和位置的头，一个具有所有操作数的可变长度的身体。元组被组织成一个层次结构，并有3个主要类别。

@subsection @code{gimple_statement_base} (gsbase)
@cindex gimple_statement_base

这是层次结构的根，其存放了大多GIMPLE语句所需要的基本信息。有一些域并不与所有的GIMPLE语句相关，但是被挪到基础结构中是为了利用其它域剩下的空位（从而使得结构体更加紧凑）。结构体在64位主机上占用4个字（32个字节 ）：

@multitable {@code{references_memory_p}} {Size (bits)}
@item Field				@tab Size (bits)
@item @code{code}			@tab 8
@item @code{subcode}			@tab 16
@item @code{no_warning}			@tab 1
@item @code{visited}			@tab 1
@item @code{nontemporal_move}		@tab 1
@item @code{plf}			@tab 2
@item @code{modified}			@tab 1
@item @code{has_volatile_ops}		@tab 1
@item @code{references_memory_p}	@tab 1
@item @code{uid}			@tab 32
@item @code{location}			@tab 32
@item @code{num_ops}			@tab 32
@item @code{bb}				@tab 64
@item @code{block}			@tab 63
@item Total size			@tab 32 bytes	
@end multitable

@itemize @bullet
@item @code{code}
GIMPLE指令的主要标识 

@item @code{subcode}
用来区分相同基本指令的不同变体，或者提供使用于给定代码的标记。@code{subcode}标记域具有不同的用法，并取决于指令的代码，但是其主要是用来区分相同家族的指令。该域最突出的用法是在赋值中，其子代码指出了在赋值的右手边所进行的操作。例如，a = b + c被编码为@code{GIMPLE_ASSIGN <PLUS_EXPR, a, b, c>}。

@item @code{no_warning}
位标记，用来指出是否在该语句上已经产生了一个警告。

@item @code{visited}
通用目的的“访问”标记 。由每个编译过程根据需要来设置和清除。

@item @code{nontemporal_move}
位标记，用在赋值中，用来表示非临时的移动。虽然该位标记只用于赋值，但其被放到这里是为了利用先前域所剩下的空位。

@item @code{plf}
编译过程局部标记。该2个位的掩码可以由任何编译过程用作通用的标记。编译过程负责相应的清除和设置这两个标记。

@item @code{modified}
位标记，用来指出语句是否被修改。主要由操作数扫描器来使用，用来确定什么时候重新扫描一条语句的操作数。

@item @code{has_volatile_ops}
位标记，用来指出语句是否包含被标记为volatile的操作数。

@item @code{references_memory_p}
位标记，用来指出语句是否包含内存引用（即，其操作数为全局变量，或者指针解引用，或者任何必须在内存中的）。

@item @code{uid}
为无符号整数，由想要为每条语句分配ID的编译过程使用。这些ID必须由每个编译过程来分配和使用。

@item @code{location}
为一个@code{location_t}标识符，用来指定该语句的源代码位置。其从前端继承下来。

@item @code{num_ops}
该语句具有的操作数个数。这描述了元组中嵌套的操作数向量的大小。只在一些元组中使用，但其声明在基础元组中是为了利用先前语所剩下的32位空位。

@item @code{bb}
包含该语句的基本块。
 
@item @code{block}
包含该语句的词法块。还用于调试信息的生成。

@end itemize

@subsection @code{gimple_statement_with_ops}
@cindex gimple_statement_with_ops

该元组实际分成两部分：@code{gimple_statement_with_ops_base} 和 @code{gimple_statement_with_ops}。这是为了适应操作数向量的分配方法。操作数向量被定义为有1个元素的数组。所以，要分配动态数目的操作数，内存分配器(@code{gimple_alloc})只是简单的分配足够的内存来存放结构体本身，以及在结构体尾部加上@code{N - 1}个操作数。例如，要为有3个操作数的元组分配空间，@code{gimple_alloc}预留了@code{sizeof (struct gimple_statement_with_ops) + 2 * sizeof (tree)}个字节。

另一方面，该元组中的一些域需要与@code{gimple_statement_with_memory_ops}元组共享。所以，这些公共域被放在@code{gimple_statement_with_ops_base}中，然后由其它两个元组来继承。

@multitable {@code{addresses_taken}}	{56 + 8 * @code{num_ops} bytes}
@item	@code{gsbase}		@tab 256	
@item	@code{addresses_taken}	@tab 64	
@item	@code{def_ops}		@tab 64	
@item	@code{use_ops}		@tab 64	
@item	@code{op}		@tab @code{num_ops} * 64	
@item	Total size		@tab 56 + 8 * @code{num_ops} bytes
@end multitable

@itemize @bullet
@item @code{gsbase}
继承自@code{struct gimple_statement_base}。

@item @code{addresses_taken}
位图，存放了所有@code{VAR_DECL}的UID，该语句使用了这些@code{VAR_DECL}的地址。例如，形式为@code{p = &b}的语句将在该集合中具有符号@code{b}的UID。

@item @code{def_ops}
指针数组，指向操作数数组，指出该包含语句写入的变量的所有插槽。该数组还用于立即使用链。注意，是可以不依赖该数组的，但是这种实现会很具有入侵性。

@item @code{use_ops}
类似于@code{def_ops}，不过是针对语句读取的变量。

@item @code{op}
具有@code{num_ops}插槽的tree数组。
@end itemize

@subsection @code{gimple_statement_with_memory_ops}

该元组本质上等同于@code{gimple_statement_with_ops}，除了其包含4个额外的域，来存放与内存存储和加载相关的向量。类似于先前的情况，结构体被分成两部分，用来容纳操作数向量(@code{gimple_statement_with_memory_ops_base}和@code{gimple_statement_with_memory_ops})。

@multitable {@code{addresses_taken}}	{88 + 8 * @code{num_ops} bytes}
@item Field				@tab Size (bits)
@item @code{gsbase}			@tab 256
@item @code{addresses_taken}		@tab 64
@item @code{def_ops}			@tab 64
@item @code{use_ops}			@tab 64
@item @code{vdef_ops}			@tab 64
@item @code{vuse_ops}			@tab 64
@item @code{stores}			@tab 64	
@item @code{loads}			@tab 64	
@item @code{op}				@tab @code{num_ops} * 64	
@item Total size			@tab 88 + 8 * @code{num_ops} bytes
@end multitable

@itemize @bullet
@item @code{vdef_ops}
类似于@code{def_ops}，不过用于@code{VDEF}操作符。这是该语句写入的内存符号的一个实体。这用于维护内存SSA use-def和def-def链。

@item @code{vuse_ops}
类似于@code{use_ops}，不过用于@code{VUSE}操作数。这是该语句加载的内存符号的一个实体。这用于维护内存SSA use-def链。

@item @code{stores}
位集合，该语句写入的符号的所有UID。这与@code{vdef_ops}不同之处是，所有被影响的符号都在该集合中被提到。如果开启了内存划分，则@code{vdef_ops}向量将指向内存划分。而且，该集合中不存放SSA信息。

@item @code{loads}
类似于@code{stores}，不过用于内存加载。（注意，这里有一些冗余，应该可以通过移除这些集合来减少内存使用）。

@end itemize

所有其它元组按照这三个基本元组来定义。每个元组会增加一些域。gimple类型被定义成所有这些结构体的联合体（为了清晰，省略掉了@code{GTY}标记）：

@smallexample
union gimple_statement_d
@{
  struct gimple_statement_base gsbase;
  struct gimple_statement_with_ops gsops;
  struct gimple_statement_with_memory_ops gsmem;
  struct gimple_statement_omp omp;
  struct gimple_statement_bind gimple_bind;
  struct gimple_statement_catch gimple_catch;
  struct gimple_statement_eh_filter gimple_eh_filter;
  struct gimple_statement_phi gimple_phi;
  struct gimple_statement_resx gimple_resx;
  struct gimple_statement_try gimple_try;
  struct gimple_statement_wce gimple_wce;
  struct gimple_statement_asm gimple_asm;
  struct gimple_statement_omp_critical gimple_omp_critical;
  struct gimple_statement_omp_for gimple_omp_for;
  struct gimple_statement_omp_parallel gimple_omp_parallel;
  struct gimple_statement_omp_task gimple_omp_task;
  struct gimple_statement_omp_sections gimple_omp_sections;
  struct gimple_statement_omp_single gimple_omp_single;
  struct gimple_statement_omp_continue gimple_omp_continue;
  struct gimple_statement_omp_atomic_load gimple_omp_atomic_load;
  struct gimple_statement_omp_atomic_store gimple_omp_atomic_store;
@};
@end smallexample

 
@node GIMPLE指令集
@section GIMPLE指令集
@cindex GIMPLE instruction set

下面的表格简短地描述了GIMPLE指令集。

@multitable {@code{GIMPLE_CHANGE_DYNAMIC_TYPE}} {High GIMPLE} {Low GIMPLE}
@item 指令			@tab 高层GIMPLE	    @tab 低层GIMPLE
@item @code{GIMPLE_ASM}			@tab x			@tab x
@item @code{GIMPLE_ASSIGN}		@tab x			@tab x
@item @code{GIMPLE_BIND}		@tab x			@tab
@item @code{GIMPLE_CALL}		@tab x			@tab x
@item @code{GIMPLE_CATCH}		@tab x			@tab
@item @code{GIMPLE_CHANGE_DYNAMIC_TYPE}	@tab x			@tab x
@item @code{GIMPLE_COND}		@tab x			@tab x
@item @code{GIMPLE_EH_FILTER}		@tab x			@tab
@item @code{GIMPLE_GOTO}		@tab x			@tab x
@item @code{GIMPLE_LABEL}		@tab x			@tab x
@item @code{GIMPLE_NOP}			@tab x			@tab x
@item @code{GIMPLE_OMP_ATOMIC_LOAD}	@tab x			@tab x
@item @code{GIMPLE_OMP_ATOMIC_STORE}	@tab x			@tab x
@item @code{GIMPLE_OMP_CONTINUE}	@tab x			@tab x
@item @code{GIMPLE_OMP_CRITICAL}	@tab x			@tab x
@item @code{GIMPLE_OMP_FOR}		@tab x			@tab x
@item @code{GIMPLE_OMP_MASTER}		@tab x			@tab x
@item @code{GIMPLE_OMP_ORDERED}		@tab x			@tab x
@item @code{GIMPLE_OMP_PARALLEL}	@tab x			@tab x
@item @code{GIMPLE_OMP_RETURN}		@tab x			@tab x
@item @code{GIMPLE_OMP_SECTION}		@tab x			@tab x
@item @code{GIMPLE_OMP_SECTIONS}	@tab x			@tab x
@item @code{GIMPLE_OMP_SECTIONS_SWITCH}	@tab x			@tab x
@item @code{GIMPLE_OMP_SINGLE}		@tab x			@tab x
@item @code{GIMPLE_PHI}			@tab 			@tab x
@item @code{GIMPLE_RESX}		@tab			@tab x
@item @code{GIMPLE_RETURN}		@tab x			@tab x
@item @code{GIMPLE_SWITCH}		@tab x			@tab x
@item @code{GIMPLE_TRY}			@tab x			@tab
@end multitable

@node GIMPLE异常处理
@section 异常处理
@cindex GIMPLE Exception Handling

其它异常处理结构使用@code{GIMPLE_TRY_CATCH}来表示。@code{GIMPLE_TRY_CATCH}有两个操作数。第一个操作数为一个要执行的语句序列。如果执行这些语句并没有抛出异常，则第二个操作数被忽略。否则，如果有异常被抛出，则@code{GIMPLE_TRY_CATCH}的第二个操作数将被检查。第二个操作数可以具有以下形式：

@enumerate

@item 一个要执行的语句序列。当发生异常时，这些语句被执行，然后异常被重新抛出。

@item 一个@code{GIMPLE_CATCH}语句序列。每个@code{GIMPLE_CATCH}有一个可适用的异常类型列表和处理代码。如果被抛出的异常匹配其中一个类型，则相关的处理代码被执行。如果处理代码执行到结尾并结束，则在最初的@code{GIMPLE_TRY_CATCH}之后继续执行。

@item 一条@code{GIMPLE_EH_FILTER}语句。具有一个允许的异常类型列表，和当匹配失败时的处理代码。如果被抛出的异常不匹配所允许的类型之一，则相关的匹配失败代码会被执行。如果抛出的异常确实匹配，则继续查找下一个处理。

@end enumerate

目前抛出异常并不直接用GIMPLE来表示，而是通过调用一个函数来实现。将来的某个时候，我们将增加某种方式来表示抛出已知类型的异常的调用。

就在运行优化器之前，编译器将高级别的EH结构下降为一组@samp{goto}，魔术标号，以及EH区域。

@node Temporaries
@section Temporaries
@cindex Temporaries

当gimplification遇到一个过于复杂的子表达式的时候，会创建一个新的临时变量来存放子表达式的值，并且在当前语句之前，增加一条新的语句对其初始化。这些特殊的临时对象被称作@samp{expression temporaries}，并使用@code{get_formal_tmp_var}来分配。编译器总是尝试将相等的表达式放到同一个临时对象中，来简化冗余计算消除。

只有当我们知道在使用表达式临时对象的值之前，其不会被重新求值的时候，才可以使用，否则其将不能被修改@footnote{这些限制源自Morgan 4.8.}。其它临时对象可以使用@code{get_initialized_tmp_var}或@code{create_tmp_var}来分配。

目前，像@code{a = b + 5}这样的表达式没有被进一步简化。我们曾经尝试将其转换成型如

@smallexample
  T1 = b + 5;
  a = T1;
@end smallexample

的样子。但这会使表示变得膨胀，而无法获益。然而，必须在内存中的变量不能出现在表达式中；其值先被显式的加载到一个临时对象中。类似的，将表达式的值存放到内存变量中，也要通过一个临时对象。

@node 操作数
@section 操作数
@cindex Operands

总得来说，GIMPLE表达式由一个运算和适当数目的简单操作数组成；这些操作数必须或者为GIMPLE右值(@code{is_gimple_val})，即一个常量，或者一个寄存器变量。更复杂的操作数被分解到临时对象中，所以，

@smallexample
  a = b + c + d
@end smallexample
会变成
@smallexample
  T1 = b + c;
  a = T1 + d;
@end smallexample

对于@code{GIMPLE_CALL}的参数也是同样的规则。

一个赋值的目标通常为一个变量，但是也可以为一个@code{INDIRECT_REF}或者一个由下面描述的复合左值。

@menu
* 复合表达式::
* 复合左值::
* 条件表达式::
* 逻辑运算符::
@end menu

@node 复合表达式
@subsection 复合表达式
@cindex Compound Expressions

C逗号表达式的左手边被简单的移送到一个独立的语句中。

@node 复合左值
@subsection 复合左值
@cindex Compound Lvalues

目前涉及到数组和结构体域引用的复合左值，没有被分解；像@code{a.b[2] = 42}这样的表达式不再被简化（虽然是复杂的数组下标）。这种限制可以解决之后的优化器的局限性；如果我们要将其转换成

@smallexample
  T1 = &a.b;
  T1[2] = 42;
@end smallexample

则别名分析无法记住对@code{T1[2]}的引用是来自@code{a.b}，所以，其会认为该赋值会与@code{a}的另一个成员有别名关系；这会使@code{struct-alias-1.c}运行失败。将来对优化器的改进可以不再需要限制。

@node 条件表达式
@subsection 条件表达式
@cindex Conditional Expressions

C @code{?:} 表达式被转换成一条@code{if}语句，每个分支被分配给相同的临时对象。所以，

@smallexample
  a = b ? c : d;
@end smallexample
会变成
@smallexample
  if (b == 1)
    T1 = c;
  else
    T1 = d;
  a = T1;
@end smallexample

GIMPLE级别的if-conversion过程在适当的时候，重新引入了@code{?:}表达式。其用于向量化循环。

注意在GIMPLE中，@code{if}语句通过@code{GIMPLE_COND}来表示，正如下面所描述。

@node 逻辑运算符
@subsection 逻辑运算符
@cindex Logical Operators

除非它们出现在@code{GIMPLE_COND}的条件操作数中，否则逻辑的`and'和`or'操作符将按照下列方式进行简化：@code{a = b && c}变成

@smallexample
  T1 = (bool)b;
  if (T1 == true)
    T1 = (bool)c;
  a = T1;
@end smallexample

注意该例子中的@code{T1}不能为表达式临时对象，因为其具有两个不同的赋值。

@subsection 操作操作数

All gimple operands are of type @code{tree}.  But only certain
types of trees are allowed to be used as operand tuples.  Basic
validation is controlled by the function
@code{get_gimple_rhs_class}, which given a tree code, returns an
@code{enum} with the following values of type @code{enum
gimple_rhs_class}

@itemize @bullet
@item @code{GIMPLE_INVALID_RHS}
The tree cannot be used as a GIMPLE operand.

@item @code{GIMPLE_BINARY_RHS}
The tree is a valid GIMPLE binary operation.

@item @code{GIMPLE_UNARY_RHS}
The tree is a valid GIMPLE unary operation.

@item @code{GIMPLE_SINGLE_RHS}
The tree is a single object, that cannot be split into simpler
operands (for instance, @code{SSA_NAME}, @code{VAR_DECL}, @code{COMPONENT_REF}, etc).

This operand class also acts as an escape hatch for tree nodes
that may be flattened out into the operand vector, but would need
more than two slots on the RHS.  For instance, a @code{COND_EXPR}
expression of the form @code{(a op b) ? x : y} could be flattened
out on the operand vector using 4 slots, but it would also
require additional processing to distinguish @code{c = a op b}
from @code{c = a op b ? x : y}.  Something similar occurs with
@code{ASSERT_EXPR}.   In time, these special case tree
expressions should be flattened into the operand vector.
@end itemize

For tree nodes in the categories @code{GIMPLE_BINARY_RHS} and
@code{GIMPLE_UNARY_RHS}, they cannot be stored inside tuples directly.
They first need to be flattened and separated into individual
components.  For instance, given the GENERIC expression

@smallexample
a = b + c
@end smallexample

its tree representation is:

@smallexample
MODIFY_EXPR <VAR_DECL  <a>, PLUS_EXPR <VAR_DECL <b>, VAR_DECL <c>>>
@end smallexample

In this case, the GIMPLE form for this statement is logically
identical to its GENERIC form but in GIMPLE, the @code{PLUS_EXPR}
on the RHS of the assignment is not represented as a tree,
instead the two operands are taken out of the @code{PLUS_EXPR} sub-tree
and flattened into the GIMPLE tuple as follows:

@smallexample
GIMPLE_ASSIGN <PLUS_EXPR, VAR_DECL <a>, VAR_DECL <b>, VAR_DECL <c>>
@end smallexample

@subsection 操作数向量分配

The operand vector is stored at the bottom of the three tuple
structures that accept operands. This means, that depending on
the code of a given statement, its operand vector will be at
different offsets from the base of the structure.  To access
tuple operands use the following accessors

@deftypefn {GIMPLE function} unsigned gimple_num_ops (gimple g)
Returns the number of operands in statement G.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_op (gimple g, unsigned i)
Returns operand @code{I} from statement @code{G}.
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)
Returns a pointer into the operand vector for statement @code{G}.  This
is computed using an internal table called @code{gimple_ops_offset_}[].
This table is indexed by the gimple code of @code{G}.

When the compiler is built, this table is filled-in using the
sizes of the structures used by each statement code defined in
gimple.def.  Since the operand vector is at the bottom of the
structure, for a gimple code @code{C} the offset is computed as sizeof
(struct-of @code{C}) - sizeof (tree).

This mechanism adds one memory indirection to every access when
using @code{gimple_op}(), if this becomes a bottleneck, a pass can
choose to memoize the result from @code{gimple_ops}() and use that to
access the operands.
@end deftypefn

@subsection 操作数有效性

When adding a new operand to a gimple statement, the operand will
be validated according to what each tuple accepts in its operand
vector.  These predicates are called by the
@code{gimple_<name>_set_...()}.  Each tuple will use one of the
following predicates (Note, this list is not exhaustive):

@deftypefn {GIMPLE function} is_gimple_operand (tree t)
This is the most permissive of the predicates.  It essentially
checks whether t has a @code{gimple_rhs_class} of @code{GIMPLE_SINGLE_RHS}.
@end deftypefn


@deftypefn {GIMPLE function} is_gimple_val (tree t)
Returns true if t is a "GIMPLE value", which are all the
non-addressable stack variables (variables for which
@code{is_gimple_reg} returns true) and constants (expressions for which
@code{is_gimple_min_invariant} returns true).
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_addressable (tree t)
Returns true if t is a symbol or memory reference whose address
can be taken.
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_asm_val (tree t)
Similar to @code{is_gimple_val} but it also accepts hard registers.
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_call_addr (tree t)
Return true if t is a valid expression to use as the function
called by a @code{GIMPLE_CALL}.
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_constant (tree t)
Return true if t is a valid gimple constant.
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_min_invariant (tree t)
Return true if t is a valid minimal invariant.  This is different
from constants, in that the specific value of t may not be known
at compile time, but it is known that it doesn't change (e.g.,
the address of a function local variable).
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_min_invariant_address (tree t)
Return true if t is an @code{ADDR_EXPR} that does not change once the
program is running.
@end deftypefn


@subsection 语句有效性

@deftypefn {GIMPLE function} is_gimple_assign (gimple g)
Return true if the code of g is @code{GIMPLE_ASSIGN}.
@end deftypefn
 
@deftypefn {GIMPLE function} is_gimple_call (gimple g)
Return true if the code of g is @code{GIMPLE_CALL}
@end deftypefn
 
@deftypefn {GIMPLE function} gimple_assign_cast_p (gimple g)
Return true if g is a @code{GIMPLE_ASSIGN} that performs a type cast
operation
@end deftypefn

@node 操作GIMPLE语句
@section 操作GIMPLE语句
@cindex Manipulating GIMPLE statements

This section documents all the functions available to handle each
of the GIMPLE instructions.

@subsection 通用访问方法
The following are common accessors for gimple statements.

@deftypefn {GIMPLE function} enum gimple_code gimple_code (gimple g)
Return the code for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} basic_block gimple_bb (gimple g)
Return the basic block to which statement @code{G} belongs to.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_block (gimple g)
Return the lexical scope block holding statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_expr_type (gimple stmt)
Return the type of the main expression computed by @code{STMT}. Return
@code{void_type_node} if @code{STMT} computes nothing. This will only return
something meaningful for @code{GIMPLE_ASSIGN}, @code{GIMPLE_COND} and
@code{GIMPLE_CALL}.  For all other tuple codes, it will return
@code{void_type_node}.
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_expr_code (gimple stmt)
Return the tree code for the expression computed by @code{STMT}.  This
is only meaningful for @code{GIMPLE_CALL}, @code{GIMPLE_ASSIGN} and
@code{GIMPLE_COND}.  If @code{STMT} is @code{GIMPLE_CALL}, it will return @code{CALL_EXPR}.
For @code{GIMPLE_COND}, it returns the code of the comparison predicate.
For @code{GIMPLE_ASSIGN} it returns the code of the operation performed
by the @code{RHS} of the assignment.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_set_block (gimple g, tree block)
Set the lexical scope block of @code{G} to @code{BLOCK}.
@end deftypefn
 
@deftypefn {GIMPLE function} location_t gimple_locus (gimple g)
Return locus information for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_locus (gimple g, location_t locus)
Set locus information for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_locus_empty_p (gimple g)
Return true if @code{G} does not have locus information.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_no_warning_p (gimple stmt)
Return true if no warnings should be emitted for statement @code{STMT}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_visited (gimple stmt, bool visited_p)
Set the visited status on statement @code{STMT} to @code{VISITED_P}.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_visited_p (gimple stmt)
Return the visited status on statement @code{STMT}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_plf (gimple stmt, enum plf_mask plf, bool val_p)
Set pass local flag @code{PLF} on statement @code{STMT} to @code{VAL_P}.
@end deftypefn
 
@deftypefn {GIMPLE function} unsigned int gimple_plf (gimple stmt, enum plf_mask plf)
Return the value of pass local flag @code{PLF} on statement @code{STMT}.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_has_ops (gimple g)
Return true if statement @code{G} has register or memory operands.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_has_mem_ops (gimple g)
Return true if statement @code{G} has memory operands.
@end deftypefn
 
@deftypefn {GIMPLE function} unsigned gimple_num_ops (gimple g)
Return the number of operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)
Return the array of operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_op (gimple g, unsigned i)
Return operand @code{I} for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_op_ptr (gimple g, unsigned i)
Return a pointer to operand @code{I} for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_op (gimple g, unsigned i, tree op)
Set operand @code{I} of statement @code{G} to @code{OP}.
@end deftypefn
 
@deftypefn {GIMPLE function} bitmap gimple_addresses_taken (gimple stmt)
Return the set of symbols that have had their address taken by
@code{STMT}.
@end deftypefn
 
@deftypefn {GIMPLE function} struct def_optype_d *gimple_def_ops (gimple g)
Return the set of @code{DEF} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_def_ops (gimple g, struct def_optype_d *def)
Set @code{DEF} to be the set of @code{DEF} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} struct use_optype_d *gimple_use_ops (gimple g)
Return the set of @code{USE} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_use_ops (gimple g, struct use_optype_d *use)
Set @code{USE} to be the set of @code{USE} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} struct voptype_d *gimple_vuse_ops (gimple g)
Return the set of @code{VUSE} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_vuse_ops (gimple g, struct voptype_d *ops)
Set @code{OPS} to be the set of @code{VUSE} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} struct voptype_d *gimple_vdef_ops (gimple g)
Return the set of @code{VDEF} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_vdef_ops (gimple g, struct voptype_d *ops)
Set @code{OPS} to be the set of @code{VDEF} operands for statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} bitmap gimple_loaded_syms (gimple g)
Return the set of symbols loaded by statement @code{G}.  Each element of
the set is the @code{DECL_UID} of the corresponding symbol.
@end deftypefn
 
@deftypefn {GIMPLE function} bitmap gimple_stored_syms (gimple g)
Return the set of symbols stored by statement @code{G}.  Each element of
the set is the @code{DECL_UID} of the corresponding symbol.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_modified_p (gimple g)
Return true if statement @code{G} has operands and the modified field
has been set.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_has_volatile_ops (gimple stmt)
Return true if statement @code{STMT} contains volatile operands.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_has_volatile_ops (gimple stmt, bool volatilep)
Return true if statement @code{STMT} contains volatile operands.
@end deftypefn
 
@deftypefn {GIMPLE function} void update_stmt (gimple s)
Mark statement @code{S} as modified, and update it.
@end deftypefn
 
@deftypefn {GIMPLE function} void update_stmt_if_modified (gimple s)
Update statement @code{S} if it has been marked modified.
@end deftypefn
 
@deftypefn {GIMPLE function} gimple gimple_copy (gimple stmt)
Return a deep copy of statement @code{STMT}.
@end deftypefn

@node 元组特定访问方法
@section 元组特定访问方法
@cindex Tuple specific accessors

@menu
* @code{GIMPLE_ASM}::
* @code{GIMPLE_ASSIGN}::
* @code{GIMPLE_BIND}::
* @code{GIMPLE_CALL}::
* @code{GIMPLE_CATCH}::
* @code{GIMPLE_CHANGE_DYNAMIC_TYPE}::
* @code{GIMPLE_COND}::
* @code{GIMPLE_EH_FILTER}::
* @code{GIMPLE_LABEL}::
* @code{GIMPLE_NOP}::
* @code{GIMPLE_OMP_ATOMIC_LOAD}::
* @code{GIMPLE_OMP_ATOMIC_STORE}::
* @code{GIMPLE_OMP_CONTINUE}::
* @code{GIMPLE_OMP_CRITICAL}::
* @code{GIMPLE_OMP_FOR}::
* @code{GIMPLE_OMP_MASTER}::
* @code{GIMPLE_OMP_ORDERED}::
* @code{GIMPLE_OMP_PARALLEL}::
* @code{GIMPLE_OMP_RETURN}::
* @code{GIMPLE_OMP_SECTION}::
* @code{GIMPLE_OMP_SECTIONS}::
* @code{GIMPLE_OMP_SINGLE}::
* @code{GIMPLE_PHI}::
* @code{GIMPLE_RESX}::
* @code{GIMPLE_RETURN}::
* @code{GIMPLE_SWITCH}::
* @code{GIMPLE_TRY}::
* @code{GIMPLE_WITH_CLEANUP_EXPR}::
@end menu


@node @code{GIMPLE_ASM}
@subsection @code{GIMPLE_ASM}
@cindex @code{GIMPLE_ASM}

@deftypefn {GIMPLE function} gimple gimple_build_asm (const char *string, ninputs, noutputs, nclobbers, ...)
Build a @code{GIMPLE_ASM} statement.  This statement is used for
building in-line assembly constructs.  @code{STRING} is the assembly
code.  @code{NINPUT} is the number of register inputs.  @code{NOUTPUT} is the
number of register outputs.  @code{NCLOBBERS} is the number of clobbered
registers.  The rest of the arguments trees for each input,
output, and clobbered registers.
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_build_asm_vec (const char *, VEC(tree,gc) *, VEC(tree,gc) *, VEC(tree,gc) *)
Identical to gimple_build_asm, but the arguments are passed in
VECs.
@end deftypefn

@deftypefn {GIMPLE function} gimple_asm_ninputs (gimple g)
Return the number of input operands for @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_asm_noutputs (gimple g)
Return the number of output operands for @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_asm_nclobbers (gimple g)
Return the number of clobber operands for @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_asm_input_op (gimple g, unsigned index)
Return input operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_input_op (gimple g, unsigned index, tree in_op)
Set @code{IN_OP} to be input operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_asm_output_op (gimple g, unsigned index)
Return output operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_output_op (gimple g, @
unsigned index, tree out_op)
Set @code{OUT_OP} to be output operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_asm_clobber_op (gimple g, unsigned index)
Return clobber operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_clobber_op (gimple g, unsigned index, tree clobber_op)
Set @code{CLOBBER_OP} to be clobber operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} const char *gimple_asm_string (gimple g)
Return the string representing the assembly instruction in
@code{GIMPLE_ASM} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_asm_volatile_p (gimple g)
Return true if @code{G} is an asm statement marked volatile. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_volatile (gimple g)
Mark asm statement @code{G} as volatile. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_clear_volatile (gimple g)
Remove volatile marker from asm statement @code{G}. 
@end deftypefn

@node @code{GIMPLE_ASSIGN}
@subsection @code{GIMPLE_ASSIGN}
@cindex @code{GIMPLE_ASSIGN}

@deftypefn {GIMPLE function} gimple gimple_build_assign (tree lhs, tree rhs)
Build a @code{GIMPLE_ASSIGN} statement.  The left-hand side is an lvalue
passed in lhs.  The right-hand side can be either a unary or
binary tree expression.  The expression tree rhs will be
flattened and its operands assigned to the corresponding operand
slots in the new statement.  This function is useful when you
already have a tree expression that you want to convert into a
tuple.  However, try to avoid building expression trees for the
sole purpose of calling this function.  If you already have the
operands in separate trees, it is better to use
@code{gimple_build_assign_with_ops}.
@end deftypefn


@deftypefn {GIMPLE function} gimple gimplify_assign (tree dst, tree src, gimple_seq *seq_p)
Build a new @code{GIMPLE_ASSIGN} tuple and append it to the end of
@code{*SEQ_P}.
@end deftypefn

@code{DST}/@code{SRC} are the destination and source respectively.  You can
pass ungimplified trees in @code{DST} or @code{SRC}, in which
case they will be converted to a gimple operand if necessary.

This function returns the newly created @code{GIMPLE_ASSIGN} tuple.

@deftypefn {GIMPLE function} gimple gimple_build_assign_with_ops @
(enum tree_code subcode, tree lhs, tree op1, tree op2)
This function is similar to @code{gimple_build_assign}, but is used to
build a @code{GIMPLE_ASSIGN} statement when the operands of the
right-hand side of the assignment are already split into
different operands.

The left-hand side is an lvalue passed in lhs.  Subcode is the
@code{tree_code} for the right-hand side of the assignment.  Op1 and op2
are the operands.  If op2 is null, subcode must be a @code{tree_code}
for a unary expression.
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_assign_rhs_code (gimple g)
Return the code of the expression computed on the @code{RHS} of
assignment statement @code{G}.
@end deftypefn
 

@deftypefn {GIMPLE function} enum gimple_rhs_class gimple_assign_rhs_class (gimple g)
Return the gimple rhs class of the code for the expression
computed on the rhs of assignment statement @code{G}.  This will never
return @code{GIMPLE_INVALID_RHS}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_assign_lhs (gimple g)
Return the @code{LHS} of assignment statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_lhs_ptr (gimple g)
Return a pointer to the @code{LHS} of assignment statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_assign_rhs1 (gimple g)
Return the first operand on the @code{RHS} of assignment statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_rhs1_ptr (gimple g)
Return the address of the first operand on the @code{RHS} of assignment
statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_assign_rhs2 (gimple g)
Return the second operand on the @code{RHS} of assignment statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)
Return the address of the second operand on the @code{RHS} of assignment
statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_assign_set_lhs (gimple g, tree lhs)
Set @code{LHS} to be the @code{LHS} operand of assignment statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_assign_set_rhs1 (gimple g, tree rhs)
Set @code{RHS} to be the first operand on the @code{RHS} of assignment
statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_assign_rhs2 (gimple g)
Return the second operand on the @code{RHS} of assignment statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)
Return a pointer to the second operand on the @code{RHS} of assignment
statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_assign_set_rhs2 (gimple g, tree rhs)
Set @code{RHS} to be the second operand on the @code{RHS} of assignment
statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_assign_cast_p (gimple s)
Return true if @code{S} is an type-cast assignment.
@end deftypefn


@node @code{GIMPLE_BIND}
@subsection @code{GIMPLE_BIND}
@cindex @code{GIMPLE_BIND}

@deftypefn {GIMPLE function} gimple gimple_build_bind (tree vars, gimple_seq body)
Build a @code{GIMPLE_BIND} statement with a list of variables in @code{VARS}
and a body of statements in sequence @code{BODY}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_bind_vars (gimple g)
Return the variables declared in the @code{GIMPLE_BIND} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_set_vars (gimple g, tree vars)
Set @code{VARS} to be the set of variables declared in the @code{GIMPLE_BIND}
statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_append_vars (gimple g, tree vars)
Append @code{VARS} to the set of variables declared in the @code{GIMPLE_BIND}
statement @code{G}.
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_bind_body (gimple g)
Return the GIMPLE sequence contained in the @code{GIMPLE_BIND} statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_set_body (gimple g, gimple_seq seq)
Set @code{SEQ} to be sequence contained in the @code{GIMPLE_BIND} statement @code{G}.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_add_stmt (gimple gs, gimple stmt)
Append a statement to the end of a @code{GIMPLE_BIND}'s body. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_add_seq (gimple gs, gimple_seq seq)
Append a sequence of statements to the end of a @code{GIMPLE_BIND}'s
body.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_bind_block (gimple g)
Return the @code{TREE_BLOCK} node associated with @code{GIMPLE_BIND} statement
@code{G}. This is analogous to the @code{BIND_EXPR_BLOCK} field in trees. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_set_block (gimple g, tree block)
Set @code{BLOCK} to be the @code{TREE_BLOCK} node associated with @code{GIMPLE_BIND}
statement @code{G}. 
@end deftypefn


@node @code{GIMPLE_CALL}
@subsection @code{GIMPLE_CALL}
@cindex @code{GIMPLE_CALL}

@deftypefn {GIMPLE function} gimple gimple_build_call (tree fn, unsigned nargs, ...)
Build a @code{GIMPLE_CALL} statement to function @code{FN}.  The argument @code{FN}
must be either a @code{FUNCTION_DECL} or a gimple call address as
determined by @code{is_gimple_call_addr}.  @code{NARGS} are the number of
arguments.  The rest of the arguments follow the argument @code{NARGS},
and must be trees that are valid as rvalues in gimple (i.e., each
operand is validated with @code{is_gimple_operand}).
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_call_from_tree (tree call_expr)
Build a @code{GIMPLE_CALL} from a @code{CALL_EXPR} node.  The arguments and the
function are taken from the expression directly.  This routine
assumes that @code{call_expr} is already in GIMPLE form.  That is, its
operands are GIMPLE values and the function call needs no further
simplification.  All the call flags in @code{call_expr} are copied over
to the new @code{GIMPLE_CALL}.
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_build_call_vec (tree fn, @code{VEC}(tree, heap) *args)
Identical to @code{gimple_build_call} but the arguments are stored in a
@code{VEC}().
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_call_lhs (gimple g)
Return the @code{LHS} of call statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_call_lhs_ptr (gimple g)
Return a pointer to the @code{LHS} of call statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_call_set_lhs (gimple g, tree lhs)
Set @code{LHS} to be the @code{LHS} operand of call statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_fn (gimple g)
Return the tree node representing the function called by call
statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_call_set_fn (gimple g, tree fn)
Set @code{FN} to be the function called by call statement @code{G}.  This has
to be a gimple value specifying the address of the called
function.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_fndecl (gimple g)
If a given @code{GIMPLE_CALL}'s callee is a @code{FUNCTION_DECL}, return it.
Otherwise return @code{NULL}.  This function is analogous to
@code{get_callee_fndecl} in @code{GENERIC}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_set_fndecl (gimple g, tree fndecl)
Set the called function to @code{FNDECL}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_call_return_type (gimple g)
Return the type returned by call statement @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_chain (gimple g)
Return the static chain for call statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_set_chain (gimple g, tree chain)
Set @code{CHAIN} to be the static chain for call statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_call_num_args (gimple g)
Return the number of arguments used by call statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_call_arg (gimple g, unsigned index)
Return the argument at position @code{INDEX} for call statement @code{G}.  The
first argument is 0.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_call_arg_ptr (gimple g, unsigned index)
Return a pointer to the argument at position @code{INDEX} for call
statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_set_arg (gimple g, unsigned index, tree arg)
Set @code{ARG} to be the argument at position @code{INDEX} for call statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_set_tail (gimple s)
Mark call statement @code{S} as being a tail call (i.e., a call just
before the exit of a function). These calls are candidate for
tail call optimization. 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_call_tail_p (gimple s)
Return true if @code{GIMPLE_CALL} @code{S} is marked as a tail call. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_mark_uninlinable (gimple s)
Mark @code{GIMPLE_CALL} @code{S} as being uninlinable. 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_call_cannot_inline_p (gimple s)
Return true if @code{GIMPLE_CALL} @code{S} cannot be inlined. 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_call_noreturn_p (gimple s)
Return true if @code{S} is a noreturn call. 
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)
Build a @code{GIMPLE_CALL} identical to @code{STMT} but skipping the arguments
in the positions marked by the set @code{ARGS_TO_SKIP}.
@end deftypefn


@node @code{GIMPLE_CATCH}
@subsection @code{GIMPLE_CATCH}
@cindex @code{GIMPLE_CATCH}

@deftypefn {GIMPLE function} gimple gimple_build_catch (tree types, gimple_seq handler)
Build a @code{GIMPLE_CATCH} statement.  @code{TYPES} are the tree types this
catch handles.  @code{HANDLER} is a sequence of statements with the code
for the handler.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_catch_types (gimple g)
Return the types handled by @code{GIMPLE_CATCH} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_catch_types_ptr (gimple g)
Return a pointer to the types handled by @code{GIMPLE_CATCH} statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_catch_handler (gimple g)
Return the GIMPLE sequence representing the body of the handler
of @code{GIMPLE_CATCH} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_catch_set_types (gimple g, tree t)
Set @code{T} to be the set of types handled by @code{GIMPLE_CATCH} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_catch_set_handler (gimple g, gimple_seq handler)
Set @code{HANDLER} to be the body of @code{GIMPLE_CATCH} @code{G}. 
@end deftypefn

@node @code{GIMPLE_CHANGE_DYNAMIC_TYPE}
@subsection @code{GIMPLE_CHANGE_DYNAMIC_TYPE}
@cindex @code{GIMPLE_CHANGE_DYNAMIC_TYPE}

@deftypefn {GIMPLE function} gimple gimple_build_cdt (tree type, tree ptr)
Build a @code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement.  @code{TYPE} is the new
type for the location @code{PTR}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cdt_new_type (gimple g)
Return the new type set by @code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_cdt_new_type_ptr (gimple g)
Return a pointer to the new type set by
@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cdt_set_new_type (gimple g, tree new_type)
Set @code{NEW_TYPE} to be the type returned by
@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cdt_location (gimple g)
Return the location affected by @code{GIMPLE_CHANGE_DYNAMIC_TYPE}
statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_cdt_location_ptr (gimple g)
Return a pointer to the location affected by
@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cdt_set_location (gimple g, tree ptr)
Set @code{PTR} to be the location affected by @code{GIMPLE_CHANGE_DYNAMIC_TYPE}
statement @code{G}. 
@end deftypefn


@node @code{GIMPLE_COND}
@subsection @code{GIMPLE_COND}
@cindex @code{GIMPLE_COND}

@deftypefn {GIMPLE function} gimple gimple_build_cond (enum tree_code pred_code, tree lhs, tree rhs, tree t_label, tree f_label)
Build a @code{GIMPLE_COND} statement.  @code{A} @code{GIMPLE_COND} statement compares
@code{LHS} and @code{RHS} and if the condition in @code{PRED_CODE} is true, jump to
the label in @code{t_label}, otherwise jump to the label in @code{f_label}.
@code{PRED_CODE} are relational operator tree codes like @code{EQ_EXPR},
@code{LT_EXPR}, @code{LE_EXPR}, @code{NE_EXPR}, etc.
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_cond_from_tree (tree cond, tree t_label, tree f_label)
Build a @code{GIMPLE_COND} statement from the conditional expression
tree @code{COND}.  @code{T_LABEL} and @code{F_LABEL} are as in @code{gimple_build_cond}.
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_cond_code (gimple g)
Return the code of the predicate computed by conditional
statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_code (gimple g, enum tree_code code)
Set @code{CODE} to be the predicate code for the conditional statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_lhs (gimple g)
Return the @code{LHS} of the predicate computed by conditional statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_lhs (gimple g, tree lhs)
Set @code{LHS} to be the @code{LHS} operand of the predicate computed by
conditional statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_rhs (gimple g)
Return the @code{RHS} operand of the predicate computed by conditional
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_rhs (gimple g, tree rhs)
Set @code{RHS} to be the @code{RHS} operand of the predicate computed by
conditional statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_true_label (gimple g)
Return the label used by conditional statement @code{G} when its
predicate evaluates to true. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_true_label (gimple g, tree label)
Set @code{LABEL} to be the label used by conditional statement @code{G} when
its predicate evaluates to true. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_false_label (gimple g, tree label)
Set @code{LABEL} to be the label used by conditional statement @code{G} when
its predicate evaluates to false. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_false_label (gimple g)
Return the label used by conditional statement @code{G} when its
predicate evaluates to false. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_make_false (gimple g)
Set the conditional @code{COND_STMT} to be of the form 'if (1 == 0)'. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_make_true (gimple g)
Set the conditional @code{COND_STMT} to be of the form 'if (1 == 1)'. 
@end deftypefn

@node @code{GIMPLE_EH_FILTER}
@subsection @code{GIMPLE_EH_FILTER}
@cindex @code{GIMPLE_EH_FILTER}

@deftypefn {GIMPLE function} gimple gimple_build_eh_filter (tree types, gimple_seq failure)
Build a @code{GIMPLE_EH_FILTER} statement.  @code{TYPES} are the filter's
types.  @code{FAILURE} is a sequence with the filter's failure action.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_eh_filter_types (gimple g)
Return the types handled by @code{GIMPLE_EH_FILTER} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_eh_filter_types_ptr (gimple g)
Return a pointer to the types handled by @code{GIMPLE_EH_FILTER}
statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_eh_filter_failure (gimple g)
Return the sequence of statement to execute when @code{GIMPLE_EH_FILTER}
statement fails. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_eh_filter_set_types (gimple g, tree types)
Set @code{TYPES} to be the set of types handled by @code{GIMPLE_EH_FILTER} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_eh_filter_set_failure (gimple g, gimple_seq failure)
Set @code{FAILURE} to be the sequence of statements to execute on
failure for @code{GIMPLE_EH_FILTER} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_eh_filter_must_not_throw (gimple g)
Return the @code{EH_FILTER_MUST_NOT_THROW} flag. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_eh_filter_set_must_not_throw (gimple g, bool mntp)
Set the @code{EH_FILTER_MUST_NOT_THROW} flag. 
@end deftypefn


@node @code{GIMPLE_LABEL}
@subsection @code{GIMPLE_LABEL}
@cindex @code{GIMPLE_LABEL}

@deftypefn {GIMPLE function} gimple gimple_build_label (tree label)
Build a @code{GIMPLE_LABEL} statement with corresponding to the tree
label, @code{LABEL}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_label_label (gimple g)
Return the @code{LABEL_DECL} node used by @code{GIMPLE_LABEL} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_label_set_label (gimple g, tree label)
Set @code{LABEL} to be the @code{LABEL_DECL} node used by @code{GIMPLE_LABEL}
statement @code{G}. 
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_goto (tree dest)
Build a @code{GIMPLE_GOTO} statement to label @code{DEST}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_goto_dest (gimple g)
Return the destination of the unconditional jump @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_goto_set_dest (gimple g, tree dest)
Set @code{DEST} to be the destination of the unconditional jump @code{G}.
@end deftypefn


@node @code{GIMPLE_NOP}
@subsection @code{GIMPLE_NOP}
@cindex @code{GIMPLE_NOP}

@deftypefn {GIMPLE function} gimple gimple_build_nop (void)
Build a @code{GIMPLE_NOP} statement.
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_nop_p (gimple g)
Returns @code{TRUE} if statement @code{G} is a @code{GIMPLE_NOP}. 
@end deftypefn

@node @code{GIMPLE_OMP_ATOMIC_LOAD}
@subsection @code{GIMPLE_OMP_ATOMIC_LOAD}
@cindex @code{GIMPLE_OMP_ATOMIC_LOAD}

@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_load (tree lhs, tree rhs)
Build a @code{GIMPLE_OMP_ATOMIC_LOAD} statement.  @code{LHS} is the left-hand
side of the assignment.  @code{RHS} is the right-hand side of the
assignment.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_lhs (gimple g, tree lhs)
Set the @code{LHS} of an atomic load. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_lhs (gimple g)
Get the @code{LHS} of an atomic load. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_rhs (gimple g, tree rhs)
Set the @code{RHS} of an atomic set. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_rhs (gimple g)
Get the @code{RHS} of an atomic set. 
@end deftypefn


@node @code{GIMPLE_OMP_ATOMIC_STORE}
@subsection @code{GIMPLE_OMP_ATOMIC_STORE}
@cindex @code{GIMPLE_OMP_ATOMIC_STORE}

@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_store (tree val)
Build a @code{GIMPLE_OMP_ATOMIC_STORE} statement. @code{VAL} is the value to be
stored.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_atomic_store_set_val (gimple g, tree val)
Set the value being stored in an atomic store. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_atomic_store_val (gimple g)
Return the value being stored in an atomic store. 
@end deftypefn

@node @code{GIMPLE_OMP_CONTINUE}
@subsection @code{GIMPLE_OMP_CONTINUE}
@cindex @code{GIMPLE_OMP_CONTINUE}

@deftypefn {GIMPLE function} gimple gimple_build_omp_continue (tree control_def, tree control_use)
Build a @code{GIMPLE_OMP_CONTINUE} statement.  @code{CONTROL_DEF} is the
definition of the control variable.  @code{CONTROL_USE} is the use of
the control variable.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def (gimple s)
Return the definition of the control variable on a
@code{GIMPLE_OMP_CONTINUE} in @code{S}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def_ptr (gimple s)
Same as above, but return the pointer.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_def (gimple s)
Set the control variable definition for a @code{GIMPLE_OMP_CONTINUE}
statement in @code{S}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use (gimple s)
Return the use of the control variable on a @code{GIMPLE_OMP_CONTINUE}
in @code{S}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use_ptr (gimple s)
Same as above, but return the pointer.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_use (gimple s)
Set the control variable use for a @code{GIMPLE_OMP_CONTINUE} statement
in @code{S}.
@end deftypefn


@node @code{GIMPLE_OMP_CRITICAL}
@subsection @code{GIMPLE_OMP_CRITICAL}
@cindex @code{GIMPLE_OMP_CRITICAL}

@deftypefn {GIMPLE function} gimple gimple_build_omp_critical (gimple_seq body, tree name)
Build a @code{GIMPLE_OMP_CRITICAL} statement. @code{BODY} is the sequence of
statements for which only one thread can execute.  @code{NAME} is an
optional identifier for this critical block.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_critical_name (gimple g)
Return the name associated with @code{OMP_CRITICAL} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_critical_name_ptr (gimple g)
Return a pointer to the name associated with @code{OMP} critical
statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_critical_set_name (gimple g, tree name)
Set @code{NAME} to be the name associated with @code{OMP} critical statement @code{G}. 
@end deftypefn

@node @code{GIMPLE_OMP_FOR}
@subsection @code{GIMPLE_OMP_FOR}
@cindex @code{GIMPLE_OMP_FOR}

@deftypefn {GIMPLE function} gimple gimple_build_omp_for (gimple_seq body, @
tree clauses, tree index, tree initial, tree final, tree incr, @
gimple_seq pre_body, enum tree_code omp_for_cond)
Build a @code{GIMPLE_OMP_FOR} statement. @code{BODY} is sequence of statements
inside the for loop.  @code{CLAUSES}, are any of the @code{OMP} loop
construct's clauses: private, firstprivate,  lastprivate,
reductions, ordered, schedule, and nowait.  @code{PRE_BODY} is the
sequence of statements that are loop invariant.  @code{INDEX} is the
index variable.  @code{INITIAL} is the initial value of @code{INDEX}.  @code{FINAL} is
final value of @code{INDEX}.  OMP_FOR_COND is the predicate used to
compare @code{INDEX} and @code{FINAL}.  @code{INCR} is the increment expression.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_clauses (gimple g)
Return the clauses associated with @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_clauses_ptr (gimple g)
Return a pointer to the @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the list of clauses associated with @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_index (gimple g)
Return the index variable for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_index_ptr (gimple g)
Return a pointer to the index variable for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_index (gimple g, tree index)
Set @code{INDEX} to be the index variable for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_initial (gimple g)
Return the initial value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_initial_ptr (gimple g)
Return a pointer to the initial value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_initial (gimple g, tree initial)
Set @code{INITIAL} to be the initial value for @code{OMP_FOR} @code{G}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_final (gimple g)
Return the final value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_final_ptr (gimple g)
turn a pointer to the final value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_final (gimple g, tree final)
Set @code{FINAL} to be the final value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_incr (gimple g)
Return the increment value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_incr_ptr (gimple g)
Return a pointer to the increment value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_incr (gimple g, tree incr)
Set @code{INCR} to be the increment value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_omp_for_pre_body (gimple g)
Return the sequence of statements to execute before the @code{OMP_FOR}
statement @code{G} starts. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_pre_body (gimple g, gimple_seq pre_body)
Set @code{PRE_BODY} to be the sequence of statements to execute before
the @code{OMP_FOR} statement @code{G} starts.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_for_set_cond (gimple g, enum tree_code cond)
Set @code{COND} to be the condition code for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_omp_for_cond (gimple g)
Return the condition code associated with @code{OMP_FOR} @code{G}. 
@end deftypefn


@node @code{GIMPLE_OMP_MASTER}
@subsection @code{GIMPLE_OMP_MASTER}
@cindex @code{GIMPLE_OMP_MASTER}

@deftypefn {GIMPLE function} gimple gimple_build_omp_master (gimple_seq body)
Build a @code{GIMPLE_OMP_MASTER} statement. @code{BODY} is the sequence of
statements to be executed by just the master.
@end deftypefn


@node @code{GIMPLE_OMP_ORDERED}
@subsection @code{GIMPLE_OMP_ORDERED}
@cindex @code{GIMPLE_OMP_ORDERED}

@deftypefn {GIMPLE function} gimple gimple_build_omp_ordered (gimple_seq body)
Build a @code{GIMPLE_OMP_ORDERED} statement.
@end deftypefn

@code{BODY} is the sequence of statements inside a loop that will
executed in sequence.


@node @code{GIMPLE_OMP_PARALLEL}
@subsection @code{GIMPLE_OMP_PARALLEL}
@cindex @code{GIMPLE_OMP_PARALLEL}

@deftypefn {GIMPLE function} gimple gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn, tree data_arg)
Build a @code{GIMPLE_OMP_PARALLEL} statement.
@end deftypefn

@code{BODY} is sequence of statements which are executed in parallel.
@code{CLAUSES}, are the @code{OMP} parallel construct's clauses.  @code{CHILD_FN} is
the function created for the parallel threads to execute.
@code{DATA_ARG} are the shared data argument(s).

@deftypefn {GIMPLE function} bool gimple_omp_parallel_combined_p (gimple g)
Return true if @code{OMP} parallel statement @code{G} has the
@code{GF_OMP_PARALLEL_COMBINED} flag set.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_parallel_set_combined_p (gimple g)
Set the @code{GF_OMP_PARALLEL_COMBINED} field in @code{OMP} parallel statement
@code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} gimple_seq gimple_omp_body (gimple g)
Return the body for the @code{OMP} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_set_body (gimple g, gimple_seq body)
Set @code{BODY} to be the body for the @code{OMP} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_parallel_clauses (gimple g)
Return the clauses associated with @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_parallel_clauses_ptr (gimple g)
Return a pointer to the clauses associated with @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_parallel_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the list of clauses associated with
@code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_parallel_child_fn (gimple g)
Return the child function used to hold the body of @code{OMP_PARALLEL}
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_parallel_child_fn_ptr (gimple g)
Return a pointer to the child function used to hold the body of
@code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_parallel_set_child_fn (gimple g, tree child_fn)
Set @code{CHILD_FN} to be the child function for @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_parallel_data_arg (gimple g)
Return the artificial argument used to send variables and values
from the parent to the children threads in @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_parallel_data_arg_ptr (gimple g)
Return a pointer to the data argument for @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_parallel_set_data_arg (gimple g, tree data_arg)
Set @code{DATA_ARG} to be the data argument for @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} bool is_gimple_omp (gimple stmt)
Returns true when the gimple statement @code{STMT} is any of the OpenMP
types. 
@end deftypefn


@node @code{GIMPLE_OMP_RETURN}
@subsection @code{GIMPLE_OMP_RETURN}
@cindex @code{GIMPLE_OMP_RETURN}

@deftypefn {GIMPLE function} gimple gimple_build_omp_return (bool wait_p)
Build a @code{GIMPLE_OMP_RETURN} statement. @code{WAIT_P} is true if this is a
non-waiting return.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_return_set_nowait (gimple s)
Set the nowait flag on @code{GIMPLE_OMP_RETURN} statement @code{S}.
@end deftypefn
 

@deftypefn {GIMPLE function} bool gimple_omp_return_nowait_p (gimple g)
Return true if @code{OMP} return statement @code{G} has the
@code{GF_OMP_RETURN_NOWAIT} flag set.
@end deftypefn

@node @code{GIMPLE_OMP_SECTION}
@subsection @code{GIMPLE_OMP_SECTION}
@cindex @code{GIMPLE_OMP_SECTION}

@deftypefn {GIMPLE function} gimple gimple_build_omp_section (gimple_seq body)
Build a @code{GIMPLE_OMP_SECTION} statement for a sections statement.
@end deftypefn

@code{BODY} is the sequence of statements in the section.

@deftypefn {GIMPLE function} bool gimple_omp_section_last_p (gimple g)
Return true if @code{OMP} section statement @code{G} has the
@code{GF_OMP_SECTION_LAST} flag set.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_section_set_last (gimple g)
Set the @code{GF_OMP_SECTION_LAST} flag on @code{G}.
@end deftypefn

@node @code{GIMPLE_OMP_SECTIONS}
@subsection @code{GIMPLE_OMP_SECTIONS}
@cindex @code{GIMPLE_OMP_SECTIONS}

@deftypefn {GIMPLE function} gimple gimple_build_omp_sections (gimple_seq body, tree clauses)
Build a @code{GIMPLE_OMP_SECTIONS} statement. @code{BODY} is a sequence of
section statements.  @code{CLAUSES} are any of the @code{OMP} sections
construct's clauses: private, firstprivate, lastprivate,
reduction, and nowait.
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_omp_sections_switch (void)
Build a @code{GIMPLE_OMP_SECTIONS_SWITCH} statement.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_sections_control (gimple g)
Return the control variable associated with the
@code{GIMPLE_OMP_SECTIONS} in @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_omp_sections_control_ptr (gimple g)
Return a pointer to the clauses associated with the
@code{GIMPLE_OMP_SECTIONS} in @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_sections_set_control (gimple g, tree control)
Set @code{CONTROL} to be the set of clauses associated with the
@code{GIMPLE_OMP_SECTIONS} in @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_sections_clauses (gimple g)
Return the clauses associated with @code{OMP_SECTIONS} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_sections_clauses_ptr (gimple g)
Return a pointer to the clauses associated with @code{OMP_SECTIONS} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_sections_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the set of clauses associated with @code{OMP_SECTIONS}
@code{G}. 
@end deftypefn


@node @code{GIMPLE_OMP_SINGLE}
@subsection @code{GIMPLE_OMP_SINGLE}
@cindex @code{GIMPLE_OMP_SINGLE}

@deftypefn {GIMPLE function} gimple gimple_build_omp_single (gimple_seq body, tree clauses)
Build a @code{GIMPLE_OMP_SINGLE} statement. @code{BODY} is the sequence of
statements that will be executed once.  @code{CLAUSES} are any of the
@code{OMP} single construct's clauses: private, firstprivate,
copyprivate, nowait.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_single_clauses (gimple g)
Return the clauses associated with @code{OMP_SINGLE} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_single_clauses_ptr (gimple g)
Return a pointer to the clauses associated with @code{OMP_SINGLE} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_single_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the clauses associated with @code{OMP_SINGLE} @code{G}. 
@end deftypefn


@node @code{GIMPLE_PHI}
@subsection @code{GIMPLE_PHI}
@cindex @code{GIMPLE_PHI}

@deftypefn {GIMPLE function} gimple make_phi_node (tree var, int len)
Build a @code{PHI} node with len argument slots for variable var.
@end deftypefn

@deftypefn {GIMPLE function} unsigned gimple_phi_capacity (gimple g)
Return the maximum number of arguments supported by @code{GIMPLE_PHI} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} unsigned gimple_phi_num_args (gimple g)
Return the number of arguments in @code{GIMPLE_PHI} @code{G}. This must always
be exactly the number of incoming edges for the basic block
holding @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_phi_result (gimple g)
Return the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_phi_result_ptr (gimple g)
Return a pointer to the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_phi_set_result (gimple g, tree result)
Set @code{RESULT} to be the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} struct phi_arg_d *gimple_phi_arg (gimple g, index)
Return the @code{PHI} argument corresponding to incoming edge @code{INDEX} for
@code{GIMPLE_PHI} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_phi_set_arg (gimple g, index, struct phi_arg_d * phiarg)
Set @code{PHIARG} to be the argument corresponding to incoming edge
@code{INDEX} for @code{GIMPLE_PHI} @code{G}. 
@end deftypefn

@node @code{GIMPLE_RESX}
@subsection @code{GIMPLE_RESX}
@cindex @code{GIMPLE_RESX}

@deftypefn {GIMPLE function} gimple gimple_build_resx (int region)
Build a @code{GIMPLE_RESX} statement which is a statement.  This
statement is a placeholder for _Unwind_Resume before we know if a
function call or a branch is needed.  @code{REGION} is the exception
region from which control is flowing.
@end deftypefn

@deftypefn {GIMPLE function} int gimple_resx_region (gimple g)
Return the region number for @code{GIMPLE_RESX} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_resx_set_region (gimple g, int region)
Set @code{REGION} to be the region number for @code{GIMPLE_RESX} @code{G}. 
@end deftypefn

@node @code{GIMPLE_RETURN}
@subsection @code{GIMPLE_RETURN}
@cindex @code{GIMPLE_RETURN}

@deftypefn {GIMPLE function} gimple gimple_build_return (tree retval)
Build a @code{GIMPLE_RETURN} statement whose return value is retval.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_return_retval (gimple g)
Return the return value for @code{GIMPLE_RETURN} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_return_set_retval (gimple g, tree retval)
Set @code{RETVAL} to be the return value for @code{GIMPLE_RETURN} @code{G}. 
@end deftypefn

@node @code{GIMPLE_SWITCH}
@subsection @code{GIMPLE_SWITCH}
@cindex @code{GIMPLE_SWITCH}

@deftypefn {GIMPLE function} gimple gimple_build_switch ( nlabels, tree index, tree default_label, ...)
Build a @code{GIMPLE_SWITCH} statement.  @code{NLABELS} are the number of
labels excluding the default label.  The default label is passed
in @code{DEFAULT_LABEL}.  The rest of the arguments are trees
representing the labels.  Each label is a tree of code
@code{CASE_LABEL_EXPR}.
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_build_switch_vec (tree index, tree default_label, @code{VEC}(tree,heap) *args)
This function is an alternate way of building @code{GIMPLE_SWITCH}
statements.  @code{INDEX} and @code{DEFAULT_LABEL} are as in
gimple_build_switch.  @code{ARGS} is a vector of @code{CASE_LABEL_EXPR} trees
that contain the labels.
@end deftypefn

@deftypefn {GIMPLE function} unsigned gimple_switch_num_labels (gimple g)
Return the number of labels associated with the switch statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_num_labels (gimple g, unsigned nlabels)
Set @code{NLABELS} to be the number of labels for the switch statement
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_switch_index (gimple g)
Return the index variable used by the switch statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_index (gimple g, tree index)
Set @code{INDEX} to be the index variable for switch statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_switch_label (gimple g, unsigned index)
Return the label numbered @code{INDEX}. The default label is 0, followed
by any labels in a switch statement. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_label (gimple g, unsigned index, tree label)
Set the label number @code{INDEX} to @code{LABEL}. 0 is always the default
label. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_switch_default_label (gimple g)
Return the default label for a switch statement. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_default_label (gimple g, tree label)
Set the default label for a switch statement. 
@end deftypefn


@node @code{GIMPLE_TRY}
@subsection @code{GIMPLE_TRY}
@cindex @code{GIMPLE_TRY}

@deftypefn {GIMPLE function} gimple gimple_build_try (gimple_seq eval, gimple_seq cleanup, unsigned int kind)
Build a @code{GIMPLE_TRY} statement.  @code{EVAL} is a sequence with the
expression to evaluate.  @code{CLEANUP} is a sequence of statements to
run at clean-up time.  @code{KIND} is the enumeration value
@code{GIMPLE_TRY_CATCH} if this statement denotes a try/catch construct
or @code{GIMPLE_TRY_FINALLY} if this statement denotes a try/finally
construct.
@end deftypefn

@deftypefn {GIMPLE function} enum gimple_try_flags gimple_try_kind (gimple g)
Return the kind of try block represented by @code{GIMPLE_TRY} @code{G}. This is
either @code{GIMPLE_TRY_CATCH} or @code{GIMPLE_TRY_FINALLY}. 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_try_catch_is_cleanup (gimple g)
Return the @code{GIMPLE_TRY_CATCH_IS_CLEANUP} flag. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_try_eval (gimple g)
Return the sequence of statements used as the body for @code{GIMPLE_TRY}
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_try_cleanup (gimple g)
Return the sequence of statements used as the cleanup body for
@code{GIMPLE_TRY} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_try_set_catch_is_cleanup (gimple g, bool catch_is_cleanup)
Set the @code{GIMPLE_TRY_CATCH_IS_CLEANUP} flag. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_try_set_eval (gimple g, gimple_seq eval)
Set @code{EVAL} to be the sequence of statements to use as the body for
@code{GIMPLE_TRY} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_try_set_cleanup (gimple g, gimple_seq cleanup)
Set @code{CLEANUP} to be the sequence of statements to use as the
cleanup body for @code{GIMPLE_TRY} @code{G}. 
@end deftypefn

@node @code{GIMPLE_WITH_CLEANUP_EXPR}
@subsection @code{GIMPLE_WITH_CLEANUP_EXPR}
@cindex @code{GIMPLE_WITH_CLEANUP_EXPR}

@deftypefn {GIMPLE function} gimple gimple_build_wce (gimple_seq cleanup)
Build a @code{GIMPLE_WITH_CLEANUP_EXPR} statement.  @code{CLEANUP} is the
clean-up expression.
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_wce_cleanup (gimple g)
Return the cleanup sequence for cleanup statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_wce_set_cleanup (gimple g, gimple_seq cleanup)
Set @code{CLEANUP} to be the cleanup sequence for @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_wce_cleanup_eh_only (gimple g)
Return the @code{CLEANUP_EH_ONLY} flag for a @code{WCE} tuple. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_wce_set_cleanup_eh_only (gimple g, bool eh_only_p)
Set the @code{CLEANUP_EH_ONLY} flag for a @code{WCE} tuple. 
@end deftypefn


@node GIMPLE序列 
@section GIMPLE序列 
@cindex GIMPLE sequences 

GIMPLE序列等价于@code{GENERIC}中使用的@code{STATEMENT_LIST}。它们用于将语句链接在一起，当和序列迭代器一起使用的时候，可以提供一个迭代语句的框架。

GIMPLE序列的类型为struct @code{gimple_sequence}。序列指针的类型为@code{gimple_seq}，其与struct @code{gimple_sequence} *相同。当声明一个局部序列时，你可以定义一个类型为struct @code{gimple_sequence}的局部变量。当声明一个分配在垃圾搜集堆中的序列时，使用下面介绍的函数@code{gimple_seq_alloc}。

在标题为序列迭代器的章节中，有一些便利的函数用于在序列中进行迭代。

下面是一个函数列表，用来操作和查询序列。

@deftypefn {GIMPLE function} void gimple_seq_add_stmt (gimple_seq *seq, gimple g)
如果@code{G}不为@code{NULL}，将一条gimple语句链接到序列*@code{SEQ}的结尾。如果*@code{SEQ}为@code{NULL}，则在链接之前分配一个序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_add_seq (gimple_seq *dest, gimple_seq src)
如果@code{SRC}不为@code{NULL}，则将序列@code{SRC}追加到序列*@code{DEST}的结尾。如果*@code{DEST}为@code{NULL}，则在追加之前分配一个新的序列。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_seq_deep_copy (gimple_seq src)
对序列@code{SRC}执行深度复制，并返回结果。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_seq_reverse (gimple_seq seq)
反转序列@code{SEQ}中语句的顺序。返回@code{SEQ}。
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_seq_first (gimple_seq s)
返回序列@code{S}中的第一条语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_seq_last (gimple_seq s)
返回序列@code{S}中的最后一条语句。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_set_last (gimple_seq s, gimple last)
将序列@code{S}中的最后一条语句设置为@code{LAST}中的语句。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_set_first (gimple_seq s, gimple first)
将序列@code{S}中的第一条语句设置为@code{FIRST}中的语句。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_init (gimple_seq s)
将序列@code{S}初始化为空序列。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_seq_alloc (void)
在可以被垃圾搜集的存储中分配一个新的序列，并将其返回。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_copy (gimple_seq dest, gimple_seq src)
将序列@code{SRC}复制到序列@code{DEST}。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_seq_empty_p (gimple_seq s)
如果序列@code{S}为空，则返回真。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq bb_seq (basic_block bb)
返回@code{BB}中的语句序列。
@end deftypefn

@deftypefn {GIMPLE function} void set_bb_seq (basic_block bb, gimple_seq seq)
将@code{BB}中的语句序列设置成@code{SEQ}。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_seq_singleton_p (gimple_seq seq)
确定序列@code{SEQ}中是否只包含一条语句。
@end deftypefn

@node 序列迭代器 
@section 序列迭代器 
@cindex Sequence iterators 

序列迭代器为一些便利的结构，用于在序列中迭代语句。给定序列@code{SEQ}，典型的对gimple序列迭代器的使用为：

@smallexample
gimple_stmt_iterator gsi;

for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))
  @{
    gimple g = gsi_stmt (gsi);
    /* Do something with gimple statement @code{G}.  */
  @}
@end smallexample

也可以向后迭代：

@smallexample
        for (gsi = gsi_last (seq); !gsi_end_p (gsi); gsi_prev (&gsi))
@end smallexample

在基本块上进行前向和后向迭代可以通过配合使用@code{gsi_start_bb}和@code{gsi_last_bb}。

在下面的介绍中，我们有时会用到enum @code{gsi_iterator_update}。对于该枚举的有效操作有：

@itemize @bullet
@item @code{GSI_NEW_STMT}
只有当增加单个语句被时才有效。将迭代器移动到该处。

@item @code{GSI_SAME_STMT}
将迭代器放在相同的语句处。

@item @code{GSI_CONTINUE_LINKING}
将迭代器移动到在相同方向上，适合链接其它语句的位置。
@end itemize

下面为一个函数列表，用于操作和使用语句迭代器。

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_start (gimple_seq seq)
返回一个新的迭代器，指向序列@code{SEQ}的第一个语句。如果@code{SEQ}为空，则迭代器的基本块为@code{NULL}。当迭代器总是需要正确设置基本块的时候，使用@code{gsi_start_bb}。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_start_bb (basic_block bb)
返回一个新的迭代器，指向基本块@code{BB}中的第一条语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_last (gimple_seq seq)
返回一个新的迭代器，初始化为指向序列@code{SEQ}中的最后一条语句。如果@code{SEQ}为空，则迭代器的基本块为@code{NULL}。当迭代器总是需要正确设置基本块的时候，使用@code{gsi_last_bb}。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_last_bb (basic_block bb)
返回一个新的迭代器，指向基本块@code{BB}中的最后一条语句。
@end deftypefn

@deftypefn {GIMPLE function} bool gsi_end_p (gimple_stmt_iterator i)
如果位于@code{I}的结尾，则返回@code{TRUE}。
@end deftypefn

@deftypefn {GIMPLE function} bool gsi_one_before_end_p (gimple_stmt_iterator i)
如果是@code{I}的结尾之前的一个语句，则返回@code{TRUE}。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_next (gimple_stmt_iterator *i)
将迭代器前进到下一个gimple语句。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_prev (gimple_stmt_iterator *i)
将迭代器前进到前一个gimple语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple gsi_stmt (gimple_stmt_iterator i)
返回当前的stmt。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_after_labels (basic_block bb)
返回一个块语句迭代器，指向块@code{BB}中的第一个非标号的语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple *gsi_stmt_ptr (gimple_stmt_iterator *i)
返回指向当前stmt的指针。
@end deftypefn

@deftypefn {GIMPLE function} basic_block gsi_bb (gimple_stmt_iterator i)
返回与该迭代器关联的基本块。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gsi_seq (gimple_stmt_iterator i)
返回与该迭代器关联的序列。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_remove (gimple_stmt_iterator *i, bool remove_eh_info)
从序列中移除当前stmt。迭代器被更新为指向下一条语句。当@code{REMOVE_EH_INFO}为真，则我们将迭代器@code{I}指向的语句从@code{EH}表中移除。否则我们不修改@code{EH}表。通常当语句将从@code{IL}中被移除，并不被插入到其它地方的时候，@code{REMOVE_EH_INFO}应该为真。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_seq_before (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
将语句序列@code{SEQ}链接在由迭代器@code{I}指向的语句之前。@code{MODE}指出了插入操作之后，迭代器要做什么（参见上面的@code{enum gsi_iterator_update}）。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_before (gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode)
Links statement @code{G} before the statement pointed-to by iterator @code{I}.
Updates iterator @code{I} according to @code{MODE}.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
Links sequence @code{SEQ} after the statement pointed-to by iterator @code{I}.
@code{MODE} is as in @code{gsi_insert_after}.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_after (gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode)
Links statement @code{G} after the statement pointed-to by iterator @code{I}.
@code{MODE} is as in @code{gsi_insert_after}.
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gsi_split_seq_after (gimple_stmt_iterator i)
Move all statements in the sequence after @code{I} to a new sequence.
Return this new sequence.
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gsi_split_seq_before (gimple_stmt_iterator *i)
Move all statements in the sequence before @code{I} to a new sequence.
Return this new sequence.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_replace (gimple_stmt_iterator *i, gimple stmt, bool update_eh_info)
Replace the statement pointed-to by @code{I} to @code{STMT}.  If @code{UPDATE_EH_INFO}
is true, the exception handling information of the original
statement is moved to the new statement.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_before (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)
Insert statement @code{STMT} before the statement pointed-to by iterator
@code{I}, update @code{STMT}'s basic block and scan it for new operands.  @code{MODE}
specifies how to update iterator @code{I} after insertion (see enum
@code{gsi_iterator_update}).
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_seq_before (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
Like @code{gsi_insert_before}, but for all the statements in @code{SEQ}.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_after (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)
Insert statement @code{STMT} after the statement pointed-to by iterator
@code{I}, update @code{STMT}'s basic block and scan it for new operands.  @code{MODE}
specifies how to update iterator @code{I} after insertion (see enum
@code{gsi_iterator_update}).
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
Like @code{gsi_insert_after}, but for all the statements in @code{SEQ}.
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_for_stmt (gimple stmt)
Finds iterator for @code{STMT}.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)
Move the statement at @code{FROM} so it comes right after the statement
at @code{TO}.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)
Move the statement at @code{FROM} so it comes right before the statement
at @code{TO}.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_move_to_bb_end (gimple_stmt_iterator *from, basic_block bb)
Move the statement at @code{FROM} to the end of basic block @code{BB}.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_on_edge (edge e, gimple stmt)
Add @code{STMT} to the pending list of edge @code{E}.  No actual insertion is
made until a call to @code{gsi_commit_edge_inserts}() is made.
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_seq_on_edge (edge e, gimple_seq seq)
Add the sequence of statements in @code{SEQ} to the pending list of edge
@code{E}.  No actual insertion is made until a call to
@code{gsi_commit_edge_inserts}() is made.
@end deftypefn

@deftypefn {GIMPLE function} basic_block gsi_insert_on_edge_immediate (edge e, gimple stmt)
类似于@code{gsi_insert_on_edge}+@code{gsi_commit_edge_inserts}。如果需要创建一个新的块，则将其返回。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_commit_one_edge_insert (edge e, basic_block *new_bb)
提交在边@code{E}上进行的插入操作。如果创建了新的基本块，则将@code{NEW_BB}设置为该块，否则将其设置为@code{NULL}。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_commit_edge_inserts (void)
该函数将提交所有要进行的边插入操作，并在需要的时候创建新的基本块。
@end deftypefn


@node 增加一个新的GIMPLE语句代码
@section 增加一个新的GIMPLE语句代码
@cindex Adding a new GIMPLE statement code

增加一个新的GIMPLE语句代码，第一步是修改文件@code{gimple.def}，其包含了所有的GIMPLE代码。然后，你必须增加一个相应的结构体，以及@code{union gimple_statement_d}中的一个实体，这些都在@code{gimple.h}中。这将要求你在@code{gsstruct.def}中增加一个相应的@code{GTY}标记，以及在@code{gss_for_code}中增加处理该标记的代码，这位于@code{gimple.c}中。

为了让垃圾搜集器知道你在@code{gimple.h}中创建的结构体的大小，你需要在@code{gimple_size}增加一个case来处理你的新的GIMPLE语句，位于@code{gimple.c}中。

你可能想创建一个函数来构建新的gimple语句，在@code{gimple.c}中。该函数应该被称作@code{gimple_build_<@code{NEW_TUPLE_NAME}>}，并返回类型为gimple的新的元组。

如果你的新语句需要对其成员或者操作数进行访问的代码，则在@code{gimple.h}中放入简单的inline访问代码，以及在@code{gimple.c}中任何不平凡的访问代码，并在@code{gimple.h}中有相应的函数原型。

@node 语句和操作数遍历
@section 语句和操作数遍历
@cindex Statement and operand traversals
有两个函数可以用于遍历语句和序列：分别为@code{walk_gimple_stmt}和@code{walk_gimple_seq}。还有第三个函数用于遍历语句中的操作数：@code{walk_gimple_op}。

@deftypefn {GIMPLE function} tree walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)
该函数用于在@code{GSI}中遍历当前语句，并可选的使用@code{WI}中存放的遍历状态。如果@code{WI}为@code{NULL}，则在遍历中不保存状态。

回调函数@code{CALLBACK_STMT}被调用。如果@code{CALLBACK_STMT}返回真，则意味着回调函数已经处理了语句的所有操作数，并且无需遍历它的操作数。

如果@code{CALLBACK_STMT}为@code{NULL}或者返回假，则@code{CALLBACK_OP}会在语句的每个操作数上被调用，通过@code{walk_gimple_op}。如果@code{walk_gimple_op}对任意操作数返回了非@code{NULL}，则剩下的操作数将不被扫描。

返回值为对@code{walk_gimple_op}最后调用所返回的值，或者如果没有指定@code{CALLBACK_OP}则返回@code{NULL_TREE}。

@end deftypefn


@deftypefn {GIMPLE function} tree walk_gimple_op (gimple stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)
使用该函数来遍历语句@code{STMT}的操作数。每个操作数通过@code{walk_tree}来遍历，并使用@code{WI}中可选的状态信息。

@code{CALLBACK_OP}在@code{STMT}的每个操作数上被调用，通过@code{walk_tree}。@code{walk_tree}的其它参数必须存放在@code{WI}中。对于每个操作数@code{OP}，@code{walk_tree}被调用为：

@smallexample
    walk_tree (&@code{OP}, @code{CALLBACK_OP}, @code{WI}, @code{WI}- @code{PSET})
@end smallexample

如果@code{CALLBACK_OP}对于一个操作数返回非@code{NULL}，则剩下的操作数不再被扫描。返回值为对@code{walk_tree}最后调用所返回的值，或者如果没有指定@code{CALLBACK_OP}则返回@code{NULL_TREE}。

@end deftypefn


@deftypefn {GIMPLE function} tree walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)
该函数遍历序列@code{SEQ}中的所有语句，在每个语句上调用@code{walk_gimple_stmt}。@code{WI}跟@code{walk_gimple_stmt}中的一样。如果@code{walk_gimple_stmt}返回非@code{NULL}，则停止遍历，并返回值。否则，所有语句都被遍历并返回@code{NULL_TREE}。

@end deftypefn
