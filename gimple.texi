@c Copyright (c) 2008, 2009 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node GIMPLE
@chapter GIMPLE
@cindex GIMPLE

GIMPLE为一个三地址表示，通过将GENERIC表达式分解成不超过3个操作数（有些情况例外，比如函数调用）的元组。虽然我们已经做过一些不同的选择，但GIMPLE在很大程度上受McGill大学的McCAT编译器项目中使用的SIMPLE IL的影响。有一点，SIMPLE不支持@code{goto}。

临时对象被引入，用来存放计算复杂表达式所需要的中间值。另外，GENERIC中所有的控制结构被下降为条件跳转，词法作用域被移除，异常区域被转换成一个异常区域tree。

将GENERIC转换成GIMPLE的编译器过程，被称作@samp{gimplifier}。@samp{gimplifier}按递归的方式进行工作，从原始的GENERIC表达式生成GIMPLE元组。

早期用于GIMPLE表示的实现策略为，使用与前端表示解析树相同的内部数据结构。这会简化实现，因为我们可以利用现存的功能和接口。然而，与抽象语法树（AST）相比，GIMPLE是一个更加严格的表示，因此其不需要tree数据结构所提供的完整复杂的结构。

函数的GENERIC表示被存放在所关联的@code{FUNCTION_DECL} tree结点的@code{DECL_SAVED_TREE}域。其通过调用@code{gimplify_function_tree}来转换成GIMPLE。

如果前端想在tree表示中包含语言特定的tree代码，并提供给后端，则其必须提供一个@code{LANG_HOOKS_GIMPLIFY_EXPR}的定义，其知道如果将前端的tree转换成GIMPLE。通常这样的钩子会涉及许多相同的代码，用来将前端tree扩展成RTL。该函数可以返回被完全下降的GIMPLE，或者可以返回GENERIC tree并让主gimplifier将它们下降；这通常会更简单些。没有被完全下降的GIMPLE被称为``High GIMPLE''，由@code{pass_lower_cf}过程之前的IL组成。High GIMPLE包含一些容器语句，例如词法作用域（由@code{GIMPLE_BIND}来表示），以及嵌套表达式（例如，@code{GIMPLE_TRY}）。而``Low GIMPLE''将所有隐式的控制跳转或者异常表达式都直接暴露成IL和EH区域tree。

C和C++前端目前直接从前端tree转换成GIMPLE，并将其交给后端，而不是首先转换成GENERIC。它们的gimplifier钩子知道所有的@code{_STMT}结点，以及如何将它们转成GENERIC形式。在genericization过程中有一些工作，应该首先被运行，但是@code{STMT_EXPR}的存在意味着，为了将所有的C语句转换成GENERIC，则需要遍历整个tree，所以一起下降会更简单些。如果有人写了一个优化过程，其在更高级别的tree上会工作的更好，则这在将来可能会有改变，但是目前所有的优化都是在GIMPLE上进行的。

你可以使用选项@option{-fdump-tree-gimple}来转储一个类C的GIMPLE表示形式。

@menu
* 元组表示::
* GIMPLE指令集::
* GIMPLE异常处理::
* Temporaries::
* 操作数::
* 操作GIMPLE语句::
* 元组特定访问方法::
* GIMPLE序列::
* 序列迭代器::
* 增加一个新的GIMPLE语句代码::
* 语句和操作数遍历::
@end menu

@node 元组表示
@section 元组表示
@cindex tuples

GIMPLE指令为可变大小的元组，并由两部分组成：一个描述指令和位置的头，一个具有所有操作数的可变长度的身体。元组被组织成一个层次结构，并有3个主要类别。

@subsection @code{gimple_statement_base} (gsbase)
@cindex gimple_statement_base

这是层次结构的根，其存放了大多GIMPLE语句所需要的基本信息。有一些域并不与所有的GIMPLE语句相关，但是被挪到基础结构中是为了利用其它域剩下的空位（从而使得结构体更加紧凑）。结构体在64位主机上占用4个字（32个字节 ）：

@multitable {@code{references_memory_p}} {Size (bits)}
@item Field				@tab Size (bits)
@item @code{code}			@tab 8
@item @code{subcode}			@tab 16
@item @code{no_warning}			@tab 1
@item @code{visited}			@tab 1
@item @code{nontemporal_move}		@tab 1
@item @code{plf}			@tab 2
@item @code{modified}			@tab 1
@item @code{has_volatile_ops}		@tab 1
@item @code{references_memory_p}	@tab 1
@item @code{uid}			@tab 32
@item @code{location}			@tab 32
@item @code{num_ops}			@tab 32
@item @code{bb}				@tab 64
@item @code{block}			@tab 63
@item Total size			@tab 32 bytes	
@end multitable

@itemize @bullet
@item @code{code}
GIMPLE指令的主要标识 

@item @code{subcode}
用来区分相同基本指令的不同变体，或者提供使用于给定代码的标记。@code{subcode}标记域具有不同的用法，并取决于指令的代码，但是其主要是用来区分相同家族的指令。该域最突出的用法是在赋值中，其子代码指出了在赋值的右手边所进行的操作。例如，a = b + c被编码为@code{GIMPLE_ASSIGN <PLUS_EXPR, a, b, c>}。

@item @code{no_warning}
位标记，用来指出是否在该语句上已经产生了一个警告。

@item @code{visited}
通用目的的“访问”标记 。由每个编译过程根据需要来设置和清除。

@item @code{nontemporal_move}
位标记，用在赋值中，用来表示非临时的移动。虽然该位标记只用于赋值，但其被放到这里是为了利用先前域所剩下的空位。

@item @code{plf}
编译过程局部标记。该2个位的掩码可以由任何编译过程用作通用的标记。编译过程负责相应的清除和设置这两个标记。

@item @code{modified}
位标记，用来指出语句是否被修改。主要由操作数扫描器来使用，用来确定什么时候重新扫描一条语句的操作数。

@item @code{has_volatile_ops}
位标记，用来指出语句是否包含被标记为volatile的操作数。

@item @code{references_memory_p}
位标记，用来指出语句是否包含内存引用（即，其操作数为全局变量，或者指针解引用，或者任何必须在内存中的）。

@item @code{uid}
为无符号整数，由想要为每条语句分配ID的编译过程使用。这些ID必须由每个编译过程来分配和使用。

@item @code{location}
为一个@code{location_t}标识符，用来指定该语句的源代码位置。其从前端继承下来。

@item @code{num_ops}
该语句具有的操作数个数。这描述了元组中嵌套的操作数向量的大小。只在一些元组中使用，但其声明在基础元组中是为了利用先前语所剩下的32位空位。

@item @code{bb}
包含该语句的基本块。
 
@item @code{block}
包含该语句的词法块。还用于调试信息的生成。

@end itemize

@subsection @code{gimple_statement_with_ops}
@cindex gimple_statement_with_ops

该元组实际分成两部分：@code{gimple_statement_with_ops_base} 和 @code{gimple_statement_with_ops}。这是为了适应操作数向量的分配方法。操作数向量被定义为有1个元素的数组。所以，要分配动态数目的操作数，内存分配器(@code{gimple_alloc})只是简单的分配足够的内存来存放结构体本身，以及在结构体尾部加上@code{N - 1}个操作数。例如，要为有3个操作数的元组分配空间，@code{gimple_alloc}预留了@code{sizeof (struct gimple_statement_with_ops) + 2 * sizeof (tree)}个字节。

另一方面，该元组中的一些域需要与@code{gimple_statement_with_memory_ops}元组共享。所以，这些公共域被放在@code{gimple_statement_with_ops_base}中，然后由其它两个元组来继承。

@multitable {@code{addresses_taken}}	{56 + 8 * @code{num_ops} bytes}
@item	@code{gsbase}		@tab 256	
@item	@code{addresses_taken}	@tab 64	
@item	@code{def_ops}		@tab 64	
@item	@code{use_ops}		@tab 64	
@item	@code{op}		@tab @code{num_ops} * 64	
@item	Total size		@tab 56 + 8 * @code{num_ops} bytes
@end multitable

@itemize @bullet
@item @code{gsbase}
继承自@code{struct gimple_statement_base}。

@item @code{addresses_taken}
位图，存放了所有@code{VAR_DECL}的UID，该语句使用了这些@code{VAR_DECL}的地址。例如，形式为@code{p = &b}的语句将在该集合中具有符号@code{b}的UID。

@item @code{def_ops}
指针数组，指向操作数数组，指出该包含语句写入的变量的所有插槽。该数组还用于立即使用链。注意，是可以不依赖该数组的，但是这种实现会很具有入侵性。

@item @code{use_ops}
类似于@code{def_ops}，不过是针对语句读取的变量。

@item @code{op}
具有@code{num_ops}插槽的tree数组。
@end itemize

@subsection @code{gimple_statement_with_memory_ops}

该元组本质上等同于@code{gimple_statement_with_ops}，除了其包含4个额外的域，来存放与内存存储和加载相关的向量。类似于先前的情况，结构体被分成两部分，用来容纳操作数向量(@code{gimple_statement_with_memory_ops_base}和@code{gimple_statement_with_memory_ops})。

@multitable {@code{addresses_taken}}	{88 + 8 * @code{num_ops} bytes}
@item Field				@tab Size (bits)
@item @code{gsbase}			@tab 256
@item @code{addresses_taken}		@tab 64
@item @code{def_ops}			@tab 64
@item @code{use_ops}			@tab 64
@item @code{vdef_ops}			@tab 64
@item @code{vuse_ops}			@tab 64
@item @code{stores}			@tab 64	
@item @code{loads}			@tab 64	
@item @code{op}				@tab @code{num_ops} * 64	
@item Total size			@tab 88 + 8 * @code{num_ops} bytes
@end multitable

@itemize @bullet
@item @code{vdef_ops}
类似于@code{def_ops}，不过用于@code{VDEF}操作符。这是该语句写入的内存符号的一个实体。这用于维护内存SSA use-def和def-def链。

@item @code{vuse_ops}
类似于@code{use_ops}，不过用于@code{VUSE}操作数。这是该语句加载的内存符号的一个实体。这用于维护内存SSA use-def链。

@item @code{stores}
位集合，该语句写入的符号的所有UID。这与@code{vdef_ops}不同之处是，所有被影响的符号都在该集合中被提到。如果开启了内存划分，则@code{vdef_ops}向量将指向内存划分。而且，该集合中不存放SSA信息。

@item @code{loads}
类似于@code{stores}，不过用于内存加载。（注意，这里有一些冗余，应该可以通过移除这些集合来减少内存使用）。

@end itemize

所有其它元组按照这三个基本元组来定义。每个元组会增加一些域。gimple类型被定义成所有这些结构体的联合体（为了清晰，省略掉了@code{GTY}标记）：

@smallexample
union gimple_statement_d
@{
  struct gimple_statement_base gsbase;
  struct gimple_statement_with_ops gsops;
  struct gimple_statement_with_memory_ops gsmem;
  struct gimple_statement_omp omp;
  struct gimple_statement_bind gimple_bind;
  struct gimple_statement_catch gimple_catch;
  struct gimple_statement_eh_filter gimple_eh_filter;
  struct gimple_statement_phi gimple_phi;
  struct gimple_statement_resx gimple_resx;
  struct gimple_statement_try gimple_try;
  struct gimple_statement_wce gimple_wce;
  struct gimple_statement_asm gimple_asm;
  struct gimple_statement_omp_critical gimple_omp_critical;
  struct gimple_statement_omp_for gimple_omp_for;
  struct gimple_statement_omp_parallel gimple_omp_parallel;
  struct gimple_statement_omp_task gimple_omp_task;
  struct gimple_statement_omp_sections gimple_omp_sections;
  struct gimple_statement_omp_single gimple_omp_single;
  struct gimple_statement_omp_continue gimple_omp_continue;
  struct gimple_statement_omp_atomic_load gimple_omp_atomic_load;
  struct gimple_statement_omp_atomic_store gimple_omp_atomic_store;
@};
@end smallexample

 
@node GIMPLE指令集
@section GIMPLE指令集
@cindex GIMPLE instruction set

下面的表格简短地描述了GIMPLE指令集。

@multitable {@code{GIMPLE_CHANGE_DYNAMIC_TYPE}} {High GIMPLE} {Low GIMPLE}
@item 指令			@tab 高层GIMPLE	    @tab 低层GIMPLE
@item @code{GIMPLE_ASM}			@tab x			@tab x
@item @code{GIMPLE_ASSIGN}		@tab x			@tab x
@item @code{GIMPLE_BIND}		@tab x			@tab
@item @code{GIMPLE_CALL}		@tab x			@tab x
@item @code{GIMPLE_CATCH}		@tab x			@tab
@item @code{GIMPLE_CHANGE_DYNAMIC_TYPE}	@tab x			@tab x
@item @code{GIMPLE_COND}		@tab x			@tab x
@item @code{GIMPLE_EH_FILTER}		@tab x			@tab
@item @code{GIMPLE_GOTO}		@tab x			@tab x
@item @code{GIMPLE_LABEL}		@tab x			@tab x
@item @code{GIMPLE_NOP}			@tab x			@tab x
@item @code{GIMPLE_OMP_ATOMIC_LOAD}	@tab x			@tab x
@item @code{GIMPLE_OMP_ATOMIC_STORE}	@tab x			@tab x
@item @code{GIMPLE_OMP_CONTINUE}	@tab x			@tab x
@item @code{GIMPLE_OMP_CRITICAL}	@tab x			@tab x
@item @code{GIMPLE_OMP_FOR}		@tab x			@tab x
@item @code{GIMPLE_OMP_MASTER}		@tab x			@tab x
@item @code{GIMPLE_OMP_ORDERED}		@tab x			@tab x
@item @code{GIMPLE_OMP_PARALLEL}	@tab x			@tab x
@item @code{GIMPLE_OMP_RETURN}		@tab x			@tab x
@item @code{GIMPLE_OMP_SECTION}		@tab x			@tab x
@item @code{GIMPLE_OMP_SECTIONS}	@tab x			@tab x
@item @code{GIMPLE_OMP_SECTIONS_SWITCH}	@tab x			@tab x
@item @code{GIMPLE_OMP_SINGLE}		@tab x			@tab x
@item @code{GIMPLE_PHI}			@tab 			@tab x
@item @code{GIMPLE_RESX}		@tab			@tab x
@item @code{GIMPLE_RETURN}		@tab x			@tab x
@item @code{GIMPLE_SWITCH}		@tab x			@tab x
@item @code{GIMPLE_TRY}			@tab x			@tab
@end multitable

@node GIMPLE异常处理
@section 异常处理
@cindex GIMPLE Exception Handling

其它异常处理结构使用@code{GIMPLE_TRY_CATCH}来表示。@code{GIMPLE_TRY_CATCH}有两个操作数。第一个操作数为一个要执行的语句序列。如果执行这些语句并没有抛出异常，则第二个操作数被忽略。否则，如果有异常被抛出，则@code{GIMPLE_TRY_CATCH}的第二个操作数将被检查。第二个操作数可以具有以下形式：

@enumerate

@item 一个要执行的语句序列。当发生异常时，这些语句被执行，然后异常被重新抛出。

@item 一个@code{GIMPLE_CATCH}语句序列。每个@code{GIMPLE_CATCH}有一个可适用的异常类型列表和处理代码。如果被抛出的异常匹配其中一个类型，则相关的处理代码被执行。如果处理代码执行到结尾并结束，则在最初的@code{GIMPLE_TRY_CATCH}之后继续执行。

@item 一条@code{GIMPLE_EH_FILTER}语句。具有一个允许的异常类型列表，和当匹配失败时的处理代码。如果被抛出的异常不匹配所允许的类型之一，则相关的匹配失败代码会被执行。如果抛出的异常确实匹配，则继续查找下一个处理。

@end enumerate

目前抛出异常并不直接用GIMPLE来表示，而是通过调用一个函数来实现。将来的某个时候，我们将增加某种方式来表示抛出已知类型的异常的调用。

就在运行优化器之前，编译器将高级别的EH结构下降为一组@samp{goto}，魔术标号，以及EH区域。

@node Temporaries
@section Temporaries
@cindex Temporaries

当gimplification遇到一个过于复杂的子表达式的时候，会创建一个新的临时变量来存放子表达式的值，并且在当前语句之前，增加一条新的语句对其初始化。这些特殊的临时对象被称作@samp{expression temporaries}，并使用@code{get_formal_tmp_var}来分配。编译器总是尝试将相等的表达式放到同一个临时对象中，来简化冗余计算消除。

只有当我们知道在使用表达式临时对象的值之前，其不会被重新求值的时候，才可以使用，否则其将不能被修改@footnote{这些限制源自Morgan 4.8.}。其它临时对象可以使用@code{get_initialized_tmp_var}或@code{create_tmp_var}来分配。

目前，像@code{a = b + 5}这样的表达式没有被进一步简化。我们曾经尝试将其转换成型如

@smallexample
  T1 = b + 5;
  a = T1;
@end smallexample

的样子。但这会使表示变得膨胀，而无法获益。然而，必须在内存中的变量不能出现在表达式中；其值先被显式的加载到一个临时对象中。类似的，将表达式的值存放到内存变量中，也要通过一个临时对象。

@node 操作数
@section 操作数
@cindex Operands

总得来说，GIMPLE表达式由一个运算和适当数目的简单操作数组成；这些操作数必须或者为GIMPLE右值(@code{is_gimple_val})，即一个常量，或者一个寄存器变量。更复杂的操作数被分解到临时对象中，所以，

@smallexample
  a = b + c + d
@end smallexample
会变成
@smallexample
  T1 = b + c;
  a = T1 + d;
@end smallexample

对于@code{GIMPLE_CALL}的参数也是同样的规则。

一个赋值的目标通常为一个变量，但是也可以为一个@code{INDIRECT_REF}或者一个由下面描述的复合左值。

@menu
* 复合表达式::
* 复合左值::
* 条件表达式::
* 逻辑运算符::
@end menu

@node 复合表达式
@subsection 复合表达式
@cindex Compound Expressions

C逗号表达式的左手边被简单的移送到一个独立的语句中。

@node 复合左值
@subsection 复合左值
@cindex Compound Lvalues

目前涉及到数组和结构体域引用的复合左值，没有被分解；像@code{a.b[2] = 42}这样的表达式不再被简化（虽然是复杂的数组下标）。这种限制可以解决之后的优化器的局限性；如果我们要将其转换成

@smallexample
  T1 = &a.b;
  T1[2] = 42;
@end smallexample

则别名分析无法记住对@code{T1[2]}的引用是来自@code{a.b}，所以，其会认为该赋值会与@code{a}的另一个成员有别名关系；这会使@code{struct-alias-1.c}运行失败。将来对优化器的改进可以不再需要限制。

@node 条件表达式
@subsection 条件表达式
@cindex Conditional Expressions

C @code{?:} 表达式被转换成一条@code{if}语句，每个分支被分配给相同的临时对象。所以，

@smallexample
  a = b ? c : d;
@end smallexample
会变成
@smallexample
  if (b == 1)
    T1 = c;
  else
    T1 = d;
  a = T1;
@end smallexample

GIMPLE级别的if-conversion过程在适当的时候，重新引入了@code{?:}表达式。其用于向量化循环。

注意在GIMPLE中，@code{if}语句通过@code{GIMPLE_COND}来表示，正如下面所描述。

@node 逻辑运算符
@subsection 逻辑运算符
@cindex Logical Operators

除非它们出现在@code{GIMPLE_COND}的条件操作数中，否则逻辑的`and'和`or'操作符将按照下列方式进行简化：@code{a = b && c}变成

@smallexample
  T1 = (bool)b;
  if (T1 == true)
    T1 = (bool)c;
  a = T1;
@end smallexample

注意该例子中的@code{T1}不能为表达式临时对象，因为其具有两个不同的赋值。

@subsection 操作操作数

所有的gimple操作数都是@code{tree}类型的。不过只有特定类型的tree可以被用作操作数元组。函数@code{get_gimple_rhs_class}可以进行基本的验证，其给定一个tree代码，返回一个@code{enum}，为下列@code{enum gimple_rhs_class}类型的值

@itemize @bullet
@item @code{GIMPLE_INVALID_RHS}
该tree不能用作GIMPLE操作数。

@item @code{GIMPLE_BINARY_RHS}
该tree为一个有效的GIMPLE二元运算。

@item @code{GIMPLE_UNARY_RHS}
该tree为一个有效的GIMPLE一元运算。

@item @code{GIMPLE_SINGLE_RHS}
该tree为单个对象，不能被拆分成更简单的操作数（例如，@code{SSA_NAME}, @code{VAR_DECL}, @code{COMPONENT_REF}等等）。

该操作数类别还作为转义通口，对于那些可以被平整到操作数向量中，但是右手边会需要多于两个插槽的tree节点。例如，@code{(a op b) ? x : y}的@code{COND_EXPR}表达式，会被平整到使用4个插槽的操作数向量中，但是其还需要额外的处理来从@code{c = a op b ? x : y}中判断@code{c = a op b}。对于@code{ASSERT_EXPR}，也有类似的情况。这些特殊情况的tree表达式应该被平整到操作数向量中。
@end itemize

对于在@code{GIMPLE_BINARY_RHS}和@code{GIMPLE_UNARY_RHS}类别中的tree节点，它们不能被直接存放在元组中。需要首先被平整，分隔到独立的部分。例如，给定GENERIC表达式

@smallexample
a = b + c
@end smallexample

其tree表示为:

@smallexample
MODIFY_EXPR <VAR_DECL  <a>, PLUS_EXPR <VAR_DECL <b>, VAR_DECL <c>>>
@end smallexample

这种情况下，该语句的GIMPLE形式逻辑上等同于它的GENERIC形式，但是在GIMPLE中，赋值语句的右手边@code{PLUS_EXPR}，不被表示成一个tree，替代的，@code{PLUS_EXPR}的两个操作数子树被拿出来，并平整到GIMPLE元组中，如下：

@smallexample
GIMPLE_ASSIGN <PLUS_EXPR, VAR_DECL <a>, VAR_DECL <b>, VAR_DECL <c>>
@end smallexample

@subsection 操作数向量分配

操作数向量被存放在三元组结构的底部。这意味着，取决于给定语句的代码，其操作数向量相对于基本结构体的偏移量会不同。使用下列方法来访问元组操作数

@deftypefn {GIMPLE function} unsigned gimple_num_ops (gimple g)
返回语句@code{G}中的操作数个数。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_op (gimple g, unsigned i)
返回语句@code{G}的第@code{I}个操作数。
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)
返回指向语句@code{G}的操作数向量的指针。这通过内部称作@code{gimple_ops_offset_}[]的表来计算。该表的索引为@code{G}的gimple代码。

当编译器被构建时，将gimple.def中定义的每个语句代码，所对应的结构体大小来填充该表。因为操作数向量在结构体的底部，所以对于gimple代码@code{C}，其偏移量被计算为sizeof (struct-of @code{C}) - sizeof (tree)。

该机制对于使用@code{gimple_op}()的每次访问，都增加了一个内存重定向，如果这会变成瓶颈，则编译过程可以选择记住@code{gimple_ops}()的结果，并使用它来访问操作数。
@end deftypefn

@subsection 操作数有效性

当为gimple语句增加一个新的操作数，将根据每个元组在它操作数向量中可以接受的情况来验证该操作数。这些断言由@code{gimple_<name>_set_...()}调用。元组会使用下列断言（注意，该列表并不全）：

@deftypefn {GIMPLE function} is_gimple_operand (tree t)
这是条件最宽的断言。其实质上是检查t是否具有@code{GIMPLE_SINGLE_RHS}的@code{gimple_rhs_class}。
@end deftypefn


@deftypefn {GIMPLE function} is_gimple_val (tree t)
返回真，如果t为一个“GIMPLE值”，其为所有非寻址的栈变量（@code{is_gimple_reg}返回真的变量）和常量（@code{is_gimple_min_invariant}返回真的表达式）。
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_addressable (tree t)
返回真，如果t为一个符号，或者内存引用，其地址可以被使用。
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_asm_val (tree t)
类似于@code{is_gimple_val}，不过其还接受硬件寄存器。
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_call_addr (tree t)
返回真，如果t为一个有效的表达式，被作用由@code{GIMPLE_CALL}调用的函数。
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_constant (tree t)
返回真，如果t为一个有效的gimple常量。
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_min_invariant (tree t)
返回真，如果t为一个有效的最小不变量。这与常量不同，其特定的值在编译的时候可能不已知，但是知道其不会改变（例如，函数局部变量的地址）。
@end deftypefn

@deftypefn {GIMPLE function} is_gimple_min_invariant_address (tree t)
返回真，如果t为一个@code{ADDR_EXPR}，其在程序运行时不会改变。
@end deftypefn


@subsection 语句有效性

@deftypefn {GIMPLE function} is_gimple_assign (gimple g)
返回真，如果g的代码为@code{GIMPLE_ASSIGN}。
@end deftypefn
 
@deftypefn {GIMPLE function} is_gimple_call (gimple g)
返回真，如果g的代码为@code{GIMPLE_CALL}。
@end deftypefn
 
@deftypefn {GIMPLE function} gimple_assign_cast_p (gimple g)
返回真，如果g为一个@code{GIMPLE_ASSIGN}并执行一个类型转换操作。
@end deftypefn

@node 操作GIMPLE语句
@section 操作GIMPLE语句
@cindex Manipulating GIMPLE statements

这章介绍了所有可用于处理每个GIMPLE指令的函数。

@subsection 通用访问方法
下列为对gimple语句的通用访问。

@deftypefn {GIMPLE function} enum gimple_code gimple_code (gimple g)
返回语句@code{G}的代码。
@end deftypefn
 
@deftypefn {GIMPLE function} basic_block gimple_bb (gimple g)
返回语句@code{G}所属的基本块。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_block (gimple g)
返回包含语句@code{G}的词法作用域。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_expr_type (gimple stmt)
返回@code{STMT}所计算的主表达式。如果@code{STMT}不做任何计算，则返回@code{void_type_node}。这将只为@code{GIMPLE_ASSIGN}, @code{GIMPLE_COND} 和 @code{GIMPLE_CALL}返回一些有意义的东西。对于所有其它元组代码，其将返回@code{void_type_node}。
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_expr_code (gimple stmt)
返回@code{STMT}所计算的表达式的tree代码。这将只为@code{GIMPLE_CALL}, @code{GIMPLE_ASSIGN}和@code{GIMPLE_COND}返回一些有意义的东西。如果@code{STMT}为@code{GIMPLE_CALL}，其将返回@code{CALL_EXPR}。对于@code{GIMPLE_COND}，其返回比较断言的代码。对于@code{GIMPLE_ASSIGN}，其返回赋值语句的右手边所执行的操作代码。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_set_block (gimple g, tree block)
将@code{G}的词法作用域块设置为@code{BLOCK}。
@end deftypefn
 
@deftypefn {GIMPLE function} location_t gimple_locus (gimple g)
返回语句@code{G}的locus信息。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_locus (gimple g, location_t locus)
为语句@code{G}设置locus信息。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_locus_empty_p (gimple g)
返回真，如果@code{G}不具有locus信息。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_no_warning_p (gimple stmt)
返回真，如果对于语句@code{STMT}不会产生警告。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_visited (gimple stmt, bool visited_p)
在语句@code{STMT}上将访问状态设置成@code{VISITED_P}。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_visited_p (gimple stmt)
返回语句@code{STMT}上的访问状态。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_plf (gimple stmt, enum plf_mask plf, bool val_p)
将语句@code{STMT}上的编译过程局部标记@code{PLF}设置为@code{VAL_P}。
@end deftypefn
 
@deftypefn {GIMPLE function} unsigned int gimple_plf (gimple stmt, enum plf_mask plf)
返回语句@code{STMT}上的编译过程局部标记@code{PLF}。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_has_ops (gimple g)
返回真，如果语句@code{G}具有寄存器或内存操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_has_mem_ops (gimple g)
返回真，如果语句@code{G}具有内存操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} unsigned gimple_num_ops (gimple g)
返回语句@code{G}的操作数个数。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)
返回语句@code{G}的操作数数组。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_op (gimple g, unsigned i)
返回语句@code{G}的操作数@code{I}。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_op_ptr (gimple g, unsigned i)
返回语句@code{G}的操作数@code{I}的指针。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_op (gimple g, unsigned i, tree op)
将语句@code{G}的操作数@code{I}设置为@code{OP}。
@end deftypefn
 
@deftypefn {GIMPLE function} bitmap gimple_addresses_taken (gimple stmt)
返回@code{STMT}使用过其地址的符号集合。
@end deftypefn
 
@deftypefn {GIMPLE function} struct def_optype_d *gimple_def_ops (gimple g)
返回语句@code{G}的@code{DEF}操作数集合。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_def_ops (gimple g, struct def_optype_d *def)
将语句@code{G}的@code{DEF}操作数集合设置为@code{DEF}。
@end deftypefn
 
@deftypefn {GIMPLE function} struct use_optype_d *gimple_use_ops (gimple g)
返回语句@code{G}的@code{USE}操作数集合。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_use_ops (gimple g, struct use_optype_d *use)
将语句@code{G}的@code{USE}操作数集合设置为@code{USE}。
@end deftypefn
 
@deftypefn {GIMPLE function} struct voptype_d *gimple_vuse_ops (gimple g)
返回语句@code{G}的@code{VUSE}操作数集合。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_vuse_ops (gimple g, struct voptype_d *ops)
将语句@code{G}的@code{VUSE}操作数集合设置为@code{OPS}。
@end deftypefn
 
@deftypefn {GIMPLE function} struct voptype_d *gimple_vdef_ops (gimple g)
返回语句@code{G}的@code{VDEF}操作数集合。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_vdef_ops (gimple g, struct voptype_d *ops)
将语句@code{G}的@code{VDEF}操作数集合设置为@code{OPS}。
@end deftypefn
 
@deftypefn {GIMPLE function} bitmap gimple_loaded_syms (gimple g)
返回语句@code{G}所加载的符号集合。集合中的每个元素为对应符号的@code{DECL_UID}。
@end deftypefn
 
@deftypefn {GIMPLE function} bitmap gimple_stored_syms (gimple g)
返回语句@code{G}所存储的符号集合。集合中的每个元素为对应符号的@code{DECL_UID}。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_modified_p (gimple g)
返回真，如果语句@code{G}具有操作数并且被修改域已经被设置。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_has_volatile_ops (gimple stmt)
返回真，如果语句@code{STMT}包含volatile操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_set_has_volatile_ops (gimple stmt, bool volatilep)
返回真，如果语句@code{STMT}包含volatile操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} void update_stmt (gimple s)
将语句@code{S}标记为已经被修改，并对其进行更新。
@end deftypefn
 
@deftypefn {GIMPLE function} void update_stmt_if_modified (gimple s)
更新语句@code{S}，如果其已经被标记为被修改。
@end deftypefn
 
@deftypefn {GIMPLE function} gimple gimple_copy (gimple stmt)
返回语句@code{STMT}的一个深度复制。
@end deftypefn

@node 元组特定访问方法
@section 元组特定访问方法
@cindex Tuple specific accessors

@menu
* @code{GIMPLE_ASM}::
* @code{GIMPLE_ASSIGN}::
* @code{GIMPLE_BIND}::
* @code{GIMPLE_CALL}::
* @code{GIMPLE_CATCH}::
* @code{GIMPLE_CHANGE_DYNAMIC_TYPE}::
* @code{GIMPLE_COND}::
* @code{GIMPLE_EH_FILTER}::
* @code{GIMPLE_LABEL}::
* @code{GIMPLE_NOP}::
* @code{GIMPLE_OMP_ATOMIC_LOAD}::
* @code{GIMPLE_OMP_ATOMIC_STORE}::
* @code{GIMPLE_OMP_CONTINUE}::
* @code{GIMPLE_OMP_CRITICAL}::
* @code{GIMPLE_OMP_FOR}::
* @code{GIMPLE_OMP_MASTER}::
* @code{GIMPLE_OMP_ORDERED}::
* @code{GIMPLE_OMP_PARALLEL}::
* @code{GIMPLE_OMP_RETURN}::
* @code{GIMPLE_OMP_SECTION}::
* @code{GIMPLE_OMP_SECTIONS}::
* @code{GIMPLE_OMP_SINGLE}::
* @code{GIMPLE_PHI}::
* @code{GIMPLE_RESX}::
* @code{GIMPLE_RETURN}::
* @code{GIMPLE_SWITCH}::
* @code{GIMPLE_TRY}::
* @code{GIMPLE_WITH_CLEANUP_EXPR}::
@end menu


@node @code{GIMPLE_ASM}
@subsection @code{GIMPLE_ASM}
@cindex @code{GIMPLE_ASM}

@deftypefn {GIMPLE function} gimple gimple_build_asm (const char *string, ninputs, noutputs, nclobbers, ...)
构建一条@code{GIMPLE_ASM}语句。该语句用于内联的汇编结构。@code{STRING}为汇编代码。@code{NINPUT}为寄存器输入的数目。@code{NOUTPUT}为寄存器输出的数目。@code{NCLOBBERS}为被破坏的寄存器的数目。剩下的参数tree对应于每个输入，输出和被破坏的寄存器。
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_build_asm_vec (const char *, VEC(tree,gc) *, VEC(tree,gc) *, VEC(tree,gc) *)
等同于gimple_build_asm，不过参数在VEC中传递。
@end deftypefn

@deftypefn {GIMPLE function} gimple_asm_ninputs (gimple g)
返回@code{GIMPLE_ASM} @code{G}的输入操作数的数目。 
@end deftypefn

@deftypefn {GIMPLE function} gimple_asm_noutputs (gimple g)
返回@code{GIMPLE_ASM} @code{G}的输出操作数的数目。 
@end deftypefn

@deftypefn {GIMPLE function} gimple_asm_nclobbers (gimple g)
返回@code{GIMPLE_ASM} @code{G}的破坏操作数的数目。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_asm_input_op (gimple g, unsigned index)
返回@code{GIMPLE_ASM} @code{G}的索引为@code{INDEX}的输入操作数。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_input_op (gimple g, unsigned index, tree in_op)
将@code{IN_OP}设置为@code{GIMPLE_ASM} @code{G}的索引为@code{INDEX}的输入操作数。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_asm_output_op (gimple g, unsigned index)
返回@code{GIMPLE_ASM} @code{G}的索引为@code{INDEX}的输出操作数。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_output_op (gimple g, @
unsigned index, tree out_op)
将@code{OUT_OP}设置为@code{GIMPLE_ASM} @code{G}的索引为@code{INDEX}的输出操作数。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_asm_clobber_op (gimple g, unsigned index)
返回@code{GIMPLE_ASM} @code{G}的索引为@code{INDEX}的破坏操作数。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_clobber_op (gimple g, unsigned index, tree clobber_op)
将@code{CLOBBER_OP}设置为@code{GIMPLE_ASM} @code{G}的索引为@code{INDEX}的破坏操作数。
@end deftypefn

@deftypefn {GIMPLE function} const char *gimple_asm_string (gimple g)
返回@code{GIMPLE_ASM} @code{G}中的字符串表示的汇编指令。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_asm_volatile_p (gimple g)
返回真，如果@code{G}为一个标记为volatile的asm语句。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_set_volatile (gimple g)
将asm语句@code{G}标记为volatile。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_asm_clear_volatile (gimple g)
从asm语句@code{G}中移除volatile标记。 
@end deftypefn

@node @code{GIMPLE_ASSIGN}
@subsection @code{GIMPLE_ASSIGN}
@cindex @code{GIMPLE_ASSIGN}

@deftypefn {GIMPLE function} gimple gimple_build_assign (tree lhs, tree rhs)
构建一条@code{GIMPLE_ASSIGN}语句。左手边为lhs中传递的左值。右手边可以为一个一元或者二元tree表达式。表达式tree rhs将被平整，其操作数赋值给新语句中相应的操作数插槽中。该函数可用于，你已经有一个tree表达式，并想将其转成元组的时候。然而，不用为了调用该函数，而特意构建表达式tree。如果操作数已经是在独立的tree中，则最好使用@code{gimple_build_assign_with_ops}。
@end deftypefn


@deftypefn {GIMPLE function} gimple gimplify_assign (tree dst, tree src, gimple_seq *seq_p)
构建一个新的@code{GIMPLE_ASSIGN}元组，并将其追加到@code{*SEQ_P}的结尾。
@end deftypefn

@code{DST}/@code{SRC}分别为目的和源。你可以在@code{DST}或@code{SRC}中传递ungimplified tree，它们会在需要的时候被转换成gimple操作数。

该函数返回新创建的@code{GIMPLE_ASSIGN}元组。

@deftypefn {GIMPLE function} gimple gimple_build_assign_with_ops @
(enum tree_code subcode, tree lhs, tree op1, tree op2)
该函数类似于@code{gimple_build_assign}，不过是当赋值的右手边操作数已经被拆分成不同操作数的时候，用来构建一个@code{GIMPLE_ASSIGN}语句。

左手边为在lhs中传递的左值。subcode为赋值的右手边的@code{tree_code}。op1和op2为操作数。如果op2为null，则subcode必须为一个一元表达式的
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_assign_rhs_code (gimple g)
返回赋值语句@code{G}的@code{RHS}上的表达式代码。
@end deftypefn
 
@deftypefn {GIMPLE function} enum gimple_rhs_class gimple_assign_rhs_class (gimple g)
返回赋值语句@code{G}右手边的表达式代码的gimple rhs类别。这个永远不会返回@code{GIMPLE_INVALID_RHS}。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_assign_lhs (gimple g)
返回赋值语句@code{G}的@code{LHS}。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_lhs_ptr (gimple g)
返回指向赋值语句@code{G}的@code{LHS}的指针。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_assign_rhs1 (gimple g)
返回指向赋值语句@code{G}的@code{RHS}的第一个操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_rhs1_ptr (gimple g)
返回指向赋值语句@code{G}的@code{RHS}的第一个操作数的地址。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_assign_rhs2 (gimple g)
返回指向赋值语句@code{G}的@code{RHS}的第二个操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)
返回指向赋值语句@code{G}的@code{RHS}的第二个操作数的地址。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_assign_set_lhs (gimple g, tree lhs)
将@code{LHS}设置为赋值语句@code{G}的@code{LHS}操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_assign_set_rhs1 (gimple g, tree rhs)
将@code{RHS}设置为赋值语句@code{G}的@code{RHS}的第一个操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)
返回指向赋值语句@code{G}的@code{RHS}的第二个操作数的指针。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_assign_set_rhs2 (gimple g, tree rhs)
将@code{RHS}设置为赋值语句@code{G}的@code{RHS}的第二个操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} bool gimple_assign_cast_p (gimple s)
返回真，如果@code{S}为一个有类型转换的赋值。
@end deftypefn


@node @code{GIMPLE_BIND}
@subsection @code{GIMPLE_BIND}
@cindex @code{GIMPLE_BIND}

@deftypefn {GIMPLE function} gimple gimple_build_bind (tree vars, gimple_seq body)
构建一条@code{GIMPLE_BIND}语句，使用@code{VARS}中的变量列表和@code{BODY}序列中的语句体。 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_bind_vars (gimple g)
返回在@code{GIMPLE_BIND}语句@code{G}中声明的变量。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_set_vars (gimple g, tree vars)
将@code{VARS}设置为@code{GIMPLE_BIND}语句@code{G}中的声明变量集。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_append_vars (gimple g, tree vars)
将@code{VARS}追加到@code{GIMPLE_BIND}语句@code{G}中的声明变量集中。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_bind_body (gimple g)
返回在@code{GIMPLE_BIND}语句@code{G}中包含的GIMPLE序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_set_body (gimple g, gimple_seq seq)
将@code{SEQ}设置为@code{GIMPLE_BIND}语句@code{G}中包含的序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_add_stmt (gimple gs, gimple stmt)
追加一条语句到@code{GIMPLE_BIND}的主体的结尾。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_add_seq (gimple gs, gimple_seq seq)
追加一个语句序列到@code{GIMPLE_BIND}的主体的结尾。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_bind_block (gimple g)
返回与@code{GIMPLE_BIND}语句@code{G}相关联的@code{TREE_BLOCK}节点。这类似于tree中的@code{BIND_EXPR_BLOCK}域。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_bind_set_block (gimple g, tree block)
将@code{BLOCK}设置为与@code{GIMPLE_BIND}语句@code{G}相关联的@code{TREE_BLOCK}节点。
@end deftypefn


@node @code{GIMPLE_CALL}
@subsection @code{GIMPLE_CALL}
@cindex @code{GIMPLE_CALL}

@deftypefn {GIMPLE function} gimple gimple_build_call (tree fn, unsigned nargs, ...)
构建一条对函数@code{FN}的@code{GIMPLE_CALL}语句。参数@code{FN}必须为一个@code{FUNCTION_DECL}或者一个由@code{is_gimple_call_addr}确定的gimple调用地址。@code{NARGS}为参数的数目。其余的参数在参数@code{NARGS}之后，必须为可以在gimple中作为右值的tree（即，每个操作数使用@code{is_gimple_operand}验证有效）。
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_call_from_tree (tree call_expr)
根据@code{CALL_EXPR}节点构建一个@code{GIMPLE_CALL}。参数和函数直接取自表达式。该函数假设@code{call_expr}已经是GIMPLE形式。也就是说，其操作数为GIMPLE值，并且函数调用不需要进一步的简化。@code{call_expr}中所有的调用标记被复制到新的@code{GIMPLE_CALL}中。
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_build_call_vec (tree fn, @code{VEC}(tree, heap) *args)
等同于@code{gimple_build_call}，不过参数是存储在@code{VEC}()中。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_call_lhs (gimple g)
返回调用语句@code{G}的@code{LHS}。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_call_lhs_ptr (gimple g)
返回指向调用语句@code{G}的@code{LHS}的指针。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_call_set_lhs (gimple g, tree lhs)
将@code{LHS}设置为调用语句@code{G}的@code{LHS}操作数。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_fn (gimple g)
返回调用语句@code{G}所调用的tree节点表示的函数。
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_call_set_fn (gimple g, tree fn)
将@code{FN}设置为调用语句@code{G}所调用的函数。这必须是一个gimple值，描述了被调用函数的地址。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_fndecl (gimple g)
如果给定的@code{GIMPLE_CALL}的调用者为一个@code{FUNCTION_DECL}，则将其返回。否则返回@code{NULL}。该函数类似于@code{GENERIC}中的@code{get_callee_fndecl}。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_set_fndecl (gimple g, tree fndecl)
将被调用的函数设置为@code{FNDECL}。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_call_return_type (gimple g)
返回调用语句@code{G}所返回的类型。
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_call_chain (gimple g)
返回调用语句@code{G}的静态链。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_set_chain (gimple g, tree chain)
将@code{CHAIN}设置为调用语句@code{G}的静态链。 
@end deftypefn

@deftypefn {GIMPLE function} gimple_call_num_args (gimple g)
返回调用语句@code{G}的参数个数。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_call_arg (gimple g, unsigned index)
返回调用语句@code{G}在位置@code{INDEX}上的参数。第一个参数的索引为0。
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_call_arg_ptr (gimple g, unsigned index)
返回指向调用语句@code{G}在位置@code{INDEX}上的参数的指针。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_set_arg (gimple g, unsigned index, tree arg)
将@code{ARG}设置为调用语句@code{G}在位置@code{INDEX}上的参数。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_set_tail (gimple s)
将调用语句@code{S}标记为一个尾调用（即，就在exit函数之前的调用）。这些调用为尾调用优化的候选。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_call_tail_p (gimple s)
返回真，如果@code{GIMPLE_CALL} @code{S}被标记为尾调用。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_call_mark_uninlinable (gimple s)
将@code{GIMPLE_CALL} @code{S}标记为不可内联的。 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_call_cannot_inline_p (gimple s)
返回真，如果@code{GIMPLE_CALL} @code{S}不能被内联。 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_call_noreturn_p (gimple s)
返回真，如果@code{S}为一个noreturn调用。 
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)
构建一个@code{GIMPLE_CALL}，等同于@code{STMT}，不过跳过由@code{ARGS_TO_SKIP}集标记的位置参数。
@end deftypefn


@node @code{GIMPLE_CATCH}
@subsection @code{GIMPLE_CATCH}
@cindex @code{GIMPLE_CATCH}

@deftypefn {GIMPLE function} gimple gimple_build_catch (tree types, gimple_seq handler)
构建一个@code{GIMPLE_CATCH}语句。@code{TYPES}为该catch所处理的tree类型。@code{HANDLER}是一个语句序列，为处理代码。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_catch_types (gimple g)
返回由@code{GIMPLE_CATCH}语句@code{G}所处理的类型。 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_catch_types_ptr (gimple g)
返回指向由@code{GIMPLE_CATCH}语句@code{G}所处理的类型的指针。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_catch_handler (gimple g)
返回表示@code{GIMPLE_CATCH}语句@code{G}的处理者主体的GIMPLE序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_catch_set_types (gimple g, tree t)
将@code{T}设置为@code{GIMPLE_CATCH}语句@code{G}处理的类型集。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_catch_set_handler (gimple g, gimple_seq handler)
将@code{HANDLER}设置为@code{GIMPLE_CATCH} @code{G}的主体。 
@end deftypefn

@node @code{GIMPLE_CHANGE_DYNAMIC_TYPE}
@subsection @code{GIMPLE_CHANGE_DYNAMIC_TYPE}
@cindex @code{GIMPLE_CHANGE_DYNAMIC_TYPE}

@deftypefn {GIMPLE function} gimple gimple_build_cdt (tree type, tree ptr)
构建一个@code{GIMPLE_CHANGE_DYNAMIC_TYPE}语句。@code{TYPE}为位置@code{PTR}的新类型。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cdt_new_type (gimple g)
返回由@code{GIMPLE_CHANGE_DYNAMIC_TYPE}语句@code{G}设置的新类型。
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_cdt_new_type_ptr (gimple g)
返回一个指针，指向由@code{GIMPLE_CHANGE_DYNAMIC_TYPE}语句@code{G}设置的新类型。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cdt_set_new_type (gimple g, tree new_type)
将@code{NEW_TYPE}设置为@code{GIMPLE_CHANGE_DYNAMIC_TYPE}语句@code{G}返回的类型。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cdt_location (gimple g)
返回@code{GIMPLE_CHANGE_DYNAMIC_TYPE}语句@code{G}所影响的位置。
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_cdt_location_ptr (gimple g)
返回一个指针，指向@code{GIMPLE_CHANGE_DYNAMIC_TYPE}语句@code{G}所影响的位置。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cdt_set_location (gimple g, tree ptr)
将@code{PTR}设置为@code{GIMPLE_CHANGE_DYNAMIC_TYPE}语句@code{G}所影响的位置。
@end deftypefn


@node @code{GIMPLE_COND}
@subsection @code{GIMPLE_COND}
@cindex @code{GIMPLE_COND}

@deftypefn {GIMPLE function} gimple gimple_build_cond (enum tree_code pred_code, tree lhs, tree rhs, tree t_label, tree f_label)
构建一个@code{GIMPLE_COND}语句。@code{A} @code{GIMPLE_COND}语句比较@code{LHS} 和 @code{RHS}，如果@code{PRED_CODE}中的条件为真，则跳到@code{t_label}中的标号上去，否则跳到@code{f_label}中的标号上去。@code{PRED_CODE}为关系操作符tree节点，比如@code{EQ_EXPR},
@code{LT_EXPR}, @code{LE_EXPR}, @code{NE_EXPR}等等。
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_cond_from_tree (tree cond, tree t_label, tree f_label)
跟条件表达式tree@code{COND}，构建一个@code{GIMPLE_COND}语句。@code{T_LABEL} 和 @code{F_LABEL}与@code{gimple_build_cond}中的一样。
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_cond_code (gimple g)
返回条件语句@code{G}计算的断言代码。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_code (gimple g, enum tree_code code)
将@code{CODE}设置为条件语句@code{G}的断言代码。 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_lhs (gimple g)
返回条件语句@code{G}要计算的断言的@code{LHS}操作数。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_lhs (gimple g, tree lhs)
将@code{LHS}设置为条件语句@code{G}要计算的断言的@code{LHS}操作数。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_rhs (gimple g)
返回条件语句@code{G}要计算的断言的@code{RHS}操作数。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_rhs (gimple g, tree rhs)
将@code{RHS}设置为条件语句@code{G}要计算的断言的@code{RHS}操作数。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_true_label (gimple g)
返回条件语句@code{G}当其断言求值为真时使用的标号。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_true_label (gimple g, tree label)
将@code{LABEL}设为条件语句@code{G}当其断言求值为真时使用的标号。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_set_false_label (gimple g, tree label)
将@code{LABEL}设为条件语句@code{G}当其断言求值为假时使用的标号。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_cond_false_label (gimple g)
返回条件语句@code{G}当其断言求值为假时使用的标号。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_make_false (gimple g)
将条件@code{COND_STMT}设置为'if (1 == 0)'的形式。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_cond_make_true (gimple g)
将条件@code{COND_STMT}设置为'if (1 == 1)'的形式。 
@end deftypefn

@node @code{GIMPLE_EH_FILTER}
@subsection @code{GIMPLE_EH_FILTER}
@cindex @code{GIMPLE_EH_FILTER}

@deftypefn {GIMPLE function} gimple gimple_build_eh_filter (tree types, gimple_seq failure)
构建一个@code{GIMPLE_EH_FILTER}语句。@code{TYPES}为过滤器的类型。@code{FAILURE}为一个序列，为过滤器的失败动作。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_eh_filter_types (gimple g)
返回@code{GIMPLE_EH_FILTER}语句@code{G}处理的类型。
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_eh_filter_types_ptr (gimple g)
返回一个指针，指向@code{GIMPLE_EH_FILTER}语句@code{G}处理的类型。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_eh_filter_failure (gimple g)
返回当@code{GIMPLE_EH_FILTER}语句失败时执行的语句序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_eh_filter_set_types (gimple g, tree types)
将@code{TYPES}设置为@code{GIMPLE_EH_FILTER}语句@code{G}处理的类型集。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_eh_filter_set_failure (gimple g, gimple_seq failure)
将@code{FAILURE}设置为@code{GIMPLE_EH_FILTER}语句失败时执行的语句序列。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_eh_filter_must_not_throw (gimple g)
返回@code{EH_FILTER_MUST_NOT_THROW}标记。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_eh_filter_set_must_not_throw (gimple g, bool mntp)
设置@code{EH_FILTER_MUST_NOT_THROW}标记。
@end deftypefn


@node @code{GIMPLE_LABEL}
@subsection @code{GIMPLE_LABEL}
@cindex @code{GIMPLE_LABEL}

@deftypefn {GIMPLE function} gimple gimple_build_label (tree label)
构建一个@code{GIMPLE_LABEL}语句，对应于tree标号@code{LABEL}。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_label_label (gimple g)
返回@code{GIMPLE_LABEL}语句@code{G}使用的@code{LABEL_DECL}节点。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_label_set_label (gimple g, tree label)
将@code{LABEL}设置为@code{GIMPLE_LABEL}语句@code{G}使用的@code{LABEL_DECL}节点。
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_goto (tree dest)
构建一个到标号@code{DEST}的@code{GIMPLE_GOTO}语句。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_goto_dest (gimple g)
返回无条件跳转@code{G}的目的。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_goto_set_dest (gimple g, tree dest)
将@code{DEST}设置为无条件跳转@code{G}的目的。
@end deftypefn


@node @code{GIMPLE_NOP}
@subsection @code{GIMPLE_NOP}
@cindex @code{GIMPLE_NOP}

@deftypefn {GIMPLE function} gimple gimple_build_nop (void)
构建一个@code{GIMPLE_NOP}语句。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_nop_p (gimple g)
返回@code{TRUE}，如果语句@code{G}为一个@code{GIMPLE_NOP}。 
@end deftypefn

@node @code{GIMPLE_OMP_ATOMIC_LOAD}
@subsection @code{GIMPLE_OMP_ATOMIC_LOAD}
@cindex @code{GIMPLE_OMP_ATOMIC_LOAD}

@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_load (tree lhs, tree rhs)
Build a @code{GIMPLE_OMP_ATOMIC_LOAD} statement.  @code{LHS} is the left-hand
side of the assignment.  @code{RHS} is the right-hand side of the
assignment.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_lhs (gimple g, tree lhs)
Set the @code{LHS} of an atomic load. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_lhs (gimple g)
Get the @code{LHS} of an atomic load. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_rhs (gimple g, tree rhs)
Set the @code{RHS} of an atomic set. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_rhs (gimple g)
Get the @code{RHS} of an atomic set. 
@end deftypefn


@node @code{GIMPLE_OMP_ATOMIC_STORE}
@subsection @code{GIMPLE_OMP_ATOMIC_STORE}
@cindex @code{GIMPLE_OMP_ATOMIC_STORE}

@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_store (tree val)
Build a @code{GIMPLE_OMP_ATOMIC_STORE} statement. @code{VAL} is the value to be
stored.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_atomic_store_set_val (gimple g, tree val)
Set the value being stored in an atomic store. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_atomic_store_val (gimple g)
Return the value being stored in an atomic store. 
@end deftypefn

@node @code{GIMPLE_OMP_CONTINUE}
@subsection @code{GIMPLE_OMP_CONTINUE}
@cindex @code{GIMPLE_OMP_CONTINUE}

@deftypefn {GIMPLE function} gimple gimple_build_omp_continue (tree control_def, tree control_use)
Build a @code{GIMPLE_OMP_CONTINUE} statement.  @code{CONTROL_DEF} is the
definition of the control variable.  @code{CONTROL_USE} is the use of
the control variable.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def (gimple s)
Return the definition of the control variable on a
@code{GIMPLE_OMP_CONTINUE} in @code{S}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def_ptr (gimple s)
Same as above, but return the pointer.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_def (gimple s)
Set the control variable definition for a @code{GIMPLE_OMP_CONTINUE}
statement in @code{S}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use (gimple s)
Return the use of the control variable on a @code{GIMPLE_OMP_CONTINUE}
in @code{S}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use_ptr (gimple s)
Same as above, but return the pointer.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_use (gimple s)
Set the control variable use for a @code{GIMPLE_OMP_CONTINUE} statement
in @code{S}.
@end deftypefn


@node @code{GIMPLE_OMP_CRITICAL}
@subsection @code{GIMPLE_OMP_CRITICAL}
@cindex @code{GIMPLE_OMP_CRITICAL}

@deftypefn {GIMPLE function} gimple gimple_build_omp_critical (gimple_seq body, tree name)
Build a @code{GIMPLE_OMP_CRITICAL} statement. @code{BODY} is the sequence of
statements for which only one thread can execute.  @code{NAME} is an
optional identifier for this critical block.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_critical_name (gimple g)
Return the name associated with @code{OMP_CRITICAL} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_critical_name_ptr (gimple g)
Return a pointer to the name associated with @code{OMP} critical
statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_critical_set_name (gimple g, tree name)
Set @code{NAME} to be the name associated with @code{OMP} critical statement @code{G}. 
@end deftypefn

@node @code{GIMPLE_OMP_FOR}
@subsection @code{GIMPLE_OMP_FOR}
@cindex @code{GIMPLE_OMP_FOR}

@deftypefn {GIMPLE function} gimple gimple_build_omp_for (gimple_seq body, @
tree clauses, tree index, tree initial, tree final, tree incr, @
gimple_seq pre_body, enum tree_code omp_for_cond)
Build a @code{GIMPLE_OMP_FOR} statement. @code{BODY} is sequence of statements
inside the for loop.  @code{CLAUSES}, are any of the @code{OMP} loop
construct's clauses: private, firstprivate,  lastprivate,
reductions, ordered, schedule, and nowait.  @code{PRE_BODY} is the
sequence of statements that are loop invariant.  @code{INDEX} is the
index variable.  @code{INITIAL} is the initial value of @code{INDEX}.  @code{FINAL} is
final value of @code{INDEX}.  OMP_FOR_COND is the predicate used to
compare @code{INDEX} and @code{FINAL}.  @code{INCR} is the increment expression.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_clauses (gimple g)
Return the clauses associated with @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_clauses_ptr (gimple g)
Return a pointer to the @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the list of clauses associated with @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_index (gimple g)
Return the index variable for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_index_ptr (gimple g)
Return a pointer to the index variable for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_index (gimple g, tree index)
Set @code{INDEX} to be the index variable for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_initial (gimple g)
Return the initial value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_initial_ptr (gimple g)
Return a pointer to the initial value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_initial (gimple g, tree initial)
Set @code{INITIAL} to be the initial value for @code{OMP_FOR} @code{G}.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_final (gimple g)
Return the final value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_final_ptr (gimple g)
turn a pointer to the final value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_final (gimple g, tree final)
Set @code{FINAL} to be the final value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_for_incr (gimple g)
Return the increment value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_for_incr_ptr (gimple g)
Return a pointer to the increment value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_incr (gimple g, tree incr)
Set @code{INCR} to be the increment value for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_omp_for_pre_body (gimple g)
Return the sequence of statements to execute before the @code{OMP_FOR}
statement @code{G} starts. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_for_set_pre_body (gimple g, gimple_seq pre_body)
Set @code{PRE_BODY} to be the sequence of statements to execute before
the @code{OMP_FOR} statement @code{G} starts.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_for_set_cond (gimple g, enum tree_code cond)
Set @code{COND} to be the condition code for @code{OMP_FOR} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} enum tree_code gimple_omp_for_cond (gimple g)
Return the condition code associated with @code{OMP_FOR} @code{G}. 
@end deftypefn


@node @code{GIMPLE_OMP_MASTER}
@subsection @code{GIMPLE_OMP_MASTER}
@cindex @code{GIMPLE_OMP_MASTER}

@deftypefn {GIMPLE function} gimple gimple_build_omp_master (gimple_seq body)
Build a @code{GIMPLE_OMP_MASTER} statement. @code{BODY} is the sequence of
statements to be executed by just the master.
@end deftypefn


@node @code{GIMPLE_OMP_ORDERED}
@subsection @code{GIMPLE_OMP_ORDERED}
@cindex @code{GIMPLE_OMP_ORDERED}

@deftypefn {GIMPLE function} gimple gimple_build_omp_ordered (gimple_seq body)
Build a @code{GIMPLE_OMP_ORDERED} statement.
@end deftypefn

@code{BODY} is the sequence of statements inside a loop that will
executed in sequence.


@node @code{GIMPLE_OMP_PARALLEL}
@subsection @code{GIMPLE_OMP_PARALLEL}
@cindex @code{GIMPLE_OMP_PARALLEL}

@deftypefn {GIMPLE function} gimple gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn, tree data_arg)
Build a @code{GIMPLE_OMP_PARALLEL} statement.
@end deftypefn

@code{BODY} is sequence of statements which are executed in parallel.
@code{CLAUSES}, are the @code{OMP} parallel construct's clauses.  @code{CHILD_FN} is
the function created for the parallel threads to execute.
@code{DATA_ARG} are the shared data argument(s).

@deftypefn {GIMPLE function} bool gimple_omp_parallel_combined_p (gimple g)
Return true if @code{OMP} parallel statement @code{G} has the
@code{GF_OMP_PARALLEL_COMBINED} flag set.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_parallel_set_combined_p (gimple g)
Set the @code{GF_OMP_PARALLEL_COMBINED} field in @code{OMP} parallel statement
@code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} gimple_seq gimple_omp_body (gimple g)
Return the body for the @code{OMP} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_set_body (gimple g, gimple_seq body)
Set @code{BODY} to be the body for the @code{OMP} statement @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_parallel_clauses (gimple g)
Return the clauses associated with @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_parallel_clauses_ptr (gimple g)
Return a pointer to the clauses associated with @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_parallel_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the list of clauses associated with
@code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_parallel_child_fn (gimple g)
Return the child function used to hold the body of @code{OMP_PARALLEL}
@code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_parallel_child_fn_ptr (gimple g)
Return a pointer to the child function used to hold the body of
@code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_parallel_set_child_fn (gimple g, tree child_fn)
Set @code{CHILD_FN} to be the child function for @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_parallel_data_arg (gimple g)
Return the artificial argument used to send variables and values
from the parent to the children threads in @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_parallel_data_arg_ptr (gimple g)
Return a pointer to the data argument for @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_parallel_set_data_arg (gimple g, tree data_arg)
Set @code{DATA_ARG} to be the data argument for @code{OMP_PARALLEL} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} bool is_gimple_omp (gimple stmt)
Returns true when the gimple statement @code{STMT} is any of the OpenMP
types. 
@end deftypefn


@node @code{GIMPLE_OMP_RETURN}
@subsection @code{GIMPLE_OMP_RETURN}
@cindex @code{GIMPLE_OMP_RETURN}

@deftypefn {GIMPLE function} gimple gimple_build_omp_return (bool wait_p)
Build a @code{GIMPLE_OMP_RETURN} statement. @code{WAIT_P} is true if this is a
non-waiting return.
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_return_set_nowait (gimple s)
Set the nowait flag on @code{GIMPLE_OMP_RETURN} statement @code{S}.
@end deftypefn
 

@deftypefn {GIMPLE function} bool gimple_omp_return_nowait_p (gimple g)
Return true if @code{OMP} return statement @code{G} has the
@code{GF_OMP_RETURN_NOWAIT} flag set.
@end deftypefn

@node @code{GIMPLE_OMP_SECTION}
@subsection @code{GIMPLE_OMP_SECTION}
@cindex @code{GIMPLE_OMP_SECTION}

@deftypefn {GIMPLE function} gimple gimple_build_omp_section (gimple_seq body)
Build a @code{GIMPLE_OMP_SECTION} statement for a sections statement.
@end deftypefn

@code{BODY} is the sequence of statements in the section.

@deftypefn {GIMPLE function} bool gimple_omp_section_last_p (gimple g)
Return true if @code{OMP} section statement @code{G} has the
@code{GF_OMP_SECTION_LAST} flag set.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_section_set_last (gimple g)
Set the @code{GF_OMP_SECTION_LAST} flag on @code{G}.
@end deftypefn

@node @code{GIMPLE_OMP_SECTIONS}
@subsection @code{GIMPLE_OMP_SECTIONS}
@cindex @code{GIMPLE_OMP_SECTIONS}

@deftypefn {GIMPLE function} gimple gimple_build_omp_sections (gimple_seq body, tree clauses)
Build a @code{GIMPLE_OMP_SECTIONS} statement. @code{BODY} is a sequence of
section statements.  @code{CLAUSES} are any of the @code{OMP} sections
construct's clauses: private, firstprivate, lastprivate,
reduction, and nowait.
@end deftypefn


@deftypefn {GIMPLE function} gimple gimple_build_omp_sections_switch (void)
Build a @code{GIMPLE_OMP_SECTIONS_SWITCH} statement.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_sections_control (gimple g)
Return the control variable associated with the
@code{GIMPLE_OMP_SECTIONS} in @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree *gimple_omp_sections_control_ptr (gimple g)
Return a pointer to the clauses associated with the
@code{GIMPLE_OMP_SECTIONS} in @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} void gimple_omp_sections_set_control (gimple g, tree control)
Set @code{CONTROL} to be the set of clauses associated with the
@code{GIMPLE_OMP_SECTIONS} in @code{G}.
@end deftypefn
 
@deftypefn {GIMPLE function} tree gimple_omp_sections_clauses (gimple g)
Return the clauses associated with @code{OMP_SECTIONS} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_sections_clauses_ptr (gimple g)
Return a pointer to the clauses associated with @code{OMP_SECTIONS} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_sections_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the set of clauses associated with @code{OMP_SECTIONS}
@code{G}. 
@end deftypefn


@node @code{GIMPLE_OMP_SINGLE}
@subsection @code{GIMPLE_OMP_SINGLE}
@cindex @code{GIMPLE_OMP_SINGLE}

@deftypefn {GIMPLE function} gimple gimple_build_omp_single (gimple_seq body, tree clauses)
Build a @code{GIMPLE_OMP_SINGLE} statement. @code{BODY} is the sequence of
statements that will be executed once.  @code{CLAUSES} are any of the
@code{OMP} single construct's clauses: private, firstprivate,
copyprivate, nowait.
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_omp_single_clauses (gimple g)
Return the clauses associated with @code{OMP_SINGLE} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_omp_single_clauses_ptr (gimple g)
Return a pointer to the clauses associated with @code{OMP_SINGLE} @code{G}. 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_omp_single_set_clauses (gimple g, tree clauses)
Set @code{CLAUSES} to be the clauses associated with @code{OMP_SINGLE} @code{G}. 
@end deftypefn


@node @code{GIMPLE_PHI}
@subsection @code{GIMPLE_PHI}
@cindex @code{GIMPLE_PHI}

@deftypefn {GIMPLE function} gimple make_phi_node (tree var, int len)
构建一个@code{PHI}节点，对于变量var有len个参数槽。
@end deftypefn

@deftypefn {GIMPLE function} unsigned gimple_phi_capacity (gimple g)
返回@code{GIMPLE_PHI} @code{G}支持的最大参数数目。 
@end deftypefn

@deftypefn {GIMPLE function} unsigned gimple_phi_num_args (gimple g)
返回@code{GIMPLE_PHI} @code{G}中的参数数目。这必须总是为包含@code{G}的基本块的输出边的个数。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_phi_result (gimple g)
返回由@code{GIMPLE_PHI} @code{G}创建的@code{SSA}名字。 
@end deftypefn

@deftypefn {GIMPLE function} tree *gimple_phi_result_ptr (gimple g)
返回一个指针，指向由@code{GIMPLE_PHI} @code{G}创建的@code{SSA}名字。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_phi_set_result (gimple g, tree result)
将@code{RESULT}设置为由@code{GIMPLE_PHI} @code{G}创建的@code{SSA}名字。
@end deftypefn

@deftypefn {GIMPLE function} struct phi_arg_d *gimple_phi_arg (gimple g, index)
返回对应于@code{GIMPLE_PHI} @code{G}的输入边索引为@code{INDEX}的@code{PHI}参数。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_phi_set_arg (gimple g, index, struct phi_arg_d * phiarg)
将@code{PHIARG}设置为对应于@code{GIMPLE_PHI} @code{G}的输入边索引为@code{INDEX}的参数。
@end deftypefn

@node @code{GIMPLE_RESX}
@subsection @code{GIMPLE_RESX}
@cindex @code{GIMPLE_RESX}

@deftypefn {GIMPLE function} gimple gimple_build_resx (int region)
构建一个@code{GIMPLE_RESX}语句。该语句是_Unwind_Resume的占位，在我们知道是否需要函数调用或者分支之前。@code{REGION}为异常区域。
@end deftypefn

@deftypefn {GIMPLE function} int gimple_resx_region (gimple g)
返回@code{GIMPLE_RESX} @code{G}的区域编号。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_resx_set_region (gimple g, int region)
将@code{REGION}设置为@code{GIMPLE_RESX} @code{G}的区域编号。 
@end deftypefn

@node @code{GIMPLE_RETURN}
@subsection @code{GIMPLE_RETURN}
@cindex @code{GIMPLE_RETURN}

@deftypefn {GIMPLE function} gimple gimple_build_return (tree retval)
构建一个@code{GIMPLE_RETURN}语句，其返回值为retval。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_return_retval (gimple g)
返回@code{GIMPLE_RETURN} @code{G}的返回值。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_return_set_retval (gimple g, tree retval)
将@code{RETVAL}设置为@code{GIMPLE_RETURN} @code{G}的返回值。 
@end deftypefn

@node @code{GIMPLE_SWITCH}
@subsection @code{GIMPLE_SWITCH}
@cindex @code{GIMPLE_SWITCH}

@deftypefn {GIMPLE function} gimple gimple_build_switch ( nlabels, tree index, tree default_label, ...)
构建一个@code{GIMPLE_SWITCH}语句。@code{NLABELS}为不包括缺省标号的标号数目。缺省标号在@code{DEFAULT_LABEL}中传递。其余的参数为表示标号的tree。每个标号为一个代码为@code{CASE_LABEL_EXPR}的tree。
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_build_switch_vec (tree index, tree default_label, @code{VEC}(tree,heap) *args)
该函数为一个候选的方式，用来构建@code{GIMPLE_SWITCH}语句。@code{INDEX} 和 @code{DEFAULT_LABEL}与gimple_build_switch中的一样。@code{ARGS}为一个包含了标号的@code{CASE_LABEL_EXPR} tree向量。
@end deftypefn

@deftypefn {GIMPLE function} unsigned gimple_switch_num_labels (gimple g)
返回与switch语句@code{G}相关联的标号数目。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_num_labels (gimple g, unsigned nlabels)
将switch语句@code{G}的标号数目设置为@code{NLABELS}。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_switch_index (gimple g)
返回switch语句@code{G}的索引变量。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_index (gimple g, tree index)
将@code{INDEX}设置为switch语句@code{G}的索引变量。 
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_switch_label (gimple g, unsigned index)
返回编号为@code{INDEX}的标号。缺省标号为0，接着是swith语句中的其它标号。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_label (gimple g, unsigned index, tree label)
将@code{LABEL}的编号设置为@code{INDEX}。0总是为缺省编号。
@end deftypefn

@deftypefn {GIMPLE function} tree gimple_switch_default_label (gimple g)
返回switch语句的缺省标号。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_switch_set_default_label (gimple g, tree label)
为switch语句设置缺省标号。 
@end deftypefn


@node @code{GIMPLE_TRY}
@subsection @code{GIMPLE_TRY}
@cindex @code{GIMPLE_TRY}

@deftypefn {GIMPLE function} gimple gimple_build_try (gimple_seq eval, gimple_seq cleanup, unsigned int kind)
构建一个@code{GIMPLE_TRY}语句。@code{EVAL}为要求值的表达式序列。@code{CLEANUP}为在清除时运行的语句序列。@code{KIND}为枚举值@code{GIMPLE_TRY_CATCH}，如果该语句表示一个try/catch结构，或者@code{GIMPLE_TRY_FINALLY}，如果该语句表示一个try/finally结构。
@end deftypefn

@deftypefn {GIMPLE function} enum gimple_try_flags gimple_try_kind (gimple g)
返回@code{GIMPLE_TRY} @code{G}表示的try块的种类。这是@code{GIMPLE_TRY_CATCH} 或 @code{GIMPLE_TRY_FINALLY}。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_try_catch_is_cleanup (gimple g)
返回@code{GIMPLE_TRY_CATCH_IS_CLEANUP}标记。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_try_eval (gimple g)
返回@code{GIMPLE_TRY} @code{G}的主体使用的语句序列。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_try_cleanup (gimple g)
返回@code{GIMPLE_TRY} @code{G}的清除体使用的语句序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_try_set_catch_is_cleanup (gimple g, bool catch_is_cleanup)
设置@code{GIMPLE_TRY_CATCH_IS_CLEANUP}标记。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_try_set_eval (gimple g, gimple_seq eval)
将@code{EVAL}设置为@code{GIMPLE_TRY} @code{G}的主体使用的语句序列。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_try_set_cleanup (gimple g, gimple_seq cleanup)
将@code{CLEANUP}设置为@code{GIMPLE_TRY} @code{G}的清除体使用的语句序列。
@end deftypefn

@node @code{GIMPLE_WITH_CLEANUP_EXPR}
@subsection @code{GIMPLE_WITH_CLEANUP_EXPR}
@cindex @code{GIMPLE_WITH_CLEANUP_EXPR}

@deftypefn {GIMPLE function} gimple gimple_build_wce (gimple_seq cleanup)
构建一条@code{GIMPLE_WITH_CLEANUP_EXPR}语句。@code{CLEANUP}为一个清除表达式。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_wce_cleanup (gimple g)
返回清除语句@code{G}的清除序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_wce_set_cleanup (gimple g, gimple_seq cleanup)
将@code{CLEANUP}设置为@code{G}的清除序列。 
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_wce_cleanup_eh_only (gimple g)
返回@code{WCE}元组的@code{CLEANUP_EH_ONLY}标记。 
@end deftypefn

@deftypefn {GIMPLE function} void gimple_wce_set_cleanup_eh_only (gimple g, bool eh_only_p)
为@code{WCE}元组设置@code{CLEANUP_EH_ONLY}标记。 
@end deftypefn


@node GIMPLE序列 
@section GIMPLE序列 
@cindex GIMPLE sequences 

GIMPLE序列等价于@code{GENERIC}中使用的@code{STATEMENT_LIST}。它们用于将语句链接在一起，当和序列迭代器一起使用的时候，可以提供一个迭代语句的框架。

GIMPLE序列的类型为struct @code{gimple_sequence}。序列指针的类型为@code{gimple_seq}，其与struct @code{gimple_sequence} *相同。当声明一个局部序列时，你可以定义一个类型为struct @code{gimple_sequence}的局部变量。当声明一个分配在垃圾搜集堆中的序列时，使用下面介绍的函数@code{gimple_seq_alloc}。

在标题为序列迭代器的章节中，有一些便利的函数用于在序列中进行迭代。

下面是一个函数列表，用来操作和查询序列。

@deftypefn {GIMPLE function} void gimple_seq_add_stmt (gimple_seq *seq, gimple g)
如果@code{G}不为@code{NULL}，将一条gimple语句链接到序列*@code{SEQ}的结尾。如果*@code{SEQ}为@code{NULL}，则在链接之前分配一个序列。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_add_seq (gimple_seq *dest, gimple_seq src)
如果@code{SRC}不为@code{NULL}，则将序列@code{SRC}追加到序列*@code{DEST}的结尾。如果*@code{DEST}为@code{NULL}，则在追加之前分配一个新的序列。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_seq_deep_copy (gimple_seq src)
对序列@code{SRC}执行深度复制，并返回结果。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_seq_reverse (gimple_seq seq)
反转序列@code{SEQ}中语句的顺序。返回@code{SEQ}。
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_seq_first (gimple_seq s)
返回序列@code{S}中的第一条语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple gimple_seq_last (gimple_seq s)
返回序列@code{S}中的最后一条语句。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_set_last (gimple_seq s, gimple last)
将序列@code{S}中的最后一条语句设置为@code{LAST}中的语句。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_set_first (gimple_seq s, gimple first)
将序列@code{S}中的第一条语句设置为@code{FIRST}中的语句。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_init (gimple_seq s)
将序列@code{S}初始化为空序列。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gimple_seq_alloc (void)
在可以被垃圾搜集的存储中分配一个新的序列，并将其返回。
@end deftypefn

@deftypefn {GIMPLE function} void gimple_seq_copy (gimple_seq dest, gimple_seq src)
将序列@code{SRC}复制到序列@code{DEST}。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_seq_empty_p (gimple_seq s)
如果序列@code{S}为空，则返回真。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq bb_seq (basic_block bb)
返回@code{BB}中的语句序列。
@end deftypefn

@deftypefn {GIMPLE function} void set_bb_seq (basic_block bb, gimple_seq seq)
将@code{BB}中的语句序列设置成@code{SEQ}。
@end deftypefn

@deftypefn {GIMPLE function} bool gimple_seq_singleton_p (gimple_seq seq)
确定序列@code{SEQ}中是否只包含一条语句。
@end deftypefn

@node 序列迭代器 
@section 序列迭代器 
@cindex Sequence iterators 

序列迭代器为一些便利的结构，用于在序列中迭代语句。给定序列@code{SEQ}，典型的对gimple序列迭代器的使用为：

@smallexample
gimple_stmt_iterator gsi;

for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))
  @{
    gimple g = gsi_stmt (gsi);
    /* Do something with gimple statement @code{G}.  */
  @}
@end smallexample

也可以向后迭代：

@smallexample
        for (gsi = gsi_last (seq); !gsi_end_p (gsi); gsi_prev (&gsi))
@end smallexample

在基本块上进行前向和后向迭代可以通过配合使用@code{gsi_start_bb}和@code{gsi_last_bb}。

在下面的介绍中，我们有时会用到enum @code{gsi_iterator_update}。对于该枚举的有效操作有：

@itemize @bullet
@item @code{GSI_NEW_STMT}
只有当增加单个语句被时才有效。将迭代器移动到该处。

@item @code{GSI_SAME_STMT}
将迭代器放在相同的语句处。

@item @code{GSI_CONTINUE_LINKING}
将迭代器移动到在相同方向上，适合链接其它语句的位置。
@end itemize

下面为一个函数列表，用于操作和使用语句迭代器。

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_start (gimple_seq seq)
返回一个新的迭代器，指向序列@code{SEQ}的第一个语句。如果@code{SEQ}为空，则迭代器的基本块为@code{NULL}。当迭代器总是需要正确设置基本块的时候，使用@code{gsi_start_bb}。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_start_bb (basic_block bb)
返回一个新的迭代器，指向基本块@code{BB}中的第一条语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_last (gimple_seq seq)
返回一个新的迭代器，初始化为指向序列@code{SEQ}中的最后一条语句。如果@code{SEQ}为空，则迭代器的基本块为@code{NULL}。当迭代器总是需要正确设置基本块的时候，使用@code{gsi_last_bb}。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_last_bb (basic_block bb)
返回一个新的迭代器，指向基本块@code{BB}中的最后一条语句。
@end deftypefn

@deftypefn {GIMPLE function} bool gsi_end_p (gimple_stmt_iterator i)
如果位于@code{I}的结尾，则返回@code{TRUE}。
@end deftypefn

@deftypefn {GIMPLE function} bool gsi_one_before_end_p (gimple_stmt_iterator i)
如果是@code{I}的结尾之前的一个语句，则返回@code{TRUE}。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_next (gimple_stmt_iterator *i)
将迭代器前进到下一个gimple语句。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_prev (gimple_stmt_iterator *i)
将迭代器前进到前一个gimple语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple gsi_stmt (gimple_stmt_iterator i)
返回当前的stmt。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_after_labels (basic_block bb)
返回一个块语句迭代器，指向块@code{BB}中的第一个非标号的语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple *gsi_stmt_ptr (gimple_stmt_iterator *i)
返回指向当前stmt的指针。
@end deftypefn

@deftypefn {GIMPLE function} basic_block gsi_bb (gimple_stmt_iterator i)
返回与该迭代器关联的基本块。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gsi_seq (gimple_stmt_iterator i)
返回与该迭代器关联的序列。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_remove (gimple_stmt_iterator *i, bool remove_eh_info)
从序列中移除当前stmt。迭代器被更新为指向下一条语句。当@code{REMOVE_EH_INFO}为真，则我们将迭代器@code{I}指向的语句从@code{EH}表中移除。否则我们不修改@code{EH}表。通常当语句将从@code{IL}中被移除，并不被插入到其它地方的时候，@code{REMOVE_EH_INFO}应该为真。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_seq_before (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
将语句序列@code{SEQ}链接在由迭代器@code{I}指向的语句之前。@code{MODE}指出了插入操作之后，迭代器要做什么（参见上面的@code{enum gsi_iterator_update}）。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_before (gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode)
将语句@code{G}链接在由迭代器@code{I}指向的语句之前。根据@code{MODE}来更新迭代器@code{I}。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
将序列@code{SEQ}链接在由迭代器@code{I}指向的语句之后。@code{MODE}与在@code{gsi_insert_after}中的相同。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_link_after (gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode)
将语句@code{G}链接在由迭代器@code{I}指向的语句之后。@code{MODE}与在@code{gsi_insert_after}中的相同。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gsi_split_seq_after (gimple_stmt_iterator i)
将@code{I}之后的所有语句移送到新的序列中。返回该新的序列。
@end deftypefn

@deftypefn {GIMPLE function} gimple_seq gsi_split_seq_before (gimple_stmt_iterator *i)
将@code{I}之前的所有语句移送到新的序列中。返回该新的序列。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_replace (gimple_stmt_iterator *i, gimple stmt, bool update_eh_info)
将由@code{I}指向的语句替换为@code{STMT}。如果@code{UPDATE_EH_INFO}为真，则原来语句的异常处理信息被移送到新的语句中。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_before (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)
在由迭代器@code{I}指向的语句之前插入语句@code{STMT}，更新@code{STMT}的基本块并扫描新的操作数。@code{MODE}描述了插入操作之后，如何更新迭代器@code{I}(参见enum @code{gsi_iterator_update})。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_seq_before (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
类似于@code{gsi_insert_before}，不过是对于@code{SEQ}中的所有语句。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_after (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)
在由迭代器@code{I}指向的语句之后插入语句@code{STMT}，更新@code{STMT}的基本块并扫描新的操作数。@code{MODE}描述了插入操作之后，如何更新迭代器@code{I}(参见enum @code{gsi_iterator_update})。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)
类似于@code{gsi_insert_after}，不过是对于@code{SEQ}中的所有语句。
@end deftypefn

@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_for_stmt (gimple stmt)
查找@code{STMT}的迭代器。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)
将语句移送到@code{FROM}处，使得其正好位于@code{TO}处的语句之后。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)
将语句移送到@code{FROM}处，使得其正好位于@code{TO}处的语句之前。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_move_to_bb_end (gimple_stmt_iterator *from, basic_block bb)
将@code{FROM}处的语句移送到基本块@code{BB}的结尾。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_on_edge (edge e, gimple stmt)
将@code{STMT}增加到边@code{E}的待定列表中。直到调用@code{gsi_commit_edge_inserts}()之前，不会进行实际的插入操作。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_insert_seq_on_edge (edge e, gimple_seq seq)
将@code{SEQ}中语句序列增加到边@code{E}的待定列表中。直到调用@code{gsi_commit_edge_inserts}()之前，不会进行实际的插入操作。
@end deftypefn

@deftypefn {GIMPLE function} basic_block gsi_insert_on_edge_immediate (edge e, gimple stmt)
类似于@code{gsi_insert_on_edge}+@code{gsi_commit_edge_inserts}。如果需要创建一个新的块，则将其返回。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_commit_one_edge_insert (edge e, basic_block *new_bb)
提交在边@code{E}上进行的插入操作。如果创建了新的基本块，则将@code{NEW_BB}设置为该块，否则将其设置为@code{NULL}。
@end deftypefn

@deftypefn {GIMPLE function} void gsi_commit_edge_inserts (void)
该函数将提交所有要进行的边插入操作，并在需要的时候创建新的基本块。
@end deftypefn


@node 增加一个新的GIMPLE语句代码
@section 增加一个新的GIMPLE语句代码
@cindex Adding a new GIMPLE statement code

增加一个新的GIMPLE语句代码，第一步是修改文件@code{gimple.def}，其包含了所有的GIMPLE代码。然后，你必须增加一个相应的结构体，以及@code{union gimple_statement_d}中的一个实体，这些都在@code{gimple.h}中。这将要求你在@code{gsstruct.def}中增加一个相应的@code{GTY}标记，以及在@code{gss_for_code}中增加处理该标记的代码，这位于@code{gimple.c}中。

为了让垃圾搜集器知道你在@code{gimple.h}中创建的结构体的大小，你需要在@code{gimple_size}增加一个case来处理你的新的GIMPLE语句，位于@code{gimple.c}中。

你可能想创建一个函数来构建新的gimple语句，在@code{gimple.c}中。该函数应该被称作@code{gimple_build_<@code{NEW_TUPLE_NAME}>}，并返回类型为gimple的新的元组。

如果你的新语句需要对其成员或者操作数进行访问的代码，则在@code{gimple.h}中放入简单的inline访问代码，以及在@code{gimple.c}中任何不平凡的访问代码，并在@code{gimple.h}中有相应的函数原型。

@node 语句和操作数遍历
@section 语句和操作数遍历
@cindex Statement and operand traversals
有两个函数可以用于遍历语句和序列：分别为@code{walk_gimple_stmt}和@code{walk_gimple_seq}。还有第三个函数用于遍历语句中的操作数：@code{walk_gimple_op}。

@deftypefn {GIMPLE function} tree walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)
该函数用于在@code{GSI}中遍历当前语句，并可选的使用@code{WI}中存放的遍历状态。如果@code{WI}为@code{NULL}，则在遍历中不保存状态。

回调函数@code{CALLBACK_STMT}被调用。如果@code{CALLBACK_STMT}返回真，则意味着回调函数已经处理了语句的所有操作数，并且无需遍历它的操作数。

如果@code{CALLBACK_STMT}为@code{NULL}或者返回假，则@code{CALLBACK_OP}会在语句的每个操作数上被调用，通过@code{walk_gimple_op}。如果@code{walk_gimple_op}对任意操作数返回了非@code{NULL}，则剩下的操作数将不被扫描。

返回值为对@code{walk_gimple_op}最后调用所返回的值，或者如果没有指定@code{CALLBACK_OP}则返回@code{NULL_TREE}。

@end deftypefn


@deftypefn {GIMPLE function} tree walk_gimple_op (gimple stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)
使用该函数来遍历语句@code{STMT}的操作数。每个操作数通过@code{walk_tree}来遍历，并使用@code{WI}中可选的状态信息。

@code{CALLBACK_OP}在@code{STMT}的每个操作数上被调用，通过@code{walk_tree}。@code{walk_tree}的其它参数必须存放在@code{WI}中。对于每个操作数@code{OP}，@code{walk_tree}被调用为：

@smallexample
    walk_tree (&@code{OP}, @code{CALLBACK_OP}, @code{WI}, @code{WI}- @code{PSET})
@end smallexample

如果@code{CALLBACK_OP}对于一个操作数返回非@code{NULL}，则剩下的操作数不再被扫描。返回值为对@code{walk_tree}最后调用所返回的值，或者如果没有指定@code{CALLBACK_OP}则返回@code{NULL_TREE}。

@end deftypefn


@deftypefn {GIMPLE function} tree walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)
该函数遍历序列@code{SEQ}中的所有语句，在每个语句上调用@code{walk_gimple_stmt}。@code{WI}跟@code{walk_gimple_stmt}中的一样。如果@code{walk_gimple_stmt}返回非@code{NULL}，则停止遍历，并返回值。否则，所有语句都被遍历并返回@code{NULL_TREE}。

@end deftypefn
