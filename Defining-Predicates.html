<html lang="zh">
<head>
<title>Defining Predicates - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Predicates.html#Predicates" title="Predicates">
<link rel="prev" href="Machine_002dIndependent-Predicates.html#Machine_002dIndependent-Predicates" title="Machine-Independent Predicates">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Defining-Predicates"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Machine_002dIndependent-Predicates.html#Machine_002dIndependent-Predicates">Machine-Independent Predicates</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Predicates.html#Predicates">Predicates</a>
<hr>
</div>

<h4 class="subsection">16.7.2 定义机器特定的predicate</h4>

<p><a name="index-defining-predicates-3263"></a><a name="index-define_005fpredicate-3264"></a><a name="index-define_005fspecial_005fpredicate-3265"></a>
<!-- Many machines have requirements for their operands that cannot be -->
<!-- expressed precisely using the generic predicates.  You can define -->
<!-- additional predicates using @code{define_predicate} and -->
<!-- @code{define_special_predicate} expressions.  These expressions have -->
<!-- three operands: -->
许多机器对操作数的要求无法使用通用的predicate来精确表达。
你可以使用表达式<code>define_predicate</code>和<code>define_special_predicate</code>来定义 额外的predicate。这些表达式具有三个操作数：

<!-- @itemize @bullet -->
<!-- @item -->
<!-- The name of the predicate, as it will be referred to in -->
<!-- @code{match_operand} or @code{match_operator} expressions. -->
     <ul>
<li>predicate的名字，
其将在<code>match_operand</code>或<code>match_operator</code>表达式中被引用。

     <!-- @item -->
     <!-- An RTL expression which evaluates to true if the predicate allows the -->
     <!-- operand @var{op}, false if it does not.  This expression can only use -->
     <!-- the following RTL codes: -->
     <li>一个RTL表达式，如果predicate允许<var>op</var>操作数，则值为真，否则为假。
该表达式只能使用下列RTL代码：

     <!-- @table @code -->
     <!-- @item MATCH_OPERAND -->
     <!-- When written inside a predicate expression, a @code{MATCH_OPERAND} -->
     <!-- expression evaluates to true if the predicate it names would allow -->
     <!-- @var{op}.  The operand number and constraint are ignored.  Due to -->
     <!-- limitations in @command{genrecog}, you can only refer to generic -->
     <!-- predicates and predicates that have already been defined. -->
          <dl>
<dt><code>MATCH_OPERAND</code><dd>当用于predicate表达式中时，
表达式<code>MATCH_OPERAND</code>在predicate允许<var>op</var>时为真。
操作数编号和constraint被忽略。由于<samp><span class="command">genrecog</span></samp>中的限制，
你只能用于引用通用的predicate和已经被定义的predicate。

          <!-- @item MATCH_CODE -->
          <!-- This expression evaluates to true if @var{op} or a specified -->
          <!-- subexpression of @var{op} has one of a given list of RTX codes. -->
          <br><dt><code>MATCH_CODE</code><dd>该表达式为真，
如果<var>op</var>或一个指定的<var>op</var>的子表达式具有给定RTX代码列表中的一个RTX代码。

          <!-- The first operand of this expression is a string constant containing a -->
          <!-- comma-separated list of RTX code names (in lower case).  These are the -->
          <!-- codes for which the @code{MATCH_CODE} will be true. -->
          <p>该表达式的第一个操作数为一个字符串常量，
包含了逗号分割的RTX代码名字（小写形式）列表。这些是<code>MATCH_CODE</code>为真的代码。

          <!-- The second operand is a string constant which indicates what -->
          <!-- subexpression of @var{op} to examine.  If it is absent or the empty -->
          <!-- string, @var{op} itself is examined.  Otherwise, the string constant -->
          <!-- must be a sequence of digits and/or lowercase letters.  Each character -->
          <!-- indicates a subexpression to extract from the current expression; for -->
          <!-- the first character this is @var{op}, for the second and subsequent -->
          <!-- characters it is the result of the previous character.  A digit -->
          <!-- @var{n} extracts @samp{@w{XEXP (@var{e}, @var{n})}}; a letter @var{l} -->
          <!-- extracts @samp{@w{XVECEXP (@var{e}, 0, @var{n})}} where @var{n} is the -->
          <!-- alphabetic ordinal of @var{l} (0 for `a', 1 for 'b', and so on).  The -->
          <!-- @code{MATCH_CODE} then examines the RTX code of the subexpression -->
          <!-- extracted by the complete string.  It is not possible to extract -->
          <!-- components of an @code{rtvec} that is not at position 0 within its RTX -->
          <!-- object. -->
          <p>第二个操作数为一个字符串常量，其指示<var>op</var>的什么子表达式需要被检查。
如果没有或者为空字符串，则检查<var>op</var>本身。
否则，字符串常量必须为一个数字和/或小写字母的序列。
每个字符指示从当前表达式中抽取的子表达式；
第一个字符为<var>op</var>，第二个和后续字符，其为先前字符的结果。
数字<var>n</var>用于抽取&lsquo;<samp><span class="samp">XEXP&nbsp;(</span><var>e</var><span class="samp">,&nbsp;</span><var>n</var><span class="samp">)<!-- /@w --></span></samp>&rsquo;；
字母<var>l</var>抽取&lsquo;<samp><span class="samp">XVECEXP&nbsp;(</span><var>e</var><span class="samp">,&nbsp;0,&nbsp;</span><var>n</var><span class="samp">)<!-- /@w --></span></samp>&rsquo;，
其中<var>n</var>为<var>l</var>的字母顺序（0为`a'，1为'b'，等等）。
<code>MATCH_CODE</code>然后检查完整字符串所抽取的子表达式的RTX代码。

          <!-- @item MATCH_TEST -->
          <!-- This expression has one operand, a string constant containing a C -->
          <!-- expression.  The predicate's arguments, @var{op} and @var{mode}, are -->
          <!-- available with those names in the C expression.  The @code{MATCH_TEST} -->
          <!-- evaluates to true if the C expression evaluates to a nonzero value. -->
          <!-- @code{MATCH_TEST} expressions must not have side effects. -->
          <br><dt><code>MATCH_TEST</code><dd>该表达式具有一个操作数，一个包含了一个C表达式的字符串常量。
在C表达式中可以使用predicate的参数，<var>op</var>和<var>mode</var>。
当C表达式为非0值时，<code>MATCH_TEST</code>为真。
<code>MATCH_TEST</code>表达式必须不具有副作用。

          <!-- @item  AND -->
          <!-- @itemx IOR -->
          <!-- @itemx NOT -->
          <!-- @itemx IF_THEN_ELSE -->
          <!-- The basic @samp{MATCH_} expressions can be combined using these -->
          <!-- logical operators, which have the semantics of the C operators -->
          <!-- @samp{&&}, @samp{||}, @samp{!}, and @samp{@w{? :}} respectively.  As -->
          <!-- in Common Lisp, you may give an @code{AND} or @code{IOR} expression an -->
          <!-- arbitrary number of arguments; this has exactly the same effect as -->
          <!-- writing a chain of two-argument @code{AND} or @code{IOR} expressions. -->
          <!-- @end table -->
          <br><dt><code>AND</code><dt><code>IOR</code><dt><code>NOT</code><dt><code>IF_THEN_ELSE</code><dd>基本的&lsquo;<samp><span class="samp">MATCH_</span></samp>&rsquo;表达式可以使用这些逻辑操作符组合，
其分别具有C操作符&lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo;, &lsquo;<samp><span class="samp">||</span></samp>&rsquo;, &lsquo;<samp><span class="samp">!</span></samp>&rsquo;和&lsquo;<samp><span class="samp">?&nbsp;:<!-- /@w --></span></samp>&rsquo;的语义。
正如在Common Lisp中，可以给<code>AND</code>或<code>IOR</code>表达式任意数目的参数；
这跟写成两个参数的<code>AND</code>或<code>IOR</code>表达式链具有相同的效果。
</dl>

     <!-- @item -->
     <!-- An optional block of C code, which should execute -->
     <!-- @samp{@w{return true}} if the predicate is found to match and -->
     <!-- @samp{@w{return false}} if it does not.  It must not have any side -->
     <!-- effects.  The predicate arguments, @var{op} and @var{mode}, are -->
     <!-- available with those names. -->
     <li>一个可选的C代码块，其应该在发现predicate匹配时执行&lsquo;<samp><span class="samp">return&nbsp;true<!-- /@w --></span></samp>&rsquo;，
不匹配时执行&lsquo;<samp><span class="samp">return&nbsp;false<!-- /@w --></span></samp>&rsquo;。其一定不要具有副作用。
predicate参数，<var>op</var>和<var>mode</var>，是有效的。

     <!-- If a code block is present in a predicate definition, then the RTL -->
     <!-- expression must evaluate to true @emph{and} the code block must -->
     <!-- execute @samp{@w{return true}} for the predicate to allow the operand. -->
     <!-- The RTL expression is evaluated first; do not re-check anything in the -->
     <!-- code block that was checked in the RTL expression. -->
     <!-- @end itemize -->
     <p>如果代码块存在于predicate定义中，则对于predicate允许的操作数，
RTL表达式必须求值为true并且代码块必须执行&lsquo;<samp><span class="samp">return&nbsp;true<!-- /@w --></span></samp>&rsquo;。
RTL表达式被首先求值，不要重复检查代码块中的在RTL表达式中曾经被检查过的任何事情。
</ul>

<!-- The program @command{genrecog} scans @code{define_predicate} and -->
<!-- @code{define_special_predicate} expressions to determine which RTX -->
<!-- codes are possibly allowed.  You should always make this explicit in -->
<!-- the RTL predicate expression, using @code{MATCH_OPERAND} and -->
<!-- @code{MATCH_CODE}. -->
 <p>程序<samp><span class="command">genrecog</span></samp>扫描<code>define_predicate</code>和
<code>define_special_predicate</code>表达式来决定什么RTX代码可能被允许。
你应该使其在RTL predicate表达式中总是显式的，
使用<code>MATCH_OPERAND</code>和<code>MATCH_CODE</code>。

<!-- Here is an example of a simple predicate definition, from the IA64 -->
<!-- machine description: -->
 <p>这里有一个简单的定义predicate的例子，来自IA64机器描述：

<pre class="smallexample">     ;; <span class="roman">True if </span><var>op</var><span class="roman"> is a </span><code>SYMBOL_REF</code><span class="roman"> which refers to the sdata section.</span>
     (define_predicate "small_addr_symbolic_operand"
       (and (match_code "symbol_ref")
            (match_test "SYMBOL_REF_SMALL_ADDR_P (op)")))
</pre>
 <p class="noindent"><!-- And here is another, showing the use of the C block. -->
另一个例子，展示了C块的使用。

<pre class="smallexample">     ;; <span class="roman">True if </span><var>op</var><span class="roman"> is a register operand that is (or could be) a GR reg.</span>
     (define_predicate "gr_register_operand"
       (match_operand 0 "register_operand")
     {
       unsigned int regno;
       if (GET_CODE (op) == SUBREG)
         op = SUBREG_REG (op);
     
       regno = REGNO (op);
       return (regno &gt;= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));
     })
</pre>
 <!-- Predicates written with @code{define_predicate} automatically include -->
<!-- a test that @var{mode} is @code{VOIDmode}, or @var{op} has the same -->
<!-- mode as @var{mode}, or @var{op} is a @code{CONST_INT} or -->
<!-- @code{CONST_DOUBLE}.  They do @emph{not} check specifically for -->
<!-- integer @code{CONST_DOUBLE}, nor do they test that the value of either -->
<!-- kind of constant fits in the requested mode.  This is because -->
<!-- target-specific predicates that take constants usually have to do more -->
<!-- stringent value checks anyway.  If you need the exact same treatment -->
<!-- of @code{CONST_INT} or @code{CONST_DOUBLE} that the generic predicates -->
<!-- provide, use a @code{MATCH_OPERAND} subexpression to call -->
<!-- @code{const_int_operand}, @code{const_double_operand}, or -->
<!-- @code{immediate_operand}. -->
 <p>使用<code>define_predicate</code>编写的predicate会自动包含一个测试，
用来测试<var>mode</var>为<code>VOIDmode</code>，
或者<var>op</var>具有与<var>mode</var>相同的机器模式，
或者<var>op</var>为<code>CONST_INT</code>或<code>CONST_DOUBLE</code>。
它们<em>不</em>专门检查整数<code>CONST_DOUBLE</code>，
也不测试每种常量的值是否适合所需求的机器模式。
这是因为接受常量的目标机特定的predicate，通常必须做更严厉的值检查。
如果你需要确切的通用predicate提供的对<code>CONST_INT</code>或
<code>CONST_DOUBLE</code>的对待，
则可以使用<code>MATCH_OPERAND</code>子表达式来调用<code>const_int_operand</code>,
<code>const_double_operand</code>或者<code>immediate_operand</code>。

<!-- Predicates written with @code{define_special_predicate} do not get any -->
<!-- automatic mode checks, and are treated as having special mode handling -->
<!-- by @command{genrecog}. -->
 <p>使用<code>define_special_predicate</code>编写的predicate不做任何自动的机器模式检查，
并且<samp><span class="command">genrecog</span></samp>将其作为具有特定的机器模式处理来对待。

<!-- The program @command{genpreds} is responsible for generating code to -->
<!-- test predicates.  It also writes a header file containing function -->
<!-- declarations for all machine-specific predicates.  It is not necessary -->
<!-- to declare these predicates in @file{@var{cpu}-protos.h}. -->
 <p>程序<samp><span class="command">genpreds</span></samp>负责生成代码来测试predicate。
其还编写了一个包含所有机器特定predicate的函数声明的头文件。
所以不需要在cpu-protos.h中声明这些predicate。

<!-- @c Most of this node appears by itself (in a different place) even -->
<!-- @c when the INTERNALS flag is clear.  Passages that require the internals -->
<!-- @c manual's context are conditionalized to appear only in the internals manual. -->
<!-- @node Constraints -->
<!-- @section Operand Constraints -->
<!-- @cindex operand constraints -->
<!-- @cindex constraints -->
 </body></html>

