<html lang="zh">
<head>
<title>Adding new DECL node types - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Internal-structure.html#Internal-structure" title="Internal structure">
<link rel="prev" href="Current-structure-hierarchy.html#Current-structure-hierarchy" title="Current structure hierarchy">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Adding-new-DECL-node-types"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Current-structure-hierarchy.html#Current-structure-hierarchy">Current structure hierarchy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Internal-structure.html#Internal-structure">Internal structure</a>
<hr>
</div>

<h5 class="subsubsection">11.4.2.2 添加新的DECL节点类型</h5>

<!-- Adding a new @code{DECL} tree consists of the following steps -->
<p>增加一个新的<code>DECL</code>树包含下列步骤

     <dl>
<!-- @item Add a new tree code for the @code{DECL} node -->
<!-- For language specific @code{DECL} nodes, there is a @file{.def} file -->
<!-- in each frontend directory where the tree code should be added. -->
<!-- For @code{DECL} nodes that are part of the middle-end, the code should -->
<!-- be added to @file{tree.def}. -->
<dt>为<code>DECL</code>节点增加一个新的树代码<dd>对于语言特定的<code>DECL</code>节点，在每个前端目录下有一个<samp><span class="file">.def</span></samp>文件，用来添加树代码。对于属于中端一部分的<code>DECL</code>节点，代码应该添加到<samp><span class="file">tree.def</span></samp>中。

     <!-- @item Create a new structure type for the @code{DECL} node -->
     <!-- These structures should inherit from one of the existing structures in -->
     <!-- the language hierarchy by using that structure as the first member. -->
     <br><dt>为<code>DECL</code>节点创建一个新的结构体类型<dd>这些结构体应该继承于现有的层次结构体，方法是使用该结构体作为第一个成员。

     <pre class="smallexample">          struct tree_foo_decl
          {
             struct tree_decl_with_vis common;
          }
</pre>
     <!-- Would create a structure name @code{tree_foo_decl} that inherits from -->
     <!-- @code{struct tree_decl_with_vis}. -->
     <p>将会创建一个名为<code>tree_foo_decl</code>的结构体，继承于<code>struct tree_decl_with_vis</code>。

     <!-- For language specific @code{DECL} nodes, this new structure type -->
     <!-- should go in the appropriate @file{.h} file. -->
     <!-- For @code{DECL} nodes that are part of the middle-end, the structure -->
     <!-- type should go in @file{tree.h}. -->
     <p>对于语言特定的<code>DECL</code>节点，这个新的结构体类型应该放在合适的<samp><span class="file">.h</span></samp>文件中。对于属于中端一部分的<code>DECL</code>节点，结构体类型应该在<samp><span class="file">tree.h</span></samp>中。

     <!-- @item Add a member to the tree structure enumerator for the node -->
     <!-- For garbage collection and dynamic checking purposes, each @code{DECL} -->
     <!-- node structure type is required to have a unique enumerator value -->
     <!-- specified with it. -->
     <!-- For language specific @code{DECL} nodes, this new enumerator value -->
     <!-- should go in the appropriate @file{.def} file. -->
     <!-- For @code{DECL} nodes that are part of the middle-end, the enumerator -->
     <!-- values are specified in @file{treestruct.def}. -->
     <br><dt>向树结构枚举中增加一个节点成员<dd>出于垃圾搜集和动态检查的目的，每个<code>DECL</code>节点结构体类型需要具有一个唯一的枚举值用来指定它。对于语言特定的<code>DECL</code>节点，该新的枚举值应该在合适的.def文中。对于属于中端的<code>DECL</code>节点，枚举值在<samp><span class="file">treestruct.def</span></samp>中指定。

     <!-- @item Update @code{union tree_node} -->
     <!-- In order to make your new structure type usable, it must be added to -->
     <!-- @code{union tree_node}. -->
     <!-- For language specific @code{DECL} nodes, a new entry should be added -->
     <!-- to the appropriate @file{.h} file of the form -->
     <br><dt>更新<code>union tree_node</code><dd>为了使得新的结构体类型可用，其必须被添加到<code>union tree_node</code>中。对于语言特定的<code>DECL</code>节点，一个新的项应该被添加到合适的<samp><span class="file">.h</span></samp>文件中，形式如下
     <pre class="smallexample">            struct tree_foo_decl GTY ((tag ("TS_VAR_DECL"))) foo_decl;
</pre>
     <!-- For @code{DECL} nodes that are part of the middle-end, the additional -->
     <!-- member goes directly into @code{union tree_node} in @file{tree.h}. -->
     <p>对于属于中端的<code>DECL</code>节点，额外的成员直接放在<samp><span class="file">tree.h</span></samp>里的<code>union tree_node</code>中。
For <code>DECL</code> nodes that are part of the middle-end, the additional

     <!-- @item Update dynamic checking info -->
     <!-- In order to be able to check whether accessing a named portion of -->
     <!-- @code{union tree_node} is legal, and whether a certain @code{DECL} node -->
     <!-- contains one of the enumerated @code{DECL} node structures in the -->
     <!-- hierarchy, a simple lookup table is used. -->
     <!-- This lookup table needs to be kept up to date with the tree structure -->
     <!-- hierarchy, or else checking and containment macros will fail -->
     <!-- inappropriately. -->
     <br><dt>更新动态检查信息<dd>为了能够检查访问<code>union tree_node</code>的一个命名部分是否合法，以及特定的<code>DECL</code>节点是否包含了枚举的<code>DECL</code>节点结构体，我们使用了一个简单的查找表。该查找表需要随着树结构层次一起更新，否则用于检查和包含的宏将会失败。

     <!-- For language specific @code{DECL} nodes, their is an @code{init_ts} -->
     <!-- function in an appropriate @file{.c} file, which initializes the lookup -->
     <!-- table. -->
     <!-- Code setting up the table for new @code{DECL} nodes should be added -->
     <!-- there. -->
     <!-- For each @code{DECL} tree code and enumerator value representing a -->
     <!-- member of the inheritance  hierarchy, the table should contain 1 if -->
     <!-- that tree code inherits (directly or indirectly) from that member. -->
     <!-- Thus, a @code{FOO_DECL} node derived from @code{struct decl_with_rtl}, -->
     <!-- and enumerator value @code{TS_FOO_DECL}, would be set up as follows -->
     <p>对于语言特定的<code>DECL</code>节点，它们是在合适的<samp><span class="file">.c</span></samp>文件中的<code>init_ts</code>函数，用于初始化查找表。为新的<code>DECL</code>节点建立表格的代码应该添加到这里。对于每个表示继承层次的成员的<code>DECL</code>树代码和枚举值，如果树代码（直接或间接）继承于那个成员，则表应该包含1。因此，一个源于<code>struct decl_with_rtl</code>的，枚举值为<code>TS_FOO_DECL</code>的<code>FOO_DECL</code>节点，会使用下列方式来建立。
     <pre class="smallexample">          tree_contains_struct[FOO_DECL][TS_FOO_DECL] = 1;
          tree_contains_struct[FOO_DECL][TS_DECL_WRTL] = 1;
          tree_contains_struct[FOO_DECL][TS_DECL_COMMON] = 1;
          tree_contains_struct[FOO_DECL][TS_DECL_MINIMAL] = 1;
</pre>
     <!-- For @code{DECL} nodes that are part of the middle-end, the setup code -->
     <!-- goes into @file{tree.c}. -->
     <p>对于属于中端的<code>DECL</code>节点，建表代码在<samp><span class="file">tree.c</span></samp>中。

     <!-- @item Add macros to access any new fields and flags -->
     <br><dt>增加访问任何新的域和标识的宏<dd>
<!-- Each added field or flag should have a macro that is used to access -->
<!-- it, that performs appropriate checking to ensure only the right type of -->
<!-- @code{DECL} nodes access the field. -->
每个增加的域或标识，都应有一个宏用来访问它，并且执行适当的检查以保证访问的是正确类型的<code>DECL</code>。

     <!-- These macros generally take the following form -->
     <p>这些宏通常采用下面的形式
     <pre class="smallexample">          #define FOO_DECL_FIELDNAME(NODE) FOO_DECL_CHECK(NODE)-&gt;foo_decl.fieldname
</pre>
     <!-- However, if the structure is simply a base class for further -->
     <!-- structures, something like the following should be used -->
     <p>但是，如果结构体只是更多结构体的一个基类，有时会使用下面的形式
     <pre class="smallexample">          #define BASE_STRUCT_CHECK(T) CONTAINS_STRUCT_CHECK(T, TS_BASE_STRUCT)
          #define BASE_STRUCT_FIELDNAME(NODE) \
             (BASE_STRUCT_CHECK(NODE)-&gt;base_struct.fieldname
</pre>
     </dl>

<!--  -->
<!-- Attributes -->
<!--  -->
<!-- @node Attributes -->
<!-- @section Attributes in trees -->
 </body></html>

