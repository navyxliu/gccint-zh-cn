<html lang="zh">
<head>
<title>RTL Template - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Machine-Desc.html#Machine-Desc" title="Machine Desc">
<link rel="prev" href="Example.html#Example" title="Example">
<link rel="next" href="Output-Template.html#Output-Template" title="Output Template">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="RTL-Template"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Output-Template.html#Output-Template">Output Template</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Example.html#Example">Example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Machine-Desc.html#Machine-Desc">Machine Desc</a>
<hr>
</div>

<h3 class="section">16.4 RTL模板</h3>

<p><a name="index-RTL-insn-template-3212"></a><a name="index-generating-insns-3213"></a><a name="index-insns_002c-generating-3214"></a><a name="index-recognizing-insns-3215"></a><a name="index-insns_002c-recognizing-3216"></a>
<!-- The RTL template is used to define which insns match the particular pattern -->
<!-- and how to find their operands.  For named patterns, the RTL template also -->
<!-- says how to construct an insn from specified operands. -->
RTL模板用来定义哪些insn匹配特定的模式，以及如何找到它们的操作数。对于命名的模 式，RTL模板还说明了如何根据特定的操作数来构建一个insn。

<!-- Construction involves substituting specified operands into a copy of the -->
<!-- template.  Matching involves determining the values that serve as the -->
<!-- operands in the insn being matched.  Both of these activities are -->
<!-- controlled by special expression types that direct matching and -->
<!-- substitution of the operands. -->
 <p>构建insn涉及到替换指定操作数到模板。匹配insn涉及到测定被匹配insn的操作数值。这 些匹配和替换操作数的行为都是由专门的表达式类型来控制。

<!-- @table @code -->
<!-- @findex match_operand -->
<!-- @item (match_operand:@var{m} @var{n} @var{predicate} @var{constraint}) -->
<!-- This expression is a placeholder for operand number @var{n} of -->
<!-- the insn.  When constructing an insn, operand number @var{n} -->
<!-- will be substituted at this point.  When matching an insn, whatever -->
<!-- appears at this position in the insn will be taken as operand -->
<!-- number @var{n}; but it must satisfy @var{predicate} or this instruction -->
<!-- pattern will not match at all. -->
     
<a name="index-match_005foperand-3217"></a>
<dl><dt><code>(match_operand:</code><var>m</var> <var>n</var> <var>predicate</var> <var>constraint</var><code>)</code><dd>该表达式用来代表insn中的第 <var>n</var> 个操作数。当构建insn时，操作数编号 <var>n</var> 将
在此处被替换。当匹配insn时，凡是在insn中该位置出现的将被当作操作数编号 <var>n</var>；
但是其必须满足 <var>predicate</var>，否则该指令模式将根本不匹配

     <!-- Operand numbers must be chosen consecutively counting from zero in -->
     <!-- each instruction pattern.  There may be only one @code{match_operand} -->
     <!-- expression in the pattern for each operand number.  Usually operands -->
     <!-- are numbered in the order of appearance in @code{match_operand} -->
     <!-- expressions.  In the case of a @code{define_expand}, any operand numbers -->
     <!-- used only in @code{match_dup} expressions have higher values than all -->
     <!-- other operand numbers. -->
     <p>每个指令模式中的操作数编号必须从0开始连续的选择。在指令模式中，可以对每个操作数
编号只是用一个 <code>match_operand</code> 表达式。 通常操作数按照在
<code>match_operand</code> 表达式中出现的顺序被编号。对于 <code>define_expand</code>，任何
使用的操作数编号，只有在 <code>match_dup</code> 表达式中才会具有比其它操作数编号更高
的值。

     <!-- @var{predicate} is a string that is the name of a function that -->
     <!-- accepts two arguments, an expression and a machine mode. -->
     <!-- @xref{Predicates}.  During matching, the function will be called with -->
     <!-- the putative operand as the expression and @var{m} as the mode -->
     <!-- argument (if @var{m} is not specified, @code{VOIDmode} will be used, -->
     <!-- which normally causes @var{predicate} to accept any mode).  If it -->
     <!-- returns zero, this instruction pattern fails to match. -->
     <!-- @var{predicate} may be an empty string; then it means no test is to be -->
     <!-- done on the operand, so anything which occurs in this position is -->
     <!-- valid. -->
     <p><var>predicate</var> 为一个字符串，为一个函数的名字，其接受两个参数，一个表达式和一个 机器模式。参见<a href="Predicates.html#Predicates">Predicates</a>。在匹配过程中，函数将会被调用，使用假定的操作数作为 表达式并且 <var>m</var> 作为机器模式参数（如果 <var>m</var> 没有被指定，则使用 <code>VOIDmode</code>，这通常会使得 <var>predicate</var> 可以接受任何机器模式）。如果其返 回0，则该指令模式匹配失败。<var>predicate</var> 可以为一个空字符串；这意味着不对操作 数作测试，这样出现在该位置的任何都是有效的。

     <!-- Most of the time, @var{predicate} will reject modes other than @var{m}-but -->
     <!-- not always.  For example, the predicate @code{address_operand} uses -->
     <!-- @var{m} as the mode of memory ref that the address should be valid for. -->
     <!-- Many predicates accept @code{const_int} nodes even though their mode is -->
     <!-- @code{VOIDmode}. -->
     <p>大多时候，<var>predicate</var> 将会拒绝 <var>m</var> 之外的机器模式——但并不总是这样。例 如，predicate <code>address_operand</code> 使用 <var>m</var> 作为内存引用的机器模式。许多predicate 接受 <code>const_int</code> 节点，即使它们的机器模式为 <code>VOIDmode</code>。

     <!-- @var{constraint} controls reloading and the choice of the best register -->
     <!-- class to use for a value, as explained later (@pxref{Constraints}). -->
     <!-- If the constraint would be an empty string, it can be omitted. -->
     <p><var>constraint</var> 控制重载以及针对一个值选择最好的寄存器类别来使用，将在后面解释 （参见<a href="Constraints.html#Constraints">Constraints</a>）。如果constraint为空字符串，则可以忽略掉。

     <!-- People are often unclear on the difference between the constraint and the -->
     <!-- predicate.  The predicate helps decide whether a given insn matches the -->
     <!-- pattern.  The constraint plays no role in this decision; instead, it -->
     <!-- controls various decisions in the case of an insn which does match. -->
     <p>人们经常弄不清楚constraint和predicate的区别。predicate帮助决定一个给定的insn是否匹配指令模式。constraint在该决定中不发挥作用；替代的，其控制已经匹配的insn的各种决定。

     <!-- @findex match_scratch -->
     <!-- @item (match_scratch:@var{m} @var{n} @var{constraint}) -->
     <!-- This expression is also a placeholder for operand number @var{n} -->
     <!-- and indicates that operand must be a @code{scratch} or @code{reg} -->
     <!-- expression. -->
     <p><a name="index-match_005fscratch-3218"></a><br><dt><code>(match_scratch:</code><var>m</var> <var>n</var> <var>constraint</var><code>)</code><dd>该表达式也是操作数编号 <var>n</var> 的占位符，并且指示操作数必须为一个 <code>scratch</code>
或者 <code>reg</code> 表达式。

     <!-- When matching patterns, this is equivalent to -->
     <p>当在匹配指令模式时，其相当于

     <pre class="smallexample">          (match_operand:<var>m</var> <var>n</var> "scratch_operand" <var>pred</var>)
</pre>
     <!-- but, when generating RTL, it produces a (@code{scratch}:@var{m}) -->
     <!-- expression. -->
     <p>但是，当在生成RTL时，其产生一个(<code>scratch</code>:<var>m</var>)表达式。

     <!-- If the last few expressions in a @code{parallel} are @code{clobber} -->
     <!-- expressions whose operands are either a hard register or -->
     <!-- @code{match_scratch}, the combiner can add or delete them when -->
     <!-- necessary.  @xref{Side Effects}. -->
     <p>如果在一个 <code>parallel</code> 中的最后几个表达式为 <code>clobber</code> 表达式，其操作数
为一个硬寄存器或者 <code>match_scratch</code>，则组合器可以在需要的时候增加或删除它
们。参见<a href="Side-Effects.html#Side-Effects">Side Effects</a>。

     <!-- @findex match_dup -->
     <!-- @item (match_dup @var{n}) -->
     <!-- This expression is also a placeholder for operand number @var{n}. -->
     <!-- It is used when the operand needs to appear more than once in the -->
     <!-- insn. -->
     <p><a name="index-match_005fdup-3219"></a><br><dt><code>(match_dup </code><var>n</var><code>)</code><dd>该表达式也为操作数编号 <var>n</var> 的占位符。其用于当操作数需要在insn中出现多次的
情况。

     <!-- In construction, @code{match_dup} acts just like @code{match_operand}: -->
     <!-- the operand is substituted into the insn being constructed.  But in -->
     <!-- matching, @code{match_dup} behaves differently.  It assumes that operand -->
     <!-- number @var{n} has already been determined by a @code{match_operand} -->
     <!-- appearing earlier in the recognition template, and it matches only an -->
     <!-- identical-looking expression. -->
     <p>在构建过程中，<code>match_dup</code> 的作用就跟 <code>match_operand</code> 一样。操作数被
替换到正在被构建的insn中。但是在匹配时，<code>match_dup</code> 的行为就有所不同了。
其假设操作数编号 <var>n</var> 已经由在识别模板中之前出现的 <code>match_operand</code> 确
定了，其只匹配相同的表达式。

     <!-- Note that @code{match_dup} should not be used to tell the compiler that -->
     <!-- a particular register is being used for two operands (example: -->
     <!-- @code{add} that adds one register to another; the second register is -->
     <!-- both an input operand and the output operand).  Use a matching -->
     <!-- constraint (@pxref{Simple Constraints}) for those.  @code{match_dup} is for the cases where one -->
     <!-- operand is used in two places in the template, such as an instruction -->
     <!-- that computes both a quotient and a remainder, where the opcode takes -->
     <!-- two input operands but the RTL template has to refer to each of those -->
     <!-- twice; once for the quotient pattern and once for the remainder pattern. -->
     <p>注意 <code>match_dup</code> 不要用来告诉编译器特定寄存器被用于两个操作数（例如：
<code>add</code> 将一个寄存器加到另一个之上；第二个寄存器即为输入操作数，同样也为输
出操作数）。可以为此使用匹配constraint（参见<a href="Simple-Constraints.html#Simple-Constraints">Simple Constraints</a>）。<code>match_dup</code>
是用于一个操作数在模板中的两个地方被使用的情况，例如一条指令同时计算商和余数，
其中操作码接受两个输入操作数，但是RTL模板不得不引用它们两次；一次用于求商指令
模式，一次用于求余数指令模式。

     <!-- @findex match_operator -->
     <!-- @item (match_operator:@var{m} @var{n} @var{predicate} [@var{operands}@dots{}]) -->
     <!-- This pattern is a kind of placeholder for a variable RTL expression -->
     <!-- code. -->
     <p><a name="index-match_005foperator-3220"></a><br><dt><code>(match_operator:</code><var>m</var> <var>n</var> <var>predicate</var><code> [</code><var>operands</var><code>...])</code><dd>该指令模式为一个可变RTL表达式代码的一种占位符。

     <!-- When constructing an insn, it stands for an RTL expression whose -->
     <!-- expression code is taken from that of operand @var{n}, and whose -->
     <!-- operands are constructed from the patterns @var{operands}. -->
     <p>当构造一个insn时，其代表RTL表达式，其表达式代码取自操作数 <var>n</var>，并且其操作
数从指令模式 <var>operands</var> 中构造。

     <!-- When matching an expression, it matches an expression if the function -->
     <!-- @var{predicate} returns nonzero on that expression @emph{and} the -->
     <!-- patterns @var{operands} match the operands of the expression. -->
     <p>当匹配一个表达式时，其匹配一个表达式，如果函数 <var>predicate</var> 对于该表达式返
回非零，<em>并且</em> 指令模式 <var>operands</var> 匹配表达式的操作数。

     <!-- Suppose that the function @code{commutative_operator} is defined as -->
     <!-- follows, to match any expression whose operator is one of the -->
     <!-- commutative arithmetic operators of RTL and whose mode is @var{mode}: -->
     <p>假设函数 <code>commutative_operator</code> 被如下定义，来匹配任何表达式，其操作符为
RTL中可交换的算术操作符，并且其机器模式为 <var>mode</var>：

     <pre class="smallexample">          int
          commutative_integer_operator (x, mode)
               rtx x;
               enum machine_mode mode;
          {
            enum rtx_code code = GET_CODE (x);
            if (GET_MODE (x) != mode)
              return 0;
            return (GET_RTX_CLASS (code) == RTX_COMM_ARITH
                    || code == EQ || code == NE);
          }
</pre>
     <!-- Then the following pattern will match any RTL expression consisting -->
     <!-- of a commutative operator applied to two general operands: -->
     <p>那么下列指令模式将匹配任何RTL表达式，其由一个可交换操作符和两个通用操作数组成：

     <pre class="smallexample">          (match_operator:SI 3 "commutative_operator"
            [(match_operand:SI 1 "general_operand" "g")
             (match_operand:SI 2 "general_operand" "g")])
</pre>
     <!-- Here the vector @code{[@var{operands}@dots{}]} contains two patterns -->
     <!-- because the expressions to be matched all contain two operands. -->
     <p>这里的向量 <code>[</code><var>operands</var><code>...]</code> 包含了两个指令模式，因为要匹配的表达
式都是包含两个操作数。

     <!-- When this pattern does match, the two operands of the commutative -->
     <!-- operator are recorded as operands 1 and 2 of the insn.  (This is done -->
     <!-- by the two instances of @code{match_operand}.)  Operand 3 of the insn -->
     <!-- will be the entire commutative expression: use @code{GET_CODE -->
     <!-- (operands[3])} to see which commutative operator was used. -->
     <p>当该指令模式确实匹配时，可交换操作符的两个操作数被记录为insn的操作数1和2。（这
由 <code>match_operand</code> 的两个实例完成）。insn的操作数3将为整个可交换表达式：使
用 <code>GET_CODE (operands[3])</code> 来查看使用了哪个可交换操作符。

     <!-- The machine mode @var{m} of @code{match_operator} works like that of -->
     <!-- @code{match_operand}: it is passed as the second argument to the -->
     <!-- predicate function, and that function is solely responsible for -->
     <!-- deciding whether the expression to be matched ``has'' that mode. -->
     <p><code>match_operator</code> 的机器模式 <var>m</var> 的作用与 <code>match_operand</code> 的类似：
其被作为第二个参数传递给predicate函数，并且函数专门负责决定被匹配的表达式是否具有那
个机器模式。

     <!-- When constructing an insn, argument 3 of the gen-function will specify -->
     <!-- the operation (i.e.@: the expression code) for the expression to be -->
     <!-- made.  It should be an RTL expression, whose expression code is copied -->
     <!-- into a new expression whose operands are arguments 1 and 2 of the -->
     <!-- gen-function.  The subexpressions of argument 3 are not used; -->
     <!-- only its expression code matters. -->
     <p>当构造insn时，gen-function 的参数3将会指定要构造的表达式的操作（即，表达式代
码）。其应该为一个RTL表达式，其表达式代码被复制到一个新的表达式中，新表达式的
操作数为 gen-function的参数1和2。参数3的子表达式不被使用；只与它的表达式代码
有关。

     <!-- When @code{match_operator} is used in a pattern for matching an insn, -->
     <!-- it usually best if the operand number of the @code{match_operator} -->
     <!-- is higher than that of the actual operands of the insn.  This improves -->
     <!-- register allocation because the register allocator often looks at -->
     <!-- operands 1 and 2 of insns to see if it can do register tying. -->
     <p>当 <code>match_operator</code> 被用于指令模式中来匹配insn时，通常最好让
<code>match_operator</code> 的操作数编号高于insn的实际操作数。这将提高寄存器分配，
因为寄存器分配者通常查看insn的操作数1和2，来看是否它可以做寄存器绑定
（register tying）。

     <!-- There is no way to specify constraints in @code{match_operator}.  The -->
     <!-- operand of the insn which corresponds to the @code{match_operator} -->
     <!-- never has any constraints because it is never reloaded as a whole. -->
     <!-- However, if parts of its @var{operands} are matched by -->
     <!-- @code{match_operand} patterns, those parts may have constraints of -->
     <!-- their own. -->
     <p>无法指定在 <code>match_operator</code> 中的constraint。对应于 <code>match_operator</code> 的
insn的操作数，不具有任何constraint，因为它从来不作为一个整体被重载。但是，如果它
的 <var>operands</var> 的一部分被 <code>match_operand</code> 指令模式匹配，那些部分可
以具有它们自己的constraint。

     <!-- @findex match_op_dup -->
     <!-- @item (match_op_dup:@var{m} @var{n}[@var{operands}@dots{}]) -->
     <!-- Like @code{match_dup}, except that it applies to operators instead of -->
     <!-- operands.  When constructing an insn, operand number @var{n} will be -->
     <!-- substituted at this point.  But in matching, @code{match_op_dup} behaves -->
     <!-- differently.  It assumes that operand number @var{n} has already been -->
     <!-- determined by a @code{match_operator} appearing earlier in the -->
     <!-- recognition template, and it matches only an identical-looking -->
     <!-- expression. -->
     <p><a name="index-match_005fop_005fdup-3221"></a><br><dt><code>(match_op_dup:</code><var>m</var> <var>n</var><code>[</code><var>operands</var><code>...])</code><dd>类似 <code>match_dup</code>，除了其应用于操作符而不是操作数。当构造insn时，操作数
编号 <var>n</var> 将在这一点被替代。但是在匹配时，<code>match_op_dup</code> 的行为有所
不同。其假设操作数编号 <var>n</var> 已经被在识别模板中先前出现的
<code>match_operator</code> 所确定，并且其只匹配identical-looking的表达式。

     <!-- @findex match_parallel -->
     <!-- @item (match_parallel @var{n} @var{predicate} [@var{subpat}@dots{}]) -->
     <!-- This pattern is a placeholder for an insn that consists of a -->
     <!-- @code{parallel} expression with a variable number of elements.  This -->
     <!-- expression should only appear at the top level of an insn pattern. -->
     <p><a name="index-match_005fparallel-3222"></a><br><dt><code>(match_parallel </code><var>n</var> <var>predicate</var><code> [</code><var>subpat</var><code>...])</code><dd>该指令模式为一个insn的占位符，该insn由一个具有可变数目元素的 <code>parallel</code>
表达式组成。该表达式应该只在insn指令模式的顶层出现。

     <!-- When constructing an insn, operand number @var{n} will be substituted at -->
     <!-- this point.  When matching an insn, it matches if the body of the insn -->
     <!-- is a @code{parallel} expression with at least as many elements as the -->
     <!-- vector of @var{subpat} expressions in the @code{match_parallel}, if each -->
     <!-- @var{subpat} matches the corresponding element of the @code{parallel}, -->
     <!-- @emph{and} the function @var{predicate} returns nonzero on the -->
     <!-- @code{parallel} that is the body of the insn.  It is the responsibility -->
     <!-- of the predicate to validate elements of the @code{parallel} beyond -->
     <!-- those listed in the @code{match_parallel}. -->
     <p>当构造insn时，操作数编号 <var>n</var> 将在该处被替换。当匹配一个insn时，其当insn
的主体为一个 <code>parallel</code> 表达式，其具有至少跟向量 <var>subpat</var> 表达式同
样多数目元素，并且函数 <var>predicate</var> 返回非零时才匹配。predicate负责判定在
<code>match_parallel</code> 中的 <code>parallel</code> 的元素是否有效。

     <!-- A typical use of @code{match_parallel} is to match load and store -->
     <!-- multiple expressions, which can contain a variable number of elements -->
     <!-- in a @code{parallel}.  For example, -->
     <p><code>match_parallel</code> 的一个典型用法是，匹配加载和存储多个表达式，其可以在
<code>parallel</code> 中包含一个可变数目的元素。例如，

     <pre class="smallexample">          (define_insn ""
            [(match_parallel 0 "load_multiple_operation"
               [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                     (match_operand:SI 2 "memory_operand" "m"))
                (use (reg:SI 179))
                (clobber (reg:SI 179))])]
            ""
            "loadm 0,0,%1,%2")
</pre>
     <!-- This example comes from @file{a29k.md}.  The function -->
     <!-- @code{load_multiple_operation} is defined in @file{a29k.c} and checks -->
     <!-- that subsequent elements in the @code{parallel} are the same as the -->
     <!-- @code{set} in the pattern, except that they are referencing subsequent -->
     <!-- registers and memory locations. -->
     <p>这个例子来自 <samp><span class="file">a29k.md</span></samp>。函数 <code>load_multiple_operation</code> 在
<samp><span class="file">a29k.c</span></samp> 中定义，其检查在 <code>parallel</code> 中的序列元素，是否与在
指令模式中的 <code>set</code> 相同，除非它们在引用后续的寄存器和内存位置。

     <!-- An insn that matches this pattern might look like: -->
     <p>匹配该指令模式的insn可能看起来像：

     <pre class="smallexample">          (parallel
           [(set (reg:SI 20) (mem:SI (reg:SI 100)))
            (use (reg:SI 179))
            (clobber (reg:SI 179))
            (set (reg:SI 21)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 4))))
            (set (reg:SI 22)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 8))))])
</pre>
     <!-- @findex match_par_dup -->
     <!-- @item (match_par_dup @var{n} [@var{subpat}@dots{}]) -->
     <!-- Like @code{match_op_dup}, but for @code{match_parallel} instead of -->
     <!-- @code{match_operator}. -->
     <p><a name="index-match_005fpar_005fdup-3223"></a><br><dt><code>(match_par_dup </code><var>n</var><code> [</code><var>subpat</var><code>...])</code><dd>与 <code>match_op_dup</code> 类似，但是针对于 <code>match_parallel</code>，而不是
<code>match_operator</code>。
</dl>

<!-- @node Output Template -->
<!-- @section Output Templates and Operand Substitution -->
<!-- @cindex output templates -->
<!-- @cindex operand substitution -->
 </body></html>

