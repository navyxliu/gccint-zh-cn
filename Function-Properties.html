<html lang="zh">
<head>
<title>Function Properties - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Functions.html#Functions" title="Functions">
<link rel="prev" href="Function-Basics.html#Function-Basics" title="Function Basics">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Function-Properties"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Function-Basics.html#Function-Basics">Function Basics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Functions.html#Functions">Functions</a>
<hr>
</div>

<h4 class="subsection">11.8.2 函数属性</h4>

<p><a name="index-function-properties-2561"></a><a name="index-statements-2562"></a>
<!-- To determine the scope of a function, you can use the -->
<!-- @code{DECL_CONTEXT} macro.  This macro will return the class -->
<!-- (either a @code{RECORD_TYPE} or a @code{UNION_TYPE}) or namespace (a -->
<!-- @code{NAMESPACE_DECL}) of which the function is a member.  For a virtual -->
<!-- function, this macro returns the class in which the function was -->
<!-- actually defined, not the base class in which the virtual declaration -->
<!-- occurred. -->
要确定函数的作用域，可以使用<code>DECL_CONTEXT</code>宏。该宏将返回函数作为其成员的类（或者<code>RECORD_TYPE</code>或者<code>UNION_TYPE</code>）或命名空间（<code>NAMESPACE_DECL</code>）。对于虚函数，该宏返回函数被实际定义的类，而不是其声明所在的基类。

<!-- In C, the @code{DECL_CONTEXT} for a function maybe another function. -->
<!-- This representation indicates that the GNU nested function extension -->
<!-- is in use.  For details on the semantics of nested functions, see the -->
<!-- GCC Manual.  The nested function can refer to local variables in its -->
<!-- containing function.  Such references are not explicitly marked in the -->
<!-- tree structure; back ends must look at the @code{DECL_CONTEXT} for the -->
<!-- referenced @code{VAR_DECL}.  If the @code{DECL_CONTEXT} for the -->
<!-- referenced @code{VAR_DECL} is not the same as the function currently -->
<!-- being processed, and neither @code{DECL_EXTERNAL} nor -->
<!-- @code{TREE_STATIC} hold, then the reference is to a local variable in -->
<!-- a containing function, and the back end must take appropriate action. -->
 <p>在C中，函数的<code>DECL_CONTEXT</code>可能为另一个函数。这表示正在使用GNU嵌套函数扩展功能。关于嵌套函数语法的详细内容，参见GCC手册。嵌套函数可以引用其所包含的函数的局部变量。这样的引用没有在树结构体里被显示的标记。如果被引用<code>VAR_DECL</code>的<code>DECL_CONTEXT</code>与当前被处理的函数不相同，并且<code>DECL_EXTERNAL</code>和<code>DECL_STATIC</code>都没有持有内容，则该引用是针对包含的函数的局部变量，后端必须采取合适的行为。

     <dl>
<dt><code>DECL_EXTERNAL</code><a name="index-DECL_005fEXTERNAL-2563"></a><dd><!-- This predicate holds if the function is undefined. -->
该断言判断函数是否未定义。

     <br><dt><code>TREE_PUBLIC</code><a name="index-TREE_005fPUBLIC-2564"></a><dd><!-- This predicate holds if the function has external linkage. -->
该断言判断函数是否具有外部连接。

     <br><dt><code>TREE_STATIC</code><a name="index-TREE_005fSTATIC-2565"></a><dd><!-- This predicate holds if the function has been defined. -->
该断言判断函数是否已经被定义。

     <br><dt><code>TREE_THIS_VOLATILE</code><a name="index-TREE_005fTHIS_005fVOLATILE-2566"></a><dd><!-- This predicate holds if the function does not return normally. -->
该断言判断函数是否不进行正常的返回。

     <br><dt><code>TREE_READONLY</code><a name="index-TREE_005fREADONLY-2567"></a><dd><!-- This predicate holds if the function can only read its arguments. -->
该断言判断函数是否只能对参数进行读操作。

     <br><dt><code>DECL_PURE_P</code><a name="index-DECL_005fPURE_005fP-2568"></a><dd><!-- This predicate holds if the function can only read its arguments, but -->
<!-- may also read global memory. -->
该断言判断函数是否只能对参数进行读操作，但是还可以读全局内存。

     <br><dt><code>DECL_VIRTUAL_P</code><a name="index-DECL_005fVIRTUAL_005fP-2569"></a><dd><!-- This predicate holds if the function is virtual. -->
该断言判断函数是否为虚函数。

     <br><dt><code>DECL_ARTIFICIAL</code><a name="index-DECL_005fARTIFICIAL-2570"></a><dd><!-- This macro holds if the function was implicitly generated by the -->
<!-- compiler, rather than explicitly declared.  In addition to implicitly -->
<!-- generated class member functions, this macro holds for the special -->
<!-- functions created to implement static initialization and destruction, to -->
<!-- compute run-time type information, and so forth. -->
该宏保存了函数是否由编译器隐式的生成，而不是被显式的生成。除了隐式的生成的类成员函数以外，该宏还保存了创建的特定函数，用来实现静态初始化和析构，来计算运行时信息等等。

     <br><dt><code>DECL_FUNCTION_SPECIFIC_TARGET</code><a name="index-DECL_005fFUNCTION_005fSPECIFIC_005fTARGET-2571"></a><dd><!-- This macro returns a tree node that holds the target options that are -->
<!-- to be used to compile this particular function or @code{NULL_TREE} if -->
<!-- the function is to be compiled with the target options specified on -->
<!-- the command line. -->
该宏返回一个tree节点，存放了用于编译该特定函数的目标机选项，或者为<code>NULL_TREE</code>，如果是使用命令行中指定的目标机选项来编译该函数。

     <br><dt><code>DECL_FUNCTION_SPECIFIC_OPTIMIZATION</code><a name="index-DECL_005fFUNCTION_005fSPECIFIC_005fOPTIMIZATION-2572"></a><dd><!-- This macro returns a tree node that holds the optimization options -->
<!-- that are to be used to compile this particular function or -->
<!-- @code{NULL_TREE} if the function is to be compiled with the -->
<!-- optimization options specified on the command line. -->
该宏返回一个tree节点，存放了用于编译该特定函数的优化选项，或者为<code>NULL_TREE</code>，如果是使用命令行中指定的优化选项来编译该函数。

 </dl>

<!--  -->
<!-- Language-dependent trees -->
<!--  -->
<!-- @node Language-dependent trees -->
<!-- @section Language-dependent trees -->
 </body></html>

