<html lang="zh">
<head>
<title>Target Attributes - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Mode-Switching.html#Mode-Switching" title="Mode Switching">
<link rel="next" href="Emulated-TLS.html#Emulated-TLS" title="Emulated TLS">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Target-Attributes"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Emulated-TLS.html#Emulated-TLS">Emulated TLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Mode-Switching.html#Mode-Switching">Mode Switching</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.25 定义目标机特定的<code>__attribute__</code>用法</h3>

<p><a name="index-target-attributes-4723"></a><a name="index-machine-attributes-4724"></a><a name="index-attributes_002c-target_002dspecific-4725"></a>
<!-- Target-specific attributes may be defined for functions, data and types. -->
<!-- These are described using the following target hooks; they also need to -->
<!-- be documented in @file{extend.texi}. -->
可以为函数，数据和类型定义target特定的属性。
这些使用下列target钩子来描述；它们还需要在<samp><span class="file">extend.texi</span></samp>中被记述。

<div class="defun">
&mdash; Target Hook: const struct attribute_spec * <b>TARGET_ATTRIBUTE_TABLE</b><var><a name="index-TARGET_005fATTRIBUTE_005fTABLE-4726"></a></var><br>
<blockquote><!-- If defined, this target hook points to an array of @samp{struct -->
     <!-- attribute_spec} (defined in @file{tree.h}) specifying the machine -->
     <!-- specific attributes for this target and some of the restrictions on the -->
     <!-- entities to which these attributes are applied and the arguments they -->
     <!-- take. -->
      <p>如果定义，
该目标钩子指向一个&lsquo;<samp><span class="samp">struct attribute_spec</span></samp>&rsquo; (在<samp><span class="file">tree.h</span></samp>中定义) 数组，
用来指定该目标的机器特定的属性，
以及这些属性被应用到的实体和它们接受的参数的一些限制。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P</b> (<var>const_tree name</var>)<var><a name="index-TARGET_005fATTRIBUTE_005fTAKES_005fIDENTIFIER_005fP-4727"></a></var><br>
<blockquote><!-- If defined, this target hook is a function which returns true if the -->
     <!-- machine-specific attribute named @var{name} expects an identifier -->
     <!-- given as its first argument to be passed on as a plain identifier, not -->
     <!-- subjected to name lookup.  If this is not defined, the default is -->
     <!-- false for all machine-specific attributes. -->
      </blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_COMP_TYPE_ATTRIBUTES</b> (<var>const_tree type1, const_tree type2</var>)<var><a name="index-TARGET_005fCOMP_005fTYPE_005fATTRIBUTES-4728"></a></var><br>
<blockquote><!-- If defined, this target hook is a function which returns zero if the attributes on -->
     <!-- @var{type1} and @var{type2} are incompatible, one if they are compatible, -->
     <!-- and two if they are nearly compatible (which causes a warning to be -->
     <!-- generated).  If this is not defined, machine-specific attributes are -->
     <!-- supposed always to be compatible. -->
      <p>如果定义，该目标钩子为一个函数，
如果<var>type1</var>和<var>type2</var>的属性不匹配则返回0，匹配则返回1，
几乎匹配则返回2（这将产生一个warning）。如果没有被定义，
则机器特定的属性总被假定为匹配的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SET_DEFAULT_TYPE_ATTRIBUTES</b> (<var>tree type</var>)<var><a name="index-TARGET_005fSET_005fDEFAULT_005fTYPE_005fATTRIBUTES-4729"></a></var><br>
<blockquote><!-- If defined, this target hook is a function which assigns default attributes to -->
     <!-- the newly defined @var{type}. -->
      <p>如果定义，该目标钩子为一个函数，其将缺省属性赋予新定义的类型<var>type</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_MERGE_TYPE_ATTRIBUTES</b> (<var>tree type1, tree type2</var>)<var><a name="index-TARGET_005fMERGE_005fTYPE_005fATTRIBUTES-4730"></a></var><br>
<blockquote><!-- Define this target hook if the merging of type attributes needs special -->
     <!-- handling.  If defined, the result is a list of the combined -->
     <!-- @code{TYPE_ATTRIBUTES} of @var{type1} and @var{type2}.  It is assumed -->
     <!-- that @code{comptypes} has already been called and returned 1.  This -->
     <!-- function may call @code{merge_attributes} to handle machine-independent -->
     <!-- merging. -->
      <p>定义该target钩子，如果合并类型属性需要进行特殊的处理。
如果定义，则结果为<var>type1</var>和<var>type2</var>的组合<code>TYPE_ATTRIBUTES</code>列表。
其假设<code>comptypes</code>总是被调用并返回1。
该函数可以调用<code>merge_attributes</code>来处理机器无关的合并。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_MERGE_DECL_ATTRIBUTES</b> (<var>tree olddecl, tree newdecl</var>)<var><a name="index-TARGET_005fMERGE_005fDECL_005fATTRIBUTES-4731"></a></var><br>
<blockquote><!-- Define this target hook if the merging of decl attributes needs special -->
     <!-- handling.  If defined, the result is a list of the combined -->
     <!-- @code{DECL_ATTRIBUTES} of @var{olddecl} and @var{newdecl}. -->
     <!-- @var{newdecl} is a duplicate declaration of @var{olddecl}.  Examples of -->
     <!-- when this is needed are when one attribute overrides another, or when an -->
     <!-- attribute is nullified by a subsequent definition.  This function may -->
     <!-- call @code{merge_attributes} to handle machine-independent merging. -->
      <p>定义该target钩子，如果合并decl属性需要进行特殊的处理。如果定义，
则结果为<var>olddecl</var>和<var>newdecl</var>的组合<code>DECL_ATTRIBUTES</code>列表。
<var>newdecl</var>为<var>olddecl</var>的拷贝。这样的例子是当一个属性覆盖另一个，
或者当一个属性被后续的属性置空的情况。
该函数可以调用<code>merge_attributes</code>来处理机器无关的合并。

      <p><a name="index-TARGET_005fDLLIMPORT_005fDECL_005fATTRIBUTES-4732"></a><!-- If the only target-specific handling you require is @samp{dllimport} -->
<!-- for Microsoft Windows targets, you should define the macro -->
<!-- @code{TARGET_DLLIMPORT_DECL_ATTRIBUTES} to @code{1}.  The compiler -->
<!-- will then define a function called -->
<!-- @code{merge_dllimport_decl_attributes} which can then be defined as -->
<!-- the expansion of @code{TARGET_MERGE_DECL_ATTRIBUTES}.  You can also -->
<!-- add @code{handle_dll_attribute} in the attribute table for your port -->
<!-- to perform initial processing of the @samp{dllimport} and -->
<!-- @samp{dllexport} attributes.  This is done in @file{i386/cygwin.h} and -->
<!-- @file{i386/i386.c}, for example. -->
如果唯一需要target特定的处理是Microsoft Windows target的&lsquo;<samp><span class="samp">dllimport</span></samp>&rsquo;，
则你应该定义宏<code>TARGET_DLLIMPORT_DECL_ATTRIBUTES</code>为<code>1</code>。
然后编译器将会定义一个叫做<code>merge_dllimport_decl_attributes</code>的函数，
其可以被定义为<code>TARGET_MERGE_DECL_ATTRIBUTES</code>的扩展。
你还可以为你的port在属性表中增加<code>handle_dll_attribute</code>，
来执行&lsquo;<samp><span class="samp">dllimport</span></samp>&rsquo;和&lsquo;<samp><span class="samp">dllexport</span></samp>&rsquo;属性的初始化处理。
例如，在<samp><span class="file">i386/cygwin.h</span></samp>和<samp><span class="file">i386/i386.c</span></samp>中。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VALID_DLLIMPORT_ATTRIBUTE_P</b> (<var>const_tree decl</var>)<var><a name="index-TARGET_005fVALID_005fDLLIMPORT_005fATTRIBUTE_005fP-4733"></a></var><br>
<blockquote><!-- @var{decl} is a variable or function with @code{__attribute__((dllimport))} specified.  Use this hook if the target needs to add extra validation checks to @code{handle_dll_attribute}. -->
      <p><var>decl</var>为一个指定为<code>__attribute__((dllimport))</code>的变量或者函数。
使用该钩子，如果target需要给<code>handle_dll_attribute</code>增加额外的有效性检查。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>TARGET_DECLSPEC</b><var><a name="index-TARGET_005fDECLSPEC-4734"></a></var><br>
<blockquote><!-- Define this macro to a nonzero value if you want to treat -->
     <!-- @code{__declspec(X)} as equivalent to @code{__attribute((X))}.  By -->
     <!-- default, this behavior is enabled only for targets that define -->
     <!-- @code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}.  The current implementation -->
     <!-- of @code{__declspec} is via a built-in macro, but you should not rely -->
     <!-- on this implementation detail. -->
      <p>定义该宏为非零，
如果你想将<code>__declspec(X)</code>与<code>__attribute((X))</code>等同对待。
缺省下，只有在定义了<code>TARGET_DLLIMPORT_DECL_ATTRIBUTES</code>的target上才可以。
目前对于<code>__declspec</code>的实现是通过一个内建的宏，但是你不应该依赖于实现细节。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_INSERT_ATTRIBUTES</b> (<var>tree node, tree *attr_ptr</var>)<var><a name="index-TARGET_005fINSERT_005fATTRIBUTES-4735"></a></var><br>
<blockquote><!-- Define this target hook if you want to be able to add attributes to a decl -->
     <!-- when it is being created.  This is normally useful for back ends which -->
     <!-- wish to implement a pragma by using the attributes which correspond to -->
     <!-- the pragma's effect.  The @var{node} argument is the decl which is being -->
     <!-- created.  The @var{attr_ptr} argument is a pointer to the attribute list -->
     <!-- for this decl.  The list itself should not be modified, since it may be -->
     <!-- shared with other decls, but attributes may be chained on the head of -->
     <!-- the list and @code{*@var{attr_ptr}} modified to point to the new -->
     <!-- attributes, or a copy of the list may be made if further changes are -->
     <!-- needed. -->
      <p>定义该target钩子，如果你想在decl被创建时，能够为其增加属性。
这在后端想要实现一个pragma，并且用到与pragma相关的属性的时候，
通常很有用。参数<var>node</var>是正在创建的decl。
参数<var>attr_ptr</var>是指向该decl的属性列表的指针。不要修改列表本身，
因为其可能与其它decl共享，但是可以将属性链接到列表的头部，
并且修改<code>*</code><var>attr_ptr</var>以指向新的属性，或者如果需要进一步的修改，
创建一个列表的拷贝。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P</b> (<var>const_tree fndecl</var>)<var><a name="index-TARGET_005fFUNCTION_005fATTRIBUTE_005fINLINABLE_005fP-4736"></a></var><br>
<blockquote><p><a name="index-inlining-4737"></a><!-- This target hook returns @code{true} if it is ok to inline @var{fndecl} -->
<!-- into the current function, despite its having target-specific -->
<!-- attributes, @code{false} otherwise.  By default, if a function has a -->
<!-- target specific attribute attached to it, it will not be inlined. -->
该target钩子返回<code>true</code>，如果可以将<var>fndecl</var>内联到当前函数中，
而不管它具有的target特定属性，否则为<code>false</code>。
缺省下，如果函数具有一个target特定属性，则不会被内联。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_OPTION_VALID_ATTRIBUTE_P</b> (<var>tree fndecl, tree name, tree args, int flags</var>)<var><a name="index-TARGET_005fOPTION_005fVALID_005fATTRIBUTE_005fP-4738"></a></var><br>
<blockquote><p>This hook is called to parse the <code>attribute(option("..."))</code>, and
it allows the function to set different target machine compile time
options for the current function that might be different than the
options specified on the command line.  The hook should return
<code>true</code> if the options are valid.

      <p>The hook should set the <var>DECL_FUNCTION_SPECIFIC_TARGET</var> field in
the function declaration to hold a pointer to a target specific
<var>struct cl_target_option</var> structure. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_OPTION_SAVE</b> (<var>struct cl_target_option *ptr</var>)<var><a name="index-TARGET_005fOPTION_005fSAVE-4739"></a></var><br>
<blockquote><p>This hook is called to save any additional target specific information
in the <var>struct cl_target_option</var> structure for function specific
options. 
参见<a href="Option-file-format.html#Option-file-format">Option file format</a>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_OPTION_RESTORE</b> (<var>struct cl_target_option *ptr</var>)<var><a name="index-TARGET_005fOPTION_005fRESTORE-4740"></a></var><br>
<blockquote><p>This hook is called to restore any additional target specific
information in the <var>struct cl_target_option</var> structure for
function specific options. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_OPTION_PRINT</b> (<var>FILE *file, int indent, struct cl_target_option *ptr</var>)<var><a name="index-TARGET_005fOPTION_005fPRINT-4741"></a></var><br>
<blockquote><p>This hook is called to print any additional target specific
information in the <var>struct cl_target_option</var> structure for
function specific options. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_OPTION_PRAGMA_PARSE</b> (<var>tree args, tree pop_target</var>)<var><a name="index-TARGET_005fOPTION_005fPRAGMA_005fPARSE-4742"></a></var><br>
<blockquote><p>This target hook parses the options for <code>#pragma GCC option</code> to
set the machine specific options for functions that occur later in the
input stream.  The options should be the same as handled by the
<code>TARGET_OPTION_VALID_ATTRIBUTE_P</code> hook. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_OPTION_OVERRIDE</b> (<var>void</var>)<var><a name="index-TARGET_005fOPTION_005fOVERRIDE-4743"></a></var><br>
<blockquote><p>Sometimes certain combinations of command options do not make sense on
a particular target machine.  You can override the hook
<code>TARGET_OPTION_OVERRIDE</code> to take account of this.  This hooks is called
once just after all the command options have been parsed.

      <p>Don't use this hook to turn on various extra optimizations for
<samp><span class="option">-O</span></samp>.  That is what <code>TARGET_OPTION_OPTIMIZATION</code> is for.

      <p>If you need to do something whenever the optimization level is
changed via the optimize attribute or pragma, see
<code>TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE</code>
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CAN_INLINE_P</b> (<var>tree caller, tree callee</var>)<var><a name="index-TARGET_005fCAN_005fINLINE_005fP-4744"></a></var><br>
<blockquote><p>This target hook returns <code>false</code> if the <var>caller</var> function
cannot inline <var>callee</var>, based on target specific information.  By
default, inlining is not allowed if the callee function has function
specific target options and the caller does not use the same options. 
</p></blockquote></div>

 </body></html>

