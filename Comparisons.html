<html lang="zh">
<head>
<title>Comparisons - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="Arithmetic.html#Arithmetic" title="Arithmetic">
<link rel="next" href="Bit_002dFields.html#Bit_002dFields" title="Bit-Fields">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Comparisons"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Bit_002dFields.html#Bit_002dFields">Bit-Fields</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Arithmetic.html#Arithmetic">Arithmetic</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.10 比较运算</h3>

<p><a name="index-RTL-comparison-operations-2128"></a>
<!-- Comparison operators test a relation on two operands and are considered -->
<!-- to represent a machine-dependent nonzero value described by, but not -->
<!-- necessarily equal to, @code{STORE_FLAG_VALUE} (@pxref{Misc}) -->
<!-- if the relation holds, or zero if it does not, for comparison operators -->
<!-- whose results have a `MODE_INT' mode, -->
<!-- @code{FLOAT_STORE_FLAG_VALUE} (@pxref{Misc}) if the relation holds, or -->
<!-- zero if it does not, for comparison operators that return floating-point -->
<!-- values, and a vector of either @code{VECTOR_STORE_FLAG_VALUE} (@pxref{Misc}) -->
<!-- if the relation holds, or of zeros if it does not, for comparison operators -->
<!-- that return vector results. -->
<!-- The mode of the comparison operation is independent of the mode -->
<!-- of the data being compared.  If the comparison operation is being tested -->
<!-- (e.g., the first operand of an @code{if_then_else}), the mode must be -->
<!-- @code{VOIDmode}. -->
比较运算符测试两个操作数的关系，对于结果具有`MODE_INT'机器模式的比较运算，如果关系成立，则表示成机器相关的非零值，其由<code>STORE_FLAG_VALUE</code>
(参见<a href="Misc.html#Misc">Misc</a>)描述，但是不需要相等，如果不成立，则为零。对于结果为浮点值的比较运算，如果关系成立，则为<code>FLOAT_STORE_FLAG_VALUE</code>
(参见<a href="Misc.html#Misc">Misc</a>)，否则为零。对于返回向量结果的比较运算，如果关系成立，则为<code>VECTOR_STORE_FLAG_VALUE</code>
(参见<a href="Misc.html#Misc">Misc</a>)，否则为零向量。比较运算的机器模式独立于被比较的数据的机器模式。如果正在测试比较运算（例如，<code>if_then_else</code>的第一个操作数），则机器模式必须为<code>VOIDmode</code>。

 <p><a name="index-condition-codes-2129"></a><!-- There are two ways that comparison operations may be used.  The -->
<!-- comparison operators may be used to compare the condition codes -->
<!-- @code{(cc0)} against zero, as in @code{(eq (cc0) (const_int 0))}.  Such -->
<!-- a construct actually refers to the result of the preceding instruction -->
<!-- in which the condition codes were set.  The instruction setting the -->
<!-- condition code must be adjacent to the instruction using the condition -->
<!-- code; only @code{note} insns may separate them. -->
有两种方式可以被比较运算使用。比较运算符可以用于将条件代码<code>(cc0)</code>与零进行比较，型如<code>(eq (cc0) (const_int 0))</code>。这种结构实际上是用到了先前指令的结果，条件代码在那里被设置。设置条件代码的指令必须邻接于使用条件代码的指令；只有<code>note</code> insn可以分开它们。

<!-- Alternatively, a comparison operation may directly compare two data -->
<!-- objects.  The mode of the comparison is determined by the operands; they -->
<!-- must both be valid for a common machine mode.  A comparison with both -->
<!-- operands constant would be invalid as the machine mode could not be -->
<!-- deduced from it, but such a comparison should never exist in RTL due to -->
<!-- constant folding. -->
 <p>替换的，比较运算可以直接比较两个数据对象。比较运算的机器模式由操作数来决定；它们必须对一个共同的机器模式有效。对两个操作数都为常量的比较，将是无效的，因为不能从中推导出机器模式，不过这样的比较不会出现在RTL中，因为常数折叠。

<!-- In the example above, if @code{(cc0)} were last set to -->
<!-- @code{(compare @var{x} @var{y})}, the comparison operation is -->
<!-- identical to @code{(eq @var{x} @var{y})}.  Usually only one style -->
<!-- of comparisons is supported on a particular machine, but the combine -->
<!-- pass will try to merge the operations to produce the @code{eq} shown -->
<!-- in case it exists in the context of the particular insn involved. -->
 <p>在上面的例子中，如果<code>(cc0)</code>最后被设置为<code>(compare </code><var>x</var> <var>y</var><code>)</code>，则比较运算等价于<code>(eq </code><var>x</var> <var>y</var><code>)</code>。通常，在一个特定的机器上，只支持一种风格的比较。但是，合并过程将尝试合并运算，从而产生<code>eq</code>。

<!-- Inequality comparisons come in two flavors, signed and unsigned.  Thus, -->
<!-- there are distinct expression codes @code{gt} and @code{gtu} for signed and -->
<!-- unsigned greater-than.  These can produce different results for the same -->
<!-- pair of integer values: for example, 1 is signed greater-than @minus{}1 but not -->
<!-- unsigned greater-than, because @minus{}1 when regarded as unsigned is actually -->
<!-- @code{0xffffffff} which is greater than 1. -->
 <p>不等式比较有两种，有符号和无符号。因此，对于有符号和无符号的大于，有两个不同的表达式代码<code>gt</code>和<code>gtu</code>。对于相同的整数值，这些可以产生不同的结果：例如，1有符号大于&minus;1，但是并不无符号大于，因为&minus;1被作为无符号时，实际为<code>0xffffffff</code>，其大于1。

<!-- The signed comparisons are also used for floating point values.  Floating -->
<!-- point comparisons are distinguished by the machine modes of the operands. -->
 <p>有符号比较也用于浮点值。浮点比较通过操作数的机器模式来区分。

     
<a name="index-eq-2130"></a>
<a name="index-equal-2131"></a>
<dl><dt><code>(eq:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- @code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y} -->
<!-- are equal, otherwise 0. -->
如果<var>x</var>和<var>y</var>所表示的值相等，则为<code>STORE_FLAG_VALUE</code>，否则为0。

     <p><a name="index-ne-2132"></a><a name="index-not-equal-2133"></a><br><dt><code>(ne:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- @code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y} -->
<!-- are not equal, otherwise 0. -->
如果<var>x</var>和<var>y</var>所表示的值不相等，则为<code>STORE_FLAG_VALUE</code>，否则为0。

     <p><a name="index-gt-2134"></a><a name="index-greater-than-2135"></a><br><dt><code>(gt:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- @code{STORE_FLAG_VALUE} if the @var{x} is greater than @var{y}.  If they -->
<!-- are fixed-point, the comparison is done in a signed sense. -->
如果<var>x</var>比<var>y</var>大，则为<code>STORE_FLAG_VALUE</code>。如果它们为定点，则按照有符号比较。

     <p><a name="index-gtu-2136"></a><a name="index-greater-than-2137"></a><a name="index-unsigned-greater-than-2138"></a><br><dt><code>(gtu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Like @code{gt} but does unsigned comparison, on fixed-point numbers only. -->
类似于<code>gt</code>，不过进行无符号比较，只用于定点数。

     <p><a name="index-lt-2139"></a><a name="index-less-than-2140"></a><a name="index-ltu-2141"></a><a name="index-unsigned-less-than-2142"></a><br><dt><code>(lt:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(ltu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Like @code{gt} and @code{gtu} but test for ``less than''. -->
类似于<code>gt</code>和<code>gtu</code>，不过测试“小于”。

     <p><a name="index-ge-2143"></a><a name="index-greater-than-2144"></a><a name="index-geu-2145"></a><a name="index-unsigned-greater-than-2146"></a><br><dt><code>(ge:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(geu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Like @code{gt} and @code{gtu} but test for ``greater than or equal''. -->
类似于<code>gt</code>和<code>gtu</code>，不过测试“大于或等于”。

     <p><a name="index-le-2147"></a><a name="index-less-than-or-equal-2148"></a><a name="index-leu-2149"></a><a name="index-unsigned-less-than-2150"></a><br><dt><code>(le:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dt><code>(leu:</code><var>m</var> <var>x</var> <var>y</var><code>)</code><dd><!-- Like @code{gt} and @code{gtu} but test for ``less than or equal''. -->
类似于<code>gt</code>和<code>gtu</code>，不过测试“小于或等于”。

     <p><a name="index-if_005fthen_005felse-2151"></a><br><dt><code>(if_then_else </code><var>cond</var> <var>then</var> <var>else</var><code>)</code><dd><!-- This is not a comparison operation but is listed here because it is -->
<!-- always used in conjunction with a comparison operation.  To be -->
<!-- precise, @var{cond} is a comparison expression.  This expression -->
<!-- represents a choice, according to @var{cond}, between the value -->
<!-- represented by @var{then} and the one represented by @var{else}. -->
这不是比较运算，但是被列在这里，因为其总是与比较运算结合使用。确切的说，<var>cond</var>为一个比较表达式。该表达式表示一个根据<var>cond</var>，在<var>then</var>所表示的值和<var>else</var>所表示的值之间的选择，

     <!-- On most machines, @code{if_then_else} expressions are valid only -->
     <!-- to express conditional jumps. -->
     <p>在大多数机器上，<code>if_then_else</code>表达式只用于表示条件跳转。

     <p><a name="index-cond-2152"></a><br><dt><code>(cond [</code><var>test1</var> <var>value1</var> <var>test2</var> <var>value2</var><code> ...] </code><var>default</var><code>)</code><dd><!-- Similar to @code{if_then_else}, but more general.  Each of @var{test1}, -->
<!-- @var{test2}, @dots{} is performed in turn.  The result of this expression is -->
<!-- the @var{value} corresponding to the first nonzero test, or @var{default} if -->
<!-- none of the tests are nonzero expressions. -->
类似于<code>if_then_else</code>，不过更普通。每个<var>test1</var>，<var>test2</var>，<small class="dots">...</small>被依次执行。表达式的结果为对应于第一个非零测试的<var>value</var>，或者如果测试都为零，则为<var>default</var>。

     <!-- This is currently not valid for instruction patterns and is supported only -->
     <!-- for insn attributes.  @xref{Insn Attributes}. -->
     <p>这目前在指令模式中不可用，只在insn属性中被支持。参见<a href="Insn-Attributes.html#Insn-Attributes">Insn Attributes</a>.

 </dl>

<!-- @node Bit-Fields -->
<!-- @section Bit-Fields -->
 </body></html>

