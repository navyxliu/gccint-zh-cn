<html lang="zh">
<head>
<title>RTL passes - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Passes.html#Passes" title="Passes">
<link rel="prev" href="Tree-SSA-passes.html#Tree-SSA-passes" title="Tree SSA passes">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="RTL-passes"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Tree-SSA-passes.html#Tree-SSA-passes">Tree SSA passes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Passes.html#Passes">Passes</a>
<hr>
</div>

<h3 class="section">9.5 RTL过程</h3>

<!-- The following briefly describes the RTL generation and optimization -->
<!-- passes that are run after the Tree optimization passes. -->
<p>下面简要描述了tree优化之后所运行的rtl生成和优化过程。

     <ul>
<!-- @item RTL generation -->
<li>RTL生成

     <!-- Avoiding overfull is tricky here. -->
     <!-- The source files for RTL generation include -->
     <!-- @file{stmt.c}, -->
     <!-- @file{calls.c}, -->
     <!-- @file{expr.c}, -->
     <!-- @file{explow.c}, -->
     <!-- @file{expmed.c}, -->
     <!-- @file{function.c}, -->
     <!-- @file{optabs.c} -->
     <!-- and @file{emit-rtl.c}. -->
     <!-- Also, the file -->
     <!-- @file{insn-emit.c}, generated from the machine description by the -->
     <!-- program @code{genemit}, is used in this pass.  The header file -->
     <!-- @file{expr.h} is used for communication within this pass. -->
     <p>实现RTL生成的源文件包括
<samp><span class="file">stmt.c</span></samp>,
<samp><span class="file">calls.c</span></samp>,
<samp><span class="file">expr.c</span></samp>,
<samp><span class="file">explow.c</span></samp>,
<samp><span class="file">expmed.c</span></samp>,
<samp><span class="file">function.c</span></samp>,
<samp><span class="file">optabs.c</span></samp>和<samp><span class="file">emit-rtl.c</span></samp>。
该过程还用到了由<code>genemit</code>程序通过机器描述生成的<samp><span class="file">insn-emit.c</span></samp>文件。该过程使用头文件<samp><span class="file">expr.h</span></samp>来交互信息。

     <p><a name="index-genflags-1688"></a><a name="index-gencodes-1689"></a><!-- The header files @file{insn-flags.h} and @file{insn-codes.h}, -->
<!-- generated from the machine description by the programs @code{genflags} -->
<!-- and @code{gencodes}, tell this pass which standard names are available -->
<!-- for use and which patterns correspond to them. -->
由程序<code>genflags</code>和<code>gencodes</code>通过机器描述来生成的头文件<samp><span class="file">insn-flags.h</span></samp>和<samp><span class="file">insn-codes.h</span></samp>，告诉了该过程哪些标准名字可用，以及哪些模式与它们对应。

     <!-- @item Generation of exception landing pads -->
     <li>生成异常处理着陆架（Generate exception handling landing pads）

     <!-- This pass generates the glue that handles communication between the -->
     <!-- exception handling library routines and the exception handlers within -->
     <!-- the function.  Entry points in the function that are invoked by the -->
     <!-- exception handling library are called @dfn{landing pads}.  The code -->
     <!-- for this pass is located in @file{except.c}. -->
     <p>该过程生成用来管理异常处理库程序和函数中的异常处理器之间通讯的粘合机制（glue）。由异常处理库调用的函数的入口点，被称作着陆架（<dfn>landing pads</dfn>）。该过程的代码位于<samp><span class="file">except.c</span></samp>中。

     <!-- @item Control flow graph cleanup -->
     <li>清除控制流图（Cleanup control flow graph）

     <!-- This pass removes unreachable code, simplifies jumps to next, jumps to -->
     <!-- jump, jumps across jumps, etc.  The pass is run multiple times. -->
     <!-- For historical reasons, it is occasionally referred to as the ``jump -->
     <!-- optimization pass''.  The bulk of the code for this pass is in -->
     <!-- @file{cfgcleanup.c}, and there are support routines in @file{cfgrtl.c} -->
     <!-- and @file{jump.c}. -->
     <p>该过程去除不可达代码，对跳转到下一条指令（jumps to next），连续跳转（jumps to jump），交叉跳转（jumps across jumps）等情况进行简化。该过程被运行多次。出于历史原因，该过程有时被称为“跳转优化过程”。该过程的主要代码在<samp><span class="file">cfgcleanup.c</span></samp>中，还有一些辅助程序在<samp><span class="file">cfgrtl.c</span></samp>和<samp><span class="file">jump.c</span></samp>中。

     <!-- @item Forward propagation of single-def values -->
     <li>单定义值的向前传播（Forward propagation of single-def values）

     <!-- This pass attempts to remove redundant computation by substituting -->
     <!-- variables that come from a single definition, and -->
     <!-- seeing if the result can be simplified.  It performs copy propagation -->
     <!-- and addressing mode selection.  The pass is run twice, with values -->
     <!-- being propagated into loops only on the second run.  The code is -->
     <!-- located in @file{fwprop.c}. -->
     <p>该过程尝试通过替换来自单一定义的变量，并观察结果是否能够被简化的方式，来去除冗余计算。它执行了复制传播和寻址模式选择。该过程运行两次，并只在第二次的时候将值传播到循环中。它位于<samp><span class="file">fwprop.c</span></samp>中。

     <!-- @item Common subexpression elimination -->
     <li>公共子表达式消除（Common subexpression elimination）

     <!-- This pass removes redundant computation within basic blocks, and -->
     <!-- optimizes addressing modes based on cost.  The pass is run twice. -->
     <!-- The code for this pass is located in @file{cse.c}. -->
     <p>该过程去除基本块中的冗余计算，并且根据代价来优化寻址模式。该过程运行两次。源代码位于<samp><span class="file">cse.c</span></samp>中。

     <!-- @item Global common subexpression elimination -->
     <li>全局公共子表达式消除（Global common subexpression elimination）

     <!-- This pass performs two -->
     <!-- different types of GCSE  depending on whether you are optimizing for -->
     <!-- size or not (LCM based GCSE tends to increase code size for a gain in -->
     <!-- speed, while Morel-Renvoise based GCSE does not). -->
     <!-- When optimizing for size, GCSE is done using Morel-Renvoise Partial -->
     <!-- Redundancy Elimination, with the exception that it does not try to move -->
     <!-- invariants out of loops-that is left to  the loop optimization pass. -->
     <!-- If MR PRE GCSE is done, code hoisting (aka unification) is also done, as -->
     <!-- well as load motion. -->
     <!-- If you are optimizing for speed, LCM (lazy code motion) based GCSE is -->
     <!-- done.  LCM is based on the work of Knoop, Ruthing, and Steffen.  LCM -->
     <!-- based GCSE also does loop invariant code motion.  We also perform load -->
     <!-- and store motion when optimizing for speed. -->
     <!-- Regardless of which type of GCSE is used, the GCSE pass also performs -->
     <!-- global constant and  copy propagation. -->
     <!-- The source file for this pass is @file{gcse.c}, and the LCM routines -->
     <!-- are in @file{lcm.c}. -->
     <p>该过程执行两种不同类型的GCSE，取决于你是否在优化代码大小（基于LCM的GCSE趋向于通过增加代码大小来获得速度，而基于Morel- Renvoise的GCSE则不是）。当优化代码大小时，使用Morel-Renvoise Partial Redundancy Elimination（部分冗余消除）来做GCSE，并不尝试将不变量移到循环之外——这留到循环优化过程。如果进行MR PRE，则还会进行代码提升（code hoisting），（也称为code unification），还有加载移动（load motion）。如果你在优化速度，则会进行基于LCM（lazy code motion）的GCSE。LCM是基于Knoop, Ruthing和Steffen的工作。基于LCM的GCSE也会进行循环不变量代码移动。当优化速度时，我们还执行加载和存储移动。不管使用哪一种类型的GCSE，该过程都还执行全局常量传播和复制传播。该过程的源代码为<samp><span class="file">gcse.c</span></samp>，LCM程序在<samp><span class="file">lcm.c</span></samp>中。

     <!-- @item Loop optimization -->
     <li>循环优化（Loop optimization）

     <!-- This pass performs several loop related optimizations. -->
     <!-- The source files @file{cfgloopanal.c} and @file{cfgloopmanip.c} contain -->
     <!-- generic loop analysis and manipulation code.  Initialization and finalization -->
     <!-- of loop structures is handled by @file{loop-init.c}. -->
     <!-- A loop invariant motion pass is implemented in @file{loop-invariant.c}. -->
     <!-- Basic block level optimizations-unrolling, peeling and unswitching loops- -->
     <!-- are implemented in @file{loop-unswitch.c} and @file{loop-unroll.c}. -->
     <!-- Replacing of the exit condition of loops by special machine-dependent -->
     <!-- instructions is handled by @file{loop-doloop.c}. -->
     <p>该过程执行几个循环相关的优化。源文件<samp><span class="file">cfgloopanal.c</span></samp>和<samp><span class="file">cfgloopmanip.c</span></samp>包含了通用的循环分析和操作代码。循环结构体的初始化和完成（finalization）由<samp><span class="file">loop-init.c</span></samp>处理。循环不变量移动过程在<samp><span class="file">loop-invariant.c</span></samp>中实现。基本块级的优化—— unrolling,peeling和unswitching——在<samp><span class="file">loop-unswitch.c</span></samp>和<samp><span class="file">loop-unroll.c</span></samp>中实现。<samp><span class="file">loop-doloop.c</span></samp>是关于使用特定的机器相关结构来替代循环退出条件的处理。

     <!-- @item Jump bypassing -->
     <li>跳转迂回（Jump bypassing）

     <!-- This pass is an aggressive form of GCSE that transforms the control -->
     <!-- flow graph of a function by propagating constants into conditional -->
     <!-- branch instructions.  The source file for this pass is @file{gcse.c}. -->
     <p>该过程是GCSE的激进形式，通过传播常数到条件分支指令中来转换函数的控制流图。该过程的源文件为<samp><span class="file">gcse.c</span></samp>。

     <!-- @item If conversion -->
     <li>If转换（If conversion）

     <!-- This pass attempts to replace conditional branches and surrounding -->
     <!-- assignments with arithmetic, boolean value producing comparison -->
     <!-- instructions, and conditional move instructions.  In the very last -->
     <!-- invocation after reload, it will generate predicated instructions -->
     <!-- when supported by the target.  The code is located in @file{ifcvt.c}. -->
     <p>该过程尝试使用产生比较指令和条件移送指令的算术的布尔值，来替换条件分支和附近的赋值。在重载之后最近的调用中，当目标机支持的时候，其将生成断言指令。该过程位于<samp><span class="file">ifcvt.c</span></samp>。

     <!-- @item Web construction -->
     <li>Web构造（Web construction）

     <!-- This pass splits independent uses of each pseudo-register.  This can -->
     <!-- improve effect of the other transformation, such as CSE or register -->
     <!-- allocation.  The code for this pass is located in @file{web.c}. -->
     <p>该过程拆分为独立的使用每个伪寄存器。这能够提高其它转换过程的效率，例如CSE或者寄存器分配。源文件为<samp><span class="file">web.c</span></samp>。

     <!-- @item Instruction combination -->
     <li>指令合并（Instruction combination）

     <!-- This pass attempts to combine groups of two or three instructions that -->
     <!-- are related by data flow into single instructions.  It combines the -->
     <!-- RTL expressions for the instructions by substitution, simplifies the -->
     <!-- result using algebra, and then attempts to match the result against -->
     <!-- the machine description.  The code is located in @file{combine.c}. -->
     <p>该过程尝试去将数据流相关的两条或者三条指令组合并为单一指令。它通过替代，使用代数简化结果的方式来为指令合并RTL表达式，然后尝试去将结果跟机器描述匹配。该过程位于<samp><span class="file">combine.c</span></samp>。

     <!-- @item Register movement -->
     <li>寄存器移动（Register movement）

     <!-- This pass looks for cases where matching constraints would force an -->
     <!-- instruction to need a reload, and this reload would be a -->
     <!-- register-to-register move.  It then attempts to change the registers -->
     <!-- used by the instruction to avoid the move instruction.  The code is -->
     <!-- located in @file{regmove.c}. -->
     <p>该过程寻找这样的情况，即当匹配约束条件时会迫使指令需要重载，并且这个重载为一个寄存器到寄存器的move操作。然后它尝试改变指令使用的寄存器来避免move指令。该过程位于<samp><span class="file">regmove.c</span></samp>中。

     <!-- @item Mode switching optimization -->
     <li>优化模式转换（Optimize mode switching）

     <!-- This pass looks for instructions that require the processor to be in a -->
     <!-- specific ``mode'' and minimizes the number of mode changes required to -->
     <!-- satisfy all users.  What these modes are, and what they apply to are -->
     <!-- completely target-specific.  The code for this pass is located in -->
     <!-- @file{mode-switching.c}. -->
     <p>该过程寻找这样的指令，即需要处理器处于特定的模式（mode），然后将模式改变的数目减到最少。这些模式是什么以及应用于什么完全是目标机特定的。源代码位于<samp><span class="file">mode-switching.c</span></samp>中。

     <p><a name="index-modulo-scheduling-1690"></a><a name="index-sms_002c-swing_002c-software-pipelining-1691"></a><!-- @item Modulo scheduling -->
<li>模调度（Modulo scheduling）

     <!-- This pass looks at innermost loops and reorders their instructions -->
     <!-- by overlapping different iterations.  Modulo scheduling is performed -->
     <!-- immediately before instruction scheduling.  The code for this pass is -->
     <!-- located in @file{modulo-sched.c}. -->
     <p>该过程查看内部循环并且通过复合不同的迭代来重排它们的指令。模调度在指令调度之后立即被执行。该过程位于<samp><span class="file">modulo-sched.c</span></samp>。

     <!-- @item Instruction scheduling -->
     <li>指令调度（Instruction scheduling）

     <!-- This pass looks for instructions whose output will not be available by -->
     <!-- the time that it is used in subsequent instructions.  Memory loads and -->
     <!-- floating point instructions often have this behavior on RISC machines. -->
     <!-- It re-orders instructions within a basic block to try to separate the -->
     <!-- definition and use of items that otherwise would cause pipeline -->
     <!-- stalls.  This pass is performed twice, before and after register -->
     <!-- allocation.  The code for this pass is located in @file{haifa-sched.c}, -->
     <!-- @file{sched-deps.c}, @file{sched-ebb.c}, @file{sched-rgn.c} and -->
     <!-- @file{sched-vis.c}. -->
     <p>该过程寻找这样的指令，其输出在后来的指令中不会用到。在RISC机器上，内存加载和浮点指令经常会有这样的特征。它重新排序基本块中的指令以尝试将定义和使用分开，从而避免引起流水线阻塞。该过程执行两次，分别在寄存器分配之前和之后。该过程位于<samp><span class="file">haifa-sched.c</span></samp>, <samp><span class="file">sched-deps.c</span></samp>, <samp><span class="file">sched-ebb.c</span></samp>, <samp><span class="file">sched-rgn.c</span></samp>和<samp><span class="file">sched-vis.c</span></samp>中。

     <!-- @item Register allocation -->
     <li>寄存器分配（Register allocation）

     <!-- These passes make sure that all occurrences of pseudo registers are -->
     <!-- eliminated, either by allocating them to a hard register, replacing -->
     <!-- them by an equivalent expression (e.g.@: a constant) or by placing -->
     <!-- them on the stack.  This is done in several subpasses: -->
     <p>这些过程确保所有伪寄存器都被去除，或者通过给它们分配硬件寄存器，或者使用等价表达式来替换（例如常数），或者将它们放在栈中。这由几个子过程来完成：

          <ul>
<li><!-- Register move optimizations.  This pass makes some simple RTL code -->
<!-- transformations which improve the subsequent register allocation.  The -->
<!-- source file is @file{regmove.c}. -->
寄存器移送优化。该过程进行一些简单的RTL代码转换，来改进后续的寄存器分配。源文件为<samp><span class="file">regmove.c</span></samp>。

          <li><!-- The integrated register allocator (@acronym{IRA}).  It is called -->
<!-- integrated because coalescing, register live range splitting, and hard -->
<!-- register preferencing are done on-the-fly during coloring.  It also -->
<!-- has better integration with the reload pass.  Pseudo-registers spilled -->
<!-- by the allocator or the reload have still a chance to get -->
<!-- hard-registers if the reload evicts some pseudo-registers from -->
<!-- hard-registers.  The allocator helps to choose better pseudos for -->
<!-- spilling based on their live ranges and to coalesce stack slots -->
<!-- allocated for the spilled pseudo-registers.  IRA is a regional -->
<!-- register allocator which is transformed into Chaitin-Briggs allocator -->
<!-- if there is one region.  By default, IRA chooses regions using -->
<!-- register pressure but the user can force it to use one region or -->
<!-- regions corresponding to all loops. -->
集成寄存器分配(<acronym>IRA</acronym>)。其被称作集成的，是因为合并，寄存器活跃范围拆分，以及硬件寄存器优先选定，都在图着色中被执行。其还更好的与重载过程集合在一起。寄存器分配或者重载所溢出的伪寄存器还有机会来获得硬件寄存器，如果重载从硬件寄存器中赶出了一些伪寄存器。寄存器分配可以帮助选择更好的伪寄存器来溢出，基于它们的活跃返回，并且合并为溢出的伪寄存器所分配的栈槽。IRA为一个区域的寄存器分配，如果只有一个区域，则其被转换成Chaitin-Briggs寄存器分配。缺省的IRA使用寄存器压力来选择区域，不过用户可以强制其使用一个区域或者对应于所有循环的多个区域。

          <!-- Source files of the allocator are @file{ira.c}, @file{ira-build.c}, -->
          <!-- @file{ira-costs.c}, @file{ira-conflicts.c}, @file{ira-color.c}, -->
          <!-- @file{ira-emit.c}, @file{ira-lives}, plus header files @file{ira.h} -->
          <!-- and @file{ira-int.h} used for the communication between the allocator -->
          <!-- and the rest of the compiler and between the IRA files. -->
          <p>寄存器分配的源文件为<samp><span class="file">ira.c</span></samp>, <samp><span class="file">ira-build.c</span></samp>,<samp><span class="file">ira-costs.c</span></samp>, <samp><span class="file">ira-conflicts.c</span></samp>, <samp><span class="file">ira-color.c</span></samp>,<samp><span class="file">ira-emit.c</span></samp>, <samp><span class="file">ira-lives</span></samp>，以及头文件<samp><span class="file">ira.h</span></samp>和<samp><span class="file">ira-int.h</span></samp>，用于在分配器和编译器其它部分，以及IRA文件之间的交互。

          <p><a name="index-reloading-1692"></a><li><!-- Reloading.  This pass renumbers pseudo registers with the hardware -->
<!-- registers numbers they were allocated.  Pseudo registers that did not -->
<!-- get hard registers are replaced with stack slots.  Then it finds -->
<!-- instructions that are invalid because a value has failed to end up in -->
<!-- a register, or has ended up in a register of the wrong kind.  It fixes -->
<!-- up these instructions by reloading the problematical values -->
<!-- temporarily into registers.  Additional instructions are generated to -->
<!-- do the copying. -->
重载（reloading）。该过程使用分配的硬件寄存器编号来重新为伪寄存器编号。没有获得硬件寄存器的伪寄存器被分配到栈槽中。然后寻找那些由于无法放入寄存器，或者放入错误类型寄存器所引起的无效指令。通过将有问题的值临时重载到寄存器中来修复这些指令，并生成辅助的指令进行复制。

          <!-- The reload pass also optionally eliminates the frame pointer and inserts -->
          <!-- instructions to save and restore call-clobbered registers around calls. -->
          <p>重载过程还可选的消除帧指针，以及插入指令来保存和恢复调用破坏掉的（call-clobbered）寄存器。

          <!-- Source files are @file{reload.c} and @file{reload1.c}, plus the header -->
          <!-- @file{reload.h} used for communication between them. -->
          <p>源文件为<samp><span class="file">reload.c</span></samp>和<samp><span class="file">reload1.c</span></samp>，还有用于信息交互的头文件<samp><span class="file">reload.h</span></samp>。
</ul>

     <!-- @item Basic block reordering -->
     <li>基本块重新排序（Basic block reordering）

     <!-- This pass implements profile guided code positioning.  If profile -->
     <!-- information is not available, various types of static analysis are -->
     <!-- performed to make the predictions normally coming from the profile -->
     <!-- feedback (IE execution frequency, branch probability, etc).  It is -->
     <!-- implemented in the file @file{bb-reorder.c}, and the various -->
     <!-- prediction routines are in @file{predict.c}. -->
     <p>该过程实现了profile指导的代码安置（code positioning）。如果profile信息不可用，便会执行不同类型的静态分析来作出通常通过profile反馈（IE执行频率，分支可能性等）而得出的预测。其在<samp><span class="file">bb-reorder.c</span></samp>中实现，不同的预测程序在<samp><span class="file">predict.c</span></samp>中。

     <!-- @item Variable tracking -->
     <li>变量跟踪（Variable tracking）

     <!-- This pass computes where the variables are stored at each -->
     <!-- position in code and generates notes describing the variable locations -->
     <!-- to RTL code.  The location lists are then generated according to these -->
     <!-- notes to debug information if the debugging information format supports -->
     <!-- location lists.  The code is located in @file{var-tracking.c}. -->
     <p>该过程计算变量在代码中的每个位置（position）所被存储的到的地方，并生成注解到RTL代码中来描述变量位置(location)。如果调试信息格式支持位置列表(location lists)的话，便会根据这些注解来生成位置列表到调试信息中。

     <!-- @item Delayed branch scheduling -->
     <li>延迟分支调度（Delayed branch scheduling）

     <!-- This optional pass attempts to find instructions that can go into the -->
     <!-- delay slots of other instructions, usually jumps and calls.  The code -->
     <!-- for this pass is located in @file{reorg.c}. -->
     <p>该可选的过程尝试去找到能够放在其它指令，通常是跳转或者调用指令，的延迟槽中的指令。源文件名为<samp><span class="file">reorg.c</span></samp>。

     <!-- @item Branch shortening -->
     <li>分支缩短（Branch shortening）

     <!-- On many RISC machines, branch instructions have a limited range. -->
     <!-- Thus, longer sequences of instructions must be used for long branches. -->
     <!-- In this pass, the compiler figures out what how far each instruction -->
     <!-- will be from each other instruction, and therefore whether the usual -->
     <!-- instructions, or the longer sequences, must be used for each branch. -->
     <!-- The code for this pass is located in @file{final.c}. -->
     <p>许多RISC机器上，分支指令有一个限制范围。因此，较长的指令序列必须用于长分支。在这个过程中，编译器计算出指令间的距离有多长，并且对于每个分支是否使用普通指令或者交长的指令序列。

     <!-- @item Register-to-stack conversion -->
     <li>寄存器到栈的转换（Register-to-stack conversion）

     <!-- Conversion from usage of some hard registers to usage of a register -->
     <!-- stack may be done at this point.  Currently, this is supported only -->
     <!-- for the floating-point registers of the Intel 80387 coprocessor.  The -->
     <!-- code for this pass is located in @file{reg-stack.c}. -->
     <p>将一些硬件寄存器的使用转换为一个寄存器栈的使用可以在这里完成。目前，该过程只支持Intel 80387协处理器的浮点寄存器。源文件名为<samp><span class="file">reg-stack.c</span></samp>。

     <!-- @item Final -->
     <li>Final过程

     <!-- This pass outputs the assembler code for the function.  The source files -->
     <!-- are @file{final.c} plus @file{insn-output.c}; the latter is generated -->
     <!-- automatically from the machine description by the tool @file{genoutput}. -->
     <!-- The header file @file{conditions.h} is used for communication between -->
     <!-- these files.  If mudflap is enabled, the queue of deferred declarations -->
     <!-- and any addressed constants (e.g., string literals) is processed by -->
     <!-- @code{mudflap_finish_file} into a synthetic constructor function -->
     <!-- containing calls into the mudflap runtime. -->
     <p>该过程输出函数的汇编代码。源文件为<samp><span class="file">final.c</span></samp>和<samp><span class="file">insn-output.c</span></samp>，后者由工具<samp><span class="file">genoutput</span></samp>通过机器描述自动生成。头文件<samp><span class="file">conditions.h</span></samp>用于这些文件间的信息交互。如果启用了mudflap，延迟声明和可寻址常量（如字符串文字）的队列将由<code>mudflap_finish_file</code>处理成一个调用mudflap运行时的综合构造器函数。

     <!-- @item Debugging information output -->
     <li>调试信息输出

     <!-- This is run after final because it must output the stack slot offsets -->
     <!-- for pseudo registers that did not get hard registers.  Source files -->
     <!-- are @file{dbxout.c} for DBX symbol table format, @file{sdbout.c} for -->
     <!-- SDB symbol table format, @file{dwarfout.c} for DWARF symbol table -->
     <!-- format, files @file{dwarf2out.c} and @file{dwarf2asm.c} for DWARF2 -->
     <!-- symbol table format, and @file{vmsdbgout.c} for VMS debug symbol table -->
     <!-- format. -->
     <p>该过程在Final过程之后运行，是因为它必须为没有获得硬件寄存器的伪寄存器输出栈槽偏移量。源文件包括，用于DBX符号表格式的<samp><span class="file">dbxout.c</span></samp>，用于SDB符号表格式的<samp><span class="file">sdbout.c</span></samp>，用于DWARF符号表格式的<samp><span class="file">dwarfout.c</span></samp>，用于DWARF2符号表格式的<samp><span class="file">dwarf2out.c</span></samp>和<samp><span class="file">dwarf2asm.c</span></samp>，以及用于VMS调试符号表格式的<samp><span class="file">vmsdbgout.c</span></samp>。
</ul>

<!-- Copyright (C) 1988, 1989, 1992, 1994, 1997, 1998, 1999, 2000, 2001, 2002, -->
<!-- 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011 -->
<!-- Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gcc.texi. -->
<!-- @node RTL -->
<!-- @chapter RTL Representation -->
 </body></html>

