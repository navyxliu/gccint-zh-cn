@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
@c 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node Interface
@chapter GCC的输出接口（output interface）
@cindex interfacing to GCC output
@cindex run-time conventions
@cindex function call conventions
@cindex conventions, run-time

GCC通常被配置为使用目标平台系统默认的函数调用规范（function calling convention）。
这通过机器描述相应的宏（machine-description macros）来描述(@pxref{Target Macros})。

@cindex unions, returning
@cindex structures, returning
@cindex returning structures and unions
 
然而，在一些目标平台上，使用了不同的方法来处理结构体（struct）和联合体（union）的返回问题。
由此带来的一个结果是PCC和GCC编译的返回这类类型的函数无法相互调用。
这个问题不大，因为极少有Unix函数库例程（routine）返回这类类型。

对于长度为1、2、4、8字节的结构体/联合体，GCC通过跟 @code{int} 或 @code{double} 
一样的寄存器返回。对于别的大小的结构体/联合体，GCC会把它存储在一个调用函数传递过来的（内存）地址中
（这个地址一般都是存在寄存器中），目标机使用钩子（hook） @code{TARGET_STRUCT_VALUE_RTX}
来告诉GCC如何传递这个内存地址。

相反，绝大多数平台上的PCC是这么做的：为结构体/联合体类型的函数返回值开辟一个静态存储区，
然后被调用函数（callee）把结果复制到静态存储区中，调用函数（caller）从静态区复制过来。
这样做一来比GCC的方法效率低，二来不能重入。

在RISC、80386等一些目标机上，标准的调用规范是传递返回值的地址。
当（平台默认）使用这种方法时，GCC被设置成和这些平台上标准编译器（standard compiler）一致。
这可能和前面说的长度为1、2、4、8字节的结构体/联合体返回方式不兼容。

@cindex argument passing
@cindex passing arguments
GCC使用系统的标准规范（standard convention）传递参数。
在一些平台上，前几个参数是放在寄存器里面的，其余放在栈上。
在所有平台上都使用寄存传递所有的参数是可能的，而且会带来速度提升。
但这样就可能无法保证和使用标准规范的程序兼容了。
所以只有当你把GCC当成这个系统唯一的C编译器的时候才可行。
我们可能会在那些已经支持了全套GNU系统的平台上使用（全）寄存器参数传递，
因为这个时候我们可以用GCC来编译系统库。

另外一些平台（特别是SPARC），特定类型的参数通过``invisible reference''传递。
这意味着参数值存在内存中，地址传递给被调用函数（subroutine）。

@cindex @code{longjmp} and automatic variables
如果你要使用 @code{longjmp}, 小心自动变量（automatic variables）。
ISO C 中定义没有声明为 @code{volatile} 的自动变量在 @code{longjmp} 之后的值
是未定义（undefine）的。这也是GCC承诺的做法，因为正确的存储寄存器变量难度太大。
而且GCC的一个特性（feature）就是自动把变量放到寄存器中，即使你（被编译的代码）没有指定。

