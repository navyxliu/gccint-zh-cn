<html lang="zh">
<head>
<title>Storage Layout - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Per_002dFunction-Data.html#Per_002dFunction-Data" title="Per-Function Data">
<link rel="next" href="Type-Layout.html#Type-Layout" title="Type Layout">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Storage-Layout"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Type-Layout.html#Type-Layout">Type Layout</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Per_002dFunction-Data.html#Per_002dFunction-Data">Per-Function Data</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.5 存储布局</h3>

<p><a name="index-storage-layout-3817"></a>
<!-- Note that the definitions of the macros in this table which are sizes or -->
<!-- alignments measured in bits do not need to be constant.  They can be C -->
<!-- expressions that refer to static variables, such as the @code{target_flags}. -->
<!-- @xref{Run-time Target}. -->
注意该表格中的宏定义中，对于以bit为单位的大小或对齐，不需要为常量。它们可以为引用了静态变量的C表达式，例如<code>target_flags</code>。
参见<a href="Run_002dtime-Target.html#Run_002dtime-Target">Run-time Target</a>。

<div class="defun">
&mdash; Macro: <b>BITS_BIG_ENDIAN</b><var><a name="index-BITS_005fBIG_005fENDIAN-3818"></a></var><br>
<blockquote><!-- Define this macro to have the value 1 if the most significant bit in a -->
     <!-- byte has the lowest number; otherwise define it to have the value zero. -->
     <!-- This means that bit-field instructions count from the most significant -->
     <!-- bit.  If the machine has no bit-field instructions, then this must still -->
     <!-- be defined, but it doesn't matter which value it is defined to.  This -->
     <!-- macro need not be a constant. -->
      <p>定义该宏的值为1，如果字节中的最高有效位具有最低编号；否则定义其值为0。这意味着bit-field指令从最高有效位计数。如果机器没有bit-field指令，则该宏也需要被定义，但定义什么值都无所谓。该宏不需要为一个常量。

     <!-- This macro does not affect the way structure fields are packed into -->
     <!-- bytes or words; that is controlled by @code{BYTES_BIG_ENDIAN}. -->
      <p>该宏不影响结构体域被打包成字节或者字的方式；那是由<code>BYTES_BIG_ENDIAN</code>来控制的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BYTES_BIG_ENDIAN</b><var><a name="index-BYTES_005fBIG_005fENDIAN-3819"></a></var><br>
<blockquote><!-- Define this macro to have the value 1 if the most significant byte in a -->
     <!-- word has the lowest number.  This macro need not be a constant. -->
      <p>定义该宏的值为1，如果字中的最高有效字节具有最低编号。该宏不需要为一个常量。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>WORDS_BIG_ENDIAN</b><var><a name="index-WORDS_005fBIG_005fENDIAN-3820"></a></var><br>
<blockquote><!-- Define this macro to have the value 1 if, in a multiword object, the -->
     <!-- most significant word has the lowest number.  This applies to both -->
     <!-- memory locations and registers; see @code{REG_WORDS_BIG_ENDIAN} if the -->
      <p>+order of words in memory is not the same as the order in registers.  This
<!-- macro need not be a constant. -->
定义该宏的值为1，如果在多字（multiword）对象中，最高有效字具有最低编号。这同时应用于内存位置和寄存器中；如果内存中的字的顺序于在寄存器中的不一样，见<code>REG_WORDS_BIG_ENDIAN</code> 。 该宏不需要为一个常量。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LIBGCC2_WORDS_BIG_ENDIAN</b><var><a name="index-LIBGCC2_005fWORDS_005fBIG_005fENDIAN-3821"></a></var><br>
<blockquote><!-- Define this macro if @code{WORDS_BIG_ENDIAN} is not constant.  This must be a -->
     <!-- constant value with the same meaning as @code{WORDS_BIG_ENDIAN}, which will be -->
     <!-- used only when compiling @file{libgcc2.c}.  Typically the value will be set -->
     <!-- based on preprocessor defines. -->
      <p>定义该宏如果<code>WORDS_BIG_ENDIAN</code>不是常量。该宏必须为一个常量值，其与<code>WORDS_BIG_ENDIAN</code>的具有相同的含义，并只用于编译<samp><span class="file">libgcc2.c</span></samp>的时候。通常该值会根据预处理器定义来设置。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REG_WORDS_BIG_ENDIAN</b><var><a name="index-REG_005fWORDS_005fBIG_005fENDIAN-3822"></a></var><br>
<blockquote><p>On some machines, the order of words in a multiword object differs between
registers in memory.  In such a situation, define this macro to describe
the order of words in a register.  The macro <code>WORDS_BIG_ENDIAN</code> controls
the order of words in memory. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FLOAT_WORDS_BIG_ENDIAN</b><var><a name="index-FLOAT_005fWORDS_005fBIG_005fENDIAN-3823"></a></var><br>
<blockquote><!-- Define this macro to have the value 1 if @code{DFmode}, @code{XFmode} or -->
     <!-- @code{TFmode} floating point numbers are stored in memory with the word -->
     <!-- containing the sign bit at the lowest address; otherwise define it to -->
     <!-- have the value 0.  This macro need not be a constant. -->
      <p>定义该宏值为1，如果<code>DFmode</code>, <code>XFmode</code>或<code>TFmode</code>浮点数被存储在内存中，并且包含符号位的字位于最低地址；否则值为0。该宏不需要为一个常量。

     <!-- You need not define this macro if the ordering is the same as for -->
     <!-- multi-word integers. -->
      <p>你不需要定义该宏，如果顺序与多字整数相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BITS_PER_UNIT</b><var><a name="index-BITS_005fPER_005fUNIT-3824"></a></var><br>
<blockquote><!-- Define this macro to be the number of bits in an addressable storage -->
     <!-- unit (byte).  If you do not define this macro the default is 8. -->
      <p>定义该宏为一个可寻址的存储单元（字节）中的位数。如果没有定义，缺省为8。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BITS_PER_WORD</b><var><a name="index-BITS_005fPER_005fWORD-3825"></a></var><br>
<blockquote><!-- Number of bits in a word.  If you do not define this macro, the default -->
     <!-- is @code{BITS_PER_UNIT * UNITS_PER_WORD}. -->
      <p>字的位数。如果没有定义，缺省为<code>BITS_PER_UNIT * UNITS_PER_WORD</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_BITS_PER_WORD</b><var><a name="index-MAX_005fBITS_005fPER_005fWORD-3826"></a></var><br>
<blockquote><!-- Maximum number of bits in a word.  If this is undefined, the default is -->
     <!-- @code{BITS_PER_WORD}.  Otherwise, it is the constant value that is the -->
     <!-- largest value that @code{BITS_PER_WORD} can have at run-time. -->
      <p>字的最大位数。如果没有定义，缺省为<code>BITS_PER_WORD</code>。否则其为一个常量，为<code>BITS_PER_WORD</code>在运行时可以具有的最大值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>UNITS_PER_WORD</b><var><a name="index-UNITS_005fPER_005fWORD-3827"></a></var><br>
<blockquote><!-- Number of storage units in a word; normally the size of a general-purpose -->
     <!-- register, a power of two from 1 or 8. -->
      <p>字中的存储单元数；通常为通用目的寄存器的大小，2的1到8次幂。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MIN_UNITS_PER_WORD</b><var><a name="index-MIN_005fUNITS_005fPER_005fWORD-3828"></a></var><br>
<blockquote><!-- Minimum number of units in a word.  If this is undefined, the default is -->
     <!-- @code{UNITS_PER_WORD}.  Otherwise, it is the constant value that is the -->
     <!-- smallest value that @code{UNITS_PER_WORD} can have at run-time. -->
      <p>字中的最小存储单元数。如果没有定义，缺省为<code>UNITS_PER_WORD</code>。否则，其为一个常量，为<code>UNITS_PER_WORD</code>在运行时可以具有的最小值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>UNITS_PER_SIMD_WORD</b> (<var>mode</var>)<var><a name="index-UNITS_005fPER_005fSIMD_005fWORD-3829"></a></var><br>
<blockquote><!-- Number of units in the vectors that the vectorizer can produce for -->
     <!-- scalar mode @var{mode}.  The default is equal to @code{UNITS_PER_WORD}, -->
     <!-- because the vectorizer can do some transformations even in absence of -->
     <!-- specialized @acronym{SIMD} hardware. -->
      <p>向量化可以产生的向量的单元数。缺省等于<code>UNITS_PER_WORD</code>，因为向量化可以在即使没有专门的<acronym>SIMD</acronym>硬件的情况下做一些转换。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>POINTER_SIZE</b><var><a name="index-POINTER_005fSIZE-3830"></a></var><br>
<blockquote><!-- Width of a pointer, in bits.  You must specify a value no wider than the -->
     <!-- width of @code{Pmode}.  If it is not equal to the width of @code{Pmode}, -->
     <!-- you must define @code{POINTERS_EXTEND_UNSIGNED}.  If you do not specify -->
     <!-- a value the default is @code{BITS_PER_WORD}. -->
      <p>指针的宽度，位数。必须指定不比<code>Pmode</code>宽的值。如果其不等于<code>Pmode</code>的宽度，则必须定义<code>POINTERS_EXTEND_UNSIGNED</code>。如果没有指定一个值，则缺省为<code>BITS_PER_WORD</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>POINTERS_EXTEND_UNSIGNED</b><var><a name="index-POINTERS_005fEXTEND_005fUNSIGNED-3831"></a></var><br>
<blockquote><!-- A C expression that determines how pointers should be extended from -->
     <!-- @code{ptr_mode} to either @code{Pmode} or @code{word_mode}.  It is -->
     <!-- greater than zero if pointers should be zero-extended, zero if they -->
     <!-- should be sign-extended, and negative if some other sort of conversion -->
     <!-- is needed.  In the last case, the extension is done by the target's -->
     <!-- @code{ptr_extend} instruction. -->
      <p>一个C表达式，用来确定指针应该如何从<code>ptr_mode</code>扩展为<code>Pmode</code>或者<code>word_mode</code>。如果指针应该被零扩展，则其比0大，如果应该被符号扩展则为0，如果需要其它转换方式则为负。对于最后一种情况，扩展通过target的<code>ptr_extend</code>指令来完成。

     <!-- You need not define this macro if the @code{ptr_mode}, @code{Pmode} -->
     <!-- and @code{word_mode} are all the same width. -->
      <p>你不需要定义该宏，如果<code>ptr_mode</code>, <code>Pmode</code>和<code>word_mode</code>都为相同的宽度。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PROMOTE_MODE</b> (<var>m, unsignedp, type</var>)<var><a name="index-PROMOTE_005fMODE-3832"></a></var><br>
<blockquote><!-- A macro to update @var{m} and @var{unsignedp} when an object whose type -->
     <!-- is @var{type} and which has the specified mode and signedness is to be -->
     <!-- stored in a register.  This macro is only called when @var{type} is a -->
     <!-- scalar type. -->
      <p>用来更新<var>m</var>和<var>unsignedp</var>，当一个类型为<var>type</var>并且具有特定的机器模式的对象要被存储到寄存器中时。该宏只在<var>type</var>为一个标量类型时才被调用。

     <!-- On most RISC machines, which only have operations that operate on a full -->
     <!-- register, define this macro to set @var{m} to @code{word_mode} if -->
     <!-- @var{m} is an integer mode narrower than @code{BITS_PER_WORD}.  In most -->
     <!-- cases, only integer modes should be widened because wider-precision -->
     <!-- floating-point operations are usually more expensive than their narrower -->
     <!-- counterparts. -->
      <p>在大多数RISC机器上，只有作用于在整个寄存器上的运算，定义该宏将<var>m</var>设为为<code>word_mode</code>，如果<var>m</var>为一个比<code>BITS_PER_WORD</code>窄的整数模式。在大多数情况下，只有整数模式应该被加宽，因为宽精度的浮点运算通常比相应的窄精度的运算代价要更高。

     <!-- For most machines, the macro definition does not change @var{unsignedp}. -->
     <!-- However, some machines, have instructions that preferentially handle -->
     <!-- either signed or unsigned quantities of certain modes.  For example, on -->
     <!-- the DEC Alpha, 32-bit loads from memory and 32-bit add instructions -->
     <!-- sign-extend the result to 64 bits.  On such machines, set -->
     <!-- @var{unsignedp} according to which kind of extension is more efficient. -->
      <p>大多数机器，宏定义不改变<var>unsignedp</var>。然而，一些机器具有优先处理特定模式的有符号或者无符号的指令。例如，在DEC Alpha上，32位load和32位add指令会将结果有符号扩展为64位。在这样的机器上，根据扩展的类型来设置<var>unsignedp</var>会更加有效。

     <!-- Do not define this macro if it would never modify @var{m}. -->
      <p>如果从来不会修改<var>m</var>，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: enum machine_mode <b>TARGET_PROMOTE_FUNCTION_MODE</b> (<var>const_tree type, enum machine_mode mode, int *punsignedp, const_tree funtype, int for_return</var>)<var><a name="index-TARGET_005fPROMOTE_005fFUNCTION_005fMODE-3833"></a></var><br>
<blockquote><p>Like <code>PROMOTE_MODE</code>, but it is applied to outgoing function arguments or
function return values.  The target hook should return the new mode
and possibly change <code>*</code><var>punsignedp</var> if the promotion should
change signedness.  This function is called only for scalar <em>or
pointer</em> types.

      <p><var>for_return</var> allows to distinguish the promotion of arguments and
return values.  If it is <code>1</code>, a return value is being promoted and
<code>TARGET_FUNCTION_VALUE</code> must perform the same promotions done here. 
If it is <code>2</code>, the returned mode should be that of the register in
which an incoming parameter is copied, or the outgoing result is computed;
then the hook should return the same mode as <code>promote_mode</code>, though
the signedness may be different.

      <p><var>type</var> can be NULL when promoting function arguments of libcalls.

      <p>The default is to not promote arguments and return values.  You can
also define the hook to <code>default_promote_function_mode_always_promote</code>
if you would like to apply the same rules given by <code>PROMOTE_MODE</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PARM_BOUNDARY</b><var><a name="index-PARM_005fBOUNDARY-3834"></a></var><br>
<blockquote><!-- Normal alignment required for function parameters on the stack, in -->
     <!-- bits.  All stack parameters receive at least this much alignment -->
     <!-- regardless of data type.  On most machines, this is the same as the -->
     <!-- size of an integer. -->
      <p>函数参数在栈上的对齐方式，位数。所有栈参数都接受这样的对齐，而不论数据类型是什么。在大多数机器上，这与整数的大小相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_BOUNDARY</b><var><a name="index-STACK_005fBOUNDARY-3835"></a></var><br>
<blockquote><!-- Define this macro to the minimum alignment enforced by hardware for the -->
     <!-- stack pointer on this machine.  The definition is a C expression for the -->
     <!-- desired alignment (measured in bits).  This value is used as a default -->
     <!-- if @code{PREFERRED_STACK_BOUNDARY} is not defined.  On most machines, -->
     <!-- this should be the same as @code{PARM_BOUNDARY}. -->
      <p>定义该宏为硬件要求的在该机器上的栈指针的最小对齐。定义为一个C表达式，为所要的对齐（位数）。该值作为缺省值使用，如果没有定义<code>PREFERRED_STACK_BOUNDARY</code>。在大多数机器上，这应该与<code>PARM_BOUNDARY</code>相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PREFERRED_STACK_BOUNDARY</b><var><a name="index-PREFERRED_005fSTACK_005fBOUNDARY-3836"></a></var><br>
<blockquote><!-- Define this macro if you wish to preserve a certain alignment for the -->
     <!-- stack pointer, greater than what the hardware enforces.  The definition -->
     <!-- is a C expression for the desired alignment (measured in bits).  This -->
     <!-- macro must evaluate to a value equal to or larger than -->
     <!-- @code{STACK_BOUNDARY}. -->
      <p>定义该宏，如果你希望对栈指针维持一个特定的对齐，大于硬件要求的对齐。定义为一个C表达式，为所要的对齐（位数）。该宏必须等于或大于<code>STACK_BOUNDARY</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INCOMING_STACK_BOUNDARY</b><var><a name="index-INCOMING_005fSTACK_005fBOUNDARY-3837"></a></var><br>
<blockquote><!-- Define this macro if the incoming stack boundary may be different -->
     <!-- from @code{PREFERRED_STACK_BOUNDARY}.  This macro must evaluate -->
     <!-- to a value equal to or larger than @code{STACK_BOUNDARY}. -->
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_BOUNDARY</b><var><a name="index-FUNCTION_005fBOUNDARY-3838"></a></var><br>
<blockquote><!-- Alignment required for a function entry point, in bits. -->
      <p>函数入口点所需的对齐位数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BIGGEST_ALIGNMENT</b><var><a name="index-BIGGEST_005fALIGNMENT-3839"></a></var><br>
<blockquote><!-- Biggest alignment that any data type can require on this machine, in -->
     <!-- bits.  Note that this is not the biggest alignment that is supported, -->
     <!-- just the biggest alignment that, when violated, may cause a fault. -->
      <p>该机器上任何数据类型可以需要的最大对齐位数。注意这不是所支持的最大对齐，而是如果违反该对齐则可能会造成错误。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MALLOC_ABI_ALIGNMENT</b><var><a name="index-MALLOC_005fABI_005fALIGNMENT-3840"></a></var><br>
<blockquote><p>Alignment, in bits, a C conformant malloc implementation has to
provide.  If not defined, the default value is <code>BITS_PER_WORD</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ATTRIBUTE_ALIGNED_VALUE</b><var><a name="index-ATTRIBUTE_005fALIGNED_005fVALUE-3841"></a></var><br>
<blockquote><p>Alignment used by the <code>__attribute__ ((aligned))</code> construct.  If
not defined, the default value is <code>BIGGEST_ALIGNMENT</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MINIMUM_ATOMIC_ALIGNMENT</b><var><a name="index-MINIMUM_005fATOMIC_005fALIGNMENT-3842"></a></var><br>
<blockquote><!-- If defined, the smallest alignment, in bits, that can be given to an -->
     <!-- object that can be referenced in one operation, without disturbing any -->
     <!-- nearby object.  Normally, this is @code{BITS_PER_UNIT}, but may be larger -->
     <!-- on machines that don't have byte or half-word store operations. -->
      <p>如果被定义，则为最小对齐位数，可以分给一个对象并且在一个操作中被应用，而不需要干扰任何附近的对象。通常为<code>BITS_PER_UNIT</code>，但在没有字节或半字的存储运算的机器上可以更大些。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BIGGEST_FIELD_ALIGNMENT</b><var><a name="index-BIGGEST_005fFIELD_005fALIGNMENT-3843"></a></var><br>
<blockquote><!-- Biggest alignment that any structure or union field can require on this -->
     <!-- machine, in bits.  If defined, this overrides @code{BIGGEST_ALIGNMENT} for -->
     <!-- structure and union fields only, unless the field alignment has been set -->
     <!-- by the @code{__attribute__ ((aligned (@var{n})))} construct. -->
      <p>任何结构体或者联合体域在该机器上需要的最大对齐。如果被定义，这将只覆盖结构体和联合体的域的<code>BIGGEST_ALIGNMENT</code>，除非域对齐已经通过<code>__attribute__ ((aligned (</code><var>n</var><code>)))</code>设置。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ADJUST_FIELD_ALIGN</b> (<var>field, computed</var>)<var><a name="index-ADJUST_005fFIELD_005fALIGN-3844"></a></var><br>
<blockquote><!-- An expression for the alignment of a structure field @var{field} if the -->
     <!-- alignment computed in the usual way (including applying of -->
     <!-- @code{BIGGEST_ALIGNMENT} and @code{BIGGEST_FIELD_ALIGNMENT} to the -->
     <!-- alignment) is @var{computed}.  It overrides alignment only if the -->
     <!-- field alignment has not been set by the -->
     <!-- @code{__attribute__ ((aligned (@var{n})))} construct. -->
      <p>一个表达式，为结构体域<var>field</var>的对齐方式，如果对齐方式是按照通常方式计算（包括应用<code>BIGGEST_ALIGNMENT</code>和<code>BIGGEST_FIELD_ALIGNMENT</code>）。其只覆盖没有通过<code>__attribute__ ((aligned (</code><var>n</var><code>)))</code>设置的域。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_STACK_ALIGNMENT</b><var><a name="index-MAX_005fSTACK_005fALIGNMENT-3845"></a></var><br>
<blockquote><p>Biggest stack alignment guaranteed by the backend.  Use this macro
to specify the maximum alignment of a variable on stack.

      <p>If not defined, the default value is <code>STACK_BOUNDARY</code>.

     <!-- FIXME: The default should be @code{PREFERRED_STACK_BOUNDARY}. -->
     <!-- But the fix for PR 32893 indicates that we can only guarantee -->
     <!-- maximum stack alignment on stack up to @code{STACK_BOUNDARY}, not -->
     <!-- @code{PREFERRED_STACK_BOUNDARY}, if stack alignment isn't supported. -->
      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_OFILE_ALIGNMENT</b><var><a name="index-MAX_005fOFILE_005fALIGNMENT-3846"></a></var><br>
<blockquote><!-- Biggest alignment supported by the object file format of this machine. -->
     <!-- Use this macro to limit the alignment which can be specified using the -->
     <!-- @code{__attribute__ ((aligned (@var{n})))} construct.  If not defined, -->
     <!-- the default value is @code{BIGGEST_ALIGNMENT}. -->
      <p>由该机器的目标文件格式所支持的最大对齐。使用该宏来限制可以使用<code>__attribute__ ((aligned (</code><var>n</var><code>)))</code>结构来指定的对齐。如果没有定义，则缺省值为<code>BIGGEST_ALIGNMENT</code>。

     <!-- On systems that use ELF, the default (in @file{config/elfos.h}) is -->
     <!-- the largest supported 32-bit ELF section alignment representable on -->
     <!-- a 32-bit host e.g. @samp{(((unsigned HOST_WIDEST_INT) 1 << 28) * 8)}. -->
     <!-- On 32-bit ELF the largest supported section alignment in bits is -->
     <!-- @samp{(0x80000000 * 8)}, but this is not representable on 32-bit hosts. -->
      <p>在使用ELF的系统上，缺省（在<samp><span class="file">config/elfos.h</span></samp>中）为在32位host上可以表示的32位ELF section对齐，即&lsquo;<samp><span class="samp">(((unsigned HOST_WIDEST_INT) 1 &lt;&lt; 28) * 8)</span></samp>&rsquo;。在32位ELF上，最大支持的section对齐位数是&lsquo;<samp><span class="samp">(0x80000000 * 8)</span></samp>&rsquo;，但这在32位host上无法表示。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DATA_ALIGNMENT</b> (<var>type, basic-align</var>)<var><a name="index-DATA_005fALIGNMENT-3847"></a></var><br>
<blockquote><!-- If defined, a C expression to compute the alignment for a variable in -->
     <!-- the static store.  @var{type} is the data type, and @var{basic-align} is -->
     <!-- the alignment that the object would ordinarily have.  The value of this -->
     <!-- macro is used instead of that alignment to align the object. -->
      <p>如果定义，则为一个C表达式，来计算在静态存储中的变量的对齐。<var>type</var>为数据类型，<var>basic-align</var>为对象通常具有的对齐。该宏的值被用于替代那个对齐，并应用的对象上。

     <!-- If this macro is not defined, then @var{basic-align} is used. -->
      <p>如果该宏没有定义，则使用<var>basic-align</var>。

      <p><a name="index-strcpy-3848"></a><!-- One use of this macro is to increase alignment of medium-size data to -->
<!-- make it all fit in fewer cache lines.  Another is to cause character -->
<!-- arrays to be word-aligned so that @code{strcpy} calls that copy -->
<!-- constants to character arrays can be done inline. -->
该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。另一种用法是使得字符数组按照字对齐，这样<code>strcpy</code>调用可以通过内联方式完成。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CONSTANT_ALIGNMENT</b> (<var>constant, basic-align</var>)<var><a name="index-CONSTANT_005fALIGNMENT-3849"></a></var><br>
<blockquote><!-- If defined, a C expression to compute the alignment given to a constant -->
     <!-- that is being placed in memory.  @var{constant} is the constant and -->
     <!-- @var{basic-align} is the alignment that the object would ordinarily -->
     <!-- have.  The value of this macro is used instead of that alignment to -->
     <!-- align the object. -->
      <p>如果定义，为一个C表达式，来计算放在内存中的常量的对齐。<var>constant</var>为常量，<var>basic-align</var>为该对象通常具有的对齐。该宏的值被用于替代那个对齐，并应用的对象上。

     <!-- If this macro is not defined, then @var{basic-align} is used. -->
      <p>如果该宏没有定义，则使用<var>basic-align</var>。

     <!-- The typical use of this macro is to increase alignment for string -->
     <!-- constants to be word aligned so that @code{strcpy} calls that copy -->
     <!-- constants can be done inline. -->
      <p>该宏的典型用法为增加字符串常量的对齐，使其为字对齐，这样<code>strcpy</code>调用可以通过内联方式完成。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LOCAL_ALIGNMENT</b> (<var>type, basic-align</var>)<var><a name="index-LOCAL_005fALIGNMENT-3850"></a></var><br>
<blockquote><!-- If defined, a C expression to compute the alignment for a variable in -->
     <!-- the local store.  @var{type} is the data type, and @var{basic-align} is -->
     <!-- the alignment that the object would ordinarily have.  The value of this -->
     <!-- macro is used instead of that alignment to align the object. -->
      <p>如果定义，为一个C表达式，来计算在局部存储中的对象的对齐。<var>type</var>为数据类型，<var>basic-align</var>为对象通常的对齐。该宏的值被用于替代那个对齐，并应用的对象上。

     <!-- If this macro is not defined, then @var{basic-align} is used. -->
      <p>如果该宏没有定义，则使用<var>basic-align</var>。

     <!-- One use of this macro is to increase alignment of medium-size data to -->
     <!-- make it all fit in fewer cache lines. -->
      <p>该宏的一种用法是增加中等大小数据的对齐，使得可以放在最少的cache line中。

     <!-- If the value of this macro has a type, it should be an unsigned type. -->
      <p>如果该宏的值有类型，它应该是无符号类型。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_SLOT_ALIGNMENT</b> (<var>type, mode, basic-align</var>)<var><a name="index-STACK_005fSLOT_005fALIGNMENT-3851"></a></var><br>
<blockquote><p>If defined, a C expression to compute the alignment for stack slot. 
<var>type</var> is the data type, <var>mode</var> is the widest mode available,
and <var>basic-align</var> is the alignment that the slot would ordinarily
have.  The value of this macro is used instead of that alignment to
align the slot.

      <p>If this macro is not defined, then <var>basic-align</var> is used when
<var>type</var> is <code>NULL</code>.  Otherwise, <code>LOCAL_ALIGNMENT</code> will
be used.

      <p>This macro is to set alignment of stack slot to the maximum alignment
of all possible modes which the slot may have.

      <p>If the value of this macro has a type, it should be an unsigned type. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LOCAL_DECL_ALIGNMENT</b> (<var>decl</var>)<var><a name="index-LOCAL_005fDECL_005fALIGNMENT-3852"></a></var><br>
<blockquote><p>If defined, a C expression to compute the alignment for a local
variable <var>decl</var>.

      <p>If this macro is not defined, then
<code>LOCAL_ALIGNMENT (TREE_TYPE (</code><var>decl</var><code>), DECL_ALIGN (</code><var>decl</var><code>))</code>
is used.

      <p>One use of this macro is to increase alignment of medium-size data to
make it all fit in fewer cache lines.

      <p>If the value of this macro has a type, it should be an unsigned type. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MINIMUM_ALIGNMENT</b> (<var>exp, mode, align</var>)<var><a name="index-MINIMUM_005fALIGNMENT-3853"></a></var><br>
<blockquote><p>If defined, a C expression to compute the minimum required alignment
for dynamic stack realignment purposes for <var>exp</var> (a type or decl),
<var>mode</var>, assuming normal alignment <var>align</var>.

      <p>If this macro is not defined, then <var>align</var> will be used. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>EMPTY_FIELD_BOUNDARY</b><var><a name="index-EMPTY_005fFIELD_005fBOUNDARY-3854"></a></var><br>
<blockquote><!-- Alignment in bits to be given to a structure bit-field that follows an -->
     <!-- empty field such as @code{int : 0;}. -->
      <p>允许像<code>int : 0;</code>；这样的空域的结构体位域的对齐位数。

     <!-- If @code{PCC_BITFIELD_TYPE_MATTERS} is true, it overrides this macro. -->
      <p>如果<code>PCC_BITFIELD_TYPE_MATTERS</code>为真，则其覆盖该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STRUCTURE_SIZE_BOUNDARY</b><var><a name="index-STRUCTURE_005fSIZE_005fBOUNDARY-3855"></a></var><br>
<blockquote><!-- Number of bits which any structure or union's size must be a multiple of. -->
     <!-- Each structure or union's size is rounded up to a multiple of this. -->
      <p>任何结构体或联合体的大小必须为该位数的倍数。每个结构体或联合体的大小都将被舍入到该位数的一个倍数。

     <!-- If you do not define this macro, the default is the same as -->
     <!-- @code{BITS_PER_UNIT}. -->
      <p>如果没有定义该宏，则缺省与<code>BITS_PER_UNIT</code>相同。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STRICT_ALIGNMENT</b><var><a name="index-STRICT_005fALIGNMENT-3856"></a></var><br>
<blockquote><!-- Define this macro to be the value 1 if instructions will fail to work -->
     <!-- if given data not on the nominal alignment.  If instructions will merely -->
     <!-- go slower in that case, define this macro as 0. -->
      <p>定义该宏值为1，如果给定数据不在通常对齐方式上，则指令无法工作。如果对于这种情况指令只不过是变慢，则定义该宏为0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PCC_BITFIELD_TYPE_MATTERS</b><var><a name="index-PCC_005fBITFIELD_005fTYPE_005fMATTERS-3857"></a></var><br>
<blockquote><!-- Define this if you wish to imitate the way many other C compilers handle -->
     <!-- alignment of bit-fields and the structures that contain them. -->
      <p>定义该宏，如果你希望仿效许多其它C编译器处理位域和包含它们的结构体的对齐方式。

     <!-- The behavior is that the type written for a named bit-field (@code{int}, -->
     <!-- @code{short}, or other integer type) imposes an alignment for the entire -->
     <!-- structure, as if the structure really did contain an ordinary field of -->
     <!-- that type.  In addition, the bit-field is placed within the structure so -->
     <!-- that it would fit within such a field, not crossing a boundary for it. -->
      <p>该行为是书写为命名位域（<code>int</code>,<code>short</code>或其它整数类型）的类型被实施用于整个结构体的对齐，就好像结构体包含了一个该类型的普通的域。另外，位域放在结构体中，使得其将适合这样的域，而不会跨越边界。

     <!-- Thus, on most machines, a named bit-field whose type is written as -->
     <!-- @code{int} would not cross a four-byte boundary, and would force -->
     <!-- four-byte alignment for the whole structure.  (The alignment used may -->
     <!-- not be four bytes; it is controlled by the other alignment parameters.) -->
      <p>这样，大多数机器上，书写为<code>int</code>的命名位域将不会跨越一个四字节的边界，并将使得整个结构体为四字节对齐。（可能不使用四字节对齐；其由其它对齐参数控制。）

     <!-- An unnamed bit-field will not affect the alignment of the containing -->
     <!-- structure. -->
      <p>一个没有命名的位域将不会影响包含结构体的对齐。

     <!-- If the macro is defined, its definition should be a C expression; -->
     <!-- a nonzero value for the expression enables this behavior. -->
      <p>如果定义了该宏，则其定义为一个C表达式；该表达式的非0值会使用这样方式。

     <!-- Note that if this macro is not defined, or its value is zero, some -->
     <!-- bit-fields may cross more than one alignment boundary.  The compiler can -->
     <!-- support such references if there are @samp{insv}, @samp{extv}, and -->
     <!-- @samp{extzv} insns that can directly reference memory. -->
      <p>注意如果该宏没有定义，或者其值为0，则一些位域可能跨越多于一个的对齐边界。编译器可以支持这种引用，如果有&lsquo;<samp><span class="samp">insv</span></samp>&rsquo;, &lsquo;<samp><span class="samp">extv</span></samp>&rsquo;和&lsquo;<samp><span class="samp">extzv</span></samp>&rsquo; insns可以直接引用内存。

     <!-- The other known way of making bit-fields work is to define -->
     <!-- @code{STRUCTURE_SIZE_BOUNDARY} as large as @code{BIGGEST_ALIGNMENT}. -->
     <!-- Then every structure can be accessed with fullwords. -->
      <p>其它已知的可以使位域工作的的方式为定义<code>STRUCTURE_SIZE_BOUNDARY</code>和<code>BIGGEST_ALIGNMENT</code>一样大。

     <!-- Unless the machine has bit-field instructions or you define -->
     <!-- @code{STRUCTURE_SIZE_BOUNDARY} that way, you must define -->
     <!-- @code{PCC_BITFIELD_TYPE_MATTERS} to have a nonzero value. -->
      <p>除非机器具有位域指令或者你按照那种方式定义了<code>STRUCTURE_SIZE_BOUNDARY</code>，否则你必须定义<code>PCC_BITFIELD_TYPE_MATTERS</code>具有非0值。

     <!-- If your aim is to make GCC use the same conventions for laying out -->
     <!-- bit-fields as are used by another compiler, here is how to investigate -->
     <!-- what the other compiler does.  Compile and run this program: -->
      <p>如果你的目标是使得GCC使用与其它编译器相同的约定来布局位域，则这里有一种方式可以调查其它编译器是如何做的。编译运行该程序：

     <pre class="smallexample">          struct foo1
          {
            char x;
            char :0;
            char y;
          };
          
          struct foo2
          {
            char x;
            int :0;
            char y;
          };
          
          main ()
          {
            printf ("Size of foo1 is %d\n",
                    sizeof (struct foo1));
            printf ("Size of foo2 is %d\n",
                    sizeof (struct foo2));
            exit (0);
          }
</pre>
      <!-- If this prints 2 and 5, then the compiler's behavior is what you would -->
     <!-- get from @code{PCC_BITFIELD_TYPE_MATTERS}. -->
      <p>如果其打印2和5，则编译器的行为就是你通过<code>PCC_BITFIELD_TYPE_MATTERS</code>获得的效果。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BITFIELD_NBYTES_LIMITED</b><var><a name="index-BITFIELD_005fNBYTES_005fLIMITED-3858"></a></var><br>
<blockquote><!-- Like @code{PCC_BITFIELD_TYPE_MATTERS} except that its effect is limited -->
     <!-- to aligning a bit-field within the structure. -->
      <p>跟<code>PCC_BITFIELD_TYPE_MATTERS</code>相似，除了它只影响结构体中的位域的对齐。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_ALIGN_ANON_BITFIELD</b> (<var>void</var>)<var><a name="index-TARGET_005fALIGN_005fANON_005fBITFIELD-3859"></a></var><br>
<blockquote><!-- When @code{PCC_BITFIELD_TYPE_MATTERS} is true this hook will determine -->
     <!-- whether unnamed bitfields affect the alignment of the containing -->
     <!-- structure.  The hook should return true if the structure should inherit -->
     <!-- the alignment requirements of an unnamed bitfield's type. -->
      <p>当<code>PCC_BITFIELD_TYPE_MATTERS</code>为真，该钩子将确定未命名位域是否要影响包含它的结构体的对齐。钩子应该返回真，如果结构体应该继承未命名位域的类型所要求的对齐。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_NARROW_VOLATILE_BITFIELD</b> (<var>void</var>)<var><a name="index-TARGET_005fNARROW_005fVOLATILE_005fBITFIELD-3860"></a></var><br>
<blockquote><!-- This target hook should return @code{true} if accesses to volatile bitfields -->
     <!-- should use the narrowest mode possible.  It should return @code{false} if -->
     <!-- these accesses should use the bitfield container type. -->
      <p>该target钩子应该返回<code>true</code>，如果访问volatile位域应该尽可能使用最窄的机器模式。其应该返回<code>false</code>，如果这些访问应该使用位域的容器的类型。

     <!-- The default is @code{!TARGET_STRICT_ALIGN}. -->
      <p>缺省为<code>!TARGET_STRICT_ALIGN</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MEMBER_TYPE_FORCES_BLK</b> (<var>field, mode</var>)<var><a name="index-MEMBER_005fTYPE_005fFORCES_005fBLK-3861"></a></var><br>
<blockquote><!-- Return 1 if a structure or array containing @var{field} should be accessed using -->
     <!-- @code{BLKMODE}. -->
      <p>返回1，如果一个包含<var>field</var>的结构体或者数组应该使用<code>BLKMODE</code>模式来访问。

     <!-- If @var{field} is the only field in the structure, @var{mode} is its -->
     <!-- mode, otherwise @var{mode} is VOIDmode.  @var{mode} is provided in the -->
     <!-- case where structures of one field would require the structure's mode to -->
     <!-- retain the field's mode. -->
      <p>如果<var>field</var>为结构体中唯一的域，则<var>mode</var>为它的机器模式，否则<var>mode</var>为VOIDmode。

     <!-- Normally, this is not needed. -->
      <p>通常，不需要该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ROUND_TYPE_ALIGN</b> (<var>type, computed, specified</var>)<var><a name="index-ROUND_005fTYPE_005fALIGN-3862"></a></var><br>
<blockquote><!-- Define this macro as an expression for the alignment of a type (given -->
     <!-- by @var{type} as a tree node) if the alignment computed in the usual -->
     <!-- way is @var{computed} and the alignment explicitly specified was -->
     <!-- @var{specified}. -->
      <p>定义该宏为一个表达式，为一个类型（由作为树节点的<var>type</var>给定）的对齐，如果按照通常方式计算的对齐方式为<var>computed</var>并且显示指定的对齐方式为<var>specified</var>。

     <!-- The default is to use @var{specified} if it is larger; otherwise, use -->
     <!-- the smaller of @var{computed} and @code{BIGGEST_ALIGNMENT} -->
      <p>缺省是使用<var>specified</var>，如果其更大；否则使用<var>computed</var>和<code>BIGGEST_ALIGNMENT</code>中较小的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MAX_FIXED_MODE_SIZE</b><var><a name="index-MAX_005fFIXED_005fMODE_005fSIZE-3863"></a></var><br>
<blockquote><!-- An integer expression for the size in bits of the largest integer -->
     <!-- machine mode that should actually be used.  All integer machine modes of -->
     <!-- this size or smaller can be used for structures and unions with the -->
     <!-- appropriate sizes.  If this macro is undefined, @code{GET_MODE_BITSIZE -->
     <!-- (DImode)} is assumed. -->
      <p>一个整数表达式，为实际应该被使用的最大的整数机器模式的位数。所有该大小或者更小一些的整数机器模式都可以用于结构体和联合体。如果哦没有定义该宏，则假设为<code>GET_MODE_BITSIZE (DImode)</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_SAVEAREA_MODE</b> (<var>save_level</var>)<var><a name="index-STACK_005fSAVEAREA_005fMODE-3864"></a></var><br>
<blockquote><!-- If defined, an expression of type @code{enum machine_mode} that -->
     <!-- specifies the mode of the save area operand of a -->
     <!-- @code{save_stack_@var{level}} named pattern (@pxref{Standard Names}). -->
     <!-- @var{save_level} is one of @code{SAVE_BLOCK}, @code{SAVE_FUNCTION}, or -->
     <!-- @code{SAVE_NONLOCAL} and selects which of the three named patterns is -->
     <!-- having its mode specified. -->
      <p>如果定义，则为一个<code>enum machine_mode</code>类型的表达式，指定名为<code>save_stack_</code><var>level</var>的指令模式（参见<a href="Standard-Names.html#Standard-Names">Standard Names</a>）的save区域操作数的机器模式。
<var>save_level</var>为<code>SAVE_BLOCK</code>, <code>SAVE_FUNCTION</code>或<code>SAVE_NONLOCAL</code>中之一。

     <!-- You need not define this macro if it always returns @code{Pmode}.  You -->
     <!-- would most commonly define this macro if the -->
     <!-- @code{save_stack_@var{level}} patterns need to support both a 32- and a -->
     <!-- 64-bit mode. -->
      <p>你不需要定义该宏，如果其总是返回<code>Pmode</code>。你通常将会定义该宏，如果<code>save_stack_</code><var>level</var>指令模式需要同时支持32和64位机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STACK_SIZE_MODE</b><var><a name="index-STACK_005fSIZE_005fMODE-3865"></a></var><br>
<blockquote><!-- If defined, an expression of type @code{enum machine_mode} that -->
     <!-- specifies the mode of the size increment operand of an -->
     <!-- @code{allocate_stack} named pattern (@pxref{Standard Names}). -->
      <p>如果定义，为一个<code>enum machine_mode</code>类型的表达式，指定名为<code>allocate_stack</code>的指令模式（参见<a href="Standard-Names.html#Standard-Names">Standard Names</a>）的size increment操作数的机器模式。

     <!-- You need not define this macro if it always returns @code{word_mode}. -->
     <!-- You would most commonly define this macro if the @code{allocate_stack} -->
     <!-- pattern needs to support both a 32- and a 64-bit mode. -->
      <p>你不需要定义该宏，如果其总是返回<code>word_mode</code>。你通常将会定义该宏，如果<code>allocate_stack</code>指令模式需要同时支持32和64位机器模式。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: enum machine_mode <b>TARGET_LIBGCC_CMP_RETURN_MODE</b> (<var>void</var>)<var><a name="index-TARGET_005fLIBGCC_005fCMP_005fRETURN_005fMODE-3866"></a></var><br>
<blockquote><!-- This target hook should return the mode to be used for the return value -->
     <!-- of compare instructions expanded to libgcc calls.  If not defined -->
     <!-- @code{word_mode} is returned which is the right choice for a majority of -->
     <!-- targets. -->
      <p>该target钩子应该返回扩展为libgcc调用的比较指令的返回值的机器模式。如果没有定义，则返回<code>word_mode</code>，其对于大多数target是正确的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: enum machine_mode <b>TARGET_LIBGCC_SHIFT_COUNT_MODE</b> (<var>void</var>)<var><a name="index-TARGET_005fLIBGCC_005fSHIFT_005fCOUNT_005fMODE-3867"></a></var><br>
<blockquote><!-- This target hook should return the mode to be used for the shift count operand -->
     <!-- of shift instructions expanded to libgcc calls.  If not defined -->
     <!-- @code{word_mode} is returned which is the right choice for a majority of -->
     <!-- targets. -->
      <p>该target钩子应该返回扩展为libgcc调用的移位指令的shift count操作数的机器模式。如果没有定义，则返回<code>word_mode</code>，其对于大多数target是正确的。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: enum machine_mode <b>TARGET_UNWIND_WORD_MODE</b> (<var>void</var>)<var><a name="index-TARGET_005fUNWIND_005fWORD_005fMODE-3868"></a></var><br>
<blockquote><p>Return machine mode to be used for <code>_Unwind_Word</code> type. 
The default is to use <code>word_mode</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ROUND_TOWARDS_ZERO</b><var><a name="index-ROUND_005fTOWARDS_005fZERO-3869"></a></var><br>
<blockquote><!-- If defined, this macro should be true if the prevailing rounding -->
     <!-- mode is towards zero. -->
      <p>如果定义，该宏应该为真，如果舍入的模式是朝向0。

     <!-- Defining this macro only affects the way @file{libgcc.a} emulates -->
     <!-- floating-point arithmetic. -->
      <p>定义该宏只影响<samp><span class="file">libgcc.a</span></samp>模拟浮点算术的方式。

     <!-- Not defining this macro is equivalent to returning zero. -->
      <p>不定义该宏，等价于其返回0。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LARGEST_EXPONENT_IS_NORMAL</b> (<var>size</var>)<var><a name="index-LARGEST_005fEXPONENT_005fIS_005fNORMAL-3870"></a></var><br>
<blockquote><!-- This macro should return true if floats with @var{size} -->
     <!-- bits do not have a NaN or infinity representation, but use the largest -->
     <!-- exponent for normal numbers instead. -->
      <p>该宏应该返回真，如果具有<var>size</var>位数的浮点不具有NaN或无穷的表示，但是使用最大的普通数的指数来替代表示。

     <!-- Defining this macro only affects the way @file{libgcc.a} emulates -->
     <!-- floating-point arithmetic. -->
      <p>定义该宏只影响<samp><span class="file">libgcc.a</span></samp>模拟浮点算术的方式。

     <!-- The default definition of this macro returns false for all sizes. -->
      <p>该宏缺省定义对所有的size都返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_MS_BITFIELD_LAYOUT_P</b> (<var>const_tree record_type</var>)<var><a name="index-TARGET_005fMS_005fBITFIELD_005fLAYOUT_005fP-3871"></a></var><br>
<blockquote><p>This target hook returns <code>true</code> if bit-fields in the given
<var>record_type</var> are to be laid out following the rules of Microsoft
Visual C/C++, namely: (i) a bit-field won't share the same storage
unit with the previous bit-field if their underlying types have
different sizes, and the bit-field will be aligned to the highest
alignment of the underlying types of itself and of the previous
bit-field; (ii) a zero-sized bit-field will affect the alignment of
the whole enclosing structure, even if it is unnamed; except that
(iii) a zero-sized bit-field will be disregarded unless it follows
another bit-field of nonzero size.  If this hook returns <code>true</code>,
other macros that control bit-field layout are ignored.

      <p>When a bit-field is inserted into a packed record, the whole size
of the underlying type is used by one or more same-size adjacent
bit-fields (that is, if its long:3, 32 bits is used in the record,
and any additional adjacent long bit-fields are packed into the same
chunk of 32 bits.  However, if the size changes, a new field of that
size is allocated).  In an unpacked record, this is the same as using
alignment, but not equivalent when packing.

      <p>If both MS bit-fields and &lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo; are used,
the latter will take precedence.  If &lsquo;<samp><span class="samp">__attribute__((packed))</span></samp>&rsquo; is
used on a single field when MS bit-fields are in use, it will take
precedence for that field, but the alignment of the rest of the structure
may affect its placement. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_DECIMAL_FLOAT_SUPPORTED_P</b> (<var>void</var>)<var><a name="index-TARGET_005fDECIMAL_005fFLOAT_005fSUPPORTED_005fP-3872"></a></var><br>
<blockquote><!-- Returns true if the target supports decimal floating point. -->
      <p>返回真，如果target支持十进制浮点。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_FIXED_POINT_SUPPORTED_P</b> (<var>void</var>)<var><a name="index-TARGET_005fFIXED_005fPOINT_005fSUPPORTED_005fP-3873"></a></var><br>
<blockquote><!-- Returns true if the target supports fixed-point arithmetic. -->
      <p>返回真，如果target支持定点算术。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_EXPAND_TO_RTL_HOOK</b> (<var>void</var>)<var><a name="index-TARGET_005fEXPAND_005fTO_005fRTL_005fHOOK-3874"></a></var><br>
<blockquote><!-- This hook is called just before expansion into rtl, allowing the target -->
     <!-- to perform additional initializations or analysis before the expansion. -->
     <!-- For example, the rs6000 port uses it to allocate a scratch stack slot -->
     <!-- for use in copying SDmode values between memory and floating point -->
     <!-- registers whenever the function being expanded has any SDmode -->
     <!-- usage. -->
      <p>该钩子在扩展为rtl之前被调用，允许target在扩展前执行额外的实例化或者分析。例如，rs6000port使用它来分配scratch栈槽，当被扩展的函数具有任何SDmode使用时，用于在内存和浮点寄存器之间复制SDmode值。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_INSTANTIATE_DECLS</b> (<var>void</var>)<var><a name="index-TARGET_005fINSTANTIATE_005fDECLS-3875"></a></var><br>
<blockquote><!-- This hook allows the backend to perform additional instantiations on rtl -->
     <!-- that are not actually in any insns yet, but will be later. -->
      <p>该钩子允许后端执行额外的rtl实例化，这些实际上不存在于任何insn中，但在之后会有。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: const char * <b>TARGET_MANGLE_TYPE</b> (<var>const_tree type</var>)<var><a name="index-TARGET_005fMANGLE_005fTYPE-3876"></a></var><br>
<blockquote><p>If your target defines any fundamental types, or any types your target
uses should be mangled differently from the default, define this hook
to return the appropriate encoding for these types as part of a C++
mangled name.  The <var>type</var> argument is the tree structure representing
the type to be mangled.  The hook may be applied to trees which are
not target-specific fundamental types; it should return <code>NULL</code>
for all such types, as well as arguments it does not recognize.  If the
return value is not <code>NULL</code>, it must point to a statically-allocated
string constant.

      <p>Target-specific fundamental types might be new fundamental types or
qualified versions of ordinary fundamental types.  Encode new
fundamental types as &lsquo;<samp><span class="samp">u&nbsp;</span><var>n</var><span class="samp">&nbsp;</span><var>name</var><span class="samp"><!-- /@w --></span></samp>&rsquo;, where <var>name</var>
is the name used for the type in source code, and <var>n</var> is the
length of <var>name</var> in decimal.  Encode qualified versions of
ordinary types as &lsquo;<samp><span class="samp">U&nbsp;</span><var>n</var><span class="samp">&nbsp;</span><var>name</var><span class="samp">&nbsp;</span><var>code</var><span class="samp"><!-- /@w --></span></samp>&rsquo;, where
<var>name</var> is the name used for the type qualifier in source code,
<var>n</var> is the length of <var>name</var> as above, and <var>code</var> is the
code used to represent the unqualified version of this type.  (See
<code>write_builtin_type</code> in <samp><span class="file">cp/mangle.c</span></samp> for the list of
codes.)  In both cases the spaces are for clarity; do not include any
spaces in your string.

      <p>This hook is applied to types prior to typedef resolution.  If the mangled
name for a particular type depends only on that type's main variant, you
can perform typedef resolution yourself using <code>TYPE_MAIN_VARIANT</code>
before mangling.

      <p>The default version of this hook always returns <code>NULL</code>, which is
appropriate for a target that does not define any new fundamental
types. 
</p></blockquote></div>

<!-- @node Type Layout -->
<!-- @section Layout of Source Language Data Types -->
 </body></html>

