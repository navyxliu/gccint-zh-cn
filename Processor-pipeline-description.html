<html lang="zh">
<head>
<title>Processor pipeline description - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Insn-Attributes.html#Insn-Attributes" title="Insn Attributes">
<link rel="prev" href="Delay-Slots.html#Delay-Slots" title="Delay Slots">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Processor-pipeline-description"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Delay-Slots.html#Delay-Slots">Delay Slots</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Insn-Attributes.html#Insn-Attributes">Insn Attributes</a>
<hr>
</div>

<h4 class="subsection">16.19.8 处理器流水线描述</h4>

<p><a name="index-processor-pipeline-description-3685"></a><a name="index-processor-functional-units-3686"></a><a name="index-instruction-latency-time-3687"></a><a name="index-interlock-delays-3688"></a><a name="index-data-dependence-delays-3689"></a><a name="index-reservation-delays-3690"></a><a name="index-pipeline-hazard-recognizer-3691"></a><a name="index-automaton-based-pipeline-description-3692"></a><a name="index-regular-expressions-3693"></a><a name="index-deterministic-finite-state-automaton-3694"></a><a name="index-automaton-based-scheduler-3695"></a><a name="index-RISC-3696"></a><a name="index-VLIW-3697"></a>
<!-- To achieve better performance, most modern processors -->
<!-- (super-pipelined, superscalar @acronym{RISC}, and @acronym{VLIW} -->
<!-- processors) have many @dfn{functional units} on which several -->
<!-- instructions can be executed simultaneously.  An instruction starts -->
<!-- execution if its issue conditions are satisfied.  If not, the -->
<!-- instruction is stalled until its conditions are satisfied.  Such -->
<!-- @dfn{interlock (pipeline) delay} causes interruption of the fetching -->
<!-- of successor instructions (or demands nop instructions, e.g.@: for some -->
<!-- MIPS processors). -->
<!-- There are two major kinds of interlock delays in modern processors. -->
<!-- The first one is a data dependence delay determining @dfn{instruction -->
<!-- latency time}.  The instruction execution is not started until all -->
<!-- source data have been evaluated by prior instructions (there are more -->
<!-- complex cases when the instruction execution starts even when the data -->
<!-- are not available but will be ready in given time after the -->
<!-- instruction execution start).  Taking the data dependence delays into -->
<!-- account is simple.  The data dependence (true, output, and -->
<!-- anti-dependence) delay between two instructions is given by a -->
<!-- constant.  In most cases this approach is adequate.  The second kind -->
<!-- of interlock delays is a reservation delay.  The reservation delay -->
<!-- means that two instructions under execution will be in need of shared -->
<!-- processors resources, i.e.@: buses, internal registers, and/or -->
<!-- functional units, which are reserved for some time.  Taking this kind -->
<!-- of delay into account is complex especially for modern @acronym{RISC} -->
<!-- processors. -->
<!-- The task of exploiting more processor parallelism is solved by an -->
<!-- instruction scheduler.  For a better solution to this problem, the -->
<!-- instruction scheduler has to have an adequate description of the -->
<!-- processor parallelism (or @dfn{pipeline description}).  GCC -->
<!-- machine descriptions describe processor parallelism and functional -->
<!-- unit reservations for groups of instructions with the aid of -->
<!-- @dfn{regular expressions}. -->
<!-- The GCC instruction scheduler uses a @dfn{pipeline hazard recognizer} to -->
<!-- figure out the possibility of the instruction issue by the processor -->
<!-- on a given simulated processor cycle.  The pipeline hazard recognizer is -->
<!-- automatically generated from the processor pipeline description.  The -->
<!-- pipeline hazard recognizer generated from the machine description -->
<!-- is based on a deterministic finite state automaton (@acronym{DFA}): -->
<!-- the instruction issue is possible if there is a transition from one -->
<!-- automaton state to another one.  This algorithm is very fast, and -->
<!-- furthermore, its speed is not dependent on processor -->
<!-- complexity@footnote{However, the size of the automaton depends on -->
<!-- processor complexity.  To limit this effect, machine descriptions -->
<!-- can split orthogonal parts of the machine description among several -->
<!-- automata: but then, since each of these must be stepped independently, -->
<!-- this does cause a small decrease in the algorithm's performance.}. -->
为了获得更好的性能，大多数现代处理器（超流水线，超标量<acronym>RISC</acronym>，
以及<acronym>VLIW</acronym>处理器）都具有许多功能单元（<dfn>functional units</dfn>），
可以在其上同时执行多条指令。一条指令当它的发射条件（issue conditions）
被满足时才开始执行。如果不满足，则指令会被阻塞（stalled），直到它的条件被满足。
这样的互锁（流水线）延迟(<dfn>interlock (pipeline) delay</dfn>)
导致对后续指令读取的中断（或者需要nop指令，例如一些MIPS处理器）。

 <p>现代处理器中有两种主要的互锁延迟。第一种为数据依赖延迟，用来确定指令延迟时间
（<dfn>instruction latency time</dfn>）。直到所有源数据都被先前指令求得，
该指令才会开始执行（有更加复杂的情况是，
当指令开始执行时数据还不可用，但是将会在指令开始执行后的给定时间准备好）。
考虑数据依赖延迟是简单的。
两个指令间的数据依赖（真依赖，输出依赖，反依赖）延迟被给定为一个常量。
大多数情况下该方法都适合。第二种互锁延迟为保留延迟（reservation delay）。
保留延迟意味着要执行的两条指令将会需要共享的处理器资源，即总线，内部寄存器，
以及/或者功能单元，而这些将被保留一段时间。考虑这种延迟是复杂的，
特别是对于现代<acronym>RISC</acronym>处理器。

 <p>探索更多的处理器并行的任务是由指令调度器来解决的。为了能够更好的解决该问题，
指令调度器必须具有一个处理器并行的适当描述（或者说流水线描述）。
GCC机器描述使用正规表达式来描述处理器并行和对指令组的功能单元保留。

 <p>GCC指令调度器使用流水线冒险识别器通过给定的处理器时钟周期模拟来找出可能的指令问题。
流水线冒险识别器通过处理器流水线描述自动生成。
由机器描述生成的流水线冒险识别器是基于有限确定状态机（<acronym>DFA</acronym>）：
如果存在从一个自动机状态到另一状态的转换，则可以进行指令发射。
该算法非常快，而且它的速度不依赖于处理器的复杂度
<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>。

<!-- @cindex automaton based pipeline description -->
<!-- The rest of this section describes the directives that constitute -->
<!-- an automaton-based processor pipeline description.  The order of -->
<!-- these constructions within the machine description file is not -->
<!-- important. -->
 <p><a name="index-automaton-based-pipeline-description-3698"></a>该章节的剩余部分描述了构造一个基于自动机的处理器流水线描述的命令（directive）。
这些结构在机器描述文件中的顺序并不重要。

<!-- @findex define_automaton -->
<!-- @cindex pipeline hazard recognizer -->
<!-- The following optional construction describes names of automata -->
<!-- generated and used for the pipeline hazards recognition.  Sometimes -->
<!-- the generated finite state automaton used by the pipeline hazard -->
<!-- recognizer is large.  If we use more than one automaton and bind functional -->
<!-- units to the automata, the total size of the automata is usually -->
<!-- less than the size of the single automaton.  If there is no one such -->
<!-- construction, only one finite state automaton is generated. -->
 <p><a name="index-define_005fautomaton-3699"></a><a name="index-pipeline-hazard-recognizer-3700"></a>下面的可选结构描述了生成的自动机的名字，并用于流水线冒险识别。
有时供流水线冒险识别器使用的生成的有限状态机会非常大。
如果我们使用多个自动机并且将功能单元绑定到自动机上，
则自动机的总的大小通常会小于单个自动机的情况。
如果没有这样一个结构，则会只生成一个有限状态机。

<pre class="smallexample">     (define_automaton <var>automata-names</var>)
</pre>
 <!-- @var{automata-names} is a string giving names of the automata.  The -->
<!-- names are separated by commas.  All the automata should have unique names. -->
<!-- The automaton name is used in the constructions @code{define_cpu_unit} and -->
<!-- @code{define_query_cpu_unit}. -->
 <p><var>automata-names</var>为一个字符串，给出了自动机的名字。
名字由逗号分隔。所有自动机应该具有唯一的名字。
自动机名用于结构<code>define_cpu_unit</code>和<code>define_query_cpu_unit</code>。

<!-- @findex define_cpu_unit -->
<!-- @cindex processor functional units -->
<!-- Each processor functional unit used in the description of instruction -->
<!-- reservations should be described by the following construction. -->
 <p><a name="index-define_005fcpu_005funit-3701"></a><a name="index-processor-functional-units-3702"></a>用于指令保留描述的每个处理器功能单元应该使用下列结构来描述。

<pre class="smallexample">     (define_cpu_unit <var>unit-names</var> [<var>automaton-name</var>])
</pre>
 <!-- @var{unit-names} is a string giving the names of the functional units -->
<!-- separated by commas.  Don't use name @samp{nothing}, it is reserved -->
<!-- for other goals. -->
<!-- @var{automaton-name} is a string giving the name of the automaton with -->
<!-- which the unit is bound.  The automaton should be described in -->
<!-- construction @code{define_automaton}.  You should give -->
<!-- @dfn{automaton-name}, if there is a defined automaton. -->
<!-- The assignment of units to automata are constrained by the uses of the -->
<!-- units in insn reservations.  The most important constraint is: if a -->
<!-- unit reservation is present on a particular cycle of an alternative -->
<!-- for an insn reservation, then some unit from the same automaton must -->
<!-- be present on the same cycle for the other alternatives of the insn -->
<!-- reservation.  The rest of the constraints are mentioned in the -->
<!-- description of the subsequent constructions. -->
 <p><var>unit-names</var>为一个字符串，给出了由逗号分隔的功能单元的名字。
不要使用名字&lsquo;<samp><span class="samp">nothing</span></samp>&rsquo;，它被保留用于其它目的。

 <p><var>automaton-name</var>为一个字符串，给出了功能单元绑定的自动机名。
自动机应该在结构<code>define_automaton</code>中有描述。
如果有一个定义的自动机，则你应该给出<dfn>automaton-name</dfn>。

 <p>为功能单元赋予自动机，受到insn保留中对功能单元使用的限制。
最重要的constraint为：如果一个功能单元保留。
其余的constraint将在后续的结构描述中提到。

<!-- @findex define_query_cpu_unit -->
<!-- @cindex querying function unit reservations -->
<!-- The following construction describes CPU functional units analogously -->
<!-- to @code{define_cpu_unit}.  The reservation of such units can be -->
<!-- queried for an automaton state.  The instruction scheduler never -->
<!-- queries reservation of functional units for given automaton state.  So -->
<!-- as a rule, you don't need this construction.  This construction could -->
<!-- be used for future code generation goals (e.g.@: to generate -->
<!-- @acronym{VLIW} insn templates). -->
 <p><a name="index-define_005fquery_005fcpu_005funit-3703"></a><a name="index-querying-function-unit-reservations-3704"></a>下面的结构描述了CPU功能单元，类似于<code>define_cpu_unit</code>。
对于这样的功能单元的保留，可以被询问自动机状态。
对于给定的自动机状态，指令调度器从来不询问功能单元的保留。
所以按照规则，你不需要该结构。
该结构可以被用于将来的代码生成目的（例如，生成<acronym>VLIW</acronym> insn模板）。

<pre class="smallexample">     (define_query_cpu_unit <var>unit-names</var> [<var>automaton-name</var>])
</pre>
 <!-- @var{unit-names} is a string giving names of the functional units -->
<!-- separated by commas. -->
<!-- @var{automaton-name} is a string giving the name of the automaton with -->
<!-- which the unit is bound. -->
 <p><var>unit-names</var>为一个字符串，给出了由逗号分隔的功能单元名字。

 <p><var>automaton-name</var>为一个字符串，给出了功能单元所绑定的自动机。

<!-- @findex define_insn_reservation -->
<!-- @cindex instruction latency time -->
<!-- @cindex regular expressions -->
<!-- @cindex data bypass -->
<!-- The following construction is the major one to describe pipeline -->
<!-- characteristics of an instruction. -->
 <p><a name="index-define_005finsn_005freservation-3705"></a><a name="index-instruction-latency-time-3706"></a><a name="index-regular-expressions-3707"></a><a name="index-data-bypass-3708"></a>下面的结构为描述一条指令的流水线特征的主要结构。

<pre class="smallexample">     (define_insn_reservation <var>insn-name</var> <var>default_latency</var>
                              <var>condition</var> <var>regexp</var>)
</pre>
 <!-- @var{default_latency} is a number giving latency time of the -->
<!-- instruction.  There is an important difference between the old -->
<!-- description and the automaton based pipeline description.  The latency -->
<!-- time is used for all dependencies when we use the old description.  In -->
<!-- the automaton based pipeline description, the given latency time is only -->
<!-- used for true dependencies.  The cost of anti-dependencies is always -->
<!-- zero and the cost of output dependencies is the difference between -->
<!-- latency times of the producing and consuming insns (if the difference -->
<!-- is negative, the cost is considered to be zero).  You can always -->
<!-- change the default costs for any description by using the target hook -->
<!-- @code{TARGET_SCHED_ADJUST_COST} (@pxref{Scheduling}). -->
<!-- @var{insn-name} is a string giving the internal name of the insn.  The -->
<!-- internal names are used in constructions @code{define_bypass} and in -->
<!-- the automaton description file generated for debugging.  The internal -->
<!-- name has nothing in common with the names in @code{define_insn}.  It is a -->
<!-- good practice to use insn classes described in the processor manual. -->
<!-- @var{condition} defines what RTL insns are described by this -->
<!-- construction.  You should remember that you will be in trouble if -->
<!-- @var{condition} for two or more different -->
<!-- @code{define_insn_reservation} constructions is TRUE for an insn.  In -->
<!-- this case what reservation will be used for the insn is not defined. -->
<!-- Such cases are not checked during generation of the pipeline hazards -->
<!-- recognizer because in general recognizing that two conditions may have -->
<!-- the same value is quite difficult (especially if the conditions -->
<!-- contain @code{symbol_ref}).  It is also not checked during the -->
<!-- pipeline hazard recognizer work because it would slow down the -->
<!-- recognizer considerably. -->
<!-- @var{regexp} is a string describing the reservation of the cpu's functional -->
<!-- units by the instruction.  The reservations are described by a regular -->
<!-- expression according to the following syntax: -->
 <p><var>default_latency</var>为一个数，给出了指令的延迟时间。
在旧描述和基于自动机的流水线描述中，有一个重要的不同之处。
当我们使用旧描述时，延迟时间是用于所有的依赖。
在基于自动机的流水线描述中，给定的延迟时间只用于真依赖。
反依赖的代价总为0，并且输出依赖的代价是生产者insn和消费者insn的延迟时间之差
（如果差为负数，则代价被认为为0）。
你可以通过使用目标机钩子<code>TARGET_SCHED_ADJUST_COST</code>（参见<a href="Scheduling.html#Scheduling">Scheduling</a>），
来改变任何描述的缺省代价。

 <p><var>insn-name</var>为一个字符串，给出了insn的内部名字。
内部名字被用于结构<code>define_bypass</code>和为了调试所生成的自动机描述文件。
内部名字与<code>define_insn</code>中的名字没有任何关系。
使用在处理器手册中描述的insn类别，是一个很好的做法。

 <p><var>condition</var>定义了什么样的RTL insns由该结构描述。
你应该记住如果对于一个insn，
两个或更多不同<code>define_insn_reservation</code>结构的<var>condition</var>都为真，
则会出问题。这种情况，该insn将使用什么保留，是未定义的。
这种情况在流水线冒险识别器生成时，是不被检查的，
因为识别两个条件具有相同值是十分困难的
（特别是如果条件中包含<code>symbol_ref</code>）。
这在流水线识别器工作时，也不被检查，因为它将使识别器变得相当慢。

 <p><var>regexp</var>为一个字符串，描述了指令对cpu的功能单元的保留。
保留通过正规表达式来描述，语法如下：

<pre class="smallexample">            regexp = regexp "," oneof
                   | oneof
     
            oneof = oneof "|" allof
                  | allof
     
            allof = allof "+" repeat
                  | repeat
     
            repeat = element "*" number
                   | element
     
            element = cpu_function_unit_name
                    | reservation_name
                    | result_name
                    | "nothing"
                    | "(" regexp ")"
</pre>
 <!-- @itemize @bullet -->
<!-- @item -->
<!-- @samp{,} is used for describing the start of the next cycle in -->
<!-- the reservation. -->
<!-- @item -->
<!-- @samp{|} is used for describing a reservation described by the first -->
<!-- regular expression @strong{or} a reservation described by the second -->
<!-- regular expression @strong{or} etc. -->
<!-- @item -->
<!-- @samp{+} is used for describing a reservation described by the first -->
<!-- regular expression @strong{and} a reservation described by the -->
<!-- second regular expression @strong{and} etc. -->
<!-- @item -->
<!-- @samp{*} is used for convenience and simply means a sequence in which -->
<!-- the regular expression are repeated @var{number} times with cycle -->
<!-- advancing (see @samp{,}). -->
<!-- @item -->
<!-- @samp{cpu_function_unit_name} denotes reservation of the named -->
<!-- functional unit. -->
<!-- @item -->
<!-- @samp{reservation_name} - see description of construction -->
<!-- @samp{define_reservation}. -->
<!-- @item -->
<!-- @samp{nothing} denotes no unit reservations. -->
<!-- @end itemize -->
     <ul>
<li>&lsquo;<samp><span class="samp">,</span></samp>&rsquo;用于描述在保留中，下一周期的开始。

     <li>&lsquo;<samp><span class="samp">|</span></samp>&rsquo;用于描述在保留中，第一个正规表达式<strong>or</strong>第二个正规表达式，
<strong>or</strong>等等。

     <li>&lsquo;<samp><span class="samp">+</span></samp>&rsquo;用于描述在保留中，第一个正规表达式<strong>and</strong>第二个正规表达式，
<strong>and</strong>等等。

     <li>&lsquo;<samp><span class="samp">*</span></samp>&rsquo;用于方便记述，其简单的表示一个正规表达式序列，
表达式随着周期前移被重复<var>number</var>次（参见&lsquo;<samp><span class="samp">,</span></samp>&rsquo;）。

     <li>&lsquo;<samp><span class="samp">cpu_function_unit_name</span></samp>&rsquo;表示对命名功能单元的保留。

     <li>&lsquo;<samp><span class="samp">reservation_name</span></samp>&rsquo; &mdash; 参见对结构&lsquo;<samp><span class="samp">define_reservation</span></samp>&rsquo;的描述。

     <li>&lsquo;<samp><span class="samp">nothing</span></samp>&rsquo;表示没有功能单元被保留。
</ul>

<!-- @findex define_reservation -->
<!-- Sometimes unit reservations for different insns contain common parts. -->
<!-- In such case, you can simplify the pipeline description by describing -->
<!-- the common part by the following construction -->
<!-- @smallexample -->
<!-- (define_reservation @var{reservation-name} @var{regexp}) -->
<!-- @end smallexample -->
<!-- @var{reservation-name} is a string giving name of @var{regexp}. -->
<!-- Functional unit names and reservation names are in the same name -->
<!-- space.  So the reservation names should be different from the -->
<!-- functional unit names and can not be the reserved name @samp{nothing}. -->
 <p><a name="index-define_005freservation-3709"></a>有时，对于不同insn，具有共同部分的单元保留。
这样情况，你可以通过使用下面的结构来描述共同部分，以简化流水线描述。

<pre class="smallexample">     (define_reservation <var>reservation-name</var> <var>regexp</var>)
</pre>
 <p><var>reservation-name</var>为一个字符串，给出了<var>regexp</var>的名字。
功能单元名和保留名属于同一命名空间。所以，保留名应该与功能单元名不同，
并且不能为预留名&lsquo;<samp><span class="samp">nothing</span></samp>&rsquo;。

 <p><a name="index-define_005fbypass-3710"></a><a name="index-instruction-latency-time-3711"></a><a name="index-data-bypass-3712"></a><!-- The following construction is used to describe exceptions in the -->
<!-- latency time for given instruction pair.  This is so called bypasses. -->
下面的结构被用于描述对于给定的指令对，在延迟时间上的例外。也称之为bypass。

<pre class="smallexample">     (define_bypass <var>number</var> <var>out_insn_names</var> <var>in_insn_names</var>
                    [<var>guard</var>])
</pre>
 <!-- @var{number} defines when the result generated by the instructions -->
<!-- given in string @var{out_insn_names} will be ready for the -->
<!-- instructions given in string @var{in_insn_names}.  The instructions in -->
<!-- the string are separated by commas. -->
 <p><var>number</var>定义了给定字符串<var>out_insn_names</var>的指令所产生的结果，
什么时候可以由给定字符串<var>in_insn_names</var>的指令使用。
<!-- 字符串中的指令由逗号分隔。 -->
Each of these
strings is a comma-separated list of filename-style globs and
they refer to the names of <code>define_insn_reservation</code>s. 
For example:
<pre class="smallexample">     (define_bypass 1 "cpu1_load_*, cpu1_store_*" "cpu1_load_*")
</pre>
 <p>defines a bypass between instructions that start with
&lsquo;<samp><span class="samp">cpu1_load_</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cpu1_store_</span></samp>&rsquo; and those that start with
&lsquo;<samp><span class="samp">cpu1_load_</span></samp>&rsquo;.

<!-- @var{guard} is an optional string giving the name of a C function which -->
<!-- defines an additional guard for the bypass.  The function will get the -->
<!-- two insns as parameters.  If the function returns zero the bypass will -->
<!-- be ignored for this case.  The additional guard is necessary to -->
<!-- recognize complicated bypasses, e.g.@: when the consumer is only an address -->
<!-- of insn @samp{store} (not a stored value). -->
 <p><var>guard</var>为一个可选的字符串，给出了C函数名，其定义了bypass的额外的保护条件。
该函数将两个insn作为参数。如果函数返回0，则对于该情况bypass将被忽略。
额外的guard在识别复杂的bypass时，很有必要。
例如当消费者只是一个insn &lsquo;<samp><span class="samp">store</span></samp>&rsquo;的地址（而不是被存储的值）。

 <p>If there are more one bypass with the same output and input insns, the
chosen bypass is the first bypass with a guard in description whose
guard function returns nonzero.  If there is no such bypass, then
bypass without the guard function is chosen.

 <p><a name="index-exclusion_005fset-3713"></a><a name="index-presence_005fset-3714"></a><a name="index-final_005fpresence_005fset-3715"></a><a name="index-absence_005fset-3716"></a><a name="index-final_005fabsence_005fset-3717"></a><a name="index-VLIW-3718"></a><a name="index-RISC-3719"></a><!-- The following five constructions are usually used to describe -->
<!-- @acronym{VLIW} processors, or more precisely, to describe a placement -->
<!-- of small instructions into @acronym{VLIW} instruction slots.  They -->
<!-- can be used for @acronym{RISC} processors, too. -->
下面五个结构通常用于描述<acronym>VLIW</acronym>处理器，或者更精确的说，
来描述放入<acronym>VLIW</acronym>指令槽中的小指令的位置。
它们也可以用于<acronym>RISC</acronym>处理器。

<pre class="smallexample">     (exclusion_set <var>unit-names</var> <var>unit-names</var>)
     (presence_set <var>unit-names</var> <var>patterns</var>)
     (final_presence_set <var>unit-names</var> <var>patterns</var>)
     (absence_set <var>unit-names</var> <var>patterns</var>)
     (final_absence_set <var>unit-names</var> <var>patterns</var>)
</pre>
 <!-- @var{unit-names} is a string giving names of functional units -->
<!-- separated by commas. -->
 <p><var>unit-names</var>为一个字符串，给出了由逗号分隔的功能单元的名字。

<!-- @var{patterns} is a string giving patterns of functional units -->
<!-- separated by comma.  Currently pattern is one unit or units -->
<!-- separated by white-spaces. -->
 <p><var>patterns</var>为一个字符串，给出了由逗号分隔的功能单元的模式。
目前的模式，为一个单元或者由空格分隔的单元。

<!-- The first construction (@samp{exclusion_set}) means that each -->
<!-- functional unit in the first string can not be reserved simultaneously -->
<!-- with a unit whose name is in the second string and vice versa.  For -->
<!-- example, the construction is useful for describing processors -->
<!-- (e.g.@: some SPARC processors) with a fully pipelined floating point -->
<!-- functional unit which can execute simultaneously only single floating -->
<!-- point insns or only double floating point insns. -->
 <p>第一个结构(&lsquo;<samp><span class="samp">exclusion_set</span></samp>&rsquo;) 意味着第一个字符串中的每个功能单元不能与
第二个字符串中的功能单元同时被保留，反之亦然。例如，结构可以用于描述处理器
（例如，一些SPARC处理器）具有全流水浮点功能单元，
其只可以同时执行单浮点insn或者双浮点insn。

<!-- The second construction (@samp{presence_set}) means that each -->
<!-- functional unit in the first string can not be reserved unless at -->
<!-- least one of pattern of units whose names are in the second string is -->
<!-- reserved.  This is an asymmetric relation.  For example, it is useful -->
<!-- for description that @acronym{VLIW} @samp{slot1} is reserved after -->
<!-- @samp{slot0} reservation.  We could describe it by the following -->
<!-- construction -->
 <p>第二个结构(&lsquo;<samp><span class="samp">presence_set</span></samp>&rsquo;) 意味着第一个字符串中的每个功能单元不能被保留，
除非至少一种模式的功能单元其名字在第二个字符串中且被保留。这是一个不对称关系。
例如，可以用于描述<acronym>VLIW</acronym> &lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;在&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;保留之后被保留。
我们可以使用下列结构来描述

<pre class="smallexample">     (presence_set "slot1" "slot0")
</pre>
 <!-- Or @samp{slot1} is reserved only after @samp{slot0} and unit @samp{b0} -->
<!-- reservation.  In this case we could write -->
 <p>或者&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;只在&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;和功能单元&lsquo;<samp><span class="samp">b0</span></samp>&rsquo;保留之后被保留。
这种情况下，我们可以写成

<pre class="smallexample">     (presence_set "slot1" "slot0 b0")
</pre>
 <!-- The third construction (@samp{final_presence_set}) is analogous to -->
<!-- @samp{presence_set}.  The difference between them is when checking is -->
<!-- done.  When an instruction is issued in given automaton state -->
<!-- reflecting all current and planned unit reservations, the automaton -->
<!-- state is changed.  The first state is a source state, the second one -->
<!-- is a result state.  Checking for @samp{presence_set} is done on the -->
<!-- source state reservation, checking for @samp{final_presence_set} is -->
<!-- done on the result reservation.  This construction is useful to -->
<!-- describe a reservation which is actually two subsequent reservations. -->
<!-- For example, if we use -->
 <p>第三个结构(&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;) 类似于&lsquo;<samp><span class="samp">presence_set</span></samp>&rsquo;。
区别在于什么时候进行检查。当指令在给定自动机状态被发射时，
其将影响所有当前和计划中的单元保留，并且自动机状态被改变。
第一个状态为源状态，第二个为结果状态。
对于&lsquo;<samp><span class="samp">presence_set</span></samp>&rsquo;的检查是在源状态保留时进行的，
对于&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;的检查是在结果状态下进行的。
该结构可以用于描述实际上是两个连续的保留的保留。例如，如果我们使用

<pre class="smallexample">     (presence_set "slot1" "slot0")
</pre>
 <!-- the following insn will be never issued (because @samp{slot1} requires -->
<!-- @samp{slot0} which is absent in the source state). -->
 <p>下列insn将永远不会被发射（因为&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;需要&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;，
而&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;在源状态是空缺的）

<pre class="smallexample">     (define_reservation "insn_and_nop" "slot0 + slot1")
</pre>
 <!-- but it can be issued if we use analogous @samp{final_presence_set}. -->
 <p>但是如果我们使用类似的&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;其就可以被发射。

<!-- The forth construction (@samp{absence_set}) means that each functional -->
<!-- unit in the first string can be reserved only if each pattern of units -->
<!-- whose names are in the second string is not reserved.  This is an -->
<!-- asymmetric relation (actually @samp{exclusion_set} is analogous to -->
<!-- this one but it is symmetric).  For example it might be useful in a -->
<!-- @acronym{VLIW} description to say that @samp{slot0} cannot be reserved -->
<!-- after either @samp{slot1} or @samp{slot2} have been reserved.  This -->
<!-- can be described as: -->
 <p>第四个结构 (&lsquo;<samp><span class="samp">absence_set</span></samp>&rsquo;) 意味着在第一个字符串中的每个功能单元，
只有在每个名字在第二个字符串中的功能单元没有被保留时才能被保留。
这是一个不对称关系（实际上&lsquo;<samp><span class="samp">exclusion_set</span></samp>&rsquo;与其类似，但它是对成的）。
例如，可以用于<acronym>VLIW</acronym>描述，来表示&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;不能在&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;或
&lsquo;<samp><span class="samp">slot2</span></samp>&rsquo;保留后被保留。这可以描述为

<pre class="smallexample">     (absence_set "slot0" "slot1, slot2")
</pre>
 <!-- Or @samp{slot2} can not be reserved if @samp{slot0} and unit @samp{b0} -->
<!-- are reserved or @samp{slot1} and unit @samp{b1} are reserved.  In -->
<!-- this case we could write -->
 <p>或者&lsquo;<samp><span class="samp">slot2</span></samp>&rsquo;不能被保留，如果&lsquo;<samp><span class="samp">slot0</span></samp>&rsquo;和单元&lsquo;<samp><span class="samp">b0</span></samp>&rsquo;被保留，
或者&lsquo;<samp><span class="samp">slot1</span></samp>&rsquo;和单元&lsquo;<samp><span class="samp">b1</span></samp>&rsquo;被保留. 这种情况下，我们可以写成

<pre class="smallexample">     (absence_set "slot2" "slot0 b0, slot1 b1")
</pre>
 <!-- All functional units mentioned in a set should belong to the same -->
<!-- automaton. -->
 <p>所有在集合（set）中提到的功能单元应属于相同的自动机。
<!-- The last construction (@samp{final_absence_set}) is analogous to -->
<!-- @samp{absence_set} but checking is done on the result (state) -->
<!-- reservation.  See comments for @samp{final_presence_set}. -->
最后一个结构(&lsquo;<samp><span class="samp">final_absence_set</span></samp>&rsquo;)类似于&lsquo;<samp><span class="samp">absence_set</span></samp>&rsquo;，
但是检查是在结果（状态）保留时进行。参见&lsquo;<samp><span class="samp">final_presence_set</span></samp>&rsquo;的注解。

<!-- @findex automata_option -->
<!-- @cindex deterministic finite state automaton -->
<!-- @cindex nondeterministic finite state automaton -->
<!-- @cindex finite state automaton minimization -->
<!-- You can control the generator of the pipeline hazard recognizer with -->
<!-- the following construction. -->
<!-- @smallexample -->
<!-- (automata_option @var{options}) -->
<!-- @end smallexample -->
<!-- @var{options} is a string giving options which affect the generated -->
<!-- code.  Currently there are the following options: -->
 <p><a name="index-automata_005foption-3720"></a><a name="index-deterministic-finite-state-automaton-3721"></a><a name="index-nondeterministic-finite-state-automaton-3722"></a><a name="index-finite-state-automaton-minimization-3723"></a>你可以使用下面的结构来控制流水线冒险识别器的生成。

<pre class="smallexample">     (automata_option <var>options</var>)
</pre>
 <p><var>options</var>为一个字符串，给出了影响生成代码的选项。目前有下列选项：

<!-- @itemize @bullet -->
<!-- @item -->
<!-- @dfn{no-minimization} makes no minimization of the automaton.  This is -->
<!-- only worth to do when we are debugging the description and need to -->
<!-- look more accurately at reservations of states. -->
<!-- @item -->
<!-- @dfn{time} means printing time statistics about the generation of -->
<!-- automata. -->
<!-- @item -->
<!-- @dfn{stats} means printing statistics about the generated automata -->
<!-- such as the number of DFA states, NDFA states and arcs. -->
<!-- @item -->
<!-- @dfn{v} means a generation of the file describing the result automata. -->
<!-- The file has suffix @samp{.dfa} and can be used for the description -->
<!-- verification and debugging. -->
<!-- @item -->
<!-- @dfn{w} means a generation of warning instead of error for -->
<!-- non-critical errors. -->
<!-- @item -->
<!-- @dfn{no-comb-vect} prevents the automaton generator from generating -->
<!-- two data structures and comparing them for space efficiency.  Using -->
<!-- a comb vector to represent transitions may be better, but it can be -->
<!-- very expensive to construct.  This option is useful if the build -->
<!-- process spends an unacceptably long time in genautomata. -->
<!-- @item -->
<!-- @dfn{ndfa} makes nondeterministic finite state automata.  This affects -->
<!-- the treatment of operator @samp{|} in the regular expressions.  The -->
<!-- usual treatment of the operator is to try the first alternative and, -->
<!-- if the reservation is not possible, the second alternative.  The -->
<!-- nondeterministic treatment means trying all alternatives, some of them -->
<!-- may be rejected by reservations in the subsequent insns. -->
<!-- @item -->
<!-- @dfn{collapse-ndfa} modifies the behaviour of the generator when -->
<!-- producing an automaton.  An additional state transition to collapse a -->
<!-- nondeterministic @acronym{NDFA} state to a deterministic @acronym{DFA} -->
<!-- state is generated.  It can be triggered by passing @code{const0_rtx} to -->
<!-- state_transition.  In such an automaton, cycle advance transitions are -->
<!-- available only for these collapsed states.  This option is useful for -->
<!-- ports that want to use the @code{ndfa} option, but also want to use -->
<!-- @code{define_query_cpu_unit} to assign units to insns issued in a cycle. -->
<!-- @item -->
<!-- @dfn{progress} means output of a progress bar showing how many states -->
<!-- were generated so far for automaton being processed.  This is useful -->
<!-- during debugging a @acronym{DFA} description.  If you see too many -->
<!-- generated states, you could interrupt the generator of the pipeline -->
<!-- hazard recognizer and try to figure out a reason for generation of the -->
<!-- huge automaton. -->
<!-- @end itemize -->
     <ul>
<li><dfn>no-minimization</dfn>不对自动机进行最小化处理。
这只在我们进行调试描述信息并且需要更加精确的查看保留状态时，才值得做。

     <li><dfn>time</dfn>意味着打印生成自动机的时间统计。

     <li><dfn>stats</dfn>意味着打印生成自动机的DFA状态，NDFA状态和arcs这样的数目统

     <li><dfn>v</dfn>意味着生成一个描述生成自动机的文件。文件具有后缀&lsquo;<samp><span class="samp">.dfa</span></samp>&rsquo;，
并且可以用于验证和调试描述。

     <li><dfn>w</dfn>意味着对于非关键的错误使用警告来替代。

     <li><dfn>ndfa</dfn>生成非确定有限状态机。这将影响对正规表达式中操作符&lsquo;<samp><span class="samp">|</span></samp>&rsquo;的对待。
通常对该操作符的处理是先尝试第一个，然后再第二个。
非确定状态机意味着尝试所有的选择，其中一些可以被后续的insn放弃。

     <li><dfn>progress</dfn>意味着输出一个进度条，来显示被处理的自动机目前生成了多少状态。
这在调试<acronym>DFA</acronym>描述时很有用。如果你看到太多的状态被生成，
你可以中断流水线冒险识别器的生成并尝试去弄清楚为什么会生成如此大的自动机。
</ul>

<!-- As an example, consider a superscalar @acronym{RISC} machine which can -->
<!-- issue three insns (two integer insns and one floating point insn) on -->
<!-- the cycle but can finish only two insns.  To describe this, we define -->
<!-- the following functional units. -->
<!-- @smallexample -->
<!-- (define_cpu_unit "i0_pipeline, i1_pipeline, f_pipeline") -->
<!-- (define_cpu_unit "port0, port1") -->
<!-- @end smallexample -->
<!-- All simple integer insns can be executed in any integer pipeline and -->
<!-- their result is ready in two cycles.  The simple integer insns are -->
<!-- issued into the first pipeline unless it is reserved, otherwise they -->
<!-- are issued into the second pipeline.  Integer division and -->
<!-- multiplication insns can be executed only in the second integer -->
<!-- pipeline and their results are ready correspondingly in 8 and 4 -->
<!-- cycles.  The integer division is not pipelined, i.e.@: the subsequent -->
<!-- integer division insn can not be issued until the current division -->
<!-- insn finished.  Floating point insns are fully pipelined and their -->
<!-- results are ready in 3 cycles.  Where the result of a floating point -->
<!-- insn is used by an integer insn, an additional delay of one cycle is -->
<!-- incurred.  To describe all of this we could specify -->
 <p>作为一个例子，考虑一个超标量<acronym>RISC</acronym>机器，
其可以在一个周期发射三条insn（两条整数insn和一条浮点insn），
但是只能完成两条insn。为了描述，我们定义下列功能单元。

<pre class="smallexample">     (define_cpu_unit "i0_pipeline, i1_pipeline, f_pipeline")
     (define_cpu_unit "port0, port1")
</pre>
 <p>所有简单的整数insn可以在任何整数流水线中被执行，并且结果可以在两个周期获得。
简单的整数insn将被发射到第一个流水线中，除非它被保留，
否则它们将被发射到第二个流水线中。整数除和乘insn只能在第二个整数流水线中被执行，
并且它们的结果相应的在8和4个周期获得。
整数除为非流水线，即后续的整数除insn在当前的除法insn完成前不能被发射。
浮点insn为全流水的并且它们的结果在3个周期获得。
当浮点insn的结果被整数insn使用使，将会产生一个额外的周期延迟。
要描述所有这些，我们可以指定

<pre class="smallexample">     (define_cpu_unit "div")
     
     (define_insn_reservation "simple" 2 (eq_attr "type" "int")
                              "(i0_pipeline | i1_pipeline), (port0 | port1)")
     
     (define_insn_reservation "mult" 4 (eq_attr "type" "mult")
                              "i1_pipeline, nothing*2, (port0 | port1)")
     
     (define_insn_reservation "div" 8 (eq_attr "type" "div")
                              "i1_pipeline, div*7, div + (port0 | port1)")
     
     (define_insn_reservation "float" 3 (eq_attr "type" "float")
                              "f_pipeline, nothing, (port0 | port1))
     
     (define_bypass 4 "float" "simple,mult,div")
</pre>
 <!-- To simplify the description we could describe the following reservation -->
<!-- @smallexample -->
<!-- (define_reservation "finish" "port0|port1") -->
<!-- @end smallexample -->
<!-- and use it in all @code{define_insn_reservation} as in the following -->
<!-- construction -->
<!-- @smallexample -->
<!-- (define_insn_reservation "simple" 2 (eq_attr "type" "int") -->
<!-- "(i0_pipeline | i1_pipeline), finish") -->
<!-- @end smallexample -->
 <p>为了简化描述，我们可以描述下列保留

<pre class="smallexample">     (define_reservation "finish" "port0|port1")
</pre>
 <p>并在所有<code>define_insn_reservation</code>中使用，比如下面的结构

<pre class="smallexample">     (define_insn_reservation "simple" 2 (eq_attr "type" "int")
                              "(i0_pipeline | i1_pipeline), finish")
</pre>
 <!-- @end ifset -->
<!-- @ifset INTERNALS -->
<!-- @node Conditional Execution -->
<!-- @section Conditional Execution -->
<!-- @cindex conditional execution -->
<!-- @cindex predication -->
 <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> 然而，自动机的大小依赖于处理器的复杂度。为了限制这种影响，
机器描述可以将机器描述的正交部分拆分成多个自动机：但是，
由于每个这样的自动机都必须独立的执行每一步，
所以这确实会在算法性能上造成一点消减。</p>

 <hr></div>

 </body></html>

