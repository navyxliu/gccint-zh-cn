<html lang="zh">
<head>
<title>Working with declarations - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Declarations.html#Declarations" title="Declarations">
<link rel="next" href="Internal-structure.html#Internal-structure" title="Internal structure">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Working-with-declarations"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Internal-structure.html#Internal-structure">Internal structure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Declarations.html#Declarations">Declarations</a>
<hr>
</div>

<h4 class="subsection">11.4.1 关于声明的操作</h4>

<!-- Some macros can be used with any kind of declaration.  These include: -->
<p>一些宏可以用于任何种类的声明。这包括：
     <dl>
<dt><code>DECL_NAME</code><a name="index-DECL_005fNAME-2407"></a><dd><!-- This macro returns an @code{IDENTIFIER_NODE} giving the name of the -->
<!-- entity. -->
该宏返回一个<code>IDENTIFIER_NODE</code>，给出了实体的名字。

     <br><dt><code>TREE_TYPE</code><a name="index-TREE_005fTYPE-2408"></a><dd><!-- This macro returns the type of the entity declared. -->
该宏返回被声明的实体的类型。

     <br><dt><code>EXPR_FILENAME</code><a name="index-EXPR_005fFILENAME-2409"></a><dd><!-- This macro returns the name of the file in which the entity was -->
<!-- declared, as a @code{char*}.  For an entity declared implicitly by the -->
<!-- compiler (like @code{__builtin_memcpy}), this will be the string -->
<!-- @code{"<internal>"}. -->
该宏返回被声明的实体所在的文件的名字，作为一个<code>char*</code>。对于由编译器隐式声明的实体（比如<code>__builtin_memcpy</code>），这将为字符串<code>"&lt;internal&gt;"</code>。

     <br><dt><code>EXPR_LINENO</code><a name="index-EXPR_005fLINENO-2410"></a><dd><!-- This macro returns the line number at which the entity was declared, as -->
<!-- an @code{int}. -->
该宏返回被声明的实体所在的行号，作为一个<code>int</code>。

     <br><dt><code>DECL_ARTIFICIAL</code><a name="index-DECL_005fARTIFICIAL-2411"></a><dd><!-- This predicate holds if the declaration was implicitly generated by the -->
<!-- compiler.  For example, this predicate will hold of an implicitly -->
<!-- declared member function, or of the @code{TYPE_DECL} implicitly -->
<!-- generated for a class type.  Recall that in C++ code like: -->
该断言用来表示声明是否为编译器隐式产生的。例如，该断言可以用来存放一个隐式声明的成员函数，或者为一个class类型隐式生成的<code>TYPE_DECL</code>。回想一下在C++代码中：
     <pre class="smallexample">          struct S {};
</pre>
     <p class="noindent"><!-- is roughly equivalent to C code like: -->
大体上等价于C代码：
     <pre class="smallexample">          struct S {};
          typedef struct S S;
</pre>
     <!-- The implicitly generated @code{typedef} declaration is represented by a -->
     <!-- @code{TYPE_DECL} for which @code{DECL_ARTIFICIAL} holds. -->
     <p>隐式生成的<code>typedef</code>声明由<code>TYPE_DECL</code>表示，在<code>DECL_ARTIFICIAL</code>中存放。

 </dl>

<!-- The various kinds of declarations include: -->
 <p>各种类型的声明：
     <dl>
<dt><code>LABEL_DECL</code><dd><!-- These nodes are used to represent labels in function bodies.  For more -->
<!-- information, see @ref{Functions}.  These nodes only appear in block -->
<!-- scopes. -->
这些节点用于表示函数体内的标号。更多信息，可以参考<a href="Functions.html#Functions">Functions</a>。这些节点只出现在块作用域（block scope）。

     <br><dt><code>CONST_DECL</code><dd><!-- These nodes are used to represent enumeration constants.  The value of -->
<!-- the constant is given by @code{DECL_INITIAL} which will be an -->
<!-- @code{INTEGER_CST} with the same type as the @code{TREE_TYPE} of the -->
<!-- @code{CONST_DECL}, i.e., an @code{ENUMERAL_TYPE}. -->
这些节点用于表示枚举常量。常量的值由<code>DECL_INITIAL</code>给出，为一个<code>INTEGER_CST</code>，并且和<code>CONST_DECL</code>的<code>TREE_TYPE</code>具有相同的类型，即<code>ENUMERAL_TYPE</code>。

     <br><dt><code>RESULT_DECL</code><dd><!-- These nodes represent the value returned by a function.  When a value is -->
<!-- assigned to a @code{RESULT_DECL}, that indicates that the value should -->
<!-- be returned, via bitwise copy, by the function.  You can use -->
<!-- @code{DECL_SIZE} and @code{DECL_ALIGN} on a @code{RESULT_DECL}, just as -->
<!-- with a @code{VAR_DECL}. -->
这些节点表示函数的返回值。当<code>RESULT_DECL</code>被赋予一个值的时候，这表明该值将被函数通过按位拷贝的方式返回。就像对于<code>VAR_DECL</code>一样，你可以在<code>RESULT_DECL</code>上使用<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>。

     <br><dt><code>TYPE_DECL</code><dd><!-- These nodes represent @code{typedef} declarations.  The @code{TREE_TYPE} -->
<!-- is the type declared to have the name given by @code{DECL_NAME}.  In -->
<!-- some cases, there is no associated name. -->
这些节点表示<code>typedef</code>声明。<code>TREE_TYPE</code>为被声明的类型，其名字由<code>DECL_NAME</code>给出。有些情况下，没有相关联的名字。

     <br><dt><code>VAR_DECL</code><dd><!-- These nodes represent variables with namespace or block scope, as well -->
<!-- as static data members.  The @code{DECL_SIZE} and @code{DECL_ALIGN} are -->
<!-- analogous to @code{TYPE_SIZE} and @code{TYPE_ALIGN}.  For a declaration, -->
<!-- you should always use the @code{DECL_SIZE} and @code{DECL_ALIGN} rather -->
<!-- than the @code{TYPE_SIZE} and @code{TYPE_ALIGN} given by the -->
<!-- @code{TREE_TYPE}, since special attributes may have been applied to the -->
<!-- variable to give it a particular size and alignment.  You may use the -->
<!-- predicates @code{DECL_THIS_STATIC} or @code{DECL_THIS_EXTERN} to test -->
<!-- whether the storage class specifiers @code{static} or @code{extern} were -->
<!-- used to declare a variable. -->
这些节点表示具有命名空间或者块作用域的变量，以及静态数据成员。<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>，类似于<code>TYPE_SIZE</code>和<code>TYPE_ALIGN</code>。对于声明，你应该总是使用<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>，而不是由<code>TREE_TYPE</code>给定的<code>TYPE_SIZE</code>和<code>TYPE_ALIGN</code>，因为，可能会对变量应用了特定的属性，使其具有特定的大小和对齐方式。你可以使用断言<code>DECL_THIS_STATIC</code>或<code>DECL_THIS_EXTERN</code>来测试是否使用了存储类别说明符<code>static</code>或<code>extern</code>来声明一个变量。

     <!-- If this variable is initialized (but does not require a constructor), -->
     <!-- the @code{DECL_INITIAL} will be an expression for the initializer.  The -->
     <!-- initializer should be evaluated, and a bitwise copy into the variable -->
     <!-- performed.  If the @code{DECL_INITIAL} is the @code{error_mark_node}, -->
     <!-- there is an initializer, but it is given by an explicit statement later -->
     <!-- in the code; no bitwise copy is required. -->
     <p>如果该变量被初始化（并需要一个构造者），则<code>DECL_INITIAL</code>将为初始化者的表达式。初始化者将被求值，并按位复制到变量中。如果<code>DECL_INITIAL</code>为<code>error_mark_node</code>，则表明存在一个初始化者，只不过它由之后代码中的显式的语句给出；这将不需要进行按位复制。

     <!-- GCC provides an extension that allows either automatic variables, or -->
     <!-- global variables, to be placed in particular registers.  This extension -->
     <!-- is being used for a particular @code{VAR_DECL} if @code{DECL_REGISTER} -->
     <!-- holds for the @code{VAR_DECL}, and if @code{DECL_ASSEMBLER_NAME} is not -->
     <!-- equal to @code{DECL_NAME}.  In that case, @code{DECL_ASSEMBLER_NAME} is -->
     <!-- the name of the register into which the variable will be placed. -->
     <p>GCC提供了一个扩展，允许自动变量或者全局变量，被放到特定的寄存器中。如果<code>DECL_REGISTER</code>存放了<code>VAR_DECL</code>，并且<code>DECL_ASSEMBLER_NAME</code>不等于<code>DECL_NAME</code>，则<code>VAR_DECL</code>是使用了该扩展。这种情况下，<code>DECL_ASSEMBLER_NAME</code>为存放变量的寄存器的名字。

     <br><dt><code>PARM_DECL</code><dd><!-- Used to represent a parameter to a function.  Treat these nodes -->
<!-- similarly to @code{VAR_DECL} nodes.  These nodes only appear in the -->
<!-- @code{DECL_ARGUMENTS} for a @code{FUNCTION_DECL}. -->
用于表示一个函数的参数。这些节点可以作为<code>VAR_DECL</code>节点来看待。这些节点只出现在<code>FUNCTION_DECL</code>的<code>DECL_ARGUMENTS</code>中。

     <!-- The @code{DECL_ARG_TYPE} for a @code{PARM_DECL} is the type that will -->
     <!-- actually be used when a value is passed to this function.  It may be a -->
     <!-- wider type than the @code{TREE_TYPE} of the parameter; for example, the -->
     <!-- ordinary type might be @code{short} while the @code{DECL_ARG_TYPE} is -->
     <!-- @code{int}. -->
     <p><code>PARM_DECL</code>的<code>DECL_ARG_TYPE</code>为，当值传给函数时实际使用的类型。其可以为一个比参数的<code>TREE_TYPE</code>更宽的类型；例如，原始类型可能为<code>short</code>，而<code>DECL_ARG_TYPE</code>为<code>int</code>。

     <br><dt><code>DEBUG_EXPR_DECL</code><dd>Used to represent an anonymous debug-information temporary created to
hold an expression as it is optimized away, so that its value can be
referenced in debug bind statements.

     <br><dt><code>FIELD_DECL</code><dd><!-- These nodes represent non-static data members.  The @code{DECL_SIZE} and -->
<!-- @code{DECL_ALIGN} behave as for @code{VAR_DECL} nodes. -->
<!-- The position of the field within the parent record is specified by a -->
<!-- combination of three attributes.  @code{DECL_FIELD_OFFSET} is the position, -->
<!-- counting in bytes, of the @code{DECL_OFFSET_ALIGN}-bit sized word containing -->
<!-- the bit of the field closest to the beginning of the structure. -->
<!-- @code{DECL_FIELD_BIT_OFFSET} is the bit offset of the first bit of the field -->
<!-- within this word; this may be nonzero even for fields that are not bit-fields, -->
<!-- since @code{DECL_OFFSET_ALIGN} may be greater than the natural alignment -->
<!-- of the field's type. -->
这些节点表示非静态数据成员。<code>DECL_SIZE</code>和<code>DECL_ALIGN</code>的行为，跟<code>VAR_DECL</code>节点的一样。在父记录（parent record）中的域的位置，由三个属性组合指定。<code>DECL_FIELD_OFFSET</code>为按字节计数的位置，

     <!-- If @code{DECL_C_BIT_FIELD} holds, this field is a bit-field.  In a bit-field, -->
     <!-- @code{DECL_BIT_FIELD_TYPE} also contains the type that was originally -->
     <!-- specified for it, while DECL_TYPE may be a modified type with lesser precision, -->
     <!-- according to the size of the bit field. -->
     <p>如果DECL_C_BIT_FIELD有效，则该域是一个位域。在位域中，DECL_BIT_FIELD_TYPE还包含了原始指定的类型，而DECL_TYPE可能是根据位域的大小，修改后具有更少精度的类型。

     <br><dt><code>NAMESPACE_DECL</code><dd>Namespaces provide a name hierarchy for other declarations.  They
appear in the <code>DECL_CONTEXT</code> of other <code>_DECL</code> nodes.

 </dl>

<!-- @node Internal structure -->
<!-- @subsection Internal structure -->
 </body></html>

