@c -*-texinfo-*-
@c Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007, 2008 Free Software
@c Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Control Flow Graph
@c ---------------------------------------------------------------------

@node 控制流
@chapter 控制流图
@cindex CFG, Control Flow Graph
@findex basic-block.h

控制流图（CFG）是一个建立在中间代码（RTL或者@code{tree}指令流）之上的数据结构，
对正在编译的函数的控制流行为的抽象。CFG是一个有向图，顶点表示基本块，
边表示从一个基本块到另一个的控制流的可能转换。
用来表示控制流图的数据结构定义在@file{basic-block.h}中。

@menu
* 基本块::       基本块的定义和表示。    
* 边::           边的类型和表示。
* Profile信息::  频率和概率的表示。
* 维护CFG::      保持控制流图的更新。
* 活跃信息::     使用和维护活跃信息。
@end menu


@node 基本块
@section 基本块

@cindex basic block
@findex basic_block
基本块是只具有一个入口和一个出口的直线顺序的代码序列。
在GCC中，基本块使用@code{basic_block}数据类型来表示。

@findex next_bb, prev_bb, FOR_EACH_BB
结构体@code{basic_block}的两个指针成员是指针@code{next_bb}和@code{prev_bb}，
用来构造和内在的指令流顺序相同的基本块双向链表。
基本块的链接由操作CFG的API来更新。
宏@code{FOR_EACH_BB}可以用来按照lexicographical顺序来访问所有基本块。
也可以使用@code{walk_dominator_tree}，来进行dominator遍历。
给出两个基本块A和B，块A支配（dominate）块B，如果A@emph{总是}在B之前被执行。

@findex BASIC_BLOCK
数组@code{BASIC_BLOCK}按照未指定的顺序包含了所有的基本块。
每一个@code{basic_block}结构体都有一个域，
包含了一个唯一的整数标识符@code{index}，
其为该块在@code{BASIC_BLOCK}数组中的索引。
函数中基本块的总数为@code{n_basic_blocks}。
由于过程可以重排，创建，复制和销毁基本块，
所以基本块的索引和总数在编译过程中都可能改变。
任何块的索引都不应该比@code{last_basic_block}的大。

@findex ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR
一些特定的基本块用来表示一个函数的可能的入口和出口。
这些块被称作@code{ENTRY_BLOCK_PRT}和@code{EXIT_BLOCK_PTR}。
这些块不包含任何代码，并且不是@code{BASIC_BLOCK}数组的成员。
因此它们被赋予了唯一的负数索引。

每个@code{basic_block}还包含了指向基本块中的第一个指令
（@dfn{head}）和最后一条指令（@dfn{tail}），或者指令流的结尾。
实际上，由于@code{basic_block}数据类型在GCC的两个主要中间表示
（@code{tree}和RTL）中都被用来表示块，
因此具有针对这两种表示的指向基本块的头和尾的指针。

@findex NOTE_INSN_BASIC_BLOCK, CODE_LABEL, notes
对于RTL，这些指针是@code{rtx head, end}。在RTL函数表示中，
头指针总是指向@code{NOTE_INSN_BASIC_BLOCK}或者@code{CODE_LABEL}。
在RTL函数表示中，指令流不仅包含“真正”的指令，
而且还有注解（@dfn{notes}）。
任何移动或者复制基本块的函数都需要注意更新这些注解。
许多这些注解都期望指令流由线性区域组成，这使得难以更新。
@code{NOTE_INSN_BASIC_BLOCK}注解是唯一类型的，
可以出现在基本块内包含的指令流中。
一个基本块的指令流总是跟随一个@code{NOTE_INSN_BASIC_BLOCK}，
但是块注解之前可以有0个或多个@code{CODE_LABEL}节点。
基本块结束于控制流指令，
或者最后一条指令后面跟随@code{CODE_LABEL}或者@code{NOTE_INSN_BASIC_BLOCK}。
@code{CODE_LABEL}不能出现在基本块中的指令流里。

@findex can_fallthru
@cindex table jump
除了注解之外，跳转表向量还被表示为insn流中的“伪指令”。
这些向量从不出现在基本块中，并且应该总是放在跳转指令引用它们的表后面。
在移除table-jump之后，通常很难消除计算地址和引用向量的代码，
所以对这些向量的清除工作被推迟到活跃分析之后。
这样跳转表向量可能会在insn流中出现未被引用，并且无用的情况。
在任何边成为@dfn{fall-thru}之前，关于现存的构架，
需要调用@code{can_fallthru}函数来检测。

@cindex block statement iterators
对于@code{tree}的表示，基本块的头和尾由@code{stmt_list}域指向，
但是，决不要直接引用这些特定的@code{tree}。相反的，在树级别上，
使用抽象容器和迭代器来访问基本块中的语句和表达式。
这些迭代器被称作块语句迭代器（BSI）。
可以在各种@file{tree-*}文件中使用grep查找@code{^bsi}。
下面的摘抄可以很好的打印使用 GIMPLE表示的程序的所有语句。

@smallexample
FOR_EACH_BB (bb)
  @{
     block_stmt_iterator si;

     for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))
       @{
          tree stmt = bsi_stmt (si);
          print_generic_stmt (stderr, stmt, 0);
       @}
  @}
@end smallexample


@node 边
@section 边

@cindex edge in the flow graph
@findex edge
边表示从某个基本块A的结束到另一个基本块B的开头的可能的控制流转换。
我们称A是B的前驱，B是A的后继。在GCC中，边由@code{edge}数据类型表示。
每个@code{edge}作为两个基本块之间的链接：
一个@code{edge}的@code{src}成员指向前驱@code{dest}基本块。
数据类型@code{basic_block}的成员@code{preds}和@code{succs}，
指向块的前驱和后继们的边的type-safe向量。

@cindex edge iterators
当在一个边向量中访问边时，应该使用边迭代器。
边迭代器由@code{edge_iterator}数据结构和一些可以使用的操作方法构成：

@ftable @code
@item ei_start
该函数初始化一个指向边向量中第一个边的@code{edge_iterator}。

@item ei_last
该函数初始化一个指向边向量中最后一个边的@code{edge_iterator}。

@item ei_end_p
如果@code{edge_iterator}表示边向量中的最后一个边，则该断言为@code{true}。 

@item ei_one_before_end_p
如果@code{edge_iterator}表示边向量中的倒数第二个边，则该断言为@code{true}。

@item ei_next
该函数接受一个指向@code{edge_iterator}的指针，并使其指向序列中的下一个边。 

@item ei_prev
该函数接受一个指向@code{edge_iterator}的指针，并使其指向序列中的上一个边。 

@item ei_edge
该函数返回由@code{edge_iterator}当前指向的@code{edge}。 

@item ei_safe_safe
该函数返回由@code{edge_iterator}当前指向的@code{edge}，
但是如果迭代器指向序列的结尾时，则返回@code{NULL}。
该函数是为现有的代码提供的，即代码假设用@code{NULL}边来表示序列的结尾。
@end ftable

宏@code{FOR_EACH_EDGE}可以方便的用来访问前驱边或后继边序列。
当在遍历中会移除元素时，不要使用该宏，否则会错过这些元素。
这里有一个如何使用该宏的例子：

@smallexample
edge e;
edge_iterator ei;

FOR_EACH_EDGE (e, ei, bb->succs)
  @{
     if (e->flags & EDGE_FALLTHRU)
       break;
  @}
@end smallexample

@findex fall-thru
有许多原因会导致控制流从一个块传递到另一个。
一种可能是某条指令，例如@code{CODE_LABEL}，在一个线形的指令流中，
总是起始一个新基本块。在这种情况下，
一个@dfn{fall-thru}边将基本块与随后的第一个比本块相连。
但是有许多其它原因会导致边被创建。
@code{edge}的数据类型的@code{flags}域用于存储我们处理的边的类型信息。
每个边都具有下列类型之一：

@table @emph
@item jump
与跳转指令相关的边没有被设置类型标识。这些边用于无条件或有条件跳转，
以及RTL中还有表跳转。它们是最容易操作的，因为当流图不为SSA形式的时候，
可以自由重定向。 

@item fall-thru
@findex EDGE_FALLTHRU, force_nonfallthru
Fall-thru边存在于当基本块不需要分支而是继续执行随后的块的时候。
这些边的标志设为@code{EDGE_FALLTHRU}。不像其它类型的边，
这些边必须直接进入基本块的指令流中。
函数@code{force_nonfallthru}可以用于在需要重定向时插入一个无条件跳转。
注意这可能需要创建一个新基本块。

@item exception handling
@cindex exception handling
@findex EDGE_ABNORMAL, EDGE_EH
异常处理边表示可能的控制转移，从一个陷门指令到一个异常处理器。
关于“trapping”定义不尽相同。在C++中，只有函数调用能够抛出异常，
但是对于Java，像除0或者段错误都被定义为异常，
并且因此每条指令都可能抛出这种需要处理的异常。
异常边设置了@code{EDGE_ABNORMAL}和@code{EDGE_EH}标识。

@findex purge_dead_edges
当更新指令流时，能够容易的将可能trapping的指令转换成non-traaping，
通过简单的将异常边移除。相反的转换比较困难，但是是不会发生的。
可以通过调用@code{purge_dead_edges}来消除边。

@findex REG_EH_REGION, EDGE_ABNORMAL_CALL
在RTL表示中，异常边的目的地由附加在insn上的注解@code{REG_EH_REGION}来指定。
在trapping调用的情况下，还设置了@code{EDGE_ABNORMAL_CALL}标识。
在@code{tree}表示中，该额外的标识没有被设置。

@findex may_trap_p, tree_could_trap_p
在RTL表示中，断言@code{may_trap_p}可以用来检测指令是否还可能trap。
对于tree表示，可以用@code{tree_could_trap_p}，
不过该断言只检测可能的内存trap，像在废除一个无效的指针地址。

@item sibling calls
@cindex sibling call
@findex EDGE_ABNORMAL, EDGE_SIBCALL
兄弟调用或者尾调用以非标准的方式终止函数，
并且因此必须存在一个引向出口的边。
@code{EDGE_SIBCALL}和@code{EDGE_ABNORMAL}在这种情况下被设置。
这些边只存在于RTL表示中。 

@item computed jumps
@cindex computed jump
@findex EDGE_ABNORMAL
计算跳转包含了引向函数中代码引用的所有标号的边。
所有这些边都设置了@code{EDGE_ABNORMAL}标识。
用来表示计算跳转的边通常会造成编译时间性能问题，
因为函数有许多标号组成，许多计算跳转可能具有密集的流图，
所以这些边需要特别仔细的处理。在编译过程的早期阶段，
GCC尝试避免这样的密集流图，通过因子化计算跳转。
例如，给定下列跳转， 

@smallexample
  goto *x;
  [ @dots{} ]

  goto *x;
  [ @dots{} ]

  goto *x;
  [ @dots{} ]
@end smallexample

@noindent
将计算跳转提取公因子，会产生具有比较简单流图的代码序列：

@smallexample
  goto y;
  [ @dots{} ]

  goto y;
  [ @dots{} ]

  goto y;
  [ @dots{} ]

y:
  goto *x;
@end smallexample

但是，这种转换的典型问题是产生的结果代码具有运行时代价：
一个额外的跳转。因此计算跳转在编译器之后的过程里被un-factored。
当你工作于这些过程上时，需要注意。曾有许多已存的例子，
即对未公因子化的计算跳转编译时造成的头痛之事。

@item nonlocal goto handlers
@cindex nonlocal goto handler
@findex EDGE_ABNORMAL, EDGE_ABNORMAL_CALL
GCC允许嵌套函数使用@code{goto}到一个通过参数传给被调用者的标号的方式来返回到调用者那里。
传给嵌套函数的标号包含了特定的代码用来在函数调用之后进行清理工作。
这段代码被称为“nonlocal goto receivers”。
如果一个函数包含这样的非局部goto接受者，一个从调用到标号的边被创建，
并设置了@code{EDGE_ABNORMAL}和@code{EDGE_ABNORMAL_CALL}标识。

@item function entry points
@cindex function entry point, alternate function entry point
@findex LABEL_ALTERNATE_NAME
根据定义，函数执行起始于基本块0，
所以总有一个边从@code{ENTRY_BLOCK_PTR}到基本块0。
目前，对备用入口点没有@code{tree}表示。在RTL里，
备用入口点通过定义了@code{LABEL_ALTERNATE_NAME}的@code{CODE_LABEL}指定。
这能够被后端用于为通过不同上下文调用函数而生成备用prologues。
将来，Fortran90定义的多入口函数的完全支持需要被实现。

@item function exits
在pre-reload表示中，函数终止于insn链中的最后一条指令，
并且没有显示的返回指令。这对应于由fall-thru引向出口块。
reload之后，最佳的RTL epilogues被用于显示的（有条件的）返回指令中。
@end table


@node Profile信息
@section Profile信息

@cindex profile representation
在许多情况下，编译器必须对是否由一块代码的速度来换取另一块的速度，
或者由代码的大小来换取速度，来作出选择。这种情况下，
知道给定块将会被执行几次这样的信息会很有帮助。
这就是在流程图中维护profile的目的。
GCC能够处理通过@dfn{profile feedback}获得的profile信息，
但也能够根据统计和启发来估计分支跳转的可能性。

@cindex profile feedback
基于反馈的profile是通过编译测量程序来产生的，在训练运行中执行，
并且在重新编译程序产生最终可执行程序时，读取基本块和边的执行数目。
该方法使得程序花费大量的时间在训练运行上，从而提供了非常精确的信息。
信息是否匹配平均运行取决于选择的训练数据集，
但是个别研究表现程序的行为通常会由于稍微不同的数据集就会变化。

@cindex Static profile estimation
@cindex branch prediction
@findex predict.def
当profile反馈不可用时，编译器可以被请求尝试使用heuristics集
（详情参见@file{predict.def}）来进行预测程序中每个分支的行为，
并且通过在图中传播可能性来计算每个基本块的评估频率。

@findex frequency, count, BB_FREQ_BASE
每个@code{basic_block}包含两个整数域来表示profile信息：
@code{frequency}和@code{count}。
@code{frequency}是对函数中的基本块每隔多久被执行的评估。
其被表示为一个整数标量，范围从0到@code{BB_FREQ_BASE}。
函数中执行频率最高的基本块被初始化为@code{BB_FREQ_BASE}，
其余的frequency相应的进行刻画。优化过程中，
执行频率最高的基本块的frequency能够减少（例如由循环展开造成的）
或增加（例如由交叉跳转优化造成的），所以有时需要执行多次度量。

@findex gcov_type
@code{count}包含了硬计数的执行数目，在训练运行中测算出的，
并且只有profile反馈可用时为非0。该值被表示为主机的宽整数
（一般为64位整数），特定类型@code{gcov_type}。

大多数优化过程只能使用基本块的frequency信息，
但是一些过程可能想知道硬执行次数。在度量之后，频率应该总是匹配计数，
但是在更新profile信息的过程中，数值误差可能会积累到十分大的错误。

@findex REG_BR_PROB_BASE, EDGE_FREQUENCY
每个边还包含一个分支可能性域：
一个范围从0到@code{REG_BR_PROB_BASE}的整数。
其表示将控制从@code{src}基本块传递到@code{dest}基本块的可能性，
即控制流向该边的可能性。
@code{EDGE_FREQUENCY}宏可用于计算给定边会被接受的频率。
同时每个边还有一个@code{count}域，用来表示与基本块相同的信息。

基本块频率不在指令流中表示，但是在RTL表示中，
边频率用来表示条件跳转（通过@code{REG_BR_PROB}宏），
因为它们用在将指令输出到汇编文件中的时候，并且流图不在被维护。

@cindex reverse probability
控制流通过给定边到达目的基本块的可能性被称作反向可能性，
并且没有直接表示，但是可以容易的从基本块的频率中计算获得。

@findex redirect_edge_and_branch
不幸的是，更新profile信息是一个精致的任务，
这使得很难集成到CFG操作API中。许多修改CFG的函数和钩子，
像@code{redirect_edge_and_branch}，
都不具有足够的信息来容易的修改profile，
所以更新多半情况是留给调用者的。很难找到profile更新代码中的bug，
因为它们只是体现在产生了更糟的代码，
并且检测profile一致性是不可能的，因为数值误差积累。
因此在每个修改CFG的过程中，应该特别注意这个问题。

@findex REG_BR_PROB_BASE, BB_FREQ_BASE, count
必须指出@code{REG_BR_PROB_BASE}和@code{BB_FREQ_BASE}被设为足够低，
才有可能在流图中计算任何频率或可能性作为指数的2的幂运算。

@node 维护CFG
@section 维护CFG
@findex cfghooks.h

每个编译器过程都具有的一个重要任务是保持控制流图和所有profile信息更新。
在每个过程之后都重建控制流图是不可能的，因为这样代价会很高，
而且丢失的profile信息是根本无法重建的。

GCC有两个主要的中间表示，
并且它们都使用@code{basic_block}和@code{edge}数据类型来表示控制流。
两种表示都尽可能多的共享CFG维护的代码。对于每一种表示，
都定义了一套@dfn{hooks}，以便于需要的时候可以提供自己的CFG维护函数的实现。
这些钩子定义在@file{cfghooks.h}中。这些钩子提供了几乎所有普通的CFG操作，
包括块分割和合并，边重定向，以及创建和删除基本块。
这些钩子应该提供所有需要的维护和操作RTL和@code{tree}表示下的CFG。

目前，基本块的边界在修改指令时会被透明的维护，因此很少需要手动移动它们
（比如当有人想要显式的输出基本块外面的指令的时候）。
将CFG看作指令链的组成部分，比看作建立在之上的结构，往往要更好些。
但是原则上，对于树表示的控制流图并不是数表示的必须部分。
函数树可以在不需要首先创建树表示的流图的情况下就被扩展。
这种情况在没有进行任何树优化的编译时会发生。当进行树优化时，
并且指令流被重写为SSA形式，CFG就和指令流非常紧密的联系起来了。
特别在语句插入和移除时要注意。实际上，如果没有同时对CFG进行恰当的维护，
整个树表示就很难使用和维护。

@findex BLOCK_FOR_INSN, bb_for_stmt
在RTL表示里，每条指令有一个@code{BLOCK_FOR_INSN}值用来表示指向包含该指令的基本块。
在@code{tree}表示里，函数@code{bb_for_stmt}返回一个指向包含所查询语句的基本块。

@cindex block statement iterators
在@code{tree}表示里，当需要对函数进行改动时，
应该使用块语句迭代器（@dfn{block statement iterators}）。
这些迭代器提供了流程图和指令流的整体抽象。
块语句迭代器由@code{block_stmt_iterator}数据结构和一些修改函数构成，
包括下面的：

@ftable @code
@item bsi_start
该函数初始化一个@code{block_stmt_iterator}，使其指向基本块中第一条非空语句。 

@item bsi_last
该函数初始化一个@code{block_stmt_iterator}，使其指向基本块中最后一条语句。

@item bsi_end_p
如果@code{block_stmt_iterator}表示基本块的结束，则为@code{true}。

@item bsi_next
该函数接受一个@code{block_stmt_iterator}，并使其指向它的后继。

@item bsi_prev
该函数接受一个@code{block_stmt_iterator}，并使其指向它的前驱。

@item bsi_insert_after
该函数在@code{block_stmt_iterator}所在位置之后插入一条语句。
最后一个参数决定是否将语句迭代器更新指向新插入的语句，
还是保留指向原来的语句。

@item bsi_insert_before
该函数在@code{block_stmt_iterator}所在位置之前插入一条语句。
最后一个参数决定是否将语句迭代器更新指向新插入的语句，
还是保留指向原来的语句。

@item bsi_remove
该函数移除@code{block_stmt_iterator}所在位置的语句，
并且如果基本块中还有语句，则将剩余的语句重新链接。 
@end ftable

@findex BB_HEAD, BB_END
在RTL表示里，宏@code{BB_HEAD}和@code{BB_END}可以用来获得基本块的
起始@code{rtx}和结束@code{rtx}。没有抽象迭代器被定义用来遍历insn链，
不过可以使用@code{NEXT_INSN}和@code{PREV_INSN}替代。参见 @ref{Insns}。

@findex purge_dead_edges
通常一个代码操作过程将会简化指令流和控制流，也可能消除一些边。
例如当一个条件跳转被替换为非条件跳转，甚至在编译java时，
将可能的trapping指令简化为non-trapping。边的更新是不透明的，
每个优化过程都要求手动进行。不过，实际中这种情况很少发生。如果存在的话，
过程可以针对给定的基本块调用@code{purge_dead_edges}来移除多余的边。

@findex redirect_edge_and_branch, redirect_jump
另一个常见的情景是分支指令的重定向。
不过由于可以非常好的建模为控制流图里的边重定向，
因此应尽量使用@code{redirect_edge_and_branch}，而不是其它底层函数，
例如只是操作RTL链的@code{redirect_jump}。
定义在@file{cfghooks.h}中的CFG钩子应该提供了操作和维护CFG所需要的全部API。

@findex split_block
有时候，一个过程可能不得不要向基本块的中间插入控制流指令，这样的话，
就在基本块中间产生一个入口点。根据定义，这是不可能的，
因此必须要将块分开以确保只含有一个入口点，也就是基本块的头。
当基本块中间的指令必须成为跳转或分支指令的目标时，
可以使用CFG钩子@code{split_block}。

@findex insert_insn_on_edge
@findex commit_edge_insertions
@findex bsi_insert_on_edge
@findex bsi_commit_edge_inserts
@cindex edge splitting
对一个全局优化，一个常用的操作是在流图中将边拆分，并插入指令。
在RTL表示里，可以很容易的实现，
通过使用@code{insert_insn_on_edge}函数来生成一条暂存的“on the edge”指令，
以便之后的@code{commit_edge_insertions}调用来将插入的指令从边上移到基本块的指令流里。
如果需要的话，还会生成新的基本块。在@code{tree}表示里，
等价的函数为@code{bsi_insert_on_edge}，用来在边上插入一个块语句迭代器，
以及@code{bsi_commit_edge_inserts}，将指令挪到实际的指令流里。

在调试优化过程时，
函数@code{verify_flow_info}可能有助于发现在控制流图的更新代码中的bug。

注意，目前在由树的表示扩展到RTL时，控制流的表示会被丢弃。
长远的看，CFG应给被维持并随着函数树本身被扩展到RTL表示。

@node 活跃信息
@section 活跃信息
@cindex Liveness representation
活跃信息有助于决定在程序的给定点是否一些寄存器是“活跃”的，
即其包含的值可能在程序之后的地方被使用。
例如，这些信息被使用在寄存器分配过程，
伪寄存器只有在活跃的时候才需要被分配给唯一的硬件寄存器或者栈存储单元。
当一个寄存器无用的时候，硬件寄存器和栈存储单元可以被随意重用于其它值。

在后端从@code{pass_df_initialize}起始到@code{pass_df_finish}结束之间，
活跃信息是有效的。有三种活跃分析：@code{LR}，能够确定在函数的任意点@code{P}，
寄存器是否会在从@code{P}到函数结束之间的某处被使用。
@code{UR}，能够确定是否从函数的起始到P之间定义了变量。
@code{LIVE}是@code{LR}和@code{UR}的交集，变量在@code{P}点是活跃的，
如果同时从函数的开始到现在存在一个赋值，
并且从@code{P}到函数的结束之间存在对其的使用。

通常这三种信息里，@code{LIVE}最有帮助。
宏@code{DF_[LR,UR,LIVE]_[IN,OUT]}可以用来访问这些信息。
这些宏接受一个基本块号，并返回一个以寄存器号为索引的位图。
该信息只保证截至在调用@code{df_analyze}之后是最新的。
关于使用数据流的详细信息参见@file{df-core.c}文件。

@findex REG_DEAD, REG_UNUSED
活跃信息部分存在RTL指令流里，部分存在流程图里。局部信息存在指令流中：
每条指令可以包含@code{REG_DEAD}注解（note），
来表示给定寄存器的值已经不再被需要了，或者@code{REG_UNUSED}注解，
来表示由指令计算所得的值从来没有被使用。第二个可以有助于指令一次计算多值。

