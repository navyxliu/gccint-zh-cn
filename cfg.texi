@c -*-texinfo-*-
@c Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007, 2008 Free Software
@c Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Control Flow Graph
@c ---------------------------------------------------------------------

@en @node Control Flow
@en @chapter Control Flow Graph
@node Control Flow
@chapter 控制流图
@cindex CFG, Control Flow Graph
@findex basic-block.h

@en A control flow graph (CFG) is a data structure built on top of the
@en intermediate code representation (the RTL or @code{tree} instruction
@en stream) abstracting the control flow behavior of a function that is
@en being compiled.  The CFG is a directed graph where the vertices
@en represent basic blocks and edges represent possible transfer of
@en control flow from one basic block to another.  The data structures
@en used to represent the control flow graph are defined in
@en @file{basic-block.h}.
控制流图（CFG）是一个建立在中间代码（RTL或者@code{tree}指令流）之上的数据结构，用来对编译函数的控制流行为进行抽象。CFG是一个有向图，顶点表示基本块，边表示从一个基本块到另一个基本可能的控制流转换。用来表示控制流图的数据结构定义在@file{basic-block.h}中。

@en @menu
@en * Basic Blocks::           The definition and representation of basic blocks.
@en * Edges::                  Types of edges and their representation.
@en * Profile information::    Representation of frequencies and probabilities.
@en * Maintaining the CFG::    Keeping the control flow graph and up to date.
@en * Liveness information::   Using and maintaining liveness information.
@en @end menu
@menu
* Basic Blocks::		基本块的定义和表示    
* Edges::			边的类型和表示
* Profile information::		频率和概率的表示
* Maintaining the CFG::		维护和更新控制流图
* Liveness information::	使用和维护活跃信息
@end menu


@en @node Basic Blocks
@en @section Basic Blocks
@node Basic Blocks
@section 基本块

@cindex basic block
@findex basic_block
@en A basic block is a straight-line sequence of code with only one entry
@en point and only one exit.  In GCC, basic blocks are represented using
@en the @code{basic_block} data type.
基本块是一段只有一个入口和一个出口的直线代码序列。在GCC中，基本块使用@code{basic_block}数据类型来表示。

@findex next_bb, prev_bb, FOR_EACH_BB
@en Two pointer members of the @code{basic_block} structure are the
@en pointers @code{next_bb} and @code{prev_bb}.  These are used to keep
@en doubly linked chain of basic blocks in the same order as the
@en underlying instruction stream.  The chain of basic blocks is updated
@en transparently by the provided API for manipulating the CFG@.  The macro
@en @code{FOR_EACH_BB} can be used to visit all the basic blocks in
@en lexicographical order.  Dominator traversals are also possible using
@en @code{walk_dominator_tree}.  Given two basic blocks A and B, block A
@en dominates block B if A is @emph{always} executed before B@.
结构体@code{basic_block}的两个指针成员，指针@code{next_bb}和@code{prev_bb}，用来维持与底层指令流顺序相同的基本块双向链表。基本块之间的链，由给定的操作CFG的API，通过透明的方式进行更新。宏@code{FOR_EACH_BB}可以用来按照字典顺序（lexicographical order）访问所有基本块。也可以使用@code{walk_dominator_tree}，按照支配顺序进行遍历（dominator traversal）。给定两个基本块A和B，如果A@emph{总是}在B之前被执行，则基本块A支配（dominate）基本块B。

@findex BASIC_BLOCK
@en The @code{BASIC_BLOCK} array contains all basic blocks in an
@en unspecified order.  Each @code{basic_block} structure has a field
@en that holds a unique integer identifier @code{index} that is the
@en index of the block in the @code{BASIC_BLOCK} array.
@en The total number of basic blocks in the function is
@en @code{n_basic_blocks}.  Both the basic block indices and
@en the total number of basic blocks may vary during the compilation
@en process, as passes reorder, create, duplicate, and destroy basic
@en blocks.  The index for any block should never be greater than
@en @code{last_basic_block}.
@code{BASIC_BLOCK}数组包含了所有的基本块，并且顺序不固定。每个@code{basic_block}结构体都有一个域，用来存放唯一的整数标识符@code{index}，作为该基本块在@code{BASIC_BLOCK}数组中的索引。函数中基本块的总数为@code{n_basic_blocks}。由于passes可以重排，创建，复制和销毁基本块，所以基本块的索引和总数在编译过程中都可能会改变。任何基本块的索引都不能大于@code{last_basic_block}的。

@findex ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR
@en Special basic blocks represent possible entry and exit points of a
@en function.  These blocks are called @code{ENTRY_BLOCK_PTR} and
@en @code{EXIT_BLOCK_PTR}.  These blocks do not contain any code, and are
@en not elements of the @code{BASIC_BLOCK} array.  Therefore they have
@en been assigned unique, negative index numbers.
有专门的基本块来表示函数的可能入口和出口。这些基本块被称作@code{ENTRY_BLOCK_PRT}和@code{EXIT_BLOCK_PTR}。这些基本块不包含任何代码，并且不是@code{BASIC_BLOCK}数组的成员。因此它们被赋予了唯一的负数索引。

@en Each @code{basic_block} also contains pointers to the first
@en instruction (the @dfn{head}) and the last instruction (the @dfn{tail})
@en or @dfn{end} of the instruction stream contained in a basic block.  In
@en fact, since the @code{basic_block} data type is used to represent
@en blocks in both major intermediate representations of GCC (@code{tree}
@en and RTL), there are pointers to the head and end of a basic block for
@en both representations.
每个@code{basic_block}还包含了指针，用来指向基本块中的第一条指令（@dfn{head}）和最后一条指令（@dfn{tail}），或者指令流的结尾（@dfn{end}）。实际上，由于@code{basic_block}数据类型在GCC的两个主要中间表示（@code{tree}和RTL）中都被用来表示基本块，因此有针对这两种表示的指向基本块头和尾的指针。

@findex NOTE_INSN_BASIC_BLOCK, CODE_LABEL, notes
@en For RTL, these pointers are @code{rtx head, end}.  In the RTL function
@en representation, the head pointer always points either to a
@en @code{NOTE_INSN_BASIC_BLOCK} or to a @code{CODE_LABEL}, if present.
@en In the RTL representation of a function, the instruction stream
@en contains not only the ``real'' instructions, but also @dfn{notes}.
@en Any function that moves or duplicates the basic blocks needs
@en to take care of updating of these notes.  Many of these notes expect
@en that the instruction stream consists of linear regions, making such
@en updates difficult.   The @code{NOTE_INSN_BASIC_BLOCK} note is the only
@en kind of note that may appear in the instruction stream contained in a
@en basic block.  The instruction stream of a basic block always follows a
@en @code{NOTE_INSN_BASIC_BLOCK},  but zero or more @code{CODE_LABEL}
@en nodes can precede the block note.   A basic block ends by control flow
@en instruction or last instruction before following @code{CODE_LABEL} or
@en @code{NOTE_INSN_BASIC_BLOCK}.  A @code{CODE_LABEL} cannot appear in
@en the instruction stream of a basic block.
对于RTL，这些指针是@code{rtx head, end}。在RTL函数表示中，头指针总是指向@code{NOTE_INSN_BASIC_BLOCK}或者@code{CODE_LABEL}。在RTL函数表示中，指令流不仅包含“真正”的指令，而且还有注解（@dfn{notes}）。任何移动或者复制基本块的函数都需要注意更新这些注解。许多这些注解都期望指令流是由线性区域组成的，所以这使得更新比较困难。@code{NOTE_INSN_BASIC_BLOCK}是唯一可以出现在基本块内指令流中的注解。一个基本块的指令流总是跟随一个@code{NOTE_INSN_BASIC_BLOCK}，但是基本块注解之前可以有0个或多个@code{CODE_LABEL}节点。基本块结束于一条控制流指令，或者后面是紧随@code{CODE_LABEL}或者@code{NOTE_INSN_BASIC_BLOCK}的最后一条指令。@code{CODE_LABEL}不能出现在基本块中的指令流里。

@findex can_fallthru
@cindex table jump
@en In addition to notes, the jump table vectors are also represented as
@en ``pseudo-instructions'' inside the insn stream.  These vectors never
@en appear in the basic block and should always be placed just after the
@en table jump instructions referencing them.  After removing the
@en table-jump it is often difficult to eliminate the code computing the
@en address and referencing the vector, so cleaning up these vectors is
@en postponed until after liveness analysis.   Thus the jump table vectors
@en may appear in the insn stream unreferenced and without any purpose.
@en Before any edge is made @dfn{fall-thru}, the existence of such
@en construct in the way needs to be checked by calling
@en @code{can_fallthru} function.
除了注解之外，跳转表向量也被表示为insn流中的“伪指令”。这些向量从不出现在基本块中，并应该总是被放在引用它们的表跳转指令（tabel jump instructions）的后面。在移除table-jump之后，通常很难消除计算地址和引用向量的代码，所以对这些向量的清除工作被推迟到活跃分析之后。这样，跳转表向量可能会在insn流中出现，但未被引用，没有任何用图。在将任何边（edge）作为@dfn{fall-thru}之前，都需要调用@code{can_fallthru}函数来检查这种构造方式是否可以。

@cindex block statement iterators
@en For the @code{tree} representation, the head and end of the basic block
@en are being pointed to by the @code{stmt_list} field, but this special
@en @code{tree} should never be referenced directly.  Instead, at the tree
@en level abstract containers and iterators are used to access statements
@en and expressions in basic blocks.  These iterators are called
@en @dfn{block statement iterators} (BSIs).  Grep for @code{^bsi}
@en in the various @file{tree-*} files.
@en The following snippet will pretty-print all the statements of the
@en program in the GIMPLE representation.
对于@code{tree}表示，基本块的头和尾由@code{stmt_list}域指向。但是，不要直接引用这些特定的@code{tree}。替代的，在树级别上，使用抽象容器和迭代器来访问基本块中的语句和表达式。这些迭代器被称作块语句迭代器（@dfn{block statement iterators}, BSI）。可以在各种@file{tree-*}文件中使用grep来查找@code{^bsi}。下面的片段可以打印（pretty-print）使用GIMPLE表示的所有程序语句。

@smallexample
FOR_EACH_BB (bb)
  @{
     block_stmt_iterator si;

     for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))
       @{
          tree stmt = bsi_stmt (si);
          print_generic_stmt (stderr, stmt, 0);
       @}
  @}
@end smallexample


@en @node Edges
@en @section Edges
@node Edges
@section 边

@cindex edge in the flow graph
@findex edge
@en Edges represent possible control flow transfers from the end of some
@en basic block A to the head of another basic block B@.  We say that A is
@en a predecessor of B, and B is a successor of A@.  Edges are represented
@en in GCC with the @code{edge} data type.  Each @code{edge} acts as a
@en link between two basic blocks: the @code{src} member of an edge
@en points to the predecessor basic block of the @code{dest} basic block.
@en The members @code{preds} and @code{succs} of the @code{basic_block} data
@en type point to type-safe vectors of edges to the predecessors and
@en successors of the block.
边表示从某个基本块A的结束到另一个基本块B的开头的可能的控制流转换。我们称A是B的前驱，B是A的后继。在GCC中，边由@code{edge}数据类型表示。每个@code{edge}作为两个基本块之间的链接：@code{edge}的@code{src}成员指向@code{dest}的前驱基本块。数据类型@code{basic_block}的成员@code{preds}和@code{succs}，指向块的前驱边向量和后继边向量。

@cindex edge iterators
@en When walking the edges in an edge vector, @dfn{edge iterators} should
@en be used.  Edge iterators are constructed using the
@en @code{edge_iterator} data structure and several methods are available
@en to operate on them:
当在一个边向量中访问边时，应该使用边迭代器。边迭代器由@code{edge_iterator}数据结构和一些可以使用的操作构成：

@ftable @code
@item ei_start
@en This function initializes an @code{edge_iterator} that points to the
@en first edge in a vector of edges.
该函数初始化一个指向边向量中第一个边的@code{edge_iterator}。

@item ei_last
@en This function initializes an @code{edge_iterator} that points to the
@en last edge in a vector of edges.
该函数初始化一个指向边向量中最后一个边的@code{edge_iterator}。

@item ei_end_p
@en This predicate is @code{true} if an @code{edge_iterator} represents
@en the last edge in an edge vector.
如果@code{edge_iterator}表示边向量中的最后一个边，则该断言为@code{true}。 

@item ei_one_before_end_p
@en This predicate is @code{true} if an @code{edge_iterator} represents
@en the second last edge in an edge vector.
如果@code{edge_iterator}表示边向量中的倒数第二个边，则该断言为@code{true}。

@item ei_next
@en This function takes a pointer to an @code{edge_iterator} and makes it
@en point to the next edge in the sequence.
该函数接受一个指向@code{edge_iterator}的指针，并使其指向序列中的下一个边。 

@item ei_prev
@en This function takes a pointer to an @code{edge_iterator} and makes it
@en point to the previous edge in the sequence.
该函数接受一个指向@code{edge_iterator}的指针，并使其指向序列中的上一个边。 

@item ei_edge
@en This function returns the @code{edge} currently pointed to by an
@en @code{edge_iterator}.
该函数返回由@code{edge_iterator}当前指向的@code{edge}。 

@item ei_safe_safe
@en This function returns the @code{edge} currently pointed to by an
@en @code{edge_iterator}, but returns @code{NULL} if the iterator is
@en pointing at the end of the sequence.  This function has been provided
@en for existing code makes the assumption that a @code{NULL} edge
@en indicates the end of the sequence.
该函数返回由@code{edge_iterator}当前指向的@code{edge}，但是如果迭代器指向序列的结尾时，则返回@code{NULL}。该函数是为现有的代码提供的，这些代码假设用@code{NULL}边来表示序列的结尾。
@end ftable

@en The convenience macro @code{FOR_EACH_EDGE} can be used to visit all of
@en the edges in a sequence of predecessor or successor edges.  It must
@en not be used when an element might be removed during the traversal,
@en otherwise elements will be missed.  Here is an example of how to use
@en the macro:
宏@code{FOR_EACH_EDGE}可以方便的用来访问前驱边或后继边序列。当在遍历中会移除掉某个元素时，不要使用该宏，否则会错过这些元素。这里有一个如何使用该宏的例子：

@smallexample
edge e;
edge_iterator ei;

FOR_EACH_EDGE (e, ei, bb->succs)
  @{
     if (e->flags & EDGE_FALLTHRU)
       break;
  @}
@end smallexample

@findex fall-thru
@en There are various reasons why control flow may transfer from one block
@en to another.  One possibility is that some instruction, for example a
@en @code{CODE_LABEL}, in a linearized instruction stream just always
@en starts a new basic block.  In this case a @dfn{fall-thru} edge links
@en the basic block to the first following basic block.  But there are
@en several other reasons why edges may be created.  The @code{flags}
@en field of the @code{edge} data type is used to store information
@en about the type of edge we are dealing with.  Each edge is of one of
@en the following types:
有许多原因会导致控制流从一个块传递到另一个。一种可能是某条指令，例如@code{CODE_LABEL}，在线形的指令流中，总是起始一个新基本块。在这种情况下，一个@dfn{fall-thru}边将基本块与随后的第一个基本块相连。不过还有许多其它原因会导致边被创建。@code{edge}数据类型的@code{flags}域用于存储我们正在处理的边的类型信息。每个边都具有下列类型之一：

@table @emph
@item jump
@en No type flags are set for edges corresponding to jump instructions.
@en These edges are used for unconditional or conditional jumps and in
@en RTL also for table jumps.  They are the easiest to manipulate as they
@en may be freely redirected when the flow graph is not in SSA form.
与跳转指令相关的边没有被设置类型标识。这些边用于无条件或有条件跳转，以及RTL中还有表跳转。它们是最容易操作的，因为当流图不为SSA形式的时候，可以自由重定向。 

@item fall-thru
@findex EDGE_FALLTHRU, force_nonfallthru
@en Fall-thru edges are present in case where the basic block may continue
@en execution to the following one without branching.  These edges have
@en the @code{EDGE_FALLTHRU} flag set.  Unlike other types of edges, these
@en edges must come into the basic block immediately following in the
@en instruction stream.  The function @code{force_nonfallthru} is
@en available to insert an unconditional jump in the case that redirection
@en is needed.  Note that this may require creation of a new basic block.
@en Fall-thru边存在于当基本块不需要分支而是继续执行随后的块的时候。
这些边的标志设为@code{EDGE_FALLTHRU}。不像其它类型的边，这些边必须直接进入基本块的指令流中。函数@code{force_nonfallthru}可以用于在需要重定向时插入一个无条件跳转。注意这可能需要创建一个新基本块。

@item exception handling
@cindex exception handling
@findex EDGE_ABNORMAL, EDGE_EH
@en Exception handling edges represent possible control transfers from a
@en trapping instruction to an exception handler.  The definition of
@en ``trapping'' varies.  In C++, only function calls can throw, but for
@en Java, exceptions like division by zero or segmentation fault are
@en defined and thus each instruction possibly throwing this kind of
@en exception needs to be handled as control flow instruction.  Exception
@en edges have the @code{EDGE_ABNORMAL} and @code{EDGE_EH} flags set.
异常处理边表示可能的控制转移，从一个陷门指令到一个异常处理器。
关于“trapping”定义不尽相同。在C++中，只有函数调用能够抛出异常，
但是对于Java，像除0或者段错误都被定义为异常，
并且因此每条指令都可能抛出这种需要处理的异常。
异常边设置了@code{EDGE_ABNORMAL}和@code{EDGE_EH}标识。

@findex purge_dead_edges
@en When updating the instruction stream it is easy to change possibly
@en trapping instruction to non-trapping, by simply removing the exception
@en edge.  The opposite conversion is difficult, but should not happen
@en anyway.  The edges can be eliminated via @code{purge_dead_edges} call.
当更新指令流时，能够容易的将可能trapping的指令转换成non-traaping，
通过简单的将异常边移除。相反的转换比较困难，但是是不会发生的。
可以通过调用@code{purge_dead_edges}来消除边。

@findex REG_EH_REGION, EDGE_ABNORMAL_CALL
@en In the RTL representation, the destination of an exception edge is
@en specified by @code{REG_EH_REGION} note attached to the insn.
@en In case of a trapping call the @code{EDGE_ABNORMAL_CALL} flag is set
@en too.  In the @code{tree} representation, this extra flag is not set.
在RTL表示中，异常边的目的地由附加在insn上的注解@code{REG_EH_REGION}来指定。
在trapping调用的情况下，还设置了@code{EDGE_ABNORMAL_CALL}标识。
在@code{tree}表示中，该额外的标识没有被设置。

@findex may_trap_p, tree_could_trap_p
@en In the RTL representation, the predicate @code{may_trap_p} may be used
@en to check whether instruction still may trap or not.  For the tree
@en representation, the @code{tree_could_trap_p} predicate is available,
@en but this predicate only checks for possible memory traps, as in
@en dereferencing an invalid pointer location.
在RTL表示中，断言@code{may_trap_p}可以用来检测指令是否还可能trap。
对于tree表示，可以用@code{tree_could_trap_p}，
不过该断言只检测可能的内存trap，像在废除一个无效的指针地址。

@item sibling calls
@cindex sibling call
@findex EDGE_ABNORMAL, EDGE_SIBCALL
@en Sibling calls or tail calls terminate the function in a non-standard
@en way and thus an edge to the exit must be present.
@en @code{EDGE_SIBCALL} and @code{EDGE_ABNORMAL} are set in such case.
@en These edges only exist in the RTL representation.
兄弟调用或者尾调用以非标准的方式终止函数，
并且因此必须存在一个引向出口的边。
@code{EDGE_SIBCALL}和@code{EDGE_ABNORMAL}在这种情况下被设置。
这些边只存在于RTL表示中。 

@item computed jumps
@cindex computed jump
@findex EDGE_ABNORMAL
@en Computed jumps contain edges to all labels in the function referenced
@en from the code.  All those edges have @code{EDGE_ABNORMAL} flag set.
@en The edges used to represent computed jumps often cause compile time
@en performance problems, since functions consisting of many taken labels
@en and many computed jumps may have @emph{very} dense flow graphs, so
@en these edges need to be handled with special care.  During the earlier
@en stages of the compilation process, GCC tries to avoid such dense flow
@en graphs by factoring computed jumps.  For example, given the following
@en series of jumps,
计算跳转包含了引向函数中代码引用的所有标号的边。
所有这些边都设置了@code{EDGE_ABNORMAL}标识。
用来表示计算跳转的边通常会造成编译时间性能问题，
因为函数有许多标号组成，许多计算跳转可能具有密集的流图，
所以这些边需要特别仔细的处理。在编译过程的早期阶段，
GCC尝试避免这样的密集流图，通过因子化计算跳转。
例如，给定下列跳转， 

@smallexample
  goto *x;
  [ @dots{} ]

  goto *x;
  [ @dots{} ]

  goto *x;
  [ @dots{} ]
@end smallexample

@noindent
@en factoring the computed jumps results in the following code sequence
@en which has a much simpler flow graph:
将计算跳转提取公因子，会产生具有比较简单流图的代码序列：

@smallexample
  goto y;
  [ @dots{} ]

  goto y;
  [ @dots{} ]

  goto y;
  [ @dots{} ]

y:
  goto *x;
@end smallexample

@en However, the classic problem with this transformation is that it has a
@en runtime cost in there resulting code: An extra jump.  Therefore, the
@en computed jumps are un-factored in the later passes of the compiler.
@en Be aware of that when you work on passes in that area.  There have
@en been numerous examples already where the compile time for code with
@en unfactored computed jumps caused some serious headaches.
但是，这种转换的典型问题是产生的结果代码具有运行时代价：
一个额外的跳转。因此计算跳转在编译器之后的过程里被un-factored。
当你工作于这些过程上时，需要注意。曾有许多已存的例子，
即对未公因子化的计算跳转编译时造成的头痛之事。

@item nonlocal goto handlers
@cindex nonlocal goto handler
@findex EDGE_ABNORMAL, EDGE_ABNORMAL_CALL
@en GCC allows nested functions to return into caller using a @code{goto}
@en to a label passed to as an argument to the callee.  The labels passed
@en to nested functions contain special code to cleanup after function
@en call.  Such sections of code are referred to as ``nonlocal goto
@en receivers''.  If a function contains such nonlocal goto receivers, an
@en edge from the call to the label is created with the
@en @code{EDGE_ABNORMAL} and @code{EDGE_ABNORMAL_CALL} flags set.
GCC允许嵌套函数使用@code{goto}到一个通过参数传给被调用者的标号的方式来返回到调用者那里。
传给嵌套函数的标号包含了特定的代码用来在函数调用之后进行清理工作。
这段代码被称为“nonlocal goto receivers”。
如果一个函数包含这样的非局部goto接受者，一个从调用到标号的边被创建，
并设置了@code{EDGE_ABNORMAL}和@code{EDGE_ABNORMAL_CALL}标识。

@item function entry points
@cindex function entry point, alternate function entry point
@findex LABEL_ALTERNATE_NAME
@en By definition, execution of function starts at basic block 0, so there
@en is always an edge from the @code{ENTRY_BLOCK_PTR} to basic block 0.
@en There is no @code{tree} representation for alternate entry points at
@en this moment.  In RTL, alternate entry points are specified by
@en @code{CODE_LABEL} with @code{LABEL_ALTERNATE_NAME} defined.  This
@en feature is currently used for multiple entry point prologues and is
@en limited to post-reload passes only.  This can be used by back-ends to
@en emit alternate prologues for functions called from different contexts.
@en In future full support for multiple entry functions defined by Fortran
@en 90 needs to be implemented.
根据定义，函数执行起始于基本块0，所以总有一个边从@code{ENTRY_BLOCK_PTR}到基本块0。目前，对备用入口点没有@code{tree}表示。在RTL里，备用入口点通过定义了@code{LABEL_ALTERNATE_NAME}的@code{CODE_LABEL}指定。这能够被后端用于为通过不同上下文调用函数而生成备用prologues。将来，Fortran90定义的多入口函数的完全支持需要被实现。

@item function exits
@en In the pre-reload representation a function terminates after the last
@en instruction in the insn chain and no explicit return instructions are
@en used.  This corresponds to the fall-thru edge into exit block.  After
@en reload, optimal RTL epilogues are used that use explicit (conditional)
@en return instructions that are represented by edges with no flags set.
在pre-reload表示中，函数终止于insn链中的最后一条指令，并且没有显式的返回指令。标记对应于进入出口块的fall-thru边。reload之后，最佳的RTL结尾部分（epilogues）会被使用，其会使用显式的（有条件的）返回指令，并使用没有标记设置的边来表示。
@end table


@en @node Profile information
@en @section Profile information
@node Profile information
@section Profile信息

@cindex profile representation
@en In many cases a compiler must make a choice whether to trade speed in
@en one part of code for speed in another, or to trade code size for code
@en speed.  In such cases it is useful to know information about how often
@en some given block will be executed.  That is the purpose for
@en maintaining profile within the flow graph.
@en GCC can handle profile information obtained through @dfn{profile
@en feedback}, but it can also  estimate branch probabilities based on
@en statics and heuristics.
在许多情况下，编译器必须对是否由一块代码的速度来换取另一块的速度，
或者由代码的大小来换取速度，来作出选择。这种情况下，
知道给定块将会被执行几次这样的信息会很有帮助。
这就是在流程图中维护profile的目的。
GCC能够处理通过@dfn{profile feedback}获得的profile信息，
但也能够根据统计和启发来估计分支跳转的可能性。

@cindex profile feedback
@en The feedback based profile is produced by compiling the program with
@en instrumentation, executing it on a train run and reading the numbers
@en of executions of basic blocks and edges back to the compiler while
@en re-compiling the program to produce the final executable.  This method
@en provides very accurate information about where a program spends most
@en of its time on the train run.  Whether it matches the average run of
@en course depends on the choice of train data set, but several studies
@en have shown that the behavior of a program usually changes just
@en marginally over different data sets.
基于反馈的profile是通过编译测量程序来产生的，在训练运行中执行，
并且在重新编译程序产生最终可执行程序时，读取基本块和边的执行数目。
该方法使得程序花费大量的时间在训练运行上，从而提供了非常精确的信息。
信息是否匹配平均运行取决于选择的训练数据集，
但是个别研究表现程序的行为通常会由于稍微不同的数据集就会变化。

@cindex Static profile estimation
@cindex branch prediction
@findex predict.def
@en When profile feedback is not available, the compiler may be asked to
@en attempt to predict the behavior of each branch in the program using a
@en set of heuristics (see @file{predict.def} for details) and compute
@en estimated frequencies of each basic block by propagating the
@en probabilities over the graph.
当profile反馈不可用时，编译器可以被请求尝试使用heuristics集
（详情参见@file{predict.def}）来进行预测程序中每个分支的行为，
并且通过在图中传播可能性来计算每个基本块的评估频率。

@findex frequency, count, BB_FREQ_BASE
@en Each @code{basic_block} contains two integer fields to represent
@en profile information: @code{frequency} and @code{count}.  The
@en @code{frequency} is an estimation how often is basic block executed
@en within a function.  It is represented as an integer scaled in the
@en range from 0 to @code{BB_FREQ_BASE}.  The most frequently executed
@en basic block in function is initially set to @code{BB_FREQ_BASE} and
@en the rest of frequencies are scaled accordingly.  During optimization,
@en the frequency of the most frequent basic block can both decrease (for
@en instance by loop unrolling) or grow (for instance by cross-jumping
@en optimization), so scaling sometimes has to be performed multiple
@en times.
每个@code{basic_block}包含两个整数域来表示profile信息：
@code{frequency}和@code{count}。
@code{frequency}是对函数中的基本块每隔多久被执行的评估。
其被表示为一个整数标量，范围从0到@code{BB_FREQ_BASE}。
函数中执行频率最高的基本块被初始化为@code{BB_FREQ_BASE}，
其余的frequency相应的进行刻画。优化过程中，
执行频率最高的基本块的frequency能够减少（例如由循环展开造成的）
或增加（例如由交叉跳转优化造成的），所以有时需要执行多次度量。

@findex gcov_type
@en The @code{count} contains hard-counted numbers of execution measured
@en during training runs and is nonzero only when profile feedback is
@en available.  This value is represented as the host's widest integer
@en (typically a 64 bit integer) of the special type @code{gcov_type}.
@code{count}包含了硬计数的执行数目，在训练运行中测算出的，
并且只有profile反馈可用时为非0。该值被表示为主机的宽整数
（一般为64位整数），特定类型@code{gcov_type}。

@en Most optimization passes can use only the frequency information of a
@en basic block, but a few passes may want to know hard execution counts.
@en The frequencies should always match the counts after scaling, however
@en during updating of the profile information numerical error may
@en accumulate into quite large errors.
大多数优化过程只能使用基本块的frequency信息，
但是一些过程可能想知道硬执行次数。在度量之后，频率应该总是匹配计数，
但是在更新profile信息的过程中，数值误差可能会积累到十分大的错误。

@findex REG_BR_PROB_BASE, EDGE_FREQUENCY
@en Each edge also contains a branch probability field: an integer in the
@en range from 0 to @code{REG_BR_PROB_BASE}.  It represents probability of
@en passing control from the end of the @code{src} basic block to the
@en @code{dest} basic block, i.e.@: the probability that control will flow
@en along this edge.   The @code{EDGE_FREQUENCY} macro is available to
@en compute how frequently a given edge is taken.  There is a @code{count}
@en field for each edge as well, representing same information as for a
@en basic block.
每个边还包含一个分支可能性域：
一个范围从0到@code{REG_BR_PROB_BASE}的整数。
其表示将控制从@code{src}基本块传递到@code{dest}基本块的可能性，
即控制流向该边的可能性。
@code{EDGE_FREQUENCY}宏可用于计算给定边会被接受的频率。
同时每个边还有一个@code{count}域，用来表示与基本块相同的信息。

@en The basic block frequencies are not represented in the instruction
@en stream, but in the RTL representation the edge frequencies are
@en represented for conditional jumps (via the @code{REG_BR_PROB}
@en macro) since they are used when instructions are output to the
@en assembly file and the flow graph is no longer maintained.
基本块频率不在指令流中表示，但是在RTL表示中，
边频率用来表示条件跳转（通过@code{REG_BR_PROB}宏），
因为它们用在将指令输出到汇编文件中的时候，并且流图不在被维护。

@cindex reverse probability
@en The probability that control flow arrives via a given edge to its
@en destination basic block is called @dfn{reverse probability} and is not
@en directly represented, but it may be easily computed from frequencies
@en of basic blocks.
控制流通过给定边到达目的基本块的可能性被称作反向可能性，
并且没有直接表示，但是可以容易的从基本块的频率中计算获得。

@findex redirect_edge_and_branch
@en Updating profile information is a delicate task that can unfortunately
@en not be easily integrated with the CFG manipulation API@.  Many of the
@en functions and hooks to modify the CFG, such as
@en @code{redirect_edge_and_branch}, do not have enough information to
@en easily update the profile, so updating it is in the majority of cases
@en left up to the caller.  It is difficult to uncover bugs in the profile
@en updating code, because they manifest themselves only by producing
@en worse code, and checking profile consistency is not possible because
@en of numeric error accumulation.  Hence special attention needs to be
@en given to this issue in each pass that modifies the CFG@.
不幸的是，更新profile信息是一个精致的任务，
这使得很难集成到CFG操作API中。许多修改CFG的函数和钩子，
像@code{redirect_edge_and_branch}，
都不具有足够的信息来容易的修改profile，
所以更新多半情况是留给调用者的。很难找到profile更新代码中的bug，
因为它们只是体现在产生了更糟的代码，
并且检测profile一致性是不可能的，因为数值误差积累。
因此在每个修改CFG的过程中，应该特别注意这个问题。

@findex REG_BR_PROB_BASE, BB_FREQ_BASE, count
@en It is important to point out that @code{REG_BR_PROB_BASE} and
@en @code{BB_FREQ_BASE} are both set low enough to be possible to compute
@en second power of any frequency or probability in the flow graph, it is
@en not possible to even square the @code{count} field, as modern CPUs are
@en fast enough to execute $2^32$ operations quickly.
必须指出@code{REG_BR_PROB_BASE}和@code{BB_FREQ_BASE}被设为足够低，
才有可能在流图中计算任何频率或可能性作为指数的2的幂运算。

@en @node Maintaining the CFG
@en @section Maintaining the CFG
@node Maintaining the CFG
@section 维护CFG
@findex cfghooks.h

@en An important task of each compiler pass is to keep both the control
@en flow graph and all profile information up-to-date.  Reconstruction of
@en the control flow graph after each pass is not an option, since it may be
@en very expensive and lost profile information cannot be reconstructed at
@en all.
每个编译器过程都具有的一个重要任务是保持控制流图和所有profile信息更新。
在每个过程之后都重建控制流图是不可能的，因为这样代价会很高，
而且丢失的profile信息是根本无法重建的。

@en GCC has two major intermediate representations, and both use the
@en @code{basic_block} and @code{edge} data types to represent control
@en flow.  Both representations share as much of the CFG maintenance code
@en as possible.  For each representation, a set of @dfn{hooks} is defined
@en so that each representation can provide its own implementation of CFG
@en manipulation routines when necessary.  These hooks are defined in
@en @file{cfghooks.h}.  There are hooks for almost all common CFG
@en manipulations, including block splitting and merging, edge redirection
@en and creating and deleting basic blocks.  These hooks should provide
@en everything you need to maintain and manipulate the CFG in both the RTL
@en and @code{tree} representation.
GCC有两个主要的中间表示，
并且它们都使用@code{basic_block}和@code{edge}数据类型来表示控制流。
两种表示都尽可能多的共享CFG维护的代码。对于每一种表示，
都定义了一套@dfn{hooks}，以便于需要的时候可以提供自己的CFG维护函数的实现。
这些钩子定义在@file{cfghooks.h}中。这些钩子提供了几乎所有普通的CFG操作，
包括块分割和合并，边重定向，以及创建和删除基本块。
这些钩子应该提供所有需要的维护和操作RTL和@code{tree}表示下的CFG。

@en At the moment, the basic block boundaries are maintained transparently
@en when modifying instructions, so there rarely is a need to move them
@en manually (such as in case someone wants to output instruction outside
@en basic block explicitly).
@en Often the CFG may be better viewed as integral part of instruction
@en chain, than structure built on the top of it.  However, in principle
@en the control flow graph for the @code{tree} representation is
@en @emph{not} an integral part of the representation, in that a function
@en tree may be expanded without first building a  flow graph for the
@en @code{tree} representation at all.  This happens when compiling
@en without any @code{tree} optimization enabled.  When the @code{tree}
@en optimizations are enabled and the instruction stream is rewritten in
@en SSA form, the CFG is very tightly coupled with the instruction stream.
@en In particular, statement insertion and removal has to be done with
@en care.  In fact, the whole @code{tree} representation can not be easily
@en used or maintained without proper maintenance of the CFG
@en simultaneously.
目前，基本块的边界在修改指令时会被透明的维护，因此很少需要手动移动它们
（比如当有人想要显式的输出基本块外面的指令的时候）。
将CFG看作指令链的组成部分，比看作建立在之上的结构，往往要更好些。
但是原则上，对于树表示的控制流图并不是数表示的必须部分。
函数树可以在不需要首先创建树表示的流图的情况下就被扩展。
这种情况在没有进行任何树优化的编译时会发生。当进行树优化时，
并且指令流被重写为SSA形式，CFG就和指令流非常紧密的联系起来了。
特别在语句插入和移除时要注意。实际上，如果没有同时对CFG进行恰当的维护，
整个树表示就很难使用和维护。

@findex BLOCK_FOR_INSN, bb_for_stmt
@en In the RTL representation, each instruction has a
@en @code{BLOCK_FOR_INSN} value that represents pointer to the basic block
@en that contains the instruction.  In the @code{tree} representation, the
@en function @code{bb_for_stmt} returns a pointer to the basic block
@en containing the queried statement.
在RTL表示里，每条指令有一个@code{BLOCK_FOR_INSN}值用来表示指向包含该指令的基本块。
在@code{tree}表示里，函数@code{bb_for_stmt}返回一个指向包含所查询语句的基本块。

@cindex block statement iterators
@en When changes need to be applied to a function in its @code{tree}
@en representation, @dfn{block statement iterators} should be used.  These
@en iterators provide an integrated abstraction of the flow graph and the
@en instruction stream.  Block statement iterators are constructed using
@en the @code{block_stmt_iterator} data structure and several modifier are
@en available, including the following:
在@code{tree}表示里，当需要对函数进行改动时，
应该使用块语句迭代器（@dfn{block statement iterators}）。
这些迭代器提供了流程图和指令流的整体抽象。
块语句迭代器由@code{block_stmt_iterator}数据结构和一些修改函数构成，
包括下面的：

@ftable @code
@item bsi_start
@en This function initializes a @code{block_stmt_iterator} that points to
@en the first non-empty statement in a basic block.
该函数初始化一个@code{block_stmt_iterator}，使其指向基本块中第一条非空语句。 

@item bsi_last
@en This function initializes a @code{block_stmt_iterator} that points to
@en the last statement in a basic block.
该函数初始化一个@code{block_stmt_iterator}，使其指向基本块中最后一条语句。

@item bsi_end_p
@en This predicate is @code{true} if a @code{block_stmt_iterator}
@en represents the end of a basic block.
如果@code{block_stmt_iterator}表示基本块的结束，则为@code{true}。

@item bsi_next
@en This function takes a @code{block_stmt_iterator} and makes it point to
@en its successor.
该函数接受一个@code{block_stmt_iterator}，并使其指向它的后继。

@item bsi_prev
@en This function takes a @code{block_stmt_iterator} and makes it point to
@en its predecessor.
该函数接受一个@code{block_stmt_iterator}，并使其指向它的前驱。

@item bsi_insert_after
@en This function inserts a statement after the @code{block_stmt_iterator}
@en passed in.  The final parameter determines whether the statement
@en iterator is updated to point to the newly inserted statement, or left
@en pointing to the original statement.
该函数在@code{block_stmt_iterator}所在位置之后插入一条语句。
最后一个参数决定是否将语句迭代器更新指向新插入的语句，
还是保留指向原来的语句。

@item bsi_insert_before
@en This function inserts a statement before the @code{block_stmt_iterator}
@en passed in.  The final parameter determines whether the statement
@en iterator is updated to point to the newly inserted statement, or left
@en pointing to the original  statement.
该函数在@code{block_stmt_iterator}所在位置之前插入一条语句。
最后一个参数决定是否将语句迭代器更新指向新插入的语句，
还是保留指向原来的语句。

@item bsi_remove
@en This function removes the @code{block_stmt_iterator} passed in and
@en rechains the remaining statements in a basic block, if any.
该函数移除@code{block_stmt_iterator}所在位置的语句，
并且如果基本块中还有语句，则将剩余的语句重新链接。 
@end ftable

@findex BB_HEAD, BB_END
@en In the RTL representation, the macros @code{BB_HEAD} and @code{BB_END}
@en may be used to get the head and end @code{rtx} of a basic block.  No
@en abstract iterators are defined for traversing the insn chain, but you
@en can just use @code{NEXT_INSN} and @code{PREV_INSN} instead.  See
@en @xref{Insns}.
在RTL表示里，宏@code{BB_HEAD}和@code{BB_END}可以用来获得基本块的
起始@code{rtx}和结束@code{rtx}。没有抽象迭代器被定义用来遍历insn链，
不过可以使用@code{NEXT_INSN}和@code{PREV_INSN}替代。参见 @ref{Insns}。

@findex purge_dead_edges
@en Usually a code manipulating pass simplifies the instruction stream and
@en the flow of control, possibly eliminating some edges.  This may for
@en example happen when a conditional jump is replaced with an
@en unconditional jump, but also when simplifying possibly trapping
@en instruction to non-trapping while compiling Java.  Updating of edges
@en is not transparent and each optimization pass is required to do so
@en manually.  However only few cases occur in practice.  The pass may
@en call @code{purge_dead_edges} on a given basic block to remove
@en superfluous edges, if any.
通常一个代码操作过程将会简化指令流和控制流，也可能消除一些边。
例如当一个条件跳转被替换为非条件跳转，甚至在编译java时，
将可能的trapping指令简化为non-trapping。边的更新是不透明的，
每个优化过程都要求手动进行。不过，实际中这种情况很少发生。如果存在的话，
过程可以针对给定的基本块调用@code{purge_dead_edges}来移除多余的边。

@findex redirect_edge_and_branch, redirect_jump
@en Another common scenario is redirection of branch instructions, but
@en this is best modeled as redirection of edges in the control flow graph
@en and thus use of @code{redirect_edge_and_branch} is preferred over more
@en low level functions, such as @code{redirect_jump} that operate on RTL
@en chain only.  The CFG hooks defined in @file{cfghooks.h} should provide
@en the complete API required for manipulating and maintaining the CFG@.
另一个常见的情景是分支指令的重定向。
不过由于可以非常好的建模为控制流图里的边重定向，
因此应尽量使用@code{redirect_edge_and_branch}，而不是其它底层函数，
例如只是操作RTL链的@code{redirect_jump}。
定义在@file{cfghooks.h}中的CFG钩子应该提供了操作和维护CFG所需要的全部API。

@findex split_block
@en It is also possible that a pass has to insert control flow instruction
@en into the middle of a basic block, thus creating an entry point in the
@en middle of the basic block, which is impossible by definition: The
@en block must be split to make sure it only has one entry point, i.e.@: the
@en head of the basic block.  The CFG hook @code{split_block} may be used
@en when an instruction in the middle of a basic block has to become the
@en target of a jump or branch instruction.
有时候，一个过程可能不得不要向基本块的中间插入控制流指令，这样的话，
就在基本块中间产生一个入口点。根据定义，这是不可能的，
因此必须要将块分开以确保只含有一个入口点，也就是基本块的头。
当基本块中间的指令必须成为跳转或分支指令的目标时，
可以使用CFG钩子@code{split_block}。

@findex insert_insn_on_edge
@findex commit_edge_insertions
@findex bsi_insert_on_edge
@findex bsi_commit_edge_inserts
@cindex edge splitting
@en For a global optimizer, a common operation is to split edges in the
@en flow graph and insert instructions on them.  In the RTL
@en representation, this can be easily done using the
@en @code{insert_insn_on_edge} function that emits an instruction
@en ``on the edge'', caching it for a later @code{commit_edge_insertions}
@en call that will take care of moving the inserted instructions off the
@en edge into the instruction stream contained in a basic block.  This
@en includes the creation of new basic blocks where needed.  In the
@en @code{tree} representation, the equivalent functions are
@en @code{bsi_insert_on_edge} which inserts a block statement
@en iterator on an edge, and @code{bsi_commit_edge_inserts} which flushes
@en the instruction to actual instruction stream.
对一个全局优化，一个常用的操作是在流图中将边拆分，并插入指令。
在RTL表示里，可以很容易的实现，
通过使用@code{insert_insn_on_edge}函数来生成一条暂存的“on the edge”指令，
以便之后的@code{commit_edge_insertions}调用来将插入的指令从边上移到基本块的指令流里。
如果需要的话，还会生成新的基本块。在@code{tree}表示里，
等价的函数为@code{bsi_insert_on_edge}，用来在边上插入一个块语句迭代器，
以及@code{bsi_commit_edge_inserts}，将指令挪到实际的指令流里。

@en While debugging the optimization pass, a @code{verify_flow_info}
@en function may be useful to find bugs in the control flow graph updating
@en code.
在调试优化过程时，
函数@code{verify_flow_info}可能有助于发现在控制流图的更新代码中的bug。

@en Note that at present, the representation of control flow in the
@en @code{tree} representation is discarded before expanding to RTL@.
@en Long term the CFG should be maintained and ``expanded'' to the
@en RTL representation along with the function @code{tree} itself.
注意，目前在由树的表示扩展到RTL时，控制流的表示会被丢弃。
长远的看，CFG应给被维持并随着函数树本身被扩展到RTL表示。

@en @node Liveness information
@en @section Liveness information
@node Liveness information
@section 活跃信息
@cindex Liveness representation
@en Liveness information is useful to determine whether some register is
@en ``live'' at given point of program, i.e.@: that it contains a value that
@en may be used at a later point in the program.  This information is
@en used, for instance, during register allocation, as the pseudo
@en registers only need to be assigned to a unique hard register or to a
@en stack slot if they are live.  The hard registers and stack slots may
@en be freely reused for other values when a register is dead.  
活跃信息有助于确定某个寄存器在程序的给定点是否是“活跃”的，即其包含的值可能在之后的地方被使用。例如，这些信息会在寄存器分配中被用到，因为伪寄存器只有在活跃的时候才需要被分配给唯一的硬件寄存器或者栈槽。当寄存器是“死”的时候，硬件寄存器和栈槽则可以被自如的重用于其它值。

@en Liveness information is available in the back end starting with
@en @code{pass_df_initialize} and ending with @code{pass_df_finish}.  Three
@en flavors of live analysis are available: With @code{LR}, it is possible
@en to determine at any point @code{P} in the function if the register may be
@en used on some path from @code{P} to the end of the function.  With
@en @code{UR}, it is possible to determine if there is a path from the
@en beginning of the function to @code{P} that defines the variable.  
@en @code{LIVE} is the intersection of the @code{LR} and @code{UR} and a
@en variable is live at @code{P} if there is both an assignment that reaches
@en it from the beginning of the function and a use that can be reached on
@en some path from @code{P} to the end of the function.
从@code{pass_df_initialize}起始到@code{pass_df_finish}结束之间，活跃信息在后端是有效的。有三种活跃分析：@code{LR}，能够确定在函数的任意点@code{P}，寄存器是否会在从@code{P}到函数结束之间的某处被使用。@code{UR}，能够确定是否从函数的起始到P之间定义了变量。@code{LIVE}是@code{LR}和@code{UR}的交集，变量在@code{P}点是活跃的，如果同时从函数的开始到现在存在一个赋值，并且从@code{P}到函数的结束之间存在对其的使用。

@en In general @code{LIVE} is the most useful of the three.  The macros
@en @code{DF_[LR,UR,LIVE]_[IN,OUT]} can be used to access this information.
@en The macros take a basic block number and return a bitmap that is indexed
@en by the register number.  This information is only guaranteed to be up to
@en date after calls are made to @code{df_analyze}.  See the file
@en @code{df-core.c} for details on using the dataflow.  
通常这三种信息里，@code{LIVE}最有帮助。宏@code{DF_[LR,UR,LIVE]_[IN,OUT]}可以用来访问这些信息。这些宏接受一个基本块号，并返回一个以寄存器号为索引的位图。该信息只保证截至在调用@code{df_analyze}之后是最新的。关于使用数据流的详细信息参见@file{df-core.c}文件。

@findex REG_DEAD, REG_UNUSED
@en The liveness information is stored partly in the RTL instruction stream
@en and partly in the flow graph.  Local information is stored in the
@en instruction stream: Each instruction may contain @code{REG_DEAD} notes
@en representing that the value of a given register is no longer needed, or
@en @code{REG_UNUSED} notes representing that the value computed by the
@en instruction is never used.  The second is useful for instructions
@en computing multiple values at once.
活跃信息有一部分存储在RTL指令流里，一部分存储在流程图里。局部信息存在指令流中：每条指令可以包含@code{REG_DEAD}注解（note），来表示给定寄存器的值已经不再被需要了，或者@code{REG_UNUSED}注解，来表示由指令计算所得的值从来没有被使用。第二个可以有助于指令一次计算多值。

