<html lang="zh">
<head>
<title>Varargs - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="next" href="Trampolines.html#Trampolines" title="Trampolines">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Varargs"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Trampolines.html#Trampolines">Trampolines</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.11 实现Varargs宏</h3>

<p><a name="index-varargs-implementation-4228"></a>
<!-- GCC comes with an implementation of @code{<varargs.h>} and -->
<!-- @code{<stdarg.h>} that work without change on machines that pass arguments -->
<!-- on the stack.  Other machines require their own implementations of -->
<!-- varargs, and the two machine independent header files must have -->
<!-- conditionals to include it. -->
GCC自带了<code>&lt;varargs.h&gt;</code>和<code>&lt;stdarg.h&gt;</code>的实现，
可直接用于在栈上传递参数的机器上。其它机器需要它们自己的varargs实现，
并且两个机器独立的头文件必须条件包含它。

<!-- ISO @code{<stdarg.h>} differs from traditional @code{<varargs.h>} mainly in -->
<!-- the calling convention for @code{va_start}.  The traditional -->
<!-- implementation takes just one argument, which is the variable in which -->
<!-- to store the argument pointer.  The ISO implementation of -->
<!-- @code{va_start} takes an additional second argument.  The user is -->
<!-- supposed to write the last named argument of the function here. -->
 <p>ISO <code>&lt;stdarg.h&gt;</code>与传统<code>&lt;varargs.h&gt;</code>的区别主要在<code>va_start</code>的调用
约定上。传统的实现只接受一个参数，其为存储参数指针的变量。
ISO的实现接受额外的第二个参数。用户应该将函数的最后一个命名参数写在这里。

<!-- However, @code{va_start} should not use this argument.  The way to find -->
<!-- the end of the named arguments is with the built-in functions described -->
<!-- below. -->
 <p>然而，<code>va_start</code>不应该使用这个参数。
发现命名参数结尾的方法为使用下面描述的内建函数。

<div class="defun">
&mdash; Macro: <b>__builtin_saveregs</b> ()<var><a name="index-g_t_005f_005fbuiltin_005fsaveregs-4229"></a></var><br>
<blockquote><!-- Use this built-in function to save the argument registers in memory so -->
     <!-- that the varargs mechanism can access them.  Both ISO and traditional -->
     <!-- versions of @code{va_start} must use @code{__builtin_saveregs}, unless -->
     <!-- you use @code{TARGET_SETUP_INCOMING_VARARGS} (see below) instead. -->
      <p>使用该内建函数来将参数寄存器保存在内存中，使得varargs机制可以访问它们。
<code>va_start</code>的ISO版本和传统版本都必须使用<code>__builtin_saveregs</code>，
除非你使用<code>TARGET_SETUP_INCOMING_VARARGS</code>来替代（参见下面）。

     <!-- On some machines, @code{__builtin_saveregs} is open-coded under the -->
     <!-- control of the target hook @code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  On -->
     <!-- other machines, it calls a routine written in assembler language, -->
     <!-- found in @file{libgcc2.c}. -->
      <p>在一些机器上，<code>__builtin_saveregs</code>为开放编码的，
在target钩子<code>TARGET_EXPAND_BUILTIN_SAVEREGS</code>的控制下。
在其它机器上，其调用了汇编语言写的例程，可以在<samp><span class="file">libgcc2.c</span></samp>中找到。

     <!-- Code generated for the call to @code{__builtin_saveregs} appears at the -->
     <!-- beginning of the function, as opposed to where the call to -->
     <!-- @code{__builtin_saveregs} is written, regardless of what the code is. -->
     <!-- This is because the registers must be saved before the function starts -->
     <!-- to use them for its own purposes. -->
      <p>不管怎样，调用<code>__builtin_saveregs</code>的生成代码都出现在函数的起始处。
这是因为寄存器必须在函数开始使用它们前被保存。
<!-- i rewrote the first sentence above to fix an overfull hbox. -mew -->
<!-- 10feb93 -->
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>__builtin_next_arg</b> (<var>lastarg</var>)<var><a name="index-g_t_005f_005fbuiltin_005fnext_005farg-4230"></a></var><br>
<blockquote><!-- This builtin returns the address of the first anonymous stack -->
     <!-- argument, as type @code{void *}.  If @code{ARGS_GROW_DOWNWARD}, it -->
     <!-- returns the address of the location above the first anonymous stack -->
     <!-- argument.  Use it in @code{va_start} to initialize the pointer for -->
     <!-- fetching arguments from the stack.  Also use it in @code{va_start} to -->
     <!-- verify that the second parameter @var{lastarg} is the last named argument -->
     <!-- of the current function. -->
      <p>这与<code>__builtin_args_info</code>等价，用于栈参数。其返回第一个匿名栈参数的地址，
类型为<code>void *</code>。如果<code>ARGS_GROW_DOWNWARD</code>，
其返回第一个匿名栈参数的上面的位置地址。在<code>va_start</code>中使用它来初始化指针，
来从栈中获得参数。同样，在<code>va_start</code>中使用它来验证第二个参数<var>lastarg</var>
为当前函数的最后一个命名参数。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>__builtin_classify_type</b> (<var>object</var>)<var><a name="index-g_t_005f_005fbuiltin_005fclassify_005ftype-4231"></a></var><br>
<blockquote><!-- Since each machine has its own conventions for which data types are -->
     <!-- passed in which kind of register, your implementation of @code{va_arg} -->
     <!-- has to embody these conventions.  The easiest way to categorize the -->
     <!-- specified data type is to use @code{__builtin_classify_type} together -->
     <!-- with @code{sizeof} and @code{__alignof__}. -->
      <p>由于每个机器具有它自己的约定，对于哪些数据类型在哪种寄存器中传递，
因此你的<code>va_arg</code>实现必须包含这些约定。
将指定数据类型归类的最简单方法是使用<code>__builtin_classify_type</code>，
加上<code>sizeof</code>和<code>__alignof__</code>。

     <!-- @code{__builtin_classify_type} ignores the value of @var{object}, -->
     <!-- considering only its data type.  It returns an integer describing what -->
     <!-- kind of type that is-integer, floating, pointer, structure, and so on. -->
      <p><code>__builtin_classify_type</code>忽略<var>object</var>的值，只考虑它的数据类型。
其返回一个整数来描述什么类型为，整型，浮点，指针，结构体等。

     <!-- The file @file{typeclass.h} defines an enumeration that you can use to -->
     <!-- interpret the values of @code{__builtin_classify_type}. -->
      <p>文件<samp><span class="file">typeclass.h</span></samp>定义了一个枚举，
你可以用来解析<code>__builtin_classify_type</code>的值。
</p></blockquote></div>

<!-- These machine description macros help implement varargs: -->
 <p>这些机器描述宏用来帮助实现varargs：

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_EXPAND_BUILTIN_SAVEREGS</b> (<var>void</var>)<var><a name="index-TARGET_005fEXPAND_005fBUILTIN_005fSAVEREGS-4232"></a></var><br>
<blockquote><!-- If defined, this hook produces the machine-specific code for a call to -->
     <!-- @code{__builtin_saveregs}.  This code will be moved to the very -->
     <!-- beginning of the function, before any parameter access are made.  The -->
     <!-- return value of this function should be an RTX that contains the value -->
     <!-- to use as the return of @code{__builtin_saveregs}. -->
      <p>如果定义，该钩子产生机器特定代码，用于调用<code>__builtin_saveregs</code>。
该代码将被移动到函数的最开始处，在访问任何参数之前。
该函数的返回值应该为一个RTX，其包含了<code>__builtin_saveregs</code>的返回值。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_SETUP_INCOMING_VARARGS</b> (<var>cumulative_args_t args_so_far, enum machine_mode mode, tree type, int *pretend_args_size, int second_time</var>)<var><a name="index-TARGET_005fSETUP_005fINCOMING_005fVARARGS-4233"></a></var><br>
<blockquote><!-- This target hook offers an alternative to using -->
     <!-- @code{__builtin_saveregs} and defining the hook -->
     <!-- @code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  Use it to store the anonymous -->
     <!-- register arguments into the stack so that all the arguments appear to -->
     <!-- have been passed consecutively on the stack.  Once this is done, you can -->
     <!-- use the standard implementation of varargs that works for machines that -->
     <!-- pass all their arguments on the stack. -->
      <p>该target钩子提供了使用<code>__builtin_saveregs</code>和定义
<code>TARGET_EXPAND_BUILTIN_SAVEREGS</code>钩子的替代。
使用它来将匿名寄存器参数存储到栈中，使得所有参数都像是通过栈连续的传递。
当这样做时，你可以使用varargs的标准实现，其用于将所有参数在栈上传递的机器上。

     <!-- The argument @var{args_so_far} points to the @code{CUMULATIVE_ARGS} data -->
     <!-- structure, containing the values that are obtained after processing the -->
     <!-- named arguments.  The arguments @var{mode} and @var{type} describe the -->
     <!-- last named argument-its machine mode and its data type as a tree node. -->
      <p>参数<var>args_so_far</var>指向<code>CUMULATIVE_ARGS</code>数据结构体，
包含了处理完命名参数之后所获得的值。
参数<var>mode</var>和<var>type</var>描述了最后一个命名参数的机器模式和作为树结点的数据类型。

     <!-- The target hook should do two things: first, push onto the stack all the -->
     <!-- argument registers @emph{not} used for the named arguments, and second, -->
     <!-- store the size of the data thus pushed into the @code{int}-valued -->
     <!-- variable pointed to by @var{pretend_args_size}.  The value that you -->
     <!-- store here will serve as additional offset for setting up the stack -->
     <!-- frame. -->
      <p>该target钩子应该做两件事：第一，将所有不用于命名参数的参数寄存器压入栈中，
第二，存储数据的大小，把<var>pretend_args_size</var>指向的<code>int</code>值得变量压入。
这里你存储的值将作为额外的偏移量，用来建立栈帧。

     <!-- Because you must generate code to push the anonymous arguments at -->
     <!-- compile time without knowing their data types, -->
     <!-- @code{TARGET_SETUP_INCOMING_VARARGS} is only useful on machines that -->
     <!-- have just a single category of argument register and use it uniformly -->
     <!-- for all data types. -->
      <p>因为你必须生成代码来将匿名参数在编译时压入，而不需要知道它们的数据类型，
所以<code>TARGET_SETUP_INCOMING_VARARGS</code>只在只有一种参数寄存器类别并用于所有
数据类型的机器上有用。

     <!-- If the argument @var{second_time} is nonzero, it means that the -->
     <!-- arguments of the function are being analyzed for the second time.  This -->
     <!-- happens for an inline function, which is not actually compiled until the -->
     <!-- end of the source file.  The hook @code{TARGET_SETUP_INCOMING_VARARGS} should -->
     <!-- not generate any instructions in this case. -->
      <p>如果参数<var>second_time</var>非0，其以为着函数的参数被第二次分析。
这发生于内联函数，其直到源文件结尾才被实际编译。对于这种情况，
钩子<code>TARGET_SETUP_INCOMING_VARARGS</code>不应该产生任何指令。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_STRICT_ARGUMENT_NAMING</b> (<var>cumulative_args_t ca</var>)<var><a name="index-TARGET_005fSTRICT_005fARGUMENT_005fNAMING-4234"></a></var><br>
<blockquote><!-- Define this hook to return @code{true} if the location where a function -->
     <!-- argument is passed depends on whether or not it is a named argument. -->
      <p>定义该钩子来返回<code>true</code>，如果函数参数传递的位置依赖于其是否为一个命名参数。

     <!-- This hook controls how the @var{named} argument to @code{FUNCTION_ARG} -->
     <!-- is set for varargs and stdarg functions.  If this hook returns -->
     <!-- @code{true}, the @var{named} argument is always true for named -->
     <!-- arguments, and false for unnamed arguments.  If it returns @code{false}, -->
     <!-- but @code{TARGET_PRETEND_OUTGOING_VARARGS_NAMED} returns @code{true}, -->
     <!-- then all arguments are treated as named.  Otherwise, all named arguments -->
     <!-- except the last are treated as named. -->
      <p>该钩子控制对于varargs和stdarg函数，如何设置FUNCTION_ARG的<var>named</var>参数。
如果该钩子返回<code>true</code>，则<var>named</var>参数总是为命名参数，未命名参数总是未假。
如果返回<code>false</code>，但是<code>TARGET_PRETEND_OUTGOING_VARARGS_NAMED</code>返回
<code>true</code>，则所有参数都被作为命名的对待。否则所有命名参数，除了最后一个，
被作为命名的对待。

     <!-- You need not define this hook if it always returns @code{false}. -->
      <p>如果其总是返回0，则不需要定义该钩子。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_PRETEND_OUTGOING_VARARGS_NAMED</b> (<var>cumulative_args_t ca</var>)<var><a name="index-TARGET_005fPRETEND_005fOUTGOING_005fVARARGS_005fNAMED-4235"></a></var><br>
<blockquote><!-- If you need to conditionally change ABIs so that one works with -->
     <!-- @code{TARGET_SETUP_INCOMING_VARARGS}, but the other works like neither -->
     <!-- @code{TARGET_SETUP_INCOMING_VARARGS} nor @code{TARGET_STRICT_ARGUMENT_NAMING} was -->
     <!-- defined, then define this hook to return @code{true} if -->
     <!-- @code{TARGET_SETUP_INCOMING_VARARGS} is used, @code{false} otherwise. -->
     <!-- Otherwise, you should not define this hook. -->
      <p>如果你需要条件的改变ABI，使得一种工作于<code>TARGET_SETUP_INCOMING_VARARGS</code>，
另一种工作于<code>TARGET_SETUP_INCOMING_VARARGS</code>和
<code>TARGET_STRICT_ARGUMENT_NAMING</code>都没有被定义，则定义该钩子返回<code>true</code>，
如果使用<code>TARGET_SETUP_INCOMING_VARARGS</code>，否则返回<code>false</code>。
否则，你不需要定义该钩子。
</p></blockquote></div>

<!-- @node Trampolines -->
<!-- @section Trampolines for Nested Functions -->
 </body></html>

