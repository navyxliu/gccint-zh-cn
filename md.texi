@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001,
@c 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@ifset INTERNALS
@node 机器描述
@chapter 机器描述
@cindex machine descriptions

机器描述包括两个部分：指令模式文件（@file{.md} file）和宏定义C头文件。

目标机器的 @file{.md} 文件包含了目标机器支持的（或者最起码值得告诉编译器的）每条指令的模式。还可能包含注释。分号使得一行的剩余部分为注释，引号标注的字符串中的分号除外。

关于C头文件的信息，参见下一章。

@menu
* 概述::                如何使用机器描述。
* 指令模式::            如何写指令模式。
* 例子::                一个 @code{define_insn} 模式的例子说明。
* RTL模板::             RTL模板定义了什么样的insn与一个模式匹配。
* 输出模板::            输出模板说明了如何从这样一个insn来生成汇编代码。
* 输出语句::            更一般的情况, 编写C代码来输出汇编代码。
* Predicates::          控制一个insn可以使用什么类型的操作数。
* Constraints::         对操作数的选择进行微调。
* 标准名字::            代码生成时使用的模式名字。
* 指令模式顺序::        不同模式顺序所产生的作用。
* 依赖指令模式::        拥有一个指令模式，可能还会需要另一个。
* 跳转指令模式::        针对跳转insn的指令模式的特殊考虑。
* 循环指令模式::        如何为特定的循环insn定义模式。
* Insn规范化::          指令的规范化。
* 扩展定义::            为一个标准操作生成一个RTL insn序列。
* Insn拆分::            拆分指令为多条指令。
* 包含指令模式::        在机器描述中包含模式。
* 窥孔定义::            定义机器特定的窥孔优化。
* Insn属性::            为生成的insn指定属性值。
* 条件执行::            为预测（predication）生成 @code{define_insn} 模式。
* 常量定义::            定义可以用在md文件中的符号常量。
* 迭代器::              使用迭代器从模板中生成模式。
@end menu

@node 概述
@section 概述机器描述是如何被使用的

编译器中有三个主要的转换：

@enumerate

@item
前端读取源代码并建立解析树。

@item
基于命名的指令模式，解析树被用来生成RTL insn列表。

@item
insn列表被用来匹配RTL模板，产生汇编代码。

@end enumerate

生成过程，只与insn的名字有关系，包括命名的 @code{define_insn} 或者 
@code{define_expand}。编译器会选择恰当名字的模式，并且根据这章后面的文档来使用
操作数，而不需要关心RTL模板或者操作数constraint。注意，编译器所寻找的名字是被硬编码
进编译器中的——它将忽略未命名的模式和名字无法识别的模式，但是，如果你没有提供所
需要的命名模式，它将异常中断（abort）。

如果使用了 @code{define_insn} ，所给出的模版将会被插入到insn列表中。如果使用了
@code{define_expand} ，将会发生三种情况之一，取决于条件逻辑。条件逻辑可以手动为
insn列表创建一个新的insn，并且调用 @code{DONE}。对于某些命名模式，它可以调用
 @code{FAIL} 来告诉编译器使用一种备用方式完成任务。如果既没有调用DONE也没有调用
 @code{FAIL}，在模式中所给出的模版将会被插入，就像 @code{define_insn}一样。

一旦生成insn列表，各种优化过程便在insn列表中转换，替代和重排insn。例如，
@code{define_split} 和 @code{define_peephole} 模式便在这里被使用。

最后，insn列表的RTL被用来匹配 @code{define_insn} 模式中的RTL模版，并且那些模式
被用来生成最终的汇编代码。这时，由于不需要关心名字，所以每个命名的 
@code{define_insn}跟没有命名没有区别。

@node 指令模式
@section 指令模式的方方面面
@cindex patterns
@cindex instruction patterns

@findex define_insn
每个指令模式包含了一个不完全的RTL表达式，和之后要被填充的部分；操作数constraint，用来
限制如何填充那些部分；以及一个输出模式或者C代码来生成汇编输出。所有这些都由一个
 @code{define_insn} 表达式包裹起来。

@code{define_insn} 是一个RTL表达式，包含了四或五个操作数：

@enumerate
@item
一个可选的名字。存在名字表明该指令模式能够为编译器的RTL生成过程，执行一个确定的
标准工作。这个过程知道确定的名字，并且如果在机器描述中定义了这些名字，则会使用
它们的指令模式。

空字符串表示不存在名字。没有命名的指令模式是不会被用来生成RTL代码的，但是之后它
们能够用来组合多个简单insn。

不识别的并且因此不在RTL生成中使用的名字，没有任何作用，就像没有命名一样。

出于调试编译器的目的，你可能还需要指定一个名字起始于 @samp{*} 字符。这样的名字只
被用来标识RTL dump中的指令，其它的都与没有命名的模式一样。

@item
@dfn{RTL template}（@pxref{RTL模板}）是一个不完全的RTL表达式向量，展示了这
条指令的样子。所谓不完全是因为它可以包含 @code{match_operand}, 
@code{match_operator} 和 @code{match_dup} 表达式，用来表示指令的操作数。

如果向量只有一个元素，则那个元素为指令模式的模版。如果向量有多个元素，则指令模式是一个 @code{parallel} 表达式，包含了所描述的元素。

@item
@cindex pattern conditions
@cindex conditions, in patterns
一个条件。这是一个字符串，包含了一个C表达式用来最终测试，判定一个insn实体是否匹
配该模式。

@cindex named patterns and conditions
对于命名模式，条件（如果存在）可能不取决于要被匹配的insn的数据，而只是取决于
目标-机器-类型标记（target-machine-type flag）。编译器需要在初始化时测试这些条
件，以至于能够确切的知道在这一次运行中，哪些命名指令是可用的。

@findex operands
对于没有命名的模式，条件只用来匹配一个单独的insn，并且只在insn已经匹配了模式的识
别模版。insn的操作数可以为vector @code{operands}。对于一旦条件匹配的insn，它便不能被用来控制寄存器分配，例如用来排除某个硬件寄存器，或者硬件寄存器组合。 

@item
@dfn{output template}：一个字符串，说明了如何将匹配的insn输出为汇编代码。字符串
中的 @samp{%} 指定了替换一个操作数值的地方。@pxref{输出模板}。

当简单替换无法满足需求的时候，你可以指定一块C代码来计算输出。
@pxref{输出语句}。

@item
一个可选的向量，包含了匹配该模式的insn的属性值。@pxref{Insn属性}。

@end enumerate

@node 例子
@section 有关@code{define_insn}的例子
@cindex @code{define_insn} example

这个指令模式的例子来自68000/68020中。

@smallexample
(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "general_operand" "rm"))]
  ""
  "*
@{
  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
    return \"tstl %0\";
  return \"cmpl #0,%0\";
@}")
@end smallexample

@noindent
还可以写成如下形式：

@smallexample
(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "general_operand" "rm"))]
  ""
@{
  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
    return "tstl %0";
  return "cmpl #0,%0";
@})
@end smallexample
这是一条根据通用操作数来设置条件代码的指令。这个模式不需要条件（条件为空字符串）
，所以任何insn，如果RTL描述的形式相符，则可以根据这个模式来处理。名字 
@samp{tstsi} 表示“test a @code{SImode} value”，并且告诉了RTL生成过程，当其需要测
试这样的值时，可以使用这个模式来构造一条指令。

输出控制字符串是一部分C代码，用来根据操作数的类别和CPU的特定类型选择输出模版。

@samp{"rm"} 是一个操作数constraint。后面将会解释它的含义。

@node RTL模板
@section RTL模板
@cindex RTL insn template
@cindex generating insns
@cindex insns, generating
@cindex recognizing insns
@cindex insns, recognizing

RTL模板用来定义哪些insn匹配特定的模式，以及如何找到它们的操作数。对于命名的模
式，RTL模板还说明了如何根据特定的操作数来构建一个insn。

构建insn涉及到替换指定操作数到模板。匹配insn涉及到测定被匹配insn的操作数值。这
些匹配和替换操作数的行为都是由专门的表达式类型来控制。

@table @code
@findex match_operand
@item (match_operand:@var{m} @var{n} @var{predicate} @var{constraint})
该表达式用来代表insn中的第 @var{n} 个操作数。当构建insn时，操作数编号 @var{n} 将
在此处被替换。当匹配insn时，凡是在insn中该位置出现的将被当作操作数编号 @var{n}；
但是其必须满足 @var{predicate}，否则该指令模式将根本不匹配。 

每个指令模式中的操作数编号必须从0开始连续的选择。在指令模式中，可以对每个操作数
编号只是用一个 @code{match_operand} 表达式。 通常操作数按照在 
@code{match_operand} 表达式中出现的顺序被编号。对于 @code{define_expand}，任何
使用的操作数编号，只有在 @code{match_dup} 表达式中才会具有比其它操作数编号更高
的值。

@var{predicate} 为一个字符串，为一个函数的名字，其接受两个参数，一个表达式和一个
机器模式。@pxref{Predicates}。在匹配过程中，函数将会被调用，使用假定的操作数作为
表达式并且 @var{m} 作为机器模式参数（如果 @var{m} 没有被指定，则使用 
@code{VOIDmode}，这通常会使得 @var{predicate} 可以接受任何机器模式）。如果其返
回0，则该指令模式匹配失败。@var{predicate} 可以为一个空字符串；这意味着不对操作
数作测试，这样出现在该位置的任何都是有效的。

大多时候，@var{predicate} 将会拒绝 @var{m} 之外的机器模式——但并不总是这样。例
如，predicate @code{address_operand} 使用 @var{m} 作为内存引用的机器模式。许多predicate
接受 @code{const_int} 节点，即使它们的机器模式为 @code{VOIDmode}。

@var{constraint} 控制重载以及针对一个值选择最好的寄存器类别来使用，将在后面解释
（@pxref{约束条件}）。如果constraint为空字符串，则可以忽略掉。

人们经常弄不清楚constraint和predicate的区别。predicate帮助决定一个给定的insn是否匹配指令模式。constraint在该决定中不发挥作用；替代的，其控制已经匹配的insn的各种决定。

@findex match_scratch
@item (match_scratch:@var{m} @var{n} @var{constraint})
该表达式也是操作数编号 @var{n} 的占位符，并且指示操作数必须为一个 @code{scratch}
或者 @code{reg} 表达式。

当在匹配指令模式时，其相当于

@smallexample
(match_operand:@var{m} @var{n} "scratch_operand" @var{pred})
@end smallexample

但是，当在生成RTL时，其产生一个(@code{scratch}:@var{m})表达式。

如果在一个 @code{parallel} 中的最后几个表达式为 @code{clobber} 表达式，其操作数
为一个硬寄存器或者 @code{match_scratch}，则组合器可以在需要的时候增加或删除它
们。@pxref{副作用}。

@findex match_dup
@item (match_dup @var{n})
该表达式也为操作数编号 @var{n} 的占位符。其用于当操作数需要在insn中出现多次的
情况。 

在构建过程中，@code{match_dup} 的作用就跟 @code{match_operand} 一样。操作数被
替换到正在被构建的insn中。但是在匹配时，@code{match_dup} 的行为就有所不同了。
其假设操作数编号 @var{n} 已经由在识别模板中之前出现的 @code{match_operand} 确
定了，其只匹配相同的表达式。

注意 @code{match_dup} 不要用来告诉编译器特定寄存器被用于两个操作数（例如：
@code{add} 将一个寄存器加到另一个之上；第二个寄存器即为输入操作数，同样也为输
出操作数）。可以为此使用匹配constraint（@pxref{简单constraint}）。@code{match_dup}
是用于一个操作数在模板中的两个地方被使用的情况，例如一条指令同时计算商和余数，
其中操作码接受两个输入操作数，但是RTL模板不得不引用它们两次；一次用于求商指令
模式，一次用于求余数指令模式。

@findex match_operator
@item (match_operator:@var{m} @var{n} @var{predicate} [@var{operands}@dots{}])
该指令模式为一个可变RTL表达式代码的一种占位符。

当构造一个insn时，其代表RTL表达式，其表达式代码取自操作数 @var{n}，并且其操作
数从指令模式 @var{operands} 中构造。

当匹配一个表达式时，其匹配一个表达式，如果函数 @var{predicate} 对于该表达式返
回非零，@emph{并且} 指令模式 @var{operands} 匹配表达式的操作数。

假设函数 @code{commutative_operator} 被如下定义，来匹配任何表达式，其操作符为
RTL中可交换的算术操作符，并且其机器模式为 @var{mode}：

@smallexample
int
commutative_integer_operator (x, mode)
     rtx x;
     enum machine_mode mode;
@{
  enum rtx_code code = GET_CODE (x);
  if (GET_MODE (x) != mode)
    return 0;
  return (GET_RTX_CLASS (code) == RTX_COMM_ARITH
          || code == EQ || code == NE);
@}
@end smallexample

那么下列指令模式将匹配任何RTL表达式，其由一个可交换操作符和两个通用操作数组成：

@smallexample
(match_operator:SI 3 "commutative_operator"
  [(match_operand:SI 1 "general_operand" "g")
   (match_operand:SI 2 "general_operand" "g")])
@end smallexample

这里的向量 @code{[@var{operands}@dots{}]} 包含了两个指令模式，因为要匹配的表达
式都是包含两个操作数。

当该指令模式确实匹配时，可交换操作符的两个操作数被记录为insn的操作数1和2。（这
由 @code{match_operand} 的两个实例完成）。insn的操作数3将为整个可交换表达式：使
用 @code{GET_CODE (operands[3])} 来查看使用了哪个可交换操作符。

@code{match_operator} 的机器模式 @var{m} 的作用与 @code{match_operand} 的类似：
其被作为第二个参数传递给predicate函数，并且函数专门负责决定被匹配的表达式是否具有那
个机器模式。

当构造insn时，gen-function 的参数3将会指定要构造的表达式的操作（即，表达式代
码）。其应该为一个RTL表达式，其表达式代码被复制到一个新的表达式中，新表达式的
操作数为 gen-function的参数1和2。参数3的子表达式不被使用；只与它的表达式代码
有关。

当 @code{match_operator} 被用于指令模式中来匹配insn时，通常最好让
@code{match_operator} 的操作数编号高于insn的实际操作数。这将提高寄存器分配，
因为寄存器分配者通常查看insn的操作数1和2，来看是否它可以做寄存器绑定
（register tying）。

无法指定在 @code{match_operator} 中的constraint。对应于 @code{match_operator} 的
insn的操作数，不具有任何constraint，因为它从来不作为一个整体被重载。但是，如果它
的 @var{operands} 的一部分被 @code{match_operand} 指令模式匹配，那些部分可
以具有它们自己的constraint。

@findex match_op_dup
@item (match_op_dup:@var{m} @var{n}[@var{operands}@dots{}])
类似 @code{match_dup}，除了其应用于操作符而不是操作数。当构造insn时，操作数
编号 @var{n} 将在这一点被替代。但是在匹配时，@code{match_op_dup} 的行为有所
不同。其假设操作数编号 @var{n} 已经被在识别模板中先前出现的 
@code{match_operator} 所确定，并且其只匹配identical-looking的表达式。

@findex match_parallel
@item (match_parallel @var{n} @var{predicate} [@var{subpat}@dots{}])
该指令模式为一个insn的占位符，该insn由一个具有可变数目元素的 @code{parallel} 
表达式组成。该表达式应该只在insn指令模式的顶层出现。

当构造insn时，操作数编号 @var{n} 将在该处被替换。当匹配一个insn时，其当insn
的主体为一个 @code{parallel} 表达式，其具有至少跟向量 @var{subpat} 表达式同
样多数目元素，并且函数 @var{predicate} 返回非零时才匹配。predicate负责判定在
@code{match_parallel} 中的 @code{parallel} 的元素是否有效。

@code{match_parallel} 的一个典型用法是，匹配加载和存储多个表达式，其可以在
@code{parallel} 中包含一个可变数目的元素。例如，

@smallexample
(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI 179))
      (clobber (reg:SI 179))])]
  ""
  "loadm 0,0,%1,%2")
@end smallexample

这个例子来自 @file{a29k.md}。函数 @code{load_multiple_operation} 在 
@file{a29k.c} 中定义，其检查在 @code{parallel} 中的序列元素，是否与在
指令模式中的 @code{set} 相同，除非它们在引用后续的寄存器和内存位置。

匹配该指令模式的insn可能看起来像：

@smallexample
(parallel
 [(set (reg:SI 20) (mem:SI (reg:SI 100)))
  (use (reg:SI 179))
  (clobber (reg:SI 179))
  (set (reg:SI 21)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 4))))
  (set (reg:SI 22)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 8))))])
@end smallexample

@findex match_par_dup
@item (match_par_dup @var{n} [@var{subpat}@dots{}])
与 @code{match_op_dup} 类似，但是针对于 @code{match_parallel}，而不是
@code{match_operator}。
@end table

@node 输出模板
@section 输出模板和操作数替换
@cindex output templates
@cindex operand substitution

@cindex @samp{%} in template
@cindex percent sign
@dfn{output template}是一个字符串，其指定了如何为一个指令模式输出汇编代码。
大多数模板都是一个固定的字符串，可以按照字面直接输出。符号 @samp{%} 用来指
定替换操作数；

最简单的情况下，一个 @samp{%} 后面跟一个数字 @var{n} 表示在字符串中的这个
位置输出操作数 @var{n}。

@samp{%} 后面跟一个字母和一个数字表示用备用方式来输出操作数。有四个字母具
有标准内嵌的含义，将在下面描述。机器描述宏 @code{PRINT_OPERAND} 能够定义
其它的非标准含义的字母。

@samp{%c@var{digit}} 可以用来替换一个常数值的操作数。

@samp{%n@var{digit}} 类似于 @samp{%c@var{digit}}，只不过是对要打印的常数
值进行取反操作（negated）。

@samp{%a@var{digit}} 可以用来替换一个操作数，并把它当作一个内存引用，实际
的操作数则被视为地址。这在输出一个加载地址的指令时很有帮助，因为对于这样
的指令，汇编器语法经常需要你将操作数写成一个内存引用的形式。

@samp{%l@var{digit}} 用来将一个 @code{label_ref} 替换到跳转指令中。

@samp{%=} 输出一个在整个编译过程中，对每一条指令都是唯一的编号。这可以用来
在一个生成多个汇编指令的单一模板中， 使得局部标号能够被多次引用。

@samp{%} 后面跟一个标点符号指定了一个不使用操作数的替换。只用一种情况是标
准的：@samp{%%} 用来输出一个 @samp{%} 到汇编代码中。其它非标准的情况可以被
定义在 @code{PRINT_OPERAND} 宏中。你必须还要通过宏 
@code{PRINT_OPERAND_PUNCT_VALID_P} 来定义哪些标点符号是有效的。

@cindex \
@cindex backslash
模板可以生成多条汇编指令。这些指令文本之间使用 @samp{\;} 隔开。

@cindex matching operands
‘%’之后跟非标准字母或者标点符号的一种用途是区分同一机器的不同汇编语言；例如，68000的Motorola语法和MIT语法。 Motorola语法要求大多数的操作名都含有句点，而MIT语法中没有。比如，MIT语法中的操作码‘movel’在Motorola语法中为 ‘move.l’。两种输出法语使用了同一个模式文件，只不过在Motorola语法需要句点的地方使用了字符序列‘%.’。Motorola语法的宏 PRINT_OPERAND定义了这个序列用于输出一个句点；MIT语法的宏将其定义为不做任何事情。

作为一种特殊情况，只包含一个单独的字符#的模板会指示编译器首先拆分insn，然后分别输出所得的指令。这样有助于减少输出模板的重复内容。如果你有一个define_insn，其需要输出多个汇编指令，并且有一个匹配的define_split已经被定义，则你可以简单的使用#作为输出模板，而不用将模板写成输出多个汇编指令的样子。

如果定义了宏ASSEMBLER_DIALECT，则可以在模板中使用'@{option0|option1|option2@}'的形式。这些形式描述了多种汇编语言语法。参见指令输出。

当RTL包含两个，约束要求必须互相匹配的操作数时，输出模板必须只引用低编号的操作数。匹配的操作数并不总是相同的，编译器的其余部分会将要打印的合适的RTL表达式放到低编号的操作数中。

紧随@samp{%}之后的非标准字母或者标点符号的一种用法是，为同一机器区别不同的汇编语言；例如，68000的Motorola语法与MIT语法。Motorola语法要求大多操作码的名字中带有句号，而MIT语法不是这样。例如，在MIT语法中的操作码@samp{movel}，在Motorola语法中为@samp{move.l}。这两种输出语法都在同一个文件中的指令模式中实现，只不过字符序列@samp{%.}用在需要句号的Motorola语法中。Motorola语法的@code{PRINT_OPERAND}宏，将该序列定义成输出一个句号；而MIT语法则将其定义为不做任何事情。

@cindex @code{#} in template
作为一个特殊情况，由一单个@code{#}字符组成的模板，指示编译器首先拆分insn，然后分别输出所得的指令。这有助于在输出模板中消除冗余。如果你有一个@code{define_insn}，其需要输出多个汇编指令，并且有一个已经定义的匹配的@code{define_split}，则你可以简单的使用@code{#}作为输出模板，来替代书写输出多个汇编指令的输出模板。

如果宏@code{ASSEMBLER_DIALECT}被定义，你可以在模板中使用形如@samp{@{option0|option1|option2@}}的结构。这些描述了多个汇编语言语法的变体。@xref{指令输出}。

@node 输出语句
@section 用于汇编输出的C语句
@cindex output statements
@cindex C statements for assembler output
@cindex generating assembler output

经常，单个固定的模板字符串，不能够为单个指令模式所识别的所有情况都能产生正确，
有效的汇编代码。例如，操作码可以依赖于操作数类别；或者一些不适宜的操作数组合
可能需要额外的机器指令。

如果输出控制字符串起始于 @samp{@@}，则其实际为一系列模板，每一个单独一行。
（空行，以及开头的空格和tab被忽略掉。）这些模板对应于模式的各个constraint
（@pxref{多个可选项}）。例如，如果一个目标机有一个二址（two-address）
加法指令 @samp{addr}相加到寄存器中，另外还有一个 @samp{addm} 将寄存器的值相加
到内存中，你可能会这样写模式：

@smallexample
(define_insn "addsi3"
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (plus:SI (match_operand:SI 1 "general_operand" "0,0")
                 (match_operand:SI 2 "general_operand" "g,r")))]
  ""
  "@@
   addr %2,%0
   addm %2,%0")
@end smallexample

@cindex @code{*} in template
@cindex asterisk in template
如果输出控制字符串起始于 @samp{*}，则其不是一个输出模板，而是一个C程序片段并且
能够计算出一个模板。其应该执行一个 @code{return} 语句来返回你想要的模板字符串。
大多数这样的模板使用C字符串文字，需要用双引号包含起来。如果要在字符串中包含这
些双引号，可以在前面加上 @samp{\}。

如果输出控制串写成一个花括号块，而不是双引号的字符串，则其被自动认为是C代码。
这种情况下，则不必要有的起始的星号，以及转义C字符串文字中的双引号。

操作数可以为数组 @code{operands}，其C数据类型为 @code{rtx []}。

一种常见的情况是，根据立即数是否在一个特定范围内来选择生成汇编代码的方式。在做
这种事情的时候要仔细，因为 @code{INTVAL} 的结果是一个主机上的整形。如果主机的
@code{int} 比目标机上的具有更多的位，则从 @code{INTVAL} 中的得到的一些位将会是
多余的。要得到正确的结果，必须仔细的忽视掉那些位的值。

@findex output_asm_insn
有可能输出一个汇编指令，然后使用子程序 @code{output_asm_insn} 来继续输出或者计
算更多的。其接收两个参数：一个模板字符串和一个操作数向量。向量可以是 
@code{operands}，或者是另一个声明为局部的并且自己初始化的 @code{rtx} 数组。

@findex which_alternative
当一个insn模式有多个可选择的constraint时，则汇编代码经常主要是由所匹配的constraint选择来决
定。如果是这样，C代码可以测试变量 @code{which_alternative}，其为实际满足条件的
constraint选择的序号（0为第一个，1位第二个选择，以此类推）。

例如，假设有两个操作码来存储0，@samp{clrreg} 用于寄存器，@samp{clrmem} 用于内存
地址。这个模式实现了如何能够使用 @samp{which_alternative} 来选择它们：

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  @{
  return (which_alternative == 0
          ? "clrreg %0" : "clrmem %0");
  @})
@end smallexample

对于上面的例子，要生成的汇编代码 @emph{只是} 由alternative来决定，则还可以写成
如下形式，使用起始于 @samp{@@} 的输出控制串：

@smallexample
@group
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  "@@
   clrreg %0
   clrmem %0")
@end group
@end smallexample

@node Predicates
@section Predicates
@cindex predicates
@cindex operand predicates
@cindex operator predicates

predicate用于确定一个@code{match_operand}或者
@code{match_operator}表达式是否匹配，
以及周围的指令模式是否会被用于那些操作数的组合。
GCC有许多机器无关的predicate，并且你可以根据需要来定义机器特定的predicate。
按照惯例，与@code{match_operand}一起使用的predicate的名字以@samp{_operand}结尾，
与@code{match_operator}一起使用的predicate的名字以@samp{_operator}结尾。

所有predicate（从数学意义上）都是具有两个参数的布尔函数：
指令模式中在那个位置上被考虑的RTL表达式，
以及@code{match_operand}或@code{match_operator}所指定的机器模式。
在这一节里，第一个参数被称为@var{op}，第二个参数被称为@var{mode}。
predicate可以作为普通的具有两个参数的函数，从C中调用；
这在输出模板或者其它机器特定的代码中，很有用处。

操作数predicate可以允许硬件实际上无法接受的操作数，
只要constraint能够为reload提供能力，来修复它们（参见@ref{Constraints}）。
然而，只要predicate指定的机器指令需求尽可能的严密，
GCC通常便会生成更好的代码。reload不能修复必须为常量的操作数（立即数）；
你必须使用只允许常量的predicate，或者使用额外的条件来加强必要条件。

@cindex predicates and machine modes
@cindex normal predicates
@cindex special predicates
大多数predicate使用统一的方式来处理它们的@var{mode}参数。
如果@var{mode}为@code{VOIDmode}（未加指明的），则@var{op}可以具有任意的模式。
如果@var{mode}为其它情况，则@var{op}必须具有相同的机器模式，
除非@var{op}是一个@code{CONST_INT}或整数@code{CONST_DOUBLE}。
这些RTL表达式总是具有@code{VOIDmode}，所以检测它们的模式匹配反而会适得其反。
替代的，接受@code{CONST_INT}和/或整数@code{CONST_DOUBLE}的predicate，
可以检测存储在常量中的值是否适合所要求的机器模式。

具有这种行为的predicate被称为常规的。
@command{genrecog}能够根据常规predicate如何处理机器模式的知识来优化指令识别器。
它还能够诊断使用常规predicate所出现的一些常见错误。例如，
使用常规predicate而没有指定机器模式几乎总是错误的。

对@var{mode}参数进行不同方式处理的predicate被称为特殊的。
通用predicate @code{address_operand}和@code{pmode_register_operand}
是特殊predicate。当使用特殊predicate的时候，
@command{genrecog}不做任何的优化或诊断。

@menu
* 机器无关的predicate:: 所有后端都可用的predicate。 
* 定义predicate::       如何写机器特定的predicate函数。
@end menu

@node 机器无关的predicate
@subsection 机器无关的predicate
@cindex machine-independent predicates
@cindex generic predicates

这些是通用predicate，适用于所有后端。它们定义在@file{recog.c}中。
第一类predicate只允许常量或立即数。

@defun immediate_operand
该predicate允许适合相应@var{mode}的任何类别的常量。
适合用于操作数必须为常量的指令。
@end defun

@defun const_int_operand
该predicate允许适合相应@var{mode}的任何@code{CONST_INT}表达式。
适合用于不是符号（symbol）或标号（label）的立即数。
@end defun

@defun const_double_operand
该predicate接受任何确实为@var{mode}的@code{CONST_DOUBLE}表达式。
如果@var{mode}为@code{VOIDmode}，则其还接受@code{CONST_INT}。
它是用于浮点立即数的。
@end defun

@noindent
第二类predicate只允许某种类别的机器寄存器。

@defun register_operand
该predicate允许适合相应@var{mode}的任何@code{REG}或@code{SUBREG}表达式。
通常适合于RISC机器上的算术指令操作数。
@end defun

@defun pmode_register_operand
这与@code{register_operand}略为不同，其对机器描述的读入器有些限制。

当机器描述读入器接受@samp{:P}机器模式后缀时，

@smallexample
(match_operand @var{n} "pmode_register_operand" @var{constraint})
@end smallexample

@noindent
与

@smallexample
(match_operand:P @var{n} "register_operand" @var{constraint})
@end smallexample

@noindent
将具有完全相同的含义。不幸的是，这样不行，应为Pmode是其它机器模式的别名，
并且可能随着机器特定选项的不同而改变。参见@ref{其它}。
@end defun

@defun scratch_operand
该predicate允许硬件寄存器和@code{SCRATCH}表达式，但不允许伪寄存器。
其由@code{match_scratch}在内部使用；而不应该被直接使用。
@end defun

@noindent
第三类predicate只允许某种内存引用。

@defun memory_operand
该predicate允许任何对内存中机器模式@var{mode}的一定数量的有效引用，
并通过@code{GO_IF_LEGITIMATE_ADDRESS}的弱形式来确定（参见@ref{寻址模式}）。
@end defun

@defun address_operand
该predicate有些不常用；
其允许任何为机器模式@var{mode}的一定数量的地址有效表达式操作数，
同样通过@code{GO_IF_LEGITIMATE_ADDRESS}的弱形式来确定。
首先，如果@samp{@w{(mem:@var{mode} (@var{exp}))}}被@code{memory_operand}接受，
则@var{exp}被@code{address_operand}接受。
注意@var{exp}不必具有机器模式@var{mode}。
@end defun

@defun indirect_operand
这是一个@code{memory_operand}的更严格形式，
其只允许将@code{general_operand}作为地址表达式的内存引用。
不鼓励对该predicate的新的使用，因为@code{general_operand}的条件非常宽，
所以很难说清对于@code{indirect_operand}什么是被允许的，什么是不被允许的。
如果目标机对不同指令的内存操作数具有不同的要求，
则最好定义目标机特定的predicate，以显式的加强硬件的要求。
@end defun

@defun push_operand
该predicate允许适合将值压入栈中的内存引用。这将为一个@code{MEM}，
其引用@code{stack_pointer_rtx}，且在其地址表达式中具有一个副作用
（参见@ref{Incdec}）；其由宏@code{STACK_PUSH_CODE}来确定（参见@ref{帧布局}）。
@end defun

@defun pop_operand
该predicate允许适合将值弹出栈中的内存引用。同样，这将为一个@code{MEM} ，
其引用@code{stack_pointer_rtx}，且在其地址表达式中具有一个副作用；
不过，这次是@code{STACK_POP_CODE} 。
@end defun

@noindent
第四类predicate允许上面的操作数的某种组合。

@defun nonmemory_operand
该predicate允许任何对于@var{mode}有效的立即数，或寄存器操作数。
@end defun

@defun nonimmediate_operand
该predicate允许任何对于@var{mode}有效的寄存器，或内存操作数。
@end defun

@defun general_operand
该predicate允许任何对于@var{mode}有效的立即数，寄存器，或内存操作数。
@end defun

@noindent
最后，有一个通用操作符predicate。

@defun comparison_operator
该predicate匹配任何执行一个基于@var{mode}的算术比较表达式；
即，@code{COMPARISON_P}对于表达式代码为真。
@end defun

@node 定义predicate
@subsection 定义机器特定的predicate
@cindex defining predicates
@findex define_predicate
@findex define_special_predicate

许多机器对操作数的要求无法使用通用的predicate来精确表达。
你可以使用表达式@code{define_predicate}和@code{define_special_predicate}来定义 额外的predicate。这些表达式具有三个操作数： 
@itemize @bullet
@item
predicate的名字，
其将在@code{match_operand}或@code{match_operator}表达式中被引用。

@item
一个RTL表达式，如果predicate允许@var{op}操作数，则值为真，否则为假。
该表达式只能使用下列RTL代码： 

@table @code
@item MATCH_OPERAND
当用于predicate表达式中时，
表达式@code{MATCH_OPERAND}在predicate允许@var{op}时为真。
操作数编号和constraint被忽略。由于@command{genrecog}中的限制，
你只能用于引用通用的predicate和已经被定义的predicate。

@item MATCH_CODE
该表达式为真，
如果@var{op}或一个指定的@var{op}的子表达式具有给定RTX代码列表中的一个RTX代码。

该表达式的第一个操作数为一个字符串常量，
包含了逗号分割的RTX代码名字（小写形式）列表。这些是@code{MATCH_CODE}为真的代码。

第二个操作数为一个字符串常量，其指示@var{op}的什么子表达式需要被检查。
如果没有或者为空字符串，则检查@var{op}本身。
否则，字符串常量必须为一个数字和/或小写字母的序列。
每个字符指示从当前表达式中抽取的子表达式；
第一个字符为@var{op}，第二个和后续字符，其为先前字符的结果。
数字@var{n}用于抽取@samp{@w{XEXP (@var{e}, @var{n})}}；
字母@var{l}抽取@samp{@w{XVECEXP (@var{e}, 0, @var{n})}}，
其中@var{n}为@var{l}的字母顺序（0为`a'，1为'b'，等等）。
@code{MATCH_CODE}然后检查完整字符串所抽取的子表达式的RTX代码。

@item MATCH_TEST
该表达式具有一个操作数，一个包含了一个C表达式的字符串常量。
在C表达式中可以使用predicate的参数，@var{op}和@var{mode}。
当C表达式为非0值时，@code{MATCH_TEST}为真。
@code{MATCH_TEST}表达式必须不具有副作用。

@item  AND
@itemx IOR
@itemx NOT
@itemx IF_THEN_ELSE
基本的@samp{MATCH_}表达式可以使用这些逻辑操作符组合，
其分别具有C操作符@samp{&&}, @samp{||}, @samp{!}和@samp{@w{? :}}的语义。
正如在Common Lisp中，可以给@code{AND}或@code{IOR}表达式任意数目的参数；
这跟写成两个参数的@code{AND}或@code{IOR}表达式链具有相同的效果。
@end table

@item
一个可选的C代码块，其应该在发现predicate匹配时执行@samp{@w{return true}}，
不匹配时执行@samp{@w{return false}}。其一定不要具有副作用。
predicate参数，@var{op}和@var{mode}，是有效的。

如果代码块存在于predicate定义中，则对于predicate允许的操作数，
RTL表达式必须求值为true并且代码块必须执行@samp{@w{return true}}。
RTL表达式被首先求值，不要重复检查代码块中的在RTL表达式中曾经被检查过的任何事情。
@end itemize

程序@command{genrecog}扫描@code{define_predicate}和
@code{define_special_predicate}表达式来决定什么RTX代码可能被允许。
你应该使其在RTL predicate表达式中总是显式的，
使用@code{MATCH_OPERAND}和@code{MATCH_CODE}。

这里有一个简单的定义predicate的例子，来自IA64机器描述：

@smallexample
@group
;; @r{True if @var{op} is a @code{SYMBOL_REF} which refers to the sdata section.}
(define_predicate "small_addr_symbolic_operand"
  (and (match_code "symbol_ref")
       (match_test "SYMBOL_REF_SMALL_ADDR_P (op)")))
@end group
@end smallexample

@noindent
另一个例子，展示了C块的使用。

@smallexample
@group
;; @r{True if @var{op} is a register operand that is (or could be) a GR reg.}
(define_predicate "gr_register_operand"
  (match_operand 0 "register_operand")
@{
  unsigned int regno;
  if (GET_CODE (op) == SUBREG)
    op = SUBREG_REG (op);

  regno = REGNO (op);
  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));
@})
@end group
@end smallexample

使用@code{define_predicate}编写的predicate会自动包含一个测试，
用来测试@var{mode}为@code{VOIDmode}，
或者@var{op}具有与@var{mode}相同的机器模式，
或者@var{op}为@code{CONST_INT}或@code{CONST_DOUBLE}。
它们@emph{不}专门检查整数@code{CONST_DOUBLE}，
也不测试每种常量的值是否适合所需求的机器模式。
这是因为接受常量的目标机特定的predicate，通常必须做更严厉的值检查。
如果你需要确切的通用predicate提供的对@code{CONST_INT}或
@code{CONST_DOUBLE}的对待，
则可以使用@code{MATCH_OPERAND}子表达式来调用@code{const_int_operand}, 
@code{const_double_operand}或者@code{immediate_operand}。

使用@code{define_special_predicate}编写的predicate不做任何自动的机器模式检查，
并且@command{genrecog}将其作为具有特定的机器模式处理来对待。

程序@command{genpreds}负责生成代码来测试predicate。
其还编写了一个包含所有机器特定predicate的函数声明的头文件。
所以不需要在cpu-protos.h中声明这些predicate。
@end ifset

@c Most of this node appears by itself (in a different place) even
@c when the INTERNALS flag is clear.  Passages that require the internals
@c manual's context are conditionalized to appear only in the internals manual.
@ifset INTERNALS
@node Constraints
@section 操作数的constraint
@cindex operand constraints
@cindex constraints

在指令模式中的每个@code{match_operand}都可以指定操作数所允许的constraint。
constraint允许你在由predicate所允许的操作数集里进行微调匹配。


@end ifset
@ifclear INTERNALS
@node Constraints
@section @code{asm}操作数的constraint条件
@cindex operand constraints, @code{asm}
@cindex constraints, @code{asm}
@cindex @code{asm} constraints

Here are specific details on what constraint letters you can use with
@code{asm} operands.
@end ifclear
constraint可以告诉一个操作数是否可以在寄存器中，以及哪种寄存器；
操作数是否可以为内存引用，以及哪种寻址方式；操作数是否可以为立即数，
以及可以具有什么值。constraint还可以要求两个操作数要匹配。

@ifset INTERNALS
@menu
* 简单的constraint::     constraint的基本用法
* 多个可选项::           当insn具有两个可选的constraint模式
* 类别优先选择::         constraint可以指导用哪个硬件寄存器来存放事物
* 修饰符::               对constraint效果更精确的控制
* 禁止Insn可选项::       使用@code{enabled}属性来禁止insn可选项
* 机器constraint::       一些特定机器现有的constraint
* 定义constraint::       如何定义机器特定的constraint
* C constraint接口::     如何测试C代码的constraint
@end menu
@end ifset

@ifclear INTERNALS
@menu
* 简单的constraint::   constraint的基本用法
* 多个可选项::         当insn具有两个可选的constraint模式
* 修饰符::             对constraint效果更精确的控制
* 机器constraint::     一些特定机器现有的constraint
@end menu
@end ifclear

@node 简单的constraint
@subsection 简单的constraint
@cindex simple constraints

最简单的constraint种类是一个由字母组成的字符串，
每个字母描述一种所允许的操作数。这里是所允许的字母：

@table @asis
@item whitespace
空格字符将被忽略，并且可以插到除了起始处的任何地方。这使得机器描述中，
不同操作数的每个可选项可以被可视化的对齐，即使它们具有不同数目的约束和修饰符。 

@cindex @samp{m} in constraint
@cindex memory references in constraints
@item @samp{m}
内存操作数将被允许，包括机器支持的任何寻址方式。

@cindex offsettable address
@cindex @samp{o} in constraint
@item @samp{o}
内存操作数将被允许，但只有当地址为偏移表的时候。
这意味着可以对地址加上一个小的整数(实际上,是为操作数的数个字节宽度,
这由它的机器模式决定),其结果也为一个有效的内存地址。

@cindex autoincrement/decrement addressing
例如，地址为常数的为一个偏移表；所以地址为一个寄存器和常数（只要常数在机器所支持
的地址偏移范围）的和；但是递增或者递减地址不是偏移表。更加复杂的间接/索引地址可
能是或者可能不是偏移表，这取决于机器支持的其它寻址模式。

@cindex @samp{V} in constraint
@item @samp{V}
一个不是offsettable的内存操作数。换句话说，
任何适合@samp{m}约束但不是@samp{o}约束的。 

@cindex @samp{<} in constraint
@item @samp{<}
允许具有自动减量寻址（先减或者后减）的内存操作数。 

@cindex @samp{>} in constraint
@item @samp{>}
允许具有自动增量寻址（先增或者后增）的内存操作数。

@cindex @samp{r} in constraint
@cindex registers in constraints
@item @samp{r}
允许为通用寄存器的寄存器操作数。 

@cindex constants in constraints
@cindex @samp{i} in constraint
@item @samp{i}
立即数（具有常数值）将被允许。这包括符号常量，
其值将在汇编时候或者更晚的时候才被知道。 

@cindex @samp{n} in constraint
@item @samp{n}
立即数，其具有已知的数值。
许多系统不支持汇编时间常量作为小于一个字的宽度的操作数。
这些操作数的约束应该为@samp{n}而不是@samp{i}。 

@cindex @samp{I} in constraint
@item @samp{I}, @samp{J}, @samp{K}, @dots{} @samp{P}
从@samp{I}到@samp{P}的其它字母可以被定义为机器特定的，
用来运行立即数具有显示指定范围的整数值。例如，在68000上，
@samp{I}被定义为代表1到8的值。这是在移位指令中被允许作为移位数的范围。 

@cindex @samp{E} in constraint
@item @samp{E}
浮点立即数（表达式代码为@code{const_double}），
但是必须target浮点格式与host机器（编译器运行的机器）的相同才行。 

@cindex @samp{F} in constraint
@item @samp{F}
浮点立即数（表达式代码为@code{const_double}或者@code{const_vector}）。 

@cindex @samp{G} in constraint
@cindex @samp{H} in constraint
@item @samp{G}, @samp{H}
@samp{G}和@samp{H}可以被定义为机器特定的方式来允许浮点立即数具有特定范围的值。 

@cindex @samp{s} in constraint
@item @samp{s}
整数立即数，其值不是一个显式的整数。

这可能有点奇怪；如果insn允许常量操作数具有在编译时不可知的值，
它当然必须允许任何可知的值。所以为什么用@samp{s}，而不是@samp{i}能？有时候，
它会允许生成更好的代码。

例如，在68000上的全字指令，有可能使用一个立即数操作数；
但是如果立即数的值是处于-128和127之间，更好的代码是将值加载到寄存器中，
使用寄存器。这是因为加载到寄存器中可以由@samp{moveq}指令来完成。
我们对此通过定义字母@samp{K}来表示任意范围超出-128和127的整数，
然后在操作数约束中指定@samp{Ks}。

@cindex @samp{g} in constraint
@item @samp{g}
任何寄存器，内存或整数立即数，除了不是通用寄存器的寄存器。 

@cindex @samp{X} in constraint
@item @samp{X}
@ifset INTERNALS
任何操作数都被允许，即使其不满足@code{general_operand}。
这通常用于@code{match_scratch}的约束中，
当一些的可选项实际上不需要scratch寄存器的时候。 
@end ifset
@ifclear INTERNALS
Any operand whatsoever is allowed.
@end ifclear

@cindex @samp{0} in constraint
@cindex digits in constraint
@item @samp{0}, @samp{1}, @samp{2}, @dots{} @samp{9}
匹配指定操作数编号的操作数。如果数字与字母一起使用，则数字应该放在最后。

该编号允许多于单个数字。如果多个数字连续的在一起，
则它们被解析为一个单独的十进制整数。很少会因此产生不明确，因为到目前为止，
还没有想要将@samp{10}解析为匹配操作数1或者0的。如果有这样的需要，
则可以使用多个可选项来替代。

@cindex matching constraint
@cindex constraint, matching
这被称为匹配约束，其实际上是指汇编器只有一个单独的操作数，
却在RTL insn中扮演两个角色。例如，
add insn在RTL中具有两个输入操作数和一个输出操作数，
但是多数CISC机器上，add指令实际上只有两个操作数，其中一个为输入输出操作数：

@smallexample
addl #35,r12
@end smallexample

匹配约束被用于这些情况。更确切的说，
匹配的两个操作数必须包括一个只作输入的操作数和一个只作输出的操作数。

@cindex load address instruction
@cindex push address instruction
@cindex address constraints
@cindex @samp{p} in constraint
@item @samp{p}
允许一个为有效内存地址的操作数。这用于“加载地址”和“地址压栈”指令。

@findex address_operand
约束中的@samp{p}必须由@code{match_operand}中的作为断言的@code{address_operand}协同工作。该断言将@code{match_operand}中指定的机器模式解析为地址有效的内存引用的机器模式。

@cindex other register constraints
@cindex extensible constraints
@item @var{other-letters}
其它字母可以采用机器相关的方式被定义，用于代表寄存器的特定类别或者其它任意的操作数类型。@samp{d}, @samp{a}和@samp{f}在68000/68020被定义用来代表数据，地址和浮点寄存器。

@end table

@ifset INTERNALS
为了具有有效的汇编代码，每个操作数必须满足它的约束。但是如果不满足的话，也不会阻止将该指令模式应用到insn上。替代的，它会指示编译器去修改代码以至于约束将被满足。通常，这是通过将一个操作数复制到寄存器中来完成的。

因此，对比下面的两条指令模式：

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "general_operand" "r")))]
  ""
  "@dots{}")
@end smallexample

@noindent
其具有两个操作数，其中一个必须出现在两个位置，

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_operand:SI 1 "general_operand" "0")
                 (match_operand:SI 2 "general_operand" "r")))]
  ""
  "@dots{}")
@end smallexample

@noindent
其具有三个操作数，其中两个通过约束被要求为是相同的。如果我们考虑如下形式的一条insn 

@smallexample
(insn @var{n} @var{prev} @var{next}
  (set (reg:SI 3)
       (plus:SI (reg:SI 6) (reg:SI 109)))
  @dots{})
@end smallexample

@noindent
第一个指令模式将根本不会被应用，因为该insn不在合适的地方包含两个相同的子表达式。指令模式会说“这看起来不像是一条加法指令；试一下其它模式”。第二个指令模式将会说，“是的，这是一条加法指令，但是有些问题”。它将指使编译器的重载过程生成额外的insn，使得约束为真。结果可能看起来像：

@smallexample
(insn @var{n2} @var{prev} @var{n}
  (set (reg:SI 3) (reg:SI 6))
  @dots{})

(insn @var{n} @var{n2} @var{next}
  (set (reg:SI 3)
       (plus:SI (reg:SI 3) (reg:SI 109)))
  @dots{})
@end smallexample

你必须确保每个操作数，在每个指令模式中，具有能够处理可能会出现的任何RTL表达式的约束。（当使用多个可选项时，每个指令模式，对于每个可能的操作数表达式组合，必须至少具有一个可选项可以处理该操作数的组合。）约束不需要允许任何可能的操作数——如果是这种情况，它们就不做约束了——但是它们必须至少指出可以加载任何可能操作数，使得适合约束的方法。

@itemize @bullet
@item
如果约束接受断言允许的任何操作数，则没有问题：重载对于该操作数将没有必要。

例如，操作数对于它的约束允许除了寄存器以外的任何事物，如果它的断言不接受寄存器的话，这样是安全的。

操作数对于断言只接受常量时，如果它的约束包含字母@samp{i}，则是安全的。如果任何可能的常量都被接受，则可以使用@samp{i}；如果断言具有更多的选择性，则约束也可以具有更多的选择性。

@item
任何操作数表达式可以通过复制到寄存器中来进行重载。所以如果一个操作数的约束允许某种寄存器，其当然是安全的。它不需要允许所有类型的寄存器；编译器知道为了使指令有效，如何将一个寄存器复制到另一个合适类别的寄存器中。 

@cindex nonoffsettable memory reference
@cindex memory reference, nonoffsettable
@item
非偏移表的内存引用可以通过将地址复制到寄存器中来重载。所以如果约束使用字母@samp{o}，则所有内存引用将被照顾到。

@item
常量操作数可以通过在内存中分配空间作为预先被初始化的数据来重载。然后可以使用内存引用。所以如果约束使用字母@samp{o}或者@samp{m}，则常量操作数不是问题。

@item
如果约束允许的常量和伪寄存器没有被分配到硬件寄存器中，并且等价于一个常量，则寄存器将被常量替换。如果断言不允许常量并且insn出于某种原因被识别了，则编译器将会崩溃。因此断言必须总是能够识别任何被约束允许的对象。

@end itemize

如果操作数的断言能够识别寄存器，但是约束不允许它们，则能够使编译器崩溃。当该操作数正好是寄存器时，重载过程将被打乱，因为它不知道如何将寄存器临时复制到内存中。

如果断言接受一元操作符，约束将被应用到操作数上。例如，MIPS处理器在ISA3级时，支持一条指令，其将两个@code{SImode}的寄存器相加产生一个 @code{DImode}的结果，但是必须寄存器能够被正确的符号扩展。该断言对于输入操作数接受一个@code{SImode}寄存器的@code{sign_extend}。将约束写成指示寄存器的类型需要为@code{sign_extend}的操作数。

@end ifset

@node 多个可选项
@subsection 多个可选的constraint
@cindex multiple alternative constraints

有时单个指令具有多个可选的操作数集。例如，在68000上，
一个逻辑或指令可以将寄存器或者立即数的值组合到内存中，
或者可以组合任何类型的操作数到寄存器中；但是不能将一个内存位置组合到另一个中。

这些约束作为多个可选项来表示。
一个可选项可以通过针对每个操作数的一系列字母来描述。
一个操作数的总的约束由该操作数第一个可选项的字母，逗号，
该操作数的第二个可选项，逗号，等等直到最后一个可选项组成。
这里有一个在68000上全字逻辑或的表示：

@ifset INTERNALS
Here is how it is done for fullword logical-or on the 68000:

@smallexample
(define_insn "iorsi3"
  [(set (match_operand:SI 0 "general_operand" "=m,d")
        (ior:SI (match_operand:SI 1 "general_operand" "%0,0")
                (match_operand:SI 2 "general_operand" "dKs,dmKs")))]
  @dots{})
@end smallexample

第一个可选项具有操作数0的@samp{m} (memory)，操作数1的@samp{0}（意味着其必须匹配
操作数0）和操作数2的@samp{dKs}。第二个可选项具有操作数0的@samp{d}
(data register)，操作数1的@samp{0}和操作数2的@samp{dmKs}。
约束中的@samp{=}和@samp{%}应用于所有的可选项；
它们的含义在下一节介绍（参见@ref{类别优先选择}）。
@end ifset

@c FIXME Is this ? and ! stuff of use in asm()?  If not, hide unless INTERNAL
如果所有操作数适合任意一个可选项，则指令为有效的。否则，对于每个可选项，
编译器计算要复制操作数使得可选项可以使用所需要增加的指令个数。
需要的复制最少的可选项将被选中。如果两个可选项需要相同数目的复制，
则选择前面的。这些选择可以通过字符@samp{?}和@samp{!}来改变：

@table @code
@cindex @samp{?} in constraint
@cindex question mark
@item ?
轻微降低@samp{?}出现的可选项，当没有可选项被确切应用时，才将其作为选择。
编译器将该可选项的花销认为高出一个单元。 

@cindex @samp{!} in constraint
@cindex exclamation point
@item !
严格降低@samp{!}出现的可选项，当该选项没有reloading的时候还可以被使用，
但是如果需要reloading，则将使用其它可选项。 
@end table

@ifset INTERNALS
当insn指令模式在其约束中具有多个可选项时，
经常会出现通过哪个可选项被匹配而决定使用使用什么汇编代码的情况。这时，
输写汇编代码的C代码可以使用变量@code{which_alternative}，
其为实际被满足的可选项的顺序编号（0对应第一个，1对应第二个，等等）。
参见@ref{输出语句}。
@end ifset

@ifset INTERNALS
@node 类别优先选择
@subsection 寄存器类别优先选择
@cindex class preference constraints
@cindex register class preference constraints

@cindex voting between constraint alternatives
操作数约束还具有另一个功能：它们使编译器可以决定为伪寄存器分配哪种硬件寄存器。
编译器检查应用到使用伪寄存器的insn的约束，
查看机器相关的指定寄存器类别的字母像@samp{d}和@samp{a}。
伪寄存器被放在获得最多“票数”的类别中。约束字母@samp{g}和@samp{r}也要投票：
它们在通用寄存器方面进行投票。机器描述告诉哪种寄存器被认为是通用的。

当然，在一些机器上所有寄存器都是等价的，并且没有定义寄存器类别。
那么就相应的没有这么复杂了。
@end ifset

@node 修饰符
@subsection constraint修饰符
@cindex modifiers in constraints
@cindex constraint modifier characters

@c prevent bad page break with this line
这里是约束修饰符。 

@table @samp
@cindex @samp{=} in constraint
@item =
意味着该指令的该操作数为只写的：先前的值将被丢弃并且由输出数据替换。 

@cindex @samp{+} in constraint
@item +
意味着该操作数可以由指令读和写。

当编译器修订操作数来满足约束时，
它需要知道哪些操作数为指令的输入以及哪些为它的输出。@samp{=}表示一个输出；
@samp{+}表示一个操作数同时为输入和输出；所有其它操作数将被认为只是输入。

如果你指定了@samp{=}或者@samp{+}，你要将它作为约束字符串的第一个字符。

@cindex @samp{&} in constraint
@cindex earlyclobber operand
@item &
意味着（在一个特别的可选项中）该操作数为一个@dfn{earlyclobber}操作数，
其在指令完成使用输入操作数之前就被修改了。
因此该操作数可能不在被用作输入操作数或者用作任何内存地址的一部分的寄存器中。

@samp{&}只应用于其所在的可选项。在具有多个可选项的约束中，
有时一个可选项需要@samp{&}，而其它的不需要。例如，参见68000的@samp{movdf} insn。

一个输入操作数可以被限定为一个earlyclobber操作数，
如果它唯一的作为输入的使用发生在早期结果被写出之前。
增加这种形式的可选项经常可以允许GCC来产生更好的代码，
当只有一些输出可以被earlyclobber影响时。例如，参见ARM的@samp{mulsi3} insn。

@samp{&}不排除对@samp{=}的需要。

@cindex @samp{%} in constraint
@item %
声明指令对于该操作数和随后的操作数是可交换的。这意味着编译器可以交换两操作数，
如果有更廉价的方式来使得所有操作数都适合约束。
@ifset INTERNALS
这经常被用于实际上只有两个操作数的加法指令中：结果必须放在一个参数中。
这里有个例子，是68000半字加指令如何被定义的： 

@smallexample
(define_insn "addhi3"
  [(set (match_operand:HI 0 "general_operand" "=m,r")
     (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
              (match_operand:HI 2 "general_operand" "di,g")))]
  @dots{})
@end smallexample
@end ifset
GCC只能处理在asm中的一个可交换对；如果你有更多的，编译器将会失败。
注意如果两个可选项严格相同，则不需要使用该修饰符；这只会在重载过程浪费时间。
该修饰符在寄存器分配之后，是不可操作的，
所以在重载之后执行的@code{define_peephole2}和@code{define_split}的结果不能依赖
@samp{%}来进行insn匹配。

@cindex @samp{#} in constraint
@item #
表示所有后续的字符，直到下一个逗号，作为约束都被忽略掉。
它们只对选择寄存器优先时有意义。 

@cindex @samp{*} in constraint
@item *
表示后续字符在选择寄存器优先时应该被忽略掉。@samp{*}对于重载没有影响。

@ifset INTERNALS
这里有一个例子：68000有一条指令，用于在数据寄存器中符号扩展一个半字，
并且还可以通过将其复制到一个地址寄存器中来符号扩展一个值。
当每种寄存器都可以被接受时，对于地址寄存器的约束相对不是很严格，
所以最好是寄存器分配将地址寄存器作为其目标。
因此，@samp{*}被使用，以至于@samp{d}约束字母（数据寄存器）被忽略，
当计算寄存器优先时。

@smallexample
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=*d,a")
        (sign_extend:SI
         (match_operand:HI 1 "general_operand" "0,g")))]
  @dots{})
@end smallexample
@end ifset
@end table

@node 机器constraint
@subsection 机器特定的constraint
@cindex machine specific constraints
@cindex constraints, machine specific

只要可能，就应该在@code{asm}参数中使用通用目的的约束字母，
因为它们可以向阅读你的代码的人们传达更加可读的意思。如果无法做到，
则使用在不同体系结构中通常具有非常相似的意思的约束字母。
最通用的约束为@samp{m}和@samp{r}（分别用于内存和通用寄存器；
参见@pxref{简单constraint}“），
以及@samp{I}，通常用于指示最常见的立即数常量格式。

每个体系结构定义了额外的约束。这些约束被编译器本身使用，用于指令生成，
同时也用于@code{asm}语句；因此，一些约束对于@code{asm}并不是很有用处。
这里有一个总结，关于在一些特定机器上使用的机器相关的约束；
包括对@code{asm}有用处的和没有用处的。
在表中提到的针对每个体系结构的编译器原文件，是该体系结构的约束的定义参考。

@table @emph
@item ARM family---@file{config/arm/arm.h}
@table @code
@item f
浮点寄存器

@item w
VFP浮点寄存器

@item F
浮点常量0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0或者10.0

@item G
浮点常量，其负数满足约束@samp{F}

@item I
可以在数据处理指令中作为立即数的整数。即，0到255范围的整数，被2的倍数进行旋转

@item J
范围在@minus{}4095到4095的整数

@item K
当倒置后，满足约束@samp{I}的整数

@item L
当求负后，满足约束@samp{I}的整数

@item M
范围在0到32的整数

@item Q
一个内存引用，其确切的地址在单个寄存器中（`@samp{m}'可以用于@code{asm}语句）

@item R
在常量池中的项

@item S
在当前文件中text段中的符号

@item Uv
适于VFP加载/存储insn（寄存器+常量 偏移量）的内存引用

@item Uy
适于iWMMXt加载/存储指令的内存引用

@item Uq
适于ARMv4 ldrsb指令的内存引用
@end table

@item AVR family---@file{config/avr/constraints.md}
@table @code
@item l
寄存器r0到r15

@item a
寄存器r16到r23

@item d
寄存器r16到r31

@item w
寄存器r24到r31。这些寄存器可以用于@samp{adiw}命令

@item e
指针寄存器(r26--r31)

@item b
基指针寄存器(r28--r31)

@item q
栈指针寄存器(SPH:SPL)

@item t
临时寄存器r0

@item x
寄存器对X (r27:r26)

@item y
寄存器对Y (r29:r28)

@item z
寄存器对Z (r31:r30)

@item I
常量，大于@minus{}1，小于64

@item J
常量，大于@minus{}64，小于1

@item K
常量整数2

@item L
常量整数0

@item M
8位的常量

@item N
常量整数@minus{}1

@item O
常量整数8，16或24

@item P
常量整数1

@item G
浮点常量0.0

@item R
整数常量，范围在-6 @dots{} 5

@item Q
一个内存地址，基于Y或者Z指针，加上一个位移
@end table

@item CRX Architecture---@file{config/crx/crx.h}
@table @code

@item b
寄存器从r0到r14（不含栈指针）

@item l
寄存器r16（64位累加器lo寄存器）

@item h
寄存器r17（64位累加器hi寄存器）

@item k
寄存器对r16-r17（64位累加器lo-hi寄存器对）

@item I
3位的常量

@item J
4位的常量

@item K
5位的常量

@item L
常量-1, 4, -4, 7, 8, 12, 16, 20, 32, 48

@item G
浮点常量，合法的可以用于存储的立即数。
@end table

@item Hewlett-Packard PA-RISC---@file{config/pa/pa.h}
@table @code
@item a
通用寄存器1

@item f
浮点寄存器

@item q
移位数量寄存器

@item x
浮点寄存器(不推荐的)

@item y
高位部分浮点寄存器（32位），浮点寄存器（64位）

@item Z
任何寄存器

@item I
有符号的11位整数常量

@item J
有符号的14位整数常量

@item K
可以使用指令@code{zdepi}存放的整数常量

@item L
有符号的5位整数常量

@item M
整数常量0

@item N
可以使用@code{ldil}指令加载的整数常量

@item O
整数常量，其值加上1便为2的幂

@item P
可以用于在@code{depi}和@code{extru}指令中@code{and}运算的整数常量

@item S
整数常量31

@item U
整数常量63

@item G
浮点常量0.0

@item A
一个@code{lo_sum} data-linkage-table内存操作数

@item Q
可以用作整数存储指令的目的操作数的内存操作数

@item R
缩放或者未缩放的索引内存操作数

@item T
浮点加载和存储的内存操作数

@item W
寄存器间接内存操作数
@end table

@item picoChip family---@file{picochip.h}
@table @code
@item k
栈寄存器

@item f
指针寄存器。可以用于访问内存，无需提供偏移量。任何其它寄存器可以用于访问内存，但需要一个常量偏移量。当偏移量为零的时候，使用指针寄存器会更有效，因为这将减少代码大小。

@item t
成对寄存器。相邻的两个寄存器，用来创建一个32位寄存器。

@item a
任何绝对内存地址（例如，符号常量，符号常量+偏移量）

@item I
4位有符号整数

@item J
4位无符号整数

@item K
8位有符号整数

@item M
任何绝对值不大于4位的常量

@item N
10位有符号整数

@item O
16位有符号整数

@end table

@item PowerPC and IBM RS6000---@file{config/rs6000/rs6000.h}
@table @code
@item b
基址寄存器

@item f
浮点寄存器

@item v
向量寄存器

@item h
@samp{MQ}, @samp{CTR}或者@samp{LINK}寄存器

@item q
@samp{MQ}寄存器

@item c
@samp{CTR}寄存器

@item l
@samp{LINK}寄存器

@item x
@samp{CR}寄存器(条件寄存器)编号0

@item y
@samp{CR}寄存器(条件寄存器)

@item z
@samp{FPMEM}栈内存，用于FPR-GPR传送

@item I
有符号16位常量

@item J
无符号16位常量，向左移16位（使用@samp{L}来替代常量）

@item K
无符号16位常量

@item L
有符号16位常量，向左移16位

@item M
大于31的常量

@item N
2的幂

@item O
零

@item P
常量，其负数为有符号的16位常量

@item G
浮点常量，可以使用一个字的指令将其加载到寄存器中

@item H
整数/浮点常量，可以使用三条指令将其加载到寄存器中

@item Q
内存操作数，相对于寄存器的偏移量(@samp{m}适用于@code{asm}语句)

@item Z
内存操作数，来自寄存器的一个索引或者间接访问(@samp{m}适用于@code{asm}语句)

@item R
AIX TOC项

@item a
地址操作数，来自寄存器的一个索引或者间接访问(@samp{p}适用于@code{asm}语句)

@item S
适于作64位掩码操作数的常量

@item T
适于作32位掩码操作数的常量

@item U
System V Release 4对小数据区域的引用

@item t
AND掩码，可以通过两条rldic@{l, r@}指令执行

@item W
不需要内存的向量常量

@end table

@item Intel 386---@file{config/i386/constraints.md}
@table @code
@item R
遗留的寄存---八个在所有i386处理上都可用的寄存器(@code{a}, @code{b}, @code{c}, @code{d},
@code{si}, @code{di}, @code{bp}, @code{sp})。

@item q
任何可以作为@code{@var{r}l}访问的寄存器。在32位机器模式中，为@code{a}, @code{b}, @code{c}和@code{d}; 在64位机器模式中，为任何整数寄存器。

@item Q
任何可以作为@code{@var{r}h}来访问的寄存器：@code{a}, @code{b}, @code{c}和@code{d}。

@ifset INTERNALS
@item l
任何在基址+索引的内存访问中，可以作为索引的寄存器：即除了栈指针以外的任何通用寄存器。
@end ifset

@item a
寄存器@code{a}

@item b
寄存器@code{b}

@item c
寄存器@code{c}

@item d
寄存器@code{d}

@item S
寄存器@code{si}

@item D
寄存器@code{di}

@item A
寄存器@code{a}和@code{d}，作为一对（用于在一个寄存器中返回结果的一半，另一个寄存器中返回另一半的指令）

@item f
任何80387浮点（栈）寄存器

@item t
80387浮点栈顶（@code{%st(0)}）

@item u
从80387浮点栈顶起始的第二项(@code{%st(1)})

@item y
任何MMX寄存器

@item x
任何SSE寄存器

@item Yz
第一个SSE寄存器(@code{%xmm0})

@ifset INTERNALS
@item Y2
任何SSE寄存器，当SSE2被启用

@item Yi
任何SSE寄存器，当SSE2和inter-unit move被启用

@item Ym
任何MMX寄存器，当inter-unit move被启用
@end ifset

@item I
整数常量，范围在0 @dots{} 31，用于32位移位

@item J
整数常量，范围在0 @dots{} 63，用于64位移位

@item K
有符号8位整数常量

@item L
@code{0xFF}或者@code{0xFFFF}，用于andsi，作为零扩展move

@item M
0, 1, 2, 或者 3 (用于@code{lea}指令的移位)

@item N
无符号8位整数常量（用于@code{in}和@code{out}指令）

@ifset INTERNALS
@item O
整数常量，范围在0 @dots{} 127，用于64位移位
@end ifset

@item G
标准的80387浮点常量

@item C
标准的SSE浮点常量

@item e
32位有符号整数常量，或者已知适合该范围的符号引用（用于有符号扩展x86-64指令的立即数）

@item Z
32位无符号整数常量，或者已知适合该范围的符号引用（用于零扩展x86-64指令的立即数）

@end table

@item Intel IA-64---@file{config/ia64/ia64.h}
@table @code
@item a
通用寄存器@code{r0}到@code{r3}，用于@code{addl}指令

@item b
分支寄存器

@item c
断言寄存器(@samp{c} as in ``conditional'')

@item d
在M-unit中的应用寄存器

@item e
在I-unit中的应用寄存器

@item f
浮点寄存器

@item m
内存操作数，记住在IA-64上，@samp{m}允许使用@samp{%Pn}打印的后增和后减方式。使用@samp{S}来禁止后增和后减。

@item G
浮点常量0.0或者1.0

@item I
14位有符号整数常量

@item J
22位有符号整数常量

@item K
8位有符号整数常量，用于逻辑指令

@item L
8位被调整的有符号整数常量，用于比较伪操作

@item M
6位无符号整数常量，用于移位计数

@item N
9位有符号整数常量，用于后增方式的加载和存储

@item O
常量零

@item P
0 或者 @minus{}1，用于@code{dep}指令

@item Q
非volatile内存，用于浮点加载和存储

@item R
整数常量范围在1到4，用于@code{shladd}指令

@item S
除了后增和后减以外的内存操作数
@end table

@item FRV---@file{config/frv/frv.h}
@table @code
@item a
类别@code{ACC_REGS}中的寄存器(@code{acc0} 到 @code{acc7}).

@item b
类别@code{EVEN_ACC_REGS}中的寄存器(@code{acc0} 到 @code{acc7}).

@item c
类别@code{CC_REGS}中的寄存器(@code{fcc0} 到 @code{fcc3} 以及 @code{icc0} 到 @code{icc3}).

@item d
类别@code{GPR_REGS}中的寄存器(@code{gr0} 到 @code{gr63}).

@item e
类别@code{EVEN_REGS}中的寄存器(@code{gr0} 到 @code{gr63})。奇数寄存器不在该类中，但是可以使用大于4个字节的机器模式来使用。

@item f
类别@code{FPR_REGS}中的寄存器(@code{fr0} 到 @code{fr63}).

@item h
类别@code{FEVEN_REGS}中的寄存器(@code{fr0} 到 @code{fr63})。奇数寄存器不在该类中，但是可以使用大于4个字节的机器模式来使用。

@item l
类比@code{LR_REG}中的寄存器(@code{lr}寄存器)。

@item q
类别@code{QUAD_REGS}中的寄存器(@code{gr2} 到 @code{gr63})。无法被4整除的寄存器编号不在该类中，但是可以使用大于8个字节的机器模式来使用。

@item t
类别@code{ICC_REGS}中的寄存器(@code{icc0} 到 @code{icc3}).

@item u
类别@code{FCC_REGS}中的寄存器(@code{fcc0} 到 @code{fcc3}).

@item v
类别@code{ICR_REGS}中的寄存器(@code{cc4} 到 @code{cc7}).

@item w
类别@code{FCR_REGS}中的寄存器(@code{cc0} 到 @code{cc3}).

@item x
类别@code{QUAD_FPR_REGS}中的寄存器(@code{fr0} 到 @code{fr63})。无法被4整除的寄存器编号不在该类中，但是可以使用大于8个字节的机器模式来使用。

@item z
类别@code{SPR_REGS}中的寄存器(@code{lcr} 和 @code{lr}).

@item A
类别@code{QUAD_ACC_REGS}中的寄存器(@code{acc0} 到 @code{acc7}).

@item B
类别@code{ACCG_REGS}中的寄存器(@code{accg0} 到 @code{accg7}).

@item C
类别@code{CR_REGS}中的寄存器(@code{cc0} 到 @code{cc7}).

@item G
浮点常量零

@item I
6位有符号整数常量

@item J
10位有符号整数常量

@item L
16位有符号整数常量

@item M
16位无符号整数常量

@item N
12位有符号整数常量，且为负---即，范围在@minus{}2048 到 @minus{}1

@item O
常量零

@item P
12有符号整数常量，且大于零---即，范围在1到2047

@end table

@item Blackfin family---@file{config/bfin/constraints.md}
@table @code
@item a
P寄存器

@item d
D寄存器

@item z
被函数调用破坏的P寄存器

@item q@var{n}
单个寄存器。如果@var{n}在范围0到7中，则对应D寄存器。如果为@code{A}，则是寄存器P0。

@item D
偶数编号的D寄存器

@item W
奇数编号的D寄存器

@item e
累加寄存器

@item A
偶数编号的累加寄存器

@item B
奇数编号的累加寄存器

@item b
I寄存器

@item v
B寄存器

@item f
M寄存器

@item c
用于循环缓冲的寄存器，即I, B或者L寄存器。

@item C
CC寄存器

@item t
LT0或者LT1.

@item k
LC0或者LC1.

@item u
LB0或者LB1.

@item x
任何D, P, B, M, I 或者L寄存器。

@item y
通常只用于函数序言和尾声的额外寄存器：RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT 和 USP。

@item w
除了累加器和CC以外的任何寄存器。

@item Ksh
有符号16位整数（范围在-32768到32767）

@item Kuh
无符号16位整数(范围在0到65535)

@item Ks7
有符号7位整数(范围在-64 到 63)

@item Ku7
无符号7位整数(范围在0到127)

@item Ku5
无符号5位整数(范围在0到31)

@item Ks4
有符号4位整数(范围在-8到7)

@item Ks3
有符号3位整数(范围在-3到4)

@item Ku3
无符号3位整数(范围在0到7)

@item P@var{n}
常量@var{n}，为一单个数字的常量，范围在0到4。

@item PA
一个整数，等于MACFLAG_XXX常量中的一个，适合用于每个累加器。

@item PB
一个整数，等于MACFLAG_XXX常量中的一个，只适合用于累加器A1。

@item M1
常量255

@item M2
常量65535

@item J
整数常量，只有一个位被设置。

@item L
整数常量，只有一个位没有被设置。

@item H

@item Q
任何SYMBOL_REF
@end table

@item M32C---@file{config/m32c/m32c.c}
@table @code
@item Rsp
@itemx Rfb
@itemx Rsb
@samp{$sp}, @samp{$fb}, @samp{$sb}.

@item Rcr
任何控制寄存器，16位宽的时候

@item Rcl
任何控制寄存器，24位宽的时候

@item R0w
@itemx R1w
@itemx R2w
@itemx R3w
$r0, $r1, $r2, $r3.

@item R02
$r0 或 $r2, 或用于32位值的$r2r0

@item R13
$r1 或 $r3, 或用于32位值的$r3r1

@item Rdi
可以存放64位值的寄存器

@item Rhl
$r0 或 $r1 (具有可寻址的高／低字节的寄存器)

@item R23
$r2 或 $r3

@item Raa
地址寄存器

@item Raw
地址寄存器，16位宽的时候

@item Ral
地址寄存器，24位宽的时候

@item Rqi
可以存放QI值的寄存器

@item Rad
可以和偏移一起使用的寄存器($a0, $a1, $sb)

@item Rsi
可以存放32位值的寄存器

@item Rhi
可以存放16位值的寄存器

@item Rhc
可以存放16位值的寄存器，包括所有的控制寄存器

@item Rra
$r0到R1，加上$a0和$a1

@item Rfl
标记寄存器

@item Rmm
基于内存的伪寄存器，$mem0到$mem15

@item Rpi
可以存放指针的寄存器(16位寄存器r8c, m16c; 24位寄存器m32cm, m32c)

@item Rpa
并行的匹配多个寄存器，形成一个大的寄存器。用于匹配函数返回值

@item Is3
-8 @dots{} 7

@item IS1
-128 @dots{} 127

@item IS2
-32768 @dots{} 32767

@item IU2
0 @dots{} 65535

@item In4
-8 @dots{} -1 或 1 @dots{} 8

@item In5
-16 @dots{} -1 或 1 @dots{} 16

@item In6
-32 @dots{} -1 或 1 @dots{} 32

@item IM2
-65536 @dots{} -1

@item Ilb
一个8位的值，且只有一个位被设置

@item Ilw
一个16位的值，且只有一个位被设置

@item Sd
普通的src/dest内存寻址模式

@item Sa
使用$a0或$a1的寻址模式

@item Si
带有立即数地址的寻址内存

@item Ss
使用栈指针($sp)寻址的内存

@item Sf
使用帧基址寄存器($fb)寻址的内存

@item Ss
使用小基址寄存器($sb)寻址的内存

@item S1
$r1h
@end table

@item MIPS---@file{config/mips/constraints.md}
@table @code
@item d
地址寄存器。与@code{r}等价，只不过是生成MIPS16代码

@item f
浮点寄存器（如果可用）

@item h
之前为@code{hi}寄存器。该约束不再被支持。

@item l
@code{lo}寄存器。使用该寄存器来存放不大于一个字的值。

@item x
@code{hi} 和 @code{lo}寄存器的结合。使用该寄存器来存放双字的值。

@item c
适用于间接跳转的寄存器。对于@option{-mabicalls}，其将总是为@code{$25}。

@item v
寄存器@code{$3}。不要在新的代码中使用该约束；保留它只是为了与glibc兼容。

@item y
等价于@code{r}; 保留它是为了向后兼容。

@item z
浮点条件代码寄存器

@item I
有符号16位常量(用于算术指令)

@item J
整数零

@item K
无符号16位常量(用于逻辑指令)

@item L
有符号32位常量，其中低16位为零。这样的常量可以使用@code{lui}来加载。

@item M
不可以使用@code{lui}, @code{addiu}或@code{ori}加载的常量。

@item N
常量，范围在-65535 到 -1 (含)。

@item O
有符号15位常量

@item P
常量，范围在1到65535 (含)

@item G
浮点零

@item R
可以用于非宏的加载和存储中的地址。
@end table

@item Motorola 680x0---@file{config/m68k/constraints.md}
@table @code
@item a
地址寄存器

@item d
数据寄存器

@item f
68881浮点寄存器，如果可用

@item I
整数，范围在1到8

@item J
16位有符号数字

@item K
有符号数字，大于0x80

@item L
整数，范围在@minus{}8 到 @minus{}1

@item M
有符号数字，大于0x100

@item N
范围在24到31，rotatert:SI 8 到 1，表示为rotate

@item O
16 (使用swap的rotate)

@item P
范围在8到15，rotatert:HI 8 到 1，表示为rotate

@item R
mov3q可以处理的数字

@item G
浮点常量，且不是68881常量

@item S
操作数，当-mpcrel有效时，满足'm'

@item T
操作数，当-mpcrel无效时，满足's'

@item Q
地址寄存器，简介寻址模式

@item U
寄存器偏移寻址

@item W
const_call_operand

@item Cs
symbol_ref 或 const

@item Ci
const_int

@item C0
const_int 0

@item Cj
不适合16位的有符号数的范围不适合16位

@item Cmvq
用于mvq的整数

@item Capsw
整数，用于moveq后面跟一个swap

@item Cmvz
用于mvz的整数

@item Cmvs
用于mvs的整数

@item Ap
push_operand

@item Ac
允许在clr中使用的非寄存器操作数

@end table

@item Motorola 68HC11 & 68HC12 families---@file{config/m68hc11/m68hc11.h}
@table @code
@item a
寄存器`a'

@item b
寄存器`b'

@item d
寄存器`d'

@item q
8位寄存器

@item t
临时软寄存器_.tmp

@item u
软寄存器_.d1 到 _.d31

@item w
栈指针寄存器

@item x
寄存器`x'

@item y
寄存器`y'

@item z
伪寄存器`z' (在后来被`x' 或 `y'替换)

@item A
地址寄存器：x, y 或 z

@item B
地址寄存器：x 或 y

@item D
寄存器(x:d)，形成一个32位的值

@item L
常量，范围在@minus{}65536 到 65535

@item M
常量，低16位为零

@item N
常整数1 或 @minus{}1

@item O
常整数16

@item P
常量，范围在@minus{}8 到 2

@end table

@need 1000
@item SPARC---@file{config/sparc/sparc.h}
@table @code
@item f
SPARC-V8体系结构上的浮点寄存器，以及SPARC-V9体系结构上的低浮点寄存器。

@item e
浮点寄存器。在SPARC-V8体系结构上等价于@samp{f}，在SPARC-V9体系结构上包含低位和高位的浮点寄存器。

@item c
浮点条件代码寄存器。

@item d
低位浮点寄存器。只用于SPARC-V9体系结构上，当虚拟指令集可用的时候。

@item b
浮点寄存器。只用于SPARC-V9体系结构上，当虚拟指令集可用的时候。

@item h
64位global或out寄存器，用于SPARC-V8+体系结构。

@item D
向量常量

@item I
有符号13位常量

@item J
零

@item K
32位常量，低12位被清零（可以使用@code{sethi}指令加载的常量）

@item L
@code{movcc}指令所支持的范围内的常量

@item M
@code{movrcc}指令所支持的范围内的常量

@item N
与@samp{K}相同，只不过，其会验证不在低32位范围的位全是零。对于机器模式宽于@code{SImode}的，比需使用其，而不是@samp{K}

@item O
常量4096

@item G
浮点零

@item H
有符号13位常量，符号扩展到32或64位

@item Q
浮点常量，其整数表示可以使用单个sethi指令，被移送到整数寄存器中。

@item R
浮点常量，其整数表示可以使用单个mov指令，被移送到整数寄存器中。

@item S
浮点常量，其整数表示可以使用一个high/lo_sum指令序列，被移送到整数寄存器中。

@item T
内存地址，对齐到8字节的边界

@item U
偶数寄存器

@item W
内存地址，用于@samp{e}约束寄存器

@item Y
向量零

@end table

@item SPU---@file{config/spu/spu.h}
@table @code
@item a
立即数，可以使用il/ila/ilh/ilhu指令加载。const_int被当作64位值。

@item c
立即数，用于and/xor/or指令。const_int被当作64位值。

@item d
立即数，用于@code{iohl}指令。const_int被当作64位值。

@item f
立即数，可以使用@code{fsmbi}指令加载。  

@item A
立即数，可以使用il/ila/ilh/ilhu指令加载。const_int被当作32位值。 

@item B
立即数，用于大多算术指令。const_int被当作32位值。  

@item C
立即数，用于and/xor/or指令。const_int被当作32位值。 

@item D
立即数，用于@code{iohl}指令。const_int被当作32位值。  

@item I
常量，范围为[-64, 63]，用于shift/rotate指令。  

@item J
无符号7位常量，用于conversion/nop/channel指令。  

@item K
有符号10位常量，用于大多算术指令。  

@item M
有符号16位立即数，用于@code{stop}。 

@item N
无符号16位常量，用于@code{iohl}和@code{fsmbi}。  

@item O
无符号7位常量，其3个最小有效位是0。  

@item P
无符号3位常量，用于16字节的rotate和shift。

@item R
调用操作数，寄存器，用于间接调用。

@item S
调用操作数，符号，用于相关调用。  

@item T
调用操作数，const_int，用于绝对调用。  

@item U
立即数，可以使用il/ila/ilh/ilhu指令加载。const_int被扩展为128位。  

@item W
立即数，用于shift和rotate指令。const_int被当作32位值。  

@item Y
立即数，用于and/xor/or指令。const_int被有符号扩展为128位。  

@item Z
立即数，用于@code{iohl}指令。const_int被有符号扩展为128位。  

@end table

@item S/390 and zSeries---@file{config/s390/s390.h}
@table @code
@item a
地址寄存器(通用目的寄存器，除了r0)

@item c
条件代码寄存器

@item d
数据寄存器（任意通用寄存器）

@item f
浮点寄存器

@item I
无符号8位常量(0--255)

@item J
无符号12位常量(0--4095)

@item K
有符号16位常量(@minus{}32768--32767)

@item L
适合作偏移量的值
@table @code
@item (0..4095)
短偏移
@item (-524288..524287)
长偏移
@end table

@item M
常量整数，值为0x7fffffff

@item N
多个字母约束，跟随4个参数字母
@table @code
@item 0..9:
部分的编号，从最大有效到最小有效计数
@item H,Q:
部分的机器模式
@item D,S,H:
包含的操作数的机器模式
@item 0,F:
其它部分的值(F---所有位都被设置)
@end table
如果常量所指定的部分具有与其它部分不同的值，则约束匹配

@item Q
没有索引寄存器，但是有短偏移的内存引用

@item R
具有索引寄存器和短偏移的内存引用

@item S
没有索引寄存器，但是有长偏移的内存引用

@item T
具有索引寄存器和长偏移的内存引用

@item U
具有短偏移的指针

@item W
具有长偏移的指针

@item Y
移位计数操作数

@end table

@item Score family---@file{config/score/score.h}
@table @code
@item d
寄存器r0到r32

@item e
寄存器r0到r16

@item t
r8---r11 或 r22---r27 寄存器

@item h
hi寄存器

@item l
lo寄存器

@item x
hi + lo 寄存器

@item q
cnt寄存器

@item y
lcb寄存器

@item z
scb寄存器

@item a
cnt + lcb + scb寄存器

@item c
cr0---cr15寄存器

@item b
cp1寄存器

@item f
cp2寄存器

@item i
cp3寄存器

@item j
cp1 + cp2 + cp3寄存器

@item I
高16位常量(32位常量，16位最小有效位为零)

@item J
无符号5位整数(范围从0到31)

@item K
无符号16位整数(范围从0到65535)

@item L
有符号16位整数(范围从@minus{}32768到32767)

@item M
无符号14位整数(范围从0到16383)

@item N
有符号14位整数(范围从@minus{}8192到8191)

@item Z
任何SYMBOL_REF
@end table

@item Xstormy16---@file{config/stormy16/stormy16.h}
@table @code
@item a
寄存器r0

@item b
寄存器r1

@item c
寄存器r2

@item d
寄存器r8

@item e
寄存器r0到r7

@item t
寄存器r0和r1

@item y
进位寄存器

@item z
寄存器r8和r9

@item I
常量，在0和3之间

@item J
常量，只有一位被设置

@item K
常量，只有一位被清零

@item L
常量，在0和255之间

@item M
常量，在@minus{}255和0之间

@item N
常量，在@minus{}3和0之间

@item O
常量，在1和4之间

@item P
常量，在@minus{}4和@minus{}1之间

@item Q
内存引用，为一个栈压入

@item R
内存引用，为一个栈弹出

@item S
内存引用，表示一个已知的常量地址

@item T
通过Rx指示的寄存器（还没实现）

@item U
不在2和15之间的常量

@item Z
常量0

@end table

@item Xtensa---@file{config/xtensa/constraints.md}
@table @code
@item a
通用32位寄存器

@item b
一位布尔寄存器

@item A
MAC16 40位累加器

@item I
有符号12位整数常量，用在MOVI指令中

@item J
有符号8位整数常量，用在ADDI指令中

@item K
整数常量，用于BccI指令

@item L
无符号常量，用于BccUI指令

@end table

@end table

@ifset INTERNALS
@node 禁止Insn可选项
@subsection 使用@code{enabled}属性来禁止insn可选项
@cindex enabled

insn属性@code{enabled}，可以出于机器特定的原因，用来禁止特定的insn的可选项。这用于，当为现有的指令模式，增加新的指令，且其只用于使用@code{-march=}选项指定的特定cpu体系结构级别。

如果insn的可选项被禁止，则其将不被使用。编译器将被禁止的可选项的约束视为不被满足。

为了能够使用@code{enabled}属性，后端必须在机器描述文件中增加：

@enumerate
@item
对@code{enabled} insn属性的定义。该属性通常使用@code{define_attr}命令来定义。该定义应该基于其它insn属性以及/或者目标机标记。@code{enabled}属性为数字属性，并且对于被启用的可选项应该求值为@code{(const_int 1)}，否则为@code{(const_int 0)}。

@item
另一个insn属性的定义，用于描述为什么一个insn可选项可用或不可用。例如，下面例子中的@code{cpu_facility}。

@item
对每个insn定义，赋予第二个属性。（注意：显然只是针对那些具有多个可选项的定义。其它insn模式应该使用insn条件来禁止或开启。）

@end enumerate

例如，下面两个指令模式可以容易的使用@code{enabled}属性合并在一起：

@smallexample

(define_insn "*movdi_old"
  [(set (match_operand:DI 0 "register_operand" "=d")
        (match_operand:DI 1 "register_operand" " d"))]
  "!TARGET_NEW"
  "lgr %0,%1")

(define_insn "*movdi_new"
  [(set (match_operand:DI 0 "register_operand" "=d,f,d")
        (match_operand:DI 1 "register_operand" " d,d,f"))]
  "TARGET_NEW"
  "@@
   lgr  %0,%1
   ldgr %0,%1
   lgdr %0,%1")

@end smallexample

合并成:

@smallexample

(define_insn "*movdi_combined"
  [(set (match_operand:DI 0 "register_operand" "=d,f,d")
        (match_operand:DI 1 "register_operand" " d,d,f"))]
  ""
  "@@
   lgr  %0,%1
   ldgr %0,%1
   lgdr %0,%1"
  [(set_attr "cpu_facility" "*,new,new")])

@end smallexample

其中@code{enabled}属性的定义为：

@smallexample

(define_attr "cpu_facility" "standard,new" (const_string "standard"))

(define_attr "enabled" ""
  (cond [(eq_attr "cpu_facility" "standard") (const_int 1)
         (and (eq_attr "cpu_facility" "new")
              (ne (symbol_ref "TARGET_NEW") (const_int 0)))
         (const_int 1)]
        (const_int 0)))

@end smallexample

@end ifset

@ifset INTERNALS
@node 定义constraint
@subsection 定义机器特定的constraint
@cindex defining constraints
@cindex constraints, defining

机器特定的约束分为两类：寄存器约束和非寄存器约束。在后者中，
如果约束允许所有可能的内存或地址操作数，则应该被专门标记出来，
以便给@code{reload}更多信息。

机器特定的约束可以给定任意长度的名字，但是它们全部由字母，数字，
下划线（@samp{_}）和三角括号（@samp{< >}）组成。跟C标识符类似，
它们必须起始于字母或者下划线。

为了避免操作数约束字符串的混淆，约束的名字不能起始于任何其它约束的名字。
例如，如果@code{x}被定义为一个约束名，则不可以定义@code{xy}，反之依然。
按照这个规则，所有约束都不能起始于通用约束字母：@samp{E F V X g i m n o p r s}。

寄存器约束直接对应于寄存器类别。参见@ref{寄存器类别}。
因此它们的定义没有太多的灵活性。

@deffn {MD Expression} define_register_constraint name regclass docstring
这三个参数都是字符串常量。@var{name}为约束的名字，
将在@code{match_operand}表达式中出现。如果@var{name}为多个字母的约束，
则它的长度应该与所有起始与同一字母的约束相同。
@var{regclass}可以为相应的寄存器类别的名字（参见@ref{寄存器类别}），
或者一个C表达式，其值为合适的寄存器类别。如果为表达式，其必须不具有副作用，
并且不能查看操作数。通常使用表达式是为了当寄存器类别对于给定的子体系结构无效时，
将一些寄存器约束映射为@code{NO_REGS}。

@var{docstring}为一条语句，介绍了约束的含义。这将在下面做进一步的解释。
@end deffn

非寄存器的约束更加像断言：约束定义给出一个布尔表达式，其指示是否约束匹配。

@deffn {MD Expression} define_constraint name docstring exp
@var{name}和@var{docstring}参数与@code{define_register_constraint}的相同，
但是注意docstring直接跟随name之后。@var{exp}为一个RTL表达式，
遵循在断言定义中相同的规则。详情参见@ref{定义predicate}。如果求得为真，
则约束匹配；如果求得为假，则不匹配。约束表达式应该指示出它们可能匹配的RTL，
就像断言表达式一样。

C表达式@code{match_test}，可以访问下列变量：

@table @var
@item op
定义操作数的RTL对象。 
@item mode
@var{op}的机器模式。
@item ival
@samp{INTVAL (@var{op})}, 如果@var{op}为@code{const_int}。
@item hval
@samp{CONST_DOUBLE_HIGH (@var{op})}, 如果@var{op}为整数@code{const_double}。
@item lval
@samp{CONST_DOUBLE_LOW (@var{op})}, 如果@var{op}为整数@code{const_double}。 
@item rval
@samp{CONST_DOUBLE_REAL_VALUE (@var{op})}, 
如果@var{op}为浮点@code{const_double}。 
@end table

变量@var{*val}应该只在表达式的其它部分已经验证了@var{op}为合适类型的RTL对象时，
才被使用。
@end deffn

大多数非寄存器约束应该使用@code{define_constraint}来定义。
其余的两个定义表达式只适合当约束匹配失败时，应该由@code{reload}单独处理的约束。

@deffn {MD Expression} define_memory_constraint name docstring exp
使用该表达式来定义匹配所有内存操作数的子集的约束：也就是，
@code{reload}能够通过将操作数转换为@samp{@w{(mem (reg @var{X}))}}的形式使得它们
匹配。其中@var{X}为基址寄存器（通过@code{BASE_REG_CLASS}指定的寄存器类别，
参见@ref{寄存器类别}）。

例如，在S/390上，一些指令不接受任意的内存引用，只接受那些不使用索引寄存器的。
约束字母@samp{Q}被定义用来表示这个类型的内存地址。
如果@samp{Q}使用@code{define_memory_constraint}定义，
则@samp{Q}约束可以处理任意内存操作数，因为@code{reload}知道在需要的时候，
它可以简单的将内存地址复制到基址寄存器中。
这与@samp{o}约束可以处理任意内存操作数的方式类似。

语法和语义在其它方面都与@code{define_constraint}相同。
@end deffn

@deffn {MD Expression} define_address_constraint name docstring exp
使用该表达式来定义匹配所有地址操作数的子集的约束：也就是，
@code{reload}能够通过将操作数转换为@samp{@w{(reg @var{X})}}的形式使得它们匹配。
同样@var{X}为基址寄存器。

使用@code{define_address_constraint}定义的约束只能用于@code{address_operand}断言
，或者机器特定的同样方式的断言。它们与通用的@samp{p}约束类似。

语法和语义在其它方面都与@code{define_constraint}相同。
@end deffn

由于历史的原因，
起始于字母@samp{G H}的名字被保留为只匹配@code{const_double}的约束，
起始与字母@samp{I J K L M N O P}被保留为只匹配@code{const_int}的约束。
这在将来可能会改变。暂时的，这些名字的约束必须使用固定形式来书写，
以便@code{genpreds}能够辨别出你在做正确的事情：

@smallexample
@group
(define_constraint "[@var{GHIJKLMNOP}]@dots{}"
  "@var{doc}@dots{}"
  (and (match_code "const_int")  ; @r{@code{const_double} for G/H}
       @var{condition}@dots{}))            ; @r{usually a @code{match_test}}
@end group
@end smallexample
@c the semicolons line up in the formatted manual

可以使用起始于其它字母的名字来定义匹配@code{const_double}或@code{const_int}的约束。

在约束定义中的每个docstring应该是一条或多条完整的语句，使用Texinfo格式来标记。
它们目前没有被使用。在将来，它们将被复制到 GCC手册中，在机器约束这一章节，
用来替换手工维护的表格。而且，将来编译器可以使用其来给出更多有帮助的诊断信息，
当过少的@code{asm}约束选择造成重载失败时。

如果你在docstring的起始出放入伪Texinfo指令@samp{@@internal}，
则（在将来）其将只出现在internals手册版本的机器特定约束表中。
这可以用于不应该出现在@code{asm}语句中的约束。

@node C constraint接口
@subsection 从C中测试constraint
@cindex testing constraints
@cindex constraints, testing

有时从C代码中测试约束要比隐式的通过@code{match_operand}中的约束字符串有用处。
生成文件@file{tm_p.h}声明了一些接口，用于机器特定的约束。
这些接口都没有用于在@ref{简单constraint}中描述的通用约束。
这在将来可能会有所改变。

警告：@file{tm_p.h}可能声明了其它操作约束的函数，除了在这里列的以外。
不要在机器独立的代码中使用那些函数。它们只是为了实现旧的约束接口。
它们在将来将会有变动或者消失。

一些有效的约束名字不是有效的C标志符，
所以这里有一个mangling框架用于从C中引用它们。
不包含三角括号或者下划线的约束名保持不变。下划线改写成两次，
每个@samp{<}被@samp{_l}替换，每个@samp{>}被@samp{_g}替换。这里有些例子：

@c the @c's prevent double blank lines in the printed manual.
@example
@multitable {Original} {Mangled}
@item @strong{Original} @tab @strong{Mangled}  @c
@item @code{x}     @tab @code{x}       @c
@item @code{P42x}  @tab @code{P42x}    @c
@item @code{P4_x}  @tab @code{P4__x}   @c
@item @code{P4>x}  @tab @code{P4_gx}   @c
@item @code{P4>>}  @tab @code{P4_g_g}  @c
@item @code{P4_g>} @tab @code{P4__g_g} @c
@end multitable
@end example

在该章节中，变量@var{c}或者为一个抽象的约束，
或者为来自@code{enum constraint_num}的常量；
变量@var{m}为一个mangled约束名字（通常作为一个大标志符的一部分）。

@deftp Enum constraint_num
对于每个机器特定的约束，有一个对应的枚举常量：
@samp{CONSTRAINT_}加上约束的mangled名字。
函数接受一个@code{enum constraint_num}作为参数。

机器独立的约束不具有相关的常量。这在将来可能会有改变。
@end deftp

@deftypefun {inline bool} satisfies_constraint_@var{m} (rtx @var{exp})
对于每个机器特定的，非寄存器约束@var{m}，有一个这样函数；其返回@code{true}，
如果@var{exp}满足约束。
这些函数只有当@file{rtl.h}被包含在@file{tm_p.h}之前时才可见。
@end deftypefun

@deftypefun bool constraint_satisfied_p (rtx @var{exp}, enum constraint_num @var{c})
类似@code{satisfies_constraint_@var{m}}函数，只是被测试的约束作为参数给出，
@var{c}。如果@var{c}指定一个寄存器约束，该函数将总是返回@code{false}。
@end deftypefun

@deftypefun {enum reg_class} regclass_for_constraint (enum constraint_num @var{c})
返回与@var{c}关联的寄存器类别。如果@var{c}不是寄存器约束，
或者那些寄存器对于当前选择的子target无效，则返回@code{NO_REGS}。
@end deftypefun

这里有一个使用@code{satisfies_constraint_@var{m}}的例子。
在窥孔优化（参见@ref{窥孔定义}）中，操作数约束字符串将被忽略，
所以如果有相应的约束，它们必须在C条件中被测试。在例子中，优化将被采用，
如果操作数2不满足@samp{K}约束。（这是从 i386机器描述中的窥孔定义简化的版本。）

@smallexample
(define_peephole2
  [(match_scratch:SI 3 "r")
   (set (match_operand:SI 0 "register_operand" "")
        (mult:SI (match_operand:SI 1 "memory_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))]

  "!satisfies_constraint_K (operands[2])"

  [(set (match_dup 3) (match_dup 1))
   (set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))]

  "")
@end smallexample

@node 标准名字
@section 用于生成的标准指令模式名
@cindex standard pattern names
@cindex pattern names
@cindex names, pattern

这里有一个在编译器的RTL生成过程中有意义的指令名称表，在指令模式中给定这些名字中的一个，则告诉RTL生成过程，其可以使用该指令模式来完成一个特定的任务。

@table @asis
@cindex @code{mov@var{m}} instruction pattern
@item @samp{mov@var{m}}
这里@var{m}表示一个两字母的机器模式名字，小写。该指令模式将那种机器模式的数据从操作数1移送到操作数0。例如@samp{movsi}移送整字数据。

如果操作数0为一个寄存器的@code{subreg}，机器模式为@var{m}，寄存器自己的机器模式比@var{m}更宽，则该指令的效果是将指定的值存储在寄存器的对应于机器模式@var{m}的部分。@var{m}之外，且与@code{subreg}在同一个目标字中的位，为未定义。目标字以外的位保持不变。

这类指令模式有几处特别的地方。首先，每个这些直到整字大小的名字，包括整字大小的，必须被定义，因为没有其它方式来从一个地方将数据复制到另一个地方。如果有接受更大机器模式的操作数的指令模式，则必须为那些大小的整数机器模式定义@samp{mov@var{m}}。

第二，这些指令模式不仅用在RTL生成过程。甚至重载过程可以生成move insn将值从栈槽复制到临时寄存器中。当这样的时候，其中一个操作数为硬件寄存器，另一个为需要被重载到寄存器中的操作数。

@findex force_reg
因此，当给定这样一对操作数时，指令模式必须生成不需要重载，并且不需要临时寄存器的RTL。例如，如果你使用一个@code{define_expand}来支持该指令模式，则这种情况下，@code{define_expand}一定不能调用@code{force_reg}或者任何其它可能生成新的伪寄存器的函数。

甚至对于在RISC机器上的子字机器模式，从内存中获取这些机器模式通常需要多个insn和一些临时变量，该要求也存在。

@findex change_address
重载过程中，具有无效地址的内存引用可以被作为操作数。这样的地址将在重载过程的后面被替换成有效地址。这种情况下，可能对地址没有做任何事情，而只是使用它。如果其被复制，则将无法使用有效的地址进行替换。不要尝试将这样的地址变成有效的地址。注意，@code{general_operand}当应用到这样的地址的时候将会失败。

@findex reload_in_progress
全局变量@code{reload_in_progress}（其必须被显式的声明）可以用来确定是否需要这样的特殊的处理。

需要进行重载的操作数的种类取决于机器描述的其余部分，不过通常在RISC机器上，只有那些没有获得硬件寄存器的伪寄存器，而在其它机器上，显式的内存引用也有可能需要进行重载。

如果一个scratch寄存器，被需要用来将一个对象与内存之间进行移送，则其可以活跃分析之前，使用@code{gen_reg_rtx}来进行分配。

如果在重载过程中，或者之后，有需要scratch寄存器的情况，则你必须提供一个适当的secondary_reload目标钩子。

@findex can_create_pseudo_p
宏@code{can_create_pseudo_p}可以用来确定创建一个新的伪寄存器是否不安全。如果该变量为非零，则调用@code{gen_reg_rtx}来分配一个新的伪寄存器是不安全的。

@samp{mov@var{m}}上的约束必须允许将任何硬件寄存器移送到任何其它硬件寄存器上，假设@code{HARD_REGNO_MODE_OK}在两个寄存器上都允许机器模式@var{m}，并且@code{REGISTER_MOVE_COST}应用到它们的类别上返回值2。

必须提供浮点@samp{mov@var{m}}指令，用于任何可以存放定点值的寄存器，因为联合体和结构体（具有机器模式@code{SImode}或@code{DImode}）可以在那些寄存器中，并且它们可以具有浮点成员。

还需要支持定点@samp{mov@var{m}}指令，用于浮点寄存器。不幸的是，我忘了为什么要这样，并且不知道这是否还是真的。如果@code{HARD_REGNO_MODE_OK}排斥在浮点寄存器中的定点值，则定点@samp{mov@var{m}}指令的约束必须被设计成，避免尝试重载到一个浮点寄存器。

@cindex @code{reload_in} instruction pattern
@cindex @code{reload_out} instruction pattern
@item @samp{reload_in@var{m}}
@itemx @samp{reload_out@var{m}}
这些命名指令模式已经被目标钩子@code{secondary_reload}废弃。

类似@samp{mov@var{m}}，不过用于当需要使用scratch寄存器在操作数0和操作数1之间移送的时候。操作数2描述scratch寄存器。参见在@pxref{寄存器类别}中对@code{SECONDARY_RELOAD_CLASS}宏的讨论。

这些指令模式中的@code{match_operand}的形式，有一些特殊的限制。首先，只有重载操作数的断言才被检查，即@code{reload_in}检查操作数1，而不检查操作数0和2。第二，在约束中只能有一个可选项。第三，约束只能使用单个寄存器类别字母；后续的约束字母都被忽略。一个例外是，空的约束字符串匹配@code{ALL_REGS}寄存器类别。这可以减轻后端为这些指令模式定义@code{ALL_REGS}约束字母的负担。

@cindex @code{movstrict@var{m}} instruction pattern
@item @samp{movstrict@var{m}}
类似@samp{mov@var{m}}，只不过，如果操作数0为一个寄存器的机器模式为@var{m}的@code{subreg}，且寄存器的自然机器模式是较宽的，则@samp{movstrict@var{m}}指令保证不会修改属于机器模式@var{m}之外的寄存器的任何部分。

@cindex @code{movmisalign@var{m}} instruction pattern
@item @samp{movmisalign@var{m}}
该move指令模式的变体，被设计为从没有与其机器模式自然对齐的内存地址中加载和存储值。对于存储，内存将在操作数0中；对于加载，内存将在操作数1中。其它操作数保证不为内存，所以容易判别是加载还是存储。

该指令模式用于向量化，当展开@code{MISALIGNED_INDIRECT_REF}表达式的时候。

@cindex @code{load_multiple} instruction pattern
@item @samp{load_multiple}
将多个连续的内存位置加载到连续的寄存器中。操作数0为连续寄存器中的第一个，操作数1为第一个内存位置，操作数2为一个常量：连续寄存器的数目。

只有当目标机器确实具有这样指令的时候才定义该指令模式；如果将内存加载到连续寄存器的最有效的方式，是每次加载一个，则 不用定义该指令模式。

在一些机器上，对于哪些连续寄存器可以存储到内存中，会有一些限制，例如特定的起始寄存器或者结尾寄存器的编号，或者一个有效范围。对于那些机器，使用@code{define_expand} (@pxref{扩展定义})，并当不符合限制的时候，将指令模式变成失败。

将生成的insn写成一个@code{parallel}，其元素为一个从适当内存位置到寄存器的@code{set}（可能还需要@code{use}或元素@code{clobber}）。使用@code{match_parallel} (@pxref{RTL模板})来识别insn。关于使用该insn模式的例子，可以参见@file{rs6000.md}。

@cindex @samp{store_multiple} instruction pattern
@item @samp{store_multiple}
类似于@samp{load_multiple}，不过是将多个连续的寄存器存储到连续的内存位置。操作数0为连续内存位置的第一个，操作数1为第一个寄存器，操作数2为常量：连续寄存器的数目。 

@cindex @code{vec_set@var{m}} instruction pattern
@item @samp{vec_set@var{m}}
设置向量中给定的域。操作数0为要修改的向量，操作数1为域的新值，操作数2指定了域的索引。

@cindex @code{vec_extract@var{m}} instruction pattern
@item @samp{vec_extract@var{m}}
从向量中抽取给定的域。操作数1为向量，操作数2指定了域索引，操作数0为存放值的地方。

@cindex @code{vec_extract_even@var{m}} instruction pattern
@item @samp{vec_extract_even@var{m}}
从输入向量（操作数1和2）中，抽取偶数元素。操作数2的偶数元素按照它们原来的顺序，连结到操作数1的偶数元素后面。结果存储在操作数0中。输出和输入向量应该具有相同的模式。

@cindex @code{vec_extract_odd@var{m}} instruction pattern
@item @samp{vec_extract_odd@var{m}}
从输入向量（操作数1和2）中，抽取奇数元素。操作数2的奇数元素按照它们原来的顺序，连结到操作数1的奇数元素后面。结果存储在操作数0中。输出和输入向量应该具有相同的模式。

@cindex @code{vec_interleave_high@var{m}} instruction pattern
@item @samp{vec_interleave_high@var{m}}
将两个输入向量的高部分元素合并到输入向量中。输出和输入向量应该具有相同的模式(@code{N}个元素)。第一个输入向量的高@code{N/2}个元素被第二个输入向量的高@code{N/2}个元素交错的插入。

@cindex @code{vec_interleave_low@var{m}} instruction pattern
@item @samp{vec_interleave_low@var{m}}
将两个输入向量的低部分元素合并到输入向量中。输出和输入向量应该具有相同的模式(@code{N}个元素)。第一个输入向量的低@code{N/2}个元素被第二个输入向量的低@code{N/2}个元素交错的插入。

@cindex @code{vec_init@var{m}} instruction pattern
@item @samp{vec_init@var{m}}
将向量初始化为给定的值。操作数0为要初始化的向量，操作数1并行的包含每个域的值。

@cindex @code{push@var{m}1} instruction pattern
@item @samp{push@var{m}1}
输出一个push指令。操作数0是压栈的值。只有当@code{PUSH_ROUNDING}被定义时，才被使用。出于历史原因，该指令模式可以缺失，这种情况下使用@code{mov}扩展来替代，并用@code{MEM}表达式来形成压栈运算。@code{mov}扩展方法不被推荐。

@cindex @code{add@var{m}3} instruction pattern
@item @samp{add@var{m}3}
操作数2加上操作数1，将结果存储在操作数0中。所有操作数必须具有机器模式@var{m}。这也可以用于两地址机器上，通过约束来要求操作数1和0为相同的位置。

@cindex @code{ssadd@var{m}3} instruction pattern
@cindex @code{usadd@var{m}3} instruction pattern
@cindex @code{sub@var{m}3} instruction pattern
@cindex @code{sssub@var{m}3} instruction pattern
@cindex @code{ussub@var{m}3} instruction pattern
@cindex @code{mul@var{m}3} instruction pattern
@cindex @code{ssmul@var{m}3} instruction pattern
@cindex @code{usmul@var{m}3} instruction pattern
@cindex @code{div@var{m}3} instruction pattern
@cindex @code{ssdiv@var{m}3} instruction pattern
@cindex @code{udiv@var{m}3} instruction pattern
@cindex @code{usdiv@var{m}3} instruction pattern
@cindex @code{mod@var{m}3} instruction pattern
@cindex @code{umod@var{m}3} instruction pattern
@cindex @code{umin@var{m}3} instruction pattern
@cindex @code{umax@var{m}3} instruction pattern
@cindex @code{and@var{m}3} instruction pattern
@cindex @code{ior@var{m}3} instruction pattern
@cindex @code{xor@var{m}3} instruction pattern
@item @samp{ssadd@var{m}3}, @samp{usadd@var{m}3}
@item @samp{sub@var{m}3}, @samp{sssub@var{m}3}, @samp{ussub@var{m}3}
@item @samp{mul@var{m}3}, @samp{ssmul@var{m}3}, @samp{usmul@var{m}3}
@itemx @samp{div@var{m}3}, @samp{ssdiv@var{m}3}
@itemx @samp{udiv@var{m}3}, @samp{usdiv@var{m}3}
@itemx @samp{mod@var{m}3}, @samp{umod@var{m}3}
@itemx @samp{umin@var{m}3}, @samp{umax@var{m}3}
@itemx @samp{and@var{m}3}, @samp{ior@var{m}3}, @samp{xor@var{m}3}
类似的，用于其它算术运算。

@cindex @code{min@var{m}3} instruction pattern
@cindex @code{max@var{m}3} instruction pattern
@item @samp{smin@var{m}3}, @samp{smax@var{m}3}
有符号的最小值和最大值运算。当用于浮点，如果两个操作数都为零，或者有一个为@code{NaN}，则没有明确指定哪个操作数作为结果返回。

@cindex @code{reduc_smin_@var{m}} instruction pattern
@cindex @code{reduc_smax_@var{m}} instruction pattern
@item @samp{reduc_smin_@var{m}}, @samp{reduc_smax_@var{m}}
查找向量的有符号最小/最大元素。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{reduc_umin_@var{m}} instruction pattern
@cindex @code{reduc_umax_@var{m}} instruction pattern
@item @samp{reduc_umin_@var{m}}, @samp{reduc_umax_@var{m}}
查找向量的无符号最小/最大元素。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{reduc_splus_@var{m}} instruction pattern
@item @samp{reduc_splus_@var{m}}
计算向量的有符号元素的和。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{reduc_uplus_@var{m}} instruction pattern
@item @samp{reduc_uplus_@var{m}}
计算向量的无符号元素的和。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{sdot_prod@var{m}} instruction pattern
@item @samp{sdot_prod@var{m}}
@cindex @code{udot_prod@var{m}} instruction pattern
@item @samp{udot_prod@var{m}}
计算两个有符号/无符号元素乘积的和。操作数1和2为相同的模式。它们的乘积，为一个宽的模式，被计算并增加到操作数3上。操作数3的机器模式等于或宽于乘积的机器模式。结果被放在操作数0上，其与操作数3具有相同的机器模式。

@cindex @code{ssum_widen@var{m3}} instruction pattern
@item @samp{ssum_widen@var{m3}}
@cindex @code{usum_widen@var{m3}} instruction pattern
@item @samp{usum_widen@var{m3}}
操作数0和2具有相同的机器模式，其比操作数1的宽。将操作数1加上操作数2，并将加宽的结果放在操作数0中。（这用于表示元素累加到一个更宽模式的累加器中）

@cindex @code{vec_shl_@var{m}} instruction pattern
@cindex @code{vec_shr_@var{m}} instruction pattern
@item @samp{vec_shl_@var{m}}, @samp{vec_shr_@var{m}}
整个向量向左/向右移位。操作数1为被移位的向量。操作数2为移位的位数。操作数0为移位后的结果向量被存储的地方。输出和输入向量应该具有相同的模式。

@cindex @code{vec_pack_trunc_@var{m}} instruction pattern
@item @samp{vec_pack_trunc_@var{m}}
变窄（降级）并合并两个向量的元素。操作数1和2为具有相同机器模式，N个，大小为S的整数或者浮点元素的向量。操作数0为结果向量，通过使用截取的方式，将它们变窄并连接成，2×N个大小为N/2的元素。

@cindex @code{vec_pack_ssat_@var{m}} instruction pattern
@cindex @code{vec_pack_usat_@var{m}} instruction pattern
@item @samp{vec_pack_ssat_@var{m}}, @samp{vec_pack_usat_@var{m}}
变窄（降级）并合并两个向量的元素。操作数1和2为具有相同机器模式，N个，大小为S的整数元素的向量。操作数0为结果向量，通过使用有符号/无符号饱和算术的方式，将它们变窄并连接成。

@cindex @code{vec_pack_sfix_trunc_@var{m}} instruction pattern
@cindex @code{vec_pack_ufix_trunc_@var{m}} instruction pattern
@item @samp{vec_pack_sfix_trunc_@var{m}}, @samp{vec_pack_ufix_trunc_@var{m}}
将两个向量的元素变窄，转成有符号/无符号整数类型并合并。操作数1和2为具有相同机器模式，N个，大小为S的浮点元素的向量。操作数0为结果向量，由2×N个大小为N/2的元素连接而成。

@cindex @code{vec_unpacks_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacks_lo_@var{m}} instruction pattern
@item @samp{vec_unpacks_hi_@var{m}}, @samp{vec_unpacks_lo_@var{m}}
抽取并变宽（提升），具有有符号整数或浮点元素的，向量的高/低部分。输入向量（操作数1）具有N个大小为S的元素。使用有符号或者浮点扩展，将向量的高/低元素进行变宽（提升），并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

@cindex @code{vec_unpacku_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacku_lo_@var{m}} instruction pattern
@item @samp{vec_unpacku_hi_@var{m}}, @samp{vec_unpacku_lo_@var{m}}
抽取并变宽（提升），具有无符号整数元素的，向量的高/低部分。输入向量（操作数1）具有N个大小为S的元素。使用零扩展，将向量的高/低元素进行变宽（提升），并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

@cindex @code{vec_unpacks_float_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacks_float_lo_@var{m}} instruction pattern
@cindex @code{vec_unpacku_float_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacku_float_lo_@var{m}} instruction pattern
@item @samp{vec_unpacks_float_hi_@var{m}}, @samp{vec_unpacks_float_lo_@var{m}}
@itemx @samp{vec_unpacku_float_hi_@var{m}}, @samp{vec_unpacku_float_lo_@var{m}}
抽取具有有符号/无符号整数元素的，向量的高/低部分，并转换成浮点类型。输入向量（操作数1）具有N个大小为S的元素。使用浮点转换，将向量的高/低元素进行转换，并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

@cindex @code{vec_widen_umult_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_umult_lo__@var{m}} instruction pattern
@cindex @code{vec_widen_smult_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_smult_lo_@var{m}} instruction pattern
@item @samp{vec_widen_umult_hi_@var{m}}, @samp{vec_widen_umult_lo_@var{m}}
@itemx @samp{vec_widen_smult_hi_@var{m}}, @samp{vec_widen_smult_lo_@var{m}}
有符号/无符号加宽乘法。两个输入（操作数1和2）为，N个大小为S的有符号/无符号元素的向量。将两个向量的高/低元素相乘，并将N/2个大小为2×S的乘积放在输出向量（操作数0）中。

@cindex @code{mulhisi3} instruction pattern
@item @samp{mulhisi3}
机器模式为@code{HImode}的操作数1和2相乘，并将@code{SImode}乘积放在操作数0中。

@cindex @code{mulqihi3} instruction pattern
@cindex @code{mulsidi3} instruction pattern
@item @samp{mulqihi3}, @samp{mulsidi3}
类似的其它宽度的加宽乘法指令。

@cindex @code{umulqihi3} instruction pattern
@cindex @code{umulhisi3} instruction pattern
@cindex @code{umulsidi3} instruction pattern
@item @samp{umulqihi3}, @samp{umulhisi3}, @samp{umulsidi3}
类似的加宽乘法指令，进行无符号乘法。


@cindex @code{usmulqihi3} instruction pattern
@cindex @code{usmulhisi3} instruction pattern
@cindex @code{usmulsidi3} instruction pattern
@item @samp{usmulqihi3}, @samp{usmulhisi3}, @samp{usmulsidi3}
类似的加宽乘法指令，将第一个操作数解析为无符号的，第二个为有符号的，然后进行有符号乘法。

@cindex @code{smul@var{m}3_highpart} instruction pattern
@item @samp{smul@var{m}3_highpart}
对机器模式为@var{m}的操作数1和2进行有符号乘法，并将乘积的最高有效的一半放在操作数0中。乘积的最低有效的一半被丢弃。

@cindex @code{umul@var{m}3_highpart} instruction pattern
@item @samp{umul@var{m}3_highpart}
类似的，只不过乘法是无符号的。

@cindex @code{madd@var{m}@var{n}4} instruction pattern
@item @samp{madd@var{m}@var{n}4}
将操作数1和2进行相乘，有符号扩展成机器模式@var{n}，加上操作数3，并将结果存放在操作数0中。操作数1和2具有机器模式@var{m}，操作数0和3具有机器模式@var{n}。两种机器模式必须都为整数或者浮点模式，并且@var{n}必须为@var{m}的两倍大小。

换句话说，@code{madd@var{m}@var{n}4}类似于@code{mul@var{m}@var{n}3}，只不过其还加上操作数3。

这些指令不允许执行@code{FAIL}。

@cindex @code{umadd@var{m}@var{n}4} instruction pattern
@item @samp{umadd@var{m}@var{n}4}
类似@code{madd@var{m}@var{n}4}，只不过零扩展乘法操作数，而不是有符号扩展它们。


@cindex @code{ssmadd@var{m}@var{n}4} instruction pattern
@item @samp{ssmadd@var{m}@var{n}4}
类似@code{madd@var{m}@var{n}4}，不过所有的运算都必须是有符号饱和的。

@cindex @code{usmadd@var{m}@var{n}4} instruction pattern
@item @samp{usmadd@var{m}@var{n}4}
类似@code{umadd@var{m}@var{n}4}，不过所有的运算都必须是无符号饱和的。

@cindex @code{msub@var{m}@var{n}4} instruction pattern
@item @samp{msub@var{m}@var{n}4}
将操作数1和2相乘，有符号扩展为机器模式@var{n}，减去操作数3，并将结果存放在操作数0中。操作数1和2具有机器模式@var{m}，操作数0和3具有机器模式@var{n}。两种机器模式必须都为整数或者浮点模式，并且@var{n}必须为@var{m}的两倍大小。

换句话说，@code{msub@var{m}@var{n}4}类似于@code{mul@var{m}@var{n}3}，只不过其还减去操作数3。

这些指令不允许执行@code{FAIL}。

@cindex @code{umsub@var{m}@var{n}4} instruction pattern
@item @samp{umsub@var{m}@var{n}4}
类似@code{msub@var{m}@var{n}4}，不过零扩展乘法操作数，而不是有符号扩展它们。

@cindex @code{ssmsub@var{m}@var{n}4} instruction pattern
@item @samp{ssmsub@var{m}@var{n}4}
类似@code{msub@var{m}@var{n}4}，不过所有的运算都必须是有符号饱和的。

@cindex @code{usmsub@var{m}@var{n}4} instruction pattern
@item @samp{usmsub@var{m}@var{n}4}
类似@code{umsub@var{m}@var{n}4}，不过所有的运算都必须是无符号饱和的。

@cindex @code{divmod@var{m}4} instruction pattern
@item @samp{divmod@var{m}4}
有符号除法，同时产生商和余数。操作数1被操作数2除，产生商存储在操作数0中，余数存储在操作数3中。

对于具有同时产生商和余数的指令的机器，提供@samp{divmod@var{m}4}指令模式，但不要提供@samp{div@var{m}3} 和 @samp{mod@var{m}3}。这使得当商和余数都被计算的时候，可以优化成相对常见的情况。

如果存在只产生商或者余数的指令，并且比都产生的指令更有效，则将@samp{divmod@var{m}4}的输出例程写成调用@code{find_reg_note}，查看商或者余数的@code{REG_UNUSED}注解，来产生适当的指令。

@cindex @code{udivmod@var{m}4} instruction pattern
@item @samp{udivmod@var{m}4}
类似的，不过进行无符号除法。

@anchor{shift patterns}
@cindex @code{ashl@var{m}3} instruction pattern
@cindex @code{ssashl@var{m}3} instruction pattern
@cindex @code{usashl@var{m}3} instruction pattern
@item @samp{ashl@var{m}3}, @samp{ssashl@var{m}3}, @samp{usashl@var{m}3}
将操作数1向左算术移位，左移位数由操作数2指定，将结果存储在操作数0中。这里@var{m}为操作数0和1的机器模式；操作数2的机器模式通过指令模式来指定，编译器会在生成指令之前，将操作数转换成该模式。超出范围的移位数目的含义，可以通过@code{TARGET_SHIFT_TRUNCATION_MASK}来指定。@xref{TARGET_SHIFT_TRUNCATION_MASK}。操作数2总是一个标量类型。

@cindex @code{ashr@var{m}3} instruction pattern
@cindex @code{lshr@var{m}3} instruction pattern
@cindex @code{rotl@var{m}3} instruction pattern
@cindex @code{rotr@var{m}3} instruction pattern
@item @samp{ashr@var{m}3}, @samp{lshr@var{m}3}, @samp{rotl@var{m}3}, @samp{rotr@var{m}3}
其它移位或者旋转指令，类似于@code{ashl@var{m}3}指令。操作数2总是一个标量类型。

@cindex @code{vashl@var{m}3} instruction pattern
@cindex @code{vashr@var{m}3} instruction pattern
@cindex @code{vlshr@var{m}3} instruction pattern
@cindex @code{vrotl@var{m}3} instruction pattern
@cindex @code{vrotr@var{m}3} instruction pattern
@item @samp{vashl@var{m}3}, @samp{vashr@var{m}3}, @samp{vlshr@var{m}3}, @samp{vrotl@var{m}3}, @samp{vrotr@var{m}3}
向量移位和旋转指令，操作数2为向量，而不是标量类型。

@cindex @code{neg@var{m}2} instruction pattern
@cindex @code{ssneg@var{m}2} instruction pattern
@cindex @code{usneg@var{m}2} instruction pattern
@item @samp{neg@var{m}2}, @samp{ssneg@var{m}2}, @samp{usneg@var{m}2}
对操作数1求负，并将结果存放在操作数0中。

@cindex @code{abs@var{m}2} instruction pattern
@item @samp{abs@var{m}2}
将操作数1的绝对值存放在操作数0中。

@cindex @code{sqrt@var{m}2} instruction pattern
@item @samp{sqrt@var{m}2}
将操作数1的平方根存储在操作数0中。

@code{sqrt}内建C函数，总是使用对应于C数据类型@code{double}的机器模式，@code{sqrtf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{fmod@var{m}3} instruction pattern
@item @samp{fmod@var{m}3}
将操作数1除以操作数2的余数，存储在操作数0中，并向零方向舍入为整数。

@code{fmod}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{fmodf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{remainder@var{m}3} instruction pattern
@item @samp{remainder@var{m}3}
将操作数1除以操作数2的余数，存储在操作数0中，并舍入为最接近的整数。

@code{remainder}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{remainderf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{cos@var{m}2} instruction pattern
@item @samp{cos@var{m}2}
将操作数1的余弦存放在操作数0中。

@code{cos}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{cosf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{sin@var{m}2} instruction pattern
@item @samp{sin@var{m}2}
将操作数1的正弦存放在操作数0中。

@code{sin}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{sinf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{exp@var{m}2} instruction pattern
@item @samp{exp@var{m}2}
将操作数1的幂存放在操作数0中。

@code{exp}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{expf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{log@var{m}2} instruction pattern
@item @samp{log@var{m}2}
将操作数1的自然对数存放在操作数0中。

@code{log}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{logf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{pow@var{m}3} instruction pattern
@item @samp{pow@var{m}3}
将操作数1的，指数为操作数2的幂值存放在操作数0中

@code{pow}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{powf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{atan2@var{m}3} instruction pattern
@item @samp{atan2@var{m}3}
将操作数1除以操作数2的反正切，存放在操作数0中，使用两个参数的正负符号来确定结果的商。

@code{atan2}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{atan2f}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{floor@var{m}2} instruction pattern
@item @samp{floor@var{m}2}
存储不大于参数的最大整数值。

@code{floor}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{floorf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{btrunc@var{m}2} instruction pattern
@item @samp{btrunc@var{m}2}
存储将参数向零方向舍入的整数。

@code{trunc}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{truncf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{round@var{m}2} instruction pattern
@item @samp{round@var{m}2}
存储将参数向远离零的方向舍入的整数。

@code{round}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{roundf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{ceil@var{m}2} instruction pattern
@item @samp{ceil@var{m}2}
Store the argument rounded to integer away from zero.

The @code{ceil} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{ceilf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{nearbyint@var{m}2} instruction pattern
@item @samp{nearbyint@var{m}2}
Store the argument rounded according to the default rounding mode

The @code{nearbyint} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{nearbyintf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{rint@var{m}2} instruction pattern
@item @samp{rint@var{m}2}
Store the argument rounded according to the default rounding mode and
raise the inexact exception when the result differs in value from
the argument

The @code{rint} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{rintf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{lrint@var{m}@var{n}2}
@item @samp{lrint@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number according to the current
rounding mode and store in operand 0 (which has mode @var{n}).

@cindex @code{lround@var{m}@var{n}2}
@item @samp{lround@var{m}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number rounding to nearest and away
from zero and store in operand 0 (which has mode @var{n}).

@cindex @code{lfloor@var{m}@var{n}2}
@item @samp{lfloor@var{m}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number rounding down and store in
operand 0 (which has mode @var{n}).

@cindex @code{lceil@var{m}@var{n}2}
@item @samp{lceil@var{m}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number rounding up and store in
operand 0 (which has mode @var{n}).

@cindex @code{copysign@var{m}3} instruction pattern
@item @samp{copysign@var{m}3}
Store a value with the magnitude of operand 1 and the sign of operand
2 into operand 0.

The @code{copysign} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{copysignf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{ffs@var{m}2} instruction pattern
@item @samp{ffs@var{m}2}
Store into operand 0 one plus the index of the least significant 1-bit
of operand 1.  If operand 1 is zero, store zero.  @var{m} is the mode
of operand 0; operand 1's mode is specified by the instruction
pattern, and the compiler will convert the operand to that mode before
generating the instruction.

The @code{ffs} built-in function of C always uses the mode which
corresponds to the C data type @code{int}.

@cindex @code{clz@var{m}2} instruction pattern
@item @samp{clz@var{m}2}
Store into operand 0 the number of leading 0-bits in @var{x}, starting
at the most significant bit position.  If @var{x} is 0, the
@code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if
the result is undefined or has a useful value.
@var{m} is the mode of operand 0; operand 1's mode is
specified by the instruction pattern, and the compiler will convert the
operand to that mode before generating the instruction.

@cindex @code{ctz@var{m}2} instruction pattern
@item @samp{ctz@var{m}2}
Store into operand 0 the number of trailing 0-bits in @var{x}, starting
at the least significant bit position.  If @var{x} is 0, the
@code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if
the result is undefined or has a useful value.
@var{m} is the mode of operand 0; operand 1's mode is
specified by the instruction pattern, and the compiler will convert the
operand to that mode before generating the instruction.

@cindex @code{popcount@var{m}2} instruction pattern
@item @samp{popcount@var{m}2}
Store into operand 0 the number of 1-bits in @var{x}.  @var{m} is the
mode of operand 0; operand 1's mode is specified by the instruction
pattern, and the compiler will convert the operand to that mode before
generating the instruction.

@cindex @code{parity@var{m}2} instruction pattern
@item @samp{parity@var{m}2}
Store into operand 0 the parity of @var{x}, i.e.@: the number of 1-bits
in @var{x} modulo 2.  @var{m} is the mode of operand 0; operand 1's mode
is specified by the instruction pattern, and the compiler will convert
the operand to that mode before generating the instruction.

@cindex @code{one_cmpl@var{m}2} instruction pattern
@item @samp{one_cmpl@var{m}2}
Store the bitwise-complement of operand 1 into operand 0.

@cindex @code{cmp@var{m}} instruction pattern
@item @samp{cmp@var{m}}
Compare operand 0 and operand 1, and set the condition codes.
The RTL pattern should look like this:

@smallexample
(set (cc0) (compare (match_operand:@var{m} 0 @dots{})
                    (match_operand:@var{m} 1 @dots{})))
@end smallexample

@cindex @code{tst@var{m}} instruction pattern
@item @samp{tst@var{m}}
Compare operand 0 against zero, and set the condition codes.
The RTL pattern should look like this:

@smallexample
(set (cc0) (match_operand:@var{m} 0 @dots{}))
@end smallexample

@samp{tst@var{m}} patterns should not be defined for machines that do
not use @code{(cc0)}.  Doing so would confuse the optimizer since it
would no longer be clear which @code{set} operations were comparisons.
The @samp{cmp@var{m}} patterns should be used instead.

@cindex @code{movmem@var{m}} instruction pattern
@item @samp{movmem@var{m}}
Block move instruction.  The destination and source blocks of memory
are the first two operands, and both are @code{mem:BLK}s with an
address in mode @code{Pmode}.

The number of bytes to move is the third operand, in mode @var{m}.
Usually, you specify @code{word_mode} for @var{m}.  However, if you can
generate better code knowing the range of valid lengths is smaller than
those representable in a full word, you should provide a pattern with a
mode corresponding to the range of values you can handle efficiently
(e.g., @code{QImode} for values in the range 0--127; note we avoid numbers
that appear negative) and also a pattern with @code{word_mode}.

The fourth operand is the known shared alignment of the source and
destination, in the form of a @code{const_int} rtx.  Thus, if the
compiler knows that both source and destination are word-aligned,
it may provide the value 4 for this operand.

Optional operands 5 and 6 specify expected alignment and size of block
respectively.  The expected alignment differs from alignment in operand 4
in a way that the blocks are not required to be aligned according to it in
all cases. This expected alignment is also in bytes, just like operand 4.
Expected size, when unknown, is set to @code{(const_int -1)}.

Descriptions of multiple @code{movmem@var{m}} patterns can only be
beneficial if the patterns for smaller modes have fewer restrictions
on their first, second and fourth operands.  Note that the mode @var{m}
in @code{movmem@var{m}} does not impose any restriction on the mode of
individually moved data units in the block.

These patterns need not give special consideration to the possibility
that the source and destination strings might overlap.

@cindex @code{movstr} instruction pattern
@item @samp{movstr}
String copy instruction, with @code{stpcpy} semantics.  Operand 0 is
an output operand in mode @code{Pmode}.  The addresses of the
destination and source strings are operands 1 and 2, and both are
@code{mem:BLK}s with addresses in mode @code{Pmode}.  The execution of
the expansion of this pattern should store in operand 0 the address in
which the @code{NUL} terminator was stored in the destination string.

@cindex @code{setmem@var{m}} instruction pattern
@item @samp{setmem@var{m}}
Block set instruction.  The destination string is the first operand,
given as a @code{mem:BLK} whose address is in mode @code{Pmode}.  The
number of bytes to set is the second operand, in mode @var{m}.  The value to
initialize the memory with is the third operand. Targets that only support the
clearing of memory should reject any value that is not the constant 0.  See
@samp{movmem@var{m}} for a discussion of the choice of mode.

The fourth operand is the known alignment of the destination, in the form
of a @code{const_int} rtx.  Thus, if the compiler knows that the
destination is word-aligned, it may provide the value 4 for this
operand.

Optional operands 5 and 6 specify expected alignment and size of block
respectively.  The expected alignment differs from alignment in operand 4
in a way that the blocks are not required to be aligned according to it in
all cases. This expected alignment is also in bytes, just like operand 4.
Expected size, when unknown, is set to @code{(const_int -1)}.

The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.

@cindex @code{cmpstrn@var{m}} instruction pattern
@item @samp{cmpstrn@var{m}}
String compare instruction, with five operands.  Operand 0 is the output;
it has mode @var{m}.  The remaining four operands are like the operands
of @samp{movmem@var{m}}.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
string.  The instruction is not allowed to prefetch more than one byte
at a time since either string may end in the first byte and reading past
that may access an invalid page or segment and cause a fault.  The
effect of the instruction is to store a value in operand 0 whose sign
indicates the result of the comparison.

@cindex @code{cmpstr@var{m}} instruction pattern
@item @samp{cmpstr@var{m}}
String compare instruction, without known maximum length.  Operand 0 is the
output; it has mode @var{m}.  The second and third operand are the blocks of
memory to be compared; both are @code{mem:BLK} with an address in mode
@code{Pmode}.

The fourth operand is the known shared alignment of the source and
destination, in the form of a @code{const_int} rtx.  Thus, if the
compiler knows that both source and destination are word-aligned,
it may provide the value 4 for this operand.

The two memory blocks specified are compared byte by byte in lexicographic
order starting at the beginning of each string.  The instruction is not allowed
to prefetch more than one byte at a time since either string may end in the
first byte and reading past that may access an invalid page or segment and
cause a fault.  The effect of the instruction is to store a value in operand 0
whose sign indicates the result of the comparison.

@cindex @code{cmpmem@var{m}} instruction pattern
@item @samp{cmpmem@var{m}}
Block compare instruction, with five operands like the operands
of @samp{cmpstr@var{m}}.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
block.  Unlike @samp{cmpstr@var{m}} the instruction can prefetch
any bytes in the two memory blocks.  The effect of the instruction is
to store a value in operand 0 whose sign indicates the result of the
comparison.

@cindex @code{strlen@var{m}} instruction pattern
@item @samp{strlen@var{m}}
Compute the length of a string, with three operands.
Operand 0 is the result (of mode @var{m}), operand 1 is
a @code{mem} referring to the first character of the string,
operand 2 is the character to search for (normally zero),
and operand 3 is a constant describing the known alignment
of the beginning of the string.

@cindex @code{float@var{mn}2} instruction pattern
@item @samp{float@var{m}@var{n}2}
Convert signed integer operand 1 (valid for fixed point mode @var{m}) to
floating point mode @var{n} and store in operand 0 (which has mode
@var{n}).

@cindex @code{floatuns@var{mn}2} instruction pattern
@item @samp{floatuns@var{m}@var{n}2}
Convert unsigned integer operand 1 (valid for fixed point mode @var{m})
to floating point mode @var{n} and store in operand 0 (which has mode
@var{n}).

@cindex @code{fix@var{mn}2} instruction pattern
@item @samp{fix@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number and store in operand 0 (which
has mode @var{n}).  This instruction's result is defined only when
the value of operand 1 is an integer.

If the machine description defines this pattern, it also needs to
define the @code{ftrunc} pattern.

@cindex @code{fixuns@var{mn}2} instruction pattern
@item @samp{fixuns@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as an unsigned number and store in operand 0 (which
has mode @var{n}).  This instruction's result is defined only when the
value of operand 1 is an integer.

@cindex @code{ftrunc@var{m}2} instruction pattern
@item @samp{ftrunc@var{m}2}
Convert operand 1 (valid for floating point mode @var{m}) to an
integer value, still represented in floating point mode @var{m}, and
store it in operand 0 (valid for floating point mode @var{m}).

@cindex @code{fix_trunc@var{mn}2} instruction pattern
@item @samp{fix_trunc@var{m}@var{n}2}
Like @samp{fix@var{m}@var{n}2} but works for any floating point value
of mode @var{m} by converting the value to an integer.

@cindex @code{fixuns_trunc@var{mn}2} instruction pattern
@item @samp{fixuns_trunc@var{m}@var{n}2}
Like @samp{fixuns@var{m}@var{n}2} but works for any floating point
value of mode @var{m} by converting the value to an integer.

@cindex @code{trunc@var{mn}2} instruction pattern
@item @samp{trunc@var{m}@var{n}2}
Truncate operand 1 (valid for mode @var{m}) to mode @var{n} and
store in operand 0 (which has mode @var{n}).  Both modes must be fixed
point or both floating point.

@cindex @code{extend@var{mn}2} instruction pattern
@item @samp{extend@var{m}@var{n}2}
Sign-extend operand 1 (valid for mode @var{m}) to mode @var{n} and
store in operand 0 (which has mode @var{n}).  Both modes must be fixed
point or both floating point.

@cindex @code{zero_extend@var{mn}2} instruction pattern
@item @samp{zero_extend@var{m}@var{n}2}
Zero-extend operand 1 (valid for mode @var{m}) to mode @var{n} and
store in operand 0 (which has mode @var{n}).  Both modes must be fixed
point.

@cindex @code{fract@var{mn}2} instruction pattern
@item @samp{fract@var{m}@var{n}2}
Convert operand 1 of mode @var{m} to mode @var{n} and store in
operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
could be fixed-point to fixed-point, signed integer to fixed-point,
fixed-point to signed integer, floating-point to fixed-point,
or fixed-point to floating-point.
When overflows or underflows happen, the results are undefined.

@cindex @code{satfract@var{mn}2} instruction pattern
@item @samp{satfract@var{m}@var{n}2}
Convert operand 1 of mode @var{m} to mode @var{n} and store in
operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
could be fixed-point to fixed-point, signed integer to fixed-point,
or floating-point to fixed-point.
When overflows or underflows happen, the instruction saturates the
results to the maximum or the minimum.

@cindex @code{fractuns@var{mn}2} instruction pattern
@item @samp{fractuns@var{m}@var{n}2}
Convert operand 1 of mode @var{m} to mode @var{n} and store in
operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
could be unsigned integer to fixed-point, or
fixed-point to unsigned integer.
When overflows or underflows happen, the results are undefined.

@cindex @code{satfractuns@var{mn}2} instruction pattern
@item @samp{satfractuns@var{m}@var{n}2}
Convert unsigned integer operand 1 of mode @var{m} to fixed-point mode
@var{n} and store in operand 0 (which has mode @var{n}).
When overflows or underflows happen, the instruction saturates the
results to the maximum or the minimum.

@cindex @code{extv} instruction pattern
@item @samp{extv}
Extract a bit-field from operand 1 (a register or memory operand), where
operand 2 specifies the width in bits and operand 3 the starting bit,
and store it in operand 0.  Operand 0 must have mode @code{word_mode}.
Operand 1 may have mode @code{byte_mode} or @code{word_mode}; often
@code{word_mode} is allowed only for registers.  Operands 2 and 3 must
be valid for @code{word_mode}.

The RTL generation pass generates this instruction only with constants
for operands 2 and 3 and the constant is never zero for operand 2.

The bit-field value is sign-extended to a full word integer
before it is stored in operand 0.

@cindex @code{extzv} instruction pattern
@item @samp{extzv}
Like @samp{extv} except that the bit-field value is zero-extended.

@cindex @code{insv} instruction pattern
@item @samp{insv}
Store operand 3 (which must be valid for @code{word_mode}) into a
bit-field in operand 0, where operand 1 specifies the width in bits and
operand 2 the starting bit.  Operand 0 may have mode @code{byte_mode} or
@code{word_mode}; often @code{word_mode} is allowed only for registers.
Operands 1 and 2 must be valid for @code{word_mode}.

The RTL generation pass generates this instruction only with constants
for operands 1 and 2 and the constant is never zero for operand 1.

@cindex @code{mov@var{mode}cc} instruction pattern
@item @samp{mov@var{mode}cc}
Conditionally move operand 2 or operand 3 into operand 0 according to the
comparison in operand 1.  If the comparison is true, operand 2 is moved
into operand 0, otherwise operand 3 is moved.

The mode of the operands being compared need not be the same as the operands
being moved.  Some machines, sparc64 for example, have instructions that
conditionally move an integer value based on the floating point condition
codes and vice versa.

If the machine does not have conditional move instructions, do not
define these patterns.

@cindex @code{add@var{mode}cc} instruction pattern
@item @samp{add@var{mode}cc}
Similar to @samp{mov@var{mode}cc} but for conditional addition.  Conditionally
move operand 2 or (operands 2 + operand 3) into operand 0 according to the
comparison in operand 1.  If the comparison is true, operand 2 is moved into
operand 0, otherwise (operand 2 + operand 3) is moved.

@cindex @code{s@var{cond}} instruction pattern
@item @samp{s@var{cond}}
Store zero or nonzero in the operand according to the condition codes.
Value stored is nonzero iff the condition @var{cond} is true.
@var{cond} is the name of a comparison operation expression code, such
as @code{eq}, @code{lt} or @code{leu}.

You specify the mode that the operand must have when you write the
@code{match_operand} expression.  The compiler automatically sees
which mode you have used and supplies an operand of that mode.

The value stored for a true condition must have 1 as its low bit, or
else must be negative.  Otherwise the instruction is not suitable and
you should omit it from the machine description.  You describe to the
compiler exactly which value is stored by defining the macro
@code{STORE_FLAG_VALUE} (@pxref{Misc}).  If a description cannot be
found that can be used for all the @samp{s@var{cond}} patterns, you
should omit those operations from the machine description.

These operations may fail, but should do so only in relatively
uncommon cases; if they would fail for common cases involving
integer comparisons, it is best to omit these patterns.

If these operations are omitted, the compiler will usually generate code
that copies the constant one to the target and branches around an
assignment of zero to the target.  If this code is more efficient than
the potential instructions used for the @samp{s@var{cond}} pattern
followed by those required to convert the result into a 1 or a zero in
@code{SImode}, you should omit the @samp{s@var{cond}} operations from
the machine description.

@cindex @code{b@var{cond}} instruction pattern
@item @samp{b@var{cond}}
Conditional branch instruction.  Operand 0 is a @code{label_ref} that
refers to the label to jump to.  Jump if the condition codes meet
condition @var{cond}.

Some machines do not follow the model assumed here where a comparison
instruction is followed by a conditional branch instruction.  In that
case, the @samp{cmp@var{m}} (and @samp{tst@var{m}}) patterns should
simply store the operands away and generate all the required insns in a
@code{define_expand} (@pxref{Expander Definitions}) for the conditional
branch operations.  All calls to expand @samp{b@var{cond}} patterns are
immediately preceded by calls to expand either a @samp{cmp@var{m}}
pattern or a @samp{tst@var{m}} pattern.

Machines that use a pseudo register for the condition code value, or
where the mode used for the comparison depends on the condition being
tested, should also use the above mechanism.  @xref{Jump Patterns}.

The above discussion also applies to the @samp{mov@var{mode}cc} and
@samp{s@var{cond}} patterns.

@cindex @code{cbranch@var{mode}4} instruction pattern
@item @samp{cbranch@var{mode}4}
Conditional branch instruction combined with a compare instruction.
Operand 0 is a comparison operator.  Operand 1 and operand 2 are the
first and second operands of the comparison, respectively.  Operand 3
is a @code{label_ref} that refers to the label to jump to.

@cindex @code{jump} instruction pattern
@item @samp{jump}
A jump inside a function; an unconditional branch.  Operand 0 is the
@code{label_ref} of the label to jump to.  This pattern name is mandatory
on all machines.

@cindex @code{call} instruction pattern
@item @samp{call}
Subroutine call instruction returning no value.  Operand 0 is the
function to call; operand 1 is the number of bytes of arguments pushed
as a @code{const_int}; operand 2 is the number of registers used as
operands.

On most machines, operand 2 is not actually stored into the RTL
pattern.  It is supplied for the sake of some RISC machines which need
to put this information into the assembler code; they can put it in
the RTL instead of operand 1.

Operand 0 should be a @code{mem} RTX whose address is the address of the
function.  Note, however, that this address can be a @code{symbol_ref}
expression even if it would not be a legitimate memory address on the
target machine.  If it is also not a valid argument for a call
instruction, the pattern for this operation should be a
@code{define_expand} (@pxref{Expander Definitions}) that places the
address into a register and uses that register in the call instruction.

@cindex @code{call_value} instruction pattern
@item @samp{call_value}
Subroutine call instruction returning a value.  Operand 0 is the hard
register in which the value is returned.  There are three more
operands, the same as the three operands of the @samp{call}
instruction (but with numbers increased by one).

Subroutines that return @code{BLKmode} objects use the @samp{call}
insn.

@cindex @code{call_pop} instruction pattern
@cindex @code{call_value_pop} instruction pattern
@item @samp{call_pop}, @samp{call_value_pop}
Similar to @samp{call} and @samp{call_value}, except used if defined and
if @code{RETURN_POPS_ARGS} is nonzero.  They should emit a @code{parallel}
that contains both the function call and a @code{set} to indicate the
adjustment made to the frame pointer.

For machines where @code{RETURN_POPS_ARGS} can be nonzero, the use of these
patterns increases the number of functions for which the frame pointer
can be eliminated, if desired.

@cindex @code{untyped_call} instruction pattern
@item @samp{untyped_call}
Subroutine call instruction returning a value of any type.  Operand 0 is
the function to call; operand 1 is a memory location where the result of
calling the function is to be stored; operand 2 is a @code{parallel}
expression where each element is a @code{set} expression that indicates
the saving of a function return value into the result block.

This instruction pattern should be defined to support
@code{__builtin_apply} on machines where special instructions are needed
to call a subroutine with arbitrary arguments or to save the value
returned.  This instruction pattern is required on machines that have
multiple registers that can hold a return value
(i.e.@: @code{FUNCTION_VALUE_REGNO_P} is true for more than one register).

@cindex @code{return} instruction pattern
@item @samp{return}
Subroutine return instruction.  This instruction pattern name should be
defined only if a single instruction can do all the work of returning
from a function.

Like the @samp{mov@var{m}} patterns, this pattern is also used after the
RTL generation phase.  In this case it is to support machines where
multiple instructions are usually needed to return from a function, but
some class of functions only requires one instruction to implement a
return.  Normally, the applicable functions are those which do not need
to save any registers or allocate stack space.

@findex reload_completed
@findex leaf_function_p
For such machines, the condition specified in this pattern should only
be true when @code{reload_completed} is nonzero and the function's
epilogue would only be a single instruction.  For machines with register
windows, the routine @code{leaf_function_p} may be used to determine if
a register window push is required.

Machines that have conditional return instructions should define patterns
such as

@smallexample
(define_insn ""
  [(set (pc)
        (if_then_else (match_operator
                         0 "comparison_operator"
                         [(cc0) (const_int 0)])
                      (return)
                      (pc)))]
  "@var{condition}"
  "@dots{}")
@end smallexample

where @var{condition} would normally be the same condition specified on the
named @samp{return} pattern.

@cindex @code{untyped_return} instruction pattern
@item @samp{untyped_return}
Untyped subroutine return instruction.  This instruction pattern should
be defined to support @code{__builtin_return} on machines where special
instructions are needed to return a value of any type.

Operand 0 is a memory location where the result of calling a function
with @code{__builtin_apply} is stored; operand 1 is a @code{parallel}
expression where each element is a @code{set} expression that indicates
the restoring of a function return value from the result block.

@cindex @code{nop} instruction pattern
@item @samp{nop}
No-op instruction.  This instruction pattern name should always be defined
to output a no-op in assembler code.  @code{(const_int 0)} will do as an
RTL pattern.

@cindex @code{indirect_jump} instruction pattern
@item @samp{indirect_jump}
An instruction to jump to an address which is operand zero.
This pattern name is mandatory on all machines.

@cindex @code{casesi} instruction pattern
@item @samp{casesi}
Instruction to jump through a dispatch table, including bounds checking.
This instruction takes five operands:

@enumerate
@item
The index to dispatch on, which has mode @code{SImode}.

@item
The lower bound for indices in the table, an integer constant.

@item
The total range of indices in the table---the largest index
minus the smallest one (both inclusive).

@item
A label that precedes the table itself.

@item
A label to jump to if the index has a value outside the bounds.
@end enumerate

The table is a @code{addr_vec} or @code{addr_diff_vec} inside of a
@code{jump_insn}.  The number of elements in the table is one plus the
difference between the upper bound and the lower bound.

@cindex @code{tablejump} instruction pattern
@item @samp{tablejump}
Instruction to jump to a variable address.  This is a low-level
capability which can be used to implement a dispatch table when there
is no @samp{casesi} pattern.

This pattern requires two operands: the address or offset, and a label
which should immediately precede the jump table.  If the macro
@code{CASE_VECTOR_PC_RELATIVE} evaluates to a nonzero value then the first
operand is an offset which counts from the address of the table; otherwise,
it is an absolute address to jump to.  In either case, the first operand has
mode @code{Pmode}.

The @samp{tablejump} insn is always the last insn before the jump
table it uses.  Its assembler code normally has no need to use the
second operand, but you should incorporate it in the RTL pattern so
that the jump optimizer will not delete the table as unreachable code.


@cindex @code{decrement_and_branch_until_zero} instruction pattern
@item @samp{decrement_and_branch_until_zero}
Conditional branch instruction that decrements a register and
jumps if the register is nonzero.  Operand 0 is the register to
decrement and test; operand 1 is the label to jump to if the
register is nonzero.  @xref{Looping Patterns}.

This optional instruction pattern is only used by the combiner,
typically for loops reversed by the loop optimizer when strength
reduction is enabled.

@cindex @code{doloop_end} instruction pattern
@item @samp{doloop_end}
Conditional branch instruction that decrements a register and jumps if
the register is nonzero.  This instruction takes five operands: Operand
0 is the register to decrement and test; operand 1 is the number of loop
iterations as a @code{const_int} or @code{const0_rtx} if this cannot be
determined until run-time; operand 2 is the actual or estimated maximum
number of iterations as a @code{const_int}; operand 3 is the number of
enclosed loops as a @code{const_int} (an innermost loop has a value of
1); operand 4 is the label to jump to if the register is nonzero.
@xref{Looping Patterns}.

This optional instruction pattern should be defined for machines with
low-overhead looping instructions as the loop optimizer will try to
modify suitable loops to utilize it.  If nested low-overhead looping is
not supported, use a @code{define_expand} (@pxref{Expander Definitions})
and make the pattern fail if operand 3 is not @code{const1_rtx}.
Similarly, if the actual or estimated maximum number of iterations is
too large for this instruction, make it fail.

@cindex @code{doloop_begin} instruction pattern
@item @samp{doloop_begin}
Companion instruction to @code{doloop_end} required for machines that
need to perform some initialization, such as loading special registers
used by a low-overhead looping instruction.  If initialization insns do
not always need to be emitted, use a @code{define_expand}
(@pxref{Expander Definitions}) and make it fail.


@cindex @code{canonicalize_funcptr_for_compare} instruction pattern
@item @samp{canonicalize_funcptr_for_compare}
Canonicalize the function pointer in operand 1 and store the result
into operand 0.

Operand 0 is always a @code{reg} and has mode @code{Pmode}; operand 1
may be a @code{reg}, @code{mem}, @code{symbol_ref}, @code{const_int}, etc
and also has mode @code{Pmode}.

Canonicalization of a function pointer usually involves computing
the address of the function which would be called if the function
pointer were used in an indirect call.

Only define this pattern if function pointers on the target machine
can have different values but still call the same function when
used in an indirect call.

@cindex @code{save_stack_block} instruction pattern
@cindex @code{save_stack_function} instruction pattern
@cindex @code{save_stack_nonlocal} instruction pattern
@cindex @code{restore_stack_block} instruction pattern
@cindex @code{restore_stack_function} instruction pattern
@cindex @code{restore_stack_nonlocal} instruction pattern
@item @samp{save_stack_block}
@itemx @samp{save_stack_function}
@itemx @samp{save_stack_nonlocal}
@itemx @samp{restore_stack_block}
@itemx @samp{restore_stack_function}
@itemx @samp{restore_stack_nonlocal}
Most machines save and restore the stack pointer by copying it to or
from an object of mode @code{Pmode}.  Do not define these patterns on
such machines.

Some machines require special handling for stack pointer saves and
restores.  On those machines, define the patterns corresponding to the
non-standard cases by using a @code{define_expand} (@pxref{Expander
Definitions}) that produces the required insns.  The three types of
saves and restores are:

@enumerate
@item
@samp{save_stack_block} saves the stack pointer at the start of a block
that allocates a variable-sized object, and @samp{restore_stack_block}
restores the stack pointer when the block is exited.

@item
@samp{save_stack_function} and @samp{restore_stack_function} do a
similar job for the outermost block of a function and are used when the
function allocates variable-sized objects or calls @code{alloca}.  Only
the epilogue uses the restored stack pointer, allowing a simpler save or
restore sequence on some machines.

@item
@samp{save_stack_nonlocal} is used in functions that contain labels
branched to by nested functions.  It saves the stack pointer in such a
way that the inner function can use @samp{restore_stack_nonlocal} to
restore the stack pointer.  The compiler generates code to restore the
frame and argument pointer registers, but some machines require saving
and restoring additional data such as register window information or
stack backchains.  Place insns in these patterns to save and restore any
such required data.
@end enumerate

When saving the stack pointer, operand 0 is the save area and operand 1
is the stack pointer.  The mode used to allocate the save area defaults
to @code{Pmode} but you can override that choice by defining the
@code{STACK_SAVEAREA_MODE} macro (@pxref{Storage Layout}).  You must
specify an integral mode, or @code{VOIDmode} if no save area is needed
for a particular type of save (either because no save is needed or
because a machine-specific save area can be used).  Operand 0 is the
stack pointer and operand 1 is the save area for restore operations.  If
@samp{save_stack_block} is defined, operand 0 must not be
@code{VOIDmode} since these saves can be arbitrarily nested.

A save area is a @code{mem} that is at a constant offset from
@code{virtual_stack_vars_rtx} when the stack pointer is saved for use by
nonlocal gotos and a @code{reg} in the other two cases.

@cindex @code{allocate_stack} instruction pattern
@item @samp{allocate_stack}
Subtract (or add if @code{STACK_GROWS_DOWNWARD} is undefined) operand 1 from
the stack pointer to create space for dynamically allocated data.

Store the resultant pointer to this space into operand 0.  If you
are allocating space from the main stack, do this by emitting a
move insn to copy @code{virtual_stack_dynamic_rtx} to operand 0.
If you are allocating the space elsewhere, generate code to copy the
location of the space to operand 0.  In the latter case, you must
ensure this space gets freed when the corresponding space on the main
stack is free.

Do not define this pattern if all that must be done is the subtraction.
Some machines require other operations such as stack probes or
maintaining the back chain.  Define this pattern to emit those
operations in addition to updating the stack pointer.

@cindex @code{check_stack} instruction pattern
@item @samp{check_stack}
If stack checking cannot be done on your system by probing the stack with
a load or store instruction (@pxref{Stack Checking}), define this pattern
to perform the needed check and signaling an error if the stack
has overflowed.  The single operand is the location in the stack furthest
from the current stack pointer that you need to validate.  Normally,
on machines where this pattern is needed, you would obtain the stack
limit from a global or thread-specific variable or register.

@cindex @code{nonlocal_goto} instruction pattern
@item @samp{nonlocal_goto}
Emit code to generate a non-local goto, e.g., a jump from one function
to a label in an outer function.  This pattern has four arguments,
each representing a value to be used in the jump.  The first
argument is to be loaded into the frame pointer, the second is
the address to branch to (code to dispatch to the actual label),
the third is the address of a location where the stack is saved,
and the last is the address of the label, to be placed in the
location for the incoming static chain.

On most machines you need not define this pattern, since GCC will
already generate the correct code, which is to load the frame pointer
and static chain, restore the stack (using the
@samp{restore_stack_nonlocal} pattern, if defined), and jump indirectly
to the dispatcher.  You need only define this pattern if this code will
not work on your machine.

@cindex @code{nonlocal_goto_receiver} instruction pattern
@item @samp{nonlocal_goto_receiver}
This pattern, if defined, contains code needed at the target of a
nonlocal goto after the code already generated by GCC@.  You will not
normally need to define this pattern.  A typical reason why you might
need this pattern is if some value, such as a pointer to a global table,
must be restored when the frame pointer is restored.  Note that a nonlocal
goto only occurs within a unit-of-translation, so a global table pointer
that is shared by all functions of a given module need not be restored.
There are no arguments.

@cindex @code{exception_receiver} instruction pattern
@item @samp{exception_receiver}
This pattern, if defined, contains code needed at the site of an
exception handler that isn't needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored after control flow is branched to the handler of
an exception.  There are no arguments.

@cindex @code{builtin_setjmp_setup} instruction pattern
@item @samp{builtin_setjmp_setup}
This pattern, if defined, contains additional code needed to initialize
the @code{jmp_buf}.  You will not normally need to define this pattern.
A typical reason why you might need this pattern is if some value, such
as a pointer to a global table, must be restored.  Though it is
preferred that the pointer value be recalculated if possible (given the
address of a label for instance).  The single argument is a pointer to
the @code{jmp_buf}.  Note that the buffer is five words long and that
the first three are normally used by the generic mechanism.

@cindex @code{builtin_setjmp_receiver} instruction pattern
@item @samp{builtin_setjmp_receiver}
This pattern, if defined, contains code needed at the site of an
built-in setjmp that isn't needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored.  It takes one argument, which is the label
to which builtin_longjmp transfered control; this pattern may be emitted
at a small offset from that label.

@cindex @code{builtin_longjmp} instruction pattern
@item @samp{builtin_longjmp}
This pattern, if defined, performs the entire action of the longjmp.
You will not normally need to define this pattern unless you also define
@code{builtin_setjmp_setup}.  The single argument is a pointer to the
@code{jmp_buf}.

@cindex @code{eh_return} instruction pattern
@item @samp{eh_return}
This pattern, if defined, affects the way @code{__builtin_eh_return},
and thence the call frame exception handling library routines, are
built.  It is intended to handle non-trivial actions needed along
the abnormal return path.

The address of the exception handler to which the function should return
is passed as operand to this pattern.  It will normally need to copied by
the pattern to some special register or memory location.
If the pattern needs to determine the location of the target call
frame in order to do so, it may use @code{EH_RETURN_STACKADJ_RTX},
if defined; it will have already been assigned.

If this pattern is not defined, the default action will be to simply
copy the return address to @code{EH_RETURN_HANDLER_RTX}.  Either
that macro or this pattern needs to be defined if call frame exception
handling is to be used.

@cindex @code{prologue} instruction pattern
@anchor{prologue instruction pattern}
@item @samp{prologue}
This pattern, if defined, emits RTL for entry to a function.  The function
entry is responsible for setting up the stack frame, initializing the frame
pointer register, saving callee saved registers, etc.

Using a prologue pattern is generally preferred over defining
@code{TARGET_ASM_FUNCTION_PROLOGUE} to emit assembly code for the prologue.

The @code{prologue} pattern is particularly useful for targets which perform
instruction scheduling.

@cindex @code{epilogue} instruction pattern
@anchor{epilogue instruction pattern}
@item @samp{epilogue}
This pattern emits RTL for exit from a function.  The function
exit is responsible for deallocating the stack frame, restoring callee saved
registers and emitting the return instruction.

Using an epilogue pattern is generally preferred over defining
@code{TARGET_ASM_FUNCTION_EPILOGUE} to emit assembly code for the epilogue.

The @code{epilogue} pattern is particularly useful for targets which perform
instruction scheduling or which have delay slots for their return instruction.

@cindex @code{sibcall_epilogue} instruction pattern
@item @samp{sibcall_epilogue}
This pattern, if defined, emits RTL for exit from a function without the final
branch back to the calling function.  This pattern will be emitted before any
sibling call (aka tail call) sites.

The @code{sibcall_epilogue} pattern must not clobber any arguments used for
parameter passing or any stack slots for arguments passed to the current
function.

@cindex @code{trap} instruction pattern
@item @samp{trap}
This pattern, if defined, signals an error, typically by causing some
kind of signal to be raised.  Among other places, it is used by the Java
front end to signal `invalid array index' exceptions.

@cindex @code{conditional_trap} instruction pattern
@item @samp{conditional_trap}
Conditional trap instruction.  Operand 0 is a piece of RTL which
performs a comparison.  Operand 1 is the trap code, an integer.

A typical @code{conditional_trap} pattern looks like

@smallexample
(define_insn "conditional_trap"
  [(trap_if (match_operator 0 "trap_operator"
             [(cc0) (const_int 0)])
            (match_operand 1 "const_int_operand" "i"))]
  ""
  "@dots{}")
@end smallexample

@cindex @code{prefetch} instruction pattern
@item @samp{prefetch}

This pattern, if defined, emits code for a non-faulting data prefetch
instruction.  Operand 0 is the address of the memory to prefetch.  Operand 1
is a constant 1 if the prefetch is preparing for a write to the memory
address, or a constant 0 otherwise.  Operand 2 is the expected degree of
temporal locality of the data and is a value between 0 and 3, inclusive; 0
means that the data has no temporal locality, so it need not be left in the
cache after the access; 3 means that the data has a high degree of temporal
locality and should be left in all levels of cache possible;  1 and 2 mean,
respectively, a low or moderate degree of temporal locality.

Targets that do not support write prefetches or locality hints can ignore
the values of operands 1 and 2.

@cindex @code{blockage} instruction pattern
@item @samp{blockage}

This pattern defines a pseudo insn that prevents the instruction
scheduler from moving instructions across the boundary defined by the
blockage insn.  Normally an UNSPEC_VOLATILE pattern.

@cindex @code{memory_barrier} instruction pattern
@item @samp{memory_barrier}

If the target memory model is not fully synchronous, then this pattern
should be defined to an instruction that orders both loads and stores
before the instruction with respect to loads and stores after the instruction.
This pattern has no operands.

@cindex @code{sync_compare_and_swap@var{mode}} instruction pattern
@item @samp{sync_compare_and_swap@var{mode}}

This pattern, if defined, emits code for an atomic compare-and-swap
operation.  Operand 1 is the memory on which the atomic operation is
performed.  Operand 2 is the ``old'' value to be compared against the
current contents of the memory location.  Operand 3 is the ``new'' value
to store in the memory if the compare succeeds.  Operand 0 is the result
of the operation; it should contain the contents of the memory
before the operation.  If the compare succeeds, this should obviously be
a copy of operand 2.

This pattern must show that both operand 0 and operand 1 are modified.

This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

@cindex @code{sync_compare_and_swap_cc@var{mode}} instruction pattern
@item @samp{sync_compare_and_swap_cc@var{mode}}

This pattern is just like @code{sync_compare_and_swap@var{mode}}, except
it should act as if compare part of the compare-and-swap were issued via
@code{cmp@var{m}}.  This comparison will only be used with @code{EQ} and
@code{NE} branches and @code{setcc} operations.

Some targets do expose the success or failure of the compare-and-swap
operation via the status flags.  Ideally we wouldn't need a separate
named pattern in order to take advantage of this, but the combine pass
does not handle patterns with multiple sets, which is required by
definition for @code{sync_compare_and_swap@var{mode}}.

@cindex @code{sync_add@var{mode}} instruction pattern
@cindex @code{sync_sub@var{mode}} instruction pattern
@cindex @code{sync_ior@var{mode}} instruction pattern
@cindex @code{sync_and@var{mode}} instruction pattern
@cindex @code{sync_xor@var{mode}} instruction pattern
@cindex @code{sync_nand@var{mode}} instruction pattern
@item @samp{sync_add@var{mode}}, @samp{sync_sub@var{mode}}
@itemx @samp{sync_ior@var{mode}}, @samp{sync_and@var{mode}}
@itemx @samp{sync_xor@var{mode}}, @samp{sync_nand@var{mode}}

These patterns emit code for an atomic operation on memory.
Operand 0 is the memory on which the atomic operation is performed.
Operand 1 is the second operand to the binary operator.

The ``nand'' operation is @code{~op0 & op1}.

This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.

@cindex @code{sync_old_add@var{mode}} instruction pattern
@cindex @code{sync_old_sub@var{mode}} instruction pattern
@cindex @code{sync_old_ior@var{mode}} instruction pattern
@cindex @code{sync_old_and@var{mode}} instruction pattern
@cindex @code{sync_old_xor@var{mode}} instruction pattern
@cindex @code{sync_old_nand@var{mode}} instruction pattern
@item @samp{sync_old_add@var{mode}}, @samp{sync_old_sub@var{mode}}
@itemx @samp{sync_old_ior@var{mode}}, @samp{sync_old_and@var{mode}}
@itemx @samp{sync_old_xor@var{mode}}, @samp{sync_old_nand@var{mode}}

These patterns are emit code for an atomic operation on memory,
and return the value that the memory contained before the operation.
Operand 0 is the result value, operand 1 is the memory on which the
atomic operation is performed, and operand 2 is the second operand
to the binary operator.

This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.

@cindex @code{sync_new_add@var{mode}} instruction pattern
@cindex @code{sync_new_sub@var{mode}} instruction pattern
@cindex @code{sync_new_ior@var{mode}} instruction pattern
@cindex @code{sync_new_and@var{mode}} instruction pattern
@cindex @code{sync_new_xor@var{mode}} instruction pattern
@cindex @code{sync_new_nand@var{mode}} instruction pattern
@item @samp{sync_new_add@var{mode}}, @samp{sync_new_sub@var{mode}}
@itemx @samp{sync_new_ior@var{mode}}, @samp{sync_new_and@var{mode}}
@itemx @samp{sync_new_xor@var{mode}}, @samp{sync_new_nand@var{mode}}

These patterns are like their @code{sync_old_@var{op}} counterparts,
except that they return the value that exists in the memory location
after the operation, rather than before the operation.

@cindex @code{sync_lock_test_and_set@var{mode}} instruction pattern
@item @samp{sync_lock_test_and_set@var{mode}}

This pattern takes two forms, based on the capabilities of the target.
In either case, operand 0 is the result of the operand, operand 1 is
the memory on which the atomic operation is performed, and operand 2
is the value to set in the lock.

In the ideal case, this operation is an atomic exchange operation, in
which the previous value in memory operand is copied into the result
operand, and the value operand is stored in the memory operand.

For less capable targets, any value operand that is not the constant 1
should be rejected with @code{FAIL}.  In this case the target may use
an atomic test-and-set bit operation.  The result operand should contain
1 if the bit was previously set and 0 if the bit was previously clear.
The true contents of the memory operand are implementation defined.

This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as an acquire barrier, that is all memory
operations after the pattern do not occur until the lock is acquired.

If this pattern is not defined, the operation will be constructed from
a compare-and-swap operation, if defined.

@cindex @code{sync_lock_release@var{mode}} instruction pattern
@item @samp{sync_lock_release@var{mode}}

This pattern, if defined, releases a lock set by
@code{sync_lock_test_and_set@var{mode}}.  Operand 0 is the memory
that contains the lock; operand 1 is the value to store in the lock.

If the target doesn't implement full semantics for
@code{sync_lock_test_and_set@var{mode}}, any value operand which is not
the constant 0 should be rejected with @code{FAIL}, and the true contents
of the memory operand are implementation defined.

This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as a release barrier, that is the lock is
released only after all previous memory operations have completed.

If this pattern is not defined, then a @code{memory_barrier} pattern
will be emitted, followed by a store of the value to the memory operand.

@cindex @code{stack_protect_set} instruction pattern
@item @samp{stack_protect_set}

This pattern, if defined, moves a @code{Pmode} value from the memory
in operand 1 to the memory in operand 0 without leaving the value in
a register afterward.  This is to avoid leaking the value some place
that an attacker might use to rewrite the stack guard slot after
having clobbered it.

If this pattern is not defined, then a plain move pattern is generated.

@cindex @code{stack_protect_test} instruction pattern
@item @samp{stack_protect_test}

This pattern, if defined, compares a @code{Pmode} value from the
memory in operand 1 with the memory in operand 0 without leaving the
value in a register afterward and branches to operand 2 if the values
weren't equal.

If this pattern is not defined, then a plain compare pattern and
conditional branch pattern is used.

@cindex @code{clear_cache} instruction pattern
@item @samp{clear_cache}

This pattern, if defined, flushes the instruction cache for a region of
memory.  The region is bounded to by the Pmode pointers in operand 0
inclusive and operand 1 exclusive.

If this pattern is not defined, a call to the library function
@code{__clear_cache} is used.

@end table

@end ifset
@c Each of the following nodes are wrapped in separate
@c "@ifset INTERNALS" to work around memory limits for the default
@c configuration in older tetex distributions.  Known to not work:
@c tetex-1.0.7, known to work: tetex-2.0.2.
@ifset INTERNALS
@node 指令模式顺序
@section 指令模式的顺序问题
@cindex Pattern Ordering
@cindex Ordering of Patterns

有时一条insn可以匹配不止一个指令模式。
则在机器描述中首先出现的指令模式将被使用。因此，
更加详细的指令模式（匹配更少事物的）和更快的指令
（在匹配时将会产生更好的代码）将通常放在描述中的前面。

有些情况下，指令模式的顺序效果可以用于隐藏无效的指令模式。
例如，68000有一条将全字转换为浮点的指令，和一条将字节转换为浮点的指令。
则将整数转换为浮点的指令将两者都可以匹配。
我们将转换全字的指令模式放在前面，从而确保使用前一种方式。
（否则将可能产生一个大的整数，以作为单个字节的立即数，这样可能无法工作）。
除了使用该指令模式顺序，还可能将转换字节的指令模式作的更加巧妙些，
以能够合适的处理任何常数值。

@end ifset
@ifset INTERNALS
@node 依赖指令模式
@section 指令模式的相互依赖性
@cindex Dependent Patterns
@cindex Interdependence of Patterns

每个机器描述必须针对每个名为@samp{b@var{cond}}的条件分支，
具有一个命名的指令模式。识别模板必须总是具有如下形式

@smallexample
(set (pc)
     (if_then_else (@var{cond} (cc0) (const_int 0))
                   (label_ref (match_operand 0 "" ""))
                   (pc)))
@end smallexample

@noindent
另外，每个机器描述必须针对每个可能的逆转条件分支具有一个匿名的指令模式。
它们的模板的形式为

@smallexample
(set (pc)
     (if_then_else (@var{cond} (cc0) (const_int 0))
                   (pc)
                   (label_ref (match_operand 0 "" ""))))
@end smallexample

@noindent
之所以需要这些，是因为jump优化会将直接条件（direct-conditional）分支，
转换为逆转条件（reverse-conditional）分支。

使用@code{match_operator}结构来减少必须为分支指定的指令模式的编号
通常是很方便的。例如，

@smallexample
(define_insn ""
  [(set (pc)
        (if_then_else (match_operator 0 "comparison_operator"
                                      [(cc0) (const_int 0)])
                      (pc)
                      (label_ref (match_operand 1 "" ""))))]
  "@var{condition}"
  "@dots{}")
@end smallexample

有些情况，机器支持除了一个或多个操作数的机器模式不同的相同指令。
例如，可以有指令“sign-extend halfword” 和“sign-extend byte”，其指令模式为

@smallexample
(set (match_operand:SI 0 @dots{})
     (extend:SI (match_operand:HI 1 @dots{})))

(set (match_operand:SI 0 @dots{})
     (extend:SI (match_operand:QI 1 @dots{})))
@end smallexample

@noindent
常整数不指定机器模式，所以扩展常量值的指令可以两个指令模式都匹配。
实际匹配的指令模式将为文件中首先出现的指令模式。为了获得正确的结果，
其必须为尽可能宽的模式（这里为@code{HImode}）。
如果指令模式匹配@code{QImode}，则当常量值实际不适合该模式时，结果将不正确。

像这样扩展常数的指令很少被生成，因为它们会被优化掉，
不过在不优化的编译中确实偶尔会出现。

如果在指令模式中constraint允许为一个常量，reload过程可以用constraint允许的常量来替换寄存器。
类似的对于内存引用。由于存在这种替换，
所以不要为递增和递减指令提供单独的指令模式。
替换的，它们应该由同一个指令模式生成。

@end ifset
@ifset INTERNALS
@node 跳转指令模式
@section 定义跳转指令模式
@cindex jump instruction patterns
@cindex defining jump instruction patterns

对于大多数机器，GCC假设该机器具有一个条件码。
比较insn根据给定操作数的有符号和无符号比较的结果来设定条件码。
单独的分支insn测试条件代码，并根据它的值进行分支跳转。
分支insn分为不同的有符号和无符号的。
许多通用机器，像VAX，68000和32000都按这种方式工作。

一些机器具有截然不同的有符号和无符号比较指令，并且只有一套条件分支指令。
处理这些机器最容易的方法为保持它们不变，直到最后写汇编代码的阶段。
这时，当输出比较指令的代码时，查看一下使用@code{next_cc0_user (insn)}的分支。
（）如果RTL得出其为一个无符号分支，则输出一个无符号比较；
否则输出一个有符号比较。当分支本身被输出时，你可以将有符号和无符号分支视为等同的。

之所以可以这样做，是因为GCC总是生成一对连续的RTL insn，
可能由@code{note} insn分隔，一个用于设置条件代码，一个用于测试，
并保持这对insn不被改变，直到最后。

要使用该技术，你必须定义机器描述宏@code{NOTICE_UPDATE_CC}，
来做@code{CC_STATUS_INIT}；换句话说，没有多余的比较指令。

一些机器具有比较分支指令，并且没有条件码。对它们可以使用类似的技术。
当该要“输出”一个比较指令时，将它的操作数记录在两个静态变量中。
当输出随后的条件码分支指令时，实际上输出了一个使用已记录的操作数的比较分支指令。

它还用于定义比较分支指令的指令模式。在优化编译中，
比较和分支指令对将根据这些指令模式被组合。但是如果优化不要求的时候，
这是不会发生的。所以你必须针对你定义的任何特定指令模式额外使用上面的一种解决方式。

在许多RISC机器上，大多数指令不影响条件码，并且甚至会没有一个单独的条件码寄存器。
在这些机器上，限制条件码的定义和使用为邻近的insn是不必要的，
并且还会阻止一些重要的优化。例如，在IBM RS/6000上，对于分支将会有一个延迟，
除非条件码寄存器在条件分支的三条指令前被设置。
如果不允许将条件码寄存器的定义和使用分开，则指令调度器将无法执行该优化。

在这些机器上，不要使用@code{(cc0)}，而是使用寄存器来表示条件代码。
如果该机器有一个特定的条件代码寄存器，则使用硬件寄存器。
如果条件代码或者比较结果可以被放在任意的通用寄存器中，
或者有多个条件寄存器，则使用伪寄存器。

@findex prev_cc0_setter
@findex next_cc0_user
在一些机器上，所生成的分支指令类型可以依赖于条件代码所产生的方式；
例如，在68k和SPARC上，直接从加法或减法指令来设置条件代码，
这并不像测试指令那样，不会清除溢出位，
所以不同的分支指令必须用于某些条件分支。对于使用@code{(cc0)}的机器，
对条件代码的设置和使用必须是邻近的（只有@code{note} insn分隔），
以允许在@code{cc_status}中的标记被使用。（参见条件码）并且，
比较分支insn可以互相定位，通过使用函数@code{prev_cc0_setter}和@code{next_cc0_user}。

但是，这在不使用@code{(cc0)}的机器上是不一样的。
在这些机器上，并不会假设比较分支指令是邻近的，上面的方法不可用。
替换的，我们使用条件码寄存器的机器模式来记录条件码寄存器的不同格式。

用于存储条件码值的寄存器应该具有@code{MODE_CC}类别的一个机器模式。
通常，其为@code{CCmode}。如果需要额外的机器模式
（正如上面提到的SPARC中加法例子），
则在@file{@var{machine}-modes.def}中定义它们（参见条件码）。
还要定义@code{SELECT_CC_MODE}来选择给定比较操作数的机器模式。

如果知道在RTL生成过程中，将需要不同的机器模式
（例如，如果机器具有单独的比较指令，针对有符号和无符号），
则它们可以在那个时候被指定。

如果是在指令合成时需要不同的机器模式，
则宏@code{SELECT_CC_MODE}用来确定哪个机器模式作为比较结果。
指令模式应该使用该模式来书写。要支持上面讨论的SPARC的加法，
我们具有指令模式

@smallexample
(define_insn ""
  [(set (reg:CC_NOOV 0)
        (compare:CC_NOOV
          (plus:SI (match_operand:SI 0 "register_operand" "%r")
                   (match_operand:SI 1 "arith_operand" "rI"))
          (const_int 0)))]
  ""
  "@dots{}")
@end smallexample

SPARC的宏@code{SELECT_CC_MODE}为参数是@code{plus}的比较运算返回一个@code{CC_NOOVmode}。

@end ifset
@ifset INTERNALS
@node 循环指令模式
@section 定义循环指令模式
@cindex looping instruction patterns
@cindex defining looping instruction patterns

一些机器具有特定的跳转指令，可以使循环更为有效。
常见的例子为68000的@samp{dbra}指令，其执行一个寄存器的递减，
并且如果结果大于0，则进行一个分支。其它机器，特别是数字信号处理器（DSP），
具有特定的块重复指令，以提供低成本的循环支持。
例如TI TMS320C3x/C4x DSP具有一个块重复指令，
其加载特定的寄存器来标记一个循环的顶部和底部，并计算循环迭代的次数。
这就避免了对@samp{dbra}这样的指令的取指和执行的需要，
并避免了和跳转相关的流水线阻塞。

GCC具有三个特定的命名指令模式，来支持低开销循环。
它们为@samp{decrement_and_branch_until_zero}, @samp{doloop_begin}和@samp{doloop_end}。
第一个指令模式@samp{decrement_and_branch_until_zero}，在RTL生成过程中没有被产生，
但可以在指令合并阶段被产生。这需要循环优化器的帮助，
使用在strength reduction过程中所搜集的信息，来将一个循环转换为向下计数到0。
一些target还要求循环优化器增加一个@code{REG_NONNEG}注解，来指示迭代计数总是为正的。
这在target执行一个有符号循环终止测试的时候被需要。例如，
68000为它的@code{dbra}指令使用了下面类似的指令模式：

@smallexample
@group
(define_insn "decrement_and_branch_until_zero"
  [(set (pc)
        (if_then_else
          (ge (plus:SI (match_operand:SI 0 "general_operand" "+d*am")
                       (const_int -1))
              (const_int 0))
          (label_ref (match_operand 1 "" ""))
          (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (const_int -1)))]
  "find_reg_note (insn, REG_NONNEG, 0)"
  "@dots{}")
@end group
@end smallexample

注意，由于该insn为jump insn并且具有一个输出，所以其必须处理自己的重载，
因此要使用`m' constraint。还要注意，由于该insn是在指令组合过程中，
通过将两个连序insn组合成一个隐式并行的insn而生成的，所以迭代计数器需要。
注意下面类似的指令模式将不会被编译器匹配。

@smallexample
@group
(define_insn "decrement_and_branch_until_zero"
  [(set (pc)
        (if_then_else
          (ge (match_operand:SI 0 "general_operand" "+d*am")
              (const_int 1))
          (label_ref (match_operand 1 "" ""))
          (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (const_int -1)))]
  "find_reg_note (insn, REG_NONNEG, 0)"
  "@dots{}")
@end group
@end smallexample

另外两个特定的循环指令模式@samp{doloop_begin}和@samp{doloop_end}，
由循环优化器为一些具有有限循环迭代，
使用强度消减所搜集的信息的良好行为的循环所生成的。

@samp{doloop_end}指令模式描述了实际的循环指令（或者隐式的循环操作），
@samp{doloop_begin}指令模式为一个可选的配套指令模式，
可以用于一些低开销循环指令的初始化需要。

注意有些机器需要在循环顶部生成实际的循环指令（例如TMS320C3x/C4x DSP）。
在循环顶部生成真正的RTL循环指令，会对流分析造成问题。所以，替换的，
一个假@samp{doloop} insn在循环的结尾处被生成。
机器相关的reorg过程会检查该@samp{doloop} insn的存在，
然后向后搜寻插入了真正循环insn（假设在循环中没有会造成问题的指令）的循环顶部。
任何额外的标号都可以在该点被生成。另外，
如果所需要的特定迭代技术器寄存器没有被分配，
则该机器相关的reorg过程能够生成一个传统的比较跳转指令对。

指令模式@samp{decrement_and_branch_until_zero}和@samp{doloop_end}的本质区别为，
循环优化器会为后者分配一个额外的伪寄存器作为迭代计数器。
该伪寄存器不能用在循环中（即，通用的规约变量不能由此生成），但是，
许多情况下循环规约变量可能变成冗余的并且被后续的过程移除掉。

@end ifset
@ifset INTERNALS
@node Insn规范化
@section 指令规范化
@cindex canonicalization of instructions
@cindex insn canonicalization

经常会有多个RTL表达式可以表示由单个机器指令所执行的运算。该情况对于逻辑，
分支和乘累加指令最常见。对于这样的情况，
编译器尝试将这些多个RTL表达式转换为一个规范的形式，
以减少对insn指令模式的需求数。

除了进行代数简化以外，还执行了下面的规范化：

@itemize @bullet
@item
对于可交换指令和比较指令，总是将常量作为第二个操作数。
如果机器只支持常量作为第二个操作数，
则只需要提供匹配将常量作为第二个操作数的指令模式。

@item
对于结合性操作符，操作符序列总是向左方向链接；例如，一个整数@code{plus}，
只有它的左操作数本身可以为一个@code{plus}。当应用到整数时，
@code{and}, @code{ior}, @code{xor}, @code{plus}, @code{mult}, @code{smin}, 
@code{smax}, @code{umin}和@code{umax}为可结合的，对于浮点，这些有时为可结合的。

@item
@cindex @code{neg}, canonicalization of
@cindex @code{not}, canonicalization of
@cindex @code{mult}, canonicalization of
@cindex @code{plus}, canonicalization of
@cindex @code{minus}, canonicalization of
对于这些操作符，如果只有一个为@code{neg}, @code{not},@code{mult}, @code{plus} 或
@code{minus}表达式的操作数，则其将为第一个操作数。

@item
对于@code{neg}, @code{mult}, @code{plus}和@code{minus}的组合中，
@code{neg}操作（如果存在）将被尽可能的移到内部。
例如@code{(neg (mult A B))}将被规范为@code{(mult (neg A) B)}，
但是@code{(plus (mult (neg A) B) C)}将被规范为@code{(minus A (mult B C))}。 

@cindex @code{compare}, canonicalization of
@item
对于@code{compare}运算符，在使用@code{cc0}（参见@ref{跳转指令模式}）的机器上，
常量总是为第二个操作数。 在其它机器上，极少的情况下，
编译器可能想使用常量作为第一个操作数来构建@code{compare}。但是，
这些情况并不常见，所以不值得来提供匹配常量作为第一个操作数的指令模式，
除非机器确实具有这样的指令。

在与上面条件相同的情况下，@code{neg}, @code{not}, @code{mult}, @code{plus} 或
@code{minus}的操作数被作为第一个操作数。

@item
@code{(ltu (plus @var{a} @var{b}) @var{b})}被转换为
@code{(ltu (plus @var{a} @var{b}) @var{a})}。
同样，使用@code{geu}来替换@code{ltu}。

@item
@code{(minus @var{x} (const_int @var{n}))}被转换为
@code{(plus @var{x} (const_int @var{-n}))}。

@item
在地址计算中（即，在@code{mem}中），左移操作被转换为与合适的2的幂相乘。 

@cindex @code{ior}, canonicalization of
@cindex @code{and}, canonicalization of
@cindex De Morgan's law
@item
De Morgan法则被用于在按位‘逻辑与’或着‘逻辑或’运算中，将位置反。
如果该结果为@code{not}表达式的唯一的操作数，则其为第一个。

具有执行按位‘逻辑与’，且其中一个操作数为一个按位求反的机器，
应该为该指令指定如下的指令模式

@smallexample
(define_insn ""
  [(set (match_operand:@var{m} 0 @dots{})
        (and:@var{m} (not:@var{m} (match_operand:@var{m} 1 @dots{}))
                     (match_operand:@var{m} 2 @dots{})))]
  "@dots{}"
  "@dots{}")
@end smallexample

@noindent
类似的，“NAND”指令的指令模式应给被写为

@smallexample
(define_insn ""
  [(set (match_operand:@var{m} 0 @dots{})
        (ior:@var{m} (not:@var{m} (match_operand:@var{m} 1 @dots{}))
                     (not:@var{m} (match_operand:@var{m} 2 @dots{}))))]
  "@dots{}"
  "@dots{}")
@end smallexample

对于这两种情况，都没必要包含许多逻辑上相同的RTL表达式。

@cindex @code{xor}, canonicalization of
@item
涉及按位‘异或’和求反的唯一可能的RTL表达式为@code{(xor:@var{m} @var{x} @var{y})}
和@code{(not:@var{m} (xor:@var{m} @var{x} @var{y}))}。

@item
对于三项的和，其中一个为常量的，将使用如下形式

@smallexample
(plus:@var{m} (plus:@var{m} @var{x} @var{y}) @var{constant})
@end smallexample

@item
在不使用@code{cc0}的机器上，
@code{(compare @var{x} (const_int 0))}将被转换为@var{x}。 

@cindex @code{zero_extract}, canonicalization of
@cindex @code{sign_extract}, canonicalization of
@item
位组（通常是单个位）和0的相等比较，将使用@code{zero_extract}，
而不是等价的@code{and}或者@code{sign_extract}运算。

@end itemize

更多的规范化规则都定义在@file{gcc/rtlanal.c}里的函数@code{commutative_operand_precedence}中。

@end ifset
@ifset INTERNALS
@node 扩展定义
@section 为代码生成定义RTL序列
@cindex expander definitions
@cindex code generation RTL sequences
@cindex defining RTL sequences for code generation

在一些目标机上，一些用于RTL生成的标准指令模式名无法通过单个insn来处理，
但是可以用一个RTL insn序列来表示它们。对于这些目标机，
你可以写一个@code{define_expand}来指定如何生成RTL序列。

@findex define_expand
@code{define_expand}为一个RTL表达式，看起来非常像@code{define_insn}；
但是不同之处为，@code{define_expand}只用于RTL生成，并且可以产生多个RTL insn。

@code{define_expand} RTX具有4个操作数:

@itemize @bullet
@item
名字。每个@code{define_expand}必须具有一个名字，
因为必须通过对名字的引用才能使用它。

@item
RTL模板。这是一个RTL表达式向量，表示一个指令序列。

@item
条件，一个字符串包含了一个C表达式。
该表达式用于表示该指令模式对于GCC运行时命令行选项所选择的什么样的target机器
子类别有效。这跟具有标准名字的@code{define_insn}的条件类似。因此，
条件（如果存在）可以不依赖于所匹配的insn的数据，而只是依赖于target机器类型标号。
编译器需要在初始化时测试这些条件，以便确切的知道在一次特定的运行时，
哪些命名指令有效。

@item
准备语句，一个字符串，包含了0个或多个C语句，其将在RTL模板生成RTL代码前被执行。
@end itemize

每个由@code{define_expand}生成的RTL insn必须匹配机器描述中的某个
@code{define_insn}。否则，编译器在尝试为insn生成代码或者试图对其进行优化的时候，
将会崩溃。

RTL模板，除了控制RTL insn的生成，还描述了当使用该指令模式时，
所需要指定的操作数。特别是，它为每个操作数给出了断言。

需要被指定的由指令模式生成RTL的，真正的操作数，
在RTL模板中它第一次出现的位置使用@code{match_operand}来描述。
这将把对于操作数的断言信息放入记录该事情的表中。
如果操作数被引用多次，则后续的引用应该使用@code{match_dup}。

RTL模板还可以引用内部操作数，
其为只在由@code{define_expand}生成的序列中使用的临时寄存器或者标号。
内部操作数使用@code{match_dup}来替换到RTL模板中，而不是@code{match_operand}。
内部操作数的值在编译器需要使用该指令模式时，不作为参数传入。替代的，
它们在指令模式中计算，在准备语句中。
这些语句计算值并将它们存入到合适的@code{operands}元素中，
以便@code{match_dup}可以找到它们。

有两个特定的宏，用于准备语句中：@code{DONE}和@code{FAIL}。
在其后面跟随一个分号，以作为一条语句来使用。

@table @code

@findex DONE
@item DONE
使用@code{DONE}宏来结束该指令模式的RTL生成。这种情况下，
由该指令模式生成的唯一的RTL insn将为在准备语句中显示调用@code{emit_insn}生成
的insn；RTL模板将不被生成。 

@findex FAIL
@item FAIL

使指令模式对于这种情况失败。当指令模式失败时，这意味着指令模式实际上无效。编译器中的调用程序将会尝试其它策略，使用其它指令模式来进行代码生成。

目前，FAIL操作只支持二元（加法，乘法，移位等）和
位域（@code{extv}, @code{extzv}和@code{insv}）操作。 
@end table

如果准备语句即没有调用@code{DONE}，也没有调用@code{FAIL}，
则@code{define_expand}的行为便跟@code{define_insn}一样，即RTL模板用于生成insn

RTL模板不用于匹配，只是用于生成最初的insn列表。
如果准备语句总是调用@code{DONE}或者@code{FAIL}，
则RTL模板可以简化为一个简单的操作数列表，例如：

@smallexample
@group
(define_expand "addsi3"
  [(match_operand:SI 0 "register_operand" "")
   (match_operand:SI 1 "register_operand" "")
   (match_operand:SI 2 "register_operand" "")]
@end group
@group
  ""
  "
@{
  handle_add (operands[0], operands[1], operands[2]);
  DONE;
@}")
@end group
@end smallexample

这里有一个例子，是为SPUR芯片定义的左移位：

@smallexample
@group
(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (ashift:SI
@end group
@group
          (match_operand:SI 1 "register_operand" "")
          (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "
@end group
@end smallexample

@smallexample
@group
@{
  if (GET_CODE (operands[2]) != CONST_INT
      || (unsigned) INTVAL (operands[2]) > 3)
    FAIL;
@}")
@end group
@end smallexample

@noindent
这个例子使用了@code{define_expand}，使得当移位数在支持的0到3的范围内时，
便会生成移位RTL insn，而对于其它情况，则会失败。当其失败时，
编译器便会使用不同的指令模式（比如一个库调用）来尝试其它策略。

如果编译器能够处理具有名字的指令模式中的非平凡的条件字符串，
则对于这样情况也可以使用@code{define_insn}。这里有另一种情况（68000上的0扩展），
其使用了@code{define_expand}的更强大的功能：

@smallexample
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "")
        (const_int 0))
   (set (strict_low_part
          (subreg:HI
            (match_dup 0)
            0))
        (match_operand:HI 1 "general_operand" ""))]
  ""
  "operands[1] = make_safe_from (operands[1], operands[0]);")
@end smallexample

@noindent
@findex make_safe_from
这里将会生成两个RTL insn，一个用于清除整个输出操作数，
另一个用于将输入操作数复制到其低半部份。
该指令序列在输入操作数指向输出操作数（的旧值）时，是不正确的。
所以，准备语句用来确保不是这样。当其指向@code{operands[0]}时，
函数@code{make_safe_from}用来将@code{operands[1]}复制到临时寄存器中。
其通过生成另一个RTL insn来完成这件事。

最后，第三个例子显示了内部操作数的使用。
在SPUR芯片上的0扩展是通过将结果与上半字mask来完成的。
但是该mask不能通过一个@code{const_int}来表示，因为常量值太大，
无法在该机器上被合法化。所以其必须使用@code{force_reg}复制到寄存器中，
然后在@code{and}中使用该寄存器。

@smallexample
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
        (and:SI (subreg:SI
                  (match_operand:HI 1 "register_operand" "")
                  0)
                (match_dup 2)))]
  ""
  "operands[2]
     = force_reg (SImode, GEN_INT (65535)); ")
@end smallexample

注意：如果@code{define_expand}被用于一个标准的二元或者一元算数运算，
或者一个位域运算，则其生成的最后的insn一定不能为一个@code{code_label},
@code{barrier}或@code{note}。其必须为一个@code{insn},
@code{jump_insn}或@code{call_insn}。如果你在结尾处不需要实际的insn，
则可以生成一条将操作数的结果复制到其本身的insn。这样的insn将不会生成代码，
但可以避免编译器中的问题。

@end ifset
@ifset INTERNALS
@node Insn拆分
@section 定义如何拆分指令
@cindex insn splitting
@cindex instruction splitting
@cindex splitting instructions

有两种情况，你应该指定如何将一个指令模式拆分为多个insn。在一些机器上，
指令需要延迟槽（参见@ref{延迟槽}）或者指令的输出对于多周期
（参见@ref{处理器流水线描述}）不可用，
则优化这些情况的编译器过程需要能够将insn移入延迟槽中。但是，
一些insn可能会生成不止一条机器指令。这些insn则不能被放入延迟槽。

通常你可以重写单个insn为单独的insn列表，每个对应于一条机器指令。
这样做的缺点是它将造成编译变慢并且需要更多的空间。如果结果insn太复杂，
则还会抑制一些优化。当编译器有理由相信可以改进指令或者延迟槽调度的时候，
则会拆分insn。

insn组合器阶段还拆分putative insns。
如果三个insn被合并到一个使用复杂表达式的insn，
其不能被某个@code{define_insn}模式匹配，
则组合器阶段尝试将复杂指令模式拆分为两个被识别的insn。通常，
它能够将复杂指令模式通过拆分某个子表达式来断开。但是，有些情况下，
像在一个RISC机器上执行一个大常量的加法，则拆分加法为两个insn的方式是机器相关的。

@findex define_split
@code{define_split}定义告诉了编译器如何将一个复杂的insn拆分为多个简单的insn。
它的形式为：

@smallexample
(define_split
  [@var{insn-pattern}]
  "@var{condition}"
  [@var{new-insn-pattern-1}
   @var{new-insn-pattern-2}
   @dots{}]
  "@var{preparation-statements}")
@end smallexample

@var{insn-pattern}为需要被拆分的指令模式，@var{condition}为要被测试的最终条件，
跟@code{define_insn}中的一样。当一个insn匹配@var{insn-pattern}，
并且满足条件@var{condition}，则它由insn列表@var{new-insn-pattern-1},
@var{new-insn-pattern-2}等来替换。

@var{preparation-statements}与那些为@code{define_expand}（参见@ref{扩展定义}）
指定的语句类似，并且在生成新RTL之前被执行。
与@code{define_expand}中的不同之处为，这些语句不能生成任何新的伪寄存器。
一旦完成重载，它们则不能在栈帧中分配任何空间。

指令模式根据两种不同的环境来匹配@var{insn-pattern}。
如果需要为延迟槽调度或者insn调度来拆分insn，则insn已经是有效的，
这意味着它已经被一些@code{define_insn}匹配过，
并且如果@code{reload_completed}为非0，则已经满足那个@code{define_insn}的约束。
在那种情况下，新的insn模式必须也是匹配某个@code{define_insn}的insn，
并且如果@code{reload_completed}为非0，则也必须满足那些定义的约束。

对于这种@code{define_split}用法的例子，考虑下面来自@file{a29k.md}的例子，
其将从@code{HImode}到@code{SImode}的@code{sign_extend}拆分为一对shift insn：

@smallexample
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (sign_extend:SI (match_operand:HI 1 "gen_reg_operand" "")))]
  ""
  [(set (match_dup 0)
        (ashift:SI (match_dup 1)
                   (const_int 16)))
   (set (match_dup 0)
        (ashiftrt:SI (match_dup 0)
                     (const_int 16)))]
  "
@{ operands[1] = gen_lowpart (SImode, operands[1]); @}")
@end smallexample

当组合器阶段尝试拆分一个insn模式时，则情况总是为，
指令模式没有被任何@code{define_insn}匹配。
组合器过程首先尝试将单个@code{set}表达式拆分，
然后是在@code{parallel}中的相同的@code{set}表达式，
不过跟随一个伪寄存器的@code{clobber}，以作为scratch寄存器来使用。
这这些情况下，组合器期望能够生成两个新的insn。
它将验证这些指令模式匹配某个@code{define_insn}定义，
所以你不需要在@code{define_split}中做这些测试（当然，there is no point in writing a @code{define_split} that will never produce insns that match).

@smallexample
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (plus:SI (match_operand:SI 1 "gen_reg_operand" "")
                 (match_operand:SI 2 "non_add_cint_operand" "")))]
  ""
  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))
   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]
"
@{
  int low = INTVAL (operands[2]) & 0xffff;
  int high = (unsigned) INTVAL (operands[2]) >> 16;

  if (low & 0x8000)
    high++, low |= 0xffff0000;

  operands[3] = GEN_INT (high << 16);
  operands[4] = GEN_INT (low);
@}")
@end smallexample

这里断言@code{non_add_cint_operand}匹配任何不是单个add insn的有效操作数的
@code{const_int}。

使用scratch寄存器的例子，来自同一个文件，
用来生成等价的寄存器和大常量的比较运算：

@smallexample
(define_split
  [(set (match_operand:CC 0 "cc_reg_operand" "")
        (compare:CC (match_operand:SI 1 "gen_reg_operand" "")
                    (match_operand:SI 2 "non_short_cint_operand" "")))
   (clobber (match_operand:SI 3 "gen_reg_operand" ""))]
  "find_single_use (operands[0], insn, 0)
   && (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ
       || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)"
  [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))
   (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]
  "
@{
  /* @r{Get the constant we are comparing against, C, and see what it
     looks like sign-extended to 16 bits.  Then see what constant
     could be XOR'ed with C to get the sign-extended value.}  */

  int c = INTVAL (operands[2]);
  int sextc = (c << 16) >> 16;
  int xorv = c ^ sextc;

  operands[4] = GEN_INT (xorv);
  operands[5] = GEN_INT (sextc);
@}")
@end smallexample

为了避免混淆，不要写这样的@code{define_split}，
其接受匹配某个@code{define_insn}的一些insn，同时也接受不匹配的insn。替代的，
可以写两个分别的@code{define_split}定义，一个针对有效的insn，
一个针对无效的insn。

允许将跳转指令拆分为一个跳转序列或者在拆分非跳转指令时创建新的跳转。
由于控制流图和分支预测信息需要更新，所以会有一些限制。

将跳转指令拆分为由另一个跳转指令覆盖的指令序列，总是有效的，
因为编译器期望新的跳转具有相同的行为。当新的序列包含多个跳转指令或新的标号时，
则需要更多的辅助。只允许创建无条件跳转，或者简单的条件跳转指令。另外，
其必须为每个条件跳转附加一个@code{REG_BR_PROB}注解。
全局变量@code{split_branch_probability}保存了原始分支的可能性。
为了简化边频率的重新计算，新的序列要求只具有向前跳转。

@findex define_insn_and_split
对于通常的情况，define_split的模式完全匹配define_insn的模式，
则可以使用@code{define_insn_and_split}。其形式为：

@smallexample
(define_insn_and_split
  [@var{insn-pattern}]
  "@var{condition}"
  "@var{output-template}"
  "@var{split-condition}"
  [@var{new-insn-pattern-1}
   @var{new-insn-pattern-2}
   @dots{}]
  "@var{preparation-statements}"
  [@var{insn-attributes}])

@end smallexample

@var{insn-pattern}, @var{condition}, @var{output-template}和
@var{insn-attributes}跟在@code{define_insn}中的用法一样. 
@var{new-insn-pattern}向量和@var{preparation-statements}跟在
@code{define_split}中的用法一样。
@var{split-condition}也跟在@code{define_split}中的用法一样, 
不同之处是如果condition开始于@samp{&&}, 
则用于拆分的条件将被构造为split condition和insn condition的逻辑“and”运算。
例如，在i386.md中:

@smallexample
(define_insn_and_split "zero_extendhisi2_and"
  [(set (match_operand:SI 0 "register_operand" "=r")
     (zero_extend:SI (match_operand:HI 1 "register_operand" "0")))
   (clobber (reg:CC 17))]
  "TARGET_ZERO_EXTEND_WITH_AND && !optimize_size"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0)
                   (and:SI (match_dup 0) (const_int 65535)))
              (clobber (reg:CC 17))])]
  ""
  [(set_attr "type" "alu1")])

@end smallexample

在这种情况下，实际的split condition将为@samp{TARGET_ZERO_EXTEND_WITH_AND && !optimize_size && reload_completed}。

@code{define_insn_and_split}结构提供了与两个单独的@code{define_insn}和@code{define_split}指令模式相同的功能. 其形式紧凑。

@end ifset
@ifset INTERNALS
@node 包含指令模式
@section 在机器描述中包含指令模式
@cindex insn includes

@findex include
模板@code{include}告诉编译器工具，
从哪里寻找在其它文件中而不是文件@file{.md}中的模板。
这只在构建时候使用，并且不允许进行预处理操作。

其形如：

@smallexample

(include
  @var{pathname})
@end smallexample

例如：

@smallexample

(include "filestuff")

@end smallexample

其中@var{pathname}为一个指定文件位置的字符串，
指定了包含文件为@file{gcc/config/target/filestuff}。
目录@file{gcc/config/target}被当作缺省目录。

机器描述可以被分割成容易管理的小章节并放在子目录下。

通过指定：

@smallexample

(include "BOGUS/filestuff")

@end smallexample

包含文件被指定为@file{gcc/config/@var{target}/BOGUS/filestuff}。

为包含文件指定一个绝对路径，像：

@smallexample

(include "/u2/BOGUS/filestuff")

@end smallexample

是被允许的，但不鼓励这么做。

@subsection 用于目录搜索的RTL生成工具选项
@cindex directory options .md
@cindex options, directory search
@cindex search options

选项@option{-I@var{dir}}指定了搜索机器描述的目录。例如：

@smallexample

genrecog -I/p1/abc/proc1 -I/p2/abcd/pro2 target.md

@end smallexample

目录@var{dir}将被增加到搜索头文件的目录列表的头部。
这可以用来覆盖系统的机器定义文件，而替换为你自己的版本，
因为这些目录将在缺省机器描述文件目录之前被搜索。
如果你使用了多个@option{-I}选项，则目录按照从左到右的顺序被扫描；
之后为标准的缺省目录。

@end ifset
@ifset INTERNALS
@node 窥孔定义
@section 机器特定的窥孔优化
@cindex peephole optimizer definitions
@cindex defining peephole optimizers

除了指令模式，@file{md}文件还可以包含关于机器特定的窥孔优化的定义。

当程序中的数据流没有建议进行尝试的时候，
组合器便不会注意某些可能存在的窥孔优化。
例如，有时两个连续的insn是可以被组合的，
虽然第二个没有显示出要使用在第一个中所计算的寄存器。
机器特定的窥孔优化器可以检测出这样的机会。

有两种窥孔定义形式可以使用。
最初的@code{define_peephole}运行于汇编输出时，
用于匹配insn和替换汇编文本。不赞成使用@code{define_peephole}。

较新的@code{define_peephole2}用来匹配insn和替换新的insn。
@code{peephole2}过程运行于寄存器分配之后，调度之前，
其使进行调度的target获得更好的代码。

@menu
* define_peephole::     RTL到文本的窥孔优化器
* define_peephole2::    RTL到RTL的窥孔优化器
@end menu

@end ifset
@ifset INTERNALS
@node define_peephole
@subsection RTL到文本的窥孔优化器
@findex define_peephole

@need 1000
定义的形式如下：

@smallexample
(define_peephole
  [@var{insn-pattern-1}
   @var{insn-pattern-2}
   @dots{}]
  "@var{condition}"
  "@var{template}"
  "@var{optional-insn-attributes}")
@end smallexample

@noindent
如果没有在该机器描述中使用任何机器特定的信息，
则可以省略掉最后的字符串操作数。
如果有，则其必须遵守在@code{define_insn}中相同的规则。

该结构中，@var{insn-pattern-1}等为匹配连续insn的指令模式。
当@var{insn-pattern-1}匹配第一个insn，
@var{insn-pattern-2}匹配下一个，等等依次类推的情况时，
则会将优化应用到该insn序列。

每个由窥孔匹配的insn也必须匹配一个@code{define_insn}。
窥孔只在代码生成前的最后阶段被检查，并且只是可选的。
因此，在一个未优化的编译中，或者不同的优化阶段中，
任何匹配窥孔但是不匹配@code{define_insn}的将会在代码生成时造成崩溃。

和通常一样，insn的操作数使用@code{match_operands},
@code{match_operator}和@code{match_dup}来匹配。
不同的是，操作数编号应用在定义的所有insn指令模式中。所以，
你可以通过一个insn中的@code{match_operand}和另一个insn中的@code{match_dup}，
来在两个insn中检查相同的操作数。

用于@code{match_operand}指令模式的操作数constraint对窥孔的适用性没有任何直接的影响，
不过它们将会在后面被验证，所以要确信当窥孔匹配时，你的constraint要足够通用。
如果窥孔匹配，但constraint却不满足，则编译器将崩溃。

将窥孔中的所有操作数的constraint省略掉是安全的；
或者你可以编写constraint作为之前测试过的标准的二次检查。

一旦insn序列匹配指令模式，则@code{condition}将被检查。
这是一个C表达式，用于对是否执行优化来做最后的决定
（如果表达式非0时，我们这样做）。
如果@code{condition}被省略掉（换句话说，字符串为空）
则优化会被应用到每个匹配指令模式的insn序列。

定义的窥孔优化在寄存器分配完成之后应用。
因此，窥孔定义可以只是查看操作数，便能检查哪些操作数结束于哪种寄存器。

@findex prev_active_insn
在条件中引用操作数的方式为对操作数编号@var{i}编写@code{operands[@var{i}]}
（匹配于@code{(match_operand @var{i} @dots{})}）。
使用变量@code{insn}来引用正在被匹配的insns的最后一个insn；
使用@code{prev_active_insn}来找到先前的insns。

@findex dead_or_set_p
当正在优化中间结果计算时，
你可以使用条件来匹配只有当中间结果不在其它地方被使用的情况。
使用C表达式@code{dead_or_set_p (@var{insn}, @var{op})}，
其中@var{insn}为你所期望其值为最后一次被使用的insn，
以及@var{op}为中间值（来自@code{operands[@var{i}]}）。

应用优化，意味着将insn序列替换为新的insn。
@var{template}控制了针对该组合insn的最终汇编代码输出。
就像@code{define_insn}模板所做的一样。
该模板中的操作数编号与用于要匹配的原始insn序列中的相同。

被定义的窥孔优化器的结果不需要匹配机器描述中的任何insn模式；
它甚至没有机会来匹配它们。窥孔优化器定义本身是作为insn模式，
用来控制insn如何输出。

被定义的窥孔优化器被作为汇编代码运行输出，
所以它们产生的insns不再被组合或重排。

这里有一个例子，来自68000机器描述：

@smallexample
(define_peephole
  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
   (set (match_operand:DF 0 "register_operand" "=f")
        (match_operand:DF 1 "register_operand" "ad"))]
  "FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])"
@{
  rtx xoperands[2];
  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);
#ifdef MOTOROLA
  output_asm_insn ("move.l %1,(sp)", xoperands);
  output_asm_insn ("move.l %1,-(sp)", operands);
  return "fmove.d (sp)+,%0";
#else
  output_asm_insn ("movel %1,sp@@", xoperands);
  output_asm_insn ("movel %1,sp@@-", operands);
  return "fmoved sp@@+,%0";
#endif
@})
@end smallexample

@need 1000
该优化的效果是将

@smallexample
@group
jbsr _foobar
addql #4,sp
movel d1,sp@@-
movel d0,sp@@-
fmoved sp@@+,fp0
@end group
@end smallexample

@noindent
转换为

@smallexample
@group
jbsr _foobar
movel d1,sp@@
movel d0,sp@@-
fmoved sp@@+,fp0
@end group
@end smallexample

@ignore
@findex CC_REVERSED
If a peephole matches a sequence including one or more jump insns, you must
take account of the flags such as @code{CC_REVERSED} which specify that the
condition codes are represented in an unusual manner.  The compiler
automatically alters any ordinary conditional jumps which occur in such
situations, but the compiler cannot alter jumps which have been replaced by
peephole optimizations.  So it is up to you to alter the assembler code
that the peephole produces.  Supply C code to write the assembler output,
and in this C code check the condition code status flags and change the
assembler code as appropriate.
@end ignore

@var{insn-pattern-1}等看起来与@code{define_insn}的第二个操作数非常相似。
不过有一个重要的不同：@code{define_insn}的第二个操作数包含了一个或多个RTX，
使用方括号包裹。通常，只有一个：
那么相同的动作则可以写成@code{define_peephole}的一个元素。
但是，当在@code{define_insn}中有多个动作时，它们被隐式的由@code{parallel}包裹。
则你必须在@code{define_peephole}中，显式的写出@code{parallel}，以及里面的方括号。
因此，如果一个insn的指令模式如下，

@smallexample
(define_insn "divmodsi4"
  [(set (match_operand:SI 0 "general_operand" "=d")
        (div:SI (match_operand:SI 1 "general_operand" "0")
                (match_operand:SI 2 "general_operand" "dmsK")))
   (set (match_operand:SI 3 "general_operand" "=d")
        (mod:SI (match_dup 1) (match_dup 2)))]
  "TARGET_68020"
  "divsl%.l %2,%3:%0")
@end smallexample

@noindent
则在窥孔中提及该insn的方法为：

@smallexample
(define_peephole
  [@dots{}
   (parallel
    [(set (match_operand:SI 0 "general_operand" "=d")
          (div:SI (match_operand:SI 1 "general_operand" "0")
                  (match_operand:SI 2 "general_operand" "dmsK")))
     (set (match_operand:SI 3 "general_operand" "=d")
          (mod:SI (match_dup 1) (match_dup 2)))])
   @dots{}]
  @dots{})
@end smallexample

@end ifset
@ifset INTERNALS
@node define_peephole2
@subsection RTL到RTL的窥孔优化器
@findex define_peephole2

@code{define_peephole2}定义告诉了编译器如何将一个指令序列用来替换另一个序列，
可能需要那些额外的scratch寄存器，以及它们的生命期必须为什么。

@smallexample
(define_peephole2
  [@var{insn-pattern-1}
   @var{insn-pattern-2}
   @dots{}]
  "@var{condition}"
  [@var{new-insn-pattern-1}
   @var{new-insn-pattern-2}
   @dots{}]
  "@var{preparation-statements}")
@end smallexample

定义几乎与@code{define_split}（参见 @ref{Insn拆分}）相同，
除了要匹配的指令模式不是一个单个指令，而是一个指令序列。

在输出模板中有可能需要用到额外的scratch寄存器。
如果没有合适的寄存器，则指令模式将简单的作为不匹配处理。

@findex match_scratch
@findex match_dup
使用@code{match_scratch}描述所需要的scratch寄存器，
并放在输入指令模式的顶层。被分配的寄存器（最初的）
将会在原始指令序列中需要使用的位置死掉。
如果scratch被用于多个位置，
则位于输入指令模式顶层的@code{match_dup}
指令模式用来标记在输入序列中寄存器必须为活跃的最后位置。

这里有一个来自IA-32机器描述的例子：

@smallexample
(define_peephole2
  [(match_scratch:SI 2 "r")
   (parallel [(set (match_operand:SI 0 "register_operand" "")
                   (match_operator:SI 3 "arith_or_logical_operator"
                     [(match_dup 0)
                      (match_operand:SI 1 "memory_operand" "")]))
              (clobber (reg:CC 17))])]
  "! optimize_size && ! TARGET_READ_MODIFY"
  [(set (match_dup 2) (match_dup 1))
   (parallel [(set (match_dup 0)
                   (match_op_dup 3 [(match_dup 0) (match_dup 2)]))
              (clobber (reg:CC 17))])]
  "")
@end smallexample

@noindent
该指令模式尝试拆分加载的使用，以希望我们能够调度内存加载延迟。
它分配了一个@code{GENERAL_REGS}(@code{"r"})类别的单个的@code{SImode}寄存器，
其只需在算术运算之前的位置为活跃的。

很难找到需要延长scratch生命期的真实例子，所以这里只是一个制造的例子： 

@smallexample
(define_peephole2
  [(match_scratch:SI 4 "r")
   (set (match_operand:SI 0 "" "") (match_operand:SI 1 "" ""))
   (set (match_operand:SI 2 "" "") (match_dup 1))
   (match_dup 4)
   (set (match_operand:SI 3 "" "") (match_dup 1))]
  "/* @r{determine 1 does not overlap 0 and 2} */"
  [(set (match_dup 4) (match_dup 1))
   (set (match_dup 0) (match_dup 4))
   (set (match_dup 2) (match_dup 4))]
   (set (match_dup 3) (match_dup 4))]
  "")
@end smallexample

@noindent
如果我们没有在输入序列的中间增加@code{(match_dup 4)}，
则可能的情况是我们选择的寄存器会在序列的起始处被第一个或第二个@code{set}杀死。

@end ifset
@ifset INTERNALS
@node Insn属性
@section 指令属性
@cindex insn attributes
@cindex instruction attributes

除了描述target机器所支持的指令以外，@file{md} 文件还定义了一组 
@dfn{attributes} 以及每个属性的取值集合。每条生成的insn都为每个属性赋予一
个值。一种可能的属性是insn对于机器的条件代码所产生的影响。该属性然后可以
被 @code{NOTICE_UPDATE_CC} 使用，来跟踪条件代码。

@menu
* 定义属性::         指定属性以及它们的值。
* 表达式::           属性值的有效表达式。
* 给Insns打标签::    为insns赋予属性值。
* 属性例子::       一个设置属性的例子。
* Insn长度::         计算insns的长度。
* 常量属性::         定义值为常量的属性。
* 延迟槽::           定义机器所需要的延迟槽。
* 处理器流水线描述:: 为insn调度指定信息。
@end menu

@end ifset
@ifset INTERNALS
@node 定义属性
@subsection 定义属性以及它们的值
@cindex defining attributes and their values
@cindex attributes, defining

@findex define_attr
表达式 @code{define_attr} 用于定义目标机所需要的每个属性。其形式为：

@smallexample
(define_attr @var{name} @var{list-of-values} @var{default})
@end smallexample

@var{name} 为一个字符串，指定了被定义的属性名。

@var{list-of-values} 或者为一个字符串，指定了可以赋予属性的逗号分隔
的值的列表，或者为一个空字符串，表示属性接受一个数字值。

@var{default} 为一个属性表达式，给出了匹配指令模式，但指令模式定义中
没有显式包含该属性值的insns，所应具有的属性值。关于更多处理缺省值的
信息，@pxref{Attr Example}。关于不依赖于任何特定insn的属性，
@pxref{Constant Attributes}。

@findex insn-attr.h
对于每个定义的属性，都有许多定义被写入 @file{insn-attr.h} 文件。对于
显式指定了属性取值集合的情况，下列将被定义：

@itemize @bullet
@item
一个针对符号 @samp{HAVE_ATTR_@var{name}} 的 @samp{#define} 被写入。

@item
一个枚举类别被定义，元素的形式为 @samp{@var{upper-name}_@var{upper-value}}，
其中属性名和值首先被转换为大写的。

@item
一个函数 @samp{get_attr_@var{name}} 被定义，其传入一个insn并返回该insn
的属性值。
@end itemize

例如，如果在 @file{md} 文件中存在下列定义：

@smallexample
(define_attr "type" "branch,fp,load,store,arith" @dots{})
@end smallexample

@noindent
则下面的行将被写入文件 @file{insn-attr.h} 中。

@smallexample
#define HAVE_ATTR_type
enum attr_type @{TYPE_BRANCH, TYPE_FP, TYPE_LOAD,
                 TYPE_STORE, TYPE_ARITH@};
extern enum attr_type get_attr_type ();
@end smallexample

如果属性接受数字值，则不会定义@code{enum} 类型，并且获得属性值的函数将
返回@code{int}。

有些属性被赋予特定的含义。这些属性不能随便用于其它目的：

@table @code
@item length
@code{length}属性用于计算每输出的代码块的长度。这尤其在验证分支距离的时候特别重要。@xref{Insn Lengths}。

@item enabled
@code{enabled}属性可以被定义，用来在代码生成过程中，阻止insn定义中的特定的可选项。@xref{Disable Insn Alternatives}

@end table

@end ifset
@ifset INTERNALS
@node 表达式
@subsection 属性表达式
@cindex attribute expressions

用于定义属性的RTL表达式，除了使用上面描述的代码外，还使用了下面要
讨论的一些细节。属性值表达式必须为下列形式之一：

@table @code
@cindex @code{const_int} and attributes
@item (const_int @var{i})
整数 @var{i} 指定了一个数字属性的值。 @var{i} 必须为非负的。 

数字属性的值可以被指定为一个 @code{const_int}，或者一个在
@code{const_string}, @code{eq_attr} (参见下面), @code{attr}, 
@code{symbol_ref}, 简单算术表达式, 和特定指令上的 @code{set_attr} 
(@pxref{Tagging Insns})中，作为字符串来表示的整数，

@cindex @code{const_string} and attributes
@item (const_string @var{value})
字符串指定了一个常量属性值。如果 @var{value} 使用 @samp{"*"} 指定，
则表示包含该表达式的insn将使用属性的缺省值。显然 @samp{"*"} 不能用
于 @code{define_attr} 的 @var{default} 表达式。

如果属性值被指定为数值的，@var{value} 必须为一个字符串，包含了一个
非负整数（通常这种情况下会使用 @code{const_int}）。否则，其必须包含
一个有效的属性值。 

@cindex @code{if_then_else} and attributes
@item (if_then_else @var{test} @var{true-value} @var{false-value})
@var{test} 指定了一个属性测试，其格式在下面定义。如果 @var{test} 为
真时，该表达式的值为 @var{true-value}，否则为 @var{false-value}。

@cindex @code{cond} and attributes
@item (cond [@var{test1} @var{value1} @dots{}] @var{default})
该表达式的第一个操作数为一个向量，包含了偶数个表达式并且由 @var{test} 
和 @var{value} 表达式对组成。表达式 @code{cond} 的值为对应于第一个为
真的 @var{test} 表达式的 @var{value}。如果没有 @var{test} 表达式为真，
则 @code{cond} 表达式的值为 @var{default} 表达式。 
@end table

@var{test}表达式可以具有下列形式：

@table @code
@cindex @code{const_int} and attribute tests
@item (const_int @var{i})
该测试为真，如果@var{i}非零，否则为假。

@cindex @code{not} and attributes
@cindex @code{ior} and attributes
@cindex @code{and} and attributes
@item (not @var{test})
@itemx (ior @var{test1} @var{test2})
@itemx (and @var{test1} @var{test2})
这些测试为真，如果所表示的逻辑函数为真。

@cindex @code{match_operand} and attributes
@item (match_operand:@var{m} @var{n} @var{pred} @var{constraints})
该测试为真，如果insn的操作数@var{n}，其属性值被确定具有机器模式@var{m}（如果@var{m}为@code{VOIDmode}，则这部分测试被忽略），并且被字符串@var{pred}指定的函数，当传递操作数@var{n}和机器模式@var{m}时，返回一个非零值（如果@var{pred}为空字符串，则这部分测试被忽略）。

@var{constraints}操作数被忽略并且应该为空字符串。

@cindex @code{le} and attributes
@cindex @code{leu} and attributes
@cindex @code{lt} and attributes
@cindex @code{gt} and attributes
@cindex @code{gtu} and attributes
@cindex @code{ge} and attributes
@cindex @code{geu} and attributes
@cindex @code{ne} and attributes
@cindex @code{eq} and attributes
@cindex @code{plus} and attributes
@cindex @code{minus} and attributes
@cindex @code{mult} and attributes
@cindex @code{div} and attributes
@cindex @code{mod} and attributes
@cindex @code{abs} and attributes
@cindex @code{neg} and attributes
@cindex @code{ashift} and attributes
@cindex @code{lshiftrt} and attributes
@cindex @code{ashiftrt} and attributes
@item (le @var{arith1} @var{arith2})
@itemx (leu @var{arith1} @var{arith2})
@itemx (lt @var{arith1} @var{arith2})
@itemx (ltu @var{arith1} @var{arith2})
@itemx (gt @var{arith1} @var{arith2})
@itemx (gtu @var{arith1} @var{arith2})
@itemx (ge @var{arith1} @var{arith2})
@itemx (geu @var{arith1} @var{arith2})
@itemx (ne @var{arith1} @var{arith2})
@itemx (eq @var{arith1} @var{arith2})
这些测试为真，如果所表示的对两个算术表达式的比较为真。算术表达式的形式为
@code{plus}, @code{minus}, @code{mult}, @code{div}, @code{mod},
@code{abs}, @code{neg}, @code{and}, @code{ior}, @code{xor}, @code{not},
@code{ashift}, @code{lshiftrt}和@code{ashiftrt}表达式。

@findex get_attr
@code{const_int}和@code{symbol_ref}总为有效（其它的形式，@pxref{Insn Lengths}）。@code{symbol_ref}为一个字符串，表示当使用@samp{get_attr_@dots{}}程序求解时，可以生成一个@code{int}的C表达式。其通常应该为一个全局变量。

@findex eq_attr
@item (eq_attr @var{name} @var{value})
@var{name}为一个字符串，指定了属性的名字。

@var{value}为一个字符串，或者为一个该属性@var{name}的有效值，由逗号分隔的值列表，或者为@samp{!}，后面跟随一个值或者列表。如果@var{value}不是起始于@samp{!}，则该测试为真，如果当前insn的@var{name}属性的值在值列表中。如果@var{value}起始于@samp{!}，则该测试为真，如果属性值不在指定的列表中。

例如，

@smallexample
(eq_attr "type" "load,store")
@end smallexample

@noindent

等价于

@smallexample
(ior (eq_attr "type" "load") (eq_attr "type" "store"))
@end smallexample

如果@var{name}指定了属性@samp{alternative}，则它是指的编译器变量@code{which_alternative}的值（@pxref{Output Statement}），并且值必须为小整数。例如，

@smallexample
(eq_attr "alternative" "2,3")
@end smallexample

@noindent

等价于

@smallexample
(ior (eq (symbol_ref "which_alternative") (const_int 2))
     (eq (symbol_ref "which_alternative") (const_int 3)))
@end smallexample

注意，对于大多数属性，当被测试的属性的值已知为匹配特定模式的所有insn时，@code{eq_attr}测试将被简化。这是迄今为止最常见的情况。

@findex attr_flag
@item (attr_flag @var{name})
表达式@code{attr_flag}的值为真，如果由@var{name}指定的标记对于当前被调度的@code{insn}为真。

@var{name}为一个字符串，指定了要测试的标记集合。测试标记@code{forward}和@code{backward}可以确定条件分支的方向。测试标记@code{very_likely}, @code{likely}, @code{very_unlikely}和@code{unlikely}可以确定条件分支是否被接受。

如果@code{very_likely}为真，则@code{likely}标记也为真。同样对于@code{very_unlikely}和@code{unlikely}也是这样。

该例子描述了一个条件分支延迟槽，其对于被接受的（annul-true）forward分支或者没有被接受的（annul-false）的backward分支，可以置空（nullified），

@smallexample
(define_delay (eq_attr "type" "cbranch")
  [(eq_attr "in_branch_delay" "true")
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "forward"))
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "backward"))])
@end smallexample

标记@code{forward}和@code{backward}为假，如果当前被调度的@code{insn}不是条件分支。

标记@code{very_likely}和@code{likely}为真，如果被调度的@code{insn}不是条件分支。标记@code{very_unlikely}和@code{unlikely}为假，如果被调度的@code{attr_flag}不是条件分支。

@code{attr_flag}只用于延迟槽调度阶段，并且跟编译器的其它过程没有关系。

@findex attr
@item (attr @var{name})
返回另一个属性的值。这对于数值属性非常有用，因为@code{eq_attr}和@code{attr_flag}可以产生比非数值属性更加有效的代码。

@end table

@end ifset
@ifset INTERNALS
@node 给Insns打标签
@subsection 给Insns赋予属性值
@cindex tagging insns
@cindex assigning attribute values to insns

给insn的属性赋予的值，主要由该insn所匹配的模式决定
（或者什么@code{define_peephole}生成的它）。
每个@code{define_insn}和@code{define_peephole}可以具有可选的最后的参数，
用来指定匹配insn的属性值。在特定insn中没有指定的任何属性的值，
将被设为在@code{define_attr}中指定的缺省值。

可选的@code{define_insn}和@code{define_peephole}最后的参数，为一个表达式向量，
每个元素定义了单个属性的值。赋属性值的最通用方式是使用@code{set}表达式，
其第一个操作数为一个@code{attr}表达式，给出了要设置的属性名。
第二个操作数为一个属性表达式（参见@ref{表达式}），给出了属性值。

当属性值依赖于可选（@samp{alternative}）属性，
则可以使用@code{set_attr_alternative}表达式。其允许指定属性表达式向量，
每个元素对应一个可选属性。

@findex set_attr
当不需要一般性的任意属性表达式，则可以使用简单的@code{set_attr}表达式，
其允许指定一个字符串，给出单个属性值或者属性值列表，
其中每个元素对应于一个可选属性。

以上的属性指定形式将在下面展示出。在每种情况中，@var{name}为一个字符串，
指定了要被设置的属性。

@table @code
@item (set_attr @var{name} @var{value-string})
@var{value-string}或者为一个字符串，给出了期望的属性值，
或者为一个包含了逗号分隔的列表的字符串，给出了后续可选项的值。
元素的个数必须匹配在insn指令模式的约束中的可选项的个数。

注意可以为一些可选项指定@samp{*}，这样属性将被假设它的缺省值匹配那个可选项。 

@findex set_attr_alternative
@item (set_attr_alternative @var{name} [@var{value1} @var{value2} @dots{}])
取决于insn的可选项，值将为被指定值的其中之一。
这是对@samp{alternative}属性使用@code{cond}的简化形式。

@findex attr
@item (set (attr @var{name}) @var{value})
第一个操作数必须为特定RTL表达式@code{attr}，其唯一的操作数是一个字符串，
给出了被设置的属性名。@var{value}为属性值。
@end table

下面展示了三种表示相同的属性指定的不同的方式：

@smallexample
(set_attr "type" "load,store,arith")

(set_attr_alternative "type"
                      [(const_string "load") (const_string "store")
                       (const_string "arith")])

(set (attr "type")
     (cond [(eq_attr "alternative" "1") (const_string "load")
            (eq_attr "alternative" "2") (const_string "store")]
           (const_string "arith")))
@end smallexample

@need 1000
@findex define_asm_attributes
表达式@code{define_asm_attributes}提供了一种机制，
用来指定赋予insn的属性是由@code{asm}语句产生的。其形式为：

@smallexample
(define_asm_attributes [@var{attr-sets}])
@end smallexample

@noindent
其中@var{attr-sets}为与@code{define_insn}和@code{define_peephole}中的相同。

这些值通常为“最坏情况”属性值。例如，它们可能指示条件码将被破坏（clobbered）。

为@code{length}属性赋值，将被特殊处理。
计算@code{asm} insn长度的方式是将表达式@code{define_asm_attributes}中指定的长度
乘以在@code{asm}语句中指定的机器指令个数。
指令个数通过计算字符串中分号和换行符的个数来决定。因此，
在@code{define_asm_attributes}中指定的@code{length}属性值应该为单个机器指令的
最大可能长度。

@end ifset
@ifset INTERNALS
@node 属性例子
@subsection 关于属性说明的例子
@cindex attribute specifications example
@cindex attribute specifications

要想有效的使用insn属性，巧妙的使用缺省值是很重要的。通常，insn被分为不同类别，
并使用称作@code{type}的属性来表示该值。该属性通常只用于定义其它属性的缺省值。
可以举一个例子来阐明它的用法。

假设我们有一个RISC机器，其具有一个条件码并且在寄存器中只进行全字操作。
让我们假设可以将所有的insn分为加载，存储，（整数）算术运算，浮点运算和分支。

在这里我们将关注条件码对于insn的影响，并局限在下列可能的影响：
条件码可以被不可预期的设置（clobbered），没有改变，被设为符合运算结果的值，
或者只在先前被设置的条件码已经被修改。

下面是该机器的一个样本@file{md}文件：

@smallexample
(define_attr "type" "load,store,arith,fp,branch" (const_string "arith"))

(define_attr "cc" "clobber,unchanged,set,change0"
             (cond [(eq_attr "type" "load")
                        (const_string "change0")
                    (eq_attr "type" "store,branch")
                        (const_string "unchanged")
                    (eq_attr "type" "arith")
                        (if_then_else (match_operand:SI 0 "" "")
                                      (const_string "set")
                                      (const_string "clobber"))]
                   (const_string "clobber")))

(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,r,m")
        (match_operand:SI 1 "general_operand" "r,m,r"))]
  ""
  "@@
   move %0,%1
   load %0,%1
   store %0,%1"
  [(set_attr "type" "arith,load,store")])
@end smallexample

注意我们假设在上面的例子中，比机器字小的算术运算将会clobber条件码，
因为它们将会根据全字的结果来设置条件码。

@end ifset
@ifset INTERNALS
@node Insn长度
@subsection 计算一个Insn的长度
@cindex insn lengths, computing
@cindex computing the length of an insn

许多机器提供了多种类型的分支指令，针对于不同长度的分支位移。多数情况下，
汇编器会选择使用正确的指令。但是，当汇编器无法做到的时候，如果一个特殊的属性，
@code{length}属性，被定义，则可以由GCC来完成。
该属性必须通过在它的@code{define_attr}中指定一个空字符串，
从而被定义成具有数字值。

对于@code{length}属性，在test表达式中允许两个额外形式的算术术语：

@table @code
@cindex @code{match_dup} and attributes
@item (match_dup @var{n})
这是指当前insn的操作数@var{n}的地址，其必须为一个@code{label_ref}。 

@cindex @code{pc} and attributes
@item (pc)
这是指当前insn的地址。或许可以将其设为下一个insn的地址，
从而跟其它地方的用法一致，但是这样容易引起混淆，因为还要计算当前insn的长度。 
@end table

@cindex @code{addr_vec}, length of
@cindex @code{addr_diff_vec}, length of
对于通常的insn，长度将由@code{length}属性的值来确定。
对于@code{addr_vec}和@code{addr_diff_vec}的insn模式，
长度通过向量数乘于每个向量的大小来计算获得。

长度按照可寻址的存储单元（字节）来度量。

下列宏可以用于改进长度计算：

@table @code
@findex ADJUST_INSN_LENGTH
@item ADJUST_INSN_LENGTH (@var{insn}, @var{length})
如果定义，则在上下文中作为函数来使用，用于修改赋予指令@var{insn}的长度。
@var{length}为一个lvalue（左值）包含了最初计算的insn长度并将使用insn的正确长度来更新。

该宏通常并不需要。一种使用它的情况为ROMP。在这个机器上，
一个@code{addr_vec} insn的大小必须被加2用于补偿可能需要的指令对齐。
@end table

@findex get_attr_length
返回@code{get_attr_length}（@code{length}属性的值）的程序，
可以被输出程序用来确定将要写入的分支指令的形式，正如下面的例子。

作为一个指定可变长度分支的例子，可以考虑一下IBM360。
如果我们采用寄存器将被设为函数起始地址这样的约定，
我们则可以使用一个4字节的指令来跳转到4K范围的标号。
否则，我们需要一个6字节的序列来从内存加载地址并然后分支到那里。

对于这样的机器，可以按照如下的方式来指定一个分支指令模式：

@smallexample
(define_insn "jump"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  ""
@{
   return (get_attr_length (insn) == 4
           ? "b %l0" : "l r15,=a(%l0); br r15");
@}
  [(set (attr "length")
        (if_then_else (lt (match_dup 0) (const_int 4096))
                      (const_int 4)
                      (const_int 6)))])
@end smallexample

@end ifset
@ifset INTERNALS
@node 常量属性
@subsection 常量属性
@cindex constant attributes

一个@code{define_attr}的特殊形式，是其缺省值的表达式为一个@code{const}表达式，
这表示了对于一个给定的运行编译器的一个属性为常量。
常量熟性可以用于指定使用了哪个处理器的变种。例如，

@smallexample
(define_attr "cpu" "m88100,m88110,m88000"
 (const
  (cond [(symbol_ref "TARGET_88100") (const_string "m88100")
         (symbol_ref "TARGET_88110") (const_string "m88110")]
        (const_string "m88000"))))

(define_attr "memory" "fast,slow"
 (const
  (if_then_else (symbol_ref "TARGET_FAST_MEM")
                (const_string "fast")
                (const_string "slow"))))
@end smallexample

针对常量属性生成的程序不具有任何参数，因为它不依赖于任何特定的insn。
用于定义常量属性的RTL表达式可以使用@code{symbol_ref}形式，
但是不可以使用包括insn属性的@code{match_operand}形式或者@code{eq_attr}形式。

@end ifset
@ifset INTERNALS
@node 延迟槽
@subsection 延迟槽调度
@cindex delay slots, defining

如果在一个目标机上存在延迟槽的话，insn属性机制可以用于指定对延迟槽的需求。
一条指令被称为需要延迟槽，
如果在物理上位于该指令之后的一些指令将被按照它们仿佛是位于之前的情况被执行。
典型的例子是分支和调用指令，其通常在执行分支或调用之前先执行后面的指令。

在一些机器上，条件分支指令可以选择性的废除（@dfn{annul}）延迟槽中的指令。
这意味着该指令对于特定的分支结果将不被执行。
对于分支为真时废除指令和分支为假时废除指令，这两种方式都被支持。

延迟槽调度与指令调度的不同之处在于，
判定一条指令是否需要延迟槽只依赖于正被生成的指令的类型，而不是指令间的数据流。
关于数据相关的指令调度的讨论，参见下一个章节。

@findex define_delay
一个insn对一个或多个延迟槽的需求是通过@code{define_delay}表达式来表示的。
其具有下列形式：

@smallexample
(define_delay @var{test}
              [@var{delay-1} @var{annul-true-1} @var{annul-false-1}
               @var{delay-2} @var{annul-true-2} @var{annul-false-2}
               @dots{}])
@end smallexample

@var{test}是一个属性测试，用来表示该@code{define_delay}是否应用到特定的insn。
如果是，则所需延迟槽的数目通过作为第二个参数的向量的长度来确定。
放在延迟槽@var{n}中的insn必须满足属性测试@var{delay-n}。
@var{annul-true-n}是一个属性测试，用来指定当分支为真时哪些insn可以被废除。
如果该延迟槽不支持废除，则应该使用@code{(nil)}。

例如，通常情况下分支和调用insns都需要一个单个的延迟槽，
其可以包含任何不是分支或调用的其它insn，则下面的可以放入@file{md}文件中：

@smallexample
(define_delay (eq_attr "type" "branch,call")
              [(eq_attr "type" "!branch,call") (nil) (nil)])
@end smallexample

可以指定多个@code{define_delay}表达式。在这种情况下，
每个这样的表达式都指定了不同的延迟槽需求，
并且在两个@code{define_delay}表达式中的test必须不能都为真。

例如，如果我们有一个机器，其对分支需要一个延迟槽，但对调用需要两个，
延迟槽不能包含分支或调用insn，并且当分支为真时，
任何在分支延迟槽中的有效insn可以被废除，则我们可以使用下列方式来表示：

@smallexample
(define_delay (eq_attr "type" "branch")
   [(eq_attr "type" "!branch,call")
    (eq_attr "type" "!branch,call")
    (nil)])

(define_delay (eq_attr "type" "call")
              [(eq_attr "type" "!branch,call") (nil) (nil)
               (eq_attr "type" "!branch,call") (nil) (nil)])
@end smallexample
@c the above is *still* too long.  --mew 4feb93

@end ifset
@ifset INTERNALS
@node 处理器流水线描述
@subsection 处理器流水线描述
@cindex processor pipeline description
@cindex processor functional units
@cindex instruction latency time
@cindex interlock delays
@cindex data dependence delays
@cindex reservation delays
@cindex pipeline hazard recognizer
@cindex automaton based pipeline description
@cindex regular expressions
@cindex deterministic finite state automaton
@cindex automaton based scheduler
@cindex RISC
@cindex VLIW

为了获得更好的性能，大多数现代处理器（超流水线，超标量@acronym{RISC}，
以及@acronym{VLIW}处理器）都具有许多功能单元（@dfn{functional units}），
可以在其上同时执行多条指令。一条指令当它的发射条件（issue conditions）
被满足时才开始执行。如果不满足，则指令会被阻塞（stalled），直到它的条件被满足。
这样的互锁（流水线）延迟(@dfn{interlock (pipeline) delay})
导致对后续指令读取的中断（或者需要nop指令，例如一些MIPS处理器）。

现代处理器中有两种主要的互锁延迟。第一种为数据依赖延迟，用来确定指令延迟时间
（@dfn{instruction latency time}）。直到所有源数据都被先前指令求得，
该指令才会开始执行（有更加复杂的情况是，
当指令开始执行时数据还不可用，但是将会在指令开始执行后的给定时间准备好）。
考虑数据依赖延迟是简单的。
两个指令间的数据依赖（真依赖，输出依赖，反依赖）延迟被给定为一个常量。
大多数情况下该方法都适合。第二种互锁延迟为保留延迟（reservation delay）。
保留延迟意味着要执行的两条指令将会需要共享的处理器资源，即总线，内部寄存器，
以及/或者功能单元，而这些将被保留一段时间。考虑这种延迟是复杂的，
特别是对于现代@acronym{RISC}处理器。

探索更多的处理器并行的任务是由指令调度器来解决的。为了能够更好的解决该问题，
指令调度器必须具有一个处理器并行的适当描述（或者说流水线描述）。
GCC机器描述使用正规表达式来描述处理器并行和对指令组的功能单元保留。

GCC指令调度器使用流水线冒险识别器通过给定的处理器时钟周期模拟来找出可能的指令问题。
流水线冒险识别器通过处理器流水线描述自动生成。
由机器描述生成的流水线冒险识别器是基于有限确定状态机（@acronym{DFA}）：
如果存在从一个自动机状态到另一状态的转换，则可以进行指令发射。
该算法非常快，而且它的速度不依赖于处理器的复杂度
@footnote{然而，自动机的大小依赖于处理器的复杂度。为了限制这种影响，
机器描述可以将机器描述的正交部分拆分成多个自动机：但是，
由于每个这样的自动机都必须独立的执行每一步，
所以这确实会在算法性能上造成一点消减。}。

@cindex automaton based pipeline description
该章节的剩余部分描述了构造一个基于自动机的处理器流水线描述的命令（directive）。
这些结构在机器描述文件中的顺序并不重要。

@findex define_automaton
@cindex pipeline hazard recognizer
下面的可选结构描述了生成的自动机的名字，并用于流水线冒险识别。
有时供流水线冒险识别器使用的生成的有限状态机会非常大。
如果我们使用多个自动机并且将功能单元绑定到自动机上，
则自动机的总的大小通常会小于单个自动机的情况。
如果没有这样一个结构，则会只生成一个有限状态机。

@smallexample
(define_automaton @var{automata-names})
@end smallexample

@var{automata-names}为一个字符串，给出了自动机的名字。
名字由逗号分隔。所有自动机应该具有唯一的名字。
自动机名用于结构@code{define_cpu_unit}和@code{define_query_cpu_unit}。

@findex define_cpu_unit
@cindex processor functional units
用于指令保留描述的每个处理器功能单元应该使用下列结构来描述。

@smallexample
(define_cpu_unit @var{unit-names} [@var{automaton-name}])
@end smallexample

@var{unit-names}为一个字符串，给出了由逗号分隔的功能单元的名字。
不要使用名字@samp{nothing}，它被保留用于其它目的。

@var{automaton-name}为一个字符串，给出了功能单元绑定的自动机名。
自动机应该在结构@code{define_automaton}中有描述。
如果有一个定义的自动机，则你应该给出@dfn{automaton-name}。

为功能单元赋予自动机，受到insn保留中对功能单元使用的限制。
最重要的constraint为：如果一个功能单元保留。
其余的constraint将在后续的结构描述中提到。

@findex define_query_cpu_unit
@cindex querying function unit reservations
下面的结构描述了CPU功能单元，类似于@code{define_cpu_unit}。
对于这样的功能单元的保留，可以被询问自动机状态。
对于给定的自动机状态，指令调度器从来不询问功能单元的保留。
所以按照规则，你不需要该结构。
该结构可以被用于将来的代码生成目的（例如，生成@acronym{VLIW} insn模板）。

@smallexample
(define_query_cpu_unit @var{unit-names} [@var{automaton-name}])
@end smallexample

@var{unit-names}为一个字符串，给出了由逗号分隔的功能单元名字。

@var{automaton-name}为一个字符串，给出了功能单元所绑定的自动机。

@findex define_insn_reservation
@cindex instruction latency time
@cindex regular expressions
@cindex data bypass
下面的结构为描述一条指令的流水线特征的主要结构。

@smallexample
(define_insn_reservation @var{insn-name} @var{default_latency}
                         @var{condition} @var{regexp})
@end smallexample

@var{default_latency}为一个数，给出了指令的延迟时间。
在旧描述和基于自动机的流水线描述中，有一个重要的不同之处。
当我们使用旧描述时，延迟时间是用于所有的依赖。
在基于自动机的流水线描述中，给定的延迟时间只用于真依赖。
反依赖的代价总为0，并且输出依赖的代价是生产者insn和消费者insn的延迟时间之差
（如果差为负数，则代价被认为为0）。
你可以通过使用目标机钩子@code{TARGET_SCHED_ADJUST_COST}（参见@ref{调度}），
来改变任何描述的缺省代价。

@var{insn-name}为一个字符串，给出了insn的内部名字。
内部名字被用于结构@code{define_bypass}和为了调试所生成的自动机描述文件。
内部名字与@code{define_insn}中的名字没有任何关系。
使用在处理器手册中描述的insn类别，是一个很好的做法。

@var{condition}定义了什么样的RTL insns由该结构描述。
你应该记住如果对于一个insn，
两个或更多不同@code{define_insn_reservation}结构的@var{condition}都为真，
则会出问题。这种情况，该insn将使用什么保留，是未定义的。
这种情况在流水线冒险识别器生成时，是不被检查的，
因为识别两个条件具有相同值是十分困难的
（特别是如果条件中包含@code{symbol_ref}）。
这在流水线识别器工作时，也不被检查，因为它将使识别器变得相当慢。

@var{regexp}为一个字符串，描述了指令对cpu的功能单元的保留。
保留通过正规表达式来描述，语法如下：

@smallexample
       regexp = regexp "," oneof
              | oneof

       oneof = oneof "|" allof
             | allof

       allof = allof "+" repeat
             | repeat

       repeat = element "*" number
              | element

       element = cpu_function_unit_name
               | reservation_name
               | result_name
               | "nothing"
               | "(" regexp ")"
@end smallexample

@itemize @bullet
@item
@samp{,}用于描述在保留中，下一周期的开始。

@item
@samp{|}用于描述在保留中，第一个正规表达式@strong{or}第二个正规表达式，
@strong{or}等等。 

@item
@samp{+}用于描述在保留中，第一个正规表达式@strong{and}第二个正规表达式，
@strong{and}等等。

@item
@samp{*}用于方便记述，其简单的表示一个正规表达式序列，
表达式随着周期前移被重复@var{number}次（参见@samp{,}）。

@item
@samp{cpu_function_unit_name}表示对命名功能单元的保留。

@item
@samp{reservation_name} --- 参见对结构@samp{define_reservation}的描述。

@item
@samp{nothing}表示没有功能单元被保留。
@end itemize

@findex define_reservation
有时，对于不同insn，具有共同部分的单元保留。
这样情况，你可以通过使用下面的结构来描述共同部分，以简化流水线描述。

@smallexample
(define_reservation @var{reservation-name} @var{regexp})
@end smallexample

@var{reservation-name}为一个字符串，给出了@var{regexp}的名字。
功能单元名和保留名属于同一命名空间。所以，保留名应该与功能单元名不同，
并且不能为预留名@samp{nothing}。

@findex define_bypass
@cindex instruction latency time
@cindex data bypass
下面的结构被用于描述对于给定的指令对，在延迟时间上的例外。也称之为bypass。

@smallexample
(define_bypass @var{number} @var{out_insn_names} @var{in_insn_names}
               [@var{guard}])
@end smallexample

@var{number}定义了给定字符串@var{out_insn_names}的指令所产生的结果，
什么时候可以由给定字符串@var{in_insn_names}的指令使用。
字符串中的指令由逗号分隔。

@var{guard}为一个可选的字符串，给出了C函数名，其定义了bypass的额外的保护条件。
该函数将两个insn作为参数。如果函数返回0，则对于该情况bypass将被忽略。
额外的guard在识别复杂的bypass时，很有必要。
例如当消费者只是一个insn @samp{store}的地址（而不是被存储的值）。

@findex exclusion_set
@findex presence_set
@findex final_presence_set
@findex absence_set
@findex final_absence_set
@cindex VLIW
@cindex RISC
下面五个结构通常用于描述@acronym{VLIW}处理器，或者更精确的说，
来描述放入@acronym{VLIW}指令槽中的小指令的位置。
它们也可以用于@acronym{RISC}处理器。

@smallexample
(exclusion_set @var{unit-names} @var{unit-names})
(presence_set @var{unit-names} @var{patterns})
(final_presence_set @var{unit-names} @var{patterns})
(absence_set @var{unit-names} @var{patterns})
(final_absence_set @var{unit-names} @var{patterns})
@end smallexample

@var{unit-names}为一个字符串，给出了由逗号分隔的功能单元的名字。

@var{patterns}为一个字符串，给出了由逗号分隔的功能单元的模式。
目前的模式，为一个单元或者由空格分隔的单元。

第一个结构(@samp{exclusion_set}) 意味着第一个字符串中的每个功能单元不能与
第二个字符串中的功能单元同时被保留，反之亦然。例如，结构可以用于描述处理器
（例如，一些SPARC处理器）具有全流水浮点功能单元，
其只可以同时执行单浮点insn或者双浮点insn。

第二个结构(@samp{presence_set}) 意味着第一个字符串中的每个功能单元不能被保留，
除非至少一种模式的功能单元其名字在第二个字符串中且被保留。这是一个不对称关系。
例如，可以用于描述@acronym{VLIW} @samp{slot1}在@samp{slot0}保留之后被保留。
我们可以使用下列结构来描述

@smallexample
(presence_set "slot1" "slot0")
@end smallexample

或者@samp{slot1}只在@samp{slot0}和功能单元@samp{b0}保留之后被保留。
这种情况下，我们可以写成

@smallexample
(presence_set "slot1" "slot0 b0")
@end smallexample

第三个结构(@samp{final_presence_set}) 类似于@samp{presence_set}。
区别在于什么时候进行检查。当指令在给定自动机状态被发射时，
其将影响所有当前和计划中的单元保留，并且自动机状态被改变。
第一个状态为源状态，第二个为结果状态。
对于@samp{presence_set}的检查是在源状态保留时进行的，
对于@samp{final_presence_set}的检查是在结果状态下进行的。
该结构可以用于描述实际上是两个连续的保留的保留。例如，如果我们使用

@smallexample
(presence_set "slot1" "slot0")
@end smallexample

下列insn将永远不会被发射（因为@samp{slot1}需要@samp{slot0}，
而@samp{slot0}在源状态是空缺的）

@smallexample
(define_reservation "insn_and_nop" "slot0 + slot1")
@end smallexample

但是如果我们使用类似的@samp{final_presence_set}其就可以被发射。

第四个结构 (@samp{absence_set}) 意味着在第一个字符串中的每个功能单元，
只有在每个名字在第二个字符串中的功能单元没有被保留时才能被保留。
这是一个不对称关系（实际上@samp{exclusion_set}与其类似，但它是对成的）。
例如，可以用于@acronym{VLIW}描述，来表示@samp{slot0}不能在@samp{slot1}或
@samp{slot2}保留后被保留。这可以描述为

@smallexample
(absence_set "slot0" "slot1, slot2")
@end smallexample

或者@samp{slot2}不能被保留，如果@samp{slot0}和单元@samp{b0}被保留，
或者@samp{slot1}和单元@samp{b1}被保留. 这种情况下，我们可以写成

@smallexample
(absence_set "slot2" "slot0 b0, slot1 b1")
@end smallexample

所有在集合（set）中提到的功能单元应属于相同的自动机。

最后一个结构(@samp{final_absence_set})类似于@samp{absence_set}，
但是检查是在结果（状态）保留时进行。参见@samp{final_presence_set}的注解。

@findex automata_option
@cindex deterministic finite state automaton
@cindex nondeterministic finite state automaton
@cindex finite state automaton minimization
你可以使用下面的结构来控制流水线冒险识别器的生成。

@smallexample
(automata_option @var{options})
@end smallexample

@var{options}为一个字符串，给出了影响生成代码的选项。目前有下列选项：

@itemize @bullet
@item
@dfn{no-minimization}不对自动机进行最小化处理。
这只在我们进行调试描述信息并且需要更加精确的查看保留状态时，才值得做。

@item
@dfn{time}意味着打印生成自动机的时间统计。

@item
@dfn{stats}意味着打印生成自动机的DFA状态，NDFA状态和arcs这样的数目统

@item
@dfn{v}意味着生成一个描述生成自动机的文件。文件具有后缀@samp{.dfa}，
并且可以用于验证和调试描述。

@item
@dfn{w}意味着对于非关键的错误使用警告来替代。

@item
@dfn{ndfa}生成非确定有限状态机。这将影响对正规表达式中操作符@samp{|}的对待。
通常对该操作符的处理是先尝试第一个，然后再第二个。
非确定状态机意味着尝试所有的选择，其中一些可以被后续的insn放弃。

@item
@dfn{progress}意味着输出一个进度条，来显示被处理的自动机目前生成了多少状态。
这在调试@acronym{DFA}描述时很有用。如果你看到太多的状态被生成，
你可以中断流水线冒险识别器的生成并尝试去弄清楚为什么会生成如此大的自动机。
@end itemize

作为一个例子，考虑一个超标量@acronym{RISC}机器，
其可以在一个周期发射三条insn（两条整数insn和一条浮点insn），
但是只能完成两条insn。为了描述，我们定义下列功能单元。

@smallexample
(define_cpu_unit "i0_pipeline, i1_pipeline, f_pipeline")
(define_cpu_unit "port0, port1")
@end smallexample

所有简单的整数insn可以在任何整数流水线中被执行，并且结果可以在两个周期获得。
简单的整数insn将被发射到第一个流水线中，除非它被保留，
否则它们将被发射到第二个流水线中。整数除和乘insn只能在第二个整数流水线中被执行，
并且它们的结果相应的在8和4个周期获得。
整数除为非流水线，即后续的整数除insn在当前的除法insn完成前不能被发射。
浮点insn为全流水的并且它们的结果在3个周期获得。
当浮点insn的结果被整数insn使用使，将会产生一个额外的周期延迟。
要描述所有这些，我们可以指定

@smallexample
(define_cpu_unit "div")

(define_insn_reservation "simple" 2 (eq_attr "type" "int")
                         "(i0_pipeline | i1_pipeline), (port0 | port1)")

(define_insn_reservation "mult" 4 (eq_attr "type" "mult")
                         "i1_pipeline, nothing*2, (port0 | port1)")

(define_insn_reservation "div" 8 (eq_attr "type" "div")
                         "i1_pipeline, div*7, div + (port0 | port1)")

(define_insn_reservation "float" 3 (eq_attr "type" "float")
                         "f_pipeline, nothing, (port0 | port1))

(define_bypass 4 "float" "simple,mult,div")
@end smallexample

为了简化描述，我们可以描述下列保留

@smallexample
(define_reservation "finish" "port0|port1")
@end smallexample

并在所有@code{define_insn_reservation}中使用，比如下面的结构

@smallexample
(define_insn_reservation "simple" 2 (eq_attr "type" "int")
                         "(i0_pipeline | i1_pipeline), finish")
@end smallexample


@end ifset
@ifset INTERNALS
@node 条件执行
@section 条件执行
@cindex conditional execution
@cindex predication

许多体系结构都提供了某种形式的条件执行，或者predicate。其特点是能够使得
指令集中的大多数指令变为无效。当指令集很大并且不完全对称时，在
@file{.md} 文件中直接描述这些形式将会变得非常冗长。一种可替代的方式
为 @code{define_cond_exec} 模板。

@findex define_cond_exec
@smallexample
(define_cond_exec
  [@var{predicate-pattern}]
  "@var{condition}"
  "@var{output-template}")
@end smallexample

@var{predicate-pattern} 为运行时执行insn所需要的必须为真的条件，并且
应该能匹配一个相关的操作符。可以使用 @code{match_operator} 来一次匹配
多个相关的操作符。任何 @code{match_operand} 操作数必须具有不超过一个
的可选项。

@var{condition} 为一个C表达式，对于生成的指令模式必须匹配为真。

@findex current_insn_predicate
@var{output-template} 为一个类似于 @code{define_insn} 输出模板
（@pxref{Output Template}）的字符串，除了不应用 @samp{*} 和 @samp{@@}
的特殊情况。这只在针对predicate的汇编文本为一个主insn的简单前缀时有用。为了
处理通用的情况，有一个全局变量 @code{current_insn_predicate}，在当前
insn被predicate时其将包含整个predicate，否则将为 @code{NULL}。

当使用 @code{define_cond_exec} 时，将会创建一个对 @code{predicable} 指
令属性的隐式引用。@pxref{Insn Attributes}。该属性并须为布尔的（即在它的
@var{list-of-values} 中具有确切的两个元素）。甚至，其必须不能使用复杂
表达式。也就是，insn中的缺省的和所有的使用都必须为一个简单常量，不能依
赖于可选项或其它。

对于每个 @code{predicable} 属性为真的 @code{define_insn}，一个新的匹配
一个指令predicate版本的 @code{define_insn} 指令模式将被生成。例如，

@smallexample
(define_insn "addsi"
  [(set (match_operand:SI 0 "register_operand" "r")
        (plus:SI (match_operand:SI 1 "register_operand" "r")
                 (match_operand:SI 2 "register_operand" "r")))]
  "@var{test1}"
  "add %2,%1,%0")

(define_cond_exec
  [(ne (match_operand:CC 0 "register_operand" "c")
       (const_int 0))]
  "@var{test2}"
  "(%0)")
@end smallexample

@noindent
生成一个新的指令模式

@smallexample
(define_insn ""
  [(cond_exec
     (ne (match_operand:CC 3 "register_operand" "c") (const_int 0))
     (set (match_operand:SI 0 "register_operand" "r")
          (plus:SI (match_operand:SI 1 "register_operand" "r")
                   (match_operand:SI 2 "register_operand" "r"))))]
  "(@var{test2}) && (@var{test1})"
  "(%3) add %2,%1,%0")
@end smallexample

@end ifset
@ifset INTERNALS
@node 常量定义
@section 常量定义
@cindex constant definitions
@findex define_constants

在指令模板中使用文字常量会减小可读性并会成为一个维护问题。

要克服该问题，你可以使用 @code{define_constants} 表达式。它包含了一个
“名字-值”成对向量。从定义处开始，任何出现在MD文件中的那些名字，都作为
相应的值被替换。你可以多次使用 @code{define_constants}；每次都为表格中
增加更多的常量。使用不同的值来重新定义一个常量将会产生一个错误。

回到a29k加载乘的例子，对于

@smallexample
(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI 179))
      (clobber (reg:SI 179))])]
  ""
  "loadm 0,0,%1,%2")
@end smallexample

你可以写成:

@smallexample
(define_constants [
    (R_BP 177)
    (R_FC 178)
    (R_CR 179)
    (R_Q  180)
])

(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI R_CR))
      (clobber (reg:SI R_CR))])]
  ""
  "loadm 0,0,%1,%2")
@end smallexample

使用define_constants定义的常量也在insn-codes.h头文件中作为#defines被输出。
@end ifset
@ifset INTERNALS
@node 迭代器
@section 迭代器
@cindex iterators in @file{.md} files

后端（Ports）常常需要为多个机器模式或者多个rtx代码定义类似的指令模式。
GCC提供了一些简单的迭代机制使得该处理变的很容易。

@menu
* 机器模式迭代器::     为不同的机器模式生成指令模式的变种
* 代码迭代器::         为代码做同样的事
@end menu

@node 机器模式迭代器
@subsection 机器模式迭代器
@cindex mode iterators in @file{.md} files

后端（Ports）经常需要为两个或多个不同机器模式定义类似的指令模式。例如：

@itemize @bullet
@item
如果一个处理器对单浮点和双浮点算术都具有硬件支持，则 @code{SFmode} 的
指令模式将会与 @code{DFmode} 的非常类似。

@item
如果一个后端（port）在一个配置中使用 @code{SImode} 的指针，而在另一个
配置中使用 @code{DImode} 的指针，则通常会具有非常类似的操作指针的
@code{SImode} 和 @code{DImode} 的指令模式。
@end itemize

机器模式迭代器允许从一个 @file{.md} 文件模板实例化多个指令模式。它们
可以用于任何类型的基于rtx的结构，例如 @code{define_insn}, 
@code{define_split} 或 @code{define_peephole2}。

@menu
* 定义机器模式迭代器:: 定义一个新的机器模式迭代器
* 替换::               使用替换来合成机器模式迭代器
* 有关机器模式迭代器的例子::               例子
@end menu

@node 定义机器模式迭代器
@subsubsection 定义机器模式迭代器
@findex define_mode_iterator

定义一个机器模式迭代器的语法为：

@smallexample
(define_mode_iterator @var{name} [(@var{mode1} "@var{cond1}") @dots{} (@var{moden} "@var{condn}")])
@end smallexample

这将允许后续的 @file{.md} 文件结构可以使用机器模式suffix 
@code{:@var{name}}。每个这样的结构将被扩展 @var{n} 次，一次使用
@code{:@var{mode1}} 来替换，一次使用 @code{:@var{mode2}} 来替换，等等。
在扩展 @var{modei} 时，每个C条件 @var{condi} 还要为真。

例如：

@smallexample
(define_mode_iterator P [(SI "Pmode == SImode") (DI "Pmode == DImode")])
@end smallexample

定义了一个新的机器模式后缀 @code{:P}。每个使用 @code{:P} 的结构将被扩展
两次，一次由 @code{:SI} 来替换 @code{:P}，一次由 @code{:DI} 来替换
@code{:P}。其中 @code{:SI} 版本的只有当 @code{Pmode == SImode} 时才被应
用，@code{:DI} 版本的只有当 @code{Pmode == DImode} 时才被应用。

就像其它 @file{.md} 条件，一个空字符串被当作“总为真”。@code{(@var{mode} "")}
也可以被缩写为 @code{@var{mode}}。例如：

@smallexample
(define_mode_iterator GPR [SI (DI "TARGET_64BIT")])
@end smallexample

意味着 @code{:DI} 扩展只有为 @code{TARGET_64BIT} 时被应用，但 @code{:SI} 
扩展却没有这样的限制。

迭代器按照它们定义的顺序被应用。这在当两个迭代器用于一个结构中需要替换时
会变的很重要。@pxref{Substitutions}。

@node 替换
@subsubsection 机器模式迭代器中的替换
@findex define_mode_attr
如果一个 @file{.md} 文件结构使用了机器模式迭代器，则结构的每个版本将通常
需要轻微不同的字符串或机器模式。例如：

@itemize @bullet
@item
当一个 @code{define_expand} 定义了多个 @code{add@var{m}3} 指令模式时
（@pxref{Standard Names}），每个扩展将需要针对 @var{m} 的适当的机器模式。

@item
当一个 @code{define_insn} 定义了多个指令模式时，每条指令将通常需要一个不
同的汇编助记符。

@item
当一个 @code{define_insn} 需要操作数具有不同的机器模式时，针对一个操作数
的机器模式使用迭代器通常需要对于其它操作数使用特点的机器模式。
@end itemize

GCC通过“机器模式属性”系统来支持这样的变种。有两种标准属性：@code{mode}，
其为机器模式的小写名字，@code{MODE}，其为机器模式的大写名字。你可以定义其
它属性，使用：

@smallexample
(define_mode_attr @var{name} [(@var{mode1} "@var{value1}") @dots{} (@var{moden} "@var{valuen}")])
@end smallexample

其中 @var{name} 为属性的名字，@var{valuei} 为与 @var{modei} 关联的值。

当GCC使用 @var{:mode} 来替换某个 @var{:iterator} 时，其将扫描指令模式中的
每个字符串和机器模式，按照 @code{<@var{iterator}:@var{attr}>}形式的序列，
其中@var{attr}为一个机器模式属性的名字。如果属性针对mode被定义，则整个
@code{<@dots{}>} 序列将被适当的属性值替换。

例如，假设一个 @file{.md} 具有：

@smallexample
(define_mode_iterator P [(SI "Pmode == SImode") (DI "Pmode == DImode")])
(define_mode_attr load [(SI "lw") (DI "ld")])
@end smallexample

如果其中一个使用 @code{:P} 的指令模式包含了字符串
@code{"<P:load>\t%0,%1"}，则 @code{SI} 版本的指令模式将使用
@code{"lw\t%0,%1"} 并且 @code{DI} 版本的将使用
@code{"ld\t%0,%1"}。

这里有一个关于使用针对一个机器模式的属性的例子：

@smallexample
(define_mode_iterator LONG [SI DI])
(define_mode_attr SHORT [(SI "HI") (DI "SI")])
(define_insn @dots{}
  (sign_extend:LONG (match_operand:<LONG:SHORT> @dots{})) @dots{})
@end smallexample

@code{@var{iterator}:} 前缀可以被省略掉，这种情况下将会针对每个迭代器扩展来
尝试替换。

@node 有关机器模式迭代器的例子
@subsubsection 有关机器模式迭代器的例子

这里有一个来自MIPS后端的一个例子。其定义了下列机器模式和属性（除了别的以外）：

@smallexample
(define_mode_iterator GPR [SI (DI "TARGET_64BIT")])
(define_mode_attr d [(SI "") (DI "d")])
@end smallexample

并且使用下列模板来同时定义 @code{subsi3} 和 @code{subdi3}：

@smallexample
(define_insn "sub<mode>3"
  [(set (match_operand:GPR 0 "register_operand" "=d")
        (minus:GPR (match_operand:GPR 1 "register_operand" "d")
                   (match_operand:GPR 2 "register_operand" "d")))]
  ""
  "<d>subu\t%0,%1,%2"
  [(set_attr "type" "arith")
   (set_attr "mode" "<MODE>")])
@end smallexample

这就完全等价于：

@smallexample
(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (minus:SI (match_operand:SI 1 "register_operand" "d")
                  (match_operand:SI 2 "register_operand" "d")))]
  ""
  "subu\t%0,%1,%2"
  [(set_attr "type" "arith")
   (set_attr "mode" "SI")])

(define_insn "subdi3"
  [(set (match_operand:DI 0 "register_operand" "=d")
        (minus:DI (match_operand:DI 1 "register_operand" "d")
                  (match_operand:DI 2 "register_operand" "d")))]
  ""
  "dsubu\t%0,%1,%2"
  [(set_attr "type" "arith")
   (set_attr "mode" "DI")])
@end smallexample

@node 代码迭代器
@subsection 代码迭代器
@cindex code iterators in @file{.md} files
@findex define_code_iterator
@findex define_code_attr

代码迭代器使用与机器模式迭代器类似的方法来操作。@pxref{Mode Iterators}。

结构：

@smallexample
(define_code_iterator @var{name} [(@var{code1} "@var{cond1}") @dots{} (@var{coden} "@var{condn}")])
@end smallexample

定义了一个伪rtx代码 @var{name}，如果条件 @var{condi} 为真时，其可以作为
@var{codei} 被实例化。每个 @var{codei} 必须具有相同的rtx格式。
@pxref{RTL类别}。

跟机器模式迭代器一样，每个使用 @var{name} 的指令模式将被扩展 @var{n} 次，
一次使用 @var{code1} 来替换，一次使用 @var{code2}，等等。
@pxref{Defining Mode Iterators}。

跟机器模式一样可以为代码定义属性。有两种标准代码属性：@code{code}，代码
的小写形式名字，以及 @code{CODE}，代码的大写形式名字。其它属性使用下列
方式来定义：

@smallexample
(define_code_attr @var{name} [(@var{code1} "@var{value1}") @dots{} (@var{coden} "@var{valuen}")])
@end smallexample

这里有一个实际使用的关于代码迭代器的例子，摘自MIPS后端（port）：

@smallexample
(define_code_iterator any_cond [unordered ordered unlt unge uneq ltgt unle ungt
                                eq ne gt ge lt le gtu geu ltu leu])

(define_expand "b<code>"
  [(set (pc)
        (if_then_else (any_cond:CC (cc0)
                                   (const_int 0))
                      (label_ref (match_operand 0 ""))
                      (pc)))]
  ""
@{
  gen_conditional_branch (operands, <CODE>);
  DONE;
@})
@end smallexample

这等价于：

@smallexample
(define_expand "bunordered"
  [(set (pc)
        (if_then_else (unordered:CC (cc0)
                                    (const_int 0))
                      (label_ref (match_operand 0 ""))
                      (pc)))]
  ""
@{
  gen_conditional_branch (operands, UNORDERED);
  DONE;
@})

(define_expand "bordered"
  [(set (pc)
        (if_then_else (ordered:CC (cc0)
                                  (const_int 0))
                      (label_ref (match_operand 0 ""))
                      (pc)))]
  ""
@{
  gen_conditional_branch (operands, ORDERED);
  DONE;
@})

@dots{}
@end smallexample

@end ifset
