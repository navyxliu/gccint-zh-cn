@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001,
@c 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@ifset INTERNALS
@en @node Machine Desc
@en @chapter Machine Descriptions
@node Machine Desc
@chapter 机器描述
@cindex machine descriptions

@en A machine description has two parts: a file of instruction patterns
@en (@file{.md} file) and a C header file of macro definitions.
机器描述包括两个部分：指令模式文件（@file{.md} file）和宏定义C头文件。

@en The @file{.md} file for a target machine contains a pattern for each
@en instruction that the target machine supports (or at least each instruction
@en that is worth telling the compiler about).  It may also contain comments.
@en A semicolon causes the rest of the line to be a comment, unless the semicolon
@en is inside a quoted string.
目标机器的@file{.md}文件包含了目标机器支持的（或者最起码值得告诉编译器的）每条指令的模式。其还可以包含注释。分号使得一行的剩余部分成为注释，引号标注的字符串中的分号除外。

@en See the next chapter for information on the C header file.
关于C头文件的信息，参见下一章。

@en @menu
@en * Overview::            How the machine description is used.
@en * Patterns::            How to write instruction patterns.
@en * Example::             An explained example of a @code{define_insn} pattern.
@en * RTL Template::        The RTL template defines what insns match a pattern.
@en * Output Template::     The output template says how to make assembler code
@en                         from such an insn.
@en * Output Statement::    For more generality, write C code to output
@en                         the assembler code.
@en * Predicates::          Controlling what kinds of operands can be used
@en                         for an insn.
@en * Constraints::         Fine-tuning operand selection.
@en * Standard Names::      Names mark patterns to use for code generation.
@en * Pattern Ordering::    When the order of patterns makes a difference.
@en * Dependent Patterns::  Having one pattern may make you need another.
@en * Jump Patterns::       Special considerations for patterns for jump insns.
@en * Looping Patterns::    How to define patterns for special looping insns.
@en * Insn Canonicalizations::Canonicalization of Instructions
@en * Expander Definitions::Generating a sequence of several RTL insns
@en                         for a standard operation.
@en * Insn Splitting::      Splitting Instructions into Multiple Instructions.
@en * Including Patterns::  Including Patterns in Machine Descriptions.
@en * Peephole Definitions::Defining machine-specific peephole optimizations.
@en * Insn Attributes::     Specifying the value of attributes for generated insns.
@en * Conditional Execution::Generating @code{define_insn} patterns for
@en                          predication.
@en * Constant Definitions::Defining symbolic constants that can be used in the
@en                         md file.
@en * Iterators::           Using iterators to generate patterns from a template.
@en @end menu

@menu
* Overview::			如何使用机器描述。
* Patterns::			如何写指令模式。
* Example::			一个@code{define_insn}模式的例子说明。
* RTL Template::		RTL模板定义了什么样的insn与一个模式匹配。
* Output Template::		输出模板说明了如何从这样一个insn来生成汇编代码。
* Output Statement::		更一般的情况, 编写C代码来输出汇编代码。
* Predicates::			控制一个insn可以使用什么类型的操作数。
* Constraints::			对操作数的选择进行微调。
* Standard Names::		代码生成时使用的模式名字。
* Pattern Ordering::		不同模式顺序所产生的作用。
* Dependent Patterns::		拥有一个指令模式，可能还会需要另一个。
* Jump Patterns::		针对跳转insn的指令模式的特殊考虑。
* Looping Patterns::		如何为特定的循环insn定义模式。
* Insn Canonicalizations::	指令的规范化。
* Expander Definitions::	为一个标准操作生成一个RTL insn序列。
* Insn Splitting::		拆分指令为多条指令。
* Including Patterns::		在机器描述中包含模式。
* Peephole Definitions::	定义机器特定的窥孔优化。
* Insn Attributes::		为生成的insn指定属性值。
* Conditional Execution::	为断言（predication）生成@code{define_insn}模式。
* Constant Definitions::	定义可以用在md文件中的符号常量。
* Iterators::			使用迭代器从模板中生成模式。
@end menu

@en @node Overview
@en @section Overview of How the Machine Description is Used
@node Overview
@section 概述机器描述是如何被使用的

@en There are three main conversions that happen in the compiler:
编译器中有三个主要的转换：

@enumerate

@item
@en The front end reads the source code and builds a parse tree.
前端读取源代码并建立解析树。

@item
@en The parse tree is used to generate an RTL insn list based on named
@en instruction patterns.
基于命名的指令模式，解析树被用来生成RTL insn列表。

@item
@en The insn list is matched against the RTL templates to produce assembler
@en code.
insn列表被用来匹配RTL模板，产生汇编代码。

@end enumerate

@en For the generate pass, only the names of the insns matter, from either a
@en named @code{define_insn} or a @code{define_expand}.  The compiler will
@en choose the pattern with the right name and apply the operands according
@en to the documentation later in this chapter, without regard for the RTL
@en template or operand constraints.  Note that the names the compiler looks
@en for are hard-coded in the compiler---it will ignore unnamed patterns and
@en patterns with names it doesn't know about, but if you don't provide a
@en named pattern it needs, it will abort.
在生成RTL insn列表的pass中，只与命名@code{define_insn}或者@code{define_expand}的insn名字有关系。编译器会选择恰当名字的模式，并且根据这章后面的介绍来应用操作数，而不需要关心RTL模板或者操作数约束（constraint）。注意，编译器所寻找的名字是被硬编码进编译器中的——它将忽略未命名的模式和名字无法识别的模式，但是，如果你没有提供编译器所需要的命名模式，它将会异常退出（abort）。

@en If a @code{define_insn} is used, the template given is inserted into the
@en insn list.  If a @code{define_expand} is used, one of three things
@en happens, based on the condition logic.  The condition logic may manually
@en create new insns for the insn list, say via @code{emit_insn()}, and
@en invoke @code{DONE}.  For certain named patterns, it may invoke @code{FAIL} to tell the
@en compiler to use an alternate way of performing that task.  If it invokes
@en neither @code{DONE} nor @code{FAIL}, the template given in the pattern
@en is inserted, as if the @code{define_expand} were a @code{define_insn}.
如果是使用的@code{define_insn}，则给定的模版将会被插入到insn列表中。如果是使用的@code{define_expand}，则根据条件逻辑，将会有三种情况会发生。条件逻辑可以手动为insn列表创建一个新的insn，比如通过@code{emit_insn()}，并且调用@code{DONE}。对于某些命名模式，它可以调用@code{FAIL}来告诉编译器使用一种替代方式完成任务。如果既没有调用DONE也没有调用@code{FAIL}，则在模式中所给出的模版将会被插入到insn列表中，就像@code{define_insn}一样。

@en Once the insn list is generated, various optimization passes convert,
@en replace, and rearrange the insns in the insn list.  This is where the
@en @code{define_split} and @code{define_peephole} patterns get used, for
@en example.
一旦生成了insn列表，则各种优化pass便在insn列表中进行转换，替代和重排insn。例如，@code{define_split}和@code{define_peephole}模式便是在这些地方被使用。

@en Finally, the insn list's RTL is matched up with the RTL templates in the
@en @code{define_insn} patterns, and those patterns are used to emit the
@en final assembly code.  For this purpose, each named @code{define_insn}
@en acts like it's unnamed, since the names are ignored.
最后，insn列表的RTL被用来匹配@code{define_insn}模式中的RTL模版，并且那些模式被用来生成最终的汇编代码。这时，由于不需要关心名字，所以每个命名的@code{define_insn}跟没有命名的没有区别。

@en @node Patterns
@en @section Everything about Instruction Patterns
@node Patterns
@section 指令模式的方方面面
@cindex patterns
@cindex instruction patterns

@findex define_insn
@en Each instruction pattern contains an incomplete RTL expression, with pieces
@en to be filled in later, operand constraints that restrict how the pieces can
@en be filled in, and an output pattern or C code to generate the assembler
@en output, all wrapped up in a @code{define_insn} expression.
每个指令模式包含了一个不完全的RTL表达式和之后要被填充的部分；操作数约束，用来限制如何填充那些部分；以及一个输出模式或者C代码，用来生成汇编输出。所有这些都由一个@code{define_insn}表达式包裹起来。

@en A @code{define_insn} is an RTL expression containing four or five operands:
@code{define_insn}是一个RTL表达式，包含了四至五个操作数：

@enumerate
@item
@en An optional name.  The presence of a name indicate that this instruction
@en pattern can perform a certain standard job for the RTL-generation
@en pass of the compiler.  This pass knows certain names and will use
@en the instruction patterns with those names, if the names are defined
@en in the machine description.
一个可选的名字。如果存在名字，则表明该指令模式能够在编译器的RTL生成pass中，执行一个特定的标准工作。这个pass知道特定的名字，并且如果在机器描述中定义了这些名字，则会使用它们的指令模式。

@en The absence of a name is indicated by writing an empty string
@en where the name should go.  Nameless instruction patterns are never
@en used for generating RTL code, but they may permit several simpler insns
@en to be combined later on.
可以使用空字符串来表示不存在名字。没有命名的指令模式是不会被用来生成RTL代码的，但是它们可以在后面用来将多个简单的insn合并起来。
 
@en Names that are not thus known and used in RTL-generation have no
@en effect; they are equivalent to no name at all.
不被识别的名字，则在RTL生成pass中不起作用；就像没有命名一样。
 
@en For the purpose of debugging the compiler, you may also specify a
@en name beginning with the @samp{*} character.  Such a name is used only
@en for identifying the instruction in RTL dumps; it is entirely equivalent
@en to having a nameless pattern for all other purposes.
出于调试编译器的目的，你还可以指定一个名字起始于@samp{*}字符。这样的名字只被用来标识RTL dump中的指令，其它的都与没有命名的模式一样。

@item
@en The @dfn{RTL template} (@pxref{RTL Template}) is a vector of incomplete
@en RTL expressions which show what the instruction should look like.  It is
@en incomplete because it may contain @code{match_operand},
@en @code{match_operator}, and @code{match_dup} expressions that stand for
@en operands of the instruction.
@dfn{RTL template}（@pxref{RTL Template}）是一个不完全的RTL表达式向量，展现了这条指令的样子。所谓不完全是因为它可以包含@code{match_operand}, @code{match_operator}和@code{match_dup}表达式，用来表示指令的操作数。

@en If the vector has only one element, that element is the template for the
@en instruction pattern.  If the vector has multiple elements, then the
@en instruction pattern is a @code{parallel} expression containing the
@en elements described.
如果向量只有一个元素，则那个元素为指令模式的模版。如果向量有多个元素，则指令模式是一个@code{parallel}表达式，包含了所描述的元素。

@item
@cindex pattern conditions
@cindex conditions, in patterns
@en A condition.  This is a string which contains a C expression that is
@en the final test to decide whether an insn body matches this pattern.
一个条件。这是一个字符串，包含了一个C表达式用于最后的测试，来判定一个insn实体是否匹配该模式。

@cindex named patterns and conditions
@en For a named pattern, the condition (if present) may not depend on
@en the data in the insn being matched, but only the target-machine-type
@en flags.  The compiler needs to test these conditions during
@en initialization in order to learn exactly which named instructions are
@en available in a particular run.
对于命名模式，条件（如果存在）可以不依赖要被匹配的insn的数据，而只是取决于目标-机器-类型标记（target-machine-type flag）。编译器需要在初始化时测试这些条件，以便能够确切的知道在这一次运行中，哪些命名指令是可用的。

@findex operands
@en For nameless patterns, the condition is applied only when matching an
@en individual insn, and only after the insn has matched the pattern's
@en recognition template.  The insn's operands may be found in the vector
@en @code{operands}.  For an insn where the condition has once matched, it
@en can't be used to control register allocation, for example by excluding
@en certain hard registers or hard register combinations.
对于没有命名的模式，只有在匹配单个insn，并且该insn已经匹配了模式的识别模版之后，条件才被使用。insn的操作数可以在向量@code{operands}中找到。对于条件匹配的insn，条件不能被用来控制寄存器分配，例如用来排除特定的硬件寄存器，或者硬件寄存器组合。 

@item
@en The @dfn{output template}: a string that says how to output matching
@en insns as assembler code.  @samp{%} in this string specifies where
@en to substitute the value of an operand.  @xref{Output Template}.
@dfn{output template}：一个字符串，说明了如何将匹配的insn输出为汇编代码。字符串中的@samp{%}指定了替换操作数的值的地方。@pxref{Output Template}。
 
@en When simple substitution isn't general enough, you can specify a piece
@en of C code to compute the output.  @xref{Output Statement}.
当简单替换无法满足需求的时候，你可以指定一块C代码来计算输出。@xref{Output Statement}。

@item
@en Optionally, a vector containing the values of attributes for insns matching
@en this pattern.  @xref{Insn Attributes}.
一个可选的向量，包含了匹配该模式的insn属性值。@xref{Insn Attributes}。
@end enumerate

@en @node Example
@en @section Example of @code{define_insn}
@node Example
@section 有关@code{define_insn}的例子
@cindex @code{define_insn} example

@en Here is an actual example of an instruction pattern, for the 68000/68020.
这里有个68000/68020的实际的指令模式例子。

@smallexample
(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "general_operand" "rm"))]
  ""
  "*
@{
  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
    return \"tstl %0\";
  return \"cmpl #0,%0\";
@}")
@end smallexample

@noindent
@en This can also be written using braced strings:
还可以写成如下形式：

@smallexample
(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "general_operand" "rm"))]
  ""
@{
  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
    return "tstl %0";
  return "cmpl #0,%0";
@})
@end smallexample

@en This is an instruction that sets the condition codes based on the value of
@en a general operand.  It has no condition, so any insn whose RTL description
@en has the form shown may be handled according to this pattern.  The name
@en @samp{tstsi} means ``test a @code{SImode} value'' and tells the RTL generation
@en pass that, when it is necessary to test such a value, an insn to do so
@en can be constructed using this pattern.
这是一条根据通用操作数来设置条件代码的指令。这个模式不需要条件（条件为空字符串），所以任何insn，如果RTL描述具有如上形式，则可以根据这个模式来处理。名字@samp{tstsi}表示“test a @code{SImode} value”，并且告诉RTL生成pass，当其需要测试这样的值时，可以使用这个模式来构造一条指令。

@en The output control string is a piece of C code which chooses which
@en output template to return based on the kind of operand and the specific
@en type of CPU for which code is being generated.
输出控制字符串是一部分C代码，用来根据操作数的类别和CPU的特定类型选择输出模版，生成代码。

@en @samp{"rm"} is an operand constraint.  Its meaning is explained below.
@samp{"rm"}是一个操作数约束。后面将会解释它的含义。

@en @node RTL Template
@en @section RTL Template
@node RTL Template
@section RTL模板
@cindex RTL insn template
@cindex generating insns
@cindex insns, generating
@cindex recognizing insns
@cindex insns, recognizing

@en The RTL template is used to define which insns match the particular pattern
@en and how to find their operands.  For named patterns, the RTL template also
@en says how to construct an insn from specified operands.
RTL模板用来定义哪些insn匹配特定的模式，以及如何找到它们的操作数。对于命名的模式，RTL模板还说明了如何根据特定的操作数来构建一个insn。

@en Construction involves substituting specified operands into a copy of the
@en template.  Matching involves determining the values that serve as the
@en operands in the insn being matched.  Both of these activities are
@en controlled by special expression types that direct matching and
@en substitution of the operands.
构建insn涉及到替换指定操作数到模板。匹配insn涉及到测定被匹配insn的操作数值。这些匹配和替换操作数的行为都是由专门的表达式类型来控制。

@table @code
@findex match_operand
@item (match_operand:@var{m} @var{n} @var{predicate} @var{constraint})
@en This expression is a placeholder for operand number @var{n} of
@en the insn.  When constructing an insn, operand number @var{n}
@en will be substituted at this point.  When matching an insn, whatever
@en appears at this position in the insn will be taken as operand
@en number @var{n}; but it must satisfy @var{predicate} or this instruction
@en pattern will not match at all.
该表达式用来代表insn中的第@var{n}个操作数。当构建insn时，操作数编号@var{n}将在此处被替换。当匹配insn时，凡是在insn中该位置出现的将被当作操作数编号@var{n}；但是其必须满足@var{predicate}，否则该指令模式将根本不匹配

@en Operand numbers must be chosen consecutively counting from zero in
@en each instruction pattern.  There may be only one @code{match_operand}
@en expression in the pattern for each operand number.  Usually operands
@en are numbered in the order of appearance in @code{match_operand}
@en expressions.  In the case of a @code{define_expand}, any operand numbers
@en used only in @code{match_dup} expressions have higher values than all
@en other operand numbers.
每个指令模式中的操作数编号必须从0开始连续的选择。在指令模式中，可以对每个操作数编号只用一个@code{match_operand}表达式。 通常操作数按照在@code{match_operand}表达式中出现的顺序被编号。对于@code{define_expand}，所有只在@code{match_dup}表达式中才用到的操作数编号，会具有比其它操作数编号更高的值。

@en @var{predicate} is a string that is the name of a function that
@en accepts two arguments, an expression and a machine mode.
@en @xref{Predicates}.  During matching, the function will be called with
@en the putative operand as the expression and @var{m} as the mode
@en argument (if @var{m} is not specified, @code{VOIDmode} will be used,
@en which normally causes @var{predicate} to accept any mode).  If it
@en returns zero, this instruction pattern fails to match.
@en @var{predicate} may be an empty string; then it means no test is to be
@en done on the operand, so anything which occurs in this position is
@en valid.
@var{predicate}为一个字符串，是一个函数的名字，其接受两个参数，一个表达式和一个机器模式。@xref{Predicates}。在匹配过程中，函数将会被调用，使用假定的操作数作为表达式并且@var{m}作为机器模式参数（如果@var{m}没有被指定，则使用@code{VOIDmode}，这通常会使得@var{predicate}可以接受任何机器模式）。如果其返回0，则该指令模式匹配失败。@var{predicate}可以为一个空字符串；这意味着不对操作数作测试，这样出现在该位置的任何操作数都是有效的。

@en Most of the time, @var{predicate} will reject modes other than @var{m}---but
@en not always.  For example, the predicate @code{address_operand} uses
@en @var{m} as the mode of memory ref that the address should be valid for.
@en Many predicates accept @code{const_int} nodes even though their mode is
@en @code{VOIDmode}.
大多时候，@var{predicate}将会拒绝@var{m}之外的机器模式——但并不总是这样。例如，断言@code{address_operand}使用@var{m}作为内存引用中有效地址的机器模式，而许多断言会接受@code{const_int}节点，即使它们的机器模式为@code{VOIDmode}。

@en @var{constraint} controls reloading and the choice of the best register
@en class to use for a value, as explained later (@pxref{Constraints}).
@en If the constraint would be an empty string, it can be omitted.
@var{constraint}用来控制reloading，以及将在后面讲到的，如何针对一个值选择使用最好的寄存器类别（@pxref{Constraints}）。如果约束为空字符串，则可以忽略掉。

@en People are often unclear on the difference between the constraint and the
@en predicate.  The predicate helps decide whether a given insn matches the
@en pattern.  The constraint plays no role in this decision; instead, it
@en controls various decisions in the case of an insn which does match.
人们经常弄不清楚约束（constraint）和断言（predicate）的区别。断言用来帮助判定一个给定的insn是否匹配指令模式。约束在该决策中并不发挥作用，而是用来控制对于已经匹配的insn，进行的各种决策。

@findex match_scratch
@item (match_scratch:@var{m} @var{n} @var{constraint})
@en This expression is also a placeholder for operand number @var{n}
@en and indicates that operand must be a @code{scratch} or @code{reg}
@en expression.
该表达式也是操作数编号@var{n}的占位符，并且指示操作数必须为一个@code{scratch}或者@code{reg}表达式。

@en When matching patterns, this is equivalent to
当在匹配指令模式时，其相当于

@smallexample
(match_operand:@var{m} @var{n} "scratch_operand" @var{pred})
@end smallexample

@en but, when generating RTL, it produces a (@code{scratch}:@var{m})
@en expression.
但是，当在生成RTL时，其产生一个(@code{scratch}:@var{m})表达式。

@en If the last few expressions in a @code{parallel} are @code{clobber}
@en expressions whose operands are either a hard register or
@en @code{match_scratch}, the combiner can add or delete them when
@en necessary.  @xref{Side Effects}.
如果在一个@code{parallel}中的最后几个表达式为@code{clobber}表达式，其操作数为一个硬寄存器或者@code{match_scratch}，则组合器可以在需要的时候增加或删除它们。@xref{Side Effects}。

@findex match_dup
@item (match_dup @var{n})
@en This expression is also a placeholder for operand number @var{n}.
@en It is used when the operand needs to appear more than once in the
@en insn.
该表达式也为操作数编号@var{n}的占位符。其用于当操作数需要在insn中出现多次的情况。 

@en In construction, @code{match_dup} acts just like @code{match_operand}:
@en the operand is substituted into the insn being constructed.  But in
@en matching, @code{match_dup} behaves differently.  It assumes that operand
@en number @var{n} has already been determined by a @code{match_operand}
@en appearing earlier in the recognition template, and it matches only an
@en identical-looking expression.
在构建过程中，@code{match_dup}的作用就跟@code{match_operand}一样。操作数被替换到正在被构建的insn中。但是在匹配时，@code{match_dup}的行为就有所不同了。其假设操作数编号@var{n}已经由在识别模板中之前出现的@code{match_operand}确定了，其只匹配相同的表达式。

@en Note that @code{match_dup} should not be used to tell the compiler that
@en a particular register is being used for two operands (example:
@en @code{add} that adds one register to another; the second register is
@en both an input operand and the output operand).  Use a matching
@en constraint (@pxref{Simple Constraints}) for those.  @code{match_dup} is for the cases where one
@en operand is used in two places in the template, such as an instruction
@en that computes both a quotient and a remainder, where the opcode takes
@en two input operands but the RTL template has to refer to each of those
@en twice; once for the quotient pattern and once for the remainder pattern.
注意@code{match_dup}不要用来告诉编译器特定寄存器被用于两个操作数（例如：@code{add}将一个寄存器加到另一个之上；第二个寄存器即为输入操作数，同样也为输出操作数）。可以为此使用匹配constraint（@pxref{Simple Constraints}）。@code{match_dup}是用于一个操作数在模板中的两个地方被使用的情况，例如一条指令同时计算商和余数，其中操作码接受两个输入操作数，但是RTL模板不得不引用它们两次；一次用于求商指令模式，一次用于求余数指令模式。

@findex match_operator
@item (match_operator:@var{m} @var{n} @var{predicate} [@var{operands}@dots{}])
@en This pattern is a kind of placeholder for a variable RTL expression
@en code.
该指令模式为一个可变RTL表达式代码的一种占位符。

@en When constructing an insn, it stands for an RTL expression whose
@en expression code is taken from that of operand @var{n}, and whose
@en operands are constructed from the patterns @var{operands}.
当构造一个insn时，其代表RTL表达式，其表达式代码取自操作数@var{n}，并且其操作数从指令模式@var{operands}中构造。

@en When matching an expression, it matches an expression if the function
@en @var{predicate} returns nonzero on that expression @emph{and} the
@en patterns @var{operands} match the operands of the expression.
当匹配一个表达式时，其匹配一个表达式，如果函数@var{predicate}对于该表达式返回非零，@emph{并且}指令模式@var{operands}匹配表达式的操作数。

@en Suppose that the function @code{commutative_operator} is defined as
@en follows, to match any expression whose operator is one of the
@en commutative arithmetic operators of RTL and whose mode is @var{mode}:
假设函数@code{commutative_operator}被如下定义，来匹配任何表达式，其操作符为RTL中可交换的算术操作符，并且其机器模式为@var{mode}：

@smallexample
int
commutative_integer_operator (x, mode)
     rtx x;
     enum machine_mode mode;
@{
  enum rtx_code code = GET_CODE (x);
  if (GET_MODE (x) != mode)
    return 0;
  return (GET_RTX_CLASS (code) == RTX_COMM_ARITH
          || code == EQ || code == NE);
@}
@end smallexample

@en Then the following pattern will match any RTL expression consisting
@en of a commutative operator applied to two general operands:
那么下列指令模式将匹配任何RTL表达式，其由一个可交换操作符和两个通用操作数组成：

@smallexample
(match_operator:SI 3 "commutative_operator"
  [(match_operand:SI 1 "general_operand" "g")
   (match_operand:SI 2 "general_operand" "g")])
@end smallexample

@en Here the vector @code{[@var{operands}@dots{}]} contains two patterns
@en because the expressions to be matched all contain two operands.
这里的向量@code{[@var{operands}@dots{}]}包含了两个指令模式，因为要匹配的表达式都是包含两个操作数。

@en When this pattern does match, the two operands of the commutative
@en operator are recorded as operands 1 and 2 of the insn.  (This is done
@en by the two instances of @code{match_operand}.)  Operand 3 of the insn
@en will be the entire commutative expression: use @code{GET_CODE
@en (operands[3])} to see which commutative operator was used.
当该指令模式确实匹配时，可交换操作符的两个操作数被记录为insn的操作数1和2。（这由@code{match_operand}的两个实例完成）。insn的操作数3将为整个可交换表达式：使用@code{GET_CODE (operands[3])}来查看使用了哪个可交换操作符。

@en The machine mode @var{m} of @code{match_operator} works like that of
@en @code{match_operand}: it is passed as the second argument to the
@en predicate function, and that function is solely responsible for
@en deciding whether the expression to be matched ``has'' that mode.
@code{match_operator}的机器模式@var{m}的作用与@code{match_operand}的类似：其被作为第二个参数传递给predicate函数，并且函数专门负责决定被匹配的表达式是否具有那个机器模式。

@en When constructing an insn, argument 3 of the gen-function will specify
@en the operation (i.e.@: the expression code) for the expression to be
@en made.  It should be an RTL expression, whose expression code is copied
@en into a new expression whose operands are arguments 1 and 2 of the
@en gen-function.  The subexpressions of argument 3 are not used;
@en only its expression code matters.
当构造insn时，gen-function 的参数3将会指定要构造的表达式的操作（即，表达式代码）。其应该为一个RTL表达式，其表达式代码被复制到一个新的表达式中，新表达式的操作数为 gen-function的参数1和2。参数3的子表达式不被使用；只与它的表达式代码有关。

@en When @code{match_operator} is used in a pattern for matching an insn,
@en it usually best if the operand number of the @code{match_operator}
@en is higher than that of the actual operands of the insn.  This improves
@en register allocation because the register allocator often looks at
@en operands 1 and 2 of insns to see if it can do register tying.
当@code{match_operator}被用于指令模式中来匹配insn时，通常最好让@code{match_operator}的操作数编号高于insn的实际操作数。这将提高寄存器分配，因为寄存器分配者通常查看insn的操作数1和2，来看是否它可以做寄存器绑定（register tying）。

@en There is no way to specify constraints in @code{match_operator}.  The
@en operand of the insn which corresponds to the @code{match_operator}
@en never has any constraints because it is never reloaded as a whole.
@en However, if parts of its @var{operands} are matched by
@en @code{match_operand} patterns, those parts may have constraints of
@en their own.
无法指定在@code{match_operator}中的constraint。对应于@code{match_operator}的insn的操作数，不具有任何constraint，因为它从来不作为一个整体被重载。但是，如果它的@var{operands}的一部分被@code{match_operand}指令模式匹配，那些部分可以具有它们自己的constraint。

@findex match_op_dup
@item (match_op_dup:@var{m} @var{n}[@var{operands}@dots{}])
@en Like @code{match_dup}, except that it applies to operators instead of
@en operands.  When constructing an insn, operand number @var{n} will be
@en substituted at this point.  But in matching, @code{match_op_dup} behaves
@en differently.  It assumes that operand number @var{n} has already been
@en determined by a @code{match_operator} appearing earlier in the
@en recognition template, and it matches only an identical-looking
@en expression.
类似@code{match_dup}，除了其应用于操作符而不是操作数。当构造insn时，操作数编号@var{n}将在这一点被替代。但是在匹配时，@code{match_op_dup}的行为有所不同。其假设操作数编号@var{n}已经被在识别模板中先前出现的@code{match_operator}所确定，并且其只匹配identical-looking的表达式。

@findex match_parallel
@item (match_parallel @var{n} @var{predicate} [@var{subpat}@dots{}])
@en This pattern is a placeholder for an insn that consists of a
@en @code{parallel} expression with a variable number of elements.  This
@en expression should only appear at the top level of an insn pattern.
该指令模式代表一个insn，并且该insn由一个具有可变数目元素的@code{parallel}表达式组成。该表达式只能在insn指令模式的顶层出现。

@en When constructing an insn, operand number @var{n} will be substituted at
@en this point.  When matching an insn, it matches if the body of the insn
@en is a @code{parallel} expression with at least as many elements as the
@en vector of @var{subpat} expressions in the @code{match_parallel}, if each
@en @var{subpat} matches the corresponding element of the @code{parallel},
@en @emph{and} the function @var{predicate} returns nonzero on the
@en @code{parallel} that is the body of the insn.  It is the responsibility
@en of the predicate to validate elements of the @code{parallel} beyond
@en those listed in the @code{match_parallel}.
当构造insn时，操作数编号@var{n}将在该处被替换。当匹配一个insn时，其当insn的主体为一个@code{parallel}表达式，其具有至少跟向量@var{subpat}表达式同样多数目元素，并且函数@var{predicate}返回非零时才匹配。断言（predicate）负责判定在@code{match_parallel}中的@code{parallel}的元素是否有效。

@en A typical use of @code{match_parallel} is to match load and store
@en multiple expressions, which can contain a variable number of elements
@en in a @code{parallel}.  For example,
@code{match_parallel}的一个典型用法是，匹配加载和存储多个表达式，其可以在@code{parallel}中包含一个可变数目的元素。例如，

@smallexample
(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI 179))
      (clobber (reg:SI 179))])]
  ""
  "loadm 0,0,%1,%2")
@end smallexample

@en This example comes from @file{a29k.md}.  The function
@en @code{load_multiple_operation} is defined in @file{a29k.c} and checks
@en that subsequent elements in the @code{parallel} are the same as the
@en @code{set} in the pattern, except that they are referencing subsequent
@en registers and memory locations.
这个例子来自@file{a29k.md}。函数@code{load_multiple_operation}在@file{a29k.c}中定义，其检查在@code{parallel}中的序列元素，是否与在指令模式中的@code{set}相同，除非它们在引用后续的寄存器和内存位置。

@en An insn that matches this pattern might look like:
匹配该指令模式的insn可能看起来像：

@smallexample
(parallel
 [(set (reg:SI 20) (mem:SI (reg:SI 100)))
  (use (reg:SI 179))
  (clobber (reg:SI 179))
  (set (reg:SI 21)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 4))))
  (set (reg:SI 22)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 8))))])
@end smallexample
 
@findex match_par_dup
@item (match_par_dup @var{n} [@var{subpat}@dots{}])
@en Like @code{match_op_dup}, but for @code{match_parallel} instead of
@en @code{match_operator}.
与@code{match_op_dup}类似，但是针对于@code{match_parallel}，而不是@code{match_operator}。
@end table

@en @node Output Template
@en @section Output Templates and Operand Substitution
@node Output Template
@section 输出模板和操作数替换
@cindex output templates
@cindex operand substitution

@cindex @samp{%} in template
@cindex percent sign
@en The @dfn{output template} is a string which specifies how to output the
@en assembler code for an instruction pattern.  Most of the template is a
@en fixed string which is output literally.  The character @samp{%} is used
@en to specify where to substitute an operand; it can also be used to
@en identify places where different variants of the assembler require
@en different syntax.
@dfn{output template}是一个字符串，其指定了如何为一个指令模式输出汇编代码。大多数模板都是一个固定的字符串，可以按照字面直接输出。符号@samp{%}用来指定替换操作数；

@en In the simplest case, a @samp{%} followed by a digit @var{n} says to output
@en operand @var{n} at that point in the string.
最简单的情况下，一个@samp{%}后面跟一个数字@var{n}表示在字符串中的这个位置输出操作数@var{n}。

@en @samp{%} followed by a letter and a digit says to output an operand in an
@en alternate fashion.  Four letters have standard, built-in meanings described
@en below.  The machine description macro @code{PRINT_OPERAND} can define
@en additional letters with nonstandard meanings.
@samp{%}后面跟一个字母和一个数字表示用备用方式来输出操作数。有四个字母具有标准内嵌的含义，将在下面描述。机器描述宏@code{PRINT_OPERAND}能够定义其它的非标准含义的字母。

@en @samp{%c@var{digit}} can be used to substitute an operand that is a
@en constant value without the syntax that normally indicates an immediate
@en operand.
@samp{%c@var{digit}}可以用来替换一个常数值的操作数。

@en @samp{%n@var{digit}} is like @samp{%c@var{digit}} except that the value of
@en the constant is negated before printing.
@samp{%n@var{digit}}类似于@samp{%c@var{digit}}，只不过是对要打印的常数值进行取反操作（negated）。

@en @samp{%a@var{digit}} can be used to substitute an operand as if it were a
@en memory reference, with the actual operand treated as the address.  This may
@en be useful when outputting a ``load address'' instruction, because often the
@en assembler syntax for such an instruction requires you to write the operand
@en as if it were a memory reference.
@samp{%a@var{digit}}可以用来替换一个操作数，并把它当作一个内存引用，实际的操作数则被视为地址。这在输出一个加载地址的指令时很有帮助，因为对于这样的指令，汇编器语法经常需要你将操作数写成一个内存引用的形式。

@en @samp{%l@var{digit}} is used to substitute a @code{label_ref} into a jump
@en instruction.
@samp{%l@var{digit}}用来将一个@code{label_ref}替换到跳转指令中。

@en @samp{%=} outputs a number which is unique to each instruction in the
@en entire compilation.  This is useful for making local labels to be
@en referred to more than once in a single template that generates multiple
@en assembler instructions.
@samp{%=}输出一个在整个编译过程中，对每一条指令都是唯一的编号。这可以用来在一个生成多个汇编指令的单一模板中， 使得局部标号能够被多次引用。

@en @samp{%} followed by a punctuation character specifies a substitution that
@en does not use an operand.  Only one case is standard: @samp{%%} outputs a
@en @samp{%} into the assembler code.  Other nonstandard cases can be
@en defined in the @code{PRINT_OPERAND} macro.  You must also define
@en which punctuation characters are valid with the
@en @code{PRINT_OPERAND_PUNCT_VALID_P} macro.
@samp{%}后面跟一个标点符号指定了一个不使用操作数的替换。只用一种情况是标准的：@samp{%%}用来输出一个@samp{%}到汇编代码中。其它非标准的情况可以被定义在@code{PRINT_OPERAND}宏中。你必须还要通过宏@code{PRINT_OPERAND_PUNCT_VALID_P}来定义哪些标点符号是有效的。

@cindex \
@cindex backslash
@en The template may generate multiple assembler instructions.  Write the text
@en for the instructions, with @samp{\;} between them.
模板可以生成多条汇编指令。这些指令文本之间使用@samp{\;}隔开。

@cindex matching operands
@en When the RTL contains two operands which are required by constraint to match
@en each other, the output template must refer only to the lower-numbered operand.
@en Matching operands are not always identical, and the rest of the compiler
@en arranges to put the proper RTL expression for printing into the lower-numbered
@en operand.
‘%’之后跟非标准字母或者标点符号的一种用途是区分同一机器的不同汇编语言；例如，68000的Motorola语法和MIT语法。 Motorola语法要求大多数的操作名都含有句点，而MIT语法中没有。比如，MIT语法中的操作码‘movel’在Motorola语法中为 ‘move.l’。两种输出法语使用了同一个模式文件，只不过在Motorola语法需要句点的地方使用了字符序列‘%.’。Motorola语法的宏 PRINT_OPERAND定义了这个序列用于输出一个句点；MIT语法的宏将其定义为不做任何事情。

@en One use of nonstandard letters or punctuation following @samp{%} is to
@en distinguish between different assembler languages for the same machine; for
@en example, Motorola syntax versus MIT syntax for the 68000.  Motorola syntax
@en requires periods in most opcode names, while MIT syntax does not.  For
@en example, the opcode @samp{movel} in MIT syntax is @samp{move.l} in Motorola
@en syntax.  The same file of patterns is used for both kinds of output syntax,
@en but the character sequence @samp{%.} is used in each place where Motorola
@en syntax wants a period.  The @code{PRINT_OPERAND} macro for Motorola syntax
@en defines the sequence to output a period; the macro for MIT syntax defines
@en it to do nothing.
紧随@samp{%}之后的非标准字母或者标点符号的一种用法是，为同一机器区别不同的汇编语言；例如，68000的Motorola语法与MIT语法。Motorola语法要求大多操作码的名字中带有句号，而MIT语法不是这样。例如，在MIT语法中的操作码@samp{movel}，在Motorola语法中为@samp{move.l}。这两种输出语法都在同一个文件中的指令模式中实现，只不过字符序列@samp{%.}用在需要句号的Motorola语法中。Motorola语法的@code{PRINT_OPERAND}宏，将该序列定义成输出一个句号；而MIT语法则将其定义为不做任何事情。

@cindex @code{#} in template
@en As a special case, a template consisting of the single character @code{#}
@en instructs the compiler to first split the insn, and then output the
@en resulting instructions separately.  This helps eliminate redundancy in the
@en output templates.   If you have a @code{define_insn} that needs to emit
@en multiple assembler instructions, and there is a matching @code{define_split}
@en already defined, then you can simply use @code{#} as the output template
@en instead of writing an output template that emits the multiple assembler
@en instructions.
作为一种特殊情况，只包含一个单独的字符#的模板会指示编译器首先拆分insn，然后分别输出所得的指令。这样有助于减少输出模板的重复内容。如果你有一个@code{define_insn}，其需要输出多个汇编指令，并且有一个匹配的@code{define_split}已经被定义，则你可以简单的使用#作为输出模板，而不用将模板写成输出多个汇编指令的样子。

@en If the macro @code{ASSEMBLER_DIALECT} is defined, you can use construct
@en of the form @samp{@{option0|option1|option2@}} in the templates.  These
@en describe multiple variants of assembler language syntax.
@en @xref{Instruction Output}.
如果宏@code{ASSEMBLER_DIALECT}被定义，你可以在模板中使用形如@samp{@{option0|option1|option2@}}的结构。这些描述了多个汇编语言语法的变体。@xref{Instruction Output}。

@en @node Output Statement
@en @section C Statements for Assembler Output
@node Output Statement
@section 用于汇编输出的C语句
@cindex output statements
@cindex C statements for assembler output
@cindex generating assembler output
@en Often a single fixed template string cannot produce correct and efficient
@en assembler code for all the cases that are recognized by a single
@en instruction pattern.  For example, the opcodes may depend on the kinds of
@en operands; or some unfortunate combinations of operands may require extra
@en machine instructions.
经常，单个固定的模板字符串，不能够为单个指令模式所识别的所有情况都能产生正确，有效的汇编代码。例如，操作码可以依赖于操作数类别；或者一些不适宜的操作数组合可能需要额外的机器指令。

@en If the output control string starts with a @samp{@@}, then it is actually
@en a series of templates, each on a separate line.  (Blank lines and
@en leading spaces and tabs are ignored.)  The templates correspond to the
@en pattern's constraint alternatives (@pxref{Multi-Alternative}).  For example,
@en if a target machine has a two-address add instruction @samp{addr} to add
@en into a register and another @samp{addm} to add a register to memory, you
@en might write this pattern:
如果输出控制字符串起始于@samp{@@}，则其实际为一系列模板，每一个单独一行。（空行，以及开头的空格和tab被忽略掉。）这些模板对应于模式的各个constraint（@pxref{Multi-Alternative}）。例如，如果一个目标机有一个二址（two-address）加法指令@samp{addr}相加到寄存器中，另外还有一个@samp{addm}将寄存器的值相加到内存中，你可能会这样写模式：

@smallexample
(define_insn "addsi3"
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (plus:SI (match_operand:SI 1 "general_operand" "0,0")
                 (match_operand:SI 2 "general_operand" "g,r")))]
  ""
  "@@
   addr %2,%0
   addm %2,%0")
@end smallexample

@cindex @code{*} in template
@cindex asterisk in template
@en If the output control string starts with a @samp{*}, then it is not an
@en output template but rather a piece of C program that should compute a
@en template.  It should execute a @code{return} statement to return the
@en template-string you want.  Most such templates use C string literals, which
@en require doublequote characters to delimit them.  To include these
@en doublequote characters in the string, prefix each one with @samp{\}.
如果输出控制字符串起始于@samp{*}，则其不是一个输出模板，而是一个C程序片段并且能够计算出一个模板。其应该执行一个@code{return}语句来返回你想要的模板字符串。大多数这样的模板使用C字符串文字，需要用双引号包含起来。如果要在字符串中包含这些双引号，可以在前面加上@samp{\}。

@en If the output control string is written as a brace block instead of a
@en double-quoted string, it is automatically assumed to be C code.  In that
@en case, it is not necessary to put in a leading asterisk, or to escape the
@en doublequotes surrounding C string literals.
如果输出控制串写成一个花括号块，而不是双引号的字符串，则其被自动认为是C代码。这种情况下，则不必要有的起始的星号，以及转义C字符串文字中的双引号。

@en The operands may be found in the array @code{operands}, whose C data type
@en is @code{rtx []}.
操作数可以为数组@code{operands}，其C数据类型为@code{rtx []}。

@en It is very common to select different ways of generating assembler code
@en based on whether an immediate operand is within a certain range.  Be
@en careful when doing this, because the result of @code{INTVAL} is an
@en integer on the host machine.  If the host machine has more bits in an
@en @code{int} than the target machine has in the mode in which the constant
@en will be used, then some of the bits you get from @code{INTVAL} will be
@en superfluous.  For proper results, you must carefully disregard the
@en values of those bits.
一种常见的情况是，根据立即数是否在一个特定范围内来选择生成汇编代码的方式。在做这种事情的时候要仔细，因为@code{INTVAL}的结果是一个主机上的整形。如果主机的@code{int}比目标机上的具有更多的位，则从@code{INTVAL}中的得到的一些位将会是多余的。要得到正确的结果，必须仔细的忽视掉那些位的值。

@findex output_asm_insn
@en It is possible to output an assembler instruction and then go on to output
@en or compute more of them, using the subroutine @code{output_asm_insn}.  This
@en receives two arguments: a template-string and a vector of operands.  The
@en vector may be @code{operands}, or it may be another array of @code{rtx}
@en that you declare locally and initialize yourself.
有可能输出一个汇编指令，然后使用子程序@code{output_asm_insn}来继续输出或者计算更多的。其接收两个参数：一个模板字符串和一个操作数向量。向量可以是@code{operands}，或者是另一个声明为局部的并且自己初始化的@code{rtx}数组。

@findex which_alternative
@en When an insn pattern has multiple alternatives in its constraints, often
@en the appearance of the assembler code is determined mostly by which alternative
@en was matched.  When this is so, the C code can test the variable
@en @code{which_alternative}, which is the ordinal number of the alternative
@en that was actually satisfied (0 for the first, 1 for the second alternative,
@en etc.).
当一个insn模式有多个可选择的constraint时，则汇编代码经常主要是由所匹配的constraint选择来决定。如果是这样，C代码可以测试变量@code{which_alternative}，其为实际满足条件的constraint选择的序号（0为第一个，1位第二个选择，以此类推）。

@en For example, suppose there are two opcodes for storing zero, @samp{clrreg}
@en for registers and @samp{clrmem} for memory locations.  Here is how
@en a pattern could use @code{which_alternative} to choose between them:
例如，假设有两个操作码来存储0，@samp{clrreg}用于寄存器，@samp{clrmem}用于内存地址。这个模式实现了如何能够使用@samp{which_alternative}来选择它们：

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  @{
  return (which_alternative == 0
          ? "clrreg %0" : "clrmem %0");
  @})
@end smallexample

@en The example above, where the assembler code to generate was
@en @emph{solely} determined by the alternative, could also have been specified
@en as follows, having the output control string start with a @samp{@@}:
对于上面的例子，要生成的汇编代码@emph{只是}由alternative来决定，则还可以写成如下形式，使用起始于@samp{@@}的输出控制串：

@smallexample
@group
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  "@@
   clrreg %0
   clrmem %0")
@end group
@end smallexample

@en @node Predicates
@en @section Predicates
@node Predicates
@section 断言
@cindex predicates
@cindex operand predicates
@cindex operator predicates

@en A predicate determines whether a @code{match_operand} or
@en @code{match_operator} expression matches, and therefore whether the
@en surrounding instruction pattern will be used for that combination of
@en operands.  GCC has a number of machine-independent predicates, and you
@en can define machine-specific predicates as needed.  By convention,
@en predicates used with @code{match_operand} have names that end in
@en @samp{_operand}, and those used with @code{match_operator} have names
@en that end in @samp{_operator}.
断言用于确定一个@code{match_operand}或者 @code{match_operator}表达式是否匹配， 以及周围的指令模式是否会被用于那些操作数的组合。 GCC有许多机器无关的predicate，并且你可以根据需要来定义机器特定的断言。 按照惯例，与@code{match_operand}一起使用的predicate的名字以@samp{_operand}结尾， 与@code{match_operator}一起使用的predicate的名字以@samp{_operator}结尾。

@en All predicates are Boolean functions (in the mathematical sense) of
@en two arguments: the RTL expression that is being considered at that
@en position in the instruction pattern, and the machine mode that the
@en @code{match_operand} or @code{match_operator} specifies.  In this
@en section, the first argument is called @var{op} and the second argument
@en @var{mode}.  Predicates can be called from C as ordinary two-argument
@en functions; this can be useful in output templates or other
@en machine-specific code.
所有断言（从数学意义上）都是具有两个参数的布尔函数： 指令模式中在那个位置上被考虑的RTL表达式， 以及@code{match_operand}或@code{match_operator}所指定的机器模式。 在这一节里，第一个参数被称为@var{op}，第二个参数被称为@var{mode}。 predicate可以作为普通的具有两个参数的函数，从C中调用； 这在输出模板或者其它机器特定的代码中，很有用处。

@en Operand predicates can allow operands that are not actually acceptable
@en to the hardware, as long as the constraints give reload the ability to
@en fix them up (@pxref{Constraints}).  However, GCC will usually generate
@en better code if the predicates specify the requirements of the machine
@en instructions as closely as possible.  Reload cannot fix up operands
@en that must be constants (``immediate operands''); you must use a
@en predicate that allows only constants, or else enforce the requirement
@en in the extra condition.
操作数断言可以允许硬件实际上无法接受的操作数， 只要约束能够为reload提供能力，来修复它们（@pxref{Constraints}）。 然而，只要断言指定的机器指令需求尽可能的严密， GCC通常便会生成更好的代码。reload不能修复必须为常量的操作数（立即数）； 你必须使用只允许常量的断言，或者使用额外的条件来加强必要条件。

@cindex predicates and machine modes
@cindex normal predicates
@cindex special predicates
@en Most predicates handle their @var{mode} argument in a uniform manner.
@en If @var{mode} is @code{VOIDmode} (unspecified), then @var{op} can have
@en any mode.  If @var{mode} is anything else, then @var{op} must have the
@en same mode, unless @var{op} is a @code{CONST_INT} or integer
@en @code{CONST_DOUBLE}.  These RTL expressions always have
@en @code{VOIDmode}, so it would be counterproductive to check that their
@en mode matches.  Instead, predicates that accept @code{CONST_INT} and/or
@en integer @code{CONST_DOUBLE} check that the value stored in the
@en constant will fit in the requested mode.
大多数predicate使用统一的方式来处理它们的@var{mode}参数。如果@var{mode}为@code{VOIDmode}（未加指明的），则@var{op}可以具有任意的模式。如果@var{mode}为其它情况，则@var{op}必须具有相同的机器模式，除非@var{op}是一个@code{CONST_INT}或整数@code{CONST_DOUBLE}。这些RTL表达式总是具有@code{VOIDmode}，所以检测它们的模式匹配反而会适得其反。替代的，接受@code{CONST_INT}和/或整数@code{CONST_DOUBLE}的predicate，可以检测存储在常量中的值是否适合所要求的机器模式。

@en Predicates with this behavior are called @dfn{normal}.
@en @command{genrecog} can optimize the instruction recognizer based on
@en knowledge of how normal predicates treat modes.  It can also diagnose
@en certain kinds of common errors in the use of normal predicates; for
@en instance, it is almost always an error to use a normal predicate
@en without specifying a mode.
具有这种行为的predicate被称为常规的。@command{genrecog}能够根据常规predicate如何处理机器模式的知识来优化指令识别器。它还能够诊断使用常规predicate所出现的一些常见错误。例如，使用常规predicate而没有指定机器模式几乎总是错误的。

@en Predicates that do something different with their @var{mode} argument
@en are called @dfn{special}.  The generic predicates
@en @code{address_operand} and @code{pmode_register_operand} are special
@en predicates.  @command{genrecog} does not do any optimizations or
@en diagnosis when special predicates are used.
对@var{mode}参数进行不同方式处理的predicate被称为特殊的。通用predicate @code{address_operand}和@code{pmode_register_operand}是特殊predicate。当使用特殊predicate的时候，@command{genrecog}不做任何的优化或诊断。

@en @menu
@en * Machine-Independent Predicates::  Predicates available to all back ends.
@en * Defining Predicates::             How to write machine-specific predicate
@en                                     functions.
@en @end menu
@menu
* Machine-Independent Predicates:: 所有后端都可用的@term{predicate}。 
* Defining Predicates::       如何写机器特定的predicate函数。
@end menu

@en @node Machine-Independent Predicates
@en @subsection Machine-Independent Predicates
@node Machine-Independent Predicates
@subsection 机器无关的@term{predicate}
@cindex machine-independent predicates
@cindex generic predicates

@en These are the generic predicates available to all back ends.  They are
@en defined in @file{recog.c}.  The first category of predicates allow
@en only constant, or @dfn{immediate}, operands.
这些是通用predicate，适用于所有后端。它们定义在@file{recog.c}中。第一类predicate只允许常量或立即数。

@defun immediate_operand
@en This predicate allows any sort of constant that fits in @var{mode}.
@en It is an appropriate choice for instructions that take operands that
@en must be constant.
@en @end defun
该predicate允许适合相应@var{mode}的任何类别的常量。适合用于操作数必须为常量的指令。
@end defun

@defun const_int_operand
@en This predicate allows any @code{CONST_INT} expression that fits in
@en @var{mode}.  It is an appropriate choice for an immediate operand that
@en does not allow a symbol or label.
@en @end defun
该predicate允许适合相应@var{mode}的任何@code{CONST_INT}表达式。适合用于不是符号（symbol）或标号（label）的立即数。
@end defun

@defun const_double_operand
@en This predicate accepts any @code{CONST_DOUBLE} expression that has
@en exactly @var{mode}.  If @var{mode} is @code{VOIDmode}, it will also
@en accept @code{CONST_INT}.  It is intended for immediate floating point
@en constants.
该predicate接受任何确实为@var{mode}的@code{CONST_DOUBLE}表达式。如果@var{mode}为@code{VOIDmode}，则其还接受@code{CONST_INT}。它是用于浮点立即数的。
@end defun

@noindent
@en The second category of predicates allow only some kind of machine
@en register.
第二类predicate只允许某种类别的机器寄存器。

@defun register_operand
@en This predicate allows any @code{REG} or @code{SUBREG} expression that
@en is valid for @var{mode}.  It is often suitable for arithmetic
@en instruction operands on a RISC machine.
该predicate允许适合相应@var{mode}的任何@code{REG}或@code{SUBREG}表达式。通常适合于RISC机器上的算术指令操作数。
@end defun

@defun pmode_register_operand
@en This is a slight variant on @code{register_operand} which works around
@en a limitation in the machine-description reader.
这与@code{register_operand}略为不同，其对机器描述的读入器有些限制。

@smallexample
(match_operand @var{n} "pmode_register_operand" @var{constraint})
@end smallexample

@noindent
@en means exactly what
与

@smallexample
(match_operand:P @var{n} "register_operand" @var{constraint})
@end smallexample

@noindent
@en would mean, if the machine-description reader accepted @samp{:P}
@en mode suffixes.  Unfortunately, it cannot, because @code{Pmode} is an
@en alias for some other mode, and might vary with machine-specific
@en options.  @xref{Misc}.
当机器描述读入器接受@samp{:P}机器模式后缀时，将具有完全相同的含义。不幸的是，这样不行，应为Pmode是其它机器模式的别名，并且可能随着机器特定选项的不同而改变。@xref{Misc}。
@end defun

@defun scratch_operand
@en This predicate allows hard registers and @code{SCRATCH} expressions,
@en but not pseudo-registers.  It is used internally by @code{match_scratch};
@en it should not be used directly.
该predicate允许硬件寄存器和@code{SCRATCH}表达式，但不允许伪寄存器。其由@code{match_scratch}在内部使用；而不应该被直接使用。
@end defun

@noindent
@en The third category of predicates allow only some kind of memory reference.
第三类predicate只允许某种内存引用。

@defun memory_operand
@en This predicate allows any valid reference to a quantity of mode
@en @var{mode} in memory, as determined by the weak form of
@en @code{GO_IF_LEGITIMATE_ADDRESS} (@pxref{Addressing Modes}).
该predicate允许任何对内存中机器模式@var{mode}的一定数量的有效引用，并通过@code{GO_IF_LEGITIMATE_ADDRESS}的弱形式来确定(@pxref{Addressing Modes})。
@end defun

@defun address_operand
@en This predicate is a little unusual; it allows any operand that is a
@en valid expression for the @emph{address} of a quantity of mode
@en @var{mode}, again determined by the weak form of
@en @code{GO_IF_LEGITIMATE_ADDRESS}.  To first order, if
@en @samp{@w{(mem:@var{mode} (@var{exp}))}} is acceptable to
@en @code{memory_operand}, then @var{exp} is acceptable to
@en @code{address_operand}.  Note that @var{exp} does not necessarily have
@en the mode @var{mode}.
该predicate有些不常用；其允许任何为机器模式@var{mode}的一定数量的地址有效表达式操作数，同样通过@code{GO_IF_LEGITIMATE_ADDRESS}的弱形式来确定。首先，如果@samp{@w{(mem:@var{mode} (@var{exp}))}}被@code{memory_operand}接受，则@var{exp}被@code{address_operand}接受。注意@var{exp}不必具有机器模式@var{mode}。
@end defun

@defun indirect_operand
@en This is a stricter form of @code{memory_operand} which allows only
@en memory references with a @code{general_operand} as the address
@en expression.  New uses of this predicate are discouraged, because
@en @code{general_operand} is very permissive, so it's hard to tell what
@en an @code{indirect_operand} does or does not allow.  If a target has
@en different requirements for memory operands for different instructions,
@en it is better to define target-specific predicates which enforce the
@en hardware's requirements explicitly.
这是一个@code{memory_operand}的更严格形式，其只允许将@code{general_operand}作为地址表达式的内存引用。不鼓励对该predicate的新的使用，因为@code{general_operand}的条件非常宽，所以很难说清对于@code{indirect_operand}什么是被允许的，什么是不被允许的。如果目标机对不同指令的内存操作数具有不同的要求，则最好定义目标机特定的predicate，以显式的加强硬件的要求。
@end defun

@defun push_operand
@en This predicate allows a memory reference suitable for pushing a value
@en onto the stack.  This will be a @code{MEM} which refers to
@en @code{stack_pointer_rtx}, with a side-effect in its address expression
@en (@pxref{Incdec}); which one is determined by the
@en @code{STACK_PUSH_CODE} macro (@pxref{Frame Layout}).
该predicate允许适合将值压入栈中的内存引用。这将为一个@code{MEM}，其引用@code{stack_pointer_rtx}，且在其地址表达式中具有一个副作用(@pxref{Incdec})；其由宏@code{STACK_PUSH_CODE}来确定(@pxref{Frame Layout}。
@end defun

@defun pop_operand
@en This predicate allows a memory reference suitable for popping a value
@en off the stack.  Again, this will be a @code{MEM} referring to
@en @code{stack_pointer_rtx}, with a side-effect in its address
@en expression.  However, this time @code{STACK_POP_CODE} is expected.
该predicate允许适合将值弹出栈中的内存引用。同样，这将为一个@code{MEM} ，其引用@code{stack_pointer_rtx}，且在其地址表达式中具有一个副作用；不过，这次是@code{STACK_POP_CODE} 。
@end defun

@noindent
@en The fourth category of predicates allow some combination of the above
@en operands.
第四类predicate允许上面的操作数的某种组合。

@defun nonmemory_operand
@en This predicate allows any immediate or register operand valid for @var{mode}.
该predicate允许任何对于@var{mode}有效的立即数，或寄存器操作数。
@end defun

@defun nonimmediate_operand
@en This predicate allows any register or memory operand valid for @var{mode}.
该predicate允许任何对于@var{mode}有效的寄存器，或内存操作数。
@end defun

@defun general_operand
@en This predicate allows any immediate, register, or memory operand
@en valid for @var{mode}.
该predicate允许任何对于@var{mode}有效的立即数，寄存器，或内存操作数。
@end defun

@noindent
@en Finally, there are two generic operator predicates.
最后，有两个通用操作符断言。

@defun comparison_operator
@en This predicate matches any expression which performs an arithmetic
@en comparison in @var{mode}; that is, @code{COMPARISON_P} is true for the
@en expression code.
该predicate匹配任何执行一个基于@var{mode}的算术比较表达式；即，@code{COMPARISON_P}对于表达式代码为真。
@end defun

@defun ordered_comparison_operator
@en This predicate matches any expression which performs an arithmetic
@en comparison in @var{mode} and whose expression code is valid for integer
@en modes; that is, the expression code will be one of @code{eq}, @code{ne},
@en @code{lt}, @code{ltu}, @code{le}, @code{leu}, @code{gt}, @code{gtu},
@en @code{ge}, @code{geu}.
This predicate matches any expression which performs an arithmetic
comparison in @var{mode} and whose expression code is valid for integer
modes; that is, the expression code will be one of @code{eq}, @code{ne},
@code{lt}, @code{ltu}, @code{le}, @code{leu}, @code{gt}, @code{gtu},
@code{ge}, @code{geu}.
@end defun

@en @node Defining Predicates
@en @subsection Defining Machine-Specific Predicates
@node Defining Predicates
@subsection 定义机器特定的predicate
@cindex defining predicates
@findex define_predicate
@findex define_special_predicate

@en Many machines have requirements for their operands that cannot be
@en expressed precisely using the generic predicates.  You can define
@en additional predicates using @code{define_predicate} and
@en @code{define_special_predicate} expressions.  These expressions have
@en three operands:
许多机器对操作数的要求无法使用通用的predicate来精确表达。你可以使用表达式@code{define_predicate}和@code{define_special_predicate}来定义 额外的predicate。这些表达式具有三个操作数： 

@itemize @bullet
@item
@en The name of the predicate, as it will be referred to in
@en @code{match_operand} or @code{match_operator} expressions.
predicate的名字，
其将在@code{match_operand}或@code{match_operator}表达式中被引用。

@item
@en An RTL expression which evaluates to true if the predicate allows the
@en operand @var{op}, false if it does not.  This expression can only use
@en the following RTL codes:
一个RTL表达式，如果predicate允许@var{op}操作数，则值为真，否则为假。该表达式只能使用下列RTL代码： 

@table @code
@item MATCH_OPERAND
@en When written inside a predicate expression, a @code{MATCH_OPERAND}
@en expression evaluates to true if the predicate it names would allow
@en @var{op}.  The operand number and constraint are ignored.  Due to
@en limitations in @command{genrecog}, you can only refer to generic
@en predicates and predicates that have already been defined.
当用于predicate表达式中时，表达式@code{MATCH_OPERAND}在predicate允许@var{op}时为真。操作数编号和constraint被忽略。由于@command{genrecog}中的限制，你只能用于引用通用的predicate和已经被定义的predicate。

@item MATCH_CODE
@en This expression evaluates to true if @var{op} or a specified
@en subexpression of @var{op} has one of a given list of RTX codes.
该表达式为真，如果@var{op}或一个指定的@var{op}的子表达式具有给定RTX代码列表中的一个RTX代码。

@en The first operand of this expression is a string constant containing a
@en comma-separated list of RTX code names (in lower case).  These are the
@en codes for which the @code{MATCH_CODE} will be true.
该表达式的第一个操作数为一个字符串常量，包含了逗号分割的RTX代码名字（小写形式）列表。这些是@code{MATCH_CODE}为真的代码。

@en The second operand is a string constant which indicates what
@en subexpression of @var{op} to examine.  If it is absent or the empty
@en string, @var{op} itself is examined.  Otherwise, the string constant
@en must be a sequence of digits and/or lowercase letters.  Each character
@en indicates a subexpression to extract from the current expression; for
@en the first character this is @var{op}, for the second and subsequent
@en characters it is the result of the previous character.  A digit
@en @var{n} extracts @samp{@w{XEXP (@var{e}, @var{n})}}; a letter @var{l}
@en extracts @samp{@w{XVECEXP (@var{e}, 0, @var{n})}} where @var{n} is the
@en alphabetic ordinal of @var{l} (0 for `a', 1 for 'b', and so on).  The
@en @code{MATCH_CODE} then examines the RTX code of the subexpression
@en extracted by the complete string.  It is not possible to extract
@en components of an @code{rtvec} that is not at position 0 within its RTX
@en object.
第二个操作数为一个字符串常量，其指示@var{op}的什么子表达式需要被检查。如果没有或者为空字符串，则检查@var{op}本身。否则，字符串常量必须为一个数字和/或小写字母的序列。每个字符指示从当前表达式中抽取的子表达式；第一个字符为@var{op}，第二个和后续字符，其为先前字符的结果。数字@var{n}用于抽取@samp{@w{XEXP (@var{e}, @var{n})}}；字母@var{l}抽取@samp{@w{XVECEXP (@var{e}, 0, @var{n})}}，其中@var{n}为@var{l}的字母顺序（0为`a'，1为'b'，等等）。@code{MATCH_CODE}然后检查完整字符串所抽取的子表达式的RTX代码。

@item MATCH_TEST
@en This expression has one operand, a string constant containing a C
@en expression.  The predicate's arguments, @var{op} and @var{mode}, are
@en available with those names in the C expression.  The @code{MATCH_TEST}
@en evaluates to true if the C expression evaluates to a nonzero value.
@en @code{MATCH_TEST} expressions must not have side effects.
该表达式具有一个操作数，一个包含了一个C表达式的字符串常量。在C表达式中可以使用predicate的参数，@var{op}和@var{mode}。当C表达式为非0值时，@code{MATCH_TEST}为真。@code{MATCH_TEST}表达式必须不具有副作用。

@item  AND
@itemx IOR
@itemx NOT
@itemx IF_THEN_ELSE
@en The basic @samp{MATCH_} expressions can be combined using these
@en logical operators, which have the semantics of the C operators
@en @samp{&&}, @samp{||}, @samp{!}, and @samp{@w{? :}} respectively.  As
@en in Common Lisp, you may give an @code{AND} or @code{IOR} expression an
@en arbitrary number of arguments; this has exactly the same effect as
@en writing a chain of two-argument @code{AND} or @code{IOR} expressions.
基本的@samp{MATCH_}表达式可以使用这些逻辑操作符组合，其分别具有C操作符@samp{&&}, @samp{||}, @samp{!}和@samp{@w{? :}}的语义。正如在Common Lisp中，可以给@code{AND}或@code{IOR}表达式任意数目的参数；这跟写成两个参数的@code{AND}或@code{IOR}表达式链具有相同的效果。
@end table

@item
@en An optional block of C code, which should execute
@en @samp{@w{return true}} if the predicate is found to match and
@en @samp{@w{return false}} if it does not.  It must not have any side
@en effects.  The predicate arguments, @var{op} and @var{mode}, are
@en available with those names.
一个可选的C代码块，其应该在发现predicate匹配时执行@samp{@w{return true}}，不匹配时执行@samp{@w{return false}}。其一定不要具有副作用。predicate参数，@var{op}和@var{mode}，是有效的。

@en If a code block is present in a predicate definition, then the RTL
@en expression must evaluate to true @emph{and} the code block must
@en execute @samp{@w{return true}} for the predicate to allow the operand.
@en The RTL expression is evaluated first; do not re-check anything in the
@en code block that was checked in the RTL expression.
如果代码块存在于predicate定义中，则对于predicate允许的操作数，RTL表达式必须求值为true并且代码块必须执行@samp{@w{return true}}。RTL表达式被首先求值，不要重复检查代码块中的在RTL表达式中曾经被检查过的任何事情。
@end itemize

@en The program @command{genrecog} scans @code{define_predicate} and
@en @code{define_special_predicate} expressions to determine which RTX
@en codes are possibly allowed.  You should always make this explicit in
@en the RTL predicate expression, using @code{MATCH_OPERAND} and
@en @code{MATCH_CODE}.
程序@command{genrecog}扫描@code{define_predicate}和@code{define_special_predicate}表达式来决定什么RTX代码可能被允许。你应该使其在RTL predicate表达式中总是显式的，使用@code{MATCH_OPERAND}和@code{MATCH_CODE}。

@en Here is an example of a simple predicate definition, from the IA64
@en machine description:
这里有一个简单的定义predicate的例子，来自IA64机器描述：

@smallexample
@group
;; @r{True if @var{op} is a @code{SYMBOL_REF} which refers to the sdata section.}
(define_predicate "small_addr_symbolic_operand"
  (and (match_code "symbol_ref")
       (match_test "SYMBOL_REF_SMALL_ADDR_P (op)")))
@end group
@end smallexample

@noindent
@en And here is another, showing the use of the C block.
另一个例子，展示了C块的使用。

@smallexample
@group
;; @r{True if @var{op} is a register operand that is (or could be) a GR reg.}
(define_predicate "gr_register_operand"
  (match_operand 0 "register_operand")
@{
  unsigned int regno;
  if (GET_CODE (op) == SUBREG)
    op = SUBREG_REG (op);

  regno = REGNO (op);
  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));
@})
@end group
@end smallexample

@en Predicates written with @code{define_predicate} automatically include
@en a test that @var{mode} is @code{VOIDmode}, or @var{op} has the same
@en mode as @var{mode}, or @var{op} is a @code{CONST_INT} or
@en @code{CONST_DOUBLE}.  They do @emph{not} check specifically for
@en integer @code{CONST_DOUBLE}, nor do they test that the value of either
@en kind of constant fits in the requested mode.  This is because
@en target-specific predicates that take constants usually have to do more
@en stringent value checks anyway.  If you need the exact same treatment
@en of @code{CONST_INT} or @code{CONST_DOUBLE} that the generic predicates
@en provide, use a @code{MATCH_OPERAND} subexpression to call
@en @code{const_int_operand}, @code{const_double_operand}, or
@en @code{immediate_operand}.
使用@code{define_predicate}编写的predicate会自动包含一个测试，用来测试@var{mode}为@code{VOIDmode}，或者@var{op}具有与@var{mode}相同的机器模式，或者@var{op}为@code{CONST_INT}或@code{CONST_DOUBLE}。它们@emph{不}专门检查整数@code{CONST_DOUBLE}，也不测试每种常量的值是否适合所需求的机器模式。这是因为接受常量的目标机特定的predicate，通常必须做更严厉的值检查。如果你需要确切的通用predicate提供的对@code{CONST_INT}或@code{CONST_DOUBLE}的对待，则可以使用@code{MATCH_OPERAND}子表达式来调用@code{const_int_operand}, @code{const_double_operand}或者@code{immediate_operand}。

@en Predicates written with @code{define_special_predicate} do not get any
@en automatic mode checks, and are treated as having special mode handling
@en by @command{genrecog}.
使用@code{define_special_predicate}编写的predicate不做任何自动的机器模式检查，并且@command{genrecog}将其作为具有特定的机器模式处理来对待。

@en The program @command{genpreds} is responsible for generating code to
@en test predicates.  It also writes a header file containing function
@en declarations for all machine-specific predicates.  It is not necessary
@en to declare these predicates in @file{@var{cpu}-protos.h}.
程序@command{genpreds}负责生成代码来测试predicate。其还编写了一个包含所有机器特定predicate的函数声明的头文件。所以不需要在cpu-protos.h中声明这些predicate。
@end ifset

@en @c Most of this node appears by itself (in a different place) even
@en @c when the INTERNALS flag is clear.  Passages that require the internals
@en @c manual's context are conditionalized to appear only in the internals manual.
@ifset INTERNALS
@en @node Constraints
@en @section Operand Constraints
@node Constraints
@section 操作数的约束
@cindex operand constraints
@cindex constraints

@en Each @code{match_operand} in an instruction pattern can specify
@en constraints for the operands allowed.  The constraints allow you to
@en fine-tune matching within the set of operands allowed by the
@en predicate.
在指令模式中的每个@code{match_operand}都可以指定操作数所允许的约束。 约束允许你在由断言所允许的操作数集里进行微调匹配。

@end ifset
@ifclear INTERNALS
@en @node Constraints
@en @section Constraints for @code{asm} Operands
@node Constraints
@section @code{asm}操作数的constraint条件
@cindex operand constraints, @code{asm}
@cindex constraints, @code{asm}
@cindex @code{asm} constraints

@en Here are specific details on what constraint letters you can use with
@en @code{asm} operands.
Here are specific details on what constraint letters you can use with
@code{asm} operands.
@end ifclear
@en Constraints can say whether
@en an operand may be in a register, and which kinds of register; whether the
@en operand can be a memory reference, and which kinds of address; whether the
@en operand may be an immediate constant, and which possible values it may
@en have.  Constraints can also require two operands to match.
@en Side-effects aren't allowed in operands of inline @code{asm}, unless
@en @samp{<} or @samp{>} constraints are used, because there is no guarantee
@en that the side-effects will happen exactly once in an instruction that can update
@en the addressing register.
约束可以告诉一个操作数是否可以在寄存器中，以及哪种寄存器；
操作数是否可以为内存引用，以及哪种寻址方式；操作数是否可以为立即数，
以及可以具有什么值。约束还可以要求两个操作数要匹配。

@ifset INTERNALS
@en @menu
@en * Simple Constraints::  Basic use of constraints.
@en * Multi-Alternative::   When an insn has two alternative constraint-patterns.
@en * Class Preferences::   Constraints guide which hard register to put things in.
@en * Modifiers::           More precise control over effects of constraints.
@en * Disable Insn Alternatives:: Disable insn alternatives using the @code{enabled} attribute.
@en * Machine Constraints:: Existing constraints for some particular machines.
@en * Define Constraints::  How to define machine-specific constraints.
@en * C Constraint Interface:: How to test constraints from C code.
@en @end menu
@menu
* Simple Constraints::       约束的基本用法
* Multi-Alternative::     当insn具有两个可选的约束模式
* Class Preferences::   约束可以指导用哪个硬件寄存器来存放事物
* Modifiers::         对约束效果更精确的控制
* Disable Insn Alternatives:: 使用@code{enabled}属性来禁止insn可选项
* Machine Constraints::       一些特定机器现有的约束
* Define Constraints::       如何定义机器特定的约束
* C Constraint Interface::     如何测试C代码的约束
@end menu
@end ifset

@ifclear INTERNALS
@en @menu
@en * Simple Constraints::  Basic use of constraints.
@en * Multi-Alternative::   When an insn has two alternative constraint-patterns.
@en * Modifiers::           More precise control over effects of constraints.
@en * Machine Constraints:: Special constraints for some particular machines.
@en @end menu
@menu
* 简单约束::     约束的基本用法
* 多个可选项::   当insn具有两个可选的约束模式
* 修饰符::       对约束效果更精确的控制
* 机器约束::     一些特定机器现有的
@end menu
@end ifclear

@en @node Simple Constraints
@en @subsection Simple Constraints
@node Simple Constraints
@subsection 简单约束
@cindex simple constraints

@en The simplest kind of constraint is a string full of letters, each of
@en which describes one kind of operand that is permitted.  Here are
@en the letters that are allowed:
最简单的约束种类是一个由字母组成的字符串， 每个字母描述一种所允许的操作数。这里是所允许的字母：

@table @asis
@item whitespace
@en Whitespace characters are ignored and can be inserted at any position
@en except the first.  This enables each alternative for different operands to
@en be visually aligned in the machine description even if they have different
@en number of constraints and modifiers.
空格字符将被忽略，并且可以插到除了起始处的任何地方。这使得机器描述中， 不同操作数的每个可选项可以被可视化的对齐，即使它们具有不同数目的约束和修饰符。 

@cindex @samp{m} in constraint
@cindex memory references in constraints
@item @samp{m}
@en A memory operand is allowed, with any kind of address that the machine
@en supports in general.
@en Note that the letter used for the general memory constraint can be
@en re-defined by a back end using the @code{TARGET_MEM_CONSTRAINT} macro.
内存操作数将被允许，包括机器支持的任何寻址方式。

@cindex offsettable address
@cindex @samp{o} in constraint
@item @samp{o}
@en A memory operand is allowed, but only if the address is
@en @dfn{offsettable}.  This means that adding a small integer (actually,
@en the width in bytes of the operand, as determined by its machine mode)
@en may be added to the address and the result is also a valid memory
@en address.
内存操作数将被允许，但只有当地址为偏移表的时候。 这意味着可以对地址加上一个小的整数(实际上,是为操作数的数个字节宽度, 这由它的机器模式决定),其结果也为一个有效的内存地址。

@cindex autoincrement/decrement addressing
@en For example, an address which is constant is offsettable; so is an
@en address that is the sum of a register and a constant (as long as a
@en slightly larger constant is also within the range of address-offsets
@en supported by the machine); but an autoincrement or autodecrement
@en address is not offsettable.  More complicated indirect/indexed
@en addresses may or may not be offsettable depending on the other
@en addressing modes that the machine supports.
例如，地址为常数的为一个偏移表；所以地址为一个寄存器和常数（只要常数在机器所支持 的地址偏移范围）的和；但是递增或者递减地址不是偏移表。更加复杂的间接/索引地址可 能是或者可能不是偏移表，这取决于机器支持的其它寻址模式。

@en Note that in an output operand which can be matched by another
@en operand, the constraint letter @samp{o} is valid only when accompanied
@en by both @samp{<} (if the target machine has predecrement addressing)
@en and @samp{>} (if the target machine has preincrement addressing).

@cindex @samp{V} in constraint
@item @samp{V}
@en A memory operand that is not offsettable.  In other words, anything that
@en would fit the @samp{m} constraint but not the @samp{o} constraint.
一个不是offsettable的内存操作数。换句话说， 任何适合@samp{m}约束但不是@samp{o}约束的。 

@cindex @samp{<} in constraint
@item @samp{<}
@en A memory operand with autodecrement addressing (either predecrement or
@en postdecrement) is allowed.  In inline @code{asm} this constraint is only
@en allowed if the operand is used exactly once in an instruction that can
@en handle the side-effects.  Not using an operand with @samp{<} in constraint
@en string in the inline @code{asm} pattern at all or using it in multiple
@en instructions isn't valid, because the side-effects wouldn't be performed
@en or would be performed more than once.  Furthermore, on some targets
@en the operand with @samp{<} in constraint string must be accompanied by
@en special instruction suffixes like @code{%U0} instruction suffix on PowerPC
@en or @code{%P0} on IA-64.
允许具有自动减量寻址（先减或者后减）的内存操作数。 

@cindex @samp{>} in constraint
@item @samp{>}
@en A memory operand with autoincrement addressing (either preincrement or
@en postincrement) is allowed.  In inline @code{asm} the same restrictions
@en as for @samp{<} apply.
允许具有自动增量寻址（先增或者后增）的内存操作数。

@cindex @samp{r} in constraint
@cindex registers in constraints
@item @samp{r}
@en A register operand is allowed provided that it is in a general
@en register.
允许为通用寄存器的寄存器操作数。 

@cindex constants in constraints
@cindex @samp{i} in constraint
@item @samp{i}
@en An immediate integer operand (one with constant value) is allowed.
@en This includes symbolic constants whose values will be known only at
@en assembly time or later.
立即数（具有常数值）将被允许。这包括符号常量， 其值将在汇编时候或者更晚的时候才被知道。 

@cindex @samp{n} in constraint
@item @samp{n}
@en An immediate integer operand with a known numeric value is allowed.
@en Many systems cannot support assembly-time constants for operands less
@en than a word wide.  Constraints for these operands should use @samp{n}
@en rather than @samp{i}.
立即数，其具有已知的数值。 许多系统不支持汇编时间常量作为小于一个字的宽度的操作数。 这些操作数的约束应该为@samp{n}而不是@samp{i}。 

@cindex @samp{I} in constraint
@item @samp{I}, @samp{J}, @samp{K}, @dots{} @samp{P}
@en Other letters in the range @samp{I} through @samp{P} may be defined in
@en a machine-dependent fashion to permit immediate integer operands with
@en explicit integer values in specified ranges.  For example, on the
@en 68000, @samp{I} is defined to stand for the range of values 1 to 8.
@en This is the range permitted as a shift count in the shift
@en instructions.
从@samp{I}到@samp{P}的其它字母可以被定义为机器特定的， 用来运行立即数具有显示指定范围的整数值。例如，在68000上， @samp{I}被定义为代表1到8的值。这是在移位指令中被允许作为移位数的范围。 

@cindex @samp{E} in constraint
@item @samp{E}
@en An immediate floating operand (expression code @code{const_double}) is
@en allowed, but only if the target floating point format is the same as
@en that of the host machine (on which the compiler is running).
浮点立即数（表达式代码为@code{const_double}）， 但是必须target浮点格式与host机器（编译器运行的机器）的相同才行。 

@cindex @samp{F} in constraint
@item @samp{F}
@en An immediate floating operand (expression code @code{const_double} or
@en @code{const_vector}) is allowed.
浮点立即数（表达式代码为@code{const_double}或者@code{const_vector}）。 

@cindex @samp{G} in constraint
@cindex @samp{H} in constraint
@item @samp{G}, @samp{H}
@en @samp{G} and @samp{H} may be defined in a machine-dependent fashion to
@en permit immediate floating operands in particular ranges of values.
@samp{G}和@samp{H}可以被定义为机器特定的方式来允许浮点立即数具有特定范围的值。 

@cindex @samp{s} in constraint
@item @samp{s}
@en An immediate integer operand whose value is not an explicit integer is
@en allowed.
整数立即数，其值不是一个显式的整数。

@en This might appear strange; if an insn allows a constant operand with a
@en value not known at compile time, it certainly must allow any known
@en value.  So why use @samp{s} instead of @samp{i}?  Sometimes it allows
@en better code to be generated.
这可能有点奇怪；如果insn允许常量操作数具有在编译时不可知的值， 它当然必须允许任何可知的值。所以为什么用@samp{s}，而不是@samp{i}能？有时候， 它会允许生成更好的代码。

@en For example, on the 68000 in a fullword instruction it is possible to
@en use an immediate operand; but if the immediate value is between @minus{}128
@en and 127, better code results from loading the value into a register and
@en using the register.  This is because the load into the register can be
@en done with a @samp{moveq} instruction.  We arrange for this to happen
@en by defining the letter @samp{K} to mean ``any integer outside the
@en range @minus{}128 to 127'', and then specifying @samp{Ks} in the operand
@en constraints.
例如，在68000上的全字指令，有可能使用一个立即数操作数； 但是如果立即数的值是处于-128和127之间，更好的代码是将值加载到寄存器中， 使用寄存器。这是因为加载到寄存器中可以由@samp{moveq}指令来完成。 我们对此通过定义字母@samp{K}来表示任意范围超出-128和127的整数， 然后在操作数约束中指定@samp{Ks}。

@cindex @samp{g} in constraint
@item @samp{g}
@en Any register, memory or immediate integer operand is allowed, except for
@en registers that are not general registers.
任何寄存器，内存或整数立即数，除了不是通用寄存器的寄存器。 

@cindex @samp{X} in constraint
@item @samp{X}
@ifset INTERNALS
@en Any operand whatsoever is allowed, even if it does not satisfy
@en @code{general_operand}.  This is normally used in the constraint of
@en a @code{match_scratch} when certain alternatives will not actually
@en require a scratch register.
任何操作数都被允许，即使其不满足@code{general_operand}。 这通常用于@code{match_scratch}的约束中，当一些的可选项实际上不需要scratch寄存器的时候。 
@end ifset

@ifclear INTERNALS
Any operand whatsoever is allowed.
@end ifclear

@cindex @samp{0} in constraint
@cindex digits in constraint
@item @samp{0}, @samp{1}, @samp{2}, @dots{} @samp{9}
@en An operand that matches the specified operand number is allowed.  If a
@en digit is used together with letters within the same alternative, the
@en digit should come last.
匹配指定操作数编号的操作数。如果数字与字母一起使用，则数字应该放在最后。

@en This number is allowed to be more than a single digit.  If multiple
@en digits are encountered consecutively, they are interpreted as a single
@en decimal integer.  There is scant chance for ambiguity, since to-date
@en it has never been desirable that @samp{10} be interpreted as matching
@en either operand 1 @emph{or} operand 0.  Should this be desired, one
@en can use multiple alternatives instead.
该编号允许多于单个数字。如果多个数字连续的在一起， 则它们被解析为一个单独的十进制整数。很少会因此产生不明确，因为到目前为止， 还没有想要将@samp{10}解析为匹配操作数1或者0的。如果有这样的需要， 则可以使用多个可选项来替代。

@cindex matching constraint
@cindex constraint, matching
@en This is called a @dfn{matching constraint} and what it really means is
@en that the assembler has only a single operand that fills two roles
@en @ifset INTERNALS
@en considered separate in the RTL insn.  For example, an add insn has two
@en input operands and one output operand in the RTL, but on most CISC
@en @end ifset
@en @ifclear INTERNALS
@en which @code{asm} distinguishes.  For example, an add instruction uses
@en two input operands and an output operand, but on most CISC
@en @end ifclear
@en machines an add instruction really has only two operands, one of them an
@en input-output operand:
这被称为匹配约束，其实际上是指汇编器只有一个单独的操作数， 却在RTL insn中扮演两个角色。例如，add insn在RTL中具有两个输入操作数和一个输出操作数，但是多数CISC机器上，add指令实际上只有两个操作数，其中一个为输入输出操作数：

@smallexample
addl #35,r12
@end smallexample

@en Matching constraints are used in these circumstances.
@en More precisely, the two operands that match must include one input-only
@en operand and one output-only operand.  Moreover, the digit must be a
@en smaller number than the number of the operand that uses it in the
@en constraint.
匹配约束被用于这些情况。更确切的说， 匹配的两个操作数必须包括一个只作输入的操作数和一个只作输出的操作数。

@en @ifset INTERNALS
@en For operands to match in a particular case usually means that they
@en are identical-looking RTL expressions.  But in a few special cases
@en specific kinds of dissimilarity are allowed.  For example, @code{*x}
@en as an input operand will match @code{*x++} as an output operand.
@en For proper results in such cases, the output template should always
@en use the output-operand's number when printing the operand.
@en @end ifset

@cindex load address instruction
@cindex push address instruction
@cindex address constraints
@cindex @samp{p} in constraint
@item @samp{p}
@en An operand that is a valid memory address is allowed.  This is
@en for ``load address'' and ``push address'' instructions.
允许一个为有效内存地址的操作数。这用于“加载地址”和“地址压栈”指令。

@findex address_operand
@en @samp{p} in the constraint must be accompanied by @code{address_operand}
@en as the predicate in the @code{match_operand}.  This predicate interprets
@en the mode specified in the @code{match_operand} as the mode of the memory
@en reference for which the address would be valid.
约束中的@samp{p}必须由@code{match_operand}中的作为断言的@code{address_operand}协同工作。该断言将@code{match_operand}中指定的机器模式解析为地址有效的内存引用的机器模式。

@cindex other register constraints
@cindex extensible constraints
@item @var{other-letters}
@en Other letters can be defined in machine-dependent fashion to stand for
@en particular classes of registers or other arbitrary operand types.
@en @samp{d}, @samp{a} and @samp{f} are defined on the 68000/68020 to stand
@en for data, address and floating point registers.
其它字母可以采用机器相关的方式被定义，用于代表寄存器的特定类别或者其它任意的操作数类型。@samp{d}, @samp{a}和@samp{f}在68000/68020被定义用来代表数据，地址和浮点寄存器。
@end table

@ifset INTERNALS
@en In order to have valid assembler code, each operand must satisfy
@en its constraint.  But a failure to do so does not prevent the pattern
@en from applying to an insn.  Instead, it directs the compiler to modify
@en the code so that the constraint will be satisfied.  Usually this is
@en done by copying an operand into a register.
为了具有有效的汇编代码，每个操作数必须满足它的约束。但是如果不满足的话，也不会阻止将该指令模式应用到insn上。替代的，它会指示编译器去修改代码以至于约束将被满足。通常，这是通过将一个操作数复制到寄存器中来完成的。

@en Contrast, therefore, the two instruction patterns that follow:
因此，对比下面的两条指令模式：

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "general_operand" "r")))]
  ""
  "@dots{}")
@end smallexample

@noindent
@en which has two operands, one of which must appear in two places, and
其具有两个操作数，其中一个必须出现在两个位置，

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_operand:SI 1 "general_operand" "0")
                 (match_operand:SI 2 "general_operand" "r")))]
  ""
  "@dots{}")
@end smallexample

@en which has three operands, two of which are required by a constraint to be
@en identical.  If we are considering an insn of the form
其具有三个操作数，其中两个通过约束被要求为是相同的。如果我们考虑如下形式的一条insn 

@smallexample
(insn @var{n} @var{prev} @var{next}
  (set (reg:SI 3)
       (plus:SI (reg:SI 6) (reg:SI 109)))
  @dots{})
@end smallexample
@noindent

@en the first pattern would not apply at all, because this insn does not
@en contain two identical subexpressions in the right place.  The pattern would
@en say, ``That does not look like an add instruction; try other patterns''.
@en The second pattern would say, ``Yes, that's an add instruction, but there
@en is something wrong with it''.  It would direct the reload pass of the
@en compiler to generate additional insns to make the constraint true.  The
@en results might look like this:
第一个指令模式将根本不会被应用，因为该insn不在合适的地方包含两个相同的子表达式。指令模式会说“这看起来不像是一条加法指令；试一下其它模式”。第二个指令模式将会说，“是的，这是一条加法指令，但是有些问题”。它将指使编译器的重载过程生成额外的insn，使得约束为真。结果可能看起来像：

@smallexample
(insn @var{n2} @var{prev} @var{n}
  (set (reg:SI 3) (reg:SI 6))
  @dots{})

(insn @var{n} @var{n2} @var{next}
  (set (reg:SI 3)
       (plus:SI (reg:SI 3) (reg:SI 109)))
  @dots{})
@end smallexample

@en It is up to you to make sure that each operand, in each pattern, has
@en constraints that can handle any RTL expression that could be present for
@en that operand.  (When multiple alternatives are in use, each pattern must,
@en for each possible combination of operand expressions, have at least one
@en alternative which can handle that combination of operands.)  The
@en constraints don't need to @emph{allow} any possible operand---when this is
@en the case, they do not constrain---but they must at least point the way to
@en reloading any possible operand so that it will fit.
你必须确保每个操作数，在每个指令模式中，具有能够处理可能会出现的任何RTL表达式的约束。（当使用多个可选项时，每个指令模式，对于每个可能的操作数表达式组合，必须至少具有一个可选项可以处理该操作数的组合。）约束不需要允许任何可能的操作数——如果是这种情况，它们就不做约束了——但是它们必须至少指出可以加载任何可能操作数，使得适合约束的方法。

@itemize @bullet
@item
@en If the constraint accepts whatever operands the predicate permits,
@en there is no problem: reloading is never necessary for this operand.
如果约束接受断言允许的任何操作数，则没有问题：重载对于该操作数将没有必要。

@en For example, an operand whose constraints permit everything except
@en registers is safe provided its predicate rejects registers.
例如，操作数对于它的约束允许除了寄存器以外的任何事物，如果它的断言不接受寄存器的话，这样是安全的。

@en An operand whose predicate accepts only constant values is safe
@en provided its constraints include the letter @samp{i}.  If any possible
@en constant value is accepted, then nothing less than @samp{i} will do;
@en if the predicate is more selective, then the constraints may also be
@en more selective.
操作数对于断言只接受常量时，如果它的约束包含字母@samp{i}，则是安全的。如果任何可能的常量都被接受，则可以使用@samp{i}；如果断言具有更多的选择性，则约束也可以具有更多的选择性。

@item
@en Any operand expression can be reloaded by copying it into a register.
@en So if an operand's constraints allow some kind of register, it is
@en certain to be safe.  It need not permit all classes of registers; the
@en compiler knows how to copy a register into another register of the
@en proper class in order to make an instruction valid.
任何操作数表达式可以通过复制到寄存器中来进行重载。所以如果一个操作数的约束允许某种寄存器，其当然是安全的。它不需要允许所有类型的寄存器；编译器知道为了使指令有效，如何将一个寄存器复制到另一个合适类别的寄存器中。 

@cindex nonoffsettable memory reference
@cindex memory reference, nonoffsettable
@item
@en A nonoffsettable memory reference can be reloaded by copying the
@en address into a register.  So if the constraint uses the letter
@en @samp{o}, all memory references are taken care of.
非偏移表的内存引用可以通过将地址复制到寄存器中来重载。所以如果约束使用字母@samp{o}，则所有内存引用将被照顾到。

@item
@en A constant operand can be reloaded by allocating space in memory to
@en hold it as preinitialized data.  Then the memory reference can be used
@en in place of the constant.  So if the constraint uses the letters
@en @samp{o} or @samp{m}, constant operands are not a problem.
常量操作数可以通过在内存中分配空间作为预先被初始化的数据来重载。然后可以使用内存引用。所以如果约束使用字母@samp{o}或者@samp{m}，则常量操作数不是问题。

@item
@en If the constraint permits a constant and a pseudo register used in an insn
@en was not allocated to a hard register and is equivalent to a constant,
@en the register will be replaced with the constant.  If the predicate does
@en not permit a constant and the insn is re-recognized for some reason, the
@en compiler will crash.  Thus the predicate must always recognize any
@en objects allowed by the constraint.
如果约束允许的常量和伪寄存器没有被分配到硬件寄存器中，并且等价于一个常量，则寄存器将被常量替换。如果断言不允许常量并且insn出于某种原因被识别了，则编译器将会崩溃。因此断言必须总是能够识别任何被约束允许的对象。
@end itemize

@en If the operand's predicate can recognize registers, but the constraint does
@en not permit them, it can make the compiler crash.  When this operand happens
@en to be a register, the reload pass will be stymied, because it does not know
@en how to copy a register temporarily into memory.
如果操作数的断言能够识别寄存器，但是约束不允许它们，则能够使编译器崩溃。当该操作数正好是寄存器时，重载过程将被打乱，因为它不知道如何将寄存器临时复制到内存中。

@en If the predicate accepts a unary operator, the constraint applies to the
@en operand.  For example, the MIPS processor at ISA level 3 supports an
@en instruction which adds two registers in @code{SImode} to produce a
@en @code{DImode} result, but only if the registers are correctly sign
@en extended.  This predicate for the input operands accepts a
@en @code{sign_extend} of an @code{SImode} register.  Write the constraint
@en to indicate the type of register that is required for the operand of the
@en @code{sign_extend}.
如果断言接受一元操作符，约束将被应用到操作数上。例如，MIPS处理器在ISA3级时，支持一条指令，其将两个@code{SImode}的寄存器相加产生一个 @code{DImode}的结果，但是必须寄存器能够被正确的符号扩展。该断言对于输入操作数接受一个@code{SImode}寄存器的@code{sign_extend}。将约束写成指示寄存器的类型需要为@code{sign_extend}的操作数。

@end ifset
@en @node Multi-Alternative
@en @subsection Multiple Alternative Constraints
@node Multi-Alternative
@subsection 多个可选的约束
@cindex multiple alternative constraints

@ifset INTERNALS
@en Sometimes a single instruction has multiple alternative sets of possible
@en operands.  For example, on the 68000, a logical-or instruction can combine
@en register or an immediate value into memory, or it can combine any kind of
@en operand into a register; but it cannot combine one memory location into
@en another.
有时单个指令具有多个可选的操作数集。例如，在68000上，
一个逻辑或指令可以将寄存器或者立即数的值组合到内存中，
或者可以组合任何类型的操作数到寄存器中；但是不能将一个内存位置组合到另一个中。

@en These constraints are represented as multiple alternatives.  An alternative
@en can be described by a series of letters for each operand.  The overall
@en constraint for an operand is made from the letters for this operand
@en from the first alternative, a comma, the letters for this operand from
@en the second alternative, a comma, and so on until the last alternative.
@en Here is how it is done for fullword logical-or on the 68000:
这些约束作为多个可选项来表示。
一个可选项可以通过针对每个操作数的一系列字母来描述。
一个操作数的总的约束由该操作数第一个可选项的字母，逗号，
该操作数的第二个可选项，逗号，等等直到最后一个可选项组成。
这里有一个在68000上全字逻辑或的表示：

@smallexample
(define_insn "iorsi3"
  [(set (match_operand:SI 0 "general_operand" "=m,d")
        (ior:SI (match_operand:SI 1 "general_operand" "%0,0")
                (match_operand:SI 2 "general_operand" "dKs,dmKs")))]
  @dots{})
@end smallexample

@en The first alternative has @samp{m} (memory) for operand 0, @samp{0} for
@en operand 1 (meaning it must match operand 0), and @samp{dKs} for operand
@en 2.  The second alternative has @samp{d} (data register) for operand 0,
@en @samp{0} for operand 1, and @samp{dmKs} for operand 2.  The @samp{=} and
@en @samp{%} in the constraints apply to all the alternatives; their
@en meaning is explained in the next section (@pxref{Class Preferences}).
第一个可选项具有操作数0的@samp{m} (memory)，操作数1的@samp{0}（意味着其必须匹配 操作数0）和操作数2的@samp{dKs}。第二个可选项具有操作数0的@samp{d} (data register)，操作数1的@samp{0}和操作数2的@samp{dmKs}。 约束中的@samp{=}和@samp{%}应用于所有的可选项； 它们的含义在下一节介绍（@pxref{Class Preferences}）。
@end ifset

@en @c FIXME Is this ? and ! stuff of use in asm()?  If not, hide unless INTERNAL
@en If all the operands fit any one alternative, the instruction is valid.
@en Otherwise, for each alternative, the compiler counts how many instructions
@en must be added to copy the operands so that that alternative applies.
@en The alternative requiring the least copying is chosen.  If two alternatives
@en need the same amount of copying, the one that comes first is chosen.
@en These choices can be altered with the @samp{?} and @samp{!} characters:
如果所有操作数适合任意一个可选项，则指令为有效的。否则，对于每个可选项，编译器计算要复制操作数使得可选项可以使用所需要增加的指令个数。需要的复制最少的可选项将被选中。如果两个可选项需要相同数目的复制，则选择前面的。这些选择可以通过字符@samp{?}和@samp{!}来改变：

@table @code
@cindex @samp{?} in constraint
@cindex question mark
@item ?
@en Disparage slightly the alternative that the @samp{?} appears in,
@en as a choice when no alternative applies exactly.  The compiler regards
@en this alternative as one unit more costly for each @samp{?} that appears
@en in it.
轻微降低@samp{?}出现的可选项，当没有可选项被确切应用时，才将其作为选择。编译器将该可选项的花销认为高出一个单元。 

@cindex @samp{!} in constraint
@cindex exclamation point
@item !
@en Disparage severely the alternative that the @samp{!} appears in.
@en This alternative can still be used if it fits without reloading,
@en but if reloading is needed, some other alternative will be used.
@en @end table
严格降低@samp{!}出现的可选项，当该选项没有reloading的时候还可以被使用， 但是如果需要reloading，则将使用其它可选项。 
@end table

@ifset INTERNALS
@en When an insn pattern has multiple alternatives in its constraints, often
@en the appearance of the assembler code is determined mostly by which
@en alternative was matched.  When this is so, the C code for writing the
@en assembler code can use the variable @code{which_alternative}, which is
@en the ordinal number of the alternative that was actually satisfied (0 for
@en the first, 1 for the second alternative, etc.).  @xref{Output Statement}.
当insn指令模式在其约束中具有多个可选项时， 经常会出现通过哪个可选项被匹配而决定使用使用什么汇编代码的情况。这时， 输写汇编代码的C代码可以使用变量@code{which_alternative}， 其为实际被满足的可选项的顺序编号（0对应第一个，1对应第二个，等等）。@xref{Output Statement}。
@end ifset

@ifset INTERNALS
@en @node Class Preferences
@en @subsection Register Class Preferences
@node Class Preferences
@subsection 寄存器类别优先选择
@cindex class preference constraints
@cindex register class preference constraints

@cindex voting between constraint alternatives
@en The operand constraints have another function: they enable the compiler
@en to decide which kind of hardware register a pseudo register is best
@en allocated to.  The compiler examines the constraints that apply to the
@en insns that use the pseudo register, looking for the machine-dependent
@en letters such as @samp{d} and @samp{a} that specify classes of registers.
@en The pseudo register is put in whichever class gets the most ``votes''.
@en The constraint letters @samp{g} and @samp{r} also vote: they vote in
@en favor of a general register.  The machine description says which registers
@en are considered general.
操作数约束还具有另一个功能：它们使编译器可以决定为伪寄存器分配哪种硬件寄存器。编译器检查应用到使用伪寄存器的insn的约束，查看机器相关的指定寄存器类别的字母像@samp{d}和@samp{a}。伪寄存器被放在获得最多“票数”的类别中。约束字母@samp{g}和@samp{r}也要投票：它们在通用寄存器方面进行投票。机器描述告诉哪种寄存器被认为是通用的。

@en Of course, on some machines all registers are equivalent, and no register
@en classes are defined.  Then none of this complexity is relevant.
当然，在一些机器上所有寄存器都是等价的，并且没有定义寄存器类别。那么就相应的没有这么复杂了。
@end ifset

@en @node Modifiers
@en @subsection Constraint Modifier Characters
@node Modifiers
@subsection constraint修饰符
@cindex modifiers in constraints
@cindex constraint modifier characters

@en @c prevent bad page break with this line
@en Here are constraint modifier characters.
@en prevent bad page break with this line
这里是约束修饰符。

@table @samp
@cindex @samp{=} in constraint
@item =
@en Means that this operand is write-only for this instruction: the previous
@en value is discarded and replaced by output data.
意味着该指令的该操作数为只写的：先前的值将被丢弃并且由输出数据替换。 

@cindex @samp{+} in constraint
@item +
@en Means that this operand is both read and written by the instruction.
意味着该操作数可以由指令读和写。

@en When the compiler fixes up the operands to satisfy the constraints,
@en it needs to know which operands are inputs to the instruction and
@en which are outputs from it.  @samp{=} identifies an output; @samp{+}
@en identifies an operand that is both input and output; all other operands
@en are assumed to be input only.
当编译器修订操作数来满足约束时，它需要知道哪些操作数为指令的输入以及哪些为它的输出。@samp{=}表示一个输出；@samp{+}表示一个操作数同时为输入和输出；所有其它操作数将被认为只是输入。

@en If you specify @samp{=} or @samp{+} in a constraint, you put it in the
@en first character of the constraint string.
如果你指定了@samp{=}或者@samp{+}，你要将它作为约束字符串的第一个字符。

@cindex @samp{&} in constraint
@cindex earlyclobber operand
@item &
@en Means (in a particular alternative) that this operand is an
@en @dfn{earlyclobber} operand, which is modified before the instruction is
@en finished using the input operands.  Therefore, this operand may not lie
@en in a register that is used as an input operand or as part of any memory
@en address.
意味着（在一个特别的可选项中）该操作数为一个@dfn{earlyclobber}操作数，其在指令完成使用输入操作数之前就被修改了。因此该操作数可能不在被用作输入操作数或者用作任何内存地址的一部分的寄存器中。

@en @samp{&} applies only to the alternative in which it is written.  In
@en constraints with multiple alternatives, sometimes one alternative
@en requires @samp{&} while others do not.  See, for example, the
@en @samp{movdf} insn of the 68000.
@samp{&}只应用于其所在的可选项。在具有多个可选项的约束中，有时一个可选项需要@samp{&}，而其它的不需要。例如，参见68000的@samp{movdf} insn。

@en An input operand can be tied to an earlyclobber operand if its only
@en use as an input occurs before the early result is written.  Adding
@en alternatives of this form often allows GCC to produce better code
@en when only some of the inputs can be affected by the earlyclobber.
@en See, for example, the @samp{mulsi3} insn of the ARM@.
一个输入操作数可以被限定为一个earlyclobber操作数，如果它唯一的作为输入的使用发生在早期结果被写出之前。增加这种形式的可选项经常可以允许GCC来产生更好的代码，当只有一些输出可以被earlyclobber影响时。例如，参见ARM的@samp{mulsi3} insn。

@en @samp{&} does not obviate the need to write @samp{=}.
@samp{&}不排除对@samp{=}的需要。

@cindex @samp{%} in constraint
@item %
@en Declares the instruction to be commutative for this operand and the
@en following operand.  This means that the compiler may interchange the
@en two operands if that is the cheapest way to make all operands fit the
@en constraints.
声明指令对于该操作数和随后的操作数是可交换的。这意味着编译器可以交换两操作数，如果有更廉价的方式来使得所有操作数都适合约束。
@ifset INTERNALS
@en This is often used in patterns for addition instructions
@en that really have only two operands: the result must go in one of the
@en arguments.  Here for example, is how the 68000 halfword-add
@en instruction is defined:
这经常被用于实际上只有两个操作数的加法指令中：结果必须放在一个参数中。这里有个例子，是68000半字加指令如何被定义的： 
 
@smallexample
(define_insn "addhi3"
  [(set (match_operand:HI 0 "general_operand" "=m,r")
     (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
              (match_operand:HI 2 "general_operand" "di,g")))]
  @dots{})
@end smallexample
@end ifset

@en GCC can only handle one commutative pair in an asm; if you use more,
@en the compiler may fail.  Note that you need not use the modifier if
@en the two alternatives are strictly identical; this would only waste
@en time in the reload pass.  The modifier is not operational after
@en register allocation, so the result of @code{define_peephole2}
@en and @code{define_split}s performed after reload cannot rely on
@en @samp{%} to make the intended insn match.
GCC只能处理在asm中的一个可交换对；如果你有更多的，编译器将会失败。注意如果两个可选项严格相同，则不需要使用该修饰符；这只会在重载过程浪费时间。该修饰符在寄存器分配之后，是不可操作的，所以在重载之后执行的@code{define_peephole2}和@code{define_split}的结果不能依赖@samp{%}来进行insn匹配。

@cindex @samp{#} in constraint
@item #
@en Says that all following characters, up to the next comma, are to be
@en ignored as a constraint.  They are significant only for choosing
@en register preferences.
表示所有后续的字符，直到下一个逗号，作为约束都被忽略掉。它们只对选择寄存器优先时有意义。 

@cindex @samp{*} in constraint
@item *
@en Says that the following character should be ignored when choosing
@en register preferences.  @samp{*} has no effect on the meaning of the
@en constraint as a constraint, and no effect on reloading.
表示后续字符在选择寄存器优先时应该被忽略掉。@samp{*}对于重载没有影响。

@ifset INTERNALS
@en Here is an example: the 68000 has an instruction to sign-extend a
@en halfword in a data register, and can also sign-extend a value by
@en copying it into an address register.  While either kind of register is
@en acceptable, the constraints on an address-register destination are
@en less strict, so it is best if register allocation makes an address
@en register its goal.  Therefore, @samp{*} is used so that the @samp{d}
@en constraint letter (for data register) is ignored when computing
@en register preferences.
这里有一个例子：68000有一条指令，用于在数据寄存器中符号扩展一个半字，并且还可以通过将其复制到一个地址寄存器中来符号扩展一个值。当每种寄存器都可以被接受时，对于地址寄存器的约束相对不是很严格，所以最好是寄存器分配将地址寄存器作为其目标。因此，@samp{*}被使用，以至于@samp{d}约束字母（数据寄存器）被忽略，当计算寄存器优先时。

@smallexample
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=*d,a")
        (sign_extend:SI
         (match_operand:HI 1 "general_operand" "0,g")))]
  @dots{})
@end smallexample
@end ifset
@end table

@en @node Machine Constraints
@en @subsection Constraints for Particular Machines
@node Machine Constraints
@subsection 机器特定的约束
@cindex machine specific constraints
@cindex constraints, machine specific

@en Whenever possible, you should use the general-purpose constraint letters
@en in @code{asm} arguments, since they will convey meaning more readily to
@en people reading your code.  Failing that, use the constraint letters
@en that usually have very similar meanings across architectures.  The most
@en commonly used constraints are @samp{m} and @samp{r} (for memory and
@en general-purpose registers respectively; @pxref{Simple Constraints}), and
@en @samp{I}, usually the letter indicating the most common
@en immediate-constant format.
只要可能，就应该在@code{asm}参数中使用通用目的的约束字母， 因为它们可以向阅读你的代码的人们传达更加可读的意思。如果无法做到， 则使用在不同体系结构中通常具有非常相似的意思的约束字母。 最通用的约束为@samp{m}和@samp{r}（分别用于内存和通用寄存器； @pxref{Simple Constraints}， 以及@samp{I}，通常用于指示最常见的立即数常量格式。

@en Each architecture defines additional constraints.  These constraints
@en are used by the compiler itself for instruction generation, as well as
@en for @code{asm} statements; therefore, some of the constraints are not
@en particularly useful for @code{asm}.  Here is a summary of some of the
@en machine-dependent constraints available on some particular machines;
@en it includes both constraints that are useful for @code{asm} and
@en constraints that aren't.  The compiler source file mentioned in the
@en table heading for each architecture is the definitive reference for
@en the meanings of that architecture's constraints.
每个体系结构定义了额外的约束。这些约束被编译器本身使用，用于指令生成， 同时也用于@code{asm}语句；因此，一些约束对于@code{asm}并不是很有用处。 这里有一个总结，关于在一些特定机器上使用的机器相关的约束； 包括对@code{asm}有用处的和没有用处的。 在表中提到的针对每个体系结构的编译器原文件，是该体系结构的约束的定义参考。

@table @emph
@item ARM family---@file{config/arm/arm.h}
@table @code
@item f
@en Floating-point register
浮点寄存器
 
@item w
@en VFP floating-point register
VFP浮点寄存器

@item F
@en One of the floating-point constants 0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0
@en or 10.0
浮点常量0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0或者10.0

@item G
@en Floating-point constant that would satisfy the constraint @samp{F} if it
@en were negated
浮点常量，其负数满足约束@samp{F}

@item I
@en Integer that is valid as an immediate operand in a data processing
@en instruction.  That is, an integer in the range 0 to 255 rotated by a
@en multiple of 2
可以在数据处理指令中作为立即数的整数。即，0到255范围的整数，被2的倍数进行旋转

@item J
@en Integer in the range @minus{}4095 to 4095
范围在@minus{}4095到4095的整数

@item K
@en Integer that satisfies constraint @samp{I} when inverted (ones complement)
当倒置后，满足约束@samp{I}的整数

@item L
@en Integer that satisfies constraint @samp{I} when negated (twos complement)
当求负后，满足约束@samp{I}的整数

@item M
@en Integer in the range 0 to 32
范围在0到32的整数

@item Q
@en A memory reference where the exact address is in a single register
@en (`@samp{m}' is preferable for @code{asm} statements)
一个内存引用，其确切的地址在单个寄存器中（`@samp{m}'可以用于@code{asm}语句）

@item R
@en An item in the constant pool
在常量池中的项

@item S
@en A symbol in the text segment of the current file
在当前文件中text段中的符号

@item Uv
@en A memory reference suitable for VFP load/store insns (reg+constant offset)
适于VFP加载/存储insn（寄存器+常量 偏移量）的内存引用

@item Uy
@en A memory reference suitable for iWMMXt load/store instructions.
适于iWMMXt加载/存储指令的内存引用

@item Uq
@en A memory reference suitable for the ARMv4 ldrsb instruction.
适于ARMv4 ldrsb指令的内存引用
@end table

@item AVR family---@file{config/avr/constraints.md}
@table @code
@item l
@en Registers from r0 to r15
寄存器r0到r15

@item a
@en Registers from r16 to r23
寄存器r16到r23

@item d
@en Registers from r16 to r31
寄存器r16到r31

@item w
@en Registers from r24 to r31.  These registers can be used in @samp{adiw} command
寄存器r24到r31。这些寄存器可以用于@samp{adiw}命令

@item e
@en Pointer register (r26--r31)
指针寄存器(r26--r31)

@item b
@en Base pointer register (r28--r31)
基指针寄存器(r28--r31)

@item q
@en Stack pointer register (SPH:SPL)
栈指针寄存器(SPH:SPL)

@item t
@en Temporary register r0
临时寄存器r0

@item x
@en Register pair X (r27:r26)
寄存器对X (r27:r26)

@item y
@en Register pair Y (r29:r28)
寄存器对Y (r29:r28)

@item z
@en Register pair Z (r31:r30)
寄存器对Z (r31:r30)

@item I
@en Constant greater than @minus{}1, less than 64
常量，大于@minus{}1，小于64

@item J
@en Constant greater than @minus{}64, less than 1
常量，大于@minus{}64，小于1

@item K
@en Constant integer 2
常量整数2

@item L
@en Constant integer 0
常量整数0

@item M
@en Constant that fits in 8 bits
8位的常量

@item N
@en Constant integer @minus{}1
常量整数@minus{}1

@item O
@en Constant integer 8, 16, or 24
常量整数8，16或24

@item P
@en Constant integer 1
常量整数1

@item G
@en A floating point constant 0.0
浮点常量0.0

@item R
@en Integer constant in the range @minus{}6 @dots{} 5.
整数常量，范围在-6 @dots{} 5

@item Q
@en A memory address based on Y or Z pointer with displacement.
一个内存地址，基于Y或者Z指针，加上一个位移
@end table

@item CRX Architecture---@file{config/crx/crx.h}
@table @code

@item b
@en Registers from r0 to r14 (registers without stack pointer)
寄存器从r0到r14（不含栈指针）

@item l
@en Register r16 (64-bit accumulator lo register)
寄存器r16（64位累加器lo寄存器）

@item h
@en Register r17 (64-bit accumulator hi register)
寄存器r17（64位累加器hi寄存器）

@item k
@en Register pair r16-r17. (64-bit accumulator lo-hi pair)
寄存器对r16-r17（64位累加器lo-hi寄存器对）

@item I
@en Constant that fits in 3 bits
3位的常量

@item J
@en Constant that fits in 4 bits
4位的常量

@item K
@en Constant that fits in 5 bits
5位的常量

@item L
@en Constant that is one of @minus{}1, 4, @minus{}4, 7, 8, 12, 16, 20, 32, 48
常量-1, 4, -4, 7, 8, 12, 16, 20, 32, 48

@item G
@en Floating point constant that is legal for store immediate
浮点常量，合法的可以用于存储的立即数。
@end table

@item Hewlett-Packard PA-RISC---@file{config/pa/pa.h}
@table @code
@item a
@en General register 1
通用寄存器1

@item f
@en Floating point register
浮点寄存器

@item q
@en Shift amount register
移位数量寄存器

@item x
@en Floating point register (deprecated)
浮点寄存器(不推荐的)

@item y
@en Upper floating point register (32-bit), floating point register (64-bit)
高位部分浮点寄存器（32位），浮点寄存器（64位）

@item Z
@en Any register
任何寄存器

@item I
@en Signed 11-bit integer constant
有符号的11位整数常量

@item J
@en Signed 14-bit integer constant
有符号的14位整数常量

@item K
@en Integer constant that can be deposited with a @code{zdepi} instruction
可以使用指令@code{zdepi}存放的整数常量

@item L
@en Signed 5-bit integer constant
有符号的5位整数常量

@item M
@en Integer constant 0
整数常量0

@item N
@en Integer constant that can be loaded with a @code{ldil} instruction
可以使用@code{ldil}指令加载的整数常量

@item O
@en Integer constant whose value plus one is a power of 2
整数常量，其值加上1便为2的幂

@item P
@en Integer constant that can be used for @code{and} operations in @code{depi}
@en and @code{extru} instructions
可以用于在@code{depi}和@code{extru}指令中@code{and}运算的整数常量

@item S
@en Integer constant 31
整数常量31

@item U
@en Integer constant 63
整数常量63

@item G
@en Floating-point constant 0.0
浮点常量0.0

@item A
@en A @code{lo_sum} data-linkage-table memory operand
一个@code{lo_sum} data-linkage-table内存操作数

@item Q
@en A memory operand that can be used as the destination operand of an
@en integer store instruction
可以用作整数存储指令的目的操作数的内存操作数

@item R
@en A scaled or unscaled indexed memory operand
缩放或者未缩放的索引内存操作数

@item T
@en A memory operand for floating-point loads and stores
浮点加载和存储的内存操作数

@item W
@en A register indirect memory operand
寄存器间接内存操作数
@end table

@item picoChip family---@file{picochip.h}
@table @code
@item k
@en Stack register.
栈寄存器

@item f
@en Pointer register.  A register which can be used to access memory without
@en supplying an offset.  Any other register can be used to access memory,
@en but will need a constant offset.  In the case of the offset being zero,
@en it is more efficient to use a pointer register, since this reduces code
@en size.
指针寄存器。可以用于访问内存，无需提供偏移量。任何其它寄存器可以用于访问内存，但需要一个常量偏移量。当偏移量为零的时候，使用指针寄存器会更有效，因为这将减少代码大小。

@item t
@en A twin register.  A register which may be paired with an adjacent
@en register to create a 32-bit register.
成对寄存器。相邻的两个寄存器，用来创建一个32位寄存器。

@item a
@en Any absolute memory address (e.g., symbolic constant, symbolic
@en constant + offset).
任何绝对内存地址（例如，符号常量，符号常量+偏移量）

@item I
@en 4-bit signed integer.
4位有符号整数

@item J
@en 4-bit unsigned integer.
4位无符号整数

@item K
@en 8-bit signed integer.
8位有符号整数

@item M
@en Any constant whose absolute value is no greater than 4-bits.
任何绝对值不大于4位的常量

@item N
@en 10-bit signed integer
10位有符号整数

@item O
@en 16-bit signed integer.
16位有符号整数

@end table

@item PowerPC and IBM RS6000---@file{config/rs6000/rs6000.h}
@table @code
@item b
@en Address base register
基址寄存器

@item d
Floating point register (containing 64-bit value)

@item f
@en Floating point register (containing 32-bit value)
浮点寄存器

@item v
@en Altivec vector register
向量寄存器

@item wd
VSX vector register to hold vector double data

@item wf
VSX vector register to hold vector float data

@item ws
VSX vector register to hold scalar float data

@item wa
Any VSX register

@item h
@en @samp{MQ}, @samp{CTR}, or @samp{LINK} register
@samp{MQ}, @samp{CTR}或者@samp{LINK}寄存器

@item q
@en @samp{MQ} register
@samp{MQ}寄存器

@item c
@en @samp{CTR} register
@samp{CTR}寄存器

@item l
@en @samp{LINK} register
@samp{LINK}寄存器

@item x
@en @samp{CR} register (condition register) number 0
@samp{CR}寄存器(条件寄存器)编号0

@item y
@en @samp{CR} register (condition register)
@samp{CR}寄存器(条件寄存器)

@item z
@en @samp{XER[CA]} carry bit (part of the XER register)
@samp{FPMEM}栈内存，用于FPR-GPR传送

@item I
@en Signed 16-bit constant
有符号16位常量

@item J
@en Unsigned 16-bit constant shifted left 16 bits (use @samp{L} instead for
@en @code{SImode} constants)
无符号16位常量，向左移16位（使用@samp{L}来替代常量）

@item K
@en Unsigned 16-bit constant
无符号16位常量

@item L
@en Signed 16-bit constant shifted left 16 bits
有符号16位常量，向左移16位

@item M
@en Constant larger than 31
大于31的常量

@item N
@en Exact power of 2
2的幂

@item O
@en Zero
零

@item P
@en Constant whose negation is a signed 16-bit constant
常量，其负数为有符号的16位常量

@item G
@en Floating point constant that can be loaded into a register with one
@en instruction per word
浮点常量，可以使用一个字的指令将其加载到寄存器中

@item H
@en Integer/Floating point constant that can be loaded into a register using
@en three instructions
整数/浮点常量，可以使用三条指令将其加载到寄存器中

@item m
Memory operand.  
Normally, @code{m} does not allow addresses that update the base register.
If @samp{<} or @samp{>} constraint is also used, they are allowed and
therefore on PowerPC targets in that case it is only safe
to use @samp{m<>} in an @code{asm} statement if that @code{asm} statement
accesses the operand exactly once.  The @code{asm} statement must also
use @samp{%U@var{<opno>}} as a placeholder for the ``update'' flag in the
corresponding load or store instruction.  For example:

@smallexample
asm ("st%U0 %1,%0" : "=m<>" (mem) : "r" (val));
@end smallexample

is correct but:

@smallexample
asm ("st %1,%0" : "=m<>" (mem) : "r" (val));
@end smallexample

is not.

@item es
A ``stable'' memory operand; that is, one which does not include any
automodification of the base register.  This used to be useful when
@samp{m} allowed automodification of the base register, but as those are now only
allowed when @samp{<} or @samp{>} is used, @samp{es} is basically the same
as @samp{m} without @samp{<} and @samp{>}.

@item Q
@en Memory operand that is an offset from a register (it is usually better
@en to use @samp{m} or @samp{es} in @code{asm} statements)
内存操作数，相对于寄存器的偏移量(@samp{m}适用于@code{asm}语句)

@item Z
@en Memory operand that is an indexed or indirect from a register (it is
@en usually better to use @samp{m} or @samp{es} in @code{asm} statements)
内存操作数，来自寄存器的一个索引或者间接访问(@samp{m}适用于@code{asm}语句)

@item R
@en AIX TOC entry
AIX TOC项

@item a
@en Address operand that is an indexed or indirect from a register (@samp{p} is
@en preferable for @code{asm} statements)
地址操作数，来自寄存器的一个索引或者间接访问(@samp{p}适用于@code{asm}语句)

@item S
@en Constant suitable as a 64-bit mask operand
适于作64位掩码操作数的常量

@item T
@en Constant suitable as a 32-bit mask operand
适于作32位掩码操作数的常量

@item U
@en System V Release 4 small data area reference
System V Release 4对小数据区域的引用

@item t
@en AND masks that can be performed by two rldic@{l, r@} instructions
AND掩码，可以通过两条rldic@{l, r@}指令执行

@item W
@en Vector constant that does not require memory
不需要内存的向量常量

@item j
@en Vector constant that is all zeros.
@end table

@item Intel 386---@file{config/i386/constraints.md}
@table @code
@item R
@en Legacy register---the eight integer registers available on all
@en i386 processors (@code{a}, @code{b}, @code{c}, @code{d},
@en @code{si}, @code{di}, @code{bp}, @code{sp}).
遗留的寄存---八个在所有i386处理上都可用的寄存器(@code{a}, @code{b}, @code{c}, @code{d},
@code{si}, @code{di}, @code{bp}, @code{sp})。

@item q
@en Any register accessible as @code{@var{r}l}.  In 32-bit mode, @code{a},
@en @code{b}, @code{c}, and @code{d}; in 64-bit mode, any integer register.
任何可以作为@code{@var{r}l}访问的寄存器。在32位机器模式中，为@code{a}, @code{b}, @code{c}和@code{d}; 在64位机器模式中，为任何整数寄存器。

@item Q
@en Any register accessible as @code{@var{r}h}: @code{a}, @code{b},
@en @code{c}, and @code{d}.
任何可以作为@code{@var{r}h}来访问的寄存器：@code{a}, @code{b}, @code{c}和@code{d}。

@ifset INTERNALS
@item l
@en Any register that can be used as the index in a base+index memory
@en access: that is, any general register except the stack pointer.
@en @end ifset
任何在基址+索引的内存访问中，可以作为索引的寄存器：即除了栈指针以外的任何通用寄存器。
@end ifset

@item a
@en The @code{a} register.
寄存器@code{a}

@item b
@en The @code{b} register.
寄存器@code{b}

@item c
@en The @code{c} register.
寄存器@code{c}

@item d
@en The @code{d} register.
寄存器@code{d}

@item S
@en The @code{si} register.
寄存器@code{si}

@item D
@en The @code{di} register.
寄存器@code{di}

@item A
The @code{a} and @code{d} registers.  This class is used for instructions
that return double word results in the @code{ax:dx} register pair.  Single
word values will be allocated either in @code{ax} or @code{dx}.
For example on i386 the following implements @code{rdtsc}:

@smallexample
unsigned long long rdtsc (void)
@{
  unsigned long long tick;
  __asm__ __volatile__("rdtsc":"=A"(tick));
  return tick;
@}
@end smallexample

This is not correct on x86_64 as it would allocate tick in either @code{ax}
or @code{dx}.  You have to use the following variant instead:

@smallexample
unsigned long long rdtsc (void)
@{
  unsigned int tickl, tickh;
  __asm__ __volatile__("rdtsc":"=a"(tickl),"=d"(tickh));
  return ((unsigned long long)tickh << 32)|tickl;
@}
@end smallexample

@item f
@en Any 80387 floating-point (stack) register.
任何80387浮点（栈）寄存器

@item t
@en Top of 80387 floating-point stack (@code{%st(0)}).
80387浮点栈顶（@code{%st(0)}）

@item u
@en Second from top of 80387 floating-point stack (@code{%st(1)}).
从80387浮点栈顶起始的第二项(@code{%st(1)})

@item y
@en Any MMX register.
任何MMX寄存器

@item x
@en Any SSE register.
任何SSE寄存器

@item Yz
@en First SSE register (@code{%xmm0}).
第一个SSE寄存器(@code{%xmm0})

@ifset INTERNALS
@item Y2
@en Any SSE register, when SSE2 is enabled.
任何SSE寄存器，当SSE2被启用

@item Yi
@en Any SSE register, when SSE2 and inter-unit moves are enabled.
任何SSE寄存器，当SSE2和inter-unit move被启用

@item Ym
@en Any MMX register, when inter-unit moves are enabled.
任何MMX寄存器，当inter-unit move被启用
@end ifset

@item I
@en Integer constant in the range 0 @dots{} 31, for 32-bit shifts.
整数常量，范围在0 @dots{} 31，用于32位移位

@item J
@en Integer constant in the range 0 @dots{} 63, for 64-bit shifts.
整数常量，范围在0 @dots{} 63，用于64位移位

@item K
@en Signed 8-bit integer constant.
有符号8位整数常量

@item L
@en @code{0xFF} or @code{0xFFFF}, for andsi as a zero-extending move.
@code{0xFF}或者@code{0xFFFF}，用于andsi，作为零扩展move

@item M
@en 0, 1, 2, or 3 (shifts for the @code{lea} instruction).
0, 1, 2, 或者 3 (用于@code{lea}指令的移位)

@item N
@en Unsigned 8-bit integer constant (for @code{in} and @code{out} 
@en instructions).
无符号8位整数常量（用于@code{in}和@code{out}指令）

@ifset INTERNALS
@item O
@en Integer constant in the range 0 @dots{} 127, for 128-bit shifts.
整数常量，范围在0 @dots{} 127，用于64位移位
@end ifset

@item G
@en Standard 80387 floating point constant.
标准的80387浮点常量

@item C
@en Standard SSE floating point constant.
标准的SSE浮点常量

@item e
@en 32-bit signed integer constant, or a symbolic reference known
@en to fit that range (for immediate operands in sign-extending x86-64
@en instructions).
32位有符号整数常量，或者已知适合该范围的符号引用（用于有符号扩展x86-64指令的立即数）

@item Z
@en 32-bit unsigned integer constant, or a symbolic reference known
@en to fit that range (for immediate operands in zero-extending x86-64
@en instructions).
32位无符号整数常量，或者已知适合该范围的符号引用（用于零扩展x86-64指令的立即数）
@end table
 
@item Intel IA-64---@file{config/ia64/ia64.h}
@table @code
@item a
@en General register @code{r0} to @code{r3} for @code{addl} instruction
通用寄存器@code{r0}到@code{r3}，用于@code{addl}指令

@item b
@en Branch register
分支寄存器

@item c
@en Predicate register (@samp{c} as in ``conditional'')
断言寄存器(@samp{c} as in ``conditional'')

@item d
@en Application register residing in M-unit
在M-unit中的应用寄存器

@item e
@en Application register residing in I-unit
在I-unit中的应用寄存器

@item f
@en Floating-point register
浮点寄存器

@item m
@en Memory operand.  If used together with @samp{<} or @samp{>},
@en the operand can have postincrement and postdecrement which
@en require printing with @samp{%Pn} on IA-64.
内存操作数，记住在IA-64上，@samp{m}允许使用@samp{%Pn}打印的后增和后减方式。使用@samp{S}来禁止后增和后减。

@item G
@en Floating-point constant 0.0 or 1.0
浮点常量0.0或者1.0

@item I
@en 14-bit signed integer constant
14位有符号整数常量

@item J
@en 22-bit signed integer constant
22位有符号整数常量

@item K
@en 8-bit signed integer constant for logical instructions
8位有符号整数常量，用于逻辑指令

@item L
@en 8-bit adjusted signed integer constant for compare pseudo-ops
8位被调整的有符号整数常量，用于比较伪操作

@item M
@en 6-bit unsigned integer constant for shift counts
6位无符号整数常量，用于移位计数

@item N
@en 9-bit signed integer constant for load and store postincrements
9位有符号整数常量，用于后增方式的加载和存储

@item O
@en The constant zero
常量零

@item P
@en 0 or @minus{}1 for @code{dep} instruction
0 或者 @minus{}1，用于@code{dep}指令

@item Q
@en Non-volatile memory for floating-point loads and stores
非volatile内存，用于浮点加载和存储

@item R
@en Integer constant in the range 1 to 4 for @code{shladd} instruction
整数常量范围在1到4，用于@code{shladd}指令

@item S
@en Memory operand except postincrement and postdecrement.  This is
@en now roughly the same as @samp{m} when not used together with @samp{<}
@en or @samp{>}.
除了后增和后减以外的内存操作数
@end table

@item FRV---@file{config/frv/frv.h}
@table @code
@item a
@en Register in the class @code{ACC_REGS} (@code{acc0} to @code{acc7}).
类别@code{ACC_REGS}中的寄存器(@code{acc0} 到 @code{acc7}).

@item b
@en Register in the class @code{EVEN_ACC_REGS} (@code{acc0} to @code{acc7}).
类别@code{EVEN_ACC_REGS}中的寄存器(@code{acc0} 到 @code{acc7}).

@item c
@en Register in the class @code{CC_REGS} (@code{fcc0} to @code{fcc3} and
@en @code{icc0} to @code{icc3}).
类别@code{CC_REGS}中的寄存器(@code{fcc0} 到 @code{fcc3} 以及 @code{icc0} 到 @code{icc3}).

@item d
@en Register in the class @code{GPR_REGS} (@code{gr0} to @code{gr63}).
类别@code{GPR_REGS}中的寄存器(@code{gr0} 到 @code{gr63}).

@item e
@en Register in the class @code{EVEN_REGS} (@code{gr0} to @code{gr63}).
@en Odd registers are excluded not in the class but through the use of a machine
@en mode larger than 4 bytes.
类别@code{EVEN_REGS}中的寄存器(@code{gr0} 到 @code{gr63})。奇数寄存器不在该类中，但是可以使用大于4个字节的机器模式来使用。

@item f
@en Register in the class @code{FPR_REGS} (@code{fr0} to @code{fr63}).
类别@code{FPR_REGS}中的寄存器(@code{fr0} 到 @code{fr63}).

@item h
@en Register in the class @code{FEVEN_REGS} (@code{fr0} to @code{fr63}).
@en Odd registers are excluded not in the class but through the use of a machine
@en mode larger than 4 bytes.
类别@code{FEVEN_REGS}中的寄存器(@code{fr0} 到 @code{fr63})。奇数寄存器不在该类中，但是可以使用大于4个字节的机器模式来使用。

@item l
@en Register in the class @code{LR_REG} (the @code{lr} register).
类比@code{LR_REG}中的寄存器(@code{lr}寄存器)。

@item q
@en Register in the class @code{QUAD_REGS} (@code{gr2} to @code{gr63}).
@en Register numbers not divisible by 4 are excluded not in the class but through
@en the use of a machine mode larger than 8 bytes.
类别@code{QUAD_REGS}中的寄存器(@code{gr2} 到 @code{gr63})。无法被4整除的寄存器编号不在该类中，但是可以使用大于8个字节的机器模式来使用。

@item t
@en Register in the class @code{ICC_REGS} (@code{icc0} to @code{icc3}).
类别@code{ICC_REGS}中的寄存器(@code{icc0} 到 @code{icc3}).

@item u
@en Register in the class @code{FCC_REGS} (@code{fcc0} to @code{fcc3}).
类别@code{FCC_REGS}中的寄存器(@code{fcc0} 到 @code{fcc3}).

@item v
@en Register in the class @code{ICR_REGS} (@code{cc4} to @code{cc7}).
类别@code{ICR_REGS}中的寄存器(@code{cc4} 到 @code{cc7}).

@item w
@en Register in the class @code{FCR_REGS} (@code{cc0} to @code{cc3}).
类别@code{FCR_REGS}中的寄存器(@code{cc0} 到 @code{cc3}).

@item x
@en Register in the class @code{QUAD_FPR_REGS} (@code{fr0} to @code{fr63}).
@en Register numbers not divisible by 4 are excluded not in the class but through
@en the use of a machine mode larger than 8 bytes.
类别@code{QUAD_FPR_REGS}中的寄存器(@code{fr0} 到 @code{fr63})。无法被4整除的寄存器编号不在该类中，但是可以使用大于8个字节的机器模式来使用。

@item z
@en Register in the class @code{SPR_REGS} (@code{lcr} and @code{lr}).
类别@code{SPR_REGS}中的寄存器(@code{lcr} 和 @code{lr}).

@item A
@en Register in the class @code{QUAD_ACC_REGS} (@code{acc0} to @code{acc7}).
类别@code{QUAD_ACC_REGS}中的寄存器(@code{acc0} 到 @code{acc7}).

@item B
@en Register in the class @code{ACCG_REGS} (@code{accg0} to @code{accg7}).
类别@code{ACCG_REGS}中的寄存器(@code{accg0} 到 @code{accg7}).

@item C
@en Register in the class @code{CR_REGS} (@code{cc0} to @code{cc7}).
类别@code{CR_REGS}中的寄存器(@code{cc0} 到 @code{cc7}).

@item G
@en Floating point constant zero
浮点常量零

@item I
@en 6-bit signed integer constant
6位有符号整数常量

@item J
@en 10-bit signed integer constant
10位有符号整数常量

@item L
@en 16-bit signed integer constant
16位有符号整数常量

@item M
@en 16-bit unsigned integer constant
16位无符号整数常量

@item N
@en 12-bit signed integer constant that is negative---i.e.@: in the
@en range of @minus{}2048 to @minus{}1
12位有符号整数常量，且为负---即，范围在@minus{}2048 到 @minus{}1

@item O
@en Constant zero
常量零

@item P
@en 12-bit signed integer constant that is greater than zero---i.e.@: in the
@en range of 1 to 2047.
12有符号整数常量，且大于零---即，范围在1到2047
@end table

@item Blackfin family---@file{config/bfin/constraints.md}
@table @code
@item a
@en P register
P寄存器

@item d
@en D register
D寄存器

@item z
@en A call clobbered P register.
被函数调用破坏的P寄存器

@item q@var{n}
@en A single register.  If @var{n} is in the range 0 to 7, the corresponding D
@en register.  If it is @code{A}, then the register P0.
单个寄存器。如果@var{n}在范围0到7中，则对应D寄存器。如果为@code{A}，则是寄存器P0。

@item D
@en Even-numbered D register
偶数编号的D寄存器

@item W
@en Odd-numbered D register
奇数编号的D寄存器

@item e
@en Accumulator register.
累加寄存器

@item A
@en Even-numbered accumulator register.
偶数编号的累加寄存器

@item B
@en Odd-numbered accumulator register.
奇数编号的累加寄存器

@item b
@en I register
I寄存器

@item v
@en B register
B寄存器

@item f
@en M register
M寄存器

@item c
@en Registers used for circular buffering, i.e. I, B, or L registers.
用于循环缓冲的寄存器，即I, B或者L寄存器。

@item C
@en The CC register.
CC寄存器

@item t
@en LT0 or LT1.
LT0或者LT1.

@item k
@en LC0 or LC1.
LC0或者LC1.

@item u
@en LB0 or LB1.
LB0或者LB1.

@item x
@en Any D, P, B, M, I or L register.
任何D, P, B, M, I 或者L寄存器。

@item y
@en Additional registers typically used only in prologues and epilogues: RETS,
@en RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.
通常只用于函数序言和尾声的额外寄存器：RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT 和 USP。

@item w
@en Any register except accumulators or CC.
除了累加器和CC以外的任何寄存器。

@item Ksh
@en Signed 16 bit integer (in the range @minus{}32768 to 32767)
有符号16位整数（范围在-32768到32767）

@item Kuh
@en Unsigned 16 bit integer (in the range 0 to 65535)
无符号16位整数(范围在0到65535)

@item Ks7
@en Signed 7 bit integer (in the range @minus{}64 to 63)
有符号7位整数(范围在-64 到 63)

@item Ku7
@en Unsigned 7 bit integer (in the range 0 to 127)
无符号7位整数(范围在0到127)

@item Ku5
@en Unsigned 5 bit integer (in the range 0 to 31)
无符号5位整数(范围在0到31)

@item Ks4
@en Signed 4 bit integer (in the range @minus{}8 to 7)
有符号4位整数(范围在-8到7)

@item Ks3
@en Signed 3 bit integer (in the range @minus{}3 to 4)
有符号3位整数(范围在-3到4)

@item Ku3
@en Unsigned 3 bit integer (in the range 0 to 7)
无符号3位整数(范围在0到7)

@item P@var{n}
@en Constant @var{n}, where @var{n} is a single-digit constant in the range 0 to 4.
常量@var{n}，为一单个数字的常量，范围在0到4。

@item PA
@en An integer equal to one of the MACFLAG_XXX constants that is suitable for
@en use with either accumulator.
一个整数，等于MACFLAG_XXX常量中的一个，适合用于每个累加器。

@item PB
@en An integer equal to one of the MACFLAG_XXX constants that is suitable for
@en use only with accumulator A1.
一个整数，等于MACFLAG_XXX常量中的一个，只适合用于累加器A1。

@item M1
@en Constant 255.
常量255

@item M2
@en Constant 65535.
常量65535

@item J
@en An integer constant with exactly a single bit set.
整数常量，只有一个位被设置。

@item L
@en An integer constant with all bits set except exactly one.
整数常量，只有一个位没有被设置。

@item H

@item Q
@en Any SYMBOL_REF.
任何SYMBOL_REF
@end table

@item M32C---@file{config/m32c/m32c.c}
@table @code
@item Rsp
@itemx Rfb
@itemx Rsb
@samp{$sp}, @samp{$fb}, @samp{$sb}.

@item Rcr
Any control register, when they're 16 bits wide (nothing if control
registers are 24 bits wide)

@item Rcl
Any control register, when they're 24 bits wide.

@item R0w
@itemx R1w
@itemx R2w
@itemx R3w
$r0, $r1, $r2, $r3.

@item R02
$r0 or $r2, or $r2r0 for 32 bit values.

@item R13
$r1 or $r3, or $r3r1 for 32 bit values.

@item Rdi
A register that can hold a 64 bit value.

@item Rhl
$r0 or $r1 (registers with addressable high/low bytes)

@item R23
$r2 or $r3

@item Raa
Address registers

@item Raw
Address registers when they're 16 bits wide.

@item Ral
Address registers when they're 24 bits wide.

@item Rqi
Registers that can hold QI values.

@item Rad
Registers that can be used with displacements ($a0, $a1, $sb).

@item Rsi
Registers that can hold 32 bit values.

@item Rhi
Registers that can hold 16 bit values.

@item Rhc
Registers chat can hold 16 bit values, including all control
registers.

@item Rra
$r0 through R1, plus $a0 and $a1.

@item Rfl
The flags register.

@item Rmm
The memory-based pseudo-registers $mem0 through $mem15.

@item Rpi
Registers that can hold pointers (16 bit registers for r8c, m16c; 24
bit registers for m32cm, m32c).

@item Rpa
Matches multiple registers in a PARALLEL to form a larger register.
Used to match function return values.

@item Is3
@minus{}8 @dots{} 7

@item IS1
@minus{}128 @dots{} 127

@item IS2
@minus{}32768 @dots{} 32767

@item IU2
0 @dots{} 65535

@item In4
@minus{}8 @dots{} @minus{}1 or 1 @dots{} 8

@item In5
@minus{}16 @dots{} @minus{}1 or 1 @dots{} 16

@item In6
@minus{}32 @dots{} @minus{}1 or 1 @dots{} 32

@item IM2
@minus{}65536 @dots{} @minus{}1

@item Ilb
An 8 bit value with exactly one bit set.

@item Ilw
A 16 bit value with exactly one bit set.

@item Sd
The common src/dest memory addressing modes.

@item Sa
Memory addressed using $a0 or $a1.

@item Si
Memory addressed with immediate addresses.

@item Ss
Memory addressed using the stack pointer ($sp).

@item Sf
Memory addressed using the frame base register ($fb).

@item Ss
Memory addressed using the small base register ($sb).

@item S1
$r1h
@end table

@item MeP---@file{config/mep/constraints.md}
@table @code

@item a
The $sp register.

@item b
The $tp register.

@item c
Any control register.

@item d
Either the $hi or the $lo register.

@item em
Coprocessor registers that can be directly loaded ($c0-$c15).

@item ex
Coprocessor registers that can be moved to each other.

@item er
Coprocessor registers that can be moved to core registers.

@item h
The $hi register.

@item j
The $rpc register.

@item l
The $lo register.

@item t
Registers which can be used in $tp-relative addressing.

@item v
The $gp register.

@item x
The coprocessor registers.

@item y
The coprocessor control registers.

@item z
The $0 register.

@item A
User-defined register set A.

@item B
User-defined register set B.

@item C
User-defined register set C.

@item D
User-defined register set D.

@item I
Offsets for $gp-rel addressing.

@item J
Constants that can be used directly with boolean insns.

@item K
Constants that can be moved directly to registers.

@item L
Small constants that can be added to registers.

@item M
Long shift counts.

@item N
Small constants that can be compared to registers.

@item O
Constants that can be loaded into the top half of registers.

@item S
Signed 8-bit immediates.

@item T
Symbols encoded for $tp-rel or $gp-rel addressing.

@item U
Non-constant addresses for loading/saving coprocessor registers.

@item W
The top half of a symbol's value.

@item Y
A register indirect address without offset.

@item Z
Symbolic references to the control bus.



@end table

@item MicroBlaze---@file{config/microblaze/constraints.md}
@table @code
@item d
A general register (@code{r0} to @code{r31}).

@item z
A status register (@code{rmsr}, @code{$fcc1} to @code{$fcc7}).

@end table

 
@item MIPS---@file{config/mips/constraints.md}
@table @code
@item d
@en An address register.  This is equivalent to @code{r} unless
@en generating MIPS16 code.
地址寄存器。与@code{r}等价，只不过是生成MIPS16代码

@item f
@en A floating-point register (if available).
浮点寄存器（如果可用）

@item h
@en Formerly the @code{hi} register.  This constraint is no longer supported.
之前为@code{hi}寄存器。该约束不再被支持。

@item l
@en The @code{lo} register.  Use this register to store values that are
@en no bigger than a word.
@code{lo}寄存器。使用该寄存器来存放不大于一个字的值。

@item x
@en The concatenated @code{hi} and @code{lo} registers.  Use this register
@en to store doubleword values.
@code{hi} 和 @code{lo}寄存器的结合。使用该寄存器来存放双字的值。

@item c
@en A register suitable for use in an indirect jump.  This will always be
@en @code{$25} for @option{-mabicalls}.
适用于间接跳转的寄存器。对于@option{-mabicalls}，其将总是为@code{$25}。

@item v
@en Register @code{$3}.  Do not use this constraint in new code;
@en it is retained only for compatibility with glibc.
寄存器@code{$3}。不要在新的代码中使用该约束；保留它只是为了与glibc兼容。

@item y
@en Equivalent to @code{r}; retained for backwards compatibility.
等价于@code{r}; 保留它是为了向后兼容。

@item z
@en A floating-point condition code register.
浮点条件代码寄存器

@item I
@en A signed 16-bit constant (for arithmetic instructions).
有符号16位常量(用于算术指令)

@item J
@en Integer zero.
整数零

@item K
@en An unsigned 16-bit constant (for logic instructions).
无符号16位常量(用于逻辑指令)

@item L
@en A signed 32-bit constant in which the lower 16 bits are zero.
@en Such constants can be loaded using @code{lui}.
有符号32位常量，其中低16位为零。这样的常量可以使用@code{lui}来加载。

@item M
@en A constant that cannot be loaded using @code{lui}, @code{addiu}
@en or @code{ori}.
不可以使用@code{lui}, @code{addiu}或@code{ori}加载的常量。

@item N
@en A constant in the range @minus{}65535 to @minus{}1 (inclusive).
常量，范围在-65535 到 -1 (含)。

@item O
@en A signed 15-bit constant.
有符号15位常量

@item P
@en A constant in the range 1 to 65535 (inclusive).
常量，范围在1到65535 (含)

@item G
@en Floating-point zero.
浮点零

@item R
@en An address that can be used in a non-macro load or store.
@en @end table
可以用于非宏的加载和存储中的地址。
@end table

@item Motorola 680x0---@file{config/m68k/constraints.md}
@table @code
@item a
@en Address register
地址寄存器

@item d
@en Data register
数据寄存器

@item f
@en 68881 floating-point register, if available
68881浮点寄存器，如果可用

@item I
@en Integer in the range 1 to 8
整数，范围在1到8

@item J
@en 16-bit signed number
16位有符号数字

@item K
@en Signed number whose magnitude is greater than 0x80
有符号数字，大于0x80

@item L
@en Integer in the range @minus{}8 to @minus{}1
整数，范围在@minus{}8 到 @minus{}1

@item M
@en Signed number whose magnitude is greater than 0x100
有符号数字，大于0x100

@item N
@en Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate
范围在24到31，rotatert:SI 8 到 1，表示为rotate

@item O
@en 16 (for rotate using swap)
16 (使用swap的rotate)

@item P
@en Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate
范围在8到15，rotatert:HI 8 到 1，表示为rotate

@item R
@en Numbers that mov3q can handle
mov3q可以处理的数字

@item G
@en Floating point constant that is not a 68881 constant
浮点常量，且不是68881常量

@item S
@en Operands that satisfy 'm' when -mpcrel is in effect
操作数，当-mpcrel有效时，满足'm'

@item T
@en Operands that satisfy 's' when -mpcrel is not in effect
操作数，当-mpcrel无效时，满足's'

@item Q
@en Address register indirect addressing mode
地址寄存器，简介寻址模式

@item U
@en Register offset addressing
寄存器偏移寻址

@item W
@en const_call_operand
const_call_operand

@item Cs
@en symbol_ref or const
symbol_ref 或 const

@item Ci
@en const_int
const_int

@item C0
@en const_int 0
const_int 0

@item Cj
@en Range of signed numbers that don't fit in 16 bits
不适合16位的有符号数的范围不适合16位

@item Cmvq
@en Integers valid for mvq
用于mvq的整数

@item Capsw
@en Integers valid for a moveq followed by a swap
整数，用于moveq后面跟一个swap

@item Cmvz
@en Integers valid for mvz
用于mvz的整数

@item Cmvs
@en Integers valid for mvs
用于mvs的整数

@item Ap
@en push_operand
push_operand

@item Ac
@en Non-register operands allowed in clr
允许在clr中使用的非寄存器操作数
@end table

@item Motorola 68HC11 & 68HC12 families---@file{config/m68hc11/m68hc11.h}
@table @code
@item a
@en Register `a'
寄存器`a'

@item b
@en Register `b'
寄存器`b'

@item d
@en Register `d'
寄存器`d'

@item q
@en An 8-bit register
8位寄存器

@item t
@en Temporary soft register _.tmp
临时软寄存器_.tmp

@item u
@en A soft register _.d1 to _.d31
软寄存器_.d1 到 _.d31

@item w
@en Stack pointer register
栈指针寄存器

@item x
@en Register `x'
寄存器`x'

@item y
@en Register `y'
寄存器`y'

@item z
@en Pseudo register `z' (replaced by `x' or `y' at the end)
伪寄存器`z' (在后来被`x' 或 `y'替换)

@item A
@en An address register: x, y or z
地址寄存器：x, y 或 z

@item B
@en An address register: x or y
地址寄存器：x 或 y

@item D
@en Register pair (x:d) to form a 32-bit value
寄存器(x:d)，形成一个32位的值

@item L
@en Constants in the range @minus{}65536 to 65535
常量，范围在@minus{}65536 到 65535

@item M
@en Constants whose 16-bit low part is zero
常量，低16位为零

@item N
@en Constant integer 1 or @minus{}1
常整数1 或 @minus{}1

@item O
@en Constant integer 16
常整数16

@item P
@en Constants in the range @minus{}8 to 2
常量，范围在@minus{}8 到 2
@end table

@item Moxie---@file{config/moxie/constraints.md}
@table @code
@item A
An absolute address

@item B
An offset address

@item W
A register indirect memory operand

@item I
A constant in the range of 0 to 255.

@item N
A constant in the range of 0 to @minus{}255.

@end table

@item PDP-11---@file{config/pdp11/constraints.md}
@table @code
@item a
Floating point registers AC0 through AC3.  These can be loaded from/to
memory with a single instruction.

@item d
Odd numbered general registers (R1, R3, R5).  These are used for
16-bit multiply operations.

@item f
Any of the floating point registers (AC0 through AC5).

@item G
Floating point constant 0.

@item I
An integer constant that fits in 16 bits.

@item J
An integer constant whose low order 16 bits are zero.

@item K
An integer constant that does not meet the constraints for codes
@samp{I} or @samp{J}.

@item L
The integer constant 1.

@item M
The integer constant @minus{}1.

@item N
The integer constant 0.

@item O
Integer constants @minus{}4 through @minus{}1 and 1 through 4; shifts by these
amounts are handled as multiple single-bit shifts rather than a single
variable-length shift.

@item Q
A memory reference which requires an additional word (address or
offset) after the opcode.

@item R
A memory reference that is encoded within the opcode.

@end table

@item RX---@file{config/rx/constraints.md}
@table @code
@item Q
An address which does not involve register indirect addressing or
pre/post increment/decrement addressing.

@item Symbol
A symbol reference.

@item Int08
A constant in the range @minus{}256 to 255, inclusive.

@item Sint08
A constant in the range @minus{}128 to 127, inclusive.

@item Sint16
A constant in the range @minus{}32768 to 32767, inclusive.

@item Sint24
A constant in the range @minus{}8388608 to 8388607, inclusive.

@item Uint04
A constant in the range 0 to 15, inclusive.

@end table

@need 1000
@item SPARC---@file{config/sparc/sparc.h}
@table @code
@item f
@en Floating-point register on the SPARC-V8 architecture and
@en lower floating-point register on the SPARC-V9 architecture.
SPARC-V8体系结构上的浮点寄存器，以及SPARC-V9体系结构上的低浮点寄存器。

@item e
@en Floating-point register.  It is equivalent to @samp{f} on the
@en SPARC-V8 architecture and contains both lower and upper
@en floating-point registers on the SPARC-V9 architecture.
浮点寄存器。在SPARC-V8体系结构上等价于@samp{f}，在SPARC-V9体系结构上包含低位和高位的浮点寄存器。

@item c
@en Floating-point condition code register.
浮点条件代码寄存器。

@item d
@en Lower floating-point register.  It is only valid on the SPARC-V9
@en architecture when the Visual Instruction Set is available.
低位浮点寄存器。只用于SPARC-V9体系结构上，当虚拟指令集可用的时候。

@item b
@en Floating-point register.  It is only valid on the SPARC-V9 architecture
@en when the Visual Instruction Set is available.
浮点寄存器。只用于SPARC-V9体系结构上，当虚拟指令集可用的时候。

@item h
@en 64-bit global or out register for the SPARC-V8+ architecture.
64位global或out寄存器，用于SPARC-V8+体系结构。

@item D
@en A vector constant
向量常量

@item I
@en Signed 13-bit constant
有符号13位常量

@item J
@en Zero
零

@item K
@en 32-bit constant with the low 12 bits clear (a constant that can be
@en loaded with the @code{sethi} instruction)
32位常量，低12位被清零（可以使用@code{sethi}指令加载的常量）

@item L
@en A constant in the range supported by @code{movcc} instructions
@code{movcc}指令所支持的范围内的常量

@item M
@en A constant in the range supported by @code{movrcc} instructions
@code{movrcc}指令所支持的范围内的常量

@item N
@en Same as @samp{K}, except that it verifies that bits that are not in the
@en lower 32-bit range are all zero.  Must be used instead of @samp{K} for
@en modes wider than @code{SImode}
与@samp{K}相同，只不过，其会验证不在低32位范围的位全是零。对于机器模式宽于@code{SImode}的，比需使用其，而不是@samp{K}

@item O
@en The constant 4096
常量4096

@item G
@en Floating-point zero
浮点零

@item H
@en Signed 13-bit constant, sign-extended to 32 or 64 bits
有符号13位常量，符号扩展到32或64位

@item Q
@en Floating-point constant whose integral representation can
@en be moved into an integer register using a single sethi
@en instruction
浮点常量，其整数表示可以使用单个sethi指令，被移送到整数寄存器中。

@item R
@en Floating-point constant whose integral representation can
@en be moved into an integer register using a single mov
@en instruction
浮点常量，其整数表示可以使用单个mov指令，被移送到整数寄存器中。

@item S
@en Floating-point constant whose integral representation can
@en be moved into an integer register using a high/lo_sum
@en instruction sequence
浮点常量，其整数表示可以使用一个high/lo_sum指令序列，被移送到整数寄存器中。

@item T
@en Memory address aligned to an 8-byte boundary
内存地址，对齐到8字节的边界

@item U
@en Even register
偶数寄存器

@item W
@en Memory address for @samp{e} constraint registers
内存地址，用于@samp{e}约束寄存器

@item Y
@en Vector zero
向量零
@end table

@item SPU---@file{config/spu/spu.h}
@table @code
@item a
@en An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64 bit value.  
立即数，可以使用il/ila/ilh/ilhu指令加载。const_int被当作64位值。

@item c
@en An immediate for and/xor/or instructions.  const_int is treated as a 64 bit value.  
立即数，用于and/xor/or指令。const_int被当作64位值。

@item d
@en An immediate for the @code{iohl} instruction.  const_int is treated as a 64 bit value.  
立即数，用于@code{iohl}指令。const_int被当作64位值。

@item f
@en An immediate which can be loaded with @code{fsmbi}.  
立即数，可以使用@code{fsmbi}指令加载。  

@item A
@en An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32 bit value.  
立即数，可以使用il/ila/ilh/ilhu指令加载。const_int被当作32位值。 

@item B
@en An immediate for most arithmetic instructions.  const_int is treated as a 32 bit value.  
立即数，用于大多算术指令。const_int被当作32位值。  

@item C
@en An immediate for and/xor/or instructions.  const_int is treated as a 32 bit value.  
立即数，用于and/xor/or指令。const_int被当作32位值。 

@item D
@en An immediate for the @code{iohl} instruction.  const_int is treated as a 32 bit value.  
立即数，用于@code{iohl}指令。const_int被当作32位值。  

@item I
@en A constant in the range [@minus{}64, 63] for shift/rotate instructions.  
常量，范围为[-64, 63]，用于shift/rotate指令。  

@item J
@en An unsigned 7-bit constant for conversion/nop/channel instructions.  
无符号7位常量，用于conversion/nop/channel指令。  

@item K
@en A signed 10-bit constant for most arithmetic instructions.  
有符号10位常量，用于大多算术指令。  

@item M
@en A signed 16 bit immediate for @code{stop}.  
有符号16位立即数，用于@code{stop}。 

@item N
@en An unsigned 16-bit constant for @code{iohl} and @code{fsmbi}.  
无符号16位常量，用于@code{iohl}和@code{fsmbi}。  

@item O
@en An unsigned 7-bit constant whose 3 least significant bits are 0.  
无符号7位常量，其3个最小有效位是0。  

@item P
@en An unsigned 3-bit constant for 16-byte rotates and shifts 
无符号3位常量，用于16字节的rotate和shift。

@item R
@en Call operand, reg, for indirect calls 
调用操作数，寄存器，用于间接调用。

@item S
@en Call operand, symbol, for relative calls.  
调用操作数，符号，用于相关调用。  

@item T
@en Call operand, const_int, for absolute calls.  
调用操作数，const_int，用于绝对调用。  

@item U
@en An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is sign extended to 128 bit.  
立即数，可以使用il/ila/ilh/ilhu指令加载。const_int被扩展为128位。  

@item W
@en An immediate for shift and rotate instructions.  const_int is treated as a 32 bit value.  
立即数，用于shift和rotate指令。const_int被当作32位值。  

@item Y
@en An immediate for and/xor/or instructions.  const_int is sign extended as a 128 bit.  
立即数，用于and/xor/or指令。const_int被有符号扩展为128位。  

@item Z
@en An immediate for the @code{iohl} instruction.  const_int is sign extended to 128 bit.  
立即数，用于@code{iohl}指令。const_int被有符号扩展为128位。  
@end table

@item S/390 and zSeries---@file{config/s390/s390.h}
@table @code
@item a
@en Address register (general purpose register except r0)
地址寄存器(通用目的寄存器，除了r0)

@item c
@en Condition code register
条件代码寄存器

@item d
@en Data register (arbitrary general purpose register)
数据寄存器（任意通用寄存器）

@item f
@en Floating-point register
浮点寄存器

@item I
@en Unsigned 8-bit constant (0--255)
无符号8位常量(0--255)

@item J
@en Unsigned 12-bit constant (0--4095)
无符号12位常量(0--4095)

@item K
@en Signed 16-bit constant (@minus{}32768--32767)
有符号16位常量(@minus{}32768--32767)

@item L
@en Value appropriate as displacement.
适合作偏移量的值
@table @code
@item (0..4095)
@en for short displacement
短偏移
@item (-524288..524287)
@en for long displacement
长偏移
@end table

@item M
@en Constant integer with a value of 0x7fffffff.
常量整数，值为0x7fffffff

@item N
@en Multiple letter constraint followed by 4 parameter letters.
多个字母约束，跟随4个参数字母
@table @code
@item 0..9:
@en number of the part counting from most to least significant
部分的编号，从最大有效到最小有效计数
@item H,Q:
@en mode of the part
部分的机器模式
@item D,S,H:
@en mode of the containing operand
包含的操作数的机器模式
@item 0,F:
@en value of the other parts (F---all bits set)
其它部分的值(F---所有位都被设置)
@end table
@en The constraint matches if the specified part of a constant
@en has a value different from its other parts.
如果常量所指定的部分具有与其它部分不同的值，则约束匹配

@item Q
@en Memory reference without index register and with short displacement.
没有索引寄存器，但是有短偏移的内存引用

@item R
@en Memory reference with index register and short displacement.
具有索引寄存器和短偏移的内存引用

@item S
@en Memory reference without index register but with long displacement.
没有索引寄存器，但是有长偏移的内存引用

@item T
@en Memory reference with index register and long displacement.
具有索引寄存器和长偏移的内存引用

@item U
@en Pointer with short displacement.
具有短偏移的指针

@item W
@en Pointer with long displacement.
具有长偏移的指针

@item Y
@en Shift count operand.
移位计数操作数
@end table

@item Score family---@file{config/score/score.h}
@table @code
@item d
@en Registers from r0 to r32.
寄存器r0到r32

@item e
@en Registers from r0 to r16.
寄存器r0到r16

@item t
@en r8---r11 or r22---r27 registers.
r8---r11 或 r22---r27 寄存器

@item h
@en hi register.
hi寄存器

@item l
@en lo register.
lo寄存器

@item x
@en hi + lo register.
hi + lo 寄存器

@item q
@en cnt register.
cnt寄存器

@item y
@en lcb register.
lcb寄存器

@item z
@en scb register.
scb寄存器

@item a
@en cnt + lcb + scb register.
cnt + lcb + scb寄存器

@item c
@en cr0---cr15 register.
cr0---cr15寄存器

@item b
@en cp1 registers.
cp1寄存器

@item f
@en cp2 registers.
cp2寄存器

@item i
@en cp3 registers.
cp3寄存器

@item j
@en cp1 + cp2 + cp3 registers.
cp1 + cp2 + cp3寄存器

@item I
@en High 16-bit constant (32-bit constant with 16 LSBs zero).
高16位常量(32位常量，16位最小有效位为零)

@item J
@en Unsigned 5 bit integer (in the range 0 to 31).
无符号5位整数(范围从0到31)

@item K
@en Unsigned 16 bit integer (in the range 0 to 65535).
无符号16位整数(范围从0到65535)

@item L
@en Signed 16 bit integer (in the range @minus{}32768 to 32767).
有符号16位整数(范围从@minus{}32768到32767)

@item M
@en Unsigned 14 bit integer (in the range 0 to 16383).
无符号14位整数(范围从0到16383)

@item N
@en Signed 14 bit integer (in the range @minus{}8192 to 8191).
有符号14位整数(范围从@minus{}8192到8191)

@item Z
@en Any SYMBOL_REF.
任何SYMBOL_REF
@end table

@item Xstormy16---@file{config/stormy16/stormy16.h}
@table @code
@item a
@en Register r0.
寄存器r0

@item b
@en Register r1.
寄存器r1

@item c
@en Register r2.
寄存器r2

@item d
@en Register r8.
寄存器r8

@item e
@en Registers r0 through r7.
寄存器r0到r7

@item t
@en Registers r0 and r1.
寄存器r0和r1

@item y
@en The carry register.
进位寄存器

@item z
@en Registers r8 and r9.
寄存器r8和r9

@item I
@en A constant between 0 and 3 inclusive.
常量，在0和3之间

@item J
@en A constant that has exactly one bit set.
常量，只有一位被设置

@item K
@en A constant that has exactly one bit clear.
常量，只有一位被清零

@item L
@en A constant between 0 and 255 inclusive.
常量，在0和255之间

@item M
@en A constant between @minus{}255 and 0 inclusive.
常量，在@minus{}255和0之间

@item N
@en A constant between @minus{}3 and 0 inclusive.
常量，在@minus{}3和0之间

@item O
@en A constant between 1 and 4 inclusive.
常量，在1和4之间

@item P
@en A constant between @minus{}4 and @minus{}1 inclusive.
常量，在@minus{}4和@minus{}1之间

@item Q
@en A memory reference that is a stack push.
内存引用，为一个栈压入

@item R
@en A memory reference that is a stack pop.
内存引用，为一个栈弹出

@item S
@en A memory reference that refers to a constant address of known value.
内存引用，表示一个已知的常量地址

@item T
@en The register indicated by Rx (not implemented yet).
通过Rx指示的寄存器（还没实现）

@item U
@en A constant that is not between 2 and 15 inclusive.
不在2和15之间的常量

@item Z
@en The constant 0.
常量0

@end table

@item Xtensa---@file{config/xtensa/constraints.md}
@table @code
@item a
@en General-purpose 32-bit register
通用32位寄存器

@item b
@en One-bit boolean register
一位布尔寄存器

@item A
@en MAC16 40-bit accumulator register
MAC16 40位累加器

@item I
@en Signed 12-bit integer constant, for use in MOVI instructions
有符号12位整数常量，用在MOVI指令中

@item J
@en Signed 8-bit integer constant, for use in ADDI instructions
有符号8位整数常量，用在ADDI指令中

@item K
@en Integer constant valid for BccI instructions
整数常量，用于BccI指令

@item L
@en Unsigned constant valid for BccUI instructions
无符号常量，用于BccUI指令

@end table

@end table

@ifset INTERNALS
@node Disable Insn Alternatives
@subsection 使用@code{enabled}属性来禁止insn可选项
@cindex enabled

@en The @code{enabled} insn attribute may be used to disable certain insn
@en alternatives for machine-specific reasons.  This is useful when adding
@en new instructions to an existing pattern which are only available for
@en certain cpu architecture levels as specified with the @code{-march=}
@en option.
insn属性@code{enabled}，可以出于机器特定的原因，用来禁止特定的insn的可选项。这用于，当为现有的指令模式，增加新的指令，且其只用于使用@code{-march=}选项指定的特定cpu体系结构级别。

@en If an insn alternative is disabled, then it will never be used.  The
@en compiler treats the constraints for the disabled alternative as
@en unsatisfiable.
如果insn的可选项被禁止，则其将不被使用。编译器将被禁止的可选项的约束视为不被满足。

@en In order to make use of the @code{enabled} attribute a back end has to add
@en in the machine description files:
为了能够使用@code{enabled}属性，后端必须在机器描述文件中增加：

@enumerate
@item
@en A definition of the @code{enabled} insn attribute.  The attribute is
@en defined as usual using the @code{define_attr} command.  This
@en definition should be based on other insn attributes and/or target flags.
@en The @code{enabled} attribute is a numeric attribute and should evaluate to
@en @code{(const_int 1)} for an enabled alternative and to
@en @code{(const_int 0)} otherwise.
对@code{enabled} insn属性的定义。该属性通常使用@code{define_attr}命令来定义。该定义应该基于其它insn属性以及/或者目标机标记。@code{enabled}属性为数字属性，并且对于被启用的可选项应该求值为@code{(const_int 1)}，否则为@code{(const_int 0)}。

@item
@en A definition of another insn attribute used to describe for what
@en reason an insn alternative might be available or
@en not.  E.g. @code{cpu_facility} as in the example below.
另一个insn属性的定义，用于描述为什么一个insn可选项可用或不可用。例如，下面例子中的@code{cpu_facility}。

@item
@en An assignment for the second attribute to each insn definition
@en combining instructions which are not all available under the same
@en circumstances.  (Note: It obviously only makes sense for definitions
@en with more than one alternative.  Otherwise the insn pattern should be
@en disabled or enabled using the insn condition.)
对每个insn定义，赋予第二个属性。（注意：显然只是针对那些具有多个可选项的定义。其它insn模式应该使用insn条件来禁止或开启。）

@end enumerate

@en E.g. the following two patterns could easily be merged using the @code{enabled}
@en attribute:
例如，下面两个指令模式可以容易的使用@code{enabled}属性合并在一起：

@smallexample

(define_insn "*movdi_old"
  [(set (match_operand:DI 0 "register_operand" "=d")
        (match_operand:DI 1 "register_operand" " d"))]
  "!TARGET_NEW"
  "lgr %0,%1")

(define_insn "*movdi_new"
  [(set (match_operand:DI 0 "register_operand" "=d,f,d")
        (match_operand:DI 1 "register_operand" " d,d,f"))]
  "TARGET_NEW"
  "@@
   lgr  %0,%1
   ldgr %0,%1
   lgdr %0,%1")

@end smallexample

@en to:
合并成:

@smallexample

(define_insn "*movdi_combined"
  [(set (match_operand:DI 0 "register_operand" "=d,f,d")
        (match_operand:DI 1 "register_operand" " d,d,f"))]
  ""
  "@@
   lgr  %0,%1
   ldgr %0,%1
   lgdr %0,%1"
  [(set_attr "cpu_facility" "*,new,new")])

@end smallexample

with the @code{enabled} attribute defined like this:
@smallexample

(define_attr "cpu_facility" "standard,new" (const_string "standard"))

(define_attr "enabled" ""
  (cond [(eq_attr "cpu_facility" "standard") (const_int 1)
         (and (eq_attr "cpu_facility" "new")
              (ne (symbol_ref "TARGET_NEW") (const_int 0)))
         (const_int 1)]
        (const_int 0)))

@end smallexample

@end ifset

@ifset INTERNALS
@en @node Define Constraints
@en @subsection Defining Machine-Specific Constraints
@node Define Constraints
@subsection 定义机器特定的约束
@cindex defining constraints
@cindex constraints, defining

@en Machine-specific constraints fall into two categories: register and
@en non-register constraints.  Within the latter category, constraints
@en which allow subsets of all possible memory or address operands should
@en be specially marked, to give @code{reload} more information.
机器特定的约束分为两类：寄存器约束和非寄存器约束。在后者中， 如果约束允许所有可能的内存或地址操作数，则应该被专门标记出来， 以便给@code{reload}更多信息。

@en Machine-specific constraints can be given names of arbitrary length,
@en but they must be entirely composed of letters, digits, underscores
@en (@samp{_}), and angle brackets (@samp{< >}).  Like C identifiers, they
@en must begin with a letter or underscore. 
机器特定的约束可以给定任意长度的名字，但是它们全部由字母，数字， 下划线（@samp{_}）和三角括号（@samp{< >}）组成。跟C标识符类似， 它们必须起始于字母或者下划线。

@en In order to avoid ambiguity in operand constraint strings, no
@en constraint can have a name that begins with any other constraint's
@en name.  For example, if @code{x} is defined as a constraint name,
@en @code{xy} may not be, and vice versa.  As a consequence of this rule,
@en no constraint may begin with one of the generic constraint letters:
@en @samp{E F V X g i m n o p r s}.
为了避免操作数约束字符串的混淆，约束的名字不能起始于任何其它约束的名字。 例如，如果@code{x}被定义为一个约束名，则不可以定义@code{xy}，反之依然。 按照这个规则，所有约束都不能起始于通用约束字母：@samp{E F V X g i m n o p r s}。

@en Register constraints correspond directly to register classes.
@en @xref{Register Classes}.  There is thus not much flexibility in their
@en definitions.
寄存器约束直接对应于寄存器类别。@xref{Register Classes}。 因此它们的定义没有太多的灵活性。

@en @deffn {MD Expression} define_register_constraint name regclass docstring
@en All three arguments are string constants.
@en @var{name} is the name of the constraint, as it will appear in
@en @code{match_operand} expressions.  If @var{name} is a multi-letter
@en constraint its length shall be the same for all constraints starting
@en with the same letter.  @var{regclass} can be either the
@en name of the corresponding register class (@pxref{Register Classes}),
@en or a C expression which evaluates to the appropriate register class.
@en If it is an expression, it must have no side effects, and it cannot
@en look at the operand.  The usual use of expressions is to map some
@en register constraints to @code{NO_REGS} when the register class
@en is not available on a given subarchitecture.
@deffn {MD Expression} define_register_constraint name regclass docstring
这三个参数都是字符串常量。@var{name}为约束的名字， 将在@code{match_operand}表达式中出现。如果@var{name}为多个字母的约束， 则它的长度应该与所有起始与同一字母的约束相同。 @var{regclass}可以为相应的寄存器类别的名字(@pxref{Register Classes})， 或者一个C表达式，其值为合适的寄存器类别。如果为表达式，其必须不具有副作用， 并且不能查看操作数。通常使用表达式是为了当寄存器类别对于给定的子体系结构无效时， 将一些寄存器约束映射为@code{NO_REGS}。

@en @var{docstring} is a sentence documenting the meaning of the
@en constraint.  Docstrings are explained further below.
@en @end deffn
@var{docstring}为一条语句，介绍了约束的含义。这将在下面做进一步的解释。
@end deffn

@en Non-register constraints are more like predicates: the constraint
@en definition gives a Boolean expression which indicates whether the
@en constraint matches.
非寄存器的约束更加像断言：约束定义给出一个布尔表达式，其指示是否约束匹配。

@deffn {MD Expression} define_constraint name docstring exp
@en The @var{name} and @var{docstring} arguments are the same as for
@en @code{define_register_constraint}, but note that the docstring comes
@en immediately after the name for these expressions.  @var{exp} is an RTL
@en expression, obeying the same rules as the RTL expressions in predicate
@en definitions.  @xref{Defining Predicates}, for details.  If it
@en evaluates true, the constraint matches; if it evaluates false, it
@en doesn't. Constraint expressions should indicate which RTL codes they
@en might match, just like predicate expressions.
@var{name}和@var{docstring}参数与@code{define_register_constraint}的相同， 但是注意docstring直接跟随name之后。@var{exp}为一个RTL表达式， 遵循在断言定义中相同的规则。详情参见@ref{Defining Predicates}。如果求得为真， 则约束匹配；如果求得为假，则不匹配。约束表达式应该指示出它们可能匹配的RTL， 就像断言表达式一样。

@en @code{match_test} C expressions have access to the
@en following variables:
C表达式@code{match_test}，可以访问下列变量：

@table @var
@item op
@en The RTL object defining the operand.
定义操作数的RTL对象。 
@item mode
@en The machine mode of @var{op}.
@var{op}的机器模式。
@item ival
@en @samp{INTVAL (@var{op})}, if @var{op} is a @code{const_int}.
@samp{INTVAL (@var{op})}, 如果@var{op}为@code{const_int}。
@item hval
@en @samp{CONST_DOUBLE_HIGH (@var{op})}, if @var{op} is an integer
@en @code{const_double}.
@samp{CONST_DOUBLE_HIGH (@var{op})}, 如果@var{op}为整数@code{const_double}。
@item lval
@en @samp{CONST_DOUBLE_LOW (@var{op})}, if @var{op} is an integer
@en @code{const_double}.
@samp{CONST_DOUBLE_LOW (@var{op})}, 如果@var{op}为整数@code{const_double}。 
@item rval
@en @samp{CONST_DOUBLE_REAL_VALUE (@var{op})}, if @var{op} is a floating-point
@en @code{const_double}.
@samp{CONST_DOUBLE_REAL_VALUE (@var{op})}, 
如果@var{op}为浮点@code{const_double}。 
@end table

@en The @var{*val} variables should only be used once another piece of the
@en expression has verified that @var{op} is the appropriate kind of RTL
@en object.
变量@var{*val}应该只在表达式的其它部分已经验证了@var{op}为合适类型的RTL对象时， 才被使用。
@end deffn

@en Most non-register constraints should be defined with
@en @code{define_constraint}.  The remaining two definition expressions
@en are only appropriate for constraints that should be handled specially
@en by @code{reload} if they fail to match.
大多数非寄存器约束应该使用@code{define_constraint}来定义。 其余的两个定义表达式只适合当约束匹配失败时，应该由@code{reload}单独处理的约束。

@deffn {MD Expression} define_memory_constraint name docstring exp
@en Use this expression for constraints that match a subset of all memory
@en operands: that is, @code{reload} can make them match by converting the
@en operand to the form @samp{@w{(mem (reg @var{X}))}}, where @var{X} is a
@en base register (from the register class specified by
@en @code{BASE_REG_CLASS}, @pxref{Register Classes}).
使用该表达式来定义匹配所有内存操作数的子集的约束：也就是， @code{reload}能够通过将操作数转换为@samp{@w{(mem (reg @var{X}))}}的形式使得它们 匹配。其中@var{X}为基址寄存器（通过@code{BASE_REG_CLASS}指定的寄存器类别，@pxref{Register Classes}）。

@en For example, on the S/390, some instructions do not accept arbitrary
@en memory references, but only those that do not make use of an index
@en register.  The constraint letter @samp{Q} is defined to represent a
@en memory address of this type.  If @samp{Q} is defined with
@en @code{define_memory_constraint}, a @samp{Q} constraint can handle any
@en memory operand, because @code{reload} knows it can simply copy the
@en memory address into a base register if required.  This is analogous to
@en the way an @samp{o} constraint can handle any memory operand.
例如，在S/390上，一些指令不接受任意的内存引用，只接受那些不使用索引寄存器的。 约束字母@samp{Q}被定义用来表示这个类型的内存地址。 如果@samp{Q}使用@code{define_memory_constraint}定义， 则@samp{Q}约束可以处理任意内存操作数，因为@code{reload}知道在需要的时候， 它可以简单的将内存地址复制到基址寄存器中。 这与@samp{o}约束可以处理任意内存操作数的方式类似。

@en The syntax and semantics are otherwise identical to
@en @code{define_constraint}.
语法和语义在其它方面都与@code{define_constraint}相同。
@end deffn

@deffn {MD Expression} define_address_constraint name docstring exp
@en Use this expression for constraints that match a subset of all address
@en operands: that is, @code{reload} can make the constraint match by
@en converting the operand to the form @samp{@w{(reg @var{X})}}, again
@en with @var{X} a base register.
使用该表达式来定义匹配所有地址操作数的子集的约束：也就是，
@code{reload}能够通过将操作数转换为@samp{@w{(reg @var{X})}}的形式使得它们匹配。
同样@var{X}为基址寄存器。

@en Constraints defined with @code{define_address_constraint} can only be
@en used with the @code{address_operand} predicate, or machine-specific
@en predicates that work the same way.  They are treated analogously to
@en the generic @samp{p} constraint.
使用@code{define_address_constraint}定义的约束只能用于@code{address_operand}断言
，或者机器特定的同样方式的断言。它们与通用的@samp{p}约束类似。

@en The syntax and semantics are otherwise identical to
@en @code{define_constraint}.
语法和语义在其它方面都与@code{define_constraint}相同。
@end deffn

@en For historical reasons, names beginning with the letters @samp{G H}
@en are reserved for constraints that match only @code{const_double}s, and
@en names beginning with the letters @samp{I J K L M N O P} are reserved
@en for constraints that match only @code{const_int}s.  This may change in
@en the future.  For the time being, constraints with these names must be
@en written in a stylized form, so that @code{genpreds} can tell you did
@en it correctly:
由于历史的原因，
起始于字母@samp{G H}的名字被保留为只匹配@code{const_double}的约束，
起始与字母@samp{I J K L M N O P}被保留为只匹配@code{const_int}的约束。
这在将来可能会改变。暂时的，这些名字的约束必须使用固定形式来书写，
以便@code{genpreds}能够辨别出你在做正确的事情：

@smallexample
@group
(define_constraint "[@var{GHIJKLMNOP}]@dots{}"
  "@var{doc}@dots{}"
  (and (match_code "const_int")  ; @r{@code{const_double} for G/H}
       @var{condition}@dots{}))            ; @r{usually a @code{match_test}}
@end group
@end smallexample
@c the semicolons line up in the formatted manual

@en It is fine to use names beginning with other letters for constraints
@en that match @code{const_double}s or @code{const_int}s.
可以使用起始于其它字母的名字来定义匹配@code{const_double}或@code{const_int}的约束。

@en Each docstring in a constraint definition should be one or more complete
@en sentences, marked up in Texinfo format.  @emph{They are currently unused.}
@en In the future they will be copied into the GCC manual, in @ref{Machine
@en Constraints}, replacing the hand-maintained tables currently found in
@en that section.  Also, in the future the compiler may use this to give
@en more helpful diagnostics when poor choice of @code{asm} constraints
@en causes a reload failure.
在约束定义中的每个docstring应该是一条或多条完整的语句，使用Texinfo格式来标记。
它们目前没有被使用。在将来，它们将被复制到 GCC手册中，在机器约束这一章节，
用来替换手工维护的表格。而且，将来编译器可以使用其来给出更多有帮助的诊断信息，
当过少的@code{asm}约束选择造成重载失败时。

@en If you put the pseudo-Texinfo directive @samp{@@internal} at the
@en beginning of a docstring, then (in the future) it will appear only in
@en the internals manual's version of the machine-specific constraint tables.
@en Use this for constraints that should not appear in @code{asm} statements.
如果你在docstring的起始出放入伪Texinfo指令@samp{@@internal}，
则（在将来）其将只出现在internals手册版本的机器特定约束表中。
这可以用于不应该出现在@code{asm}语句中的约束。

@en @node C Constraint Interface
@en @subsection Testing constraints from C
@node C Constraint Interface
@subsection 从C中测试约束
@cindex testing constraints
@cindex constraints, testing

@en It is occasionally useful to test a constraint from C code rather than
@en implicitly via the constraint string in a @code{match_operand}.  The
@en generated file @file{tm_p.h} declares a few interfaces for working
@en with machine-specific constraints.  None of these interfaces work with
@en the generic constraints described in @ref{Simple Constraints}.  This
@en may change in the future.
有时从C代码中测试约束要比隐式的通过@code{match_operand}中的约束字符串有用处。 生成文件@file{tm_p.h}声明了一些接口，用于机器特定的约束。 这些接口都没有用于在@ref{Simple Constraints}中描述的通用约束。 这在将来可能会有所改变。

@en @strong{Warning:} @file{tm_p.h} may declare other functions that
@en operate on constraints, besides the ones documented here.  Do not use
@en those functions from machine-dependent code.  They exist to implement
@en the old constraint interface that machine-independent components of
@en the compiler still expect.  They will change or disappear in the
@en future.
警告：@file{tm_p.h}可能声明了其它操作约束的函数，除了在这里列的以外。 不要在机器独立的代码中使用那些函数。它们只是为了实现旧的约束接口。 它们在将来将会有变动或者消失。

@en Some valid constraint names are not valid C identifiers, so there is a
@en mangling scheme for referring to them from C@.  Constraint names that
@en do not contain angle brackets or underscores are left unchanged.
@en Underscores are doubled, each @samp{<} is replaced with @samp{_l}, and
@en each @samp{>} with @samp{_g}.  Here are some examples:
一些有效的约束名字不是有效的C标志符， 所以这里有一个mangling框架用于从C中引用它们。 不包含三角括号或者下划线的约束名保持不变。下划线改写成两次， 每个@samp{<}被@samp{_l}替换，每个@samp{>}被@samp{_g}替换。这里有些例子：

@c the @c's prevent double blank lines in the printed manual.
@example
@multitable {Original} {Mangled}
@item @strong{Original} @tab @strong{Mangled}  @c
@item @code{x}     @tab @code{x}       @c
@item @code{P42x}  @tab @code{P42x}    @c
@item @code{P4_x}  @tab @code{P4__x}   @c
@item @code{P4>x}  @tab @code{P4_gx}   @c
@item @code{P4>>}  @tab @code{P4_g_g}  @c
@item @code{P4_g>} @tab @code{P4__g_g} @c
@end multitable
@end example

@en Throughout this section, the variable @var{c} is either a constraint
@en in the abstract sense, or a constant from @code{enum constraint_num};
@en the variable @var{m} is a mangled constraint name (usually as part of
@en a larger identifier).
在该章节中，变量@var{c}或者为一个抽象的约束， 或者为来自@code{enum constraint_num}的常量； 变量@var{m}为一个mangled约束名字（通常作为一个大标志符的一部分）。

@deftp Enum constraint_num
@en For each machine-specific constraint, there is a corresponding
@en enumeration constant: @samp{CONSTRAINT_} plus the mangled name of the
@en constraint.  Functions that take an @code{enum constraint_num} as an
@en argument expect one of these constants.
对于每个机器特定的约束，有一个对应的枚举常量：
@samp{CONSTRAINT_}加上约束的mangled名字。
函数接受一个@code{enum constraint_num}作为参数。

@en Machine-independent constraints do not have associated constants.
@en This may change in the future.
机器独立的约束不具有相关的常量。这在将来可能会有改变。
@end deftp

@deftypefun {inline bool} satisfies_constraint_@var{m} (rtx @var{exp})
@en For each machine-specific, non-register constraint @var{m}, there is
@en one of these functions; it returns @code{true} if @var{exp} satisfies the
@en constraint.  These functions are only visible if @file{rtl.h} was included
@en before @file{tm_p.h}.
对于每个机器特定的，非寄存器约束@var{m}，有一个这样函数；其返回@code{true}， 如果@var{exp}满足约束。 这些函数只有当@file{rtl.h}被包含在@file{tm_p.h}之前时才可见。
@end deftypefun

@deftypefun bool constraint_satisfied_p (rtx @var{exp}, enum constraint_num @var{c})
@en Like the @code{satisfies_constraint_@var{m}} functions, but the
@en constraint to test is given as an argument, @var{c}.  If @var{c}
@en specifies a register constraint, this function will always return
@en @code{false}.
类似@code{satisfies_constraint_@var{m}}函数，只是被测试的约束作为参数给出， @var{c}。如果@var{c}指定一个寄存器约束，该函数将总是返回@code{false}。
@end deftypefun

@deftypefun {enum reg_class} regclass_for_constraint (enum constraint_num @var{c})
@en Returns the register class associated with @var{c}.  If @var{c} is not
@en a register constraint, or those registers are not available for the
@en currently selected subtarget, returns @code{NO_REGS}.
返回与@var{c}关联的寄存器类别。如果@var{c}不是寄存器约束， 或者那些寄存器对于当前选择的子target无效，则返回@code{NO_REGS}。
@end deftypefun

@en Here is an example use of @code{satisfies_constraint_@var{m}}.  In
@en peephole optimizations (@pxref{Peephole Definitions}), operand
@en constraint strings are ignored, so if there are relevant constraints,
@en they must be tested in the C condition.  In the example, the
@en optimization is applied if operand 2 does @emph{not} satisfy the
@en @samp{K} constraint.  (This is a simplified version of a peephole
@en definition from the i386 machine description.)
这里有一个使用@code{satisfies_constraint_@var{m}}的例子。 在窥孔优化（@pxref{Peephole Definitions}）中，操作数约束字符串将被忽略， 所以如果有相应的约束，它们必须在C条件中被测试。在例子中，如果操作数2不满足@samp{K}约束，优化将被采用。 （这是从 i386机器描述中的窥孔定义简化的版本。）

@smallexample
(define_peephole2
  [(match_scratch:SI 3 "r")
   (set (match_operand:SI 0 "register_operand" "")
        (mult:SI (match_operand:SI 1 "memory_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))]

  "!satisfies_constraint_K (operands[2])"

  [(set (match_dup 3) (match_dup 1))
   (set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))]

  "")
@end smallexample

@en @node Standard Names
@en @section Standard Pattern Names For Generation
@node Standard Names
@section 用于生成的标准指令模式名
@cindex standard pattern names
@cindex pattern names
@cindex names, pattern

@en Here is a table of the instruction names that are meaningful in the RTL
@en generation pass of the compiler.  Giving one of these names to an
@en instruction pattern tells the RTL generation pass that it can use the
@en pattern to accomplish a certain task.
这里有一个在编译器的RTL生成过程中有意义的指令名称表，在指令模式中给定这些名字中的一个，则告诉RTL生成过程，其可以使用该指令模式来完成一个特定的任务。

@table @asis
@cindex @code{mov@var{m}} instruction pattern
@item @samp{mov@var{m}}
@en Here @var{m} stands for a two-letter machine mode name, in lowercase.
@en This instruction pattern moves data with that machine mode from operand
@en 1 to operand 0.  For example, @samp{movsi} moves full-word data.
这里@var{m}表示一个两字母的机器模式名字，小写。该指令模式将那种机器模式的数据从操作数1移送到操作数0。例如@samp{movsi}移送整字数据。

@en If operand 0 is a @code{subreg} with mode @var{m} of a register whose
@en own mode is wider than @var{m}, the effect of this instruction is
@en to store the specified value in the part of the register that corresponds
@en to mode @var{m}.  Bits outside of @var{m}, but which are within the
@en same target word as the @code{subreg} are undefined.  Bits which are
@en outside the target word are left unchanged.
如果操作数0为一个寄存器的@code{subreg}，机器模式为@var{m}，寄存器自己的机器模式比@var{m}更宽，则该指令的效果是将指定的值存储在寄存器的对应于机器模式@var{m}的部分。@var{m}之外，且与@code{subreg}在同一个目标字中的位，为未定义。目标字以外的位保持不变。

@en This class of patterns is special in several ways.  First of all, each
@en of these names up to and including full word size @emph{must} be defined,
@en because there is no other way to copy a datum from one place to another.
@en If there are patterns accepting operands in larger modes,
@en @samp{mov@var{m}} must be defined for integer modes of those sizes.
这类指令模式有几处特别的地方。首先，每个这些直到整字大小的名字，包括整字大小的，必须被定义，因为没有其它方式来从一个地方将数据复制到另一个地方。如果有接受更大机器模式的操作数的指令模式，则必须为那些大小的整数机器模式定义@samp{mov@var{m}}。

@en Second, these patterns are not used solely in the RTL generation pass.
@en Even the reload pass can generate move insns to copy values from stack
@en slots into temporary registers.  When it does so, one of the operands is
@en a hard register and the other is an operand that can need to be reloaded
@en into a register.
第二，这些指令模式不仅用在RTL生成过程。甚至重载过程可以生成move insn将值从栈槽复制到临时寄存器中。当这样的时候，其中一个操作数为硬件寄存器，另一个为需要被重载到寄存器中的操作数。

@findex force_reg
@en Therefore, when given such a pair of operands, the pattern must generate
@en RTL which needs no reloading and needs no temporary registers---no
@en registers other than the operands.  For example, if you support the
@en pattern with a @code{define_expand}, then in such a case the
@en @code{define_expand} mustn't call @code{force_reg} or any other such
@en function which might generate new pseudo registers.
因此，当给定这样一对操作数时，指令模式必须生成不需要重载，并且不需要临时寄存器的RTL。例如，如果你使用一个@code{define_expand}来支持该指令模式，则这种情况下，@code{define_expand}一定不能调用@code{force_reg}或者任何其它可能生成新的伪寄存器的函数。

@en This requirement exists even for subword modes on a RISC machine where
@en fetching those modes from memory normally requires several insns and
@en some temporary registers.
甚至对于在RISC机器上的子字机器模式，从内存中获取这些机器模式通常需要多个insn和一些临时变量，该要求也存在。

@findex change_address
@en During reload a memory reference with an invalid address may be passed
@en as an operand.  Such an address will be replaced with a valid address
@en later in the reload pass.  In this case, nothing may be done with the
@en address except to use it as it stands.  If it is copied, it will not be
@en replaced with a valid address.  No attempt should be made to make such
@en an address into a valid address and no routine (such as
@en @code{change_address}) that will do so may be called.  Note that
@en @code{general_operand} will fail when applied to such an address.
重载过程中，具有无效地址的内存引用可以被作为操作数。这样的地址将在重载过程的后面被替换成有效地址。这种情况下，可能对地址没有做任何事情，而只是使用它。如果其被复制，则将无法使用有效的地址进行替换。不要尝试将这样的地址变成有效的地址。注意，@code{general_operand}当应用到这样的地址的时候将会失败。

@findex reload_in_progress
@en The global variable @code{reload_in_progress} (which must be explicitly
@en declared if required) can be used to determine whether such special
@en handling is required.
全局变量@code{reload_in_progress}（其必须被显式的声明）可以用来确定是否需要这样的特殊的处理。

@en The variety of operands that have reloads depends on the rest of the
@en machine description, but typically on a RISC machine these can only be
@en pseudo registers that did not get hard registers, while on other
@en machines explicit memory references will get optional reloads.
需要进行重载的操作数的种类取决于机器描述的其余部分，不过通常在RISC机器上，只有那些没有获得硬件寄存器的伪寄存器，而在其它机器上，显式的内存引用也有可能需要进行重载。

@en If a scratch register is required to move an object to or from memory,
@en it can be allocated using @code{gen_reg_rtx} prior to life analysis.
如果一个scratch寄存器，被需要用来将一个对象与内存之间进行移送，则其可以活跃分析之前，使用@code{gen_reg_rtx}来进行分配。

@en If there are cases which need scratch registers during or after reload,
@en you must provide an appropriate secondary_reload target hook.
如果在重载过程中，或者之后，有需要scratch寄存器的情况，则你必须提供一个适当的secondary_reload目标钩子。

@findex can_create_pseudo_p
@en The macro @code{can_create_pseudo_p} can be used to determine if it
@en is unsafe to create new pseudo registers.  If this variable is nonzero, then
@en it is unsafe to call @code{gen_reg_rtx} to allocate a new pseudo.
宏@code{can_create_pseudo_p}可以用来确定创建一个新的伪寄存器是否不安全。如果该变量为非零，则调用@code{gen_reg_rtx}来分配一个新的伪寄存器是不安全的。

@en The constraints on a @samp{mov@var{m}} must permit moving any hard
@en register to any other hard register provided that
@en @code{HARD_REGNO_MODE_OK} permits mode @var{m} in both registers and
@en @code{TARGET_REGISTER_MOVE_COST} applied to their classes returns a value
@en of 2.
@samp{mov@var{m}}上的约束必须允许将任何硬件寄存器移送到任何其它硬件寄存器上，假设@code{HARD_REGNO_MODE_OK}在两个寄存器上都允许机器模式@var{m}，并且@code{REGISTER_MOVE_COST}应用到它们的类别上返回值2。

@en It is obligatory to support floating point @samp{mov@var{m}}
@en instructions into and out of any registers that can hold fixed point
@en values, because unions and structures (which have modes @code{SImode} or
@en @code{DImode}) can be in those registers and they may have floating
@en point members.
必须提供浮点@samp{mov@var{m}}指令，用于任何可以存放定点值的寄存器，因为联合体和结构体（具有机器模式@code{SImode}或@code{DImode}）可以在那些寄存器中，并且它们可以具有浮点成员。

@en There may also be a need to support fixed point @samp{mov@var{m}}
@en instructions in and out of floating point registers.  Unfortunately, I
@en have forgotten why this was so, and I don't know whether it is still
@en true.  If @code{HARD_REGNO_MODE_OK} rejects fixed point values in
@en floating point registers, then the constraints of the fixed point
@en @samp{mov@var{m}} instructions must be designed to avoid ever trying to
@en reload into a floating point register.
还需要支持定点@samp{mov@var{m}}指令，用于浮点寄存器。不幸的是，我忘了为什么要这样，并且不知道这是否还是真的。如果@code{HARD_REGNO_MODE_OK}排斥在浮点寄存器中的定点值，则定点@samp{mov@var{m}}指令的约束必须被设计成，避免尝试重载到一个浮点寄存器。

@cindex @code{reload_in} instruction pattern
@cindex @code{reload_out} instruction pattern
@item @samp{reload_in@var{m}}
@itemx @samp{reload_out@var{m}}
@en These named patterns have been obsoleted by the target hook
@en @code{secondary_reload}.
这些命名指令模式已经被目标钩子@code{secondary_reload}废弃。

@en Like @samp{mov@var{m}}, but used when a scratch register is required to
@en move between operand 0 and operand 1.  Operand 2 describes the scratch
@en register.  See the discussion of the @code{SECONDARY_RELOAD_CLASS}
@en macro in @pxref{Register Classes}.
类似@samp{mov@var{m}}，不过用于当需要使用scratch寄存器在操作数0和操作数1之间移送的时候。操作数2描述scratch寄存器。@pxref{Register Classes}中对@code{SECONDARY_RELOAD_CLASS}宏的讨论。

@en There are special restrictions on the form of the @code{match_operand}s
@en used in these patterns.  First, only the predicate for the reload
@en operand is examined, i.e., @code{reload_in} examines operand 1, but not
@en the predicates for operand 0 or 2.  Second, there may be only one
@en alternative in the constraints.  Third, only a single register class
@en letter may be used for the constraint; subsequent constraint letters
@en are ignored.  As a special exception, an empty constraint string
@en matches the @code{ALL_REGS} register class.  This may relieve ports
@en of the burden of defining an @code{ALL_REGS} constraint letter just
@en for these patterns.
这些指令模式中的@code{match_operand}的形式，有一些特殊的限制。首先，只有重载操作数的断言才被检查，即@code{reload_in}检查操作数1，而不检查操作数0和2。第二，在约束中只能有一个可选项。第三，约束只能使用单个寄存器类别字母；后续的约束字母都被忽略。一个例外是，空的约束字符串匹配@code{ALL_REGS}寄存器类别。这可以减轻后端为这些指令模式定义@code{ALL_REGS}约束字母的负担。

@cindex @code{movstrict@var{m}} instruction pattern
@item @samp{movstrict@var{m}}
@en Like @samp{mov@var{m}} except that if operand 0 is a @code{subreg}
@en with mode @var{m} of a register whose natural mode is wider,
@en the @samp{movstrict@var{m}} instruction is guaranteed not to alter
@en any of the register except the part which belongs to mode @var{m}.
类似@samp{mov@var{m}}，只不过，如果操作数0为一个寄存器的机器模式为@var{m}的@code{subreg}，且寄存器的自然机器模式是较宽的，则@samp{movstrict@var{m}}指令保证不会修改属于机器模式@var{m}之外的寄存器的任何部分。

@cindex @code{movmisalign@var{m}} instruction pattern
@item @samp{movmisalign@var{m}}
@en This variant of a move pattern is designed to load or store a value
@en from a memory address that is not naturally aligned for its mode.
@en For a store, the memory will be in operand 0; for a load, the memory
@en will be in operand 1.  The other operand is guaranteed not to be a
@en memory, so that it's easy to tell whether this is a load or store.
该move指令模式的变体，被设计为从没有与其机器模式自然对齐的内存地址中加载和存储值。对于存储，内存将在操作数0中；对于加载，内存将在操作数1中。其它操作数保证不为内存，所以容易判别是加载还是存储。

@en This pattern is used by the autovectorizer, and when expanding a
@en @code{MISALIGNED_INDIRECT_REF} expression.
该指令模式用于向量化，当展开@code{MISALIGNED_INDIRECT_REF}表达式的时候。

@cindex @code{load_multiple} instruction pattern
@item @samp{load_multiple}
@en Load several consecutive memory locations into consecutive registers.
@en Operand 0 is the first of the consecutive registers, operand 1
@en is the first memory location, and operand 2 is a constant: the
@en number of consecutive registers.
将多个连续的内存位置加载到连续的寄存器中。操作数0为连续寄存器中的第一个，操作数1为第一个内存位置，操作数2为一个常量：连续寄存器的数目。

@en Define this only if the target machine really has such an instruction;
@en do not define this if the most efficient way of loading consecutive
@en registers from memory is to do them one at a time.
只有当目标机器确实具有这样指令的时候才定义该指令模式；如果将内存加载到连续寄存器的最有效的方式，是每次加载一个，则 不用定义该指令模式。

@en On some machines, there are restrictions as to which consecutive
@en registers can be stored into memory, such as particular starting or
@en ending register numbers or only a range of valid counts.  For those
@en machines, use a @code{define_expand} (@pxref{Expander Definitions})
@en and make the pattern fail if the restrictions are not met.
在一些机器上，对于哪些连续寄存器可以存储到内存中，会有一些限制，例如特定的起始寄存器或者结尾寄存器的编号，或者一个有效范围。对于那些机器，使用@code{define_expand} (@pxref{Expander Definitions})，并当不符合限制的时候，将指令模式变成失败。

@en Write the generated insn as a @code{parallel} with elements being a
@en @code{set} of one register from the appropriate memory location (you may
@en also need @code{use} or @code{clobber} elements).  Use a
@en @code{match_parallel} (@pxref{RTL Template}) to recognize the insn.  See
@en @file{rs6000.md} for examples of the use of this insn pattern.
将生成的insn写成一个@code{parallel}，其元素为一个从适当内存位置到寄存器的@code{set}（可能还需要@code{use}或元素@code{clobber}）。使用@code{match_parallel} (@pxref{RTL Template})来识别insn。关于使用该insn模式的例子，可以参见@file{rs6000.md}。

@cindex @samp{store_multiple} instruction pattern
@item @samp{store_multiple}
@en Similar to @samp{load_multiple}, but store several consecutive registers
@en into consecutive memory locations.  Operand 0 is the first of the
@en consecutive memory locations, operand 1 is the first register, and
@en operand 2 is a constant: the number of consecutive registers.
类似于@samp{load_multiple}，不过是将多个连续的寄存器存储到连续的内存位置。操作数0为连续内存位置的第一个，操作数1为第一个寄存器，操作数2为常量：连续寄存器的数目。 

@cindex @code{vec_set@var{m}} instruction pattern
@item @samp{vec_set@var{m}}
@en Set given field in the vector value.  Operand 0 is the vector to modify,
@en operand 1 is new value of field and operand 2 specify the field index.
设置向量中给定的域。操作数0为要修改的向量，操作数1为域的新值，操作数2指定了域的索引。

@cindex @code{vec_extract@var{m}} instruction pattern
@item @samp{vec_extract@var{m}}
@en Extract given field from the vector value.  Operand 1 is the vector, operand 2
@en specify field index and operand 0 place to store value into.
从向量中抽取给定的域。操作数1为向量，操作数2指定了域索引，操作数0为存放值的地方。

@cindex @code{vec_extract_even@var{m}} instruction pattern
@item @samp{vec_extract_even@var{m}}
@en Extract even elements from the input vectors (operand 1 and operand 2). 
@en The even elements of operand 2 are concatenated to the even elements of operand
@en 1 in their original order. The result is stored in operand 0. 
@en The output and input vectors should have the same modes. 
从输入向量（操作数1和2）中，抽取偶数元素。操作数2的偶数元素按照它们原来的顺序，连结到操作数1的偶数元素后面。结果存储在操作数0中。输出和输入向量应该具有相同的模式。

@cindex @code{vec_extract_odd@var{m}} instruction pattern
@item @samp{vec_extract_odd@var{m}}
@en Extract odd elements from the input vectors (operand 1 and operand 2). 
@en The odd elements of operand 2 are concatenated to the odd elements of operand 
@en 1 in their original order. The result is stored in operand 0.
@en The output and input vectors should have the same modes.
从输入向量（操作数1和2）中，抽取奇数元素。操作数2的奇数元素按照它们原来的顺序，连结到操作数1的奇数元素后面。结果存储在操作数0中。输出和输入向量应该具有相同的模式。

@cindex @code{vec_interleave_high@var{m}} instruction pattern
@item @samp{vec_interleave_high@var{m}}
@en Merge high elements of the two input vectors into the output vector. The output
@en and input vectors should have the same modes (@code{N} elements). The high
@en @code{N/2} elements of the first input vector are interleaved with the high
@en @code{N/2} elements of the second input vector.
将两个输入向量的高部分元素合并到输入向量中。输出和输入向量应该具有相同的模式(@code{N}个元素)。第一个输入向量的高@code{N/2}个元素被第二个输入向量的高@code{N/2}个元素交错的插入。

@cindex @code{vec_interleave_low@var{m}} instruction pattern
@item @samp{vec_interleave_low@var{m}}
@en Merge low elements of the two input vectors into the output vector. The output
@en and input vectors should have the same modes (@code{N} elements). The low
@en @code{N/2} elements of the first input vector are interleaved with the low 
@en @code{N/2} elements of the second input vector.
将两个输入向量的低部分元素合并到输入向量中。输出和输入向量应该具有相同的模式(@code{N}个元素)。第一个输入向量的低@code{N/2}个元素被第二个输入向量的低@code{N/2}个元素交错的插入。

@cindex @code{vec_init@var{m}} instruction pattern
@item @samp{vec_init@var{m}}
@en Initialize the vector to given values.  Operand 0 is the vector to initialize
@en and operand 1 is parallel containing values for individual fields.
将向量初始化为给定的值。操作数0为要初始化的向量，操作数1并行的包含每个域的值。

@cindex @code{push@var{m}1} instruction pattern
@item @samp{push@var{m}1}
@en Output a push instruction.  Operand 0 is value to push.  Used only when
@en @code{PUSH_ROUNDING} is defined.  For historical reason, this pattern may be
@en missing and in such case an @code{mov} expander is used instead, with a
@en @code{MEM} expression forming the push operation.  The @code{mov} expander
@en method is deprecated.
输出一个push指令。操作数0是压栈的值。只有当@code{PUSH_ROUNDING}被定义时，才被使用。出于历史原因，该指令模式可以缺失，这种情况下使用@code{mov}扩展来替代，并用@code{MEM}表达式来形成压栈运算。@code{mov}扩展方法不被推荐。

@cindex @code{add@var{m}3} instruction pattern
@item @samp{add@var{m}3}
@en Add operand 2 and operand 1, storing the result in operand 0.  All operands
@en must have mode @var{m}.  This can be used even on two-address machines, by
@en means of constraints requiring operands 1 and 0 to be the same location.
操作数2加上操作数1，将结果存储在操作数0中。所有操作数必须具有机器模式@var{m}。这也可以用于两地址机器上，通过约束来要求操作数1和0为相同的位置。

@cindex @code{ssadd@var{m}3} instruction pattern
@cindex @code{usadd@var{m}3} instruction pattern
@cindex @code{sub@var{m}3} instruction pattern
@cindex @code{sssub@var{m}3} instruction pattern
@cindex @code{ussub@var{m}3} instruction pattern
@cindex @code{mul@var{m}3} instruction pattern
@cindex @code{ssmul@var{m}3} instruction pattern
@cindex @code{usmul@var{m}3} instruction pattern
@cindex @code{div@var{m}3} instruction pattern
@cindex @code{ssdiv@var{m}3} instruction pattern
@cindex @code{udiv@var{m}3} instruction pattern
@cindex @code{usdiv@var{m}3} instruction pattern
@cindex @code{mod@var{m}3} instruction pattern
@cindex @code{umod@var{m}3} instruction pattern
@cindex @code{umin@var{m}3} instruction pattern
@cindex @code{umax@var{m}3} instruction pattern
@cindex @code{and@var{m}3} instruction pattern
@cindex @code{ior@var{m}3} instruction pattern
@cindex @code{xor@var{m}3} instruction pattern
@item @samp{ssadd@var{m}3}, @samp{usadd@var{m}3}
@item @samp{sub@var{m}3}, @samp{sssub@var{m}3}, @samp{ussub@var{m}3}
@item @samp{mul@var{m}3}, @samp{ssmul@var{m}3}, @samp{usmul@var{m}3}
@itemx @samp{div@var{m}3}, @samp{ssdiv@var{m}3}
@itemx @samp{udiv@var{m}3}, @samp{usdiv@var{m}3}
@itemx @samp{mod@var{m}3}, @samp{umod@var{m}3}
@itemx @samp{umin@var{m}3}, @samp{umax@var{m}3}
@itemx @samp{and@var{m}3}, @samp{ior@var{m}3}, @samp{xor@var{m}3}
@en Similar, for other arithmetic operations.
类似的，用于其它算术运算。

@cindex @code{fma@var{m}4} instruction pattern
@item @samp{fma@var{m}4}
Multiply operand 2 and operand 1, then add operand 3, storing the
result in operand 0.  All operands must have mode @var{m}.  This
pattern is used to implement the @code{fma}, @code{fmaf}, and
@code{fmal} builtin functions from the ISO C99 standard.  The
@code{fma} operation may produce different results than doing the
multiply followed by the add if the machine does not perform a
rounding step between the operations.

@cindex @code{fms@var{m}4} instruction pattern
@item @samp{fms@var{m}4}
Like @code{fma@var{m}4}, except operand 3 subtracted from the
product instead of added to the product.  This is represented
in the rtl as

@smallexample
(fma:@var{m} @var{op1} @var{op2} (neg:@var{m} @var{op3}))
@end smallexample

@cindex @code{fnma@var{m}4} instruction pattern
@item @samp{fnma@var{m}4}
Like @code{fma@var{m}4} except that the intermediate product
is negated before being added to operand 3.  This is represented
in the rtl as

@smallexample
(fma:@var{m} (neg:@var{m} @var{op1}) @var{op2} @var{op3})
@end smallexample

@cindex @code{fnms@var{m}4} instruction pattern
@item @samp{fnms@var{m}4}
Like @code{fms@var{m}4} except that the intermediate product
is negated before subtracting operand 3.  This is represented
in the rtl as

@smallexample
(fma:@var{m} (neg:@var{m} @var{op1}) @var{op2} (neg:@var{m} @var{op3}))
@end smallexample

@cindex @code{min@var{m}3} instruction pattern
@cindex @code{max@var{m}3} instruction pattern
@item @samp{smin@var{m}3}, @samp{smax@var{m}3}
@en Signed minimum and maximum operations.  When used with floating point,
@en if both operands are zeros, or if either operand is @code{NaN}, then
@en it is unspecified which of the two operands is returned as the result.
有符号的最小值和最大值运算。当用于浮点，如果两个操作数都为零，或者有一个为@code{NaN}，则没有明确指定哪个操作数作为结果返回。

@cindex @code{reduc_smin_@var{m}} instruction pattern
@cindex @code{reduc_smax_@var{m}} instruction pattern
@item @samp{reduc_smin_@var{m}}, @samp{reduc_smax_@var{m}}
@en Find the signed minimum/maximum of the elements of a vector. The vector is
@en operand 1, and the scalar result is stored in the least significant bits of
@en operand 0 (also a vector). The output and input vector should have the same
@en modes.
查找向量的有符号最小/最大元素。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{reduc_umin_@var{m}} instruction pattern
@cindex @code{reduc_umax_@var{m}} instruction pattern
@item @samp{reduc_umin_@var{m}}, @samp{reduc_umax_@var{m}}
@en Find the unsigned minimum/maximum of the elements of a vector. The vector is
@en operand 1, and the scalar result is stored in the least significant bits of
@en operand 0 (also a vector). The output and input vector should have the same
@en modes.
查找向量的无符号最小/最大元素。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{reduc_splus_@var{m}} instruction pattern
@item @samp{reduc_splus_@var{m}}
@en Compute the sum of the signed elements of a vector. The vector is operand 1,
@en and the scalar result is stored in the least significant bits of operand 0
@en (also a vector). The output and input vector should have the same modes.
计算向量的有符号元素的和。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{reduc_uplus_@var{m}} instruction pattern
@item @samp{reduc_uplus_@var{m}}
@en Compute the sum of the unsigned elements of a vector. The vector is operand 1,
@en and the scalar result is stored in the least significant bits of operand 0
@en (also a vector). The output and input vector should have the same modes.
计算向量的无符号元素的和。向量为操作数1，标量结果存放在操作数0（也是一个向量）的最小有效位。输出和输入向量应该具有相同的模式。

@cindex @code{sdot_prod@var{m}} instruction pattern
@item @samp{sdot_prod@var{m}}
@cindex @code{udot_prod@var{m}} instruction pattern
@item @samp{udot_prod@var{m}}
@en Compute the sum of the products of two signed/unsigned elements. 
@en Operand 1 and operand 2 are of the same mode. Their product, which is of a 
@en wider mode, is computed and added to operand 3. Operand 3 is of a mode equal or 
@en wider than the mode of the product. The result is placed in operand 0, which
@en is of the same mode as operand 3. 
计算两个有符号/无符号元素乘积的和。操作数1和2为相同的模式。它们的乘积，为一个宽的模式，被计算并增加到操作数3上。操作数3的机器模式等于或宽于乘积的机器模式。结果被放在操作数0上，其与操作数3具有相同的机器模式。

@cindex @code{ssum_widen@var{m3}} instruction pattern
@item @samp{ssum_widen@var{m3}}
@cindex @code{usum_widen@var{m3}} instruction pattern
@item @samp{usum_widen@var{m3}}
@en Operands 0 and 2 are of the same mode, which is wider than the mode of 
@en operand 1. Add operand 1 to operand 2 and place the widened result in
@en operand 0. (This is used express accumulation of elements into an accumulator
@en of a wider mode.)
操作数0和2具有相同的机器模式，其比操作数1的宽。将操作数1加上操作数2，并将加宽的结果放在操作数0中。（这用于表示元素累加到一个更宽模式的累加器中）

@cindex @code{vec_shl_@var{m}} instruction pattern
@cindex @code{vec_shr_@var{m}} instruction pattern
@item @samp{vec_shl_@var{m}}, @samp{vec_shr_@var{m}}
@en Whole vector left/right shift in bits.
@en Operand 1 is a vector to be shifted.
@en Operand 2 is an integer shift amount in bits.
@en Operand 0 is where the resulting shifted vector is stored.
@en The output and input vectors should have the same modes.
整个向量向左/向右移位。操作数1为被移位的向量。操作数2为移位的位数。操作数0为移位后的结果向量被存储的地方。输出和输入向量应该具有相同的模式。

@cindex @code{vec_pack_trunc_@var{m}} instruction pattern
@item @samp{vec_pack_trunc_@var{m}}
@en Narrow (demote) and merge the elements of two vectors. Operands 1 and 2
@en are vectors of the same mode having N integral or floating point elements
@en of size S@.  Operand 0 is the resulting vector in which 2*N elements of
@en size N/2 are concatenated after narrowing them down using truncation.
变窄（降级）并合并两个向量的元素。操作数1和2为具有相同机器模式，N个，大小为S的整数或者浮点元素的向量。操作数0为结果向量，通过使用截取的方式，将它们变窄并连接成，2×N个大小为N/2的元素。

@cindex @code{vec_pack_ssat_@var{m}} instruction pattern
@cindex @code{vec_pack_usat_@var{m}} instruction pattern
@item @samp{vec_pack_ssat_@var{m}}, @samp{vec_pack_usat_@var{m}}
@en Narrow (demote) and merge the elements of two vectors.  Operands 1 and 2
@en are vectors of the same mode having N integral elements of size S.
@en Operand 0 is the resulting vector in which the elements of the two input
@en vectors are concatenated after narrowing them down using signed/unsigned
@en saturating arithmetic.
变窄（降级）并合并两个向量的元素。操作数1和2为具有相同机器模式，N个，大小为S的整数元素的向量。操作数0为结果向量，通过使用有符号/无符号饱和算术的方式，将它们变窄并连接成。

@cindex @code{vec_pack_sfix_trunc_@var{m}} instruction pattern
@cindex @code{vec_pack_ufix_trunc_@var{m}} instruction pattern
@item @samp{vec_pack_sfix_trunc_@var{m}}, @samp{vec_pack_ufix_trunc_@var{m}}
@en Narrow, convert to signed/unsigned integral type and merge the elements
@en of two vectors.  Operands 1 and 2 are vectors of the same mode having N
@en floating point elements of size S@.  Operand 0 is the resulting vector
@en in which 2*N elements of size N/2 are concatenated.
将两个向量的元素变窄，转成有符号/无符号整数类型并合并。操作数1和2为具有相同机器模式，N个，大小为S的浮点元素的向量。操作数0为结果向量，由2×N个大小为N/2的元素连接而成。

@cindex @code{vec_unpacks_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacks_lo_@var{m}} instruction pattern
@item @samp{vec_unpacks_hi_@var{m}}, @samp{vec_unpacks_lo_@var{m}}
@en Extract and widen (promote) the high/low part of a vector of signed
@en integral or floating point elements.  The input vector (operand 1) has N
@en elements of size S@.  Widen (promote) the high/low elements of the vector
@en using signed or floating point extension and place the resulting N/2
@en values of size 2*S in the output vector (operand 0).
抽取并变宽（提升），具有有符号整数或浮点元素的，向量的高/低部分。输入向量（操作数1）具有N个大小为S的元素。使用有符号或者浮点扩展，将向量的高/低元素进行变宽（提升），并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

@cindex @code{vec_unpacku_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacku_lo_@var{m}} instruction pattern
@item @samp{vec_unpacku_hi_@var{m}}, @samp{vec_unpacku_lo_@var{m}}
@en Extract and widen (promote) the high/low part of a vector of unsigned
@en integral elements.  The input vector (operand 1) has N elements of size S.
@en Widen (promote) the high/low elements of the vector using zero extension and
@en place the resulting N/2 values of size 2*S in the output vector (operand 0).
抽取并变宽（提升），具有无符号整数元素的，向量的高/低部分。输入向量（操作数1）具有N个大小为S的元素。使用零扩展，将向量的高/低元素进行变宽（提升），并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

@cindex @code{vec_unpacks_float_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacks_float_lo_@var{m}} instruction pattern
@cindex @code{vec_unpacku_float_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacku_float_lo_@var{m}} instruction pattern
@item @samp{vec_unpacks_float_hi_@var{m}}, @samp{vec_unpacks_float_lo_@var{m}}
@itemx @samp{vec_unpacku_float_hi_@var{m}}, @samp{vec_unpacku_float_lo_@var{m}}
@en Extract, convert to floating point type and widen the high/low part of a
@en vector of signed/unsigned integral elements.  The input vector (operand 1)
@en has N elements of size S@.  Convert the high/low elements of the vector using
@en floating point conversion and place the resulting N/2 values of size 2*S in
@en the output vector (operand 0).
抽取具有有符号/无符号整数元素的，向量的高/低部分，并转换成浮点类型。输入向量（操作数1）具有N个大小为S的元素。使用浮点转换，将向量的高/低元素进行转换，并将结果，N/2个大小为2*S的值，放在输出向量（操作数0）中。

@cindex @code{vec_widen_umult_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_umult_lo__@var{m}} instruction pattern
@cindex @code{vec_widen_smult_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_smult_lo_@var{m}} instruction pattern
@item @samp{vec_widen_umult_hi_@var{m}}, @samp{vec_widen_umult_lo_@var{m}}
@itemx @samp{vec_widen_smult_hi_@var{m}}, @samp{vec_widen_smult_lo_@var{m}}
@en Signed/Unsigned widening multiplication.  The two inputs (operands 1 and 2)
@en are vectors with N signed/unsigned elements of size S@.  Multiply the high/low
@en elements of the two vectors, and put the N/2 products of size 2*S in the
@en output vector (operand 0).
有符号/无符号加宽乘法。两个输入（操作数1和2）为，N个大小为S的有符号/无符号元素的向量。将两个向量的高/低元素相乘，并将N/2个大小为2×S的乘积放在输出向量（操作数0）中。

@cindex @code{mulhisi3} instruction pattern
@item @samp{mulhisi3}
@en Multiply operands 1 and 2, which have mode @code{HImode}, and store
@en a @code{SImode} product in operand 0.
机器模式为@code{HImode}的操作数1和2相乘，并将@code{SImode}乘积放在操作数0中。

@cindex @code{mulqihi3} instruction pattern
@cindex @code{mulsidi3} instruction pattern
@item @samp{mulqihi3}, @samp{mulsidi3}
@en Similar widening-multiplication instructions of other widths.
类似的其它宽度的加宽乘法指令。

@cindex @code{umulqihi3} instruction pattern
@cindex @code{umulhisi3} instruction pattern
@cindex @code{umulsidi3} instruction pattern
@item @samp{umulqihi3}, @samp{umulhisi3}, @samp{umulsidi3}
@en Similar widening-multiplication instructions that do unsigned
@en multiplication.
类似的加宽乘法指令，进行无符号乘法。

@cindex @code{usmulqihi3} instruction pattern
@cindex @code{usmulhisi3} instruction pattern
@cindex @code{usmulsidi3} instruction pattern
@item @samp{usmulqihi3}, @samp{usmulhisi3}, @samp{usmulsidi3}
@en Similar widening-multiplication instructions that interpret the first
@en operand as unsigned and the second operand as signed, then do a signed
@en multiplication.
类似的加宽乘法指令，将第一个操作数解析为无符号的，第二个为有符号的，然后进行有符号乘法。

@cindex @code{smul@var{m}3_highpart} instruction pattern
@item @samp{smul@var{m}3_highpart}
@en Perform a signed multiplication of operands 1 and 2, which have mode
@en @var{m}, and store the most significant half of the product in operand 0.
@en The least significant half of the product is discarded.
对机器模式为@var{m}的操作数1和2进行有符号乘法，并将乘积的最高有效的一半放在操作数0中。乘积的最低有效的一半被丢弃。

@cindex @code{umul@var{m}3_highpart} instruction pattern
@item @samp{umul@var{m}3_highpart}
@en Similar, but the multiplication is unsigned.
类似的，只不过乘法是无符号的。

@cindex @code{madd@var{m}@var{n}4} instruction pattern
@item @samp{madd@var{m}@var{n}4}
@en Multiply operands 1 and 2, sign-extend them to mode @var{n}, add
@en operand 3, and store the result in operand 0.  Operands 1 and 2
@en have mode @var{m} and operands 0 and 3 have mode @var{n}.
@en Both modes must be integer or fixed-point modes and @var{n} must be twice
@en the size of @var{m}.
将操作数1和2进行相乘，有符号扩展成机器模式@var{n}，加上操作数3，并将结果存放在操作数0中。操作数1和2具有机器模式@var{m}，操作数0和3具有机器模式@var{n}。两种机器模式必须都为整数或者浮点模式，并且@var{n}必须为@var{m}的两倍大小。

@en In other words, @code{madd@var{m}@var{n}4} is like
@en @code{mul@var{m}@var{n}3} except that it also adds operand 3.
换句话说，@code{madd@var{m}@var{n}4}类似于@code{mul@var{m}@var{n}3}，只不过其还加上操作数3。

@en These instructions are not allowed to @code{FAIL}.
这些指令不允许执行@code{FAIL}。

@cindex @code{umadd@var{m}@var{n}4} instruction pattern
@item @samp{umadd@var{m}@var{n}4}
@en Like @code{madd@var{m}@var{n}4}, but zero-extend the multiplication
@en operands instead of sign-extending them.
类似@code{madd@var{m}@var{n}4}，只不过零扩展乘法操作数，而不是有符号扩展它们。


@cindex @code{ssmadd@var{m}@var{n}4} instruction pattern
@item @samp{ssmadd@var{m}@var{n}4}
@en Like @code{madd@var{m}@var{n}4}, but all involved operations must be
@en signed-saturating.
类似@code{madd@var{m}@var{n}4}，不过所有的运算都必须是有符号饱和的。

@cindex @code{usmadd@var{m}@var{n}4} instruction pattern
@item @samp{usmadd@var{m}@var{n}4}
@en Like @code{umadd@var{m}@var{n}4}, but all involved operations must be
@en unsigned-saturating.
类似@code{umadd@var{m}@var{n}4}，不过所有的运算都必须是无符号饱和的。

@cindex @code{msub@var{m}@var{n}4} instruction pattern
@item @samp{msub@var{m}@var{n}4}
@en Multiply operands 1 and 2, sign-extend them to mode @var{n}, subtract the
@en result from operand 3, and store the result in operand 0.  Operands 1 and 2
@en have mode @var{m} and operands 0 and 3 have mode @var{n}.
@en Both modes must be integer or fixed-point modes and @var{n} must be twice
@en the size of @var{m}.
将操作数1和2相乘，有符号扩展为机器模式@var{n}，减去操作数3，并将结果存放在操作数0中。操作数1和2具有机器模式@var{m}，操作数0和3具有机器模式@var{n}。两种机器模式必须都为整数或者浮点模式，并且@var{n}必须为@var{m}的两倍大小。

@en In other words, @code{msub@var{m}@var{n}4} is like
@en @code{mul@var{m}@var{n}3} except that it also subtracts the result
@en from operand 3.
换句话说，@code{msub@var{m}@var{n}4}类似于@code{mul@var{m}@var{n}3}，只不过其还减去操作数3。

@en These instructions are not allowed to @code{FAIL}.
这些指令不允许执行@code{FAIL}。

@cindex @code{umsub@var{m}@var{n}4} instruction pattern
@item @samp{umsub@var{m}@var{n}4}
@en Like @code{msub@var{m}@var{n}4}, but zero-extend the multiplication
@en operands instead of sign-extending them.
类似@code{msub@var{m}@var{n}4}，不过零扩展乘法操作数，而不是有符号扩展它们。

@cindex @code{ssmsub@var{m}@var{n}4} instruction pattern
@item @samp{ssmsub@var{m}@var{n}4}
@en Like @code{msub@var{m}@var{n}4}, but all involved operations must be
@en signed-saturating.
类似@code{msub@var{m}@var{n}4}，不过所有的运算都必须是有符号饱和的。

@cindex @code{usmsub@var{m}@var{n}4} instruction pattern
@item @samp{usmsub@var{m}@var{n}4}
@en Like @code{umsub@var{m}@var{n}4}, but all involved operations must be
@en unsigned-saturating.
类似@code{umsub@var{m}@var{n}4}，不过所有的运算都必须是无符号饱和的。

@cindex @code{divmod@var{m}4} instruction pattern
@item @samp{divmod@var{m}4}
@en Signed division that produces both a quotient and a remainder.
@en Operand 1 is divided by operand 2 to produce a quotient stored
@en in operand 0 and a remainder stored in operand 3.
有符号除法，同时产生商和余数。操作数1被操作数2除，产生商存储在操作数0中，余数存储在操作数3中。

@en For machines with an instruction that produces both a quotient and a
@en remainder, provide a pattern for @samp{divmod@var{m}4} but do not
@en provide patterns for @samp{div@var{m}3} and @samp{mod@var{m}3}.  This
@en allows optimization in the relatively common case when both the quotient
@en and remainder are computed.
对于具有同时产生商和余数的指令的机器，提供@samp{divmod@var{m}4}指令模式，但不要提供@samp{div@var{m}3} 和 @samp{mod@var{m}3}。这使得当商和余数都被计算的时候，可以优化成相对常见的情况。

@en If an instruction that just produces a quotient or just a remainder
@en exists and is more efficient than the instruction that produces both,
@en write the output routine of @samp{divmod@var{m}4} to call
@en @code{find_reg_note} and look for a @code{REG_UNUSED} note on the
@en quotient or remainder and generate the appropriate instruction.
如果存在只产生商或者余数的指令，并且比都产生的指令更有效，则将@samp{divmod@var{m}4}的输出例程写成调用@code{find_reg_note}，查看商或者余数的@code{REG_UNUSED}注解，来产生适当的指令。

@cindex @code{udivmod@var{m}4} instruction pattern
@item @samp{udivmod@var{m}4}
@en Similar, but does unsigned division.
类似的，不过进行无符号除法。

@anchor{shift patterns}
@cindex @code{ashl@var{m}3} instruction pattern
@cindex @code{ssashl@var{m}3} instruction pattern
@cindex @code{usashl@var{m}3} instruction pattern
@item @samp{ashl@var{m}3}, @samp{ssashl@var{m}3}, @samp{usashl@var{m}3}
@en Arithmetic-shift operand 1 left by a number of bits specified by operand
@en 2, and store the result in operand 0.  Here @var{m} is the mode of
@en operand 0 and operand 1; operand 2's mode is specified by the
@en instruction pattern, and the compiler will convert the operand to that
@en mode before generating the instruction.  The meaning of out-of-range shift
@en counts can optionally be specified by @code{TARGET_SHIFT_TRUNCATION_MASK}.
@en @xref{TARGET_SHIFT_TRUNCATION_MASK}.  Operand 2 is always a scalar type.
将操作数1向左算术移位，左移位数由操作数2指定，将结果存储在操作数0中。这里@var{m}为操作数0和1的机器模式；操作数2的机器模式通过指令模式来指定，编译器会在生成指令之前，将操作数转换成该模式。超出范围的移位数目的含义，可以通过@code{TARGET_SHIFT_TRUNCATION_MASK}来指定。@xref{TARGET_SHIFT_TRUNCATION_MASK}. 操作数2总是一个标量类型。

@cindex @code{ashr@var{m}3} instruction pattern
@cindex @code{lshr@var{m}3} instruction pattern
@cindex @code{rotl@var{m}3} instruction pattern
@cindex @code{rotr@var{m}3} instruction pattern
@item @samp{ashr@var{m}3}, @samp{lshr@var{m}3}, @samp{rotl@var{m}3}, @samp{rotr@var{m}3}
@en Other shift and rotate instructions, analogous to the
@en @code{ashl@var{m}3} instructions.  Operand 2 is always a scalar type.
其它移位或者旋转指令，类似于@code{ashl@var{m}3}指令。操作数2总是一个标量类型。

@cindex @code{vashl@var{m}3} instruction pattern
@cindex @code{vashr@var{m}3} instruction pattern
@cindex @code{vlshr@var{m}3} instruction pattern
@cindex @code{vrotl@var{m}3} instruction pattern
@cindex @code{vrotr@var{m}3} instruction pattern
@item @samp{vashl@var{m}3}, @samp{vashr@var{m}3}, @samp{vlshr@var{m}3}, @samp{vrotl@var{m}3}, @samp{vrotr@var{m}3}
@en Vector shift and rotate instructions that take vectors as operand 2
@en instead of a scalar type.
向量移位和旋转指令，操作数2为向量，而不是标量类型。

@cindex @code{neg@var{m}2} instruction pattern
@cindex @code{ssneg@var{m}2} instruction pattern
@cindex @code{usneg@var{m}2} instruction pattern
@item @samp{neg@var{m}2}, @samp{ssneg@var{m}2}, @samp{usneg@var{m}2}
@en Negate operand 1 and store the result in operand 0.
对操作数1求负，并将结果存放在操作数0中。

@cindex @code{abs@var{m}2} instruction pattern
@item @samp{abs@var{m}2}
@en Store the absolute value of operand 1 into operand 0.
将操作数1的绝对值存放在操作数0中。

@cindex @code{sqrt@var{m}2} instruction pattern
@item @samp{sqrt@var{m}2}
@en Store the square root of operand 1 into operand 0.
将操作数1的平方根存储在操作数0中。

@en The @code{sqrt} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{sqrtf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{sqrt}内建C函数，总是使用对应于C数据类型@code{double}的机器模式，@code{sqrtf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{fmod@var{m}3} instruction pattern
@item @samp{fmod@var{m}3}
@en Store the remainder of dividing operand 1 by operand 2 into
@en operand 0, rounded towards zero to an integer.
将操作数1除以操作数2的余数，存储在操作数0中，并向零方向舍入为整数。

@en The @code{fmod} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{fmodf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{fmod}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{fmodf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{remainder@var{m}3} instruction pattern
@item @samp{remainder@var{m}3}
@en Store the remainder of dividing operand 1 by operand 2 into
@en operand 0, rounded to the nearest integer.
将操作数1除以操作数2的余数，存储在操作数0中，并舍入为最接近的整数。

@en The @code{remainder} built-in function of C always uses the mode
@en which corresponds to the C data type @code{double} and the
@en @code{remainderf} built-in function uses the mode which corresponds
@en to the C data type @code{float}.
@code{remainder}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{remainderf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{cos@var{m}2} instruction pattern
@item @samp{cos@var{m}2}
@en Store the cosine of operand 1 into operand 0.
将操作数1的余弦存放在操作数0中。

@en The @code{cos} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{cosf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{cos}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{cosf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{sin@var{m}2} instruction pattern
@item @samp{sin@var{m}2}
@en Store the sine of operand 1 into operand 0.
将操作数1的正弦存放在操作数0中。

@en The @code{sin} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{sinf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{sin}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{sinf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{exp@var{m}2} instruction pattern
@item @samp{exp@var{m}2}
@en Store the exponential of operand 1 into operand 0.
将操作数1的幂存放在操作数0中。

@en The @code{exp} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{expf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{exp}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{expf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{log@var{m}2} instruction pattern
@item @samp{log@var{m}2}
@en Store the natural logarithm of operand 1 into operand 0.
将操作数1的自然对数存放在操作数0中。

@en The @code{log} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{logf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{log}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{logf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{pow@var{m}3} instruction pattern
@item @samp{pow@var{m}3}
@en Store the value of operand 1 raised to the exponent operand 2
@en into operand 0.
将操作数1的，指数为操作数2的幂值存放在操作数0中

@en The @code{pow} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{powf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{pow}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{powf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{atan2@var{m}3} instruction pattern
@item @samp{atan2@var{m}3}
@en Store the arc tangent (inverse tangent) of operand 1 divided by
@en operand 2 into operand 0, using the signs of both arguments to
@en determine the quadrant of the result.
将操作数1除以操作数2的反正切，存放在操作数0中，使用两个参数的正负符号来确定结果的商。

@en The @code{atan2} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{atan2f}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{atan2}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{atan2f}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{floor@var{m}2} instruction pattern
@item @samp{floor@var{m}2}
@en Store the largest integral value not greater than argument.
存储不大于参数的最大整数值。

@en The @code{floor} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{floorf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{floor}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{floorf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{btrunc@var{m}2} instruction pattern
@item @samp{btrunc@var{m}2}
@en Store the argument rounded to integer towards zero.
存储将参数向零方向舍入的整数。

@en The @code{trunc} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{truncf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{trunc}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{truncf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{round@var{m}2} instruction pattern
@item @samp{round@var{m}2}
@en Store the argument rounded to integer away from zero.
存储将参数向远离零的方向舍入的整数。

@en The @code{round} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{roundf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{round}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{roundf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{ceil@var{m}2} instruction pattern
@item @samp{ceil@var{m}2}
@en Store the argument rounded to integer away from zero.
存储将参数向远离零的方向舍入的整数。

@en The @code{ceil} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{ceilf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{ceil}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{ceilf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{nearbyint@var{m}2} instruction pattern
@item @samp{nearbyint@var{m}2}
@en Store the argument rounded according to the default rounding mode
将参数根据缺省的舍入模式，舍入为整数。

@en The @code{nearbyint} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{nearbyintf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{nearbyint}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{nearbyintf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{rint@var{m}2} instruction pattern
@item @samp{rint@var{m}2}
@en Store the argument rounded according to the default rounding mode and
@en raise the inexact exception when the result differs in value from
@en the argument
将参数根据缺省的舍入模式，舍入为整数，并且当结果与参数的值不同的时候，抛出不精确异常。
 
@en The @code{rint} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{rintf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{rint}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{rintf}内建函数使用对应于C数据类型@code{float}的机器模式。
 
@cindex @code{lrint@var{m}@var{n}2}
@item @samp{lrint@var{m}@var{n}2}
@en Convert operand 1 (valid for floating point mode @var{m}) to fixed
@en point mode @var{n} as a signed number according to the current
@en rounding mode and store in operand 0 (which has mode @var{n}).
将操作数1（对于浮点模式@var{m}有效）转换成定点机器模式@var{n}，作为有符号数，根据当前的舍入模式，并存储在操作数0（具有机器模式@var{n}）中。
 
@cindex @code{lround@var{m}@var{n}2}
@item @samp{lround@var{m}@var{n}2}
@en Convert operand 1 (valid for floating point mode @var{m}) to fixed
@en point mode @var{n} as a signed number rounding to nearest and away
@en from zero and store in operand 0 (which has mode @var{n}).
将操作数1（对于浮点模式@var{m}有效）转换成定点机器模式@var{n}，舍入到最近的，远离零方向的有符号数，并存储在操作数0（具有机器模式@var{n}）中。

@cindex @code{lfloor@var{m}@var{n}2}
@item @samp{lfloor@var{m}@var{n}2}
@en Convert operand 1 (valid for floating point mode @var{m}) to fixed
@en point mode @var{n} as a signed number rounding down and store in
@en operand 0 (which has mode @var{n}).
将操作数1（对于浮点模式@var{m}有效）转换成定点机器模式@var{n}，向下舍入成有符号数，并存储在操作数0（具有机器模式@var{n}）中。

@cindex @code{lceil@var{m}@var{n}2}
@item @samp{lceil@var{m}@var{n}2}
@en Convert operand 1 (valid for floating point mode @var{m}) to fixed
@en point mode @var{n} as a signed number rounding up and store in
@en operand 0 (which has mode @var{n}).
将操作数1（对于浮点模式@var{m}有效）转换成定点机器模式@var{n}，向上舍入成有符号数，并存储在操作数0（具有机器模式@var{n}）中。

@cindex @code{copysign@var{m}3} instruction pattern
@item @samp{copysign@var{m}3}
@en Store a value with the magnitude of operand 1 and the sign of operand
@en 2 into operand 0.
将操作数1的数量级和操作数的符号组成的值，存放在操作数0中。

@en The @code{copysign} built-in function of C always uses the mode which
@en corresponds to the C data type @code{double} and the @code{copysignf}
@en built-in function uses the mode which corresponds to the C data
@en type @code{float}.
@code{copysign}内建C函数总是使用对应于C数据类型@code{double}的机器模式，@code{copysignf}内建函数使用对应于C数据类型@code{float}的机器模式。

@cindex @code{ffs@var{m}2} instruction pattern
@item @samp{ffs@var{m}2}
@en Store into operand 0 one plus the index of the least significant 1-bit
@en of operand 1.  If operand 1 is zero, store zero.  @var{m} is the mode
@en of operand 0; operand 1's mode is specified by the instruction
@en pattern, and the compiler will convert the operand to that mode before
@en generating the instruction.
将操作数1的最小有效，置1的位的索引，加上1，存放在操作数0中。如果操作数1为零，则存储零。@var{m}为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

@en The @code{ffs} built-in function of C always uses the mode which
@en corresponds to the C data type @code{int}.
@code{ffs}内建C函数总是使用对应于C数据类型@code{int}的机器模式。

@cindex @code{clz@var{m}2} instruction pattern
@item @samp{clz@var{m}2}
@en Store into operand 0 the number of leading 0-bits in @var{x}, starting
@en at the most significant bit position.  If @var{x} is 0, the
@en @code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if
@en the result is undefined or has a useful value.
@en @var{m} is the mode of operand 0; operand 1's mode is
@en specified by the instruction pattern, and the compiler will convert the
@en operand to that mode before generating the instruction.
将@var{x}中，从最高有效位开始，起始处置0的位的数目，存放在操作数0中。如果@var{x}为0，则@code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc})宏定义了结果是否为未定义或者一个有用的值。@var{m}为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

@cindex @code{ctz@var{m}2} instruction pattern
@item @samp{ctz@var{m}2}
@en Store into operand 0 the number of trailing 0-bits in @var{x}, starting
@en at the least significant bit position.  If @var{x} is 0, the
@en @code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if
@en the result is undefined or has a useful value.
@en @var{m} is the mode of operand 0; operand 1's mode is
@en specified by the instruction pattern, and the compiler will convert the
@en operand to that mode before generating the instruction.
将@var{x}中，从最小有效位开始，结尾处置0的位的数目，存放在操作数0中。如果@var{x}为0，则@code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc})宏定义了结果是否为未定义或者一个有用的值。@var{m}为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。


@cindex @code{popcount@var{m}2} instruction pattern
@item @samp{popcount@var{m}2}
@en Store into operand 0 the number of 1-bits in @var{x}.  @var{m} is the
@en mode of operand 0; operand 1's mode is specified by the instruction
@en pattern, and the compiler will convert the operand to that mode before
@en generating the instruction.
@cindex @code{popcount@var{m}2} instruction pattern
@item @samp{popcount@var{m}2}
将@var{x}中置1的位的数目，存放在操作数0中。@var{m}为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

@cindex @code{parity@var{m}2} instruction pattern
@item @samp{parity@var{m}2}
@en Store into operand 0 the parity of @var{x}, i.e.@: the number of 1-bits
@en in @var{x} modulo 2.  @var{m} is the mode of operand 0; operand 1's mode
@en is specified by the instruction pattern, and the compiler will convert
@en the operand to that mode before generating the instruction.
将@var{x}的奇偶校验存放在操作数0中，即：@var{x}中置1的位数对2求模。@var{m}为操作数0的机器模式；操作数1的机器模式由指令模式指定，编译器会在生成指令之前，将操作数转成该机器模式。

@en @cindex @code{one_cmpl@var{m}2} instruction pattern
@en @item @samp{one_cmpl@var{m}2}
@en Store the bitwise-complement of operand 1 into operand 0.
@cindex @code{one_cmpl@var{m}2} instruction pattern
@item @samp{one_cmpl@var{m}2}
对操作数1进行按位求补，并存放在操作数0中。

@cindex @code{cmp@var{m}} instruction pattern
@item @samp{cmp@var{m}}
比较操作数0和1，并设置条件代码。RTL指令模式应该像这样：

@smallexample
(set (cc0) (compare (match_operand:@var{m} 0 @dots{})
                    (match_operand:@var{m} 1 @dots{})))
@end smallexample

@cindex @code{tst@var{m}} instruction pattern
@item @samp{tst@var{m}}
将操作数0与零进行比较，并设置条件码。RTL指令模式应该像这样：

@smallexample
(set (cc0) (match_operand:@var{m} 0 @dots{}))
@end smallexample

@samp{tst@var{m}}指令模式不应该为不使用@code{(cc0)}的机器定义。这样做会使得编译器变得迷惑，因为其将会不清楚哪一个@code{set}操作为比较。应该使用@samp{cmp@var{m}}。

@cindex @code{movmem@var{m}} instruction pattern
@item @samp{movmem@var{m}}
@en Block move instruction.  The destination and source blocks of memory
@en are the first two operands, and both are @code{mem:BLK}s with an
@en address in mode @code{Pmode}.
块移动指令。内存的目的块和源块为前两个操作数，都为地址是@code{Pmode}的@code{mem:BLK}。

@en The number of bytes to move is the third operand, in mode @var{m}.
@en Usually, you specify @code{word_mode} for @var{m}.  However, if you can
@en generate better code knowing the range of valid lengths is smaller than
@en those representable in a full word, you should provide a pattern with a
@en mode corresponding to the range of values you can handle efficiently
@en (e.g., @code{QImode} for values in the range 0--127; note we avoid numbers
@en that appear negative) and also a pattern with @code{word_mode}.
要移动的字节数为第三个操作数，机器模式为@var{m}。通常，你会将@var{m}指定为@code{word_mode}。然而，如果你可以生成更好的代码，知道有效长度的范围比一整个字要小，则你应该提供一个指令模式，其机器模式对应于你可以更有效的处理的值的范围（例如，@code{QImode}对于范围0--127；注意我们回避了负数），并且一个使用@code{word_mode}的指令模式。

@en The fourth operand is the known shared alignment of the source and
@en destination, in the form of a @code{const_int} rtx.  Thus, if the
@en compiler knows that both source and destination are word-aligned,
@en it may provide the value 4 for this operand.
第四个操作数为已知的源和目的的共享对齐，形式为一个@code{const_int} rtx。因此，如果编译器知道源和目的都是字对齐的，则其可以为该操作数提供值4。

@en Optional operands 5 and 6 specify expected alignment and size of block
@en respectively.  The expected alignment differs from alignment in operand 4
@en in a way that the blocks are not required to be aligned according to it in
@en all cases. This expected alignment is also in bytes, just like operand 4.
@en Expected size, when unknown, is set to @code{(const_int -1)}.
可选的操作数5和6，分别指定了期望的对齐方式和块的大小。期望的对齐方式不同于操作数4中的对齐方式，块并不要求所有的情况下都按照这样对齐。期望的对齐方式也是以字节为单位，类似于操作数4。期望的大小，当不知道的时候，被设置为@code{(const_int -1)}。

@en Descriptions of multiple @code{movmem@var{m}} patterns can only be
@en beneficial if the patterns for smaller modes have fewer restrictions
@en on their first, second and fourth operands.  Note that the mode @var{m}
@en in @code{movmem@var{m}} does not impose any restriction on the mode of
@en individually moved data units in the block.
描述多个@code{movmem@var{m}}指令模式，只有当对于更小的机器模式的指令模式，对操作数1，2，4具有更少限制的时候，才会获利。注意@code{movmem@var{m}}中的机器模式@var{m}不对块中单独的被移动的数据单元的机器模式做任何限制。

@en These patterns need not give special consideration to the possibility
@en that the source and destination strings might overlap.
这些指令模式不需要对源和目的可能重叠的情况，进行特殊的考虑。

@cindex @code{movstr} instruction pattern
@item @samp{movstr}
@en String copy instruction, with @code{stpcpy} semantics.  Operand 0 is
@en an output operand in mode @code{Pmode}.  The addresses of the
@en destination and source strings are operands 1 and 2, and both are
@en @code{mem:BLK}s with addresses in mode @code{Pmode}.  The execution of
@en the expansion of this pattern should store in operand 0 the address in
@en which the @code{NUL} terminator was stored in the destination string.
字符串复制指令，具有@code{stpcpy}的语义。操作数0为输出操作数，机器模式为@code{Pmode}。目的字符串和源字符串的地址为操作数1和2，都是地址为@code{Pmode}的@code{mem:BLK}。对该指令模式的执行，应该将地址存放在操作数0中，其中@code{NUL}终结符存放在目标字符串中。

@cindex @code{setmem@var{m}} instruction pattern
@item @samp{setmem@var{m}}
@en Block set instruction.  The destination string is the first operand,
@en given as a @code{mem:BLK} whose address is in mode @code{Pmode}.  The
@en number of bytes to set is the second operand, in mode @var{m}.  The value to
@en initialize the memory with is the third operand. Targets that only support the
@en clearing of memory should reject any value that is not the constant 0.  See
@en @samp{movmem@var{m}} for a discussion of the choice of mode.
块设置指令。目的字符串为第一个操作数，作为一个@code{mem:BLK}，其地址的机器模式为@code{Pmode}。被设置的字节的数目是第二个操作数，机器模式为@var{m}。用于初始化内存的值为第三个操作数。只支持清空内存的目标机应该拒绝任何不为常数0的值。关于对机器模式选择的讨论，参见@samp{movmem@var{m}}。

@en The fourth operand is the known alignment of the destination, in the form
@en of a @code{const_int} rtx.  Thus, if the compiler knows that the
@en destination is word-aligned, it may provide the value 4 for this
@en operand.
第四个操作数为目标的已知对齐方式，形式为@code{const_int} rtx。因此，如果编译器知道目的操作数是字对齐的，则其可以为该操作数提供值4。

@en Optional operands 5 and 6 specify expected alignment and size of block
@en respectively.  The expected alignment differs from alignment in operand 4
@en in a way that the blocks are not required to be aligned according to it in
@en all cases. This expected alignment is also in bytes, just like operand 4.
@en Expected size, when unknown, is set to @code{(const_int -1)}.
可选的操作数5和6，分别指定了期望的对齐方式和块的大小。期望的对齐方式不同于操作数4中的对齐方式，块并不要求所有的情况下都按照这样对齐。期望的对齐方式也是以字节为单位，类似于操作数4。期望的大小，当不知道的时候，被设置为@code{(const_int -1)}。

@en The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.
对多个@code{setmem@var{m}}的使用，类似于@code{movmem@var{m}}

@cindex @code{cmpstrn@var{m}} instruction pattern
@item @samp{cmpstrn@var{m}}
String compare instruction, with five operands.  Operand 0 is the output;
it has mode @var{m}.  The remaining four operands are like the operands
of @samp{movmem@var{m}}.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
string.  The instruction is not allowed to prefetch more than one byte
at a time since either string may end in the first byte and reading past
that may access an invalid page or segment and cause a fault.  The
comparison terminates early if the fetched bytes are different or if
they are equal to zero.  The effect of the instruction is to store a
value in operand 0 whose sign indicates the result of the comparison.
@en String compare instruction, with five operands.  Operand 0 is the output;
@en it has mode @var{m}.  The remaining four operands are like the operands
@en of @samp{movmem@var{m}}.  The two memory blocks specified are compared
@en byte by byte in lexicographic order starting at the beginning of each
@en string.  The instruction is not allowed to prefetch more than one byte
@en at a time since either string may end in the first byte and reading past
@en that may access an invalid page or segment and cause a fault.  The
@en effect of the instruction is to store a value in operand 0 whose sign
@en indicates the result of the comparison.
@obsolete 字符串比较指令，有5个操作数。操作数0为输出，机器模式为@var{m}。剩下的4个操作数类似于@samp{movmem@var{m}}的操作数。两个指定的内存块按字节来进行比较，按照字典顺序，从每个字符串的起始处开始。指令不允许一次取多个字节，因为每个字符串都可能在第一个字节中终止，读取后面的字节可能会访问一个无效的页或者段，并产生一个缺失。该指令的效果是将值存放在操作数0中，其符号表示了比较的结果。
 
@cindex @code{cmpstr@var{m}} instruction pattern
@item @samp{cmpstr@var{m}}
@en String compare instruction, without known maximum length.  Operand 0 is the
@en output; it has mode @var{m}.  The second and third operand are the blocks of
@en memory to be compared; both are @code{mem:BLK} with an address in mode
@en @code{Pmode}.
字符串比较指令，不知道最大的长度。操作数0为输出，机器模式为@var{m}。第二个和第三个操作数为被比较的内存块；都是机器模式为@code{Pmode}的@code{mem:BLK}。
 
@en The fourth operand is the known shared alignment of the source and
@en destination, in the form of a @code{const_int} rtx.  Thus, if the
@en compiler knows that both source and destination are word-aligned,
@en it may provide the value 4 for this operand.
第四个操作数为源和目的的已知共享的对齐方式，形式为@code{const_int} rtx。因此，如果编译器知道源和目的都是字对齐的，则其可以为该操作数提供值4。

@en The two memory blocks specified are compared byte by byte in lexicographic
@en order starting at the beginning of each string.  The instruction is not allowed
@en to prefetch more than one byte at a time since either string may end in the
@en first byte and reading past that may access an invalid page or segment and
@en cause a fault.  The effect of the instruction is to store a value in operand 0
@en whose sign indicates the result of the comparison.
两个指定的内存块按字节来进行比较，按照字典顺序，从每个字符串的起始处开始。指令不允许一次取多个字节，因为每个字符串都可能在第一个字节中终止，读取后面的字节可能会访问一个无效的页或者段，并产生一个缺失。该指令的效果是将值存放在操作数0中，其符号表示了比较的结果。
 
@cindex @code{cmpmem@var{m}} instruction pattern
@item @samp{cmpmem@var{m}}
Block compare instruction, with five operands like the operands
of @samp{cmpstr@var{m}}.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
block.  Unlike @samp{cmpstr@var{m}} the instruction can prefetch
any bytes in the two memory blocks.  Also unlike @samp{cmpstr@var{m}}
the comparison will not stop if both bytes are zero.  The effect of
the instruction is to store a value in operand 0 whose sign indicates
the result of the comparison.
@en Block compare instruction, with five operands like the operands
@en of @samp{cmpstr@var{m}}.  The two memory blocks specified are compared
@en byte by byte in lexicographic order starting at the beginning of each
@en block.  Unlike @samp{cmpstr@var{m}} the instruction can prefetch
@en any bytes in the two memory blocks.  The effect of the instruction is
@en to store a value in operand 0 whose sign indicates the result of the
@en comparison.
@obsolete 块比较指令，这5个操作数类似于@samp{cmpstr@var{m}}。两个指定的内存块按字节来进行比较，按照字典顺序，从每个字符串的起始处开始。不像@samp{cmpstr@var{m}}，该指令可以在两个内存块中取任意个字节。该指令的效果是将值存放在操作数0中，其符号表示了比较的结果。

@cindex @code{strlen@var{m}} instruction pattern
@item @samp{strlen@var{m}}
@en Compute the length of a string, with three operands.
@en Operand 0 is the result (of mode @var{m}), operand 1 is
@en a @code{mem} referring to the first character of the string,
@en operand 2 is the character to search for (normally zero),
@en and operand 3 is a constant describing the known alignment
@en of the beginning of the string.
计算字符串的长度，有3个操作数。操作数0为结果（机器模式为@var{m}），操作数1为一个@code{mem}，指出字符串的第一个字符，操作数2为要查找的字符（通常为零），操作数3为一个常量，描述了字符串起始处的已知对齐方式。

@cindex @code{float@var{m}@var{n}2} instruction pattern
@item @samp{float@var{m}@var{n}2}
@en Convert signed integer operand 1 (valid for fixed point mode @var{m}) to
@en floating point mode @var{n} and store in operand 0 (which has mode
@en @var{n}).
将有符号整数，操作数1（对于定点机器模式@var{m}有效），转换成浮点机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。
 
@cindex @code{floatuns@var{m}@var{n}2} instruction pattern
@item @samp{floatuns@var{m}@var{n}2}
@en Convert unsigned integer operand 1 (valid for fixed point mode @var{m})
@en to floating point mode @var{n} and store in operand 0 (which has mode
@en @var{n}).
将无符号整数，操作数1（对于定点机器模式@var{m}有效），转换成浮点机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。
 
@cindex @code{fix@var{m}@var{n}2} instruction pattern
@item @samp{fix@var{m}@var{n}2}
@en Convert operand 1 (valid for floating point mode @var{m}) to fixed
@en point mode @var{n} as a signed number and store in operand 0 (which
@en has mode @var{n}).  This instruction's result is defined only when
@en the value of operand 1 is an integer.
将操作数1（对于浮点机器模式@var{m}有效），转换成定点机器模式@var{n}，作为一个有符号数并存放在操作数0（机器模式为@var{n}）中。该指令的结果，只有当操作数1的值为整数时，才被定义。

@en If the machine description defines this pattern, it also needs to
@en define the @code{ftrunc} pattern.
如果机器描述定义了该指令模式，则其还需要定义@code{ftrunc}指令模式。
 
@cindex @code{fixuns@var{m}@var{n}2} instruction pattern
@item @samp{fixuns@var{m}@var{n}2}
@en Convert operand 1 (valid for floating point mode @var{m}) to fixed
@en point mode @var{n} as an unsigned number and store in operand 0 (which
@en has mode @var{n}).  This instruction's result is defined only when the
@en value of operand 1 is an integer.
将操作数1（对于浮点机器模式@var{m}有效），转换成定点机器模式@var{n}，作为一个无符号数并存放在操作数0（机器模式为@var{n}）中。该指令的结果，只有当操作数1的值为整数时，才被定义。
 
@cindex @code{ftrunc@var{m}2} instruction pattern
@item @samp{ftrunc@var{m}2}
@en Convert operand 1 (valid for floating point mode @var{m}) to an
@en integer value, still represented in floating point mode @var{m}, and
@en store it in operand 0 (valid for floating point mode @var{m}).
将操作数1（对于浮点机器模式@var{m}有效），转换成整数值，仍按照浮点机器模式@var{m}来表示，并存放在操作数0（对于浮点机器模式@var{m}有效）中。
 
@cindex @code{fix_trunc@var{m}@var{n}2} instruction pattern
@item @samp{fix_trunc@var{m}@var{n}2}
@en Like @samp{fix@var{m}@var{n}2} but works for any floating point value
@en of mode @var{m} by converting the value to an integer.
类似于@samp{fix@var{m}@var{n}2}，不过工作于，将任意机器模式为@var{m}的浮点值，转换成整数。
 
@cindex @code{fixuns_trunc@var{m}@var{n}2} instruction pattern
@item @samp{fixuns_trunc@var{m}@var{n}2}
@en Like @samp{fixuns@var{m}@var{n}2} but works for any floating point
@en value of mode @var{m} by converting the value to an integer.
类似@samp{fixuns@var{m}@var{n}2}，不过工作于，将任意机器模式为@var{m}的浮点值，转换成整数。

@cindex @code{trunc@var{m}@var{n}2} instruction pattern
@item @samp{trunc@var{m}@var{n}2}
@en Truncate operand 1 (valid for mode @var{m}) to mode @var{n} and
@en store in operand 0 (which has mode @var{n}).  Both modes must be fixed
@en point or both floating point.
将操作数1（对机器模式@var{m}有效），截取为机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。两个机器模式都必须同为定点的或者浮点的。

@cindex @code{extend@var{m}@var{n}2} instruction pattern
@item @samp{extend@var{m}@var{n}2}
@en Sign-extend operand 1 (valid for mode @var{m}) to mode @var{n} and
@en store in operand 0 (which has mode @var{n}).  Both modes must be fixed
@en point or both floating point.
将操作数1（对机器模式@var{m}有效）符号扩展成机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。两个机器模式都必须同为定点的或者浮点的。
 
@cindex @code{zero_extend@var{m}@var{n}2} instruction pattern
@item @samp{zero_extend@var{m}@var{n}2}
@en Zero-extend operand 1 (valid for mode @var{m}) to mode @var{n} and
@en store in operand 0 (which has mode @var{n}).  Both modes must be fixed
@en point.
将操作数1（对机器模式@var{m}有效）零扩展成机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。两个机器模式都必须同为定点的或者浮点的。

@cindex @code{fract@var{m}@var{n}2} instruction pattern
@item @samp{fract@var{m}@var{n}2}
@en Convert operand 1 of mode @var{m} to mode @var{n} and store in
@en operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
@en could be fixed-point to fixed-point, signed integer to fixed-point,
@en fixed-point to signed integer, floating-point to fixed-point,
@en or fixed-point to floating-point.
@en When overflows or underflows happen, the results are undefined.
将机器模式为@var{m}的操作数1，转换成机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。机器模式@var{m}和@var{n}可以为定点到定点，有符号整数到定点，定点到有符号整数，浮点到浮点，或者定点到浮点。当发生溢出时，结果未定义。
 
@cindex @code{satfract@var{m}@var{n}2} instruction pattern
@item @samp{satfract@var{m}@var{n}2}
@en Convert operand 1 of mode @var{m} to mode @var{n} and store in
@en operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
@en could be fixed-point to fixed-point, signed integer to fixed-point,
@en or floating-point to fixed-point.
@en When overflows or underflows happen, the instruction saturates the
@en results to the maximum or the minimum.
将机器模式为@var{m}的操作数1，转换成机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。机器模式@var{m}和@var{n}可以为定点到定点，有符号整数到定点，或者浮点到定点。当发生溢出时，指令将结果饱和为最大或最小值。
 
@cindex @code{fractuns@var{m}@var{n}2} instruction pattern
@item @samp{fractuns@var{m}@var{n}2}
@en Convert operand 1 of mode @var{m} to mode @var{n} and store in
@en operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
@en could be unsigned integer to fixed-point, or
@en fixed-point to unsigned integer.
@en When overflows or underflows happen, the results are undefined.
将机器模式为@var{m}的操作数1，转换成机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。机器模式@var{m}和@var{n}可以为无符号整数到定点，或者定点到无符号整数。当发生溢出时，结果未定义。
 
@cindex @code{satfractuns@var{m}@var{n}2} instruction pattern
@item @samp{satfractuns@var{m}@var{n}2}
@en Convert unsigned integer operand 1 of mode @var{m} to fixed-point mode
@en @var{n} and store in operand 0 (which has mode @var{n}).
@en When overflows or underflows happen, the instruction saturates the
@en results to the maximum or the minimum.
将机器模式为@var{m}的，无符号整数，操作数1，转换成定点机器模式@var{n}，并存放在操作数0（机器模式为@var{n}）中。当发生溢出时，指令将结果饱和为最大或最小值。

@cindex @code{extv} instruction pattern
@item @samp{extv}
@en Extract a bit-field from operand 1 (a register or memory operand), where
@en operand 2 specifies the width in bits and operand 3 the starting bit,
@en and store it in operand 0.  Operand 0 must have mode @code{word_mode}.
@en Operand 1 may have mode @code{byte_mode} or @code{word_mode}; often
@en @code{word_mode} is allowed only for registers.  Operands 2 and 3 must
@en be valid for @code{word_mode}.
从操作数1（寄存器或者内存操作数）中抽取一个位域，其中操作数2指定了宽度，按位为单位，操作数3为起始位，并将结果存放在操作数0中。操作数0必须具有机器模式@code{word_mode}。操作数1可以具有机器模式@code{byte_mode} 或 @code{word_mode}；通常@code{word_mode}只允许用于寄存器。操作数2和3必须对@code{word_mode}有效。

@en The RTL generation pass generates this instruction only with constants
@en for operands 2 and 3 and the constant is never zero for operand 2.
RTL生成过程，生成的该指令，操作数2和3为常量，并且对于操作数2，常量不为零。
 
@en The bit-field value is sign-extended to a full word integer
@en before it is stored in operand 0.
位域的值，在存放到操作数0之前，被有符号扩展为一整个字的整数。
 
@cindex @code{extzv} instruction pattern
@item @samp{extzv}
@en Like @samp{extv} except that the bit-field value is zero-extended.
类似@samp{extv}，只不过位域的值被零扩展。
 
@cindex @code{insv} instruction pattern
@item @samp{insv}
@en Store operand 3 (which must be valid for @code{word_mode}) into a
@en bit-field in operand 0, where operand 1 specifies the width in bits and
@en operand 2 the starting bit.  Operand 0 may have mode @code{byte_mode} or
@en @code{word_mode}; often @code{word_mode} is allowed only for registers.
@en Operands 1 and 2 must be valid for @code{word_mode}.
将操作数3（必须对@code{word_mode}有效）存储到操作数0中的位域，其中操作数1指定了位宽，操作数2指定了起始位。操作数0可以具有机器模式@code{byte_mode} 或 @code{word_mode}；通常@code{word_mode}只允许用于寄存器。操作数1和2必须对@code{word_mode}有效。

@en The RTL generation pass generates this instruction only with constants
@en for operands 1 and 2 and the constant is never zero for operand 1.
RTL生成过程，生成的该指令，操作数1和2为常量，并且对于操作数1，常量不为零。

@cindex @code{mov@var{mode}cc} instruction pattern
@item @samp{mov@var{mode}cc}
@en Conditionally move operand 2 or operand 3 into operand 0 according to the
@en comparison in operand 1.  If the comparison is true, operand 2 is moved
@en into operand 0, otherwise operand 3 is moved.
根据对操作数1的比较，有条件的将操作数2或者3移送到操作数0中。如果比较为真，则操作数2被移送到操作数0中，否则操作数3被移送。

@en The mode of the operands being compared need not be the same as the operands
@en being moved.  Some machines, sparc64 for example, have instructions that
@en conditionally move an integer value based on the floating point condition
@en codes and vice versa.
操作数的机器模式不需要与被移送的操作数的相同。一些机器，例如sparc64，具有可以根据浮点条件码，条件移送整数值的指令，以及相反的指令。

@en If the machine does not have conditional move instructions, do not
@en define these patterns.
如果机器没有条件移送指令，则不要定义这些指令模式。

@cindex @code{add@var{mode}cc} instruction pattern
@item @samp{add@var{mode}cc}
@en Similar to @samp{mov@var{mode}cc} but for conditional addition.  Conditionally
@en move operand 2 or (operands 2 + operand 3) into operand 0 according to the
@en comparison in operand 1.  If the comparison is true, operand 2 is moved into
@en operand 0, otherwise (operand 2 + operand 3) is moved.
类似于@samp{mov@var{mode}cc}，不过是条件加法。根据在操作数1中的比较，条件性的将操作数2或者(操作数2 + 操作数3)，移送到操作数0中。如果比较为真，则操作数2被移送到操作数0中，否则(操作数2 + 操作数3)被移送。

@cindex @code{s@var{cond}} instruction pattern
@item @samp{s@var{cond}}
根据条件码将零或者非零存放在操作数中。当且仅当条件@var{cond}为真时，存储的值才为非零。@var{cond}为一个比较运算表达式代码的名字，例如@code{eq}, @code{lt}或@code{leu}。

当书写@code{match_operand}表达式的时候，你来指定操作数必须具有的机器模式。编译器自动的查看你使用的机器模式，并提供那个机器模式的操作数。

对于条件为真时所存储的值，其低位必须为1，不然必须为负。否则，指令就不适合，你应该从机器描述中将其去掉。你可以通过定义宏@code{STORE_FLAG_VALUE} (@pxref{Misc})，来描述哪个值被存放。如果不能找到一个用于所有@samp{s@var{cond}}指令模式的描述，则你应该从机器描述中去掉这些操作。

这些操作可以失败，但应该只在相对不常见的情况下这样做；如果它们对于常见的情况，包括整数比较，会失败，则最好去掉这些指令模式。

如果这些操作被去掉，则编译器通常会生成，将常量复制到目标，并在将零赋值给目标的语句附近进行分支跳转。如果这样的代码比用于@samp{s@var{cond}}模式的指令，后面跟着需要将结果转成@code{SImode}的1或者零的的指令，更有效，则你应该从机器描述中去掉@samp{s@var{cond}}操作。

@cindex @code{b@var{cond}} instruction pattern
@item @samp{b@var{cond}}
条件分支指令。操作数0为一个@code{label_ref}指出要跳转到的标号。如果条件码符合条件@var{cond}则跳转。

一些机器不遵循这里假设的模型，即一个比较指令，跟随一个条件跳转指令。那种情况下，@samp{cmp@var{m}} (和 @samp{tst@var{m}})指令模式，应该简单的将操作数存放开，并在@code{define_expand} (@pxref{Expander Definitions})中为条件分支操作，生成所有需要的insn。所有对扩展@samp{b@var{cond}}指令模式的调用，都会立即优先执行对扩展@samp{cmp@var{m}}或者@samp{tst@var{m}}的调用。

对条件代码值使用伪寄存器的，或者用于比较的机器模式取决于被测试的条件的机器，也应该使用上面的机制。@xref{Jump Patterns}.

上面的讨论也应用在@samp{mov@var{mode}cc}和@samp{s@var{cond}}指令模式上。

@en @cindex @code{cstore@var{mode}4} instruction pattern
@en @item @samp{cstore@var{mode}4}
@en Store zero or nonzero in operand 0 according to whether a comparison
@en is true.  Operand 1 is a comparison operator.  Operand 2 and operand 3
@en are the first and second operand of the comparison, respectively.
@en You specify the mode that operand 0 must have when you write the
@en @code{match_operand} expression.  The compiler automatically sees which
@en mode you have used and supplies an operand of that mode.
@en 
@en The value stored for a true condition must have 1 as its low bit, or
@en else must be negative.  Otherwise the instruction is not suitable and
@en you should omit it from the machine description.  You describe to the
@en compiler exactly which value is stored by defining the macro
@en @code{STORE_FLAG_VALUE} (@pxref{Misc}).  If a description cannot be
@en found that can be used for all the possible comparison operators, you
@en should pick one and use a @code{define_expand} to map all results
@en onto the one you chose.
@en 
@en These operations may @code{FAIL}, but should do so only in relatively
@en uncommon cases; if they would @code{FAIL} for common cases involving
@en integer comparisons, it is best to restrict the predicates to not
@en allow these operands.  Likewise if a given comparison operator will
@en always fail, independent of the operands (for floating-point modes, the
@en @code{ordered_comparison_operator} predicate is often useful in this case).
@en 
@en If this pattern is omitted, the compiler will generate a conditional
@en branch---for example, it may copy a constant one to the target and branching
@en around an assignment of zero to the target---or a libcall.  If the predicate
@en for operand 1 only rejects some operators, it will also try reordering the
@en operands and/or inverting the result value (e.g.@: by an exclusive OR).
@en These possibilities could be cheaper or equivalent to the instructions
@en used for the @samp{cstore@var{mode}4} pattern followed by those required
@en to convert a positive result from @code{STORE_FLAG_VALUE} to 1; in this
@en case, you can and should make operand 1's predicate reject some operators
@en in the @samp{cstore@var{mode}4} pattern, or remove the pattern altogether
@en from the machine description.
@en 
@cindex @code{cbranch@var{mode}4} instruction pattern
@item @samp{cbranch@var{mode}4}
@en Conditional branch instruction combined with a compare instruction.
@en Operand 0 is a comparison operator.  Operand 1 and operand 2 are the
@en first and second operands of the comparison, respectively.  Operand 3
@en is a @code{label_ref} that refers to the label to jump to.
条件分支指令，结合一个比较指令。操作数0为比较运算符。操作数1和2分别为比较运算的第一个和第二个操作数。操作数3为一个@code{label_ref}，指出了跳转的标号。

@cindex @code{jump} instruction pattern
@item @samp{jump}
@en A jump inside a function; an unconditional branch.  Operand 0 is the
@en @code{label_ref} of the label to jump to.  This pattern name is mandatory
@en on all machines.
函数内部跳转；无条件分支。操作数0为一个@code{label_ref}，指出了跳转的标号。该指令模式名在所有机器上都是强制必须的。

@cindex @code{call} instruction pattern
@item @samp{call}
@en Subroutine call instruction returning no value.  Operand 0 is the
@en function to call; operand 1 is the number of bytes of arguments pushed
@en as a @code{const_int}; operand 2 is the number of registers used as
@en operands.
没有返回值的子程序调用指令。操作数0为调用的函数；操作数1为压栈的参数的字节数，为一个@code{const_int}；操作数2为用作操作数的寄存器数目。
 
@en On most machines, operand 2 is not actually stored into the RTL
@en pattern.  It is supplied for the sake of some RISC machines which need
@en to put this information into the assembler code; they can put it in
@en the RTL instead of operand 1.
在大多机器上，操作数2没有被实际存放在RTL模式中。提供它是出于安全考虑，一些RISC机器需要将该信息放到汇编代码中；它们可以将其放在RTL中，而不是操作数1中。

@en Operand 0 should be a @code{mem} RTX whose address is the address of the
@en function.  Note, however, that this address can be a @code{symbol_ref}
@en expression even if it would not be a legitimate memory address on the
@en target machine.  If it is also not a valid argument for a call
@en instruction, the pattern for this operation should be a
@en @code{define_expand} (@pxref{Expander Definitions}) that places the
@en address into a register and uses that register in the call instruction.
操作数0应该为一个@code{mem} RTX，其地址为函数的地址。然而注意，该地址可以为一个@code{symbol_ref}表达式，即使其在目标机器上可能不是一个合法的内存地址。如果其也不是调用指令的有效参数，则该操作的指令模式应该为一个@code{define_expand} (@pxref{Expander Definitions})，其将地址放入寄存器中，并在调用指令中使用寄存器。

@cindex @code{call_value} instruction pattern
@item @samp{call_value}
@en Subroutine call instruction returning a value.  Operand 0 is the hard
@en register in which the value is returned.  There are three more
@en operands, the same as the three operands of the @samp{call}
@en instruction (but with numbers increased by one).
有返回值的子程序调用指令。操作数0为硬件寄存器，存放返回值。还有三个操作数，与@samp{call}指令相同（只不过将编号加一）。

@en Subroutines that return @code{BLKmode} objects use the @samp{call}
@en insn.
返回 @code{BLKmode}对象的子程序，使用@samp{call} insn。

@cindex @code{call_pop} instruction pattern
@cindex @code{call_value_pop} instruction pattern
@item @samp{call_pop}, @samp{call_value_pop}
@en Similar to @samp{call} and @samp{call_value}, except used if defined and
@en if @code{RETURN_POPS_ARGS} is nonzero.  They should emit a @code{parallel}
@en that contains both the function call and a @code{set} to indicate the
@en adjustment made to the frame pointer.
类似于@samp{call} 和 @samp{call_value}，只不过用于其被定义，并且@code{RETURN_POPS_ARGS}为非零的时候。它们应该生成一个 @code{parallel}，包含函数调用和一个@code{set}，来指示对帧指针的调整。

@en For machines where @code{RETURN_POPS_ARGS} can be nonzero, the use of these
@en patterns increases the number of functions for which the frame pointer
@en can be eliminated, if desired.
对于@code{RETURN_POPS_ARGS}可以为非零的机器，使用这些指令模式可以增加帧指针被消除掉的函数的数目。

@cindex @code{untyped_call} instruction pattern
@item @samp{untyped_call}
@en Subroutine call instruction returning a value of any type.  Operand 0 is
@en the function to call; operand 1 is a memory location where the result of
@en calling the function is to be stored; operand 2 is a @code{parallel}
@en expression where each element is a @code{set} expression that indicates
@en the saving of a function return value into the result block.
返回一个任意类型的值的子函数调用指令。操作数0为调用的函数；操作数1为内存位置，存放调用函数后的结果；操作数2为一个@code{parallel}表达式，其中每个元素都为一个@code{set}表达式，用来指示将函数返回值保存到结果块中。

@en This instruction pattern should be defined to support
@en @code{__builtin_apply} on machines where special instructions are needed
@en to call a subroutine with arbitrary arguments or to save the value
@en returned.  This instruction pattern is required on machines that have
@en multiple registers that can hold a return value
@en (i.e.@: @code{FUNCTION_VALUE_REGNO_P} is true for more than one register).
该指令模式应该被定义，来支持@code{__builtin_apply}，在一些机器上，需要特殊的指令来调用一个具有任意参数的子程序，或者将返回值保存。在具有多个寄存器，可以存放一个返回值（即@code{FUNCTION_VALUE_REGNO_P}对多个寄存器都为真）的机器上，需要该指令模式。

@cindex @code{return} instruction pattern
@item @samp{return}
@en Subroutine return instruction.  This instruction pattern name should be
@en defined only if a single instruction can do all the work of returning
@en from a function.
子程序返回指令。该指令模式名应该只有当，单个指令可以做从函数中返回时的所有工作的时候，才被定义。

@en Like the @samp{mov@var{m}} patterns, this pattern is also used after the
@en RTL generation phase.  In this case it is to support machines where
@en multiple instructions are usually needed to return from a function, but
@en some class of functions only requires one instruction to implement a
@en return.  Normally, the applicable functions are those which do not need
@en to save any registers or allocate stack space.
类似@samp{mov@var{m}}指令模式，该指令模式也在RTL生成阶段之后被使用。这种情况下，其用来支持一些机器，从函数中返回通常需要多个指令，但是某些类别的函数只需要一条指令来实现返回。通常，可以适用的函数为那些不需要保存任何寄存器或者分配栈空间的函数。

@findex reload_completed
@findex leaf_function_p
@en For such machines, the condition specified in this pattern should only
@en be true when @code{reload_completed} is nonzero and the function's
@en epilogue would only be a single instruction.  For machines with register
@en windows, the routine @code{leaf_function_p} may be used to determine if
@en a register window push is required.
对于这样的机器，该指令模式中指定的条件，应该只有当@code{reload_completed}为非零的时候才为真，并且函数的尾声应该只为一单个指令。对于有寄存器窗口的机器，例程@code{leaf_function_p}可以用来确定是否需要对寄存器窗口压栈。

@en Machines that have conditional return instructions should define patterns
@en such as
具有条件性返回指令的机器，应该将指令模式定义成

@smallexample
(define_insn ""
  [(set (pc)
        (if_then_else (match_operator
                         0 "comparison_operator"
                         [(cc0) (const_int 0)])
                      (return)
                      (pc)))]
  "@var{condition}"
  "@dots{}")
@end smallexample

@en where @var{condition} would normally be the same condition specified on the
@en named @samp{return} pattern.
其中@var{condition}通常为，在@samp{return}指令模式中指定的相同的条件。 

@cindex @code{untyped_return} instruction pattern
@item @samp{untyped_return}
@en Untyped subroutine return instruction.  This instruction pattern should
@en be defined to support @code{__builtin_return} on machines where special
@en instructions are needed to return a value of any type.
未定义类型的子程序返回指令。该指令模式应该被定义，来支持@code{__builtin_return}，在一些机器上，需要特殊的指令来返回一个任意类型的值。

@en Operand 0 is a memory location where the result of calling a function
@en with @code{__builtin_apply} is stored; operand 1 is a @code{parallel}
@en expression where each element is a @code{set} expression that indicates
@en the restoring of a function return value from the result block.
操作数0为一个内存位置，存放使用@code{__builtin_apply}调用函数的结果；操作数1为一个@code{parallel}表达式，每个元素都是一个@code{set}表达式，指示了从结果块中恢复函数的返回值。

@cindex @code{nop} instruction pattern
@item @samp{nop}
@en No-op instruction.  This instruction pattern name should always be defined
@en to output a no-op in assembler code.  @code{(const_int 0)} will do as an
@en RTL pattern.
空操作指令。该指令模式名应该总是被定义，用来在汇编代码中输出一个no-op。@code{(const_int 0)}将作为一个RTL指令模式。

@cindex @code{indirect_jump} instruction pattern
@item @samp{indirect_jump}
@en An instruction to jump to an address which is operand zero.
@en This pattern name is mandatory on all machines.
一个指令，跳转到操作数0表示的地址。该指令模式名在所有机器上都必须存在。

@cindex @code{casesi} instruction pattern
@item @samp{casesi}
@en Instruction to jump through a dispatch table, including bounds checking.
@en This instruction takes five operands:
通过派遣表进行跳转的指令，包括边界检查。该指令接受五个操作数：
 
@enumerate
@item
@en The index to dispatch on, which has mode @code{SImode}.
派遣的索引，具有机器模式@code{SImode}。

@item
@en The lower bound for indices in the table, an integer constant.
表中索引的较低边界，一个整数常量。

@item
@en The total range of indices in the table---the largest index
@en minus the smallest one (both inclusive).
表中索引的整个范围---最大索引减去最小的。

@item
@en A label that precedes the table itself.
位于表之前的标号。

@item
@en A label to jump to if the index has a value outside the bounds.
一个标号，如果索引值超出边界，则跳转到该地方。

@end enumerate

@en The table is an @code{addr_vec} or @code{addr_diff_vec} inside of a
@en @code{jump_insn}.  The number of elements in the table is one plus the
@en difference between the upper bound and the lower bound.
表为@code{jump_insn}中的一个@code{addr_vec} 或 @code{addr_diff_vec}。表中的元素个数为一加上上界和下界的差。

@cindex @code{tablejump} instruction pattern
@item @samp{tablejump}
@en Instruction to jump to a variable address.  This is a low-level
@en capability which can be used to implement a dispatch table when there
@en is no @samp{casesi} pattern.
跳转到一个可变地址的指令。这是一个低级别的能力，可以用来实现一个派遣表，当没有@samp{casesi}指令模式的时候。

@en This pattern requires two operands: the address or offset, and a label
@en which should immediately precede the jump table.  If the macro
@en @code{CASE_VECTOR_PC_RELATIVE} evaluates to a nonzero value then the first
@en operand is an offset which counts from the address of the table; otherwise,
@en it is an absolute address to jump to.  In either case, the first operand has
@en mode @code{Pmode}.
该指令模式需要两个操作数：地址或偏移量，以及一个标号，其直接位于跳转表的前面。如果宏@code{CASE_VECTOR_PC_RELATIVE}求值为一个非零值，则第一个操作数为一个偏移量，其从表的地址开始计算；否则，其为一个跳转的绝对地址。这两种情况下，第一个操作数都为@code{Pmode}。

@en The @samp{tablejump} insn is always the last insn before the jump
@en table it uses.  Its assembler code normally has no need to use the
@en second operand, but you should incorporate it in the RTL pattern so
@en that the jump optimizer will not delete the table as unreachable code.
@en 
@samp{tablejump} insn总是其使用的跳转表之前的最后一个insn。其汇编代码通常不需要用到第二个操作数，但是你应该在RTL指令模式中包含它，使得跳转优化不会将表作为不可到达代码删除。

@cindex @code{decrement_and_branch_until_zero} instruction pattern
@item @samp{decrement_and_branch_until_zero}
@en Conditional branch instruction that decrements a register and
@en jumps if the register is nonzero.  Operand 0 is the register to
@en decrement and test; operand 1 is the label to jump to if the
@en register is nonzero.  @xref{Looping Patterns}.
条件分支指令，递减一个寄存器并且如果寄存器非零则跳转。操作数0为递减并测试的寄存器；操作数1为如果寄存器非零，则跳转的标号。@xref{Looping Patterns}.

@en This optional instruction pattern is only used by the combiner,
@en typically for loops reversed by the loop optimizer when strength
@en reduction is enabled.
该可选的指令模式只用于合并器，通常被循环优化器使用，当启动强度消减的时候。

@cindex @code{doloop_end} instruction pattern
@item @samp{doloop_end}
@en Conditional branch instruction that decrements a register and jumps if
@en the register is nonzero.  This instruction takes five operands: Operand
@en 0 is the register to decrement and test; operand 1 is the number of loop
@en iterations as a @code{const_int} or @code{const0_rtx} if this cannot be
@en determined until run-time; operand 2 is the actual or estimated maximum
@en number of iterations as a @code{const_int}; operand 3 is the number of
@en enclosed loops as a @code{const_int} (an innermost loop has a value of
@en 1); operand 4 is the label to jump to if the register is nonzero.
@en @xref{Looping Patterns}.
条件分支指令，递减一个寄存器，并且如果寄存器非零则跳转。该指令接受五个操作数：操作数0是用来递减和测试的寄存器；操作数1是循环迭代的次数，为一个@code{const_int}，或者如果直到运行时才能确定，则为@code{const0_rtx}；操作数2为实际的或者估算的最大迭代数，为一个@code{const_int}；操作数3为被包含的循环数，为一个@code{const_int}（最内层循环的值为1）；操作数4为如果寄存器非零，要跳转的标号。@xref{Looping Patterns}.

@en This optional instruction pattern should be defined for machines with
@en low-overhead looping instructions as the loop optimizer will try to
@en modify suitable loops to utilize it.  If nested low-overhead looping is
@en not supported, use a @code{define_expand} (@pxref{Expander Definitions})
@en and make the pattern fail if operand 3 is not @code{const1_rtx}.
@en Similarly, if the actual or estimated maximum number of iterations is
@en too large for this instruction, make it fail.
该可选的指令模式应该为，具有低开销循环指令的机器定义，循环优化器会尝试修改合适的循环来利用它。如果不支持嵌套的低开销循环，则使用@code{define_expand} (@pxref{Expander Definitions})，并如果操作数3不为@code{const1_rtx}，则使得指令模式失败。类似的，如果实际的或者估算的最大迭代数目对于该指令来说太大，则使其失败。

@cindex @code{doloop_begin} instruction pattern
@item @samp{doloop_begin}
@en Companion instruction to @code{doloop_end} required for machines that
@en need to perform some initialization, such as loading special registers
@en used by a low-overhead looping instruction.  If initialization insns do
@en not always need to be emitted, use a @code{define_expand}
@en (@pxref{Expander Definitions}) and make it fail.
@en 
与@code{doloop_end}成套的指令，被用于需要执行一些初始化的机器，例如加载用于低开销循环指令中的特定寄存器。如果初始化insn不总是需要被生成，则使用@code{define_expand} (@pxref{Expander Definitions})，并使其失败。

@cindex @code{canonicalize_funcptr_for_compare} instruction pattern
@item @samp{canonicalize_funcptr_for_compare}
@en Canonicalize the function pointer in operand 1 and store the result
@en into operand 0.
正规化操作数1中的函数指针，并将结果存放在操作数0中。

@en Operand 0 is always a @code{reg} and has mode @code{Pmode}; operand 1
@en may be a @code{reg}, @code{mem}, @code{symbol_ref}, @code{const_int}, etc
@en and also has mode @code{Pmode}.
操作数0总是一个@code{reg}，并具有机器模式@code{Pmode}；操作数1可以为一个@code{reg}, @code{mem}, @code{symbol_ref}, @code{const_int}等等，也具有机器模式@code{Pmode}。

@en Canonicalization of a function pointer usually involves computing
@en the address of the function which would be called if the function
@en pointer were used in an indirect call.
正规化一个函数指针，通常涉及到计算函数的地址，该函数指针用在间接调用中。

@en Only define this pattern if function pointers on the target machine
@en can have different values but still call the same function when
@en used in an indirect call.
只有当目标机器上，对于函数指针可以有不同的值，但是当在间接调用的时候，其还是调用相同的函数的时候，才定义该指令模式。

@cindex @code{save_stack_block} instruction pattern
@cindex @code{save_stack_function} instruction pattern
@cindex @code{save_stack_nonlocal} instruction pattern
@cindex @code{restore_stack_block} instruction pattern
@cindex @code{restore_stack_function} instruction pattern
@cindex @code{restore_stack_nonlocal} instruction pattern
@item @samp{save_stack_block}
@itemx @samp{save_stack_function}
@itemx @samp{save_stack_nonlocal}
@itemx @samp{restore_stack_block}
@itemx @samp{restore_stack_function}
@itemx @samp{restore_stack_nonlocal}
@en Most machines save and restore the stack pointer by copying it to or
@en from an object of mode @code{Pmode}.  Do not define these patterns on
@en such machines.
大多数机器用来保存和恢复栈指针的方式，是通过将其复制到一个机器模式为@code{Pmode}的对象。不要在这样的机器上定义这些指令模式。

@en Some machines require special handling for stack pointer saves and
@en restores.  On those machines, define the patterns corresponding to the
@en non-standard cases by using a @code{define_expand} (@pxref{Expander
@en Definitions}) that produces the required insns.  The three types of
@en saves and restores are:
一些机器要求对栈指针的保存和恢复，进行特殊的处理。在那些机器上，根据非标准的情况来定义指令模式，使用@code{define_expand} (@pxref{Expander Definitions})来产生要求的insn。三种保存和恢复类型：

@enumerate
@item
@en @samp{save_stack_block} saves the stack pointer at the start of a block
@en that allocates a variable-sized object, and @samp{restore_stack_block}
@en restores the stack pointer when the block is exited.
@samp{save_stack_block}将栈指针存放在用来分配可变大小的对象块的起始处，@samp{restore_stack_block}当退出块的时候恢复栈指针。

@item
@en @samp{save_stack_function} and @samp{restore_stack_function} do a
@en similar job for the outermost block of a function and are used when the
@en function allocates variable-sized objects or calls @code{alloca}.  Only
@en the epilogue uses the restored stack pointer, allowing a simpler save or
@en restore sequence on some machines.
@samp{save_stack_function} 和 @samp{restore_stack_function}为函数最外层的快做类似的工作，并用于当函数分配可变大小的对象或者调用@code{alloca}的时候。只有尾声使用被恢复的栈指针，这使得在一些机器上，可以有更简单的保存或恢复序列。

@item
@en @samp{save_stack_nonlocal} is used in functions that contain labels
@en branched to by nested functions.  It saves the stack pointer in such a
@en way that the inner function can use @samp{restore_stack_nonlocal} to
@en restore the stack pointer.  The compiler generates code to restore the
@en frame and argument pointer registers, but some machines require saving
@en and restoring additional data such as register window information or
@en stack backchains.  Place insns in these patterns to save and restore any
@en such required data.
@samp{save_stack_nonlocal}用在包含嵌套函数分支跳转标号的函数中。其保存栈指针的方式为，最内层函数可以使用@samp{restore_stack_nonlocal}来恢复栈指针。编译器生成代码，用来恢复帧寄存器和参数指针寄存器，但是一些机器要求保存和恢复额外的数据，例如寄存器窗口信息或者栈后退链。在这些指令模式中放置保存和恢复这些要求的数据的insn。
@end enumerate

@en When saving the stack pointer, operand 0 is the save area and operand 1
@en is the stack pointer.  The mode used to allocate the save area defaults
@en to @code{Pmode} but you can override that choice by defining the
@en @code{STACK_SAVEAREA_MODE} macro (@pxref{Storage Layout}).  You must
@en specify an integral mode, or @code{VOIDmode} if no save area is needed
@en for a particular type of save (either because no save is needed or
@en because a machine-specific save area can be used).  Operand 0 is the
@en stack pointer and operand 1 is the save area for restore operations.  If
@en @samp{save_stack_block} is defined, operand 0 must not be
@en @code{VOIDmode} since these saves can be arbitrarily nested.
当保存栈指针时，操作数0是保存区域，操作数1是栈指针。用于分配保存区域的机器模式缺省为@code{Pmode}，不过你可以通过定义@code{STACK_SAVEAREA_MODE}宏(@pxref{Storage Layout})来覆盖该选择。你必须指定一个整数机器模式，或者@code{VOIDmode}，如果对于特定的类型不需要保存区域（或者因为没有需要保存的，或者因为可以使用机器特定的保存区域）。操作数0为栈指针，操作数1为用于恢复操作的保存区域。如果@samp{save_stack_block}被定义，则操作数0一定不能为@code{VOIDmode}，因为这些保存操作数可以被任意的嵌套。

@en A save area is a @code{mem} that is at a constant offset from
@en @code{virtual_stack_vars_rtx} when the stack pointer is saved for use by
@en nonlocal gotos and a @code{reg} in the other two cases.
当栈指针被保存，是用于非局部goto，则保存区域为一个@code{mem}，为一个相对于@code{virtual_stack_vars_rtx}的常量偏移，其它两种情况下，保存区域为一个@code{reg}。

@cindex @code{allocate_stack} instruction pattern
@item @samp{allocate_stack}
@en Subtract (or add if @code{STACK_GROWS_DOWNWARD} is undefined) operand 1 from
@en the stack pointer to create space for dynamically allocated data.
@en 
@en Store the resultant pointer to this space into operand 0.  If you
@en are allocating space from the main stack, do this by emitting a
@en move insn to copy @code{virtual_stack_dynamic_rtx} to operand 0.
@en If you are allocating the space elsewhere, generate code to copy the
@en location of the space to operand 0.  In the latter case, you must
@en ensure this space gets freed when the corresponding space on the main
@en stack is free.
从栈指针中减去（或者增加，如果@code{STACK_GROWS_DOWNWARD}未定义）操作数1，来为动态分配的数据创建空间。将由此产生的指向该空间的指针存放在操作数0中。如果你是从主栈中分配空间，则可以通过生成一个insn，将@code{virtual_stack_dynamic_rtx}复制到操作数0中。如果你是从其它地方分配空间，则可以生成将该空间的位置复制到操作数0中的代码。对于后者情况，你必须确保该空间当主栈中对应的空间被释放的时候，其也被释放。

@en Do not define this pattern if all that must be done is the subtraction.
@en Some machines require other operations such as stack probes or
@en maintaining the back chain.  Define this pattern to emit those
@en operations in addition to updating the stack pointer.
如果所有需要做的事情只是减法操作，则不用定义该指令模式。一些机器还要求其它的操作，例如栈探测，或者维护后向链。定义该指令模式除了更新栈指针之外的，来生成那些操作。

@cindex @code{check_stack} instruction pattern
@item @samp{check_stack}
@en If stack checking (@pxref{Stack Checking}) cannot be done on your system by
@en probing the stack, define this pattern to perform the needed check and signal
@en an error if the stack has overflowed.  The single operand is the address in
@en the stack farthest from the current stack pointer that you need to validate.
@en Normally, on platforms where this pattern is needed, you would obtain the
@en stack limit from a global or thread-specific variable or register.
如果在你的系统上，不能通过使用加载或者存储指令(@pxref{Stack Checking})探测栈，从而进行栈检查，则定义该指令模式来执行所需要的检查，并且如果栈已经溢出则产生一个错误信号。有单个操作数，为栈中从当前栈指针开始，最远的栈位置。通常，在需要该指令模式的机器上，你将从一个全局的或者线程特定的变量或者寄存器中获得栈的限制。

@cindex @code{probe_stack} instruction pattern
@item @samp{probe_stack}
If stack checking (@pxref{Stack Checking}) can be done on your system by
probing the stack but doing it with a ``store zero'' instruction is not valid
or optimal, define this pattern to do the probing differently and signal an
error if the stack has overflowed.  The single operand is the memory reference
in the stack that needs to be probed.

@cindex @code{nonlocal_goto} instruction pattern
@item @samp{nonlocal_goto}
@en Emit code to generate a non-local goto, e.g., a jump from one function
@en to a label in an outer function.  This pattern has four arguments,
@en each representing a value to be used in the jump.  The first
@en argument is to be loaded into the frame pointer, the second is
@en the address to branch to (code to dispatch to the actual label),
@en the third is the address of a location where the stack is saved,
@en and the last is the address of the label, to be placed in the
@en location for the incoming static chain.
生成产生一个非局部goto的代码，例如，从一个函数跳转到一个外部函数的标号。该指令模式有四个参数，每个参数表示一个在跳转中用到的值。第一个参数被加载到帧指针中，第二个为分支跳转的地址，第三个为栈被保存的地址，最后一个为标号的地址，放在静态链中。

@en On most machines you need not define this pattern, since GCC will
@en already generate the correct code, which is to load the frame pointer
@en and static chain, restore the stack (using the
@en @samp{restore_stack_nonlocal} pattern, if defined), and jump indirectly
@en to the dispatcher.  You need only define this pattern if this code will
@en not work on your machine.
在大多上机器上，你不需要定义该指令模式，因为GCC会产生正确的代码，用来加载帧指针和静态链，恢复栈（使用@samp{restore_stack_nonlocal}指令模式，如果定义），并间接跳转。你只有当该代码在你的机器上不工作的情况下，才需定义该指令模式。

@cindex @code{nonlocal_goto_receiver} instruction pattern
@item @samp{nonlocal_goto_receiver}
@en This pattern, if defined, contains code needed at the target of a
@en nonlocal goto after the code already generated by GCC@.  You will not
@en normally need to define this pattern.  A typical reason why you might
@en need this pattern is if some value, such as a pointer to a global table,
@en must be restored when the frame pointer is restored.  Note that a nonlocal
@en goto only occurs within a unit-of-translation, so a global table pointer
@en that is shared by all functions of a given module need not be restored.
@en There are no arguments.
该指令模式，如果定义，包含了非局部goto的目标处所需要的代码。通常不需要定义该指令模式。通常需要该指令模式的原因是，如果一些值，例如全局表的指针，必须在帧指针被恢复的时候，其也被恢复。注意，非局部goto，只出现在一个转换单元中，所以被给定模块的所有函数共享的全局表指针，不需要被恢复。该指令模式没有参数。

@cindex @code{exception_receiver} instruction pattern
@item @samp{exception_receiver}
@en This pattern, if defined, contains code needed at the site of an
@en exception handler that isn't needed at the site of a nonlocal goto.  You
@en will not normally need to define this pattern.  A typical reason why you
@en might need this pattern is if some value, such as a pointer to a global
@en table, must be restored after control flow is branched to the handler of
@en an exception.  There are no arguments.
该指令模式，如果被定义，包含了在一个异常处理的地方所需要的代码，其在非局部goto的地方不需要。通常你不需要定义该指令模式。一个典型的，你可以需要定义该指令模式的原因是，如果某个值，例如指向全局表的指针，必须在控制流分支跳转到异常处理之后，被恢复。该指令模式没有参数。

@cindex @code{builtin_setjmp_setup} instruction pattern
@item @samp{builtin_setjmp_setup}
@en This pattern, if defined, contains additional code needed to initialize
@en the @code{jmp_buf}.  You will not normally need to define this pattern.
@en A typical reason why you might need this pattern is if some value, such
@en as a pointer to a global table, must be restored.  Though it is
@en preferred that the pointer value be recalculated if possible (given the
@en address of a label for instance).  The single argument is a pointer to
@en the @code{jmp_buf}.  Note that the buffer is five words long and that
@en the first three are normally used by the generic mechanism.
该指令模式，如果被定义，则包含了需要初始化@code{jmp_buf}的代码。你通常不需要定义该指令模式。一个典型的，你可以需要定义该指令模式的原因是，如果某个值，例如指向全局表的指针，必须被恢复。尽管如此，还是推荐指针值如果可能（例如，给定一个标号的地址），则应被重新计算。有一单个操作数，

@cindex @code{builtin_setjmp_receiver} instruction pattern
@item @samp{builtin_setjmp_receiver}
@en This pattern, if defined, contains code needed at the site of a
@en built-in setjmp that isn't needed at the site of a nonlocal goto.  You
@en will not normally need to define this pattern.  A typical reason why you
@en might need this pattern is if some value, such as a pointer to a global
@en table, must be restored.  It takes one argument, which is the label
@en to which builtin_longjmp transfered control; this pattern may be emitted
@en at a small offset from that label.
该指令模式，如果被定义，包含了在内建setjmp的地方，并且在非局部goto的地方不需要的代码。你通常不需要定义该指令模式。一个典型的，你可以需要定义该指令模式的原因是，如果某个值，例如指向全局表的指针，必须被恢复。其接受一个参数，为builtin_longjmp将控制转出的标号；该指令模式可以被生成为对于标号的一个小的偏移。

@cindex @code{builtin_longjmp} instruction pattern
@item @samp{builtin_longjmp}
@en This pattern, if defined, performs the entire action of the longjmp.
@en You will not normally need to define this pattern unless you also define
@en @code{builtin_setjmp_setup}.  The single argument is a pointer to the
@en @code{jmp_buf}.
该指令模式，如果被定义，则执行整个longjmp动作。你通常不需要定义该指令模式，除非你还定义了@code{builtin_setjmp_setup}。单个操作数为指向@code{jmp_buf}的指针。

@cindex @code{eh_return} instruction pattern
@item @samp{eh_return}
@en This pattern, if defined, affects the way @code{__builtin_eh_return},
@en and thence the call frame exception handling library routines, are
@en built.  It is intended to handle non-trivial actions needed along
@en the abnormal return path.
该指令模式，如果被定义，则影响@code{__builtin_eh_return}的方式，并且调用帧异常处理库函数会被建立。其用于处理异常返回路径所需要的非平凡的动作。

@en The address of the exception handler to which the function should return
@en is passed as operand to this pattern.  It will normally need to copied by
@en the pattern to some special register or memory location.
@en If the pattern needs to determine the location of the target call
@en frame in order to do so, it may use @code{EH_RETURN_STACKADJ_RTX},
@en if defined; it will have already been assigned.
函数应该返回的异常处理的地址，被作为操作数传给该指令模式。其通常需要被指令模式复制到某个特定的寄存器或者内存位置。如果该指令模式需要确定目标调用帧的位置，则可以使用@code{EH_RETURN_STACKADJ_RTX}。

@en If this pattern is not defined, the default action will be to simply
@en copy the return address to @code{EH_RETURN_HANDLER_RTX}.  Either
@en that macro or this pattern needs to be defined if call frame exception
@en handling is to be used.
如果该指令模式没有被定义，缺省的动作为简单的将返回地址复制给@code{EH_RETURN_HANDLER_RTX}。或者宏，或者该指令模式，应该被定义，如果使用了调用帧异常处理。

@cindex @code{prologue} instruction pattern
@anchor{prologue instruction pattern}
@item @samp{prologue}
@en This pattern, if defined, emits RTL for entry to a function.  The function
@en entry is responsible for setting up the stack frame, initializing the frame
@en pointer register, saving callee saved registers, etc.
该指令模式，如果被定义，用来产生函数的入口RTL。函数入口负责设置栈帧，初始化帧指针寄存器，保存被调用者需要保存的寄存器，等等。

@en Using a prologue pattern is generally preferred over defining
@en @code{TARGET_ASM_FUNCTION_PROLOGUE} to emit assembly code for the prologue.
使用一个序言指令模式，通常的方式为定义@code{TARGET_ASM_FUNCTION_PROLOGUE}来产生序言的汇编代码。

@en The @code{prologue} pattern is particularly useful for targets which perform
@en instruction scheduling.
@code{prologue}指令模式对于执行指令调度的目标机尤其有用。

@cindex @code{epilogue} instruction pattern
@anchor{epilogue instruction pattern}
@item @samp{epilogue}
@en This pattern emits RTL for exit from a function.  The function
@en exit is responsible for deallocating the stack frame, restoring callee saved
@en registers and emitting the return instruction.
该指令模式为函数的出口生成RTL。函数出口负责撤销栈帧的分配，恢复被调用者所保存的寄存器，并产生返回指令。

@en Using an epilogue pattern is generally preferred over defining
@en @code{TARGET_ASM_FUNCTION_EPILOGUE} to emit assembly code for the epilogue.
使用尾声指令模式，通常的方式为定义@code{TARGET_ASM_FUNCTION_EPILOGUE}，来产生尾声的汇编代码。

@en The @code{epilogue} pattern is particularly useful for targets which perform
@en instruction scheduling or which have delay slots for their return instruction.
@code{prologue}指令模式对于执行指令调度的，或者它们的返回指令具有延迟槽的目标机，尤其有用。

@cindex @code{sibcall_epilogue} instruction pattern
@item @samp{sibcall_epilogue}
@en This pattern, if defined, emits RTL for exit from a function without the final
@en branch back to the calling function.  This pattern will be emitted before any
@en sibling call (aka tail call) sites.
该指令模式，如果被定义，产生一个函数的出口RTL，并且最终不分支跳转会到调用函数。该指令模式将在任何兄弟调用（即尾调用）地点之前被产生。

@en The @code{sibcall_epilogue} pattern must not clobber any arguments used for
@en parameter passing or any stack slots for arguments passed to the current
@en function.
@code{sibcall_epilogue}指令模式一定不能破坏任何用于传递的参数，或者用于传给当前函数的参数的栈槽。

@cindex @code{trap} instruction pattern
@item @samp{trap}
@en This pattern, if defined, signals an error, typically by causing some
@en kind of signal to be raised.  Among other places, it is used by the Java
@en front end to signal `invalid array index' exceptions.
该指令模式，如果被定义，则会发射一个错误信号。在其它地方，其被Java前端使用，来发射“无效的数组索引”异常信号。

@en @cindex @code{ctrap@var{MM}4} instruction pattern
@en @item @samp{ctrap@var{MM}4}

@cindex @code{conditional_trap} instruction pattern
@item @samp{conditional_trap}
@en Conditional trap instruction.  Operand 0 is a piece of RTL which
@en performs a comparison, and operands 1 and 2 are the arms of the
@en comparison.  Operand 3 is the trap code, an integer.
条件陷阱指令。操作数0为执行比较的RTL。操作数1为陷阱代码，为一个整数。

@en A typical @code{ctrap} pattern looks like
典型的@code{conditional_trap}指令模式型如：

@smallexample
(define_insn "conditional_trap"
  [(trap_if (match_operator 0 "trap_operator"
             [(cc0) (const_int 0)])
            (match_operand 1 "const_int_operand" "i"))]
  ""
  "@dots{}")
@end smallexample

@cindex @code{prefetch} instruction pattern
@item @samp{prefetch}

@en This pattern, if defined, emits code for a non-faulting data prefetch
@en instruction.  Operand 0 is the address of the memory to prefetch.  Operand 1
@en is a constant 1 if the prefetch is preparing for a write to the memory
@en address, or a constant 0 otherwise.  Operand 2 is the expected degree of
@en temporal locality of the data and is a value between 0 and 3, inclusive; 0
@en means that the data has no temporal locality, so it need not be left in the
@en cache after the access; 3 means that the data has a high degree of temporal
@en locality and should be left in all levels of cache possible;  1 and 2 mean,
@en respectively, a low or moderate degree of temporal locality.
该指令模式，如果被定义，则产生无故障的数据预取指令代码。操作数0为预取的内存地址。操作数1为常量1，如果预取打算去写一个内存地址，否则为常量0。操作数2为数据的时间局部性的等级，值在0和3之间。0意味着数据没有时间局部性，所以在访问之后不需要留在缓存中；3意味着数据具有高等级的时间局部性，应该尽可能的留在所有级别的缓存中；1和2分别意味着，低等级和中等级的时间局部性。

@en Targets that do not support write prefetches or locality hints can ignore
@en the values of operands 1 and 2.
不支持写预取或者局部性暗示的目标机，可以忽略操作数1和2的值。

@cindex @code{blockage} instruction pattern
@item @samp{blockage}

@en This pattern defines a pseudo insn that prevents the instruction
@en scheduler from moving instructions across the boundary defined by the
@en blockage insn.  Normally an UNSPEC_VOLATILE pattern.
该指令模式定义了一个伪insn，用来阻止指令调度器将指令跨越所定义的insn块边界进行移动。通常为一个UNSPEC_VOLATILE指令模式。

@cindex @code{memory_barrier} instruction pattern
@item @samp{memory_barrier}

@en If the target memory model is not fully synchronous, then this pattern
@en should be defined to an instruction that orders both loads and stores
@en before the instruction with respect to loads and stores after the instruction.
@en This pattern has no operands.
如果目标机内存模型不完全同步，则该指令模式应该被定义为一条指令，在期望进行加载和存储的指令之前。该指令模式没有操作数。

@cindex @code{sync_compare_and_swap@var{mode}} instruction pattern
@item @samp{sync_compare_and_swap@var{mode}}

@en This pattern, if defined, emits code for an atomic compare-and-swap
@en operation.  Operand 1 is the memory on which the atomic operation is
@en performed.  Operand 2 is the ``old'' value to be compared against the
@en current contents of the memory location.  Operand 3 is the ``new'' value
@en to store in the memory if the compare succeeds.  Operand 0 is the result
@en of the operation; it should contain the contents of the memory
@en before the operation.  If the compare succeeds, this should obviously be
@en a copy of operand 2.
该指令模式，如果被定义，产生一个比较并交换的原子操作代码。操作数1为执行原子操作的内存。操作数2为，与当前内存位置的内容进行比较的“旧”值。操作数3为，如果比较成功存放在内存中的“新”值。如果比较成功，其当然为对操作数2的一个复制。

@en This pattern must show that both operand 0 and operand 1 are modified.
该指令模式必须同时显示出操作数0和1被修改。

@en This pattern must issue any memory barrier instructions such that all
@en memory operations before the atomic operation occur before the atomic
@en operation and all memory operations after the atomic operation occur
@en after the atomic operation.
该指令模式必须产生内存栅栏指令，使得在原子操作之前的所有内存操作，都在原子操作之前发生，所有在原子操作之后的内存操作，都在原子操作之后发生。

@en For targets where the success or failure of the compare-and-swap
@en operation is available via the status flags, it is possible to
@en avoid a separate compare operation and issue the subsequent
@en branch or store-flag operation immediately after the compare-and-swap.
@en To this end, GCC will look for a @code{MODE_CC} set in the
@en output of @code{sync_compare_and_swap@var{mode}}; if the machine
@en description includes such a set, the target should also define special
@en @code{cbranchcc4} and/or @code{cstorecc4} instructions.  GCC will then
@en be able to take the destination of the @code{MODE_CC} set and pass it
@en to the @code{cbranchcc4} or @code{cstorecc4} pattern as the first
@en operand of the comparison (the second will be @code{(const_int 0)}).

@cindex @code{sync_compare_and_swap_cc@var{mode}} instruction pattern
@item @samp{sync_compare_and_swap_cc@var{mode}}
该指令模式与@code{sync_compare_and_swap@var{mode}}类似，除了其比较和交换的比较部分就好像是通过@code{cmp@var{m}}来发出的。该比较只与@code{EQ}和@code{NE}分支跳转，以及@code{setcc}操作一起使用。

一些目标机确实是通过状态标记来暴露比较并交换操作的成功或失败。理想的，我们不需要一个单独的命名指令模式来利用该特性，但是合并过程无法处理具有多个set的指令模式，而这正是定义@code{sync_compare_and_swap@var{mode}}所需要的。

@cindex @code{sync_add@var{mode}} instruction pattern
@cindex @code{sync_sub@var{mode}} instruction pattern
@cindex @code{sync_ior@var{mode}} instruction pattern
@cindex @code{sync_and@var{mode}} instruction pattern
@cindex @code{sync_xor@var{mode}} instruction pattern
@cindex @code{sync_nand@var{mode}} instruction pattern
@item @samp{sync_add@var{mode}}, @samp{sync_sub@var{mode}}
@itemx @samp{sync_ior@var{mode}}, @samp{sync_and@var{mode}}
@itemx @samp{sync_xor@var{mode}}, @samp{sync_nand@var{mode}}
@en These patterns emit code for an atomic operation on memory.
@en Operand 0 is the memory on which the atomic operation is performed.
@en Operand 1 is the second operand to the binary operator.
该指令模式产生一个在内存上进行原子操作的代码。操作数0为进行原子操作的内存。操作数1为二元操作符的第二个操作数。

@en This pattern must issue any memory barrier instructions such that all
@en memory operations before the atomic operation occur before the atomic
@en operation and all memory operations after the atomic operation occur
@en after the atomic operation.
该指令模式必须产生内存栅栏指令，使得在原子操作之前的所有内存操作，都在原子操作之前发生，所有在原子操作之后的内存操作，都在原子操作之后发生。

@en If these patterns are not defined, the operation will be constructed
@en from a compare-and-swap operation, if defined.
如果这些指令模式没有被定义，则操作将通过一个比较并交换操作，如果定义，来构建。

@cindex @code{sync_old_add@var{mode}} instruction pattern
@cindex @code{sync_old_sub@var{mode}} instruction pattern
@cindex @code{sync_old_ior@var{mode}} instruction pattern
@cindex @code{sync_old_and@var{mode}} instruction pattern
@cindex @code{sync_old_xor@var{mode}} instruction pattern
@cindex @code{sync_old_nand@var{mode}} instruction pattern
@item @samp{sync_old_add@var{mode}}, @samp{sync_old_sub@var{mode}}
@itemx @samp{sync_old_ior@var{mode}}, @samp{sync_old_and@var{mode}}
@itemx @samp{sync_old_xor@var{mode}}, @samp{sync_old_nand@var{mode}}
@en These patterns are emit code for an atomic operation on memory,
@en and return the value that the memory contained before the operation.
@en Operand 0 is the result value, operand 1 is the memory on which the
@en atomic operation is performed, and operand 2 is the second operand
@en to the binary operator.
这些指令模式产生在内存上的原子操作代码，并且返回操作之前内存中的值。操作数0为结果值，操作数1为执行原子操作的内存，操作数2为二元操作的第二个操作数。

@en This pattern must issue any memory barrier instructions such that all
@en memory operations before the atomic operation occur before the atomic
@en operation and all memory operations after the atomic operation occur
@en after the atomic operation.
该指令模式必须产生内存栅栏指令，使得在原子操作之前的所有内存操作，都在原子操作之前发生，所有在原子操作之后的内存操作，都在原子操作之后发生。

@en If these patterns are not defined, the operation will be constructed
@en from a compare-and-swap operation, if defined.
如果这些指令模式没有被定义，则操作将通过一个比较并交换操作，如果定义，来构建。

@cindex @code{sync_new_add@var{mode}} instruction pattern
@cindex @code{sync_new_sub@var{mode}} instruction pattern
@cindex @code{sync_new_ior@var{mode}} instruction pattern
@cindex @code{sync_new_and@var{mode}} instruction pattern
@cindex @code{sync_new_xor@var{mode}} instruction pattern
@cindex @code{sync_new_nand@var{mode}} instruction pattern
@item @samp{sync_new_add@var{mode}}, @samp{sync_new_sub@var{mode}}
@itemx @samp{sync_new_ior@var{mode}}, @samp{sync_new_and@var{mode}}
@itemx @samp{sync_new_xor@var{mode}}, @samp{sync_new_nand@var{mode}}
@en These patterns are like their @code{sync_old_@var{op}} counterparts,
@en except that they return the value that exists in the memory location
@en after the operation, rather than before the operation.
这些指令模式类似于@code{sync_old_@var{op}}所对应的指令模式，除了它们返回操作之后内存位置中存在的值，而不是操作之前。

@cindex @code{sync_lock_test_and_set@var{mode}} instruction pattern
@item @samp{sync_lock_test_and_set@var{mode}}
@en This pattern takes two forms, based on the capabilities of the target.
@en In either case, operand 0 is the result of the operand, operand 1 is
@en the memory on which the atomic operation is performed, and operand 2
@en is the value to set in the lock.
该指令模式根据目标机的能力，可以接受两种形式。两种情况下，操作数0为结果操作数，操作数1为执行原子操作的内存，操作数2为在锁中设置的值。

@en In the ideal case, this operation is an atomic exchange operation, in
@en which the previous value in memory operand is copied into the result
@en operand, and the value operand is stored in the memory operand.
理想的情况下，该操作为一个原子交换操作，内存操作数中之前的值被复制到结果操作数中，值操作数被保存在内存操作数中。

@en For less capable targets, any value operand that is not the constant 1
@en should be rejected with @code{FAIL}.  In this case the target may use
@en an atomic test-and-set bit operation.  The result operand should contain
@en 1 if the bit was previously set and 0 if the bit was previously clear.
@en The true contents of the memory operand are implementation defined.
对于能力差些的目标机，任何不为常量1的值操作数，将使用@code{FAIL}进行拒绝。这种情况下，目标机可以使用一个原子的测试并置位操作。结果操作数应该包含1，如果该位在之前被设置，或者为0，如果该位在之前被清空。内存操作数的真实内容由实现来定义。

@en This pattern must issue any memory barrier instructions such that the
@en pattern as a whole acts as an acquire barrier, that is all memory
@en operations after the pattern do not occur until the lock is acquired.
该指令模式必须产生内存栅栏指令，使得在原子操作之前的所有内存操作，都在原子操作之前发生，所有在原子操作之后的内存操作，都在原子操作之后发生。

@en If this pattern is not defined, the operation will be constructed from
@en a compare-and-swap operation, if defined.
如果这些指令模式没有被定义，则操作将通过一个比较并交换操作，如果定义，来构建。

@en 
@cindex @code{sync_lock_release@var{mode}} instruction pattern
@item @samp{sync_lock_release@var{mode}}
@en This pattern, if defined, releases a lock set by
@en @code{sync_lock_test_and_set@var{mode}}.  Operand 0 is the memory
@en that contains the lock; operand 1 is the value to store in the lock.
该指令模式，如果被定义，释放由@code{sync_lock_test_and_set@var{mode}}设置的锁。操作数0为包含锁的内存；操作数1为存放在锁中的值。

@en If the target doesn't implement full semantics for
@en @code{sync_lock_test_and_set@var{mode}}, any value operand which is not
@en the constant 0 should be rejected with @code{FAIL}, and the true contents
@en of the memory operand are implementation defined.

@en If this pattern is not defined, then a @code{memory_barrier} pattern
@en will be emitted, followed by a store of the value to the memory operand.
如果目标机没有实现@code{sync_lock_test_and_set@var{mode}}的完整语义，则任何不是常量0的值操作数将使用@code{FAIL}来拒绝，内存操作数的真实内容由实现来定义。

@en This pattern must issue any memory barrier instructions such that the
@en pattern as a whole acts as a release barrier, that is the lock is
@en released only after all previous memory operations have completed.
该指令模式必须产生内存栅栏指令，使得在原子操作之前的所有内存操作，都在原子操作之前发生，所有在原子操作之后的内存操作，都在原子操作之后发生。

@en This pattern, if defined, moves a @code{Pmode} value from the memory
@en in operand 1 to the memory in operand 0 without leaving the value in
@en a register afterward.  This is to avoid leaking the value some place
@en that an attacker might use to rewrite the stack guard slot after
@en having clobbered it.

@en If this pattern is not defined, then a plain move pattern is generated.
如果这些指令模式没有被定义，则会产生一个@code{memory_barrier}指令模式，紧跟一个将值存储到内存操作数的操作。

@cindex @code{stack_protect_set} instruction pattern
@item @samp{stack_protect_set}
@en This pattern, if defined, compares a @code{Pmode} value from the
@en memory in operand 1 with the memory in operand 0 without leaving the
@en value in a register afterward and branches to operand 2 if the values
@en weren't equal.
该指令模式，如果被定义，将内存操作数1中的@code{Pmode}值移送到内存操作数0中，并在之后不将该值留在寄存器中。这避免在某处泄露该值，从而使得攻击者用来重写栈保护槽。

@en If this pattern is not defined, then a plain compare pattern and
@en conditional branch pattern is used.
如果该指令模式没有被定义，则生成一个普通的move指令模式。

@cindex @code{stack_protect_test} instruction pattern
@item @samp{stack_protect_test}
该指令模式，如果被定义，比较内存操作数1和内存操作数0中的@code{Pmode}值，在之后不将该值留在寄存器中，并且如果值不等，则分支跳转到操作数2。

如果该指令模式没有被定义，则使用一个普通的比较和条件分支指令模式。

@cindex @code{clear_cache} instruction pattern
@item @samp{clear_cache}
@en This pattern, if defined, flushes the instruction cache for a region of
@en memory.  The region is bounded to by the Pmode pointers in operand 0
@en inclusive and operand 1 exclusive.
该指令模式，如果被定义，刷新一个内存区域的缓存。该区域的界限由操作数0（包含）和操作数1（不包含）中的Pmode指针界定。

@en If this pattern is not defined, a call to the library function
@en @code{__clear_cache} is used.
如果该指令模式没有被定义，则使用对库函数@code{__clear_cache}的一个调用。

@end table

@end ifset

@c Each of the following nodes are wrapped in separate
@c "@ifset INTERNALS" to work around memory limits for the default
@c configuration in older tetex distributions.  Known to not work:
@c tetex-1.0.7, known to work: tetex-2.0.2.
@ifset INTERNALS
@en @node Pattern Ordering
@en @section When the Order of Patterns Matters
@node Pattern Ordering
@section 指令模式的顺序问题
@cindex Pattern Ordering
@cindex Ordering of Patterns

@en Sometimes an insn can match more than one instruction pattern.  Then the
@en pattern that appears first in the machine description is the one used.
@en Therefore, more specific patterns (patterns that will match fewer things)
@en and faster instructions (those that will produce better code when they
@en do match) should usually go first in the description.
有时一条insn可以匹配不止一个指令模式。
则在机器描述中首先出现的指令模式将被使用。因此，
更加详细的指令模式（匹配更少事物的）和更快的指令
（在匹配时将会产生更好的代码）将通常放在描述中的前面。

@en In some cases the effect of ordering the patterns can be used to hide
@en a pattern when it is not valid.  For example, the 68000 has an
@en instruction for converting a fullword to floating point and another
@en for converting a byte to floating point.  An instruction converting
@en an integer to floating point could match either one.  We put the
@en pattern to convert the fullword first to make sure that one will
@en be used rather than the other.  (Otherwise a large integer might
@en be generated as a single-byte immediate quantity, which would not work.)
@en Instead of using this pattern ordering it would be possible to make the
@en pattern for convert-a-byte smart enough to deal properly with any
@en constant value.
有些情况下，指令模式的顺序效果可以用于隐藏无效的指令模式。
例如，68000有一条将全字转换为浮点的指令，和一条将字节转换为浮点的指令。
则将整数转换为浮点的指令将两者都可以匹配。
我们将转换全字的指令模式放在前面，从而确保使用前一种方式。
（否则将可能产生一个大的整数，以作为单个字节的立即数，这样可能无法工作）。
除了使用该指令模式顺序，还可能将转换字节的指令模式作的更加巧妙些，
以能够合适的处理任何常数值。

@end ifset
@ifset INTERNALS
@en @node Dependent Patterns
@en @section Interdependence of Patterns
@node Dependent Patterns
@section 指令模式的相互依赖性
@cindex Dependent Patterns
@cindex Interdependence of Patterns

@en In some cases machines support instructions identical except for the
@en machine mode of one or more operands.  For example, there may be
@en ``sign-extend halfword'' and ``sign-extend byte'' instructions whose
@en patterns are
有些情况，机器支持除了一个或多个操作数的机器模式不同的相同指令。
例如，可以有指令“sign-extend halfword” 和“sign-extend byte”，其指令模式为

@smallexample
(set (match_operand:SI 0 @dots{})
     (extend:SI (match_operand:HI 1 @dots{})))

(set (match_operand:SI 0 @dots{})
     (extend:SI (match_operand:QI 1 @dots{})))
@end smallexample

@noindent
@en Constant integers do not specify a machine mode, so an instruction to
@en extend a constant value could match either pattern.  The pattern it
@en actually will match is the one that appears first in the file.  For correct
@en results, this must be the one for the widest possible mode (@code{HImode},
@en here).  If the pattern matches the @code{QImode} instruction, the results
@en will be incorrect if the constant value does not actually fit that mode.
常整数不指定机器模式，所以扩展常量值的指令可以两个指令模式都匹配。
实际匹配的指令模式将为文件中首先出现的指令模式。为了获得正确的结果，
其必须为尽可能宽的模式（这里为@code{HImode}）。
如果指令模式匹配@code{QImode}，则当常量值实际不适合该模式时，结果将不正确。

@en Such instructions to extend constants are rarely generated because they are
@en optimized away, but they do occasionally happen in nonoptimized
@en compilations.
像这样扩展常数的指令很少被生成，因为它们会被优化掉，
不过在不优化的编译中确实偶尔会出现。

@en If a constraint in a pattern allows a constant, the reload pass may
@en replace a register with a constant permitted by the constraint in some
@en cases.  Similarly for memory references.  Because of this substitution,
@en you should not provide separate patterns for increment and decrement
@en instructions.  Instead, they should be generated from the same pattern
@en that supports register-register add insns by examining the operands and
@en generating the appropriate machine instruction.
如果在指令模式中constraint允许为一个常量，reload过程可以用constraint允许的常量来替换寄存器。
类似的对于内存引用。由于存在这种替换，
所以不要为递增和递减指令提供单独的指令模式。
替换的，它们应该由同一个指令模式生成。

@end ifset
@ifset INTERNALS
@en @node Jump Patterns
@en @section Defining Jump Instruction Patterns
@node Jump Patterns
@section 定义跳转指令模式
@cindex jump instruction patterns
@cindex defining jump instruction patterns

@en GCC does not assume anything about how the machine realizes jumps.
@en The machine description should define a single pattern, usually
@en a @code{define_expand}, which expands to all the required insns.
对于大多数机器，GCC假设该机器具有一个条件码。比较insn根据给定操作数的有符号和无符号比较的结果来设定条件码。单独的分支insn测试条件代码，并根据它的值进行分支跳转。分支insn分为不同的有符号和无符号的。许多通用机器，像VAX，68000和32000都按这种方式工作。

@en Usually, this would be a comparison insn to set the condition code
@en and a separate branch insn testing the condition code and branching
@en or not according to its value.  For many machines, however,
@en separating compares and branches is limiting, which is why the
@en more flexible approach with one @code{define_expand} is used in GCC.
@en The machine description becomes clearer for architectures that
@en have compare-and-branch instructions but no condition code.  It also
@en works better when different sets of comparison operators are supported
@en by different kinds of conditional branches (e.g. integer vs. floating-point),
@en or by conditional branches with respect to conditional stores.
一些机器具有截然不同的有符号和无符号比较指令，并且只有一套条件分支指令。处理这些机器最容易的方法为保持它们不变，直到最后写汇编代码的阶段。这时，当输出比较指令的代码时，查看一下使用@code{next_cc0_user (insn)}的分支。（）如果RTL得出其为一个无符号分支，则输出一个无符号比较；否则输出一个有符号比较。当分支本身被输出时，你可以将有符号和无符号分支视为等同的。

@en Two separate insns are always used if the machine description represents
@en a condition code register using the legacy RTL expression @code{(cc0)},
@en and on most machines that use a separate condition code register
@en (@pxref{Condition Code}).  For machines that use @code{(cc0)}, in
@en fact, the set and use of the condition code must be separate and
@en adjacent@footnote{@code{note} insns can separate them, though.}, thus
@en allowing flags in @code{cc_status} to be used (@pxref{Condition Code}) and
@en so that the comparison and branch insns could be located from each other
@en by using the functions @code{prev_cc0_setter} and @code{next_cc0_user}.
@en 
@en Even in this case having a single entry point for conditional branches
@en is advantageous, because it handles equally well the case where a single
@en comparison instruction records the results of both signed and unsigned
@en comparison of the given operands (with the branch insns coming in distinct
@en signed and unsigned flavors) as in the x86 or SPARC, and the case where
@en there are distinct signed and unsigned compare instructions and only
@en one set of conditional branch instructions as in the PowerPC.
之所以可以这样做，是因为GCC总是生成一对连续的RTL insn，
可能由@code{note} insn分隔，一个用于设置条件代码，一个用于测试，
并保持这对insn不被改变，直到最后。

要使用该技术，你必须定义机器描述宏@code{NOTICE_UPDATE_CC}，
来做@code{CC_STATUS_INIT}；换句话说，没有多余的比较指令。

一些机器具有比较分支指令，并且没有条件码。对它们可以使用类似的技术。
当该要“输出”一个比较指令时，将它的操作数记录在两个静态变量中。
当输出随后的条件码分支指令时，实际上输出了一个使用已记录的操作数的比较分支指令。

它还用于定义比较分支指令的指令模式。在优化编译中，
比较和分支指令对将根据这些指令模式被组合。但是如果优化不要求的时候，
这是不会发生的。所以你必须针对你定义的任何特定指令模式额外使用上面的一种解决方式。

在许多RISC机器上，大多数指令不影响条件码，并且甚至会没有一个单独的条件码寄存器。
在这些机器上，限制条件码的定义和使用为邻近的insn是不必要的，
并且还会阻止一些重要的优化。例如，在IBM RS/6000上，对于分支将会有一个延迟，
除非条件码寄存器在条件分支的三条指令前被设置。
如果不允许将条件码寄存器的定义和使用分开，则指令调度器将无法执行该优化。

在这些机器上，不要使用@code{(cc0)}，而是使用寄存器来表示条件代码。
如果该机器有一个特定的条件代码寄存器，则使用硬件寄存器。
如果条件代码或者比较结果可以被放在任意的通用寄存器中，
或者有多个条件寄存器，则使用伪寄存器。

@findex prev_cc0_setter
@findex next_cc0_user
在一些机器上，所生成的分支指令类型可以依赖于条件代码所产生的方式；
例如，在68k和SPARC上，直接从加法或减法指令来设置条件代码，
这并不像测试指令那样，不会清除溢出位，
所以不同的分支指令必须用于某些条件分支。对于使用@code{(cc0)}的机器，
对条件代码的设置和使用必须是邻近的（只有@code{note} insn分隔），
以允许在@code{cc_status}中的标记被使用。（参见条件码）并且，
比较分支insn可以互相定位，通过使用函数@code{prev_cc0_setter}和@code{next_cc0_user}。

但是，这在不使用@code{(cc0)}的机器上是不一样的。
在这些机器上，并不会假设比较分支指令是邻近的，上面的方法不可用。
替换的，我们使用条件码寄存器的机器模式来记录条件码寄存器的不同格式。

用于存储条件码值的寄存器应该具有@code{MODE_CC}类别的一个机器模式。
通常，其为@code{CCmode}。如果需要额外的机器模式
（正如上面提到的SPARC中加法例子），
则在@file{@var{machine}-modes.def}中定义它们（参见条件码）。
还要定义@code{SELECT_CC_MODE}来选择给定比较操作数的机器模式。

如果知道在RTL生成过程中，将需要不同的机器模式
（例如，如果机器具有单独的比较指令，针对有符号和无符号），
则它们可以在那个时候被指定。

如果是在指令合成时需要不同的机器模式，
则宏@code{SELECT_CC_MODE}用来确定哪个机器模式作为比较结果。
指令模式应该使用该模式来书写。要支持上面讨论的SPARC的加法，
我们具有指令模式

@end ifset
@ifset INTERNALS
@en @node Looping Patterns
@en @section Defining Looping Instruction Patterns
@node Looping Patterns
@section 定义循环指令模式
@cindex looping instruction patterns
@cindex defining looping instruction patterns

@en Some machines have special jump instructions that can be utilized to
@en make loops more efficient.  A common example is the 68000 @samp{dbra}
@en instruction which performs a decrement of a register and a branch if the
@en result was greater than zero.  Other machines, in particular digital
@en signal processors (DSPs), have special block repeat instructions to
@en provide low-overhead loop support.  For example, the TI TMS320C3x/C4x
@en DSPs have a block repeat instruction that loads special registers to
@en mark the top and end of a loop and to count the number of loop
@en iterations.  This avoids the need for fetching and executing a
@en @samp{dbra}-like instruction and avoids pipeline stalls associated with
@en the jump.
一些机器具有特定的跳转指令，可以使循环更为有效。
常见的例子为68000的@samp{dbra}指令，其执行一个寄存器的递减，
并且如果结果大于0，则进行一个分支。其它机器，特别是数字信号处理器（DSP），
具有特定的块重复指令，以提供低成本的循环支持。
例如TI TMS320C3x/C4x DSP具有一个块重复指令，
其加载特定的寄存器来标记一个循环的顶部和底部，并计算循环迭代的次数。
这就避免了对@samp{dbra}这样的指令的取指和执行的需要，
并避免了和跳转相关的流水线阻塞。

@en GCC has three special named patterns to support low overhead looping.
@en They are @samp{decrement_and_branch_until_zero}, @samp{doloop_begin},
@en and @samp{doloop_end}.  The first pattern,
@en @samp{decrement_and_branch_until_zero}, is not emitted during RTL
@en generation but may be emitted during the instruction combination phase.
@en This requires the assistance of the loop optimizer, using information
@en collected during strength reduction, to reverse a loop to count down to
@en zero.  Some targets also require the loop optimizer to add a
@en @code{REG_NONNEG} note to indicate that the iteration count is always
@en positive.  This is needed if the target performs a signed loop
@en termination test.  For example, the 68000 uses a pattern similar to the
@en following for its @code{dbra} instruction:
GCC具有三个特定的命名指令模式，来支持低开销循环。
它们为@samp{decrement_and_branch_until_zero}, @samp{doloop_begin}和@samp{doloop_end}。
第一个指令模式@samp{decrement_and_branch_until_zero}，在RTL生成过程中没有被产生，
但可以在指令合并阶段被产生。这需要循环优化器的帮助，
使用在strength reduction过程中所搜集的信息，来将一个循环转换为向下计数到0。
一些target还要求循环优化器增加一个@code{REG_NONNEG}注解，来指示迭代计数总是为正的。
这在target执行一个有符号循环终止测试的时候被需要。例如，
68000为它的@code{dbra}指令使用了下面类似的指令模式：

@smallexample
@group
(define_insn "decrement_and_branch_until_zero"
  [(set (pc)
        (if_then_else
          (ge (plus:SI (match_operand:SI 0 "general_operand" "+d*am")
                       (const_int -1))
              (const_int 0))
          (label_ref (match_operand 1 "" ""))
          (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (const_int -1)))]
  "find_reg_note (insn, REG_NONNEG, 0)"
  "@dots{}")
@end group
@end smallexample

@en Note that since the insn is both a jump insn and has an output, it must
@en deal with its own reloads, hence the `m' constraints.  Also note that
@en since this insn is generated by the instruction combination phase
@en combining two sequential insns together into an implicit parallel insn,
@en the iteration counter needs to be biased by the same amount as the
@en decrement operation, in this case @minus{}1.  Note that the following similar
@en pattern will not be matched by the combiner.
注意，由于该insn为jump insn并且具有一个输出，所以其必须处理自己的重载，
因此要使用`m' constraint。还要注意，由于该insn是在指令组合过程中，
通过将两个连序insn组合成一个隐式并行的insn而生成的，所以迭代计数器需要。
注意下面类似的指令模式将不会被编译器匹配。

@smallexample
@group
(define_insn "decrement_and_branch_until_zero"
  [(set (pc)
        (if_then_else
          (ge (match_operand:SI 0 "general_operand" "+d*am")
              (const_int 1))
          (label_ref (match_operand 1 "" ""))
          (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (const_int -1)))]
  "find_reg_note (insn, REG_NONNEG, 0)"
  "@dots{}")
@end group
@end smallexample

@en The other two special looping patterns, @samp{doloop_begin} and
@en @samp{doloop_end}, are emitted by the loop optimizer for certain
@en well-behaved loops with a finite number of loop iterations using
@en information collected during strength reduction.
另外两个特定的循环指令模式@samp{doloop_begin}和@samp{doloop_end}，由循环优化器为一些具有有限循环迭代，使用强度消减所搜集的信息的良好行为的循环所生成的。

@en The @samp{doloop_end} pattern describes the actual looping instruction
@en (or the implicit looping operation) and the @samp{doloop_begin} pattern
@en is an optional companion pattern that can be used for initialization
@en needed for some low-overhead looping instructions.
@samp{doloop_end}指令模式描述了实际的循环指令（或者隐式的循环操作），@samp{doloop_begin}指令模式为一个可选的配套指令模式，可以用于一些低开销循环指令的初始化需要。

@en Note that some machines require the actual looping instruction to be
@en emitted at the top of the loop (e.g., the TMS320C3x/C4x DSPs).  Emitting
@en the true RTL for a looping instruction at the top of the loop can cause
@en problems with flow analysis.  So instead, a dummy @code{doloop} insn is
@en emitted at the end of the loop.  The machine dependent reorg pass checks
@en for the presence of this @code{doloop} insn and then searches back to
@en the top of the loop, where it inserts the true looping insn (provided
@en there are no instructions in the loop which would cause problems).  Any
@en additional labels can be emitted at this point.  In addition, if the
@en desired special iteration counter register was not allocated, this
@en machine dependent reorg pass could emit a traditional compare and jump
@en instruction pair.
注意有些机器需要在循环顶部生成实际的循环指令（例如TMS320C3x/C4x DSP）。在循环顶部生成真正的RTL循环指令，会对流分析造成问题。所以，替换的，一个假@samp{doloop} insn在循环的结尾处被生成。机器相关的reorg过程会检查该@samp{doloop} insn的存在，然后向后搜寻插入了真正循环insn（假设在循环中没有会造成问题的指令）的循环顶部。任何额外的标号都可以在该点被生成。另外，如果所需要的特定迭代技术器寄存器没有被分配，则该机器相关的reorg过程能够生成一个传统的比较跳转指令对。

@en The essential difference between the
@en @samp{decrement_and_branch_until_zero} and the @samp{doloop_end}
@en patterns is that the loop optimizer allocates an additional pseudo
@en register for the latter as an iteration counter.  This pseudo register
@en cannot be used within the loop (i.e., general induction variables cannot
@en be derived from it), however, in many cases the loop induction variable
@en may become redundant and removed by the flow pass.
指令模式@samp{decrement_and_branch_until_zero}和@samp{doloop_end}的本质区别为，循环优化器会为后者分配一个额外的伪寄存器作为迭代计数器。该伪寄存器不能用在循环中（即，通用的规约变量不能由此生成），但是，许多情况下循环规约变量可能变成冗余的并且被后续的过程移除掉。

@end ifset
@ifset INTERNALS
@en @node Insn Canonicalizations
@en @section Canonicalization of Instructions
@node Insn Canonicalizations
@section 指令规范化
@cindex canonicalization of instructions
@cindex insn canonicalization

@en There are often cases where multiple RTL expressions could represent an
@en operation performed by a single machine instruction.  This situation is
@en most commonly encountered with logical, branch, and multiply-accumulate
@en instructions.  In such cases, the compiler attempts to convert these
@en multiple RTL expressions into a single canonical form to reduce the
@en number of insn patterns required.
经常会有多个RTL表达式可以表示由单个机器指令所执行的运算。该情况对于逻辑，分支和乘累加指令最常见。对于这样的情况，编译器尝试将这些多个RTL表达式转换为一个规范的形式，以减少对insn指令模式的需求数。

@en In addition to algebraic simplifications, following canonicalizations
@en are performed:
除了进行代数简化以外，还执行了下面的规范化：

@itemize @bullet
@item
@en For commutative and comparison operators, a constant is always made the
@en second operand.  If a machine only supports a constant as the second
@en operand, only patterns that match a constant in the second operand need
@en be supplied.
对于可交换指令和比较指令，总是将常量作为第二个操作数。
如果机器只支持常量作为第二个操作数，
则只需要提供匹配将常量作为第二个操作数的指令模式。

@item
@en For associative operators, a sequence of operators will always chain
@en to the left; for instance, only the left operand of an integer @code{plus}
@en can itself be a @code{plus}.  @code{and}, @code{ior}, @code{xor},
@en @code{plus}, @code{mult}, @code{smin}, @code{smax}, @code{umin}, and
@en @code{umax} are associative when applied to integers, and sometimes to
@en floating-point.
对于结合性操作符，操作符序列总是向左方向链接；例如，一个整数@code{plus}，
只有它的左操作数本身可以为一个@code{plus}。当应用到整数时，
@code{and}, @code{ior}, @code{xor}, @code{plus}, @code{mult}, @code{smin}, 
@code{smax}, @code{umin}和@code{umax}为可结合的，对于浮点，这些有时为可结合的。

@item
@cindex @code{neg}, canonicalization of
@cindex @code{not}, canonicalization of
@cindex @code{mult}, canonicalization of
@cindex @code{plus}, canonicalization of
@cindex @code{minus}, canonicalization of
@en For these operators, if only one operand is a @code{neg}, @code{not},
@en @code{mult}, @code{plus}, or @code{minus} expression, it will be the
@en first operand.
对于这些操作符，如果只有一个为@code{neg}, @code{not},@code{mult}, @code{plus} 或
@code{minus}表达式的操作数，则其将为第一个操作数。

@item
@en In combinations of @code{neg}, @code{mult}, @code{plus}, and
@en @code{minus}, the @code{neg} operations (if any) will be moved inside
@en the operations as far as possible.  For instance,
@en @code{(neg (mult A B))} is canonicalized as @code{(mult (neg A) B)}, but
@en @code{(plus (mult (neg B) C) A)} is canonicalized as
@en @code{(minus A (mult B C))}.
对于@code{neg}, @code{mult}, @code{plus}和@code{minus}的组合中，
@code{neg}操作（如果存在）将被尽可能的移到内部。
例如@code{(neg (mult A B))}将被规范为@code{(mult (neg A) B)}，
但是@code{(plus (mult (neg A) B) C)}将被规范为@code{(minus A (mult B C))}。 

@cindex @code{compare}, canonicalization of
@item
@en For the @code{compare} operator, a constant is always the second operand
@en if the first argument is a condition code register or @code{(cc0)}.
对于@code{compare}运算符，在使用@code{cc0}（参见@ref{Jump Patterns}）的机器上，
常量总是为第二个操作数。 在其它机器上，极少的情况下，
编译器可能想使用常量作为第一个操作数来构建@code{compare}。但是，
这些情况并不常见，所以不值得来提供匹配常量作为第一个操作数的指令模式，
除非机器确实具有这样的指令。

@en An operand of @code{neg}, @code{not}, @code{mult}, @code{plus}, or
@en @code{minus} is made the first operand under the same conditions as
@en above.
在与上面条件相同的情况下，@code{neg}, @code{not}, @code{mult}, @code{plus} 或
@code{minus}的操作数被作为第一个操作数。

@item
@en @code{(ltu (plus @var{a} @var{b}) @var{b})} is converted to
@en @code{(ltu (plus @var{a} @var{b}) @var{a})}. Likewise with @code{geu} instead
@en of @code{ltu}.
@code{(ltu (plus @var{a} @var{b}) @var{b})}被转换为
@code{(ltu (plus @var{a} @var{b}) @var{a})}。
同样，使用@code{geu}来替换@code{ltu}。

@item
@en @code{(minus @var{x} (const_int @var{n}))} is converted to
@en @code{(plus @var{x} (const_int @var{-n}))}.
@code{(minus @var{x} (const_int @var{n}))}被转换为
@code{(plus @var{x} (const_int @var{-n}))}。

@item
@en Within address computations (i.e., inside @code{mem}), a left shift is
@en converted into the appropriate multiplication by a power of two.
在地址计算中（即，在@code{mem}中），左移操作被转换为与合适的2的幂相乘。 

@cindex @code{ior}, canonicalization of
@cindex @code{and}, canonicalization of
@cindex De Morgan's law
@item
@en De Morgan's Law is used to move bitwise negation inside a bitwise
@en logical-and or logical-or operation.  If this results in only one
@en operand being a @code{not} expression, it will be the first one.
De Morgan法则被用于在按位‘逻辑与’或着‘逻辑或’运算中，将位置反。
如果该结果为@code{not}表达式的唯一的操作数，则其为第一个。

@en A machine that has an instruction that performs a bitwise logical-and of one
@en operand with the bitwise negation of the other should specify the pattern
@en for that instruction as
具有执行按位‘逻辑与’，且其中一个操作数为一个按位求反的机器，
应该为该指令指定如下的指令模式

@smallexample
(define_insn ""
  [(set (match_operand:@var{m} 0 @dots{})
        (and:@var{m} (not:@var{m} (match_operand:@var{m} 1 @dots{}))
                     (match_operand:@var{m} 2 @dots{})))]
  "@dots{}"
  "@dots{}")
@end smallexample

@noindent
@en Similarly, a pattern for a ``NAND'' instruction should be written
类似的，“NAND”指令的指令模式应给被写为

@smallexample
(define_insn ""
  [(set (match_operand:@var{m} 0 @dots{})
        (ior:@var{m} (not:@var{m} (match_operand:@var{m} 1 @dots{}))
                     (not:@var{m} (match_operand:@var{m} 2 @dots{}))))]
  "@dots{}"
  "@dots{}")
@end smallexample

@en In both cases, it is not necessary to include patterns for the many
@en logically equivalent RTL expressions.
对于这两种情况，都没必要包含许多逻辑上相同的RTL表达式。

@cindex @code{xor}, canonicalization of
@item
@en The only possible RTL expressions involving both bitwise exclusive-or
@en and bitwise negation are @code{(xor:@var{m} @var{x} @var{y})}
@en and @code{(not:@var{m} (xor:@var{m} @var{x} @var{y}))}.
涉及按位‘异或’和求反的唯一可能的RTL表达式为@code{(xor:@var{m} @var{x} @var{y})}
和@code{(not:@var{m} (xor:@var{m} @var{x} @var{y}))}。

@item
@en The sum of three items, one of which is a constant, will only appear in
@en the form
对于三项的和，其中一个为常量的，将使用如下形式

@smallexample
(plus:@var{m} (plus:@var{m} @var{x} @var{y}) @var{constant})
@end smallexample

@item
@cindex @code{zero_extract}, canonicalization of
@cindex @code{sign_extract}, canonicalization of
@en Equality comparisons of a group of bits (usually a single bit) with zero
@en will be written using @code{zero_extract} rather than the equivalent
@en @code{and} or @code{sign_extract} operations.
位组（通常是单个位）和0的相等比较，将使用@code{zero_extract}，
而不是等价的@code{and}或者@code{sign_extract}运算。

@end itemize

@en Further canonicalization rules are defined in the function
@en @code{commutative_operand_precedence} in @file{gcc/rtlanal.c}.
更多的规范化规则都定义在@file{gcc/rtlanal.c}里的函数@code{commutative_operand_precedence}中。

@en @end ifset
@en @ifset INTERNALS
@end ifset
@ifset INTERNALS
@en @node Expander Definitions
@en @section Defining RTL Sequences for Code Generation
@node Expander Definitions
@section 为代码生成定义RTL序列
@cindex expander definitions
@cindex code generation RTL sequences
@cindex defining RTL sequences for code generation

@en On some target machines, some standard pattern names for RTL generation
@en cannot be handled with single insn, but a sequence of RTL insns can
@en represent them.  For these target machines, you can write a
@en @code{define_expand} to specify how to generate the sequence of RTL@.
在一些目标机上，一些用于RTL生成的标准指令模式名无法通过单个insn来处理，
但是可以用一个RTL insn序列来表示它们。对于这些目标机，
你可以写一个@code{define_expand}来指定如何生成RTL序列。

@findex define_expand
@en A @code{define_expand} is an RTL expression that looks almost like a
@en @code{define_insn}; but, unlike the latter, a @code{define_expand} is used
@en only for RTL generation and it can produce more than one RTL insn.
@code{define_expand}为一个RTL表达式，看起来非常像@code{define_insn}；
但是不同之处为，@code{define_expand}只用于RTL生成，并且可以产生多个RTL insn。

@en A @code{define_expand} RTX has four operands:
@code{define_expand} RTX具有4个操作数:

@itemize @bullet
@item
@en The name.  Each @code{define_expand} must have a name, since the only
@en use for it is to refer to it by name.
名字。每个@code{define_expand}必须具有一个名字，
因为必须通过对名字的引用才能使用它。

@item
@en The RTL template.  This is a vector of RTL expressions representing
@en a sequence of separate instructions.  Unlike @code{define_insn}, there
@en is no implicit surrounding @code{PARALLEL}.
RTL模板。这是一个RTL表达式向量，表示一个指令序列。

@item
@en The condition, a string containing a C expression.  This expression is
@en used to express how the availability of this pattern depends on
@en subclasses of target machine, selected by command-line options when GCC
@en is run.  This is just like the condition of a @code{define_insn} that
@en has a standard name.  Therefore, the condition (if present) may not
@en depend on the data in the insn being matched, but only the
@en target-machine-type flags.  The compiler needs to test these conditions
@en during initialization in order to learn exactly which named instructions
@en are available in a particular run.
条件，一个字符串包含了一个C表达式。
该表达式用于表示该指令模式对于GCC运行时命令行选项所选择的什么样的target机器
子类别有效。这跟具有标准名字的@code{define_insn}的条件类似。因此，
条件（如果存在）可以不依赖于所匹配的insn的数据，而只是依赖于target机器类型标号。
编译器需要在初始化时测试这些条件，以便确切的知道在一次特定的运行时，
哪些命名指令有效。

@item
@en The preparation statements, a string containing zero or more C
@en statements which are to be executed before RTL code is generated from
@en the RTL template.
@en 
@en Usually these statements prepare temporary registers for use as
@en internal operands in the RTL template, but they can also generate RTL
@en insns directly by calling routines such as @code{emit_insn}, etc.
@en Any such insns precede the ones that come from the RTL template.
@en @end itemize
准备语句，一个字符串，包含了0个或多个C语句，其将在RTL模板生成RTL代码前被执行。通常这些语句可以用来为RTL模板中的内部操作数准备一些临时寄存器，但是它们也同样可以通过调用函数，比如@code{emit_insn}等，直接生成RTL指令。任何这些生成的指令都在RTL模板中的指令前。
@end itemize

@en Every RTL insn emitted by a @code{define_expand} must match some
@en @code{define_insn} in the machine description.  Otherwise, the compiler
@en will crash when trying to generate code for the insn or trying to optimize
@en it.
每个由@code{define_expand}生成的RTL insn必须匹配机器描述中的某个
@code{define_insn}。否则，编译器在尝试为insn生成代码或者试图对其进行优化的时候，
将会崩溃。

@en The RTL template, in addition to controlling generation of RTL insns,
@en also describes the operands that need to be specified when this pattern
@en is used.  In particular, it gives a predicate for each operand.
RTL模板，除了控制RTL insn的生成，还描述了当使用该指令模式时，
所需要指定的操作数。特别是，它为每个操作数给出了断言。

@en A true operand, which needs to be specified in order to generate RTL from
@en the pattern, should be described with a @code{match_operand} in its first
@en occurrence in the RTL template.  This enters information on the operand's
@en predicate into the tables that record such things.  GCC uses the
@en information to preload the operand into a register if that is required for
@en valid RTL code.  If the operand is referred to more than once, subsequent
@en references should use @code{match_dup}.
需要被指定的由指令模式生成RTL的，真正的操作数，
在RTL模板中它第一次出现的位置使用@code{match_operand}来描述。
这将把对于操作数的断言信息放入记录该事情的表中。
如果操作数被引用多次，则后续的引用应该使用@code{match_dup}。

@en The RTL template may also refer to internal ``operands'' which are
@en temporary registers or labels used only within the sequence made by the
@en @code{define_expand}.  Internal operands are substituted into the RTL
@en template with @code{match_dup}, never with @code{match_operand}.  The
@en values of the internal operands are not passed in as arguments by the
@en compiler when it requests use of this pattern.  Instead, they are computed
@en within the pattern, in the preparation statements.  These statements
@en compute the values and store them into the appropriate elements of
@en @code{operands} so that @code{match_dup} can find them.
RTL模板还可以引用内部操作数，
其为只在由@code{define_expand}生成的序列中使用的临时寄存器或者标号。
内部操作数使用@code{match_dup}来替换到RTL模板中，而不是@code{match_operand}。
内部操作数的值在编译器需要使用该指令模式时，不作为参数传入。替代的，
它们在指令模式中计算，在准备语句中。
这些语句计算值并将它们存入到合适的@code{operands}元素中，
以便@code{match_dup}可以找到它们。

@en There are two special macros defined for use in the preparation statements:
@en @code{DONE} and @code{FAIL}.  Use them with a following semicolon,
@en as a statement.
有两个特定的宏，用于准备语句中：@code{DONE}和@code{FAIL}。
在其后面跟随一个分号，以作为一条语句来使用。

@table @code

@findex DONE
@item DONE
@en Use the @code{DONE} macro to end RTL generation for the pattern.  The
@en only RTL insns resulting from the pattern on this occasion will be
@en those already emitted by explicit calls to @code{emit_insn} within the
@en preparation statements; the RTL template will not be generated.
使用@code{DONE}宏来结束该指令模式的RTL生成。这种情况下，
由该指令模式生成的唯一的RTL insn将为在准备语句中显示调用@code{emit_insn}生成
的insn；RTL模板将不被生成。 

@findex FAIL
@item FAIL
@en Make the pattern fail on this occasion.  When a pattern fails, it means
@en that the pattern was not truly available.  The calling routines in the
@en compiler will try other strategies for code generation using other patterns.
使指令模式对于这种情况失败。当指令模式失败时，这意味着指令模式实际上无效。编译器中的调用程序将会尝试其它策略，使用其它指令模式来进行代码生成。

@en Failure is currently supported only for binary (addition, multiplication,
@en shifting, etc.) and bit-field (@code{extv}, @code{extzv}, and @code{insv})
@en operations.
目前，FAIL操作只支持二元（加法，乘法，移位等）和
位域（@code{extv}, @code{extzv}和@code{insv}）操作。 
@end table

@en If the preparation falls through (invokes neither @code{DONE} nor
@en @code{FAIL}), then the @code{define_expand} acts like a
@en @code{define_insn} in that the RTL template is used to generate the
@en insn.
如果准备语句即没有调用@code{DONE}，也没有调用@code{FAIL}，
则@code{define_expand}的行为便跟@code{define_insn}一样，即RTL模板用于生成insn

@en The RTL template is not used for matching, only for generating the
@en initial insn list.  If the preparation statement always invokes
@en @code{DONE} or @code{FAIL}, the RTL template may be reduced to a simple
@en list of operands, such as this example:
RTL模板不用于匹配，只是用于生成最初的insn列表。
如果准备语句总是调用@code{DONE}或者@code{FAIL}，
则RTL模板可以简化为一个简单的操作数列表，例如：

@smallexample
@group
(define_expand "addsi3"
  [(match_operand:SI 0 "register_operand" "")
   (match_operand:SI 1 "register_operand" "")
   (match_operand:SI 2 "register_operand" "")]
@end group
@group
  ""
  "
@{
  handle_add (operands[0], operands[1], operands[2]);
  DONE;
@}")
@end group
@end smallexample

@en Here is an example, the definition of left-shift for the SPUR chip:
这里有一个例子，是为SPUR芯片定义的左移位：

@smallexample
@group
(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (ashift:SI
@end group
@group
          (match_operand:SI 1 "register_operand" "")
          (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "
@end group
@end smallexample

@smallexample
@group
@{
  if (GET_CODE (operands[2]) != CONST_INT
      || (unsigned) INTVAL (operands[2]) > 3)
    FAIL;
@}")
@end group
@end smallexample

@noindent
@en This example uses @code{define_expand} so that it can generate an RTL insn
@en for shifting when the shift-count is in the supported range of 0 to 3 but
@en fail in other cases where machine insns aren't available.  When it fails,
@en the compiler tries another strategy using different patterns (such as, a
@en library call).
这个例子使用了@code{define_expand}，使得当移位数在支持的0到3的范围内时，便会生成移位RTL insn，而对于其它情况，则会失败。当其失败时，编译器便会使用不同的指令模式（比如一个库调用）来尝试其它策略。

@en If the compiler were able to handle nontrivial condition-strings in
@en patterns with names, then it would be possible to use a
@en @code{define_insn} in that case.  Here is another case (zero-extension
@en on the 68000) which makes more use of the power of @code{define_expand}:
如果编译器能够处理具有名字的指令模式中的非平凡的条件字符串，则对于这样情况也可以使用@code{define_insn}。这里有另一种情况（68000上的零扩展），其使用了@code{define_expand}的更强大的功能：

@smallexample
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "")
        (const_int 0))
   (set (strict_low_part
          (subreg:HI
            (match_dup 0)
            0))
        (match_operand:HI 1 "general_operand" ""))]
  ""
  "operands[1] = make_safe_from (operands[1], operands[0]);")
@end smallexample

@noindent
@findex make_safe_from
@en Here two RTL insns are generated, one to clear the entire output operand
@en and the other to copy the input operand into its low half.  This sequence
@en is incorrect if the input operand refers to [the old value of] the output
@en operand, so the preparation statement makes sure this isn't so.  The
@en function @code{make_safe_from} copies the @code{operands[1]} into a
@en temporary register if it refers to @code{operands[0]}.  It does this
@en by emitting another RTL insn.
这里将会生成两个RTL insn，一个用于清除整个输出操作数，另一个用于将输入操作数复制到其低半部份。该指令序列在输入操作数指向输出操作数（的旧值）时，是不正确的。所以，准备语句用来确保不是这样。当其指向@code{operands[0]}时，函数@code{make_safe_from}用来将@code{operands[1]}复制到临时寄存器中。其通过生成另一个RTL insn来完成这件事。

@en Finally, a third example shows the use of an internal operand.
@en Zero-extension on the SPUR chip is done by @code{and}-ing the result
@en against a halfword mask.  But this mask cannot be represented by a
@en @code{const_int} because the constant value is too large to be legitimate
@en on this machine.  So it must be copied into a register with
@en @code{force_reg} and then the register used in the @code{and}.
最后，第三个例子显示了内部操作数的使用。在SPUR芯片上的零扩展是通过将结果与上半字mask来完成的。但是该mask不能通过一个@code{const_int}来表示，因为常量值太大，无法在该机器上被合法化。所以其必须使用@code{force_reg}复制到寄存器中，然后在@code{and}中使用该寄存器。

@smallexample
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
        (and:SI (subreg:SI
                  (match_operand:HI 1 "register_operand" "")
                  0)
                (match_dup 2)))]
  ""
  "operands[2]
     = force_reg (SImode, GEN_INT (65535)); ")
@end smallexample

@en @emph{Note:} If the @code{define_expand} is used to serve a
@en standard binary or unary arithmetic operation or a bit-field operation,
@en then the last insn it generates must not be a @code{code_label},
@en @code{barrier} or @code{note}.  It must be an @code{insn},
@en @code{jump_insn} or @code{call_insn}.  If you don't need a real insn
@en at the end, emit an insn to copy the result of the operation into
@en itself.  Such an insn will generate no code, but it can avoid problems
@en in the compiler.
注意：如果@code{define_expand}被用于一个标准的二元或者一元算数运算，或者一个位域运算，则其生成的最后的insn一定不能为一个@code{code_label}, @code{barrier}或@code{note}。其必须为一个@code{insn}, @code{jump_insn}或@code{call_insn}。如果你在结尾处不需要实际的insn，则可以生成一条将操作数的结果复制到其本身的insn。这样的insn将不会生成代码，但可以避免编译器中的问题。

@end ifset
@ifset INTERNALS
@en @node Insn Splitting
@en @section Defining How to Split Instructions
@node Insn Splitting
@section 定义如何拆分指令
@cindex insn splitting
@cindex instruction splitting
@cindex splitting instructions

@en There are two cases where you should specify how to split a pattern
@en into multiple insns.  On machines that have instructions requiring
@en delay slots (@pxref{Delay Slots}) or that have instructions whose
@en output is not available for multiple cycles (@pxref{Processor pipeline
@en description}), the compiler phases that optimize these cases need to
@en be able to move insns into one-instruction delay slots.  However, some
@en insns may generate more than one machine instruction.  These insns
@en cannot be placed into a delay slot.
有两种情况，你应该指定如何将一个指令模式拆分为多个insn。在一些机器上，指令需要延迟槽（@pxref{Delay Slots}）或者指令的输出对于多周期（@pxref{Processor pipeline description}）不可用，则优化这些情况的编译器过程需要能够将insn移入延迟槽中。但是，一些insn可能会生成不止一条机器指令。这些insn则不能被放入延迟槽。

@en Often you can rewrite the single insn as a list of individual insns,
@en each corresponding to one machine instruction.  The disadvantage of
@en doing so is that it will cause the compilation to be slower and require
@en more space.  If the resulting insns are too complex, it may also
@en suppress some optimizations.  The compiler splits the insn if there is a
@en reason to believe that it might improve instruction or delay slot
@en scheduling.
通常你可以重写单个insn为单独的insn列表，每个对应于一条机器指令。这样做的缺点是它将造成编译变慢并且需要更多的空间。如果结果insn太复杂，则还会抑制一些优化。当编译器有理由相信可以改进指令或者延迟槽调度的时候，则会拆分insn。

@en The insn combiner phase also splits putative insns.  If three insns are
@en merged into one insn with a complex expression that cannot be matched by
@en some @code{define_insn} pattern, the combiner phase attempts to split
@en the complex pattern into two insns that are recognized.  Usually it can
@en break the complex pattern into two patterns by splitting out some
@en subexpression.  However, in some other cases, such as performing an
@en addition of a large constant in two insns on a RISC machine, the way to
@en split the addition into two insns is machine-dependent.
insn组合器阶段还拆分putative insns。如果三个insn被合并到一个使用复杂表达式的insn，其不能被某个@code{define_insn}模式匹配，则组合器阶段尝试将复杂指令模式拆分为两个被识别的insn。通常，它能够将复杂指令模式通过拆分某个子表达式来断开。但是，有些情况下，像在一个RISC机器上执行一个大常量的加法，则拆分加法为两个insn的方式是机器相关的。

@findex define_split
@en The @code{define_split} definition tells the compiler how to split a
@en complex insn into several simpler insns.  It looks like this:
@code{define_split}定义告诉了编译器如何将一个复杂的insn拆分为多个简单的insn。它的形式为：

@smallexample
(define_split
  [@var{insn-pattern}]
  "@var{condition}"
  [@var{new-insn-pattern-1}
   @var{new-insn-pattern-2}
   @dots{}]
  "@var{preparation-statements}")
@end smallexample

@en @var{insn-pattern} is a pattern that needs to be split and
@en @var{condition} is the final condition to be tested, as in a
@en @code{define_insn}.  When an insn matching @var{insn-pattern} and
@en satisfying @var{condition} is found, it is replaced in the insn list
@en with the insns given by @var{new-insn-pattern-1},
@en @var{new-insn-pattern-2}, etc.
@var{insn-pattern}为需要被拆分的指令模式，@var{condition}为要被测试的最终条件，跟@code{define_insn}中的一样。当一个insn匹配@var{insn-pattern}，并且满足条件@var{condition}，则它由insn列表@var{new-insn-pattern-1},@var{new-insn-pattern-2}等来替换。

@en The @var{preparation-statements} are similar to those statements that
@en are specified for @code{define_expand} (@pxref{Expander Definitions})
@en and are executed before the new RTL is generated to prepare for the
@en generated code or emit some insns whose pattern is not fixed.  Unlike
@en those in @code{define_expand}, however, these statements must not
@en generate any new pseudo-registers.  Once reload has completed, they also
@en must not allocate any space in the stack frame.
@var{preparation-statements}与那些为@code{define_expand}（@pxref{Expander Definitions}）指定的语句类似，并且在生成新RTL之前被执行。与@code{define_expand}中的不同之处为，这些语句不能生成任何新的伪寄存器。一旦完成重载，它们则不能在栈帧中分配任何空间。

@en Patterns are matched against @var{insn-pattern} in two different
@en circumstances.  If an insn needs to be split for delay slot scheduling
@en or insn scheduling, the insn is already known to be valid, which means
@en that it must have been matched by some @code{define_insn} and, if
@en @code{reload_completed} is nonzero, is known to satisfy the constraints
@en of that @code{define_insn}.  In that case, the new insn patterns must
@en also be insns that are matched by some @code{define_insn} and, if
@en @code{reload_completed} is nonzero, must also satisfy the constraints
@en of those definitions.
指令模式根据两种不同的环境来匹配@var{insn-pattern}。如果需要为延迟槽调度或者insn调度来拆分insn，则insn已经是有效的，这意味着它已经被一些@code{define_insn}匹配过，并且如果@code{reload_completed}为非0，则已经满足那个@code{define_insn}的约束。在那种情况下，新的insn模式必须也是匹配某个@code{define_insn}的insn，并且如果@code{reload_completed}为非0，则也必须满足那些定义的约束。

@en As an example of this usage of @code{define_split}, consider the following
@en example from @file{a29k.md}, which splits a @code{sign_extend} from
@en @code{HImode} to @code{SImode} into a pair of shift insns:
对于这种@code{define_split}用法的例子，考虑下面来自@file{a29k.md}的例子，
其将从@code{HImode}到@code{SImode}的@code{sign_extend}拆分为一对shift insn：

@smallexample
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (sign_extend:SI (match_operand:HI 1 "gen_reg_operand" "")))]
  ""
  [(set (match_dup 0)
        (ashift:SI (match_dup 1)
                   (const_int 16)))
   (set (match_dup 0)
        (ashiftrt:SI (match_dup 0)
                     (const_int 16)))]
  "
@{ operands[1] = gen_lowpart (SImode, operands[1]); @}")
@end smallexample

@en When the combiner phase tries to split an insn pattern, it is always the
@en case that the pattern is @emph{not} matched by any @code{define_insn}.
@en The combiner pass first tries to split a single @code{set} expression
@en and then the same @code{set} expression inside a @code{parallel}, but
@en followed by a @code{clobber} of a pseudo-reg to use as a scratch
@en register.  In these cases, the combiner expects exactly two new insn
@en patterns to be generated.  It will verify that these patterns match some
@en @code{define_insn} definitions, so you need not do this test in the
@en @code{define_split} (of course, there is no point in writing a
@en @code{define_split} that will never produce insns that match).
@en 
@en Here is an example of this use of @code{define_split}, taken from
@en @file{rs6000.md}:
当组合器阶段尝试拆分一个insn模式时，则情况总是为，指令模式没有被任何@code{define_insn}匹配。组合器过程首先尝试将单个@code{set}表达式拆分，然后是在@code{parallel}中的相同的@code{set}表达式，不过跟随一个伪寄存器的@code{clobber}，以作为scratch寄存器来使用。这这些情况下，组合器期望能够生成两个新的insn。它将验证这些指令模式匹配某个@code{define_insn}定义，所以你不需要在@code{define_split}中做这些测试（当然，there is no point in writing a @code{define_split} that will never produce insns that match).

@smallexample
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (plus:SI (match_operand:SI 1 "gen_reg_operand" "")
                 (match_operand:SI 2 "non_add_cint_operand" "")))]
  ""
  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))
   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]
"
@{
  int low = INTVAL (operands[2]) & 0xffff;
  int high = (unsigned) INTVAL (operands[2]) >> 16;

  if (low & 0x8000)
    high++, low |= 0xffff0000;

  operands[3] = GEN_INT (high << 16);
  operands[4] = GEN_INT (low);
@}")
@end smallexample

@en Here the predicate @code{non_add_cint_operand} matches any
@en @code{const_int} that is @emph{not} a valid operand of a single add
@en insn.  The add with the smaller displacement is written so that it
@en can be substituted into the address of a subsequent operation.
这里断言@code{non_add_cint_operand}匹配任何不是单个add insn的有效操作数的@code{const_int}。

@en An example that uses a scratch register, from the same file, generates
@en an equality comparison of a register and a large constant:
使用scratch寄存器的例子，来自同一个文件，用来生成等价的寄存器和大常量的比较运算：

@smallexample
(define_split
  [(set (match_operand:CC 0 "cc_reg_operand" "")
        (compare:CC (match_operand:SI 1 "gen_reg_operand" "")
                    (match_operand:SI 2 "non_short_cint_operand" "")))
   (clobber (match_operand:SI 3 "gen_reg_operand" ""))]
  "find_single_use (operands[0], insn, 0)
   && (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ
       || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)"
  [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))
   (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]
  "
@{
  /* @r{Get the constant we are comparing against, C, and see what it
     looks like sign-extended to 16 bits.  Then see what constant
     could be XOR'ed with C to get the sign-extended value.}  */

  int c = INTVAL (operands[2]);
  int sextc = (c << 16) >> 16;
  int xorv = c ^ sextc;

  operands[4] = GEN_INT (xorv);
  operands[5] = GEN_INT (sextc);
@}")
@end smallexample

@en To avoid confusion, don't write a single @code{define_split} that
@en accepts some insns that match some @code{define_insn} as well as some
@en insns that don't.  Instead, write two separate @code{define_split}
@en definitions, one for the insns that are valid and one for the insns that
@en are not valid.
为了避免混淆，不要写这样的@code{define_split}，其接受匹配某个@code{define_insn}的一些insn，同时也接受不匹配的insn。替代的，可以写两个分别的@code{define_split}定义，一个针对有效的insn，一个针对无效的insn。

@en The splitter is allowed to split jump instructions into sequence of
@en jumps or create new jumps in while splitting non-jump instructions.  As
@en the central flowgraph and branch prediction information needs to be updated,
@en several restriction apply.
允许将跳转指令拆分为一个跳转序列或者在拆分非跳转指令时创建新的跳转。由于控制流图和分支预测信息需要更新，所以会有一些限制。

@en Splitting of jump instruction into sequence that over by another jump
@en instruction is always valid, as compiler expect identical behavior of new
@en jump.  When new sequence contains multiple jump instructions or new labels,
@en more assistance is needed.  Splitter is required to create only unconditional
@en jumps, or simple conditional jump instructions.  Additionally it must attach a
@en @code{REG_BR_PROB} note to each conditional jump.  A global variable
@en @code{split_branch_probability} holds the probability of the original branch in case
@en it was a simple conditional jump, @minus{}1 otherwise.  To simplify
@en recomputing of edge frequencies, the new sequence is required to have only
@en forward jumps to the newly created labels.
将跳转指令拆分为由另一个跳转指令覆盖的指令序列，总是有效的，因为编译器期望新的跳转具有相同的行为。当新的序列包含多个跳转指令或新的标号时，则需要更多的辅助。只允许创建无条件跳转，或者简单的条件跳转指令。另外，其必须为每个条件跳转附加一个@code{REG_BR_PROB}注解。全局变量@code{split_branch_probability}保存了原始分支的可能性。为了简化边频率的重新计算，新的序列要求只具有向前跳转。

@findex define_insn_and_split
@en For the common case where the pattern of a define_split exactly matches the
@en pattern of a define_insn, use @code{define_insn_and_split}.  It looks like
@en this:
对于通常的情况，define_split的模式完全匹配define_insn的模式，则可以使用@code{define_insn_and_split}。其形式为：

@smallexample
(define_insn_and_split
  [@var{insn-pattern}]
  "@var{condition}"
  "@var{output-template}"
  "@var{split-condition}"
  [@var{new-insn-pattern-1}
   @var{new-insn-pattern-2}
   @dots{}]
  "@var{preparation-statements}"
  [@var{insn-attributes}])

@end smallexample

@en @var{insn-pattern}, @var{condition}, @var{output-template}, and
@en @var{insn-attributes} are used as in @code{define_insn}.  The
@en @var{new-insn-pattern} vector and the @var{preparation-statements} are used as
@en in a @code{define_split}.  The @var{split-condition} is also used as in
@en @code{define_split}, with the additional behavior that if the condition starts
@en with @samp{&&}, the condition used for the split will be the constructed as a
@en logical ``and'' of the split condition with the insn condition.  For example,
@en from i386.md:
@var{insn-pattern}, @var{condition}, @var{output-template}和
@var{insn-attributes}跟在@code{define_insn}中的用法一样. 
@var{new-insn-pattern}向量和@var{preparation-statements}跟在
@code{define_split}中的用法一样。
@var{split-condition}也跟在@code{define_split}中的用法一样, 
不同之处是如果condition开始于@samp{&&}, 
则用于拆分的条件将被构造为split condition和insn condition的逻辑“and”运算。
例如，在i386.md中:

@smallexample
(define_insn_and_split "zero_extendhisi2_and"
  [(set (match_operand:SI 0 "register_operand" "=r")
     (zero_extend:SI (match_operand:HI 1 "register_operand" "0")))
   (clobber (reg:CC 17))]
  "TARGET_ZERO_EXTEND_WITH_AND && !optimize_size"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0)
                   (and:SI (match_dup 0) (const_int 65535)))
              (clobber (reg:CC 17))])]
  ""
  [(set_attr "type" "alu1")])

@end smallexample

@en In this case, the actual split condition will be
@en @samp{TARGET_ZERO_EXTEND_WITH_AND && !optimize_size && reload_completed}.
在这种情况下，实际的split condition将为@samp{TARGET_ZERO_EXTEND_WITH_AND && !optimize_size && reload_completed}。

@en The @code{define_insn_and_split} construction provides exactly the same
@en functionality as two separate @code{define_insn} and @code{define_split}
@en patterns.  It exists for compactness, and as a maintenance tool to prevent
@en having to ensure the two patterns' templates match.
@code{define_insn_and_split}结构提供了与两个单独的@code{define_insn}和@code{define_split}指令模式相同的功能. 其形式紧凑。

@en @end ifset
@en @ifset INTERNALS
@en @node Including Patterns
@en @section Including Patterns in Machine Descriptions.
@en @cindex insn includes
@en 
@en @findex include
@en The @code{include} pattern tells the compiler tools where to
@en look for patterns that are in files other than in the file
@en @file{.md}.  This is used only at build time and there is no preprocessing allowed.
@en 
@en It looks like:
@end ifset
@ifset INTERNALS
@node Including Patterns
@section 在机器描述中包含指令模式
@cindex insn includes

@findex include
模板@code{include}告诉编译器工具，
从哪里寻找在其它文件中而不是文件@file{.md}中的模板。
这只在构建时候使用，并且不允许进行预处理操作。

其形如：

@smallexample

(include
  @var{pathname})
@end smallexample

@en For example:
例如：

@smallexample

(include "filestuff")

@end smallexample

@en Where @var{pathname} is a string that specifies the location of the file,
@en specifies the include file to be in @file{gcc/config/target/filestuff}.  The
@en directory @file{gcc/config/target} is regarded as the default directory.
其中@var{pathname}为一个指定文件位置的字符串，
指定了包含文件为@file{gcc/config/target/filestuff}。
目录@file{gcc/config/target}被当作缺省目录。

@en Machine descriptions may be split up into smaller more manageable subsections
@en and placed into subdirectories.
机器描述可以被分割成容易管理的小章节并放在子目录下。

@en By specifying:
通过指定：

@smallexample

(include "BOGUS/filestuff")

@end smallexample

@en the include file is specified to be in @file{gcc/config/@var{target}/BOGUS/filestuff}.
@en 
@en Specifying an absolute path for the include file such as;
@en @smallexample
包含文件被指定为@file{gcc/config/@var{target}/BOGUS/filestuff}。

为包含文件指定一个绝对路径，像：

@smallexample

(include "/u2/BOGUS/filestuff")

@end smallexample

@en is permitted but is not encouraged.
是被允许的，但不鼓励这么做。

@en @subsection RTL Generation Tool Options for Directory Search
@en @cindex directory options .md
@en @cindex options, directory search
@en @cindex search options
@subsection 用于目录搜索的RTL生成工具选项
@cindex directory options .md
@cindex options, directory search
@cindex search options

@en The @option{-I@var{dir}} option specifies directories to search for machine descriptions.
@en For example:
选项@option{-I@var{dir}}指定了搜索机器描述的目录。例如：

@smallexample

genrecog -I/p1/abc/proc1 -I/p2/abcd/pro2 target.md

@end smallexample

@en 
@en Add the directory @var{dir} to the head of the list of directories to be
@en searched for header files.  This can be used to override a system machine definition
@en file, substituting your own version, since these directories are
@en searched before the default machine description file directories.  If you use more than
@en one @option{-I} option, the directories are scanned in left-to-right
@en order; the standard default directory come after.
目录@var{dir}将被增加到搜索头文件的目录列表的头部。
这可以用来覆盖系统的机器定义文件，而替换为你自己的版本，
因为这些目录将在缺省机器描述文件目录之前被搜索。
如果你使用了多个@option{-I}选项，则目录按照从左到右的顺序被扫描；
之后为标准的缺省目录。

@end ifset
@ifset INTERNALS
@en @node Peephole Definitions
@en @section Machine-Specific Peephole Optimizers
@node Peephole Definitions
@section 机器特定的窥孔优化
@cindex peephole optimizer definitions
@cindex defining peephole optimizers

@en In addition to instruction patterns the @file{md} file may contain
@en definitions of machine-specific peephole optimizations.
除了指令模式，@file{md}文件还可以包含关于机器特定的窥孔优化的定义。

@en The combiner does not notice certain peephole optimizations when the data
@en flow in the program does not suggest that it should try them.  For example,
@en sometimes two consecutive insns related in purpose can be combined even
@en though the second one does not appear to use a register computed in the
@en first one.  A machine-specific peephole optimizer can detect such
@en opportunities.
当程序中的数据流没有建议进行尝试的时候，
组合器便不会注意某些可能存在的窥孔优化。
例如，有时两个连续的insn是可以被组合的，
虽然第二个没有显示出要使用在第一个中所计算的寄存器。
机器特定的窥孔优化器可以检测出这样的机会。

@en There are two forms of peephole definitions that may be used.  The
@en original @code{define_peephole} is run at assembly output time to
@en match insns and substitute assembly text.  Use of @code{define_peephole}
@en is deprecated.
有两种窥孔定义形式可以使用。
最初的@code{define_peephole}运行于汇编输出时，
用于匹配insn和替换汇编文本。不赞成使用@code{define_peephole}。

@en A newer @code{define_peephole2} matches insns and substitutes new
@en insns.  The @code{peephole2} pass is run after register allocation
@en but before scheduling, which may result in much better code for
@en targets that do scheduling.
较新的@code{define_peephole2}用来匹配insn和替换新的insn。
@code{peephole2}过程运行于寄存器分配之后，调度之前，
其使进行调度的target获得更好的代码。

@en @menu
@en * define_peephole::     RTL to Text Peephole Optimizers
@en * define_peephole2::    RTL to RTL Peephole Optimizers
@en @end menu
@menu
* define_peephole::     RTL到文本的窥孔优化器
* define_peephole2::    RTL到RTL的窥孔优化器
@end menu

@end ifset
@ifset INTERNALS
@en @node define_peephole
@en @subsection RTL to Text Peephole Optimizers
@node define_peephole
@subsection RTL到文本的窥孔优化器
@findex define_peephole

@need 1000
@en A definition looks like this:
定义的形式如下：

@smallexample
(define_peephole
  [@var{insn-pattern-1}
   @var{insn-pattern-2}
   @dots{}]
  "@var{condition}"
  "@var{template}"
  "@var{optional-insn-attributes}")
@end smallexample

@noindent
@en The last string operand may be omitted if you are not using any
@en machine-specific information in this machine description.  If present,
@en it must obey the same rules as in a @code{define_insn}.
如果没有在该机器描述中使用任何机器特定的信息，
则可以省略掉最后的字符串操作数。
如果有，则其必须遵守在@code{define_insn}中相同的规则。

@en In this skeleton, @var{insn-pattern-1} and so on are patterns to match
@en consecutive insns.  The optimization applies to a sequence of insns when
@en @var{insn-pattern-1} matches the first one, @var{insn-pattern-2} matches
@en the next, and so on.
该结构中，@var{insn-pattern-1}等为匹配连续insn的指令模式。
当@var{insn-pattern-1}匹配第一个insn，
@var{insn-pattern-2}匹配下一个，等等依次类推的情况时，
则会将优化应用到该insn序列。

@en Each of the insns matched by a peephole must also match a
@en @code{define_insn}.  Peepholes are checked only at the last stage just
@en before code generation, and only optionally.  Therefore, any insn which
@en would match a peephole but no @code{define_insn} will cause a crash in code
@en generation in an unoptimized compilation, or at various optimization
@en stages.
每个由窥孔匹配的insn也必须匹配一个@code{define_insn}。
窥孔只在代码生成前的最后阶段被检查，并且只是可选的。
因此，在一个未优化的编译中，或者不同的优化阶段中，
任何匹配窥孔但是不匹配@code{define_insn}的将会在代码生成时造成崩溃。

@en The operands of the insns are matched with @code{match_operands},
@en @code{match_operator}, and @code{match_dup}, as usual.  What is not
@en usual is that the operand numbers apply to all the insn patterns in the
@en definition.  So, you can check for identical operands in two insns by
@en using @code{match_operand} in one insn and @code{match_dup} in the
@en other.
和通常一样，insn的操作数使用@code{match_operands},
@code{match_operator}和@code{match_dup}来匹配。
不同的是，操作数编号应用在定义的所有insn指令模式中。所以，
你可以通过一个insn中的@code{match_operand}和另一个insn中的@code{match_dup}，
来在两个insn中检查相同的操作数。

@en The operand constraints used in @code{match_operand} patterns do not have
@en any direct effect on the applicability of the peephole, but they will
@en be validated afterward, so make sure your constraints are general enough
@en to apply whenever the peephole matches.  If the peephole matches
@en but the constraints are not satisfied, the compiler will crash.
用于@code{match_operand}指令模式的操作数constraint对窥孔的适用性没有任何直接的影响，
不过它们将会在后面被验证，所以要确信当窥孔匹配时，你的constraint要足够通用。
如果窥孔匹配，但constraint却不满足，则编译器将崩溃。

@en It is safe to omit constraints in all the operands of the peephole; or
@en you can write constraints which serve as a double-check on the criteria
@en previously tested.
将窥孔中的所有操作数的constraint省略掉是安全的；
或者你可以编写constraint作为之前测试过的标准的二次检查。

@en Once a sequence of insns matches the patterns, the @var{condition} is
@en checked.  This is a C expression which makes the final decision whether to
@en perform the optimization (we do so if the expression is nonzero).  If
@en @var{condition} is omitted (in other words, the string is empty) then the
@en optimization is applied to every sequence of insns that matches the
@en patterns.
一旦insn序列匹配指令模式，则@code{condition}将被检查。
这是一个C表达式，用于对是否执行优化来做最后的决定
（如果表达式非0时，我们这样做）。
如果@code{condition}被省略掉（换句话说，字符串为空）
则优化会被应用到每个匹配指令模式的insn序列。

@en The defined peephole optimizations are applied after register allocation
@en is complete.  Therefore, the peephole definition can check which
@en operands have ended up in which kinds of registers, just by looking at
@en the operands.
定义的窥孔优化在寄存器分配完成之后应用。
因此，窥孔定义可以只是查看操作数，便能检查哪些操作数结束于哪种寄存器。

@en @findex prev_active_insn
@en The way to refer to the operands in @var{condition} is to write
@en @code{operands[@var{i}]} for operand number @var{i} (as matched by
@en @code{(match_operand @var{i} @dots{})}).  Use the variable @code{insn}
@en to refer to the last of the insns being matched; use
@en @code{prev_active_insn} to find the preceding insns.
@findex prev_active_insn
在条件中引用操作数的方式为对操作数编号@var{i}编写@code{operands[@var{i}]}
（匹配于@code{(match_operand @var{i} @dots{})}）。
使用变量@code{insn}来引用正在被匹配的insns的最后一个insn；
使用@code{prev_active_insn}来找到先前的insns。

@findex dead_or_set_p
@en When optimizing computations with intermediate results, you can use
@en @var{condition} to match only when the intermediate results are not used
@en elsewhere.  Use the C expression @code{dead_or_set_p (@var{insn},
@en @var{op})}, where @var{insn} is the insn in which you expect the value
@en to be used for the last time (from the value of @code{insn}, together
@en with use of @code{prev_nonnote_insn}), and @var{op} is the intermediate
@en value (from @code{operands[@var{i}]}).
当正在优化中间结果计算时，
你可以使用条件来匹配只有当中间结果不在其它地方被使用的情况。
使用C表达式@code{dead_or_set_p (@var{insn}, @var{op})}，
其中@var{insn}为你所期望其值为最后一次被使用的insn，
以及@var{op}为中间值（来自@code{operands[@var{i}]}）。

@en Applying the optimization means replacing the sequence of insns with one
@en new insn.  The @var{template} controls ultimate output of assembler code
@en for this combined insn.  It works exactly like the template of a
@en @code{define_insn}.  Operand numbers in this template are the same ones
@en used in matching the original sequence of insns.
应用优化，意味着将insn序列替换为新的insn。
@var{template}控制了针对该组合insn的最终汇编代码输出。
就像@code{define_insn}模板所做的一样。
该模板中的操作数编号与用于要匹配的原始insn序列中的相同。

@en The result of a defined peephole optimizer does not need to match any of
@en the insn patterns in the machine description; it does not even have an
@en opportunity to match them.  The peephole optimizer definition itself serves
@en as the insn pattern to control how the insn is output.
被定义的窥孔优化器的结果不需要匹配机器描述中的任何insn模式；
它甚至没有机会来匹配它们。窥孔优化器定义本身是作为insn模式，
用来控制insn如何输出。

@en Defined peephole optimizers are run as assembler code is being output,
@en so the insns they produce are never combined or rearranged in any way.
被定义的窥孔优化器被作为汇编代码运行输出，
所以它们产生的insns不再被组合或重排。

@en Here is an example, taken from the 68000 machine description:
这里有一个例子，来自68000机器描述：

@smallexample
(define_peephole
  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
   (set (match_operand:DF 0 "register_operand" "=f")
        (match_operand:DF 1 "register_operand" "ad"))]
  "FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])"
@{
  rtx xoperands[2];
  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);
#ifdef MOTOROLA
  output_asm_insn ("move.l %1,(sp)", xoperands);
  output_asm_insn ("move.l %1,-(sp)", operands);
  return "fmove.d (sp)+,%0";
#else
  output_asm_insn ("movel %1,sp@@", xoperands);
  output_asm_insn ("movel %1,sp@@-", operands);
  return "fmoved sp@@+,%0";
#endif
@})
@end smallexample

@need 1000
@en The effect of this optimization is to change
该优化的效果是将

@smallexample
@group
jbsr _foobar
addql #4,sp
movel d1,sp@@-
movel d0,sp@@-
fmoved sp@@+,fp0
@end group
@end smallexample

@noindent
转换为

@smallexample
@group
jbsr _foobar
movel d1,sp@@
movel d0,sp@@-
fmoved sp@@+,fp0
@end group
@end smallexample

@en @ignore
@en @findex CC_REVERSED
@en If a peephole matches a sequence including one or more jump insns, you must
@en take account of the flags such as @code{CC_REVERSED} which specify that the
@en condition codes are represented in an unusual manner.  The compiler
@en automatically alters any ordinary conditional jumps which occur in such
@en situations, but the compiler cannot alter jumps which have been replaced by
@en peephole optimizations.  So it is up to you to alter the assembler code
@en that the peephole produces.  Supply C code to write the assembler output,
@en and in this C code check the condition code status flags and change the
@en assembler code as appropriate.
@en @end ignore
@en 
@en @var{insn-pattern-1} and so on look @emph{almost} like the second
@en operand of @code{define_insn}.  There is one important difference: the
@en second operand of @code{define_insn} consists of one or more RTX's
@en enclosed in square brackets.  Usually, there is only one: then the same
@en action can be written as an element of a @code{define_peephole}.  But
@en when there are multiple actions in a @code{define_insn}, they are
@en implicitly enclosed in a @code{parallel}.  Then you must explicitly
@en write the @code{parallel}, and the square brackets within it, in the
@en @code{define_peephole}.  Thus, if an insn pattern looks like this,
@var{insn-pattern-1}等看起来与@code{define_insn}的第二个操作数非常相似。
不过有一个重要的不同：@code{define_insn}的第二个操作数包含了一个或多个RTX，
使用方括号包裹。通常，只有一个：
那么相同的动作则可以写成@code{define_peephole}的一个元素。
但是，当在@code{define_insn}中有多个动作时，它们被隐式的由@code{parallel}包裹。
则你必须在@code{define_peephole}中，显式的写出@code{parallel}，以及里面的方括号。
因此，如果一个insn的指令模式如下，

@smallexample
(define_insn "divmodsi4"
  [(set (match_operand:SI 0 "general_operand" "=d")
        (div:SI (match_operand:SI 1 "general_operand" "0")
                (match_operand:SI 2 "general_operand" "dmsK")))
   (set (match_operand:SI 3 "general_operand" "=d")
        (mod:SI (match_dup 1) (match_dup 2)))]
  "TARGET_68020"
  "divsl%.l %2,%3:%0")
@end smallexample

@noindent
@en then the way to mention this insn in a peephole is as follows:
则在窥孔中提及该insn的方法为：

@smallexample
(define_peephole
  [@dots{}
   (parallel
    [(set (match_operand:SI 0 "general_operand" "=d")
          (div:SI (match_operand:SI 1 "general_operand" "0")
                  (match_operand:SI 2 "general_operand" "dmsK")))
     (set (match_operand:SI 3 "general_operand" "=d")
          (mod:SI (match_dup 1) (match_dup 2)))])
   @dots{}]
  @dots{})
@end smallexample

@end ifset
@ifset INTERNALS
@en @node define_peephole2
@en @subsection RTL to RTL Peephole Optimizers
@node define_peephole2
@subsection RTL到RTL的窥孔优化器
@findex define_peephole2

@en The @code{define_peephole2} definition tells the compiler how to
@en substitute one sequence of instructions for another sequence,
@en what additional scratch registers may be needed and what their
@en lifetimes must be.
@code{define_peephole2}定义告诉了编译器如何将一个指令序列用来替换另一个序列，
可能需要那些额外的scratch寄存器，以及它们的生命期必须为什么。

@smallexample
(define_peephole2
  [@var{insn-pattern-1}
   @var{insn-pattern-2}
   @dots{}]
  "@var{condition}"
  [@var{new-insn-pattern-1}
   @var{new-insn-pattern-2}
   @dots{}]
  "@var{preparation-statements}")
@end smallexample

@en The definition is almost identical to @code{define_split}
@en (@pxref{Insn Splitting}) except that the pattern to match is not a
@en single instruction, but a sequence of instructions.
定义几乎与@code{define_split}（@pxref{Insn Splitting}）相同，
除了要匹配的指令模式不是一个单个指令，而是一个指令序列。

@en It is possible to request additional scratch registers for use in the
@en output template.  If appropriate registers are not free, the pattern
@en will simply not match.
在输出模板中有可能需要用到额外的scratch寄存器。
如果没有合适的寄存器，则指令模式将简单的作为不匹配处理。

@findex match_scratch
@findex match_dup
@en Scratch registers are requested with a @code{match_scratch} pattern at
@en the top level of the input pattern.  The allocated register (initially) will
@en be dead at the point requested within the original sequence.  If the scratch
@en is used at more than a single point, a @code{match_dup} pattern at the
@en top level of the input pattern marks the last position in the input sequence
@en at which the register must be available.
使用@code{match_scratch}描述所需要的scratch寄存器，
并放在输入指令模式的顶层。被分配的寄存器（最初的）
将会在原始指令序列中需要使用的位置死掉。
如果scratch被用于多个位置，
则位于输入指令模式顶层的@code{match_dup}
指令模式用来标记在输入序列中寄存器必须为活跃的最后位置。

@en Here is an example from the IA-32 machine description:
这里有一个来自IA-32机器描述的例子：

@smallexample
(define_peephole2
  [(match_scratch:SI 2 "r")
   (parallel [(set (match_operand:SI 0 "register_operand" "")
                   (match_operator:SI 3 "arith_or_logical_operator"
                     [(match_dup 0)
                      (match_operand:SI 1 "memory_operand" "")]))
              (clobber (reg:CC 17))])]
  "! optimize_size && ! TARGET_READ_MODIFY"
  [(set (match_dup 2) (match_dup 1))
   (parallel [(set (match_dup 0)
                   (match_op_dup 3 [(match_dup 0) (match_dup 2)]))
              (clobber (reg:CC 17))])]
  "")
@end smallexample

@noindent
@en This pattern tries to split a load from its use in the hopes that we'll be
@en able to schedule around the memory load latency.  It allocates a single
@en @code{SImode} register of class @code{GENERAL_REGS} (@code{"r"}) that needs
@en to be live only at the point just before the arithmetic.
该指令模式尝试拆分加载的使用，以希望我们能够调度内存加载延迟。
它分配了一个@code{GENERAL_REGS}(@code{"r"})类别的单个的@code{SImode}寄存器，
其只需在算术运算之前的位置为活跃的。

@en A real example requiring extended scratch lifetimes is harder to come by,
@en so here's a silly made-up example:
很难找到需要延长scratch生命期的真实例子，所以这里只是一个制造的例子： 

@smallexample
(define_peephole2
  [(match_scratch:SI 4 "r")
   (set (match_operand:SI 0 "" "") (match_operand:SI 1 "" ""))
   (set (match_operand:SI 2 "" "") (match_dup 1))
   (match_dup 4)
   (set (match_operand:SI 3 "" "") (match_dup 1))]
  "/* @r{determine 1 does not overlap 0 and 2} */"
  [(set (match_dup 4) (match_dup 1))
   (set (match_dup 0) (match_dup 4))
   (set (match_dup 2) (match_dup 4))]
   (set (match_dup 3) (match_dup 4))]
  "")
@end smallexample

@noindent
@en If we had not added the @code{(match_dup 4)} in the middle of the input
@en sequence, it might have been the case that the register we chose at the
@en beginning of the sequence is killed by the first or second @code{set}.
如果我们没有在输入序列的中间增加@code{(match_dup 4)}，
则可能的情况是我们选择的寄存器会在序列的起始处被第一个或第二个@code{set}杀死。

@end ifset
@ifset INTERNALS
@en @node Insn Attributes
@en @section Instruction Attributes
@node Insn Attributes
@section 指令属性
@cindex insn attributes
@cindex instruction attributes

@en In addition to describing the instruction supported by the target machine,
@en the @file{md} file also defines a group of @dfn{attributes} and a set of
@en values for each.  Every generated insn is assigned a value for each attribute.
@en One possible attribute would be the effect that the insn has on the machine's
@en condition code.  This attribute can then be used by @code{NOTICE_UPDATE_CC}
@en to track the condition codes.
除了描述target机器所支持的指令以外，@file{md} 文件还定义了一组 
@dfn{attributes} 以及每个属性的取值集合。每条生成的insn都为每个属性赋予一
个值。一种可能的属性是insn对于机器的条件代码所产生的影响。该属性然后可以
被 @code{NOTICE_UPDATE_CC} 使用，来跟踪条件代码。

@en @menu
@en * Defining Attributes:: Specifying attributes and their values.
@en * Expressions::         Valid expressions for attribute values.
@en * Tagging Insns::       Assigning attribute values to insns.
@en * Attr Example::        An example of assigning attributes.
@en * Insn Lengths::        Computing the length of insns.
@en * Constant Attributes:: Defining attributes that are constant.
@en * Delay Slots::         Defining delay slots required for a machine.
@en * Processor pipeline description:: Specifying information for insn scheduling.
@en @end menu
@menu
* Defining Attributes::         指定属性以及它们的值。
* Expressions::           属性值的有效表达式。
* Tagging Insns::    为insns赋予属性值。
* Attr Example::       一个设置属性的例子。
* Insn Lengths::         计算insns的长度。
* Constant Attributes::         定义值为常量的属性。
* Delay Slots::           定义机器所需要的延迟槽。
* Processor pipeline description:: 为insn调度指定信息。
@end menu

@end ifset
@ifset INTERNALS
@en @node Defining Attributes
@en @subsection Defining Attributes and their Values
@node Defining Attributes
@subsection 定义属性以及它们的值
@cindex defining attributes and their values
@cindex attributes, defining

@findex define_attr
@en The @code{define_attr} expression is used to define each attribute required
@en by the target machine.  It looks like:
表达式 @code{define_attr} 用于定义目标机所需要的每个属性。其形式为：

@smallexample
(define_attr @var{name} @var{list-of-values} @var{default})
@end smallexample

@en @var{name} is a string specifying the name of the attribute being defined.
@var{name} 为一个字符串，指定了被定义的属性名。

@en @var{list-of-values} is either a string that specifies a comma-separated
@en list of values that can be assigned to the attribute, or a null string to
@en indicate that the attribute takes numeric values.
@var{list-of-values} 或者为一个字符串，指定了可以赋予属性的逗号分隔
的值的列表，或者为一个空字符串，表示属性接受一个数字值。

@en @var{default} is an attribute expression that gives the value of this
@en attribute for insns that match patterns whose definition does not include
@en an explicit value for this attribute.  @xref{Attr Example}, for more
@en information on the handling of defaults.  @xref{Constant Attributes},
@en for information on attributes that do not depend on any particular insn.
@var{default} 为一个属性表达式，给出了匹配指令模式，但指令模式定义中
没有显式包含该属性值的insns，所应具有的属性值。关于更多处理缺省值的
信息，@xref{Attr Example}。关于不依赖于任何特定insn的属性，
@xref{Constant Attributes}。

@findex insn-attr.h
@en For each defined attribute, a number of definitions are written to the
@en @file{insn-attr.h} file.  For cases where an explicit set of values is
@en specified for an attribute, the following are defined:
对于每个定义的属性，都有许多定义被写入 @file{insn-attr.h} 文件。对于
显式指定了属性取值集合的情况，下列将被定义：

@itemize @bullet
@item
@en A @samp{#define} is written for the symbol @samp{HAVE_ATTR_@var{name}}.
一个针对符号 @samp{HAVE_ATTR_@var{name}} 的 @samp{#define} 被写入。

@item
@en An enumerated class is defined for @samp{attr_@var{name}} with
@en elements of the form @samp{@var{upper-name}_@var{upper-value}} where
@en the attribute name and value are first converted to uppercase.
一个枚举类别被定义，元素的形式为 @samp{@var{upper-name}_@var{upper-value}}，
其中属性名和值首先被转换为大写的。

@item
@en A function @samp{get_attr_@var{name}} is defined that is passed an insn and
@en returns the attribute value for that insn.
一个函数 @samp{get_attr_@var{name}} 被定义，其传入一个insn并返回该insn
的属性值。
@end itemize

@en For example, if the following is present in the @file{md} file:
例如，如果在 @file{md} 文件中存在下列定义：

@smallexample
(define_attr "type" "branch,fp,load,store,arith" @dots{})
@end smallexample

@noindent
@en the following lines will be written to the file @file{insn-attr.h}.
则下面的行将被写入文件 @file{insn-attr.h} 中。

@smallexample
#define HAVE_ATTR_type
enum attr_type @{TYPE_BRANCH, TYPE_FP, TYPE_LOAD,
                 TYPE_STORE, TYPE_ARITH@};
extern enum attr_type get_attr_type ();
@end smallexample

@en If the attribute takes numeric values, no @code{enum} type will be
@en defined and the function to obtain the attribute's value will return
@en @code{int}.
如果属性接受数字值，则不会定义@code{enum} 类型，并且获得属性值的函数将
返回@code{int}。

@en There are attributes which are tied to a specific meaning.  These
@en attributes are not free to use for other purposes:
有些属性被赋予特定的含义。这些属性不能随便用于其它目的：

@table @code
@item length
@en The @code{length} attribute is used to calculate the length of emitted
@en code chunks.  This is especially important when verifying branch
@en distances. @xref{Insn Lengths}.
@code{length}属性用于计算每输出的代码块的长度。这尤其在验证分支距离的时候特别重要。@xref{Insn Lengths}.

@item enabled
@en The @code{enabled} attribute can be defined to prevent certain
@en alternatives of an insn definition from being used during code
@en generation. @xref{Disable Insn Alternatives}.
@code{enabled}属性可以被定义，用来在代码生成过程中，阻止insn定义中的特定的可选项。@xref{Disable Insn Alternatives}.

@end table

@findex define_enum_attr
@anchor{define_enum_attr}
Another way of defining an attribute is to use:

@smallexample
(define_enum_attr "@var{attr}" "@var{enum}" @var{default})
@end smallexample

This works in just the same way as @code{define_attr}, except that
the list of values is taken from a separate enumeration called
@var{enum} (@pxref{define_enum}).  This form allows you to use
the same list of values for several attributes without having to
repeat the list each time.  For example:

@smallexample
(define_enum "processor" [
  model_a
  model_b
  @dots{}
])
(define_enum_attr "arch" "processor"
  (const (symbol_ref "target_arch")))
(define_enum_attr "tune" "processor"
  (const (symbol_ref "target_tune")))
@end smallexample

defines the same attributes as:

@smallexample
(define_attr "arch" "model_a,model_b,@dots{}"
  (const (symbol_ref "target_arch")))
(define_attr "tune" "model_a,model_b,@dots{}"
  (const (symbol_ref "target_tune")))
@end smallexample

but without duplicating the processor list.  The second example defines two
separate C enums (@code{attr_arch} and @code{attr_tune}) whereas the first
defines a single C enum (@code{processor}).

@end ifset
@ifset INTERNALS
@en @node Expressions
@en @subsection Attribute Expressions
@node Expressions
@subsection 属性表达式
@cindex attribute expressions

@en RTL expressions used to define attributes use the codes described above
@en plus a few specific to attribute definitions, to be discussed below.
@en Attribute value expressions must have one of the following forms:
用于定义属性的RTL表达式，除了使用上面描述的代码外，还使用了下面要
讨论的一些细节。属性值表达式必须为下列形式之一：

@table @code
@cindex @code{const_int} and attributes
@item (const_int @var{i})
@en The integer @var{i} specifies the value of a numeric attribute.  @var{i}
@en must be non-negative.
整数 @var{i} 指定了一个数字属性的值。 @var{i} 必须为非负的。 

@en The value of a numeric attribute can be specified either with a
@en @code{const_int}, or as an integer represented as a string in
@en @code{const_string}, @code{eq_attr} (see below), @code{attr},
@en @code{symbol_ref}, simple arithmetic expressions, and @code{set_attr}
@en overrides on specific instructions (@pxref{Tagging Insns}).
数字属性的值可以被指定为一个 @code{const_int}，或者一个在
@code{const_string}, @code{eq_attr} (参见下面), @code{attr}, 
@code{symbol_ref}, 简单算术表达式, 和特定指令上的 @code{set_attr} 
(@pxref{Tagging Insns})中，作为字符串来表示的整数，

@cindex @code{const_string} and attributes
@item (const_string @var{value})
@en The string @var{value} specifies a constant attribute value.
@en If @var{value} is specified as @samp{"*"}, it means that the default value of
@en the attribute is to be used for the insn containing this expression.
@en @samp{"*"} obviously cannot be used in the @var{default} expression
@en of a @code{define_attr}.
字符串指定了一个常量属性值。如果 @var{value} 使用 @samp{"*"} 指定，
则表示包含该表达式的insn将使用属性的缺省值。显然 @samp{"*"} 不能用
于 @code{define_attr} 的 @var{default} 表达式。

@en If the attribute whose value is being specified is numeric, @var{value}
@en must be a string containing a non-negative integer (normally
@en @code{const_int} would be used in this case).  Otherwise, it must
@en contain one of the valid values for the attribute.
如果属性值被指定为数值的，@var{value} 必须为一个字符串，包含了一个
非负整数（通常这种情况下会使用 @code{const_int}）。否则，其必须包含
一个有效的属性值。 

@cindex @code{if_then_else} and attributes
@item (if_then_else @var{test} @var{true-value} @var{false-value})
@en @var{test} specifies an attribute test, whose format is defined below.
@en The value of this expression is @var{true-value} if @var{test} is true,
@en otherwise it is @var{false-value}.
@var{test} 指定了一个属性测试，其格式在下面定义。如果 @var{test} 为
真时，该表达式的值为 @var{true-value}，否则为 @var{false-value}。

@cindex @code{cond} and attributes
@item (cond [@var{test1} @var{value1} @dots{}] @var{default})
@en The first operand of this expression is a vector containing an even
@en number of expressions and consisting of pairs of @var{test} and @var{value}
@en expressions.  The value of the @code{cond} expression is that of the
@en @var{value} corresponding to the first true @var{test} expression.  If
@en none of the @var{test} expressions are true, the value of the @code{cond}
@en expression is that of the @var{default} expression.
该表达式的第一个操作数为一个向量，包含了偶数个表达式并且由 @var{test} 
和 @var{value} 表达式对组成。表达式 @code{cond} 的值为对应于第一个为
真的 @var{test} 表达式的 @var{value}。如果没有 @var{test} 表达式为真，
则 @code{cond} 表达式的值为 @var{default} 表达式。 
@end table

@en @var{test} expressions can have one of the following forms:
@var{test}表达式可以具有下列形式：

@table @code
@cindex @code{const_int} and attribute tests
@item (const_int @var{i})
@en This test is true if @var{i} is nonzero and false otherwise.
该测试为真，如果@var{i}非零，否则为假。

@cindex @code{not} and attributes
@cindex @code{ior} and attributes
@cindex @code{and} and attributes
@item (not @var{test})
@itemx (ior @var{test1} @var{test2})
@itemx (and @var{test1} @var{test2})
@en These tests are true if the indicated logical function is true.
这些测试为真，如果所表示的逻辑函数为真。

@cindex @code{match_operand} and attributes
@item (match_operand:@var{m} @var{n} @var{pred} @var{constraints})
@en This test is true if operand @var{n} of the insn whose attribute value
@en is being determined has mode @var{m} (this part of the test is ignored
@en if @var{m} is @code{VOIDmode}) and the function specified by the string
@en @var{pred} returns a nonzero value when passed operand @var{n} and mode
@en @var{m} (this part of the test is ignored if @var{pred} is the null
@en string).
该测试为真，如果insn的操作数@var{n}，其属性值被确定具有机器模式@var{m}（如果@var{m}为@code{VOIDmode}，则这部分测试被忽略），并且被字符串@var{pred}指定的函数，当传递操作数@var{n}和机器模式@var{m}时，返回一个非零值（如果@var{pred}为空字符串，则这部分测试被忽略）。

@en The @var{constraints} operand is ignored and should be the null string.
@var{constraints}操作数被忽略并且应该为空字符串。

@cindex @code{le} and attributes
@cindex @code{leu} and attributes
@cindex @code{lt} and attributes
@cindex @code{gt} and attributes
@cindex @code{gtu} and attributes
@cindex @code{ge} and attributes
@cindex @code{geu} and attributes
@cindex @code{ne} and attributes
@cindex @code{eq} and attributes
@cindex @code{plus} and attributes
@cindex @code{minus} and attributes
@cindex @code{mult} and attributes
@cindex @code{div} and attributes
@cindex @code{mod} and attributes
@cindex @code{abs} and attributes
@cindex @code{neg} and attributes
@cindex @code{ashift} and attributes
@cindex @code{lshiftrt} and attributes
@cindex @code{ashiftrt} and attributes
@item (le @var{arith1} @var{arith2})
@itemx (leu @var{arith1} @var{arith2})
@itemx (lt @var{arith1} @var{arith2})
@itemx (ltu @var{arith1} @var{arith2})
@itemx (gt @var{arith1} @var{arith2})
@itemx (gtu @var{arith1} @var{arith2})
@itemx (ge @var{arith1} @var{arith2})
@itemx (geu @var{arith1} @var{arith2})
@itemx (ne @var{arith1} @var{arith2})
@itemx (eq @var{arith1} @var{arith2})
@en These tests are true if the indicated comparison of the two arithmetic
@en expressions is true.  Arithmetic expressions are formed with
@en @code{plus}, @code{minus}, @code{mult}, @code{div}, @code{mod},
@en @code{abs}, @code{neg}, @code{and}, @code{ior}, @code{xor}, @code{not},
@en @code{ashift}, @code{lshiftrt}, and @code{ashiftrt} expressions.
这些测试为真，如果所表示的对两个算术表达式的比较为真。算术表达式的形式为
@code{plus}, @code{minus}, @code{mult}, @code{div}, @code{mod},
@code{abs}, @code{neg}, @code{and}, @code{ior}, @code{xor}, @code{not},
@code{ashift}, @code{lshiftrt}和@code{ashiftrt}表达式。

@findex get_attr
@en @code{const_int} and @code{symbol_ref} are always valid terms (@pxref{Insn
@en Lengths},for additional forms).  @code{symbol_ref} is a string
@en denoting a C expression that yields an @code{int} when evaluated by the
@en @samp{get_attr_@dots{}} routine.  It should normally be a global
@en variable.
@code{const_int}和@code{symbol_ref}总为有效（其它的形式，@pxref{Insn Lengths}）。@code{symbol_ref}为一个字符串，表示当使用@samp{get_attr_@dots{}}程序求解时，可以生成一个@code{int}的C表达式。其通常应该为一个全局变量。

@findex eq_attr
@item (eq_attr @var{name} @var{value})
@en @var{name} is a string specifying the name of an attribute.
@var{name}为一个字符串，指定了属性的名字。

@en @var{value} is a string that is either a valid value for attribute
@en @var{name}, a comma-separated list of values, or @samp{!} followed by a
@en value or list.  If @var{value} does not begin with a @samp{!}, this
@en test is true if the value of the @var{name} attribute of the current
@en insn is in the list specified by @var{value}.  If @var{value} begins
@en with a @samp{!}, this test is true if the attribute's value is
@en @emph{not} in the specified list.
@var{value}为一个字符串，或者为一个该属性@var{name}的有效值，由逗号分隔的值列表，或者为@samp{!}，后面跟随一个值或者列表。如果@var{value}不是起始于@samp{!}，则该测试为真，如果当前insn的@var{name}属性的值在值列表中。如果@var{value}起始于@samp{!}，则该测试为真，如果属性值不在指定的列表中。

@en For example,
例如，

@smallexample
(eq_attr "type" "load,store")
@end smallexample

@noindent
@en is equivalent to
等价于

@smallexample
(ior (eq_attr "type" "load") (eq_attr "type" "store"))
@end smallexample

@en If @var{name} specifies an attribute of @samp{alternative}, it refers to the
@en value of the compiler variable @code{which_alternative}
@en (@pxref{Output Statement}) and the values must be small integers.  For
@en example,
如果@var{name}指定了属性@samp{alternative}，则它是指的编译器变量@code{which_alternative}的值（@pxref{Output Statement}），并且值必须为小整数。例如，

@smallexample
(eq_attr "alternative" "2,3")
@end smallexample

@noindent
@en is equivalent to
等价于

@smallexample
(ior (eq (symbol_ref "which_alternative") (const_int 2))
     (eq (symbol_ref "which_alternative") (const_int 3)))
@end smallexample

@en Note that, for most attributes, an @code{eq_attr} test is simplified in cases
@en where the value of the attribute being tested is known for all insns matching
@en a particular pattern.  This is by far the most common case.
@en 
@en @findex attr_flag
@en @item (attr_flag @var{name})
@en The value of an @code{attr_flag} expression is true if the flag
@en specified by @var{name} is true for the @code{insn} currently being
@en scheduled.
@en 
@en @var{name} is a string specifying one of a fixed set of flags to test.
@en Test the flags @code{forward} and @code{backward} to determine the
@en direction of a conditional branch.  Test the flags @code{very_likely},
@en @code{likely}, @code{very_unlikely}, and @code{unlikely} to determine
@en if a conditional branch is expected to be taken.
@en 
@en If the @code{very_likely} flag is true, then the @code{likely} flag is also
@en true.  Likewise for the @code{very_unlikely} and @code{unlikely} flags.
@en 
@en This example describes a conditional branch delay slot which
@en can be nullified for forward branches that are taken (annul-true) or
@en for backward branches which are not taken (annul-false).
注意，对于大多数属性，当被测试的属性的值已知为匹配特定模式的所有insn时，@code{eq_attr}测试将被简化。这是迄今为止最常见的情况。

@findex attr_flag
@item (attr_flag @var{name})
表达式@code{attr_flag}的值为真，如果由@var{name}指定的标记对于当前被调度的@code{insn}为真。

@var{name}为一个字符串，指定了要测试的标记集合。测试标记@code{forward}和@code{backward}可以确定条件分支的方向。测试标记@code{very_likely}, @code{likely}, @code{very_unlikely}和@code{unlikely}可以确定条件分支是否被接受。

如果@code{very_likely}为真，则@code{likely}标记也为真。同样对于@code{very_unlikely}和@code{unlikely}也是这样。

该例子描述了一个条件分支延迟槽，其对于被接受的（annul-true）forward分支或者没有被接受的（annul-false）的backward分支，可以置空（nullified），

@smallexample
(define_delay (eq_attr "type" "cbranch")
  [(eq_attr "in_branch_delay" "true")
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "forward"))
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "backward"))])
@end smallexample

@en The @code{forward} and @code{backward} flags are false if the current
@en @code{insn} being scheduled is not a conditional branch.
标记@code{forward}和@code{backward}为假，如果当前被调度的@code{insn}不是条件分支。

@en The @code{very_likely} and @code{likely} flags are true if the
@en @code{insn} being scheduled is not a conditional branch.
@en The @code{very_unlikely} and @code{unlikely} flags are false if the
@en @code{insn} being scheduled is not a conditional branch.
标记@code{very_likely}和@code{likely}为真，如果被调度的@code{insn}不是条件分支。标记@code{very_unlikely}和@code{unlikely}为假，如果被调度的@code{attr_flag}不是条件分支。

@en @code{attr_flag} is only used during delay slot scheduling and has no
@en meaning to other passes of the compiler.
@code{attr_flag}只用于延迟槽调度阶段，并且跟编译器的其它过程没有关系。

@findex attr
@item (attr @var{name})
@en The value of another attribute is returned.  This is most useful
@en for numeric attributes, as @code{eq_attr} and @code{attr_flag}
@en produce more efficient code for non-numeric attributes.
返回另一个属性的值。这对于数值属性非常有用，因为@code{eq_attr}和@code{attr_flag}可以产生比非数值属性更加有效的代码。

@end table

@end ifset
@ifset INTERNALS
@en @node Tagging Insns
@en @subsection Assigning Attribute Values to Insns
@node Tagging Insns
@subsection 给Insns赋予属性值
@cindex tagging insns
@cindex assigning attribute values to insns

@en The value assigned to an attribute of an insn is primarily determined by
@en which pattern is matched by that insn (or which @code{define_peephole}
@en generated it).  Every @code{define_insn} and @code{define_peephole} can
@en have an optional last argument to specify the values of attributes for
@en matching insns.  The value of any attribute not specified in a particular
@en insn is set to the default value for that attribute, as specified in its
@en @code{define_attr}.  Extensive use of default values for attributes
@en permits the specification of the values for only one or two attributes
@en in the definition of most insn patterns, as seen in the example in the
@en next section.
给insn的属性赋予的值，主要由该insn所匹配的模式决定
（或者什么@code{define_peephole}生成的它）。
每个@code{define_insn}和@code{define_peephole}可以具有可选的最后的参数，
用来指定匹配insn的属性值。在特定insn中没有指定的任何属性的值，
将被设为在@code{define_attr}中指定的缺省值。

@en The optional last argument of @code{define_insn} and
@en @code{define_peephole} is a vector of expressions, each of which defines
@en the value for a single attribute.  The most general way of assigning an
@en attribute's value is to use a @code{set} expression whose first operand is an
@en @code{attr} expression giving the name of the attribute being set.  The
@en second operand of the @code{set} is an attribute expression
@en (@pxref{Expressions}) giving the value of the attribute.
可选的@code{define_insn}和@code{define_peephole}最后的参数，为一个表达式向量，
每个元素定义了单个属性的值。赋属性值的最通用方式是使用@code{set}表达式，
其第一个操作数为一个@code{attr}表达式，给出了要设置的属性名。
第二个操作数为一个属性表达式（@pxref{Expressions}），给出了属性值。

@en When the attribute value depends on the @samp{alternative} attribute
@en (i.e., which is the applicable alternative in the constraint of the
@en insn), the @code{set_attr_alternative} expression can be used.  It
@en allows the specification of a vector of attribute expressions, one for
@en each alternative.
当属性值依赖于可选（@samp{alternative}）属性，
则可以使用@code{set_attr_alternative}表达式。其允许指定属性表达式向量，
每个元素对应一个可选属性。

@findex set_attr
@en When the generality of arbitrary attribute expressions is not required,
@en the simpler @code{set_attr} expression can be used, which allows
@en specifying a string giving either a single attribute value or a list
@en of attribute values, one for each alternative.
当不需要一般性的任意属性表达式，则可以使用简单的@code{set_attr}表达式，
其允许指定一个字符串，给出单个属性值或者属性值列表，
其中每个元素对应于一个可选属性。

@en The form of each of the above specifications is shown below.  In each case,
@en @var{name} is a string specifying the attribute to be set.
以上的属性指定形式将在下面展示出。在每种情况中，@var{name}为一个字符串，
指定了要被设置的属性。

@table @code
@item (set_attr @var{name} @var{value-string})
@en @var{value-string} is either a string giving the desired attribute value,
@en or a string containing a comma-separated list giving the values for
@en succeeding alternatives.  The number of elements must match the number
@en of alternatives in the constraint of the insn pattern.
@var{value-string}是一个字符串或者一个由逗号分隔的字符串列表。字符串表示属性值，用逗号分割表示后续可选项的值。
属性元素的个数必须匹配在insn指令模式的约束中的可选项的个数。

@en Note that it may be useful to specify @samp{*} for some alternative, in
@en which case the attribute will assume its default value for insns matching
@en that alternative.
注意：@samp{*}对某些alternative来说是很有用的，这样属性将被假设它的缺省值匹配那个alternative。 

@findex set_attr_alternative
@item (set_attr_alternative @var{name} [@var{value1} @var{value2} @dots{}])
@en Depending on the alternative of the insn, the value will be one of the
@en specified values.  This is a shorthand for using a @code{cond} with
@en tests on the @samp{alternative} attribute.
取决于insn的可选项，值将为被指定值的其中之一。
这是对@samp{alternative}属性使用@code{cond}的简化形式。

@findex attr
@item (set (attr @var{name}) @var{value})
@en The first operand of this @code{set} must be the special RTL expression
@en @code{attr}, whose sole operand is a string giving the name of the
@en attribute being set.  @var{value} is the value of the attribute.
第一个操作数必须为特定RTL表达式@code{attr}，其唯一的操作数是一个字符串，
给出了被设置的属性名。@var{value}为属性值。
@end table

@en The following shows three different ways of representing the same
@en attribute value specification:
下面展示了三种表示相同的属性指定的不同的方式：

@smallexample
(set_attr "type" "load,store,arith")

(set_attr_alternative "type"
                      [(const_string "load") (const_string "store")
                       (const_string "arith")])

(set (attr "type")
     (cond [(eq_attr "alternative" "1") (const_string "load")
            (eq_attr "alternative" "2") (const_string "store")]
           (const_string "arith")))
@end smallexample

@need 1000
@findex define_asm_attributes
@en The @code{define_asm_attributes} expression provides a mechanism to
@en specify the attributes assigned to insns produced from an @code{asm}
@en statement.  It has the form:
表达式@code{define_asm_attributes}提供了一种机制，
用来指定赋予insn的属性是由@code{asm}语句产生的。其形式为：

@smallexample
(define_asm_attributes [@var{attr-sets}])
@end smallexample

@noindent
@en where @var{attr-sets} is specified the same as for both the
@en @code{define_insn} and the @code{define_peephole} expressions.
其中@var{attr-sets}为与@code{define_insn}和@code{define_peephole}中的相同。

@en These values will typically be the ``worst case'' attribute values.  For
@en example, they might indicate that the condition code will be clobbered.
这些值通常为“最坏情况”属性值。例如，它们可能指示条件码将被破坏（clobbered）。

@en A specification for a @code{length} attribute is handled specially.  The
@en way to compute the length of an @code{asm} insn is to multiply the
@en length specified in the expression @code{define_asm_attributes} by the
@en number of machine instructions specified in the @code{asm} statement,
@en determined by counting the number of semicolons and newlines in the
@en string.  Therefore, the value of the @code{length} attribute specified
@en in a @code{define_asm_attributes} should be the maximum possible length
@en of a single machine instruction.
为@code{length}属性赋值，将被特殊处理。
计算@code{asm} insn长度的方式是将表达式@code{define_asm_attributes}中指定的长度
乘以在@code{asm}语句中指定的机器指令个数。
指令个数通过计算字符串中分号和换行符的个数来决定。因此，
在@code{define_asm_attributes}中指定的@code{length}属性值应该为单个机器指令的
最大可能长度。

@end ifset
@ifset INTERNALS
@en @node Attr Example
@en @subsection Example of Attribute Specifications
@node Attr Example
@subsection 关于属性说明的例子
@cindex attribute specifications example
@cindex attribute specifications

@en The judicious use of defaulting is important in the efficient use of
@en insn attributes.  Typically, insns are divided into @dfn{types} and an
@en attribute, customarily called @code{type}, is used to represent this
@en value.  This attribute is normally used only to define the default value
@en for other attributes.  An example will clarify this usage.
要想有效的使用insn属性，巧妙的使用缺省值是很重要的。通常，insn被分为不同类别，
并使用称作@code{type}的属性来表示该值。该属性通常只用于定义其它属性的缺省值。
可以举一个例子来阐明它的用法。

@en Assume we have a RISC machine with a condition code and in which only
@en full-word operations are performed in registers.  Let us assume that we
@en can divide all insns into loads, stores, (integer) arithmetic
@en operations, floating point operations, and branches.
假设我们有一个RISC机器，其具有一个条件码并且在寄存器中只进行全字操作。
让我们假设可以将所有的insn分为加载，存储，（整数）算术运算，浮点运算和分支。

@en Here we will concern ourselves with determining the effect of an insn on
@en the condition code and will limit ourselves to the following possible
@en effects:  The condition code can be set unpredictably (clobbered), not
@en be changed, be set to agree with the results of the operation, or only
@en changed if the item previously set into the condition code has been
@en modified.
在这里我们将关注条件码对于insn的影响，并局限在下列可能的影响：
条件码可以被不可预期的设置（clobbered），没有改变，被设为符合运算结果的值，
或者只在先前被设置的条件码已经被修改。

@en Here is part of a sample @file{md} file for such a machine:
下面是该机器的一个样本@file{md}文件：

@smallexample
(define_attr "type" "load,store,arith,fp,branch" (const_string "arith"))

(define_attr "cc" "clobber,unchanged,set,change0"
             (cond [(eq_attr "type" "load")
                        (const_string "change0")
                    (eq_attr "type" "store,branch")
                        (const_string "unchanged")
                    (eq_attr "type" "arith")
                        (if_then_else (match_operand:SI 0 "" "")
                                      (const_string "set")
                                      (const_string "clobber"))]
                   (const_string "clobber")))

(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,r,m")
        (match_operand:SI 1 "general_operand" "r,m,r"))]
  ""
  "@@
   move %0,%1
   load %0,%1
   store %0,%1"
  [(set_attr "type" "arith,load,store")])
@end smallexample

@en Note that we assume in the above example that arithmetic operations
@en performed on quantities smaller than a machine word clobber the condition
@en code since they will set the condition code to a value corresponding to the
@en full-word result.
注意我们假设在上面的例子中，比机器字小的算术运算将会clobber条件码，
因为它们将会根据全字的结果来设置条件码。

@end ifset
@ifset INTERNALS
@en @node Insn Lengths
@en @subsection Computing the Length of an Insn
@node Insn Lengths
@subsection 计算一个Insn的长度
@cindex insn lengths, computing
@cindex computing the length of an insn

@en For many machines, multiple types of branch instructions are provided, each
@en for different length branch displacements.  In most cases, the assembler
@en will choose the correct instruction to use.  However, when the assembler
@en cannot do so, GCC can when a special attribute, the @code{length}
@en attribute, is defined.  This attribute must be defined to have numeric
@en values by specifying a null string in its @code{define_attr}.
许多机器提供了多种类型的分支指令，针对于不同长度的分支位移。多数情况下，
汇编器会选择使用正确的指令。但是，当汇编器无法做到的时候，如果一个特殊的属性，
@code{length}属性，被定义，则可以由GCC来完成。
该属性必须通过在它的@code{define_attr}中指定一个空字符串，
从而被定义成具有数字值。

@en In the case of the @code{length} attribute, two additional forms of
@en arithmetic terms are allowed in test expressions:
对于@code{length}属性，在test表达式中允许两个额外形式的算术术语：

@table @code
@cindex @code{match_dup} and attributes
@item (match_dup @var{n})
@en This refers to the address of operand @var{n} of the current insn, which
@en must be a @code{label_ref}.
这是指当前insn的操作数@var{n}的地址，其必须为一个@code{label_ref}。 

@cindex @code{pc} and attributes
@item (pc)
@en This refers to the address of the @emph{current} insn.  It might have
@en been more consistent with other usage to make this the address of the
@en @emph{next} insn but this would be confusing because the length of the
@en current insn is to be computed.
这是指当前insn的地址。或许可以将其设为下一个insn的地址，
从而跟其它地方的用法一致，但是这样容易引起混淆，因为还要计算当前insn的长度。 
@end table

@cindex @code{addr_vec}, length of
@cindex @code{addr_diff_vec}, length of
@en For normal insns, the length will be determined by value of the
@en @code{length} attribute.  In the case of @code{addr_vec} and
@en @code{addr_diff_vec} insn patterns, the length is computed as
@en the number of vectors multiplied by the size of each vector.
对于通常的insn，长度将由@code{length}属性的值来确定。
对于@code{addr_vec}和@code{addr_diff_vec}的insn模式，
长度通过向量数乘于每个向量的大小来计算获得。

@en Lengths are measured in addressable storage units (bytes).
长度按照可寻址的存储单元（字节）来度量。

@en The following macros can be used to refine the length computation:
下列宏可以用于改进长度计算：

@table @code
@findex ADJUST_INSN_LENGTH
@item ADJUST_INSN_LENGTH (@var{insn}, @var{length})
@en If defined, modifies the length assigned to instruction @var{insn} as a
@en function of the context in which it is used.  @var{length} is an lvalue
@en that contains the initially computed length of the insn and should be
@en updated with the correct length of the insn.
如果定义，则在上下文中作为函数来使用，用于修改赋予指令@var{insn}的长度。
@var{length}为一个lvalue（左值）包含了最初计算的insn长度并将使用insn的正确长度来更新。

@en This macro will normally not be required.  A case in which it is
@en required is the ROMP@.  On this machine, the size of an @code{addr_vec}
@en insn must be increased by two to compensate for the fact that alignment
@en may be required.
该宏通常并不需要。一种使用它的情况为ROMP。在这个机器上，
一个@code{addr_vec} insn的大小必须被加2用于补偿可能需要的指令对齐。
@end table

@findex get_attr_length
@en The routine that returns @code{get_attr_length} (the value of the
@en @code{length} attribute) can be used by the output routine to
@en determine the form of the branch instruction to be written, as the
@en example below illustrates.
返回@code{get_attr_length}（@code{length}属性的值）的程序，
可以被输出程序用来确定将要写入的分支指令的形式，正如下面的例子。

@en As an example of the specification of variable-length branches, consider
@en the IBM 360.  If we adopt the convention that a register will be set to
@en the starting address of a function, we can jump to labels within 4k of
@en the start using a four-byte instruction.  Otherwise, we need a six-byte
@en sequence to load the address from memory and then branch to it.
作为一个指定可变长度分支的例子，可以考虑一下IBM360。
如果我们采用寄存器将被设为函数起始地址这样的约定，
我们则可以使用一个4字节的指令来跳转到4K范围的标号。
否则，我们需要一个6字节的序列来从内存加载地址并然后分支到那里。

@en On such a machine, a pattern for a branch instruction might be specified
@en as follows:
对于这样的机器，可以按照如下的方式来指定一个分支指令模式：

@smallexample
(define_insn "jump"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  ""
@{
   return (get_attr_length (insn) == 4
           ? "b %l0" : "l r15,=a(%l0); br r15");
@}
  [(set (attr "length")
        (if_then_else (lt (match_dup 0) (const_int 4096))
                      (const_int 4)
                      (const_int 6)))])
@end smallexample

@end ifset
@ifset INTERNALS
@en @node Constant Attributes
@en @subsection Constant Attributes
@node Constant Attributes
@subsection 常量属性
@cindex constant attributes

@en A special form of @code{define_attr}, where the expression for the
@en default value is a @code{const} expression, indicates an attribute that
@en is constant for a given run of the compiler.  Constant attributes may be
@en used to specify which variety of processor is used.  For example,
一个@code{define_attr}的特殊形式，是其缺省值的表达式为一个@code{const}表达式，
这表示了对于一个给定的运行编译器的一个属性为常量。
常量熟性可以用于指定使用了哪个处理器的变种。例如，

@smallexample
(define_attr "cpu" "m88100,m88110,m88000"
 (const
  (cond [(symbol_ref "TARGET_88100") (const_string "m88100")
         (symbol_ref "TARGET_88110") (const_string "m88110")]
        (const_string "m88000"))))

(define_attr "memory" "fast,slow"
 (const
  (if_then_else (symbol_ref "TARGET_FAST_MEM")
                (const_string "fast")
                (const_string "slow"))))
@end smallexample

@en The routine generated for constant attributes has no parameters as it
@en does not depend on any particular insn.  RTL expressions used to define
@en the value of a constant attribute may use the @code{symbol_ref} form,
@en but may not use either the @code{match_operand} form or @code{eq_attr}
@en forms involving insn attributes.
针对常量属性生成的程序不具有任何参数，因为它不依赖于任何特定的insn。
用于定义常量属性的RTL表达式可以使用@code{symbol_ref}形式，
但是不可以使用包括insn属性的@code{match_operand}形式或者@code{eq_attr}形式。

@end ifset
@ifset INTERNALS
@en @node Delay Slots
@en @subsection Delay Slot Scheduling
@node Delay Slots
@subsection 延迟槽调度
@cindex delay slots, defining

@en The insn attribute mechanism can be used to specify the requirements for
@en delay slots, if any, on a target machine.  An instruction is said to
@en require a @dfn{delay slot} if some instructions that are physically
@en after the instruction are executed as if they were located before it.
@en Classic examples are branch and call instructions, which often execute
@en the following instruction before the branch or call is performed.
如果在一个目标机上存在延迟槽的话，insn属性机制可以用于指定对延迟槽的需求。
一条指令被称为需要延迟槽，
如果在物理上位于该指令之后的一些指令将被按照它们仿佛是位于之前的情况被执行。
典型的例子是分支和调用指令，其通常在执行分支或调用之前先执行后面的指令。

@en On some machines, conditional branch instructions can optionally
@en @dfn{annul} instructions in the delay slot.  This means that the
@en instruction will not be executed for certain branch outcomes.  Both
@en instructions that annul if the branch is true and instructions that
@en annul if the branch is false are supported.
在一些机器上，条件分支指令可以选择性的废除（@dfn{annul}）延迟槽中的指令。
这意味着该指令对于特定的分支结果将不被执行。
对于分支为真时废除指令和分支为假时废除指令，这两种方式都被支持。

@en Delay slot scheduling differs from instruction scheduling in that
@en determining whether an instruction needs a delay slot is dependent only
@en on the type of instruction being generated, not on data flow between the
@en instructions.  See the next section for a discussion of data-dependent
@en instruction scheduling.
延迟槽调度与指令调度的不同之处在于，
判定一条指令是否需要延迟槽只依赖于正被生成的指令的类型，而不是指令间的数据流。
关于数据相关的指令调度的讨论，参见下一个章节。

@findex define_delay
@en The requirement of an insn needing one or more delay slots is indicated
@en via the @code{define_delay} expression.  It has the following form:
一个insn对一个或多个延迟槽的需求是通过@code{define_delay}表达式来表示的。
其具有下列形式：

@smallexample
(define_delay @var{test}
              [@var{delay-1} @var{annul-true-1} @var{annul-false-1}
               @var{delay-2} @var{annul-true-2} @var{annul-false-2}
               @dots{}])
@end smallexample
 
@en @var{test} is an attribute test that indicates whether this
@en @code{define_delay} applies to a particular insn.  If so, the number of
@en required delay slots is determined by the length of the vector specified
@en as the second argument.  An insn placed in delay slot @var{n} must
@en satisfy attribute test @var{delay-n}.  @var{annul-true-n} is an
@en attribute test that specifies which insns may be annulled if the branch
@en is true.  Similarly, @var{annul-false-n} specifies which insns in the
@en delay slot may be annulled if the branch is false.  If annulling is not
@en supported for that delay slot, @code{(nil)} should be coded.
@var{test}是一个属性测试，用来表示该@code{define_delay}是否应用到特定的insn。
如果是，则所需延迟槽的数目通过作为第二个参数的向量的长度来确定。
放在延迟槽@var{n}中的insn必须满足属性测试@var{delay-n}。
@var{annul-true-n}是一个属性测试，用来指定当分支为真时哪些insn可以被废除。
如果该延迟槽不支持废除，则应该使用@code{(nil)}。

@en For example, in the common case where branch and call insns require
@en a single delay slot, which may contain any insn other than a branch or
@en call, the following would be placed in the @file{md} file:
例如，通常情况下分支和调用insns都需要一个单个的延迟槽，
其可以包含任何不是分支或调用的其它insn，则下面的可以放入@file{md}文件中：

@smallexample
(define_delay (eq_attr "type" "branch,call")
              [(eq_attr "type" "!branch,call") (nil) (nil)])
@end smallexample

@en Multiple @code{define_delay} expressions may be specified.  In this
@en case, each such expression specifies different delay slot requirements
@en and there must be no insn for which tests in two @code{define_delay}
@en expressions are both true.
可以指定多个@code{define_delay}表达式。在这种情况下，
每个这样的表达式都指定了不同的延迟槽需求，
并且在两个@code{define_delay}表达式中的test必须不能都为真。

@en For example, if we have a machine that requires one delay slot for branches
@en but two for calls,  no delay slot can contain a branch or call insn,
@en and any valid insn in the delay slot for the branch can be annulled if the
@en branch is true, we might represent this as follows:
例如，如果我们有一个机器，其对分支需要一个延迟槽，但对调用需要两个，
延迟槽不能包含分支或调用insn，并且当分支为真时，
任何在分支延迟槽中的有效insn可以被废除，则我们可以使用下列方式来表示：

@smallexample
(define_delay (eq_attr "type" "branch")
   [(eq_attr "type" "!branch,call")
    (eq_attr "type" "!branch,call")
    (nil)])

(define_delay (eq_attr "type" "call")
              [(eq_attr "type" "!branch,call") (nil) (nil)
               (eq_attr "type" "!branch,call") (nil) (nil)])
@end smallexample
@c the above is *still* too long.  --mew 4feb93

@end ifset
@ifset INTERNALS
@en @node Processor pipeline description
@en @subsection Specifying processor pipeline description
@node Processor pipeline description
@subsection 处理器流水线描述
@cindex processor pipeline description
@cindex processor functional units
@cindex instruction latency time
@cindex interlock delays
@cindex data dependence delays
@cindex reservation delays
@cindex pipeline hazard recognizer
@cindex automaton based pipeline description
@cindex regular expressions
@cindex deterministic finite state automaton
@cindex automaton based scheduler
@cindex RISC
@cindex VLIW

@en To achieve better performance, most modern processors
@en (super-pipelined, superscalar @acronym{RISC}, and @acronym{VLIW}
@en processors) have many @dfn{functional units} on which several
@en instructions can be executed simultaneously.  An instruction starts
@en execution if its issue conditions are satisfied.  If not, the
@en instruction is stalled until its conditions are satisfied.  Such
@en @dfn{interlock (pipeline) delay} causes interruption of the fetching
@en of successor instructions (or demands nop instructions, e.g.@: for some
@en MIPS processors).
为了获得更好的性能，大多数现代处理器（超流水线，超标量@acronym{RISC}，
以及@acronym{VLIW}处理器）都具有许多功能单元（@dfn{functional units}），
可以在其上同时执行多条指令。一条指令当它的发射条件（issue conditions）
被满足时才开始执行。如果不满足，则指令会被阻塞（stalled），直到它的条件被满足。
这样的互锁（流水线）延迟(@dfn{interlock (pipeline) delay})
导致对后续指令读取的中断（或者需要nop指令，例如一些MIPS处理器）。

@en There are two major kinds of interlock delays in modern processors.
@en The first one is a data dependence delay determining @dfn{instruction
@en latency time}.  The instruction execution is not started until all
@en source data have been evaluated by prior instructions (there are more
@en complex cases when the instruction execution starts even when the data
@en are not available but will be ready in given time after the
@en instruction execution start).  Taking the data dependence delays into
@en account is simple.  The data dependence (true, output, and
@en anti-dependence) delay between two instructions is given by a
@en constant.  In most cases this approach is adequate.  The second kind
@en of interlock delays is a reservation delay.  The reservation delay
@en means that two instructions under execution will be in need of shared
@en processors resources, i.e.@: buses, internal registers, and/or
@en functional units, which are reserved for some time.  Taking this kind
@en of delay into account is complex especially for modern @acronym{RISC}
@en processors.
现代处理器中有两种主要的互锁延迟。第一种为数据依赖延迟，用来确定指令延迟时间
（@dfn{instruction latency time}）。直到所有源数据都被先前指令求得，
该指令才会开始执行（有更加复杂的情况是，
当指令开始执行时数据还不可用，但是将会在指令开始执行后的给定时间准备好）。
考虑数据依赖延迟是简单的。
两个指令间的数据依赖（真依赖，输出依赖，反依赖）延迟被给定为一个常量。
大多数情况下该方法都适合。第二种互锁延迟为保留延迟（reservation delay）。
保留延迟意味着要执行的两条指令将会需要共享的处理器资源，即总线，内部寄存器，
以及/或者功能单元，而这些将被保留一段时间。考虑这种延迟是复杂的，
特别是对于现代@acronym{RISC}处理器。

@en The task of exploiting more processor parallelism is solved by an
@en instruction scheduler.  For a better solution to this problem, the
@en instruction scheduler has to have an adequate description of the
@en processor parallelism (or @dfn{pipeline description}).  GCC
@en machine descriptions describe processor parallelism and functional
@en unit reservations for groups of instructions with the aid of
@en @dfn{regular expressions}.
探索更多的处理器并行的任务是由指令调度器来解决的。为了能够更好的解决该问题，
指令调度器必须具有一个处理器并行的适当描述（或者说流水线描述）。
GCC机器描述使用正规表达式来描述处理器并行和对指令组的功能单元保留。

@en The GCC instruction scheduler uses a @dfn{pipeline hazard recognizer} to
@en figure out the possibility of the instruction issue by the processor
@en on a given simulated processor cycle.  The pipeline hazard recognizer is
@en automatically generated from the processor pipeline description.  The
@en pipeline hazard recognizer generated from the machine description
@en is based on a deterministic finite state automaton (@acronym{DFA}):
@en the instruction issue is possible if there is a transition from one
@en automaton state to another one.  This algorithm is very fast, and
@en furthermore, its speed is not dependent on processor
@en complexity@footnote{However, the size of the automaton depends on
@en processor complexity.  To limit this effect, machine descriptions
@en can split orthogonal parts of the machine description among several
@en automata: but then, since each of these must be stepped independently,
@en this does cause a small decrease in the algorithm's performance.}.
GCC指令调度器使用流水线冒险识别器通过给定的处理器时钟周期模拟来找出可能的指令问题。
流水线冒险识别器通过处理器流水线描述自动生成。
由机器描述生成的流水线冒险识别器是基于有限确定状态机（@acronym{DFA}）：
如果存在从一个自动机状态到另一状态的转换，则可以进行指令发射。
该算法非常快，而且它的速度不依赖于处理器的复杂度
@footnote{然而，自动机的大小依赖于处理器的复杂度。为了限制这种影响，
机器描述可以将机器描述的正交部分拆分成多个自动机：但是，
由于每个这样的自动机都必须独立的执行每一步，
所以这确实会在算法性能上造成一点消减。}。

@cindex automaton based pipeline description
@en The rest of this section describes the directives that constitute
@en an automaton-based processor pipeline description.  The order of
@en these constructions within the machine description file is not
@en important.
该章节的剩余部分描述了构造一个基于自动机的处理器流水线描述的命令（directive）。
这些结构在机器描述文件中的顺序并不重要。

@findex define_automaton
@cindex pipeline hazard recognizer
@en The following optional construction describes names of automata
@en generated and used for the pipeline hazards recognition.  Sometimes
@en the generated finite state automaton used by the pipeline hazard
@en recognizer is large.  If we use more than one automaton and bind functional
@en units to the automata, the total size of the automata is usually
@en less than the size of the single automaton.  If there is no one such
@en construction, only one finite state automaton is generated.
下面的可选结构描述了生成的自动机的名字，并用于流水线冒险识别。
有时供流水线冒险识别器使用的生成的有限状态机会非常大。
如果我们使用多个自动机并且将功能单元绑定到自动机上，
则自动机的总的大小通常会小于单个自动机的情况。
如果没有这样一个结构，则会只生成一个有限状态机。

@smallexample
(define_automaton @var{automata-names})
@end smallexample

@en @var{automata-names} is a string giving names of the automata.  The
@en names are separated by commas.  All the automata should have unique names.
@en The automaton name is used in the constructions @code{define_cpu_unit} and
@en @code{define_query_cpu_unit}.
@var{automata-names}为一个字符串，给出了自动机的名字。
名字由逗号分隔。所有自动机应该具有唯一的名字。
自动机名用于结构@code{define_cpu_unit}和@code{define_query_cpu_unit}。

@findex define_cpu_unit
@cindex processor functional units
@en Each processor functional unit used in the description of instruction
@en reservations should be described by the following construction.
用于指令保留描述的每个处理器功能单元应该使用下列结构来描述。

@smallexample
(define_cpu_unit @var{unit-names} [@var{automaton-name}])
@end smallexample

@en @var{unit-names} is a string giving the names of the functional units
@en separated by commas.  Don't use name @samp{nothing}, it is reserved
@en for other goals.
@var{unit-names}为一个字符串，给出了由逗号分隔的功能单元的名字。
不要使用名字@samp{nothing}，它被保留用于其它目的。

@en @var{automaton-name} is a string giving the name of the automaton with
@en which the unit is bound.  The automaton should be described in
@en construction @code{define_automaton}.  You should give
@en @dfn{automaton-name}, if there is a defined automaton.
@var{automaton-name}为一个字符串，给出了功能单元绑定的自动机名。
自动机应该在结构@code{define_automaton}中有描述。
如果有一个定义的自动机，则你应该给出@dfn{automaton-name}。

@en The assignment of units to automata are constrained by the uses of the
@en units in insn reservations.  The most important constraint is: if a
@en unit reservation is present on a particular cycle of an alternative
@en for an insn reservation, then some unit from the same automaton must
@en be present on the same cycle for the other alternatives of the insn
@en reservation.  The rest of the constraints are mentioned in the
@en description of the subsequent constructions.
为功能单元赋予自动机，受到insn保留中对功能单元使用的限制。
最重要的constraint为：如果一个功能单元保留。
其余的constraint将在后续的结构描述中提到。

@findex define_query_cpu_unit
@cindex querying function unit reservations
@en The following construction describes CPU functional units analogously
@en to @code{define_cpu_unit}.  The reservation of such units can be
@en queried for an automaton state.  The instruction scheduler never
@en queries reservation of functional units for given automaton state.  So
@en as a rule, you don't need this construction.  This construction could
@en be used for future code generation goals (e.g.@: to generate
@en @acronym{VLIW} insn templates).
下面的结构描述了CPU功能单元，类似于@code{define_cpu_unit}。
对于这样的功能单元的保留，可以被询问自动机状态。
对于给定的自动机状态，指令调度器从来不询问功能单元的保留。
所以按照规则，你不需要该结构。
该结构可以被用于将来的代码生成目的（例如，生成@acronym{VLIW} insn模板）。

@smallexample
(define_query_cpu_unit @var{unit-names} [@var{automaton-name}])
@end smallexample

@en @var{unit-names} is a string giving names of the functional units
@en separated by commas.
@var{unit-names}为一个字符串，给出了由逗号分隔的功能单元名字。

@en @var{automaton-name} is a string giving the name of the automaton with
@en which the unit is bound.
@var{automaton-name}为一个字符串，给出了功能单元所绑定的自动机。

@findex define_insn_reservation
@cindex instruction latency time
@cindex regular expressions
@cindex data bypass
@en The following construction is the major one to describe pipeline
@en characteristics of an instruction.
下面的结构为描述一条指令的流水线特征的主要结构。

@smallexample
(define_insn_reservation @var{insn-name} @var{default_latency}
                         @var{condition} @var{regexp})
@end smallexample

@en @var{default_latency} is a number giving latency time of the
@en instruction.  There is an important difference between the old
@en description and the automaton based pipeline description.  The latency
@en time is used for all dependencies when we use the old description.  In
@en the automaton based pipeline description, the given latency time is only
@en used for true dependencies.  The cost of anti-dependencies is always
@en zero and the cost of output dependencies is the difference between
@en latency times of the producing and consuming insns (if the difference
@en is negative, the cost is considered to be zero).  You can always
@en change the default costs for any description by using the target hook
@en @code{TARGET_SCHED_ADJUST_COST} (@pxref{Scheduling}).
@var{default_latency}为一个数，给出了指令的延迟时间。
在旧描述和基于自动机的流水线描述中，有一个重要的不同之处。
当我们使用旧描述时，延迟时间是用于所有的依赖。
在基于自动机的流水线描述中，给定的延迟时间只用于真依赖。
反依赖的代价总为0，并且输出依赖的代价是生产者insn和消费者insn的延迟时间之差
（如果差为负数，则代价被认为为0）。
你可以通过使用目标机钩子@code{TARGET_SCHED_ADJUST_COST}（@pxref{Scheduling}），
来改变任何描述的缺省代价。

@en @var{insn-name} is a string giving the internal name of the insn.  The
@en internal names are used in constructions @code{define_bypass} and in
@en the automaton description file generated for debugging.  The internal
@en name has nothing in common with the names in @code{define_insn}.  It is a
@en good practice to use insn classes described in the processor manual.
@var{insn-name}为一个字符串，给出了insn的内部名字。
内部名字被用于结构@code{define_bypass}和为了调试所生成的自动机描述文件。
内部名字与@code{define_insn}中的名字没有任何关系。
使用在处理器手册中描述的insn类别，是一个很好的做法。

@en @var{condition} defines what RTL insns are described by this
@en construction.  You should remember that you will be in trouble if
@en @var{condition} for two or more different
@en @code{define_insn_reservation} constructions is TRUE for an insn.  In
@en this case what reservation will be used for the insn is not defined.
@en Such cases are not checked during generation of the pipeline hazards
@en recognizer because in general recognizing that two conditions may have
@en the same value is quite difficult (especially if the conditions
@en contain @code{symbol_ref}).  It is also not checked during the
@en pipeline hazard recognizer work because it would slow down the
@en recognizer considerably.
@var{condition}定义了什么样的RTL insns由该结构描述。
你应该记住如果对于一个insn，
两个或更多不同@code{define_insn_reservation}结构的@var{condition}都为真，
则会出问题。这种情况，该insn将使用什么保留，是未定义的。
这种情况在流水线冒险识别器生成时，是不被检查的，
因为识别两个条件具有相同值是十分困难的
（特别是如果条件中包含@code{symbol_ref}）。
这在流水线识别器工作时，也不被检查，因为它将使识别器变得相当慢。

@en @var{regexp} is a string describing the reservation of the cpu's functional
@en units by the instruction.  The reservations are described by a regular
@en expression according to the following syntax:
@var{regexp}为一个字符串，描述了指令对cpu的功能单元的保留。
保留通过正规表达式来描述，语法如下：

@smallexample
       regexp = regexp "," oneof
              | oneof

       oneof = oneof "|" allof
             | allof

       allof = allof "+" repeat
             | repeat

       repeat = element "*" number
              | element

       element = cpu_function_unit_name
               | reservation_name
               | result_name
               | "nothing"
               | "(" regexp ")"
@end smallexample

@itemize @bullet
@item
@en @samp{,} is used for describing the start of the next cycle in
@en the reservation.
@samp{,}用于描述在保留中，下一周期的开始。

@item
@en @samp{|} is used for describing a reservation described by the first
@en regular expression @strong{or} a reservation described by the second
@en regular expression @strong{or} etc.
@samp{|}用于描述在保留中，第一个正规表达式@strong{or}第二个正规表达式，
@strong{or}等等。 

@item
@en @samp{+} is used for describing a reservation described by the first
@en regular expression @strong{and} a reservation described by the
@en second regular expression @strong{and} etc.
@samp{+}用于描述在保留中，第一个正规表达式@strong{and}第二个正规表达式，
@strong{and}等等。

@item
@en @samp{*} is used for convenience and simply means a sequence in which
@en the regular expression are repeated @var{number} times with cycle
@en advancing (see @samp{,}).
@samp{*}用于方便记述，其简单的表示一个正规表达式序列，
表达式随着周期前移被重复@var{number}次（参见@samp{,}）。

@item
@en @samp{cpu_function_unit_name} denotes reservation of the named
@en functional unit.
@samp{cpu_function_unit_name}表示对命名功能单元的保留。

@item
@en @samp{reservation_name} --- see description of construction
@en @samp{define_reservation}.
@samp{reservation_name} --- 参见对结构@samp{define_reservation}的描述。

@item
@en @samp{nothing} denotes no unit reservations.
@samp{nothing}表示没有功能单元被保留。
@end itemize

@findex define_reservation
@en Sometimes unit reservations for different insns contain common parts.
@en In such case, you can simplify the pipeline description by describing
@en the common part by the following construction
有时，对于不同insn，具有共同部分的单元保留。
这样情况，你可以通过使用下面的结构来描述共同部分，以简化流水线描述。

@smallexample
(define_reservation @var{reservation-name} @var{regexp})
@end smallexample

@en @var{reservation-name} is a string giving name of @var{regexp}.
@en Functional unit names and reservation names are in the same name
@en space.  So the reservation names should be different from the
@en functional unit names and can not be the reserved name @samp{nothing}.
@var{reservation-name}为一个字符串，给出了@var{regexp}的名字。
功能单元名和保留名属于同一命名空间。所以，保留名应该与功能单元名不同，
并且不能为预留名@samp{nothing}。

@findex define_bypass
@cindex instruction latency time
@cindex data bypass
@en The following construction is used to describe exceptions in the
@en latency time for given instruction pair.  This is so called bypasses.
下面的结构被用于描述对于给定的指令对，在延迟时间上的例外。也称之为bypass。

@smallexample
(define_bypass @var{number} @var{out_insn_names} @var{in_insn_names}
               [@var{guard}])
@end smallexample

@en @var{number} defines when the result generated by the instructions
@en given in string @var{out_insn_names} will be ready for the
@en instructions given in string @var{in_insn_names}.  The instructions in
@en the string are separated by commas.
@var{number}定义了给定字符串@var{out_insn_names}的指令所产生的结果，
什么时候可以由给定字符串@var{in_insn_names}的指令使用。
字符串中的指令由逗号分隔。

@en @var{guard} is an optional string giving the name of a C function which
@en defines an additional guard for the bypass.  The function will get the
@en two insns as parameters.  If the function returns zero the bypass will
@en be ignored for this case.  The additional guard is necessary to
@en recognize complicated bypasses, e.g.@: when the consumer is only an address
@en of insn @samp{store} (not a stored value).
@var{guard}为一个可选的字符串，给出了C函数名，其定义了bypass的额外的保护条件。
该函数将两个insn作为参数。如果函数返回0，则对于该情况bypass将被忽略。
额外的guard在识别复杂的bypass时，很有必要。
例如当消费者只是一个insn @samp{store}的地址（而不是被存储的值）。

If there are more one bypass with the same output and input insns, the
chosen bypass is the first bypass with a guard in description whose
guard function returns nonzero.  If there is no such bypass, then
bypass without the guard function is chosen.

@findex exclusion_set
@findex presence_set
@findex final_presence_set
@findex absence_set
@findex final_absence_set
@cindex VLIW
@cindex RISC
@en The following five constructions are usually used to describe
@en @acronym{VLIW} processors, or more precisely, to describe a placement
@en of small instructions into @acronym{VLIW} instruction slots.  They
@en can be used for @acronym{RISC} processors, too.
下面五个结构通常用于描述@acronym{VLIW}处理器，或者更精确的说，
来描述放入@acronym{VLIW}指令槽中的小指令的位置。
它们也可以用于@acronym{RISC}处理器。

@smallexample
(exclusion_set @var{unit-names} @var{unit-names})
(presence_set @var{unit-names} @var{patterns})
(final_presence_set @var{unit-names} @var{patterns})
(absence_set @var{unit-names} @var{patterns})
(final_absence_set @var{unit-names} @var{patterns})
@end smallexample

@en @var{unit-names} is a string giving names of functional units
@en separated by commas.
@var{unit-names}为一个字符串，给出了由逗号分隔的功能单元的名字。

@en @var{patterns} is a string giving patterns of functional units
@en separated by comma.  Currently pattern is one unit or units
@en separated by white-spaces.
@var{patterns}为一个字符串，给出了由逗号分隔的功能单元的模式。
目前的模式，为一个单元或者由空格分隔的单元。

@en The first construction (@samp{exclusion_set}) means that each
@en functional unit in the first string can not be reserved simultaneously
@en with a unit whose name is in the second string and vice versa.  For
@en example, the construction is useful for describing processors
@en (e.g.@: some SPARC processors) with a fully pipelined floating point
@en functional unit which can execute simultaneously only single floating
@en point insns or only double floating point insns.
第一个结构(@samp{exclusion_set}) 意味着第一个字符串中的每个功能单元不能与
第二个字符串中的功能单元同时被保留，反之亦然。例如，结构可以用于描述处理器
（例如，一些SPARC处理器）具有全流水浮点功能单元，
其只可以同时执行单浮点insn或者双浮点insn。

@en The second construction (@samp{presence_set}) means that each
@en functional unit in the first string can not be reserved unless at
@en least one of pattern of units whose names are in the second string is
@en reserved.  This is an asymmetric relation.  For example, it is useful
@en for description that @acronym{VLIW} @samp{slot1} is reserved after
@en @samp{slot0} reservation.  We could describe it by the following
@en construction
第二个结构(@samp{presence_set}) 意味着第一个字符串中的每个功能单元不能被保留，
除非至少一种模式的功能单元其名字在第二个字符串中且被保留。这是一个不对称关系。
例如，可以用于描述@acronym{VLIW} @samp{slot1}在@samp{slot0}保留之后被保留。
我们可以使用下列结构来描述

@smallexample
(presence_set "slot1" "slot0")
@end smallexample

@en Or @samp{slot1} is reserved only after @samp{slot0} and unit @samp{b0}
@en reservation.  In this case we could write
或者@samp{slot1}只在@samp{slot0}和功能单元@samp{b0}保留之后被保留。
这种情况下，我们可以写成

@smallexample
(presence_set "slot1" "slot0 b0")
@end smallexample

@en The third construction (@samp{final_presence_set}) is analogous to
@en @samp{presence_set}.  The difference between them is when checking is
@en done.  When an instruction is issued in given automaton state
@en reflecting all current and planned unit reservations, the automaton
@en state is changed.  The first state is a source state, the second one
@en is a result state.  Checking for @samp{presence_set} is done on the
@en source state reservation, checking for @samp{final_presence_set} is
@en done on the result reservation.  This construction is useful to
@en describe a reservation which is actually two subsequent reservations.
@en For example, if we use
第三个结构(@samp{final_presence_set}) 类似于@samp{presence_set}。
区别在于什么时候进行检查。当指令在给定自动机状态被发射时，
其将影响所有当前和计划中的单元保留，并且自动机状态被改变。
第一个状态为源状态，第二个为结果状态。
对于@samp{presence_set}的检查是在源状态保留时进行的，
对于@samp{final_presence_set}的检查是在结果状态下进行的。
该结构可以用于描述实际上是两个连续的保留的保留。例如，如果我们使用

@smallexample
(presence_set "slot1" "slot0")
@end smallexample

@en the following insn will be never issued (because @samp{slot1} requires
@en @samp{slot0} which is absent in the source state).
下列insn将永远不会被发射（因为@samp{slot1}需要@samp{slot0}，
而@samp{slot0}在源状态是空缺的）

@smallexample
(define_reservation "insn_and_nop" "slot0 + slot1")
@end smallexample

@en but it can be issued if we use analogous @samp{final_presence_set}.
但是如果我们使用类似的@samp{final_presence_set}其就可以被发射。

@en The forth construction (@samp{absence_set}) means that each functional
@en unit in the first string can be reserved only if each pattern of units
@en whose names are in the second string is not reserved.  This is an
@en asymmetric relation (actually @samp{exclusion_set} is analogous to
@en this one but it is symmetric).  For example it might be useful in a 
@en @acronym{VLIW} description to say that @samp{slot0} cannot be reserved
@en after either @samp{slot1} or @samp{slot2} have been reserved.  This
@en can be described as:
第四个结构 (@samp{absence_set}) 意味着在第一个字符串中的每个功能单元，
只有在每个名字在第二个字符串中的功能单元没有被保留时才能被保留。
这是一个不对称关系（实际上@samp{exclusion_set}与其类似，但它是对成的）。
例如，可以用于@acronym{VLIW}描述，来表示@samp{slot0}不能在@samp{slot1}或
@samp{slot2}保留后被保留。这可以描述为

@smallexample
(absence_set "slot0" "slot1, slot2")
@end smallexample

@en Or @samp{slot2} can not be reserved if @samp{slot0} and unit @samp{b0}
@en are reserved or @samp{slot1} and unit @samp{b1} are reserved.  In
@en this case we could write
或者@samp{slot2}不能被保留，如果@samp{slot0}和单元@samp{b0}被保留，
或者@samp{slot1}和单元@samp{b1}被保留. 这种情况下，我们可以写成

@smallexample
(absence_set "slot2" "slot0 b0, slot1 b1")
@end smallexample

@en All functional units mentioned in a set should belong to the same
@en automaton.
所有在集合（set）中提到的功能单元应属于相同的自动机。
@en The last construction (@samp{final_absence_set}) is analogous to
@en @samp{absence_set} but checking is done on the result (state)
@en reservation.  See comments for @samp{final_presence_set}.
最后一个结构(@samp{final_absence_set})类似于@samp{absence_set}，
但是检查是在结果（状态）保留时进行。参见@samp{final_presence_set}的注解。

@en @findex automata_option
@en @cindex deterministic finite state automaton
@en @cindex nondeterministic finite state automaton
@en @cindex finite state automaton minimization
@en You can control the generator of the pipeline hazard recognizer with
@en the following construction.
@en 
@en @smallexample
@en (automata_option @var{options})
@en @end smallexample
@en 
@en @var{options} is a string giving options which affect the generated
@en code.  Currently there are the following options:
@findex automata_option
@cindex deterministic finite state automaton
@cindex nondeterministic finite state automaton
@cindex finite state automaton minimization
你可以使用下面的结构来控制流水线冒险识别器的生成。

@smallexample
(automata_option @var{options})
@end smallexample

@var{options}为一个字符串，给出了影响生成代码的选项。目前有下列选项：

@itemize @bullet
@item
@en @dfn{no-minimization} makes no minimization of the automaton.  This is
@en only worth to do when we are debugging the description and need to
@en look more accurately at reservations of states.
@dfn{no-minimization}不对自动机进行最小化处理。
这只在我们进行调试描述信息并且需要更加精确的查看保留状态时，才值得做。

@item
@en @dfn{time} means printing time statistics about the generation of
@en automata.
@dfn{time}意味着打印生成自动机的时间统计。

@item
@en @dfn{stats} means printing statistics about the generated automata
@en such as the number of DFA states, NDFA states and arcs.
@dfn{stats}意味着打印生成自动机的DFA状态，NDFA状态和arcs这样的数目统

@item
@en @dfn{v} means a generation of the file describing the result automata.
@en The file has suffix @samp{.dfa} and can be used for the description
@en verification and debugging.
@dfn{v}意味着生成一个描述生成自动机的文件。文件具有后缀@samp{.dfa}，
并且可以用于验证和调试描述。

@item
@en @dfn{w} means a generation of warning instead of error for
@en non-critical errors.
@dfn{w}意味着对于非关键的错误使用警告来替代。

@item
@en @dfn{ndfa} makes nondeterministic finite state automata.  This affects
@en the treatment of operator @samp{|} in the regular expressions.  The
@en usual treatment of the operator is to try the first alternative and,
@en if the reservation is not possible, the second alternative.  The
@en nondeterministic treatment means trying all alternatives, some of them
@en may be rejected by reservations in the subsequent insns.
@dfn{ndfa}生成非确定有限状态机。这将影响对正规表达式中操作符@samp{|}的对待。
通常对该操作符的处理是先尝试第一个，然后再第二个。
非确定状态机意味着尝试所有的选择，其中一些可以被后续的insn放弃。

@item
@en @dfn{progress} means output of a progress bar showing how many states
@en were generated so far for automaton being processed.  This is useful
@en during debugging a @acronym{DFA} description.  If you see too many
@en generated states, you could interrupt the generator of the pipeline
@en hazard recognizer and try to figure out a reason for generation of the
@en huge automaton.
@dfn{progress}意味着输出一个进度条，来显示被处理的自动机目前生成了多少状态。
这在调试@acronym{DFA}描述时很有用。如果你看到太多的状态被生成，
你可以中断流水线冒险识别器的生成并尝试去弄清楚为什么会生成如此大的自动机。
@end itemize

@en As an example, consider a superscalar @acronym{RISC} machine which can
@en issue three insns (two integer insns and one floating point insn) on
@en the cycle but can finish only two insns.  To describe this, we define
@en the following functional units.
作为一个例子，考虑一个超标量@acronym{RISC}机器，
其可以在一个周期发射三条insn（两条整数insn和一条浮点insn），
但是只能完成两条insn。为了描述，我们定义下列功能单元。

@smallexample
(define_cpu_unit "i0_pipeline, i1_pipeline, f_pipeline")
(define_cpu_unit "port0, port1")
@end smallexample

@en All simple integer insns can be executed in any integer pipeline and
@en their result is ready in two cycles.  The simple integer insns are
@en issued into the first pipeline unless it is reserved, otherwise they
@en are issued into the second pipeline.  Integer division and
@en multiplication insns can be executed only in the second integer
@en pipeline and their results are ready correspondingly in 8 and 4
@en cycles.  The integer division is not pipelined, i.e.@: the subsequent
@en integer division insn can not be issued until the current division
@en insn finished.  Floating point insns are fully pipelined and their
@en results are ready in 3 cycles.  Where the result of a floating point
@en insn is used by an integer insn, an additional delay of one cycle is
@en incurred.  To describe all of this we could specify
所有简单的整数insn可以在任何整数流水线中被执行，并且结果可以在两个周期获得。
简单的整数insn将被发射到第一个流水线中，除非它被保留，
否则它们将被发射到第二个流水线中。整数除和乘insn只能在第二个整数流水线中被执行，
并且它们的结果相应的在8和4个周期获得。
整数除为非流水线，即后续的整数除insn在当前的除法insn完成前不能被发射。
浮点insn为全流水的并且它们的结果在3个周期获得。
当浮点insn的结果被整数insn使用使，将会产生一个额外的周期延迟。
要描述所有这些，我们可以指定

@smallexample
(define_cpu_unit "div")

(define_insn_reservation "simple" 2 (eq_attr "type" "int")
                         "(i0_pipeline | i1_pipeline), (port0 | port1)")

(define_insn_reservation "mult" 4 (eq_attr "type" "mult")
                         "i1_pipeline, nothing*2, (port0 | port1)")

(define_insn_reservation "div" 8 (eq_attr "type" "div")
                         "i1_pipeline, div*7, div + (port0 | port1)")

(define_insn_reservation "float" 3 (eq_attr "type" "float")
                         "f_pipeline, nothing, (port0 | port1))

(define_bypass 4 "float" "simple,mult,div")
@end smallexample

@en To simplify the description we could describe the following reservation
为了简化描述，我们可以描述下列保留

@smallexample
(define_reservation "finish" "port0|port1")
@end smallexample

@en and use it in all @code{define_insn_reservation} as in the following
@en construction
并在所有@code{define_insn_reservation}中使用，比如下面的结构

@smallexample
(define_insn_reservation "simple" 2 (eq_attr "type" "int")
                         "(i0_pipeline | i1_pipeline), finish")
@end smallexample

@end ifset
@ifset INTERNALS
@en @node Conditional Execution
@en @section Conditional Execution
@node Conditional Execution
@section 条件执行
@cindex conditional execution
@cindex predication

@en A number of architectures provide for some form of conditional
@en execution, or predication.  The hallmark of this feature is the
@en ability to nullify most of the instructions in the instruction set.
@en When the instruction set is large and not entirely symmetric, it
@en can be quite tedious to describe these forms directly in the
@en @file{.md} file.  An alternative is the @code{define_cond_exec} template.
许多体系结构都提供了某种形式的条件执行，或者predicate。其特点是能够使得
指令集中的大多数指令变为无效。当指令集很大并且不完全对称时，在
@file{.md} 文件中直接描述这些形式将会变得非常冗长。一种可替代的方式
为 @code{define_cond_exec} 模板。

@findex define_cond_exec
@smallexample
(define_cond_exec
  [@var{predicate-pattern}]
  "@var{condition}"
  "@var{output-template}")
@end smallexample

@en @var{predicate-pattern} is the condition that must be true for the
@en insn to be executed at runtime and should match a relational operator.
@en One can use @code{match_operator} to match several relational operators
@en at once.  Any @code{match_operand} operands must have no more than one
@en alternative.
@var{predicate-pattern} 为运行时执行insn所需要的必须为真的条件，并且
应该能匹配一个相关的操作符。可以使用 @code{match_operator} 来一次匹配
多个相关的操作符。任何 @code{match_operand} 操作数必须具有不超过一个
的可选项。

@en @var{condition} is a C expression that must be true for the generated
@en pattern to match.
@var{condition} 为一个C表达式，对于生成的指令模式必须匹配为真。

@findex current_insn_predicate
@en @var{output-template} is a string similar to the @code{define_insn}
@en output template (@pxref{Output Template}), except that the @samp{*}
@en and @samp{@@} special cases do not apply.  This is only useful if the
@en assembly text for the predicate is a simple prefix to the main insn.
@en In order to handle the general case, there is a global variable
@en @code{current_insn_predicate} that will contain the entire predicate
@en if the current insn is predicated, and will otherwise be @code{NULL}.
@var{output-template} 为一个类似于 @code{define_insn} 输出模板
（@pxref{Output Template}）的字符串，除了不应用 @samp{*} 和 @samp{@@}
的特殊情况。这只在针对predicate的汇编文本为一个主insn的简单前缀时有用。为了
处理通用的情况，有一个全局变量 @code{current_insn_predicate}，在当前
insn被predicate时其将包含整个predicate，否则将为 @code{NULL}。

@en When @code{define_cond_exec} is used, an implicit reference to
@en the @code{predicable} instruction attribute is made.
@en @xref{Insn Attributes}.  This attribute must be boolean (i.e.@: have
@en exactly two elements in its @var{list-of-values}).  Further, it must
@en not be used with complex expressions.  That is, the default and all
@en uses in the insns must be a simple constant, not dependent on the
@en alternative or anything else.
当使用 @code{define_cond_exec} 时，将会创建一个对 @code{predicable} 指
令属性的隐式引用。@pxref{Insn Attributes}。该属性并须为布尔的（即在它的
@var{list-of-values} 中具有确切的两个元素）。甚至，其必须不能使用复杂
表达式。也就是，insn中的缺省的和所有的使用都必须为一个简单常量，不能依
赖于可选项或其它。

@en For each @code{define_insn} for which the @code{predicable}
@en attribute is true, a new @code{define_insn} pattern will be
@en generated that matches a predicated version of the instruction.
@en For example,
对于每个 @code{predicable} 属性为真的 @code{define_insn}，一个新的匹配
一个指令predicate版本的 @code{define_insn} 指令模式将被生成。例如，

@smallexample
(define_insn "addsi"
  [(set (match_operand:SI 0 "register_operand" "r")
        (plus:SI (match_operand:SI 1 "register_operand" "r")
                 (match_operand:SI 2 "register_operand" "r")))]
  "@var{test1}"
  "add %2,%1,%0")

(define_cond_exec
  [(ne (match_operand:CC 0 "register_operand" "c")
       (const_int 0))]
  "@var{test2}"
  "(%0)")
@end smallexample

@noindent
@en generates a new pattern
生成一个新的指令模式

@smallexample
(define_insn ""
  [(cond_exec
     (ne (match_operand:CC 3 "register_operand" "c") (const_int 0))
     (set (match_operand:SI 0 "register_operand" "r")
          (plus:SI (match_operand:SI 1 "register_operand" "r")
                   (match_operand:SI 2 "register_operand" "r"))))]
  "(@var{test2}) && (@var{test1})"
  "(%3) add %2,%1,%0")
@end smallexample

@end ifset
@ifset INTERNALS
@en @node Constant Definitions
@en @section Constant Definitions
@node Constant Definitions
@section 常量定义
@cindex constant definitions
@findex define_constants

@en Using literal constants inside instruction patterns reduces legibility and
@en can be a maintenance problem.
在指令模板中使用文字常量会减小可读性并会成为一个维护问题。

@en To overcome this problem, you may use the @code{define_constants}
@en expression.  It contains a vector of name-value pairs.  From that
@en point on, wherever any of the names appears in the MD file, it is as
@en if the corresponding value had been written instead.  You may use
@en @code{define_constants} multiple times; each appearance adds more
@en constants to the table.  It is an error to redefine a constant with
@en a different value.
要克服该问题，你可以使用 @code{define_constants} 表达式。它包含了一个
“名字-值”成对向量。从定义处开始，任何出现在MD文件中的那些名字，都作为
相应的值被替换。你可以多次使用 @code{define_constants}；每次都为表格中
增加更多的常量。使用不同的值来重新定义一个常量将会产生一个错误。

@en To come back to the a29k load multiple example, instead of
回到a29k加载乘的例子，对于

@smallexample
(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI 179))
      (clobber (reg:SI 179))])]
  ""
  "loadm 0,0,%1,%2")
@end smallexample

@en You could write:
你可以写成:

@smallexample
(define_constants [
    (R_BP 177)
    (R_FC 178)
    (R_CR 179)
    (R_Q  180)
])

(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI R_CR))
      (clobber (reg:SI R_CR))])]
  ""
  "loadm 0,0,%1,%2")
@end smallexample

@en The constants that are defined with a define_constant are also output
@en in the insn-codes.h header file as #defines.
使用define_constants定义的常量也在insn-codes.h头文件中作为#defines被输出。

@cindex enumerations
@findex define_c_enum
You can also use the machine description file to define enumerations.
Like the constants defined by @code{define_constant}, these enumerations
are visible to both the machine description file and the main C code.

The syntax is as follows:

@smallexample
(define_c_enum "@var{name}" [
  @var{value0}
  @var{value1}
  @dots{}
  @var{valuen}
])
@end smallexample

This definition causes the equivalent of the following C code to appear
in @file{insn-constants.h}:

@smallexample
enum @var{name} @{
  @var{value0} = 0,
  @var{value1} = 1,
  @dots{}
  @var{valuen} = @var{n}
@};
#define NUM_@var{cname}_VALUES (@var{n} + 1)
@end smallexample

where @var{cname} is the capitalized form of @var{name}.
It also makes each @var{valuei} available in the machine description
file, just as if it had been declared with:

@smallexample
(define_constants [(@var{valuei} @var{i})])
@end smallexample

Each @var{valuei} is usually an upper-case identifier and usually
begins with @var{cname}.

You can split the enumeration definition into as many statements as
you like.  The above example is directly equivalent to:

@smallexample
(define_c_enum "@var{name}" [@var{value0}])
(define_c_enum "@var{name}" [@var{value1}])
@dots{}
(define_c_enum "@var{name}" [@var{valuen}])
@end smallexample

Splitting the enumeration helps to improve the modularity of each
individual @code{.md} file.  For example, if a port defines its
synchronization instructions in a separate @file{sync.md} file,
it is convenient to define all synchronization-specific enumeration
values in @file{sync.md} rather than in the main @file{.md} file.

Some enumeration names have special significance to GCC:

@table @code
@item unspecv
@findex unspec_volatile
If an enumeration called @code{unspecv} is defined, GCC will use it
when printing out @code{unspec_volatile} expressions.  For example:

@smallexample
(define_c_enum "unspecv" [
  UNSPECV_BLOCKAGE
])
@end smallexample

causes GCC to print @samp{(unspec_volatile @dots{} 0)} as:

@smallexample
(unspec_volatile ... UNSPECV_BLOCKAGE)
@end smallexample

@item unspec
@findex unspec
If an enumeration called @code{unspec} is defined, GCC will use
it when printing out @code{unspec} expressions.  GCC will also use
it when printing out @code{unspec_volatile} expressions unless an
@code{unspecv} enumeration is also defined.  You can therefore
decide whether to keep separate enumerations for volatile and
non-volatile expressions or whether to use the same enumeration
for both.
@end table

@findex define_enum
@anchor{define_enum}
Another way of defining an enumeration is to use @code{define_enum}:

@smallexample
(define_enum "@var{name}" [
  @var{value0}
  @var{value1}
  @dots{}
  @var{valuen}
])
@end smallexample

This directive implies:

@smallexample
(define_c_enum "@var{name}" [
  @var{cname}_@var{cvalue0}
  @var{cname}_@var{cvalue1}
  @dots{}
  @var{cname}_@var{cvaluen}
])
@end smallexample

@findex define_enum_attr
where @var{cvaluei} is the capitalized form of @var{valuei}.
However, unlike @code{define_c_enum}, the enumerations defined
by @code{define_enum} can be used in attribute specifications
(@pxref{define_enum_attr}).

@end ifset
@ifset INTERNALS
@en @node Iterators
@en @section Iterators
@node Iterators
@section 迭代器
@cindex iterators in @file{.md} files

@en Ports often need to define similar patterns for more than one machine
@en mode or for more than one rtx code.  GCC provides some simple iterator
@en facilities to make this process easier.
后端（Ports）常常需要为多个机器模式或者多个rtx代码定义类似的指令模式。GCC提供了一些简单的迭代机制使得该处理变的很容易。

@en @menu
@en * Mode Iterators::         Generating variations of patterns for different modes.
@en * Code Iterators::         Doing the same for codes.
@en @end menu
@menu
* Mode Iterators::     为不同的机器模式生成指令模式的变种
* Code Iterators::         为代码做同样的事
@end menu

@en @node Mode Iterators
@en @subsection Mode Iterators
@en @cindex mode iterators in @file{.md} files
@node Mode Iterators
@subsection 机器模式迭代器
@cindex mode iterators in @file{.md} files

@en Ports often need to define similar patterns for two or more different modes.
@en For example:
后端（Ports）经常需要为两个或多个不同机器模式定义类似的指令模式。例如：

@itemize @bullet
@item
@en If a processor has hardware support for both single and double
@en floating-point arithmetic, the @code{SFmode} patterns tend to be
@en very similar to the @code{DFmode} ones.
如果一个处理器对单浮点和双浮点算术都具有硬件支持，则 @code{SFmode} 的
指令模式将会与 @code{DFmode} 的非常类似。

@item
@en If a port uses @code{SImode} pointers in one configuration and
@en @code{DImode} pointers in another, it will usually have very similar
@en @code{SImode} and @code{DImode} patterns for manipulating pointers.
如果一个后端（port）在一个配置中使用 @code{SImode} 的指针，而在另一个
配置中使用 @code{DImode} 的指针，则通常会具有非常类似的操作指针的
@code{SImode} 和 @code{DImode} 的指令模式。
@end itemize

@en Mode iterators allow several patterns to be instantiated from one
@en @file{.md} file template.  They can be used with any type of
@en rtx-based construct, such as a @code{define_insn},
@en @code{define_split}, or @code{define_peephole2}.
机器模式迭代器允许从一个 @file{.md} 文件模板实例化多个指令模式。它们
可以用于任何类型的基于rtx的结构，例如 @code{define_insn}, 
@code{define_split} 或 @code{define_peephole2}。

@en @menu
@en * Defining Mode Iterators:: Defining a new mode iterator.
@en * Substitutions::           Combining mode iterators with substitutions
@en * Examples::                Examples
@en @end menu
@menu
* Defining Mode Iterators:: 定义一个新的机器模式迭代器
* Substitutions::               使用替换来合成机器模式迭代器
* Examples::               例子
@end menu

@en @node Defining Mode Iterators
@en @subsubsection Defining Mode Iterators
@node Defining Mode Iterators
@subsubsection 定义机器模式迭代器
@findex define_mode_iterator

@en The syntax for defining a mode iterator is:
定义一个机器模式迭代器的语法为：

@smallexample
(define_mode_iterator @var{name} [(@var{mode1} "@var{cond1}") @dots{} (@var{moden} "@var{condn}")])
@end smallexample

@en This allows subsequent @file{.md} file constructs to use the mode suffix
@en @code{:@var{name}}.  Every construct that does so will be expanded
@en @var{n} times, once with every use of @code{:@var{name}} replaced by
@en @code{:@var{mode1}}, once with every use replaced by @code{:@var{mode2}},
@en and so on.  In the expansion for a particular @var{modei}, every
@en C condition will also require that @var{condi} be true.
这将允许后续的 @file{.md} 文件结构可以使用机器模式suffix 
@code{:@var{name}}。每个这样的结构将被扩展 @var{n} 次，一次使用
@code{:@var{mode1}} 来替换，一次使用 @code{:@var{mode2}} 来替换，等等。
在扩展 @var{modei} 时，每个C条件 @var{condi} 还要为真。

@en For example:
例如：

@smallexample
(define_mode_iterator P [(SI "Pmode == SImode") (DI "Pmode == DImode")])
@end smallexample

@en defines a new mode suffix @code{:P}.  Every construct that uses
@en @code{:P} will be expanded twice, once with every @code{:P} replaced
@en by @code{:SI} and once with every @code{:P} replaced by @code{:DI}.
@en The @code{:SI} version will only apply if @code{Pmode == SImode} and
@en the @code{:DI} version will only apply if @code{Pmode == DImode}.
定义了一个新的机器模式后缀 @code{:P}。每个使用 @code{:P} 的结构将被扩展两次，一次由 @code{:SI} 来替换 @code{:P}，一次由 @code{:DI} 来替换@code{:P}。其中 @code{:SI} 版本的只有当 @code{Pmode == SImode} 时才被应用，@code{:DI} 版本的只有当 @code{Pmode == DImode} 时才被应用。

@en As with other @file{.md} conditions, an empty string is treated
@en as ``always true''.  @code{(@var{mode} "")} can also be abbreviated
@en to @code{@var{mode}}.  For example:
就像其它 @file{.md} 条件，一个空字符串被当作“总为真”。@code{(@var{mode} "")}
也可以被缩写为 @code{@var{mode}}。例如：

@smallexample
(define_mode_iterator GPR [SI (DI "TARGET_64BIT")])
@end smallexample

@en means that the @code{:DI} expansion only applies if @code{TARGET_64BIT}
@en but that the @code{:SI} expansion has no such constraint.
意味着 @code{:DI} 扩展只有为 @code{TARGET_64BIT} 时被应用，但 @code{:SI} 
扩展却没有这样的限制。

@en Iterators are applied in the order they are defined.  This can be
@en significant if two iterators are used in a construct that requires
@en substitutions.  @xref{Substitutions}.
迭代器按照它们定义的顺序被应用。这在当两个迭代器用于一个结构中需要替换时
会变的很重要。@xref{Substitutions}。

@en @node Substitutions
@en @subsubsection Substitution in Mode Iterators
@en @findex define_mode_attr
@node Substitutions
@subsubsection 机器模式迭代器中的替换
@findex define_mode_attr
@en If an @file{.md} file construct uses mode iterators, each version of the
@en construct will often need slightly different strings or modes.  For
@en example:
如果一个 @file{.md} 文件结构使用了机器模式迭代器，则结构的每个版本将通常
需要轻微不同的字符串或机器模式。例如：

@itemize @bullet
@item
@en When a @code{define_expand} defines several @code{add@var{m}3} patterns
@en (@pxref{Standard Names}), each expander will need to use the
@en appropriate mode name for @var{m}.
当一个 @code{define_expand} 定义了多个 @code{add@var{m}3} 指令模式时
（@pxref{Standard Names}），每个扩展将需要针对 @var{m} 的适当的机器模式。

@item
@en When a @code{define_insn} defines several instruction patterns,
@en each instruction will often use a different assembler mnemonic.
当一个 @code{define_insn} 定义了多个指令模式时，每条指令将通常需要一个不
同的汇编助记符。

@item
@en When a @code{define_insn} requires operands with different modes,
@en using an iterator for one of the operand modes usually requires a specific
@en mode for the other operand(s).
当一个 @code{define_insn} 需要操作数具有不同的机器模式时，针对一个操作数
的机器模式使用迭代器通常需要对于其它操作数使用特点的机器模式。
@end itemize

@en GCC supports such variations through a system of ``mode attributes''.
@en There are two standard attributes: @code{mode}, which is the name of
@en the mode in lower case, and @code{MODE}, which is the same thing in
@en upper case.  You can define other attributes using:
GCC通过“机器模式属性”系统来支持这样的变种。有两种标准属性：@code{mode}，
其为机器模式的小写名字，@code{MODE}，其为机器模式的大写名字。你可以定义其
它属性，使用：

@smallexample
(define_mode_attr @var{name} [(@var{mode1} "@var{value1}") @dots{} (@var{moden} "@var{valuen}")])
@end smallexample

@en where @var{name} is the name of the attribute and @var{valuei}
@en is the value associated with @var{modei}.
其中 @var{name} 为属性的名字，@var{valuei} 为与 @var{modei} 关联的值。

@en When GCC replaces some @var{:iterator} with @var{:mode}, it will scan
@en each string and mode in the pattern for sequences of the form
@en @code{<@var{iterator}:@var{attr}>}, where @var{attr} is the name of a
@en mode attribute.  If the attribute is defined for @var{mode}, the whole
@en @code{<@dots{}>} sequence will be replaced by the appropriate attribute
@en value.
当GCC使用 @var{:mode} 来替换某个 @var{:iterator} 时，其将扫描指令模式中的
每个字符串和机器模式，按照 @code{<@var{iterator}:@var{attr}>}形式的序列，
其中@var{attr}为一个机器模式属性的名字。如果属性针对mode被定义，则整个
@code{<@dots{}>} 序列将被适当的属性值替换。

@en For example, suppose an @file{.md} file has:
例如，假设一个 @file{.md} 具有：

@smallexample
(define_mode_iterator P [(SI "Pmode == SImode") (DI "Pmode == DImode")])
(define_mode_attr load [(SI "lw") (DI "ld")])
@end smallexample

@en If one of the patterns that uses @code{:P} contains the string
@en @code{"<P:load>\t%0,%1"}, the @code{SI} version of that pattern
@en will use @code{"lw\t%0,%1"} and the @code{DI} version will use
@en @code{"ld\t%0,%1"}.
如果其中一个使用 @code{:P} 的指令模式包含了字符串
@code{"<P:load>\t%0,%1"}，则 @code{SI} 版本的指令模式将使用
@code{"lw\t%0,%1"} 并且 @code{DI} 版本的将使用
@code{"ld\t%0,%1"}。

@en Here is an example of using an attribute for a mode:
这里有一个关于使用针对一个机器模式的属性的例子：

@smallexample
(define_mode_iterator LONG [SI DI])
(define_mode_attr SHORT [(SI "HI") (DI "SI")])
(define_insn @dots{}
  (sign_extend:LONG (match_operand:<LONG:SHORT> @dots{})) @dots{})
@end smallexample

@en The @code{@var{iterator}:} prefix may be omitted, in which case the
@en substitution will be attempted for every iterator expansion.
@code{@var{iterator}:} 前缀可以被省略掉，这种情况下将会针对每个迭代器扩展来
尝试替换。

@en @node Examples
@en @subsubsection Mode Iterator Examples
@node Examples
@subsubsection 有关机器模式迭代器的例子
@en Here is an example from the MIPS port.  It defines the following
@en modes and attributes (among others):
这里有一个来自MIPS后端的一个例子。其定义了下列机器模式和属性（除了别的以外）：

@en @smallexample
@en (define_mode_iterator GPR [SI (DI "TARGET_64BIT")])
@en (define_mode_attr d [(SI "") (DI "d")])
@en @end smallexample
@smallexample
(define_mode_iterator GPR [SI (DI "TARGET_64BIT")])
(define_mode_attr d [(SI "") (DI "d")])
@end smallexample

@en and uses the following template to define both @code{subsi3}
@en and @code{subdi3}:
并且使用下列模板来同时定义 @code{subsi3} 和 @code{subdi3}：

@smallexample
(define_insn "sub<mode>3"
  [(set (match_operand:GPR 0 "register_operand" "=d")
        (minus:GPR (match_operand:GPR 1 "register_operand" "d")
                   (match_operand:GPR 2 "register_operand" "d")))]
  ""
  "<d>subu\t%0,%1,%2"
  [(set_attr "type" "arith")
   (set_attr "mode" "<MODE>")])
@end smallexample

@en This is exactly equivalent to:
这就完全等价于：

@smallexample
(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (minus:SI (match_operand:SI 1 "register_operand" "d")
                  (match_operand:SI 2 "register_operand" "d")))]
  ""
  "subu\t%0,%1,%2"
  [(set_attr "type" "arith")
   (set_attr "mode" "SI")])

(define_insn "subdi3"
  [(set (match_operand:DI 0 "register_operand" "=d")
        (minus:DI (match_operand:DI 1 "register_operand" "d")
                  (match_operand:DI 2 "register_operand" "d")))]
  ""
  "dsubu\t%0,%1,%2"
  [(set_attr "type" "arith")
   (set_attr "mode" "DI")])
@end smallexample

@en @node Code Iterators
@en @subsection Code Iterators
@node Code Iterators
@subsection 代码迭代器
@cindex code iterators in @file{.md} files
@findex define_code_iterator
@findex define_code_attr
@en Code iterators operate in a similar way to mode iterators.  @xref{Mode Iterators}.
代码迭代器使用与机器模式迭代器类似的方法来操作。@xref{Mode Iterators}。

@en The construct:
结构：

@smallexample
(define_code_iterator @var{name} [(@var{code1} "@var{cond1}") @dots{} (@var{coden} "@var{condn}")])
@end smallexample

@en defines a pseudo rtx code @var{name} that can be instantiated as
@en @var{codei} if condition @var{condi} is true.  Each @var{codei}
@en must have the same rtx format.  @xref{RTL Classes}.
定义了一个伪rtx代码 @var{name}，如果条件 @var{condi} 为真时，其可以作为
@var{codei} 被实例化。每个 @var{codei} 必须具有相同的rtx格式。
@xref{RTL Classes}。

@en As with mode iterators, each pattern that uses @var{name} will be
@en expanded @var{n} times, once with all uses of @var{name} replaced by
@en @var{code1}, once with all uses replaced by @var{code2}, and so on.
@en @xref{Defining Mode Iterators}.
跟机器模式迭代器一样，每个使用 @var{name} 的指令模式将被扩展 @var{n} 次，
一次使用 @var{code1} 来替换，一次使用 @var{code2}，等等。
@xref{Defining Mode Iterators}。

@en It is possible to define attributes for codes as well as for modes.
@en There are two standard code attributes: @code{code}, the name of the
@en code in lower case, and @code{CODE}, the name of the code in upper case.
@en Other attributes are defined using:
跟机器模式一样可以为代码定义属性。有两种标准代码属性：@code{code}，代码
的小写形式名字，以及 @code{CODE}，代码的大写形式名字。其它属性使用下列
方式来定义：

@smallexample
(define_code_attr @var{name} [(@var{code1} "@var{value1}") @dots{} (@var{coden} "@var{valuen}")])
@end smallexample

@en Here's an example of code iterators in action, taken from the MIPS port:
这里有一个实际使用的关于代码迭代器的例子，摘自MIPS后端（port）：

@smallexample
(define_code_iterator any_cond [unordered ordered unlt unge uneq ltgt unle ungt
                                eq ne gt ge lt le gtu geu ltu leu])

(define_expand "b<code>"
  [(set (pc)
        (if_then_else (any_cond:CC (cc0)
                                   (const_int 0))
                      (label_ref (match_operand 0 ""))
                      (pc)))]
  ""
@{
  gen_conditional_branch (operands, <CODE>);
  DONE;
@})
@end smallexample

@en This is equivalent to:
这等价于：

@smallexample
(define_expand "bunordered"
  [(set (pc)
        (if_then_else (unordered:CC (cc0)
                                    (const_int 0))
                      (label_ref (match_operand 0 ""))
                      (pc)))]
  ""
@{
  gen_conditional_branch (operands, UNORDERED);
  DONE;
@})

(define_expand "bordered"
  [(set (pc)
        (if_then_else (ordered:CC (cc0)
                                  (const_int 0))
                      (label_ref (match_operand 0 ""))
                      (pc)))]
  ""
@{
  gen_conditional_branch (operands, ORDERED);
  DONE;
@})

@dots{}
@end smallexample

@end ifset
