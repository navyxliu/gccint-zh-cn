@c Copyright (C) 2001, 2002, 2004, 2008 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node Configure Terms
@section 配置术语及其历史
@cindex configure terms
@cindex canadian

GCC的配置和构建过程有一个丰富多彩的历史，以至于不了解的人可能会为目前使用的方法所迷惑。
尽管有专门的文档描述了配置过程的细节，这里还是要说一些和GCC打交道的人必知必会的知识。

构建过程涉及三个系统的名字：(@dfn{build})是指你构建GCC的系统；
(@dfn{host})是指你安装GCC的系统；而(@dfn{target})是构建出来的GCC生成的代码运行的系统。
用选项@option{--build=}、@option{--host=}、@option{--target=}来配置GCC。

应该避免指定 host 而不指定 build 的情况，@command{configure} 可能会假定
host 的值和 build 一样，这可能导致错误，而且以前也确实出现过。

如果 build、host、target 是一样的，这样的编译器称为本地编译器（@dfn{native}）。
如果 build 和 host 是一样的，target 不一样，这样的编译器称为交叉编译器（@dfn{cross}）。
如果 build、host、target 都不一样，这样的编译器称为@dfn{canadian}。
(for obscure reasons dealing with Canada's political party and 
the background of the person working on the build at that time)。
如果 host 和 target 是相同的，而 build 不同，你就是在用一个交叉编译器为另一个系统编译一个本地编译器。
有人称之为@dfn{host-x-host},@dfn{crossed native}, 或@dfn{cross-built native}。
如果 build 和 target 相同，但是 host 不同，
你就是在用一个交叉编译器编译另一个交叉编译器，
这个交叉编译器为你正在构建GCC使用的系统生成代码。
这种情况很少见，没有统一的方法描述，或许你可以称它为@dfn{crossback}。

如果 build 和 host 相同，构建出来的GCC会被用来编译目标库（target libraries），
例如@code{libstdc++}.如果 build 和 host 不同，则需要预先准备一个交叉编译器
来构建目标库。（如果你指定了选项@option{--target=foo-bar}，那么编译器会调用
@command{foo-bar-gcc}来构建。）

构造目标库的时候，你是在为@option{--target}指定的机器构建系统。所以 build 指的是
你正在构建的系统（跟构建GCC一样），host 是你构建的目标系统（目标库是为了 target 构建的，
所以这里的 host 就是你指定的 target），而 target 没有用到（因为现在是在构建库
而不是构建编译器）。configure/make过程会根据需要调整这些变量，并在必要的时候设置
@code{$with_cross_host}为初始的@option{--host}值，以备不时之需。

@code{libiberty}支持库会被构建三次：host 一次，target 一次（即使 host 和
 target 是一样的），如果 build 和 host 不同，那么在 build 上还要构建一次。
这使得在构建过程中的每一个程序都可以使用这个库。
