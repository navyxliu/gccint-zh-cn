<html lang="zh">
<head>
<title>Function Basics - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Functions.html#Functions" title="Functions">
<link rel="next" href="Function-Properties.html#Function-Properties" title="Function Properties">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Function-Basics"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Function-Properties.html#Function-Properties">Function Properties</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Functions.html#Functions">Functions</a>
<hr>
</div>

<h4 class="subsection">11.8.1 函数基础</h4>

<p><a name="index-DECL_005fNAME-2548"></a><a name="index-DECL_005fASSEMBLER_005fNAME-2549"></a><a name="index-TREE_005fPUBLIC-2550"></a><a name="index-DECL_005fARTIFICIAL-2551"></a><a name="index-DECL_005fFUNCTION_005fSPECIFIC_005fTARGET-2552"></a><a name="index-DECL_005fFUNCTION_005fSPECIFIC_005fOPTIMIZATION-2553"></a>
<!-- A function has four core parts: the name, the parameters, the result, -->
<!-- and the body.  The following macros and functions access these parts -->
<!-- of a @code{FUNCTION_DECL} as well as other basic features: -->
函数具有四个核心部分：名字，参数，结果和函数体。下列宏和函数用来访问一个<code>FUNCTION_DECL</code>的这些部分，以及其它基本特性：
     <dl>
<dt><code>DECL_NAME</code><a name="index-DECL_005fNAME-2554"></a><dd><!-- This macro returns the unqualified name of the function, as an -->
<!-- @code{IDENTIFIER_NODE}.  For an instantiation of a function template, -->
<!-- the @code{DECL_NAME} is the unqualified name of the template, not -->
<!-- something like @code{f<int>}.  The value of @code{DECL_NAME} is -->
<!-- undefined when used on a constructor, destructor, overloaded operator, -->
<!-- or type-conversion operator, or any function that is implicitly -->
<!-- generated by the compiler.  See below for macros that can be used to -->
<!-- distinguish these cases. -->
该宏返回函数未限定的名字，为一个<code>IDENTIFIER_NODE</code>。
对于一个函数模版的实例，<code>DECL_NAME</code>为模版的未限定名字，
而不是类似<code>f&lt;int&gt;</code>的东西。当用在编译器隐式生成的构造函数，
析构函数，重载操作符，或者类型转换符，或者任何函数时，
<code>DECL_NAME</code>的值未定义。关于可以用来区分这些情况的宏，参见下面。

     <br><dt><code>DECL_ASSEMBLER_NAME</code><a name="index-DECL_005fASSEMBLER_005fNAME-2555"></a><dd><!-- This macro returns the mangled name of the function, also an -->
<!-- @code{IDENTIFIER_NODE}.  This name does not contain leading underscores -->
<!-- on systems that prefix all identifiers with underscores.  The mangled -->
<!-- name is computed in the same way on all platforms; if special processing -->
<!-- is required to deal with the object file format used on a particular -->
<!-- platform, it is the responsibility of the back end to perform those -->
<!-- modifications.  (Of course, the back end should not modify -->
<!-- @code{DECL_ASSEMBLER_NAME} itself.) -->
该宏返回函数的mangled名字，也是一个<code>IDENTIFIER_NODE</code>。该名字没有包含前导的下划线。mangled名字在所有平台上按照相同的方式来计算；如果在特定的平台上，需要对目标文件格式进行特殊的处理，则后端需要负责执行那些修改。（当然，后端不应该修改<code>DECL_ASSEMBLER_NAME</code>）

     <!-- Using @code{DECL_ASSEMBLER_NAME} will cause additional memory to be -->
     <!-- allocated (for the mangled name of the entity) so it should be used -->
     <!-- only when emitting assembly code.  It should not be used within the -->
     <!-- optimizers to determine whether or not two declarations are the same, -->
     <!-- even though some of the existing optimizers do use it in that way. -->
     <!-- These uses will be removed over time. -->
     <p>使用<code>DECL_ASSEMBLER_NAME</code>将使得额外的内存被分配（用于实体的mangled名字），所以其应该只当生成汇编代码时被使用。其不应该在优化器中被使用，用于确定两个声明是否相同，即使一些现有的优化器确实采用了这种方式。这些使用将随着时间被移除。

     <br><dt><code>DECL_ARGUMENTS</code><a name="index-DECL_005fARGUMENTS-2556"></a><dd><!-- This macro returns the @code{PARM_DECL} for the first argument to the -->
<!-- function.  Subsequent @code{PARM_DECL} nodes can be obtained by -->
<!-- following the @code{TREE_CHAIN} links. -->
该宏返回函数第一个参数的<code>PARM_DECL</code>。后续的<code>PARM_DECL</code>节点可以通过<code>TREE_CHAIN</code>来获得。

     <br><dt><code>DECL_RESULT</code><a name="index-DECL_005fRESULT-2557"></a><dd><!-- This macro returns the @code{RESULT_DECL} for the function. -->
该函数返回函数的<code>RESULT_DECL</code>。

     <br><dt><code>DECL_SAVED_TREE</code><a name="index-DECL_005fSAVED_005fTREE-2558"></a><dd><!-- This macro returns the complete body of the function. -->
该宏返回整个函数体。

     <br><dt><code>TREE_TYPE</code><a name="index-TREE_005fTYPE-2559"></a><dd><!-- This macro returns the @code{FUNCTION_TYPE} or @code{METHOD_TYPE} for -->
<!-- the function. -->
该宏返回函数的<code>FUNCTION_TYPE</code>或<code>METHOD_TYPE</code>。

     <br><dt><code>DECL_INITIAL</code><a name="index-DECL_005fINITIAL-2560"></a><dd><!-- A function that has a definition in the current translation unit will -->
<!-- have a non-@code{NULL} @code{DECL_INITIAL}.  However, back ends should not make -->
<!-- use of the particular value given by @code{DECL_INITIAL}. -->
在当前转换单元中定义的函数将会有一个非<code>NULL</code>的<code>DECL_INITIAL</code>。但是，后端不应该使用<code>DECL_INITIAL</code>给出的该特定值。

     <p>It should contain a tree of <code>BLOCK</code> nodes that mirrors the scopes
that variables are bound in the function.  Each block contains a list
of decls declared in a basic block, a pointer to a chain of blocks at
the next lower scope level, then a pointer to the next block at the
same level and a backpointer to the parent <code>BLOCK</code> or
<code>FUNCTION_DECL</code>.  So given a function as follows:

     <pre class="smallexample">          void foo()
          {
            int a;
            {
              int b;
            }
            int c;
          }
</pre>
     <p>you would get the following:

     <pre class="smallexample">          tree foo = FUNCTION_DECL;
          tree decl_a = VAR_DECL;
          tree decl_b = VAR_DECL;
          tree decl_c = VAR_DECL;
          tree block_a = BLOCK;
          tree block_b = BLOCK;
          tree block_c = BLOCK;
          BLOCK_VARS(block_a) = decl_a;
          BLOCK_SUBBLOCKS(block_a) = block_b;
          BLOCK_CHAIN(block_a) = block_c;
          BLOCK_SUPERCONTEXT(block_a) = foo;
          BLOCK_VARS(block_b) = decl_b;
          BLOCK_SUPERCONTEXT(block_b) = block_a;
          BLOCK_VARS(block_c) = decl_c;
          BLOCK_SUPERCONTEXT(block_c) = foo;
          DECL_INITIAL(foo) = block_a;
</pre>
     </dl>

<!--  -->
<!-- Function Properties -->
<!--  -->
<!-- @node Function Properties -->
<!-- @subsection Function Properties -->
 </body></html>

