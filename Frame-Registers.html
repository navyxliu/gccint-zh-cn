<html lang="zh">
<head>
<title>Frame Registers - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="prev" href="Stack-Checking.html#Stack-Checking" title="Stack Checking">
<link rel="next" href="Elimination.html#Elimination" title="Elimination">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Frame-Registers"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Elimination.html#Elimination">Elimination</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Stack-Checking.html#Stack-Checking">Stack Checking</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>
<hr>
</div>

<h4 class="subsection">17.10.4 用于栈帧寻址的寄存器</h4>

<!-- prevent bad page break with this line -->
<!-- This discusses registers that address the stack frame. -->
<p>这里讨论了用于栈帧寻址的寄存器。

<div class="defun">
&mdash; Macro: <b>STACK_POINTER_REGNUM</b><var><a name="index-STACK_005fPOINTER_005fREGNUM-4094"></a></var><br>
<blockquote><!-- The register number of the stack pointer register, which must also be a -->
     <!-- fixed register according to @code{FIXED_REGISTERS}.  On most machines, -->
     <!-- the hardware determines which register this is. -->
      <p>栈指针寄存器的寄存器编号，其还必须为一个<code>FIXED_REGISTERS</code>中的固定寄存器。在大多数机器上，硬件决定了这是哪个寄存器。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FRAME_POINTER_REGNUM</b><var><a name="index-FRAME_005fPOINTER_005fREGNUM-4095"></a></var><br>
<blockquote><!-- The register number of the frame pointer register, which is used to -->
     <!-- access automatic variables in the stack frame.  On some machines, the -->
     <!-- hardware determines which register this is.  On other machines, you can -->
     <!-- choose any register you wish for this purpose. -->
      <p>帧指针寄存器的寄存器编号，其用于访问在栈帧中的自动变量。在一些机器上，硬件决定了这是哪个寄存器。在其它机器上，你可以选择任意寄存器来达到该目的。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_FRAME_POINTER_REGNUM</b><var><a name="index-HARD_005fFRAME_005fPOINTER_005fREGNUM-4096"></a></var><br>
<blockquote><!-- On some machines the offset between the frame pointer and starting -->
     <!-- offset of the automatic variables is not known until after register -->
     <!-- allocation has been done (for example, because the saved registers are -->
     <!-- between these two locations).  On those machines, define -->
     <!-- @code{FRAME_POINTER_REGNUM} the number of a special, fixed register to -->
     <!-- be used internally until the offset is known, and define -->
     <!-- @code{HARD_FRAME_POINTER_REGNUM} to be the actual hard register number -->
     <!-- used for the frame pointer. -->
      <p>在一些机器上，帧指针和自动变量的起始处之间的偏移量直到寄存器分配进行完之后才知道（例如，因为保存寄存器位于这两个位置之间）。这些机器上，定义<code>FRAME_POINTER_REGNUM</code>为一个特定的固定寄存器的编号，在内部使用，直到位移已知，并且定义<code>HARD_FRAME_POINTER_REGNUM</code>为实际的硬件寄存器，用于帧指针。

     <!-- You should define this macro only in the very rare circumstances when it -->
     <!-- is not possible to calculate the offset between the frame pointer and -->
     <!-- the automatic variables until after register allocation has been -->
     <!-- completed.  When this macro is defined, you must also indicate in your -->
     <!-- definition of @code{ELIMINABLE_REGS} how to eliminate -->
     <!-- @code{FRAME_POINTER_REGNUM} into either @code{HARD_FRAME_POINTER_REGNUM} -->
     <!-- or @code{STACK_POINTER_REGNUM}. -->
      <p>你只需要在非常少见的情况下定义该宏，当不可能计算帧指针和自动变量的偏移时，并且直到寄存器分配完成。当该宏被定义，你必须还要在你的<code>ELIMINABLE_REGS</code>的定义中指示如果消除<code>FRAME_POINTER_REGNUM</code>为<code>HARD_FRAME_POINTER_REGNUM</code>或者<code>STACK_POINTER_REGNUM</code>。

     <!-- Do not define this macro if it would be the same as -->
     <!-- @code{FRAME_POINTER_REGNUM}. -->
      <p>如果其与<code>FRAME_POINTER_REGNUM</code>相同，则不要定义该宏。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>ARG_POINTER_REGNUM</b><var><a name="index-ARG_005fPOINTER_005fREGNUM-4097"></a></var><br>
<blockquote><!-- The register number of the arg pointer register, which is used to access -->
     <!-- the function's argument list.  On some machines, this is the same as the -->
     <!-- frame pointer register.  On some machines, the hardware determines which -->
     <!-- register this is.  On other machines, you can choose any register you -->
     <!-- wish for this purpose.  If this is not the same register as the frame -->
     <!-- pointer register, then you must mark it as a fixed register according to -->
     <!-- @code{FIXED_REGISTERS}, or arrange to be able to eliminate it -->
     <!-- (@pxref{Elimination}). -->
      <p>arg指针寄存器的寄存器编号，其用于访问函数的参数列表。在大多数机器上，这与帧指针寄存器相同。在一些机器上，硬件决定了其为那个寄存器。在其它机器上，你可以选择任意的寄存器。如果这与帧指针寄存器不同，则你必须标记其为一个固定寄存器，根据<code>FIXED_REGISTERS</code>或者设法能够消除它(参见<a href="Elimination.html#Elimination">Elimination</a>)。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_FRAME_POINTER_IS_FRAME_POINTER</b><var><a name="index-HARD_005fFRAME_005fPOINTER_005fIS_005fFRAME_005fPOINTER-4098"></a></var><br>
<blockquote><p>Define this to a preprocessor constant that is nonzero if
<code>hard_frame_pointer_rtx</code> and <code>frame_pointer_rtx</code> should be
the same.  The default definition is &lsquo;<samp><span class="samp">(HARD_FRAME_POINTER_REGNUM
== FRAME_POINTER_REGNUM)</span></samp>&rsquo;; you only need to define this macro if that
definition is not suitable for use in preprocessor conditionals. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_FRAME_POINTER_IS_ARG_POINTER</b><var><a name="index-HARD_005fFRAME_005fPOINTER_005fIS_005fARG_005fPOINTER-4099"></a></var><br>
<blockquote><p>Define this to a preprocessor constant that is nonzero if
<code>hard_frame_pointer_rtx</code> and <code>arg_pointer_rtx</code> should be the
same.  The default definition is &lsquo;<samp><span class="samp">(HARD_FRAME_POINTER_REGNUM ==
ARG_POINTER_REGNUM)</span></samp>&rsquo;; you only need to define this macro if that
definition is not suitable for use in preprocessor conditionals. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>RETURN_ADDRESS_POINTER_REGNUM</b><var><a name="index-RETURN_005fADDRESS_005fPOINTER_005fREGNUM-4100"></a></var><br>
<blockquote><!-- The register number of the return address pointer register, which is used to -->
     <!-- access the current function's return address from the stack.  On some -->
     <!-- machines, the return address is not at a fixed offset from the frame -->
     <!-- pointer or stack pointer or argument pointer.  This register can be defined -->
     <!-- to point to the return address on the stack, and then be converted by -->
     <!-- @code{ELIMINABLE_REGS} into either the frame pointer or stack pointer. -->
      <p>返回地址指针寄存器的寄存器编号，其用于访问栈中当前函数的返回地址。在一些机器上，返回地址不在帧指针或栈指针或参数指针的固定偏移处。该寄存器被定义指向栈中的返回地址，并且然后通过<code>ELIMINABLE_REGS</code>转换为帧指针或者栈指针。

     <!-- Do not define this macro unless there is no other way to get the return -->
     <!-- address from the stack. -->
      <p>不要定义该宏，除非没有其他的方式从栈中获得返回地址。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STATIC_CHAIN_REGNUM</b><var><a name="index-STATIC_005fCHAIN_005fREGNUM-4101"></a></var><br>
&mdash; Macro: <b>STATIC_CHAIN_INCOMING_REGNUM</b><var><a name="index-STATIC_005fCHAIN_005fINCOMING_005fREGNUM-4102"></a></var><br>
<blockquote><!-- Register numbers used for passing a function's static chain pointer.  If -->
     <!-- register windows are used, the register number as seen by the called -->
     <!-- function is @code{STATIC_CHAIN_INCOMING_REGNUM}, while the register -->
     <!-- number as seen by the calling function is @code{STATIC_CHAIN_REGNUM}.  If -->
     <!-- these registers are the same, @code{STATIC_CHAIN_INCOMING_REGNUM} need -->
     <!-- not be defined. -->
      <p>用于传递函数static链指针的寄存器编号。如果寄存器窗口被使用，则寄存器编号由被调用函数所看到是<code>STATIC_CHAIN_INCOMING_REGNUM</code>，而由调用者函数看到的是<code>STATIC_CHAIN_REGNUM</code>。如果这些寄存器是相同的，则不需要定义<code>STATIC_CHAIN_INCOMING_REGNUM</code>。

     <!-- The static chain register need not be a fixed register. -->
      <p>静态链寄存器不需要为一个固定寄存器。

     <!-- If the static chain is passed in memory, these macros should not be -->
     <!-- defined; instead, the @code{TARGET_STATIC_CHAIN} hook should be used. -->
      <p>如果静态链在内存中传递，则这些宏不需要定义；替代的，应该定义下面的两个宏。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: rtx <b>TARGET_STATIC_CHAIN</b> (<var>const_tree fndecl, bool incoming_p</var>)<var><a name="index-TARGET_005fSTATIC_005fCHAIN-4103"></a></var><br>
<blockquote><p>This hook replaces the use of <code>STATIC_CHAIN_REGNUM</code> et al for
targets that may use different static chain locations for different
nested functions.  This may be required if the target has function
attributes that affect the calling conventions of the function and
those calling conventions use different static chain locations.

      <p>The default version of this hook uses <code>STATIC_CHAIN_REGNUM</code> et al.

      <p>If the static chain is passed in memory, this hook should be used to
provide rtx giving <code>mem</code> expressions that denote where they are stored. 
Often the <code>mem</code> expression as seen by the caller will be at an offset
from the stack pointer and the <code>mem</code> expression as seen by the callee
will be at an offset from the frame pointer. 
<a name="index-stack_005fpointer_005frtx-4104"></a><a name="index-frame_005fpointer_005frtx-4105"></a><a name="index-arg_005fpointer_005frtx-4106"></a><!-- The variables @code{stack_pointer_rtx}, @code{frame_pointer_rtx}, and -->
<!-- @code{arg_pointer_rtx} will have been initialized and should be used -->
<!-- to refer to those items. -->
变量<code>stack_pointer_rtx</code>, <code>frame_pointer_rtx</code>和<code>arg_pointer_rtx</code>将在使用这些宏之前被初始化，并可以引用。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF_FRAME_REGISTERS</b><var><a name="index-DWARF_005fFRAME_005fREGISTERS-4107"></a></var><br>
<blockquote><!-- This macro specifies the maximum number of hard registers that can be -->
     <!-- saved in a call frame.  This is used to size data structures used in -->
     <!-- DWARF2 exception handling. -->
      <p>该宏指定了可以在一个调用帧中被保存的硬件寄存器的最大数。这用于DWARF2异常处理中的size数据结构体。

     <!-- Prior to GCC 3.0, this macro was needed in order to establish a stable -->
     <!-- exception handling ABI in the face of adding new hard registers for ISA -->
     <!-- extensions.  In GCC 3.0 and later, the EH ABI is insulated from changes -->
     <!-- in the number of hard registers.  Nevertheless, this macro can still be -->
     <!-- used to reduce the runtime memory requirements of the exception handling -->
     <!-- routines, which can be substantial if the ISA contains a lot of -->
     <!-- registers that are not call-saved. -->
      <p>在GCC3.0之前，该宏需要用来建立一个稳定的异常处理ABI。

     <!-- If this macro is not defined, it defaults to -->
     <!-- @code{FIRST_PSEUDO_REGISTER}. -->
      <p>如果该宏没有被定义，其缺省为<code>FIRST_PSEUDO_REGISTER</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PRE_GCC3_DWARF_FRAME_REGISTERS</b><var><a name="index-PRE_005fGCC3_005fDWARF_005fFRAME_005fREGISTERS-4108"></a></var><br>
<blockquote><!-- This macro is similar to @code{DWARF_FRAME_REGISTERS}, but is provided -->
     <!-- for backward compatibility in pre GCC 3.0 compiled code. -->
      <p>该宏类似于<code>DWARF_FRAME_REGISTERS</code>，是为了向后兼容在GCC3.0之前编译的代码而提供。

     <!-- If this macro is not defined, it defaults to -->
     <!-- @code{DWARF_FRAME_REGISTERS}. -->
      <p>如果没有定义该宏，其缺省为<code>DWARF_FRAME_REGISTERS</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF_REG_TO_UNWIND_COLUMN</b> (<var>regno</var>)<var><a name="index-DWARF_005fREG_005fTO_005fUNWIND_005fCOLUMN-4109"></a></var><br>
<blockquote><!-- Define this macro if the target's representation for dwarf registers -->
     <!-- is different than the internal representation for unwind column. -->
     <!-- Given a dwarf register, this macro should return the internal unwind -->
     <!-- column number to use instead. -->
      <p>定义该宏，如果target对于dwarf寄存器的表示与对于unwind column的内部表示不相同。给定一个dwarf寄存器，该宏应该返回替代使用的内部unwind column编号。

     <!-- See the PowerPC's SPE target for an example. -->
      <p>例子参见PowerPC's SPE target。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF_FRAME_REGNUM</b> (<var>regno</var>)<var><a name="index-DWARF_005fFRAME_005fREGNUM-4110"></a></var><br>
<blockquote><!-- Define this macro if the target's representation for dwarf registers -->
     <!-- used in .eh_frame or .debug_frame is different from that used in other -->
     <!-- debug info sections.  Given a GCC hard register number, this macro -->
     <!-- should return the .eh_frame register number.  The default is -->
     <!-- @code{DBX_REGISTER_NUMBER (@var{regno})}. -->
      <p>定义该宏，如果target对于用在.eh_frame或者.debug_frame的dwarf寄存器的表示与用在其它调试信息section中的不同。给定一个GCC硬件寄存器编号，该宏应该返回.eh_frame寄存器编号。缺省为<code>DBX_REGISTER_NUMBER (</code><var>regno</var><code>)</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>DWARF2_FRAME_REG_OUT</b> (<var>regno, for_eh</var>)<var><a name="index-DWARF2_005fFRAME_005fREG_005fOUT-4111"></a></var><br>
<blockquote><!-- Define this macro to map register numbers held in the call frame info -->
     <!-- that GCC has collected using @code{DWARF_FRAME_REGNUM} to those that -->
     <!-- should be output in .debug_frame (@code{@var{for_eh}} is zero) and -->
     <!-- .eh_frame (@code{@var{for_eh}} is nonzero).  The default is to -->
     <!-- return @code{@var{regno}}. -->
      <p>定义该宏来影射在调用帧信息中存放的寄存器编号，其为GCC使用<code>DWARF_FRAME_REGNUM</code>来搜集的应该放在.debug_frame（<var>for_eh</var>为0）和.eh_frame（<var>for_eh</var>为非0）中的寄存器。缺省为返回<var>regno</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>REG_VALUE_IN_UNWIND_CONTEXT</b><var><a name="index-REG_005fVALUE_005fIN_005fUNWIND_005fCONTEXT-4112"></a></var><br>
<blockquote>
      <p>Define this macro if the target stores register values as
<code>_Unwind_Word</code> type in unwind context.  It should be defined if
target register size is larger than the size of <code>void *</code>.  The
default is to store register values as <code>void *</code> type.

      </blockquote></div>

<div class="defun">
&mdash; Macro: <b>ASSUME_EXTENDED_UNWIND_CONTEXT</b><var><a name="index-ASSUME_005fEXTENDED_005fUNWIND_005fCONTEXT-4113"></a></var><br>
<blockquote>
      <p>Define this macro to be 1 if the target always uses extended unwind
context with version, args_size and by_value fields.  If it is undefined,
it will be defined to 1 when <code>REG_VALUE_IN_UNWIND_CONTEXT</code> is
defined and 0 otherwise.

      </blockquote></div>

<!-- @node Elimination -->
<!-- @subsection Eliminating Frame Pointer and Arg Pointer -->
 </body></html>

