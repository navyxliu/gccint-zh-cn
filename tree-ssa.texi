@c Copyright (c) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Tree SSA
@c ---------------------------------------------------------------------

@node Tree SSA
@chapter 分析和优化GIMPLE元组
@cindex Tree SSA
@cindex Optimization infrastructure for GIMPLE

在编译过程中，GCC使用了三种主要的中间语言来表示程序：GENERIC，GIMPLE和RTL。GENERIC是一种由每个前端生成的语言无关的表示。它用来作为语法分析器和优化器之间的接口。GENERIC是一种通用表示，能够表示使用GCC支持的所有语言编写的程序。

GIMPLE和RTL用于优化程序。GIMPLE用于目标和语言无关的优化（例如，内联，常数传播，尾调用消除，冗余消除等）。与GENERIC比较相似，GIMPLE是一种语言无关的树型表示。不过，与GENERIC不同的是GIMPLE的语法有更多的限制：表达式不包含3个以上的操作数（函数调用除外），它没有控制流程结构，并且具有副作用的表达式只允许出现在赋值语句的右端。详情参见描述GENERIC和GIMPLE的章节。

本章描述在GIMPLE优化器（也称为“树优化器”或者“中端”）中使用的数据结构和函数。特别是侧重于所有的宏，数据结构，函数和实现GIMPLE优化过程所需要的编程架构。

@menu
* Annotations::    变量的属性。
* SSA操作数::      由GIMPLE语句所引用的SSA名字。
* SSA::            静态单赋值表示。
* 别名分析::       加载和存储的别名表示。
@end menu

@node Annotations
@section Annotations
@cindex annotations

优化器需要在优化过程中将属性和变量关联起来。例如，我们需要知道一条语句属于哪个基本块，或者一个变量是否具有别名。所有这些属性被存储在叫做注解（annotation）的数据结构中，并被连接到 @code{struct tree_common} 的 @code{ann} 域中。

目前，我们定义了变量的注解 (@code{var_ann_t}) 。注解在 @file{tree-flow.h} 中有定义和文档描述。

@node SSA操作数
@section SSA操作数
@cindex operands
@cindex virtual operands
@cindex real operands
@findex update_stmt

几乎每条GIMPLE语句都会包含对变量或者内存地址的引用。由于语句的形状和大小不同，
它们的操作数也将会位于语句树中的不同位置。为了便于访问语句的操作数，
它们被组织到与语句的注解（annotation）相关联的一个列表中。
操作数列表中的每个元素都是一个指向@code{VAR_DECL}, @code{PARM_DECL}
或@code{SSA_NAME}树结点的指针。这就为检查和替换操作数提供了一种非常方便的方法。

数据流分析和优化是在所有表示变量的树结点上完成的。扫描语句操作数时，
将会考虑所有@code{SSA_VAR_P}返回非零的节点。但是，
并不是所有的@code{SSA_VAR_P}变量都使用同一种方式来处理。出于优化的目的，
我们需要区分对局部标量的引用和对全局变量，静态变量，结构体，数组，别名变量的引用，等等。
原因很简单，一方面，编译器能够为局部标量收集完整的数据流信息；另一方面，
全局变量可能会被函数调用所修改，
另外，可能无法追踪数组所有的元素或结构体所有的域的信息，等等。

操作数扫描器搜集两类操作数：实的（@dfn{real}）和虚的（@dfn{virtual}）。
@code{is_gimple_reg}返回真的操作数被认为是实操作数，否则为一个虚操作数。
我们还区分了它们的使用和定义。如果操作数的值被语句加载（例如，操作数在赋值的右边），
则为使用。如果语句给操作数赋于了一个新的值（例如，操作数在赋值语句的左边），则为定义。

虚操作数和实操作数还具有不同的数据流属性。
实操作数是对它们表示的完整对象的明确引用。例如，给定

@smallexample
@{
  int a, b;
  a = b
@}
@end smallexample

由于@code{a}和@code{b}为非别名的局部变量，
语句@code{a = b}将具有一个实定义和一个实使用，
因为变量@code{a}完全被变量@code{b}的内容修改了。
实定义还被称作为@dfn{killing definition}（杀死定义）。
类似的，对@code{b}的使用是读取了它的所有位。

与此相反，虚操作数用于具有部分或者不明确引用的变量。这包括结构体，数组，全局变量和别名变量。
这些情况下，我们具有两种类型的定义。对于全局变量，结构体和数组，
我们能够从语句中确定这些类型的变量是否具有一个killing definition（杀死定义）。如果具有，
则语句被标记为具有那个变量的必然定义（@dfn{must definition}）。但是，
如果语句只是定义了变量的一部分（即，结构体中的一个域），
或者如果我们知道语句可能会定义变量，但是不确定，
则我们将那条语句标记为具有一个可能定义（@dfn{may definition}）。例如，给定

@smallexample
@{
  int a, b, *p;

  if (@dots{})
    p = &a;
  else
    p = &b;
  *p = 5;
  return *p;
@}
@end smallexample

赋值@code{*p = 5}可能为@code{a}或者@code{b}的定义。
如果我们不能静态地确定在存储操作的时候@code{p}的指向，
我们便创建一个虚定义来标记那条语句为一个@code{a}和@code{b}的潜在的定义。
内存加载也类似的使用虚操作数进行标记。
虚操作数在树转储（dump）中显示在包含它们的语句前面。
要获得带有虚操作数的树转储，使用@option{-fdump-tree}的@option{-vops}选项：

@smallexample
@{
  int a, b, *p;

  if (@dots{})
    p = &a;
  else
    p = &b;
  # a = VDEF <a>
  # b = VDEF <b>
  *p = 5;

  # VUSE <a>
  # VUSE <b>
  return *p;
@}
@end smallexample

注意@code{VDEF}操作数具有被引用变量的两个副本。
这表明不是一个那个变量的killing definition（杀死定义）。在这种情况下，
我们称它为一个可能定义（@dfn{may definition}）或者
别名存储（@dfn{aliased store}）。
当函数被转换为SSA形式的时候，@code{VDEF}操作数的第二个变量副本将会变得很重要。
其将用于链接所有的非killing definition（杀死定义），用来防止优化对它们做错误的假设。

当语句完成时，便会立刻通过调用@code{update_stmt}来更新操作数。
如果语句元素通过@code{SET_USE}或@code{SET_DEF}被改变，
则不需要进一步的动作（即，那些宏会处理好语句更新）。
如果改变是通过直接操作语句的树，则必须在完成时调用@code{update_stmt}。
调用@code{bsi_insert}例程中的任何一个，或者@code{bsi_replace}，
都会隐式的调用@code{update_stmt}。

@subsection 操作数迭代器和访问例程
@cindex Operand Iterators 
@cindex Operand Access Routines

与操作数相关的代码都在@file{tree-ssa-operands.c}中。
操作数被存储在每条语句的注解中并且可以通过操作数迭代器或者访问例程来访问。

下列访问例程可以用来检查操作数：

@enumerate
@item @code{SINGLE_SSA_@{USE,DEF,TREE@}_OPERAND}: 
这些访问例程将会返回NULL，除非恰好有一个操作数匹配指定的标志。
如果恰好存在一个操作数，则操作数被作为@code{tree},@code{def_operand_p}或者
@code{use_operand_p}返回。 

@smallexample
tree t = SINGLE_SSA_TREE_OPERAND (stmt, flags);
use_operand_p u = SINGLE_SSA_USE_OPERAND (stmt, SSA_ALL_VIRTUAL_USES);
def_operand_p d = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_ALL_DEFS);
@end smallexample

@item @code{ZERO_SSA_OPERANDS}: 该宏返回真，如果没有操作数匹配指定的标志。 

@smallexample
if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))
  return;
@end smallexample

@item @code{NUM_SSA_OPERANDS}: 
该宏返回匹配'flags'的操作数数目。其实际上是执行了一个循环来进行统计，
所以最好只有在真正需要的时候才使用它。 

@smallexample
int count = NUM_SSA_OPERANDS (stmt, flags)
@end smallexample
@end enumerate

如果你想迭代一些或者所有操作数，
使用@code{FOR_EACH_SSA_@{USE,DEF,TREE@}_OPERAND}迭代器。
例如，要打印语句的所有操作数：

@smallexample
void
print_ops (tree stmt)
@{
  ssa_op_iter;
  tree var;

  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)
    print_generic_expr (stderr, var, TDF_SLIM);
@}
@end smallexample

如何选择合适的迭代器：

@enumerate
@item 确定你是否需要看到操作数指针，或者只是树，并选择合适的宏

@smallexample
Need            Macro:
----            -------
use_operand_p   FOR_EACH_SSA_USE_OPERAND
def_operand_p   FOR_EACH_SSA_DEF_OPERAND
tree            FOR_EACH_SSA_TREE_OPERAND
@end smallexample

@item 
你需要声明一个你感兴趣的类型的变量，和一个用作循环控制变量的ssa_op_iter结构体

@item 
确定你想使用哪些操作数，并指定你所感兴趣的那些操作数的标志。
这些标志在@file{tree-ssa-operands.h}中声明：

@smallexample
#define SSA_OP_USE              0x01    /* @r{Real USE operands.}  */
#define SSA_OP_DEF              0x02    /* @r{Real DEF operands.}  */
#define SSA_OP_VUSE             0x04    /* @r{VUSE operands.}  */
#define SSA_OP_VMAYUSE          0x08    /* @r{USE portion of VDEFS.}  */
#define SSA_OP_VDEF             0x10    /* @r{DEF portion of VDEFS.}  */

/* @r{These are commonly grouped operand flags.}  */
#define SSA_OP_VIRTUAL_USES     (SSA_OP_VUSE | SSA_OP_VMAYUSE)
#define SSA_OP_VIRTUAL_DEFS     (SSA_OP_VDEF)
#define SSA_OP_ALL_USES         (SSA_OP_VIRTUAL_USES | SSA_OP_USE)
#define SSA_OP_ALL_DEFS         (SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)
#define SSA_OP_ALL_OPERANDS     (SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)
@end smallexample
@end enumerate

所以，如果你想查看所有@code{USE}和@code{VUSE}操作数的use指针，
则可以使用类似下面的方法：

@smallexample
  use_operand_p use_p;
  ssa_op_iter iter;

  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, (SSA_OP_USE | SSA_OP_VUSE))
    @{
      process_use_ptr (use_p);
    @}
@end smallexample

宏@code{TREE}基本上与宏@code{USE}和@code{DEF}相同，
除了通过@code{USE_FROM_PTR (use_p)}和@code{DEF_FROM_PTR (def_p)}进行的
use或def的解引用。因为我们不会使用操作数指针，所以可以混合use和def标志。

@smallexample
  tree var;
  ssa_op_iter iter;

  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE)
    @{
       print_generic_expr (stderr, var, TDF_SLIM);
    @}
@end smallexample

@code{VDEF}被分解为两个标记，一个是@code{DEF}部分（@code{SSA_OP_VDEF}），
一个是USE部分（@code{SSA_OP_VMAYUSE}）。
如果你只是想要查看合在一起的@code{VDEF}，则可以使用第四个迭代器，
其返回语句中每个@code{VDEF}的 def_operand_p和use_operand_p。
注意该宏不需要任何标记。

@smallexample
  use_operand_p use_p;
  def_operand_p def_p;
  ssa_op_iter iter;

  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)
    @{
      my_code;
    @}
@end smallexample

代码中也有很多例子，同时在@file{tree-ssa-operands.h}中也有文档。

还有一些stmt迭代器是用于处理PHI节点的。

@code{FOR_EACH_PHI_ARG}跟@code{FOR_EACH_SSA_USE_OPERAND}非常类似，
只不过它是工作于@code{PHI}参数，而不是语句操作数。

@smallexample
/* Look at every virtual PHI use.  */
FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_VIRTUAL_USES)
@{
   my_code;
@}

/* Look at every real PHI use.  */
FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_USES)
  my_code;

/* Look at every PHI use.  */
FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_ALL_USES)
  my_code;
@end smallexample

@code{FOR_EACH_PHI_OR_STMT_@{USE,DEF@}}与
@code{FOR_EACH_SSA_@{USE,DEF@}_OPERAND}非常类似，
只不过它是作用于语句或者@code{PHI}节点。
这些宏可以在合适的时候使用，但是它们比单独使用@code{FOR_EACH_PHI}和
@code{FOR_EACH_SSA}例程的效率要低。

@smallexample
FOR_EACH_PHI_OR_STMT_USE (use_operand_p, stmt, iter, flags)
  @{
     my_code;
  @}

FOR_EACH_PHI_OR_STMT_DEF (def_operand_p, phi, iter, flags)
  @{
     my_code;
  @}
@end smallexample

@subsection 立即使用
@cindex Immediate Uses

现在immediate use（这个短语咋翻译？）信息总是可以被获得。
使用immediate use迭代器，你可以检查任意@code{SSA_NAME}的所有使用。
例如，要将@code{ssa_var}的所有使用改为@code{ssa_var2}，
并且之后在每个stmt上调用fold_stmt：

@smallexample
  use_operand_p imm_use_p;
  imm_use_iterator iterator;
  tree ssa_var, stmt;


  FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
    @{
      FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
        SET_USE (imm_use_p, ssa_var_2);
      fold_stmt (stmt);
    @}
@end smallexample

这里有两个可以使用的迭代器。
@code{FOR_EACH_IMM_USE_FAST}用于当immediate use没有被改变的情况下，即，
只是进行查看use，但不设置它们。

如果确实要做改变，则必须要考虑到迭代器下没有被改变的事物，这时，
可以使用@code{FOR_EACH_IMM_USE_STMT}和@code{FOR_EACH_IMM_USE_ON_STMT}迭代器。
它们试图通过将语句的所有use移动到一个被控制的位置并对它们进行迭代的方式，
来保证use列表的完整性。然后优化就能够在所有的use被处理完后来操作stmt。
这比FAST版本的有点慢，因为它增加了一个占位元素并且必须对每条语句的列表进行排序。
如果循环被提前终止，则该占位元素还必须被移除。
宏@code{BREAK_FROM_IMM_USE_SAFE}用于做这个：

@smallexample
  FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
    @{
      if (stmt == last_stmt)
        BREAK_FROM_SAFE_IMM_USE (iter);

      FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
        SET_USE (imm_use_p, ssa_var_2);
      fold_stmt (stmt);
    @}
@end smallexample

在@code{verify_ssa}中有一些检测用来验证immediate use列表是最新的，
同时还检测一个优化是否没有使用该宏而中断循环。
在@code{FOR_EACH_IMM_USE_FAST}遍历中，直接使用'break'语句是安全的。

一些有用的函数和宏：
@enumerate
@item  @code{has_zero_uses (ssa_var)} : 如果没有@code{ssa_var}的使用，则返回真。
@item   @code{has_single_use (ssa_var)} : 
如果只有@code{ssa_var}的单个使用，则返回真。
@item   @code{single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)} :
如果只有@code{ssa_var}的单个使用，则返回真，
并且还在第二和第三个参数中返回使用指针和所在的语句。
@item   @code{num_imm_uses (ssa_var)} : 
返回@code{ssa_var}的immediate use的数目。最好不要使用该宏，
因为它只是简单的使用循环来统计use。
@item  @code{PHI_ARG_INDEX_FROM_USE (use_p)} : 
给定一个在@code{PHI}节点中的use，返回use的索引数。
如果use不位于@code{PHI}节点中，则会触发一个断言。
@item  @code{USE_STMT (use_p)} : 返回use所在的语句。
@end enumerate

注意在语句通过@code{bsi_*}程序被实际插入指令流中之前，
use是不被放入immediate use列表中的。

还可以使用懒散的语句更新方式，不过这应该在确实需要的时候才使用。
别名分析和dominator优化目前都采用了这种方式。

当使用懒散更新（lazy updating）时，immediate use信息是过时的，不能被信赖。
懒散更新简单的调用@code{mark_stmt_modified}来标记语句被修改了，
而不使用@code{update_stmt}。当不再需要进行懒散更新时，
所有修改的语句都必须调用@code{update_stmt}来保持更新。
这必须在优化完成之前进行，否则@code{verify_ssa}将触发abort 异常中断。

这是通过对指令流进行简单的循环来实现的：

@smallexample
  block_stmt_iterator bsi;
  basic_block bb;
  FOR_EACH_BB (bb)
    @{
      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))
        update_stmt_if_modified (bsi_stmt (bsi));
    @}
@end smallexample

@node SSA
@section 静态单赋值
@cindex SSA
@cindex static single assignment

大多数树优化器都依赖于静态单赋值（SSA）形式所提供的数据流信息。
我们是按照@cite{R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and
K. Zadeck.  Efficiently Computing Static Single Assignment Form and the
Control Dependence Graph.  ACM Transactions on Programming Languages
and Systems, 13(4):451-490, October 1991}中的描述来实现SSA形式的。

SSA形式基于的前提是程序变量只在程序中的一个位置被赋值。
对同一变量的多次赋值将创建那个变量的新的版本。
实际的程序最初自然很少是SSA形式的，因为变量一般会被赋值多次。
编译器修改程序表示，使得代码中每次变量被赋值的时候，便会创建一个新版本的变量。
不同版本的同一变量通过变量名字的版本号作为下标来区分开。
在表达式右端使用的变量被重命名，使得它们的版本号匹配最近的赋值。

我们使用@code{SSA_NAME}节点来表示变量版本。
@file{tree-ssa.c}中的重命名程序将每个实操作数和虚操作数，
用包含了版本号和创建@code{SSA_NAME}的语句的@code{SSA_NAME}节点包裹起来。
只有定义和虚定义可能会创建新的@code{SSA_NAME}节点。

@cindex PHI nodes
有时，控制流使得无法确定变量的最近版本是多少。这种情况下，
编译器插入一个那个变量的人造定义，称作@dfn{PHI function}或者@dfn{PHI node}。
这个新的定义将变量的所有可能引入的版本合并一起，以创建一个新的名字。例如，

@smallexample
if (@dots{})
  a_1 = 5;
else if (@dots{})
  a_2 = 2;
else
  a_3 = 13;

# a_4 = PHI <a_1, a_2, a_3>
return a_4;
@end smallexample

由于不可能确定在运行时，将运行三个分支中的哪一个，
所以我们不知道在return语句中要使用@code{a_1},@code{a_2}或@code{a_3}中的哪一个。
因此，SSA重命名将会创建一个新的版本a_4，其被赋值为“合并”a_1, a_2和a_3的结果。
因此，PHI节点意味着“这些操作数中的一个，我不知道是哪一个”。

下面的宏可以用来检查PHI节点。

@defmac PHI_RESULT (@var{phi})
返回由PHI节点@var{phi}(即, @var{phi}'s LHS)创建的@code{SSA_NAME}。
@end defmac

@defmac PHI_NUM_ARGS (@var{phi})
返回@var{phi}中的参数个数。这个数目就是持有@var{phi}的基本块所引入的边的数目。
@end defmac

@defmac PHI_ARG_ELT (@var{phi}, @var{i})
返回@var{phi}的第@var{i}个参数的tuple表示。
tuple中的每个元素包含了一个@code{SSA_NAME} @var{var}和@var{var}借以流向的引入边。
@end defmac

@defmac PHI_ARG_EDGE (@var{phi}, @var{i})
返回@var{phi}的第@var{i}个参数对应的引入边。
@end defmac

@defmac PHI_ARG_DEF (@var{phi}, @var{i})
返回@var{phi}的第@var{i}个参数的@code{SSA_NAME}。
@end defmac


@subsection 保持SSA形式
@findex update_ssa
@cindex preserving SSA form
一些优化过程会改变函数并使得不再具有SSA特性。
这可能会发生在当一个过程增加了新的符号或者改变了程序使得变量不再被别名的时候。
不管什么时候发生类似的情况，受到影响的符号必须被再次重命名为SSA形式。
产生新代码或者替代存在的语句的转换也需要更新SSA形式。

由于GCC为寄存器和虚变量实现了两种不同的SSA形式，
所有保持SSA形式的更新取决于你是否正在更新寄存器或者虚名字。
这两种情况对于不断的SSA更新的背后思想是类似的：当新的SSA名字被创建时，
它们通常意味着要替换程序中的其它存在的名字。

例如，给定下列代码：

@smallexample
     1  L0:
     2  x_1 = PHI (0, x_5)
     3  if (x_1 < 10)
     4    if (x_1 > 7)
     5      y_2 = 0
     6    else
     7      y_3 = x_1 + x_7
     8    endif
     9    x_5 = x_1 + 1
     10   goto L0;
     11 endif
@end smallexample

假设我们插入了新的名字@code{x_10}和@code{x_11}（第@code{4}行和第@code{8}行）。

@smallexample
     1  L0:
     2  x_1 = PHI (0, x_5)
     3  if (x_1 < 10)
     4    x_10 = @dots{}
     5    if (x_1 > 7)
     6      y_2 = 0
     7    else
     8      x_11 = @dots{}
     9      y_3 = x_1 + x_7
     10   endif
     11   x_5 = x_1 + 1
     12   goto L0;
     13 endif
@end smallexample

我们想使用@code{x_10}和@code{x_11}的新的定义来替换@code{x_1}的所有使用。
注意将要被替换的使用只在行@code{5}, @code{9}和@code{11}中。而且，
第@code{9}行@code{x_7}的使用不应被替换
（这就是为什么我们不能仅仅标记符号@code{x}为重命名）。

另外，我们可能需要在第@code{11}行插入一个PHI节点，
因为有一个@code{x_10}和@code{x_11}的合并点。
所以@code{x_1}在第@code{11}行的使用将用新的PHI节点来替换。
PHI节点的插入是可选的。它们并不完全必要用于保持SSA形式，
并且取决于调用者的插入内容，它们可能对优化器没有用处。

更新SSA形式分为两步。首先，过程必须分别出哪些名字需要被更新，
以及哪些符号需要被重命名为SSA形式。当新的名字被引入以替换程序中现存的名字时，
新旧名字之间的映射通过调用@code{register_new_name_mapping}来注册
（注意如果你的过程通过复制基本块创建了新的代码，
对@code{tree_duplicate_bb}的调用将会自动建立所需的映射）。另一方面，
如果你的过程使得一个新的符号需要为SSA形式，
则新符号需要使用@code{mark_sym_for_renaming}来注册。

在替换映射被注册完，并且新符号被标记了要重命名后，
将会调用@code{update_ssa}来按照注册的进行改变。
这可以通过显示的调用或者为你的过程在@code{tree_opt_pass}结构体中创建
@code{TODO}标记来完成。
这里有几个@code{TODO}标记用于控制@code{update_ssa}的行为：

@itemize @bullet
@item @code{TODO_update_ssa}.  
采用为新出现的符号插入PHI节点，以及虚名字进行标记的方式更新SSA形式。
当更新实名字时，只为@code{O_j}的所有新旧定义所到达的块中的实名字@code{O_j}
插入PHI节点。如果@code{O_j}的迭代的dominance边界没有被截枝，
我们可以在块中危机具有一个或多个没有即来定义的@code{O_j}结束插入PHI节点。
这将导致对@code{O_j}符号的未初始化警告。

@item @code{TODO_update_ssa_no_phi}. 
不使用插入任何新PHI节点的方式来更新SSA形式。这被用于要自己插入所有PHI节点的
过程或者只需要更新use-def和def-def链的虚名字的过程（例如，DCE）。

@item @code{TODO_update_ssa_full_phi}.  
在任何需要的地方都插入PHI节点。不进行IDF的截枝。
这被过程用于需要@code{O_j}的PHI节点的情况
（例如，@code{pass_linear_transform}）。

警告: 如果你需要使用这个标记，则有可能你的过程是在做一些错误的事情。
为一个旧名字插入PHI节点可能会导致沉默的codegen错误或者虚假的未初始化警告。

@item @code{TODO_update_ssa_only_virtuals}.  
自己更新SSA的过程可能想要使用虚名字更新来代表通用的更新。因为FUD链易于维护，
所有这简化了他们所需的工作。注意：如果使用了该标记，
则任何实名字OLD->NEW的映射将被显式的破坏，只有标记为重命名的符合被处理。
@end itemize

@subsection 保持虚SSA形式
@cindex preserving virtual SSA form

虚SSA形式比非虚SSA形式要难以保持，主要是因为语句的虚操作数集可能会意外的改变。
通常，语句修改应该被对@code{push_stmt_changes}和@code{pop_stmt_changes}的调用
所包裹。例如，

@smallexample
    munge_stmt (tree stmt)
    @{
       push_stmt_changes (&stmt);
       @dots{} rewrite STMT @dots{}
       pop_stmt_changes (&stmt);
    @}
@end smallexample

对@code{push_stmt_changes}的调用保存了语句操作数的当前状态，
对@code{pop_stmt_changes}的调用比较保存的状态和现在的，
并对适当的符号标记为SSA重命名。

当处理一个语句栈时，通过使用LIFO顺序来调用@code{push_stmt_changes}和
@code{pop_stmt_changes}，可以一次修改多条语句。

另外，如果过程在调用@code{push_stmt_changes}后发现它不需要改变语句，
它可以通过调用@code{discard_stmt_changes}来简单的丢弃最顶层的缓存。
这将避免用来确定是否符合需要被标记为重命名所需的昂贵的操作数重扫描操作和缓存比较。

@subsection 检验@code{SSA_NAME}节点
@cindex examining SSA_NAMEs

下面的宏可以用来检查@code{SSA_NAME}节点

@defmac SSA_NAME_DEF_STMT (@var{var})
返回创建@code{SSA_NAME} @var{var}的语句@var{s}。
如过@var{s}是空语句（即，@code{IS_EMPTY_STMT (@var{s})}返回@code{true}），
则意味着对该变量的第一个引用是一个USE或者VUSE。
@end defmac

@defmac SSA_NAME_VERSION (@var{var})
返回@code{SSA_NAME}对象@var{var}的版本号。
@end defmac

@subsection 遍历use-def链

@deftypefn {Tree SSA function} void walk_use_def_chains (@var{var}, @var{fn}, @var{data})

对use-def链的遍历起始于@code{SSA_NAME}节点@var{var}。
对每一个发现的可达定义调用函数@var{fn}。函数@var{fn}接受三个参数：@var{var}，
它的定义语句（@var{def_stmt}）和一个通用指针指向@var{fn}可能想要维护的任何状态
信息（数据）。函数@var{fn}可以通过返回@code{true}来停止遍历，否则要继续遍历，
@var{fn}应该返回@code{false}。

注意，如果@var{def_stmt}是一个@code{PHI}节点，则语法有点不同。
对PHI节点的每个参数@var{arg}，该函数将：

@enumerate
@item 为@var{arg}遍历use-def链
@item 调用@code{FN (@var{arg}, @var{phi}, @var{data})}.
@end enumerate

注意不管@var{fn}的第一个是否还是最初的变量@var{var}，目前都会检测PHI的参数。
如果@var{fn}想获得@var{var}，则应该调用@code{PHI_RESULT} (@var{phi})。
@end deftypefn

@subsection 遍历支配树

@deftypefn {Tree SSA function} void walk_dominator_tree (@var{walk_data}, @var{bb})

该函数遍历当前CFG的支配树，
并调用在@file{domwalk.h}中@var{struct dom_walk_data}里定义的一系列回调函数。
你所需要定义的回调函数可以用于在遍历过程中的不同点执行自定义的代码：

@enumerate
@item 
当处理@var{bb}和它的孩子（children）时，在初始化所需要的任何局部数据的时候。
该局部数据被压入一个内部的栈中，该栈在遍历支配树时会被自动的压入和弹出。

@item 在遍历@var{bb}中的所有语句之前。

@item 对于@var{bb}中的每条语句。

@item 当遍历过所有语句之后，并在递归到@var{bb}的支配孩子之前。

@item 然后递归到@var{bb}的所有支配孩子。

@item 
在递归到@var{bb}的所有支配孩子之后，可选的，
重新遍历@var{bb}中的每条语句（即，重复步骤2和3）。

@item 
当遍历完@var{bb}和@var{bb}的支配孩子中的所有语句之后。这时，块局部数据栈被弹出。
@end enumerate
@end deftypefn

@node 别名分析
@section 别名分析
@cindex alias
@cindex flow-sensitive alias analysis
@cindex flow-insensitive alias analysis

别名分析经历4个主要阶段：

@enumerate
@item   结构体的别名分析。 

该过程遍历结构体类型的变量，并确定哪些域可以使用域的偏移量和大小来重叠。
对于每个域，一个称作“结构体域标签”（SFT）的“子变量”被创建，
其使用独立的变量来表示那个域。对于给定域，
所有可能会重叠的访问将具有那个域的SFT的虚操作数。

@smallexample
struct foo
@{
  int a;
  int b;
@}
struct foo temp;
int bar (void)
@{
  int tmp1, tmp2, tmp3;
  SFT.0_2 = VDEF <SFT.0_1>
  temp.a = 5;
  SFT.1_4 = VDEF <SFT.1_3>
  temp.b = 6;
  
  VUSE <SFT.1_4>
  tmp1_5 = temp.b;
  VUSE <SFT.0_2>
  tmp2_6 = temp.a;

  tmp3_7 = tmp1_5 + tmp2_6;
  return tmp3_7;
@}
@end smallexample

如果你出于某种原因为一个变量复制符合标签，则有可能还要复制它的子变量。

@item Points-to和escape分析

该过程遍历SSA web中的use-def链，查看三件事情：

@itemize @bullet
@item @code{P_i = &VAR}形式的赋值
@item @code{P_i = malloc()}形式的赋值
@item 逃逸当前函数的指针和ADDR_EXPR
@end itemize

逃逸的概念跟Java世界中使用的相同。当一个指针或者一个ADDR_EXPR逃逸，
指的是它已经被暴露在当前函数之外。所以，全局变量的赋值，函数参数，
以及返回指针都是逃逸的地点。

这是我们目前所限制的。因为并不是所有都被重命名到SSA，例如，
当指针被隐藏在一个结构体的域中的时候，我们就丢失了逃逸属性。
在那些情况下，我们假设指针是逃逸的。

我们使用逃逸分析来确定是否变量为call-clobbered。简单的说，
如果一个ADDR_EXPR逃逸，则变量是call-clobbered。如果一个指针P_i逃逸，
则所有P_i指向的变量（以及它的内存标签）也逃逸。

@item 计算流敏感别名

我们有两类内存标签。内存标签与程序中的指针所指向的数据类型相关。
这些标签称为“符号内存标签”（SMT）。另一类是那些与SSA_NAME相关的，
称作“名字内存标签”（NMT）。基本的想法是，当为一个INDIRECT_REF *P_i增加操作数时，
我们将先检查P_i是否具有名字标签，如果有的话我们就使用，
因为那将具有更加精确的别名信息。否则，我们使用标准的符号标签。

在这一阶段，我们遍历在points-to分析中发现的所有指针，
并为与每个指针P_i关联的名字内存标签创建别名集。如果P_i逃逸，
我们标记它指向的变量和它的标签为call-clobbered。

@item 计算流不敏感别名

该过程将比较每个符号内存标签的别名集与程序中发现的每个可寻址的变量。
给定一个符号内存标签SMT和一个可寻址变量V。
如果SMT的别名集和V冲突（通过may_alias_p来计算获得），
则V被标记为一个别名标签并被增加到SMT的别名集中。

每个希望执行语言相关的别名分析的语言应该定义一个函数，给定一个@code{tree}结点，
能够计算结点的别名集。在不同别名集中的节点不允许进行别名。例如，
参见C语言前端函数@code{c_get_alias_set}。
@end enumerate

例如，考虑下面的函数：

@smallexample
foo (int i)
@{
  int *p, *q, a, b;

  if (i > 10)
    p = &a;
  else
    q = &b;

  *p = 3;
  *q = 5;
  a = b + 2;
  return *p;
@}
@end smallexample

在别名分析完成之后，指针@code{p}的符号内存标签将具有两个别名，
变量@code{a}和@code{b}。当每次指针@code{p}被dereference时，
我们想要标记操作为一个对@code{a}和@code{b}的潜在的引用。

@smallexample
foo (int i)
@{
  int *p, a, b;

  if (i_2 > 10)
    p_4 = &a;
  else
    p_6 = &b;
  # p_1 = PHI <p_4(1), p_6(2)>;

  # a_7 = VDEF <a_3>;
  # b_8 = VDEF <b_5>;
  *p_1 = 3;

  # a_9 = VDEF <a_7>
  # VUSE <b_8>
  a_9 = b_8 + 2;

  # VUSE <a_9>;
  # VUSE <b_8>;
  return *p_1;
@}
@end smallexample

在一些情况下，一个指针的可能别名列表可能会变得很大。
这会造成代码中插入的虚操作数的数目的膨胀，使得内存消耗和编译时间增大。

当表示别名加载和存储所需要的虚操作数数目增长的太大的时候
（可以使用@option{--param max-aliased-vops}来配置），
别名集被分组以避免严重的编译时间下降和内存消耗。别名分组的heuristic如下：

@enumerate
@item 
将指针列表按照分配的虚操作数数目进行递减排序。

@item 
从列表中取出第一个指针并反转内存标签和别名的脚色。通常，
不管什么时候被别名的变量Vi被发现与内存标签T别名，
我们都将Vi增加到T的可能别名集中。这意味着，别名分析之后，我们将得到：

@smallexample
may-aliases(T) = @{ V1, V2, V3, @dots{}, Vn @}
@end smallexample

这意味着每条引用T的语句，将得到Vi标签的@code{n}个虚拟操作数。但是，
当启用了别名分组时，我们将T标记为别名标签并将其增加到所有Vi变量的别名集中：

@smallexample
may-aliases(V1) = @{ T @}
may-aliases(V2) = @{ T @}
@dots{}
may-aliases(Vn) = @{ T @}
@end smallexample

这有两个效果：(a)引用T的语句将只得到一个单独的虚拟操作数，
(b)所有变量Vi现在将显示为相互别名。所以，
我们为了提高编译时间而失去了别名精确性。但是，理论上，
像这样使用高层次的别名的程序，应该不是把优化放在第一位。

@item 
由于变量可以在多个内存标签的别名集中，所以在步骤(2)中所作的分组工作需要被扩展
为针对所有与标签T的可能别名集具有非空交集的内存标签。例如，
如果我们最初具有这些可能别名集： 

@smallexample
may-aliases(T) = @{ V1, V2, V3 @}
may-aliases(R) = @{ V2, V4 @}
@end smallexample

在步骤(2)中，我们将会反转T的别名为： 

@smallexample
may-aliases(V1) = @{ T @}
may-aliases(V2) = @{ T @}
may-aliases(V3) = @{ T @}
@end smallexample

但是注意现在V2不再与R别名了。我们本应该将R增加到may-aliases(V2)中，
但是我们是在处理别名分组以减少虚拟操作数，所以我们所要做的是将V4增加到分组中，
以获得：

@smallexample
may-aliases(V1) = @{ T @}
may-aliases(V2) = @{ T @}
may-aliases(V3) = @{ T @}
may-aliases(V4) = @{ T @}
@end smallexample

@item 
如果由于别名产生的虚拟操作数总数依然超出max-alias-vops设置的门槛，
则回到步骤(2)。
@end enumerate
