@c Copyright (c) 2004, 2005, 2007, 2008, 2010
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c Tree SSA
@c ---------------------------------------------------------------------

@en @node Tree SSA
@en @chapter Analysis and Optimization of GIMPLE tuples
@node Tree SSA
@chapter 分析和优化GIMPLE元组
@cindex Tree SSA
@cindex Optimization infrastructure for GIMPLE

@en GCC uses three main intermediate languages to represent the program
@en during compilation: GENERIC, GIMPLE and RTL@.  GENERIC is a
@en language-independent representation generated by each front end.  It
@en is used to serve as an interface between the parser and optimizer.
@en GENERIC is a common representation that is able to represent programs
@en written in all the languages supported by GCC@.
在编译过程中，GCC使用了三种主要的中间语言来表示程序：GENERIC，GIMPLE和RTL。GENERIC是一种由每个前端生成的语言无关的表示。它用来作为语法分析器和优化器之间的接口。GENERIC是一种通用表示，能够表示使用GCC支持的所有语言编写的程序。

@en GIMPLE and RTL are used to optimize the program.  GIMPLE is used for
@en target and language independent optimizations (e.g., inlining,
@en constant propagation, tail call elimination, redundancy elimination,
@en etc).  Much like GENERIC, GIMPLE is a language independent, tree based
@en representation.  However, it differs from GENERIC in that the GIMPLE
@en grammar is more restrictive: expressions contain no more than 3
@en operands (except function calls), it has no control flow structures
@en and expressions with side-effects are only allowed on the right hand
@en side of assignments.  See the chapter describing GENERIC and GIMPLE
@en for more details.
GIMPLE和RTL用于优化程序。GIMPLE用于目标和语言无关的优化（例如，内联，常数传播，尾调用消除，冗余消除等）。与GENERIC比较相似，GIMPLE是一种语言无关的树型表示。不过，与GENERIC不同的是GIMPLE的语法有更多的限制：表达式不包含3个以上的操作数（函数调用除外），它没有控制流程结构，并且具有副作用的表达式只允许出现在赋值语句的右端。详情参见描述GENERIC和GIMPLE的章节。

@en This chapter describes the data structures and functions used in the
@en GIMPLE optimizers (also known as ``tree optimizers'' or ``middle
@en end'').  In particular, it focuses on all the macros, data structures,
@en functions and programming constructs needed to implement optimization
@en passes for GIMPLE@.
本章描述在GIMPLE优化器（也称为“树优化器”或者“中端”）中使用的数据结构和函数。特别是侧重于所有的宏，数据结构，函数和实现GIMPLE优化过程所需要的编程架构。

@en @menu
@en * Annotations::         Attributes for variables.
@en * SSA Operands::        SSA names referenced by GIMPLE statements.
@en * SSA::                 Static Single Assignment representation.
@en * Alias analysis::      Representing aliased loads and stores.
@en * Memory model::        Memory model used by the middle-end.
@en @end menu
@menu
* Annotations::    变量的属性。
* SSA Operands::      由GIMPLE语句所引用的SSA名字。
* SSA::            静态单赋值表示。
* Alias analysis::       加载和存储的别名表示。
* Memory model::        Memory model used by the middle-end.
@end menu

@node Annotations
@section Annotations
@cindex annotations

@en The optimizers need to associate attributes with variables during the
@en optimization process.  For instance, we need to know whether a
@en variable has aliases.  All these attributes are stored in data
@en structures called annotations which are then linked to the field
@en @code{ann} in @code{struct tree_common}.
优化器需要在优化过程中将属性和变量关联起来。例如，我们需要知道一条语句属于哪个基本块，或者一个变量是否具有别名。所有这些属性被存储在叫做注解（annotation）的数据结构中，并被连接到 @code{struct tree_common} 的 @code{ann} 域中。

@en Presently, we define annotations for variables (@code{var_ann_t}).
@en Annotations are defined and documented in @file{tree-flow.h}.
目前，我们定义了变量的注解 (@code{var_ann_t}) 。注解在 @file{tree-flow.h} 中有定义和文档描述。

@en @node SSA Operands
@en @section SSA Operands
@node SSA Operands
@section SSA操作数
@cindex operands
@cindex virtual operands
@cindex real operands
@findex update_stmt

@en Almost every GIMPLE statement will contain a reference to a variable
@en or memory location.  Since statements come in different shapes and
@en sizes, their operands are going to be located at various spots inside
@en the statement's tree.  To facilitate access to the statement's
@en operands, they are organized into lists associated inside each
@en statement's annotation.  Each element in an operand list is a pointer
@en to a @code{VAR_DECL}, @code{PARM_DECL} or @code{SSA_NAME} tree node.
@en This provides a very convenient way of examining and replacing
@en operands.
几乎每条GIMPLE语句都会包含对变量或者内存地址的引用。由于语句的形状和大小不同，
它们的操作数也将会位于语句树中的不同位置。为了便于访问语句的操作数，
它们被组织到与语句的注解（annotation）相关联的一个列表中。
操作数列表中的每个元素都是一个指向@code{VAR_DECL}, @code{PARM_DECL}
或@code{SSA_NAME}树结点的指针。这就为检查和替换操作数提供了一种非常方便的方法。

@en Data flow analysis and optimization is done on all tree nodes
@en representing variables.  Any node for which @code{SSA_VAR_P} returns
@en nonzero is considered when scanning statement operands.  However, not
@en all @code{SSA_VAR_P} variables are processed in the same way.  For the
@en purposes of optimization, we need to distinguish between references to
@en local scalar variables and references to globals, statics, structures,
@en arrays, aliased variables, etc.  The reason is simple, the compiler
@en can gather complete data flow information for a local scalar.  On the
@en other hand, a global variable may be modified by a function call, it
@en may not be possible to keep track of all the elements of an array or
@en the fields of a structure, etc.
数据流分析和优化是在所有表示变量的树结点上完成的。扫描语句操作数时，
将会考虑所有@code{SSA_VAR_P}返回非零的节点。但是，
并不是所有的@code{SSA_VAR_P}变量都使用同一种方式来处理。出于优化的目的，
我们需要区分对局部标量的引用和对全局变量，静态变量，结构体，数组，别名变量的引用，等等。
原因很简单，一方面，编译器能够为局部标量收集完整的数据流信息；另一方面，
全局变量可能会被函数调用所修改，
另外，可能无法追踪数组所有的元素或结构体所有的域的信息，等等。

@en The operand scanner gathers two kinds of operands: @dfn{real} and
@en @dfn{virtual}.  An operand for which @code{is_gimple_reg} returns true
@en is considered real, otherwise it is a virtual operand.  We also
@en distinguish between uses and definitions.  An operand is used if its
@en value is loaded by the statement (e.g., the operand at the RHS of an
@en assignment).  If the statement assigns a new value to the operand, the
@en operand is considered a definition (e.g., the operand at the LHS of
@en an assignment).
操作数扫描器搜集两类操作数：实的（@dfn{real}）和虚的（@dfn{virtual}）。
@code{is_gimple_reg}返回真的操作数被认为是实操作数，否则为一个虚操作数。
我们还区分了它们的使用和定义。如果操作数的值被语句加载（例如，操作数在赋值的右边），
则为使用。如果语句给操作数赋于了一个新的值（例如，操作数在赋值语句的左边），则为定义。

@en Virtual and real operands also have very different data flow
@en properties.  Real operands are unambiguous references to the
@en full object that they represent.  For instance, given
虚操作数和实操作数还具有不同的数据流属性。
实操作数是对它们表示的完整对象的明确引用。例如，给定

@smallexample
@{
  int a, b;
  a = b
@}
@end smallexample

@en Since @code{a} and @code{b} are non-aliased locals, the statement
@en @code{a = b} will have one real definition and one real use because
@en variable @code{a} is completely modified with the contents of
@en variable @code{b}.  Real definition are also known as @dfn{killing
@en definitions}.  Similarly, the use of @code{b} reads all its bits.
由于@code{a}和@code{b}为非别名的局部变量，
语句@code{a = b}将具有一个实定义和一个实使用，
因为变量@code{a}完全被变量@code{b}的内容修改了。
实定义还被称作为@dfn{killing definition}（杀死定义）。
类似的，对@code{b}的使用是读取了它的所有位。

@en In contrast, virtual operands are used with variables that can have
@en a partial or ambiguous reference.  This includes structures, arrays,
@en globals, and aliased variables.  In these cases, we have two types of
@en definitions.  For globals, structures, and arrays, we can determine from
@en a statement whether a variable of these types has a killing definition.
@en If the variable does, then the statement is marked as having a
@en @dfn{must definition} of that variable.  However, if a statement is only
@en defining a part of the variable (i.e.@: a field in a structure), or if we
@en know that a statement might define the variable but we cannot say for sure,
@en then we mark that statement as having a @dfn{may definition}.  For
@en instance, given
与此相反，虚操作数用于具有部分或者不明确引用的变量。这包括结构体，数组，全局变量和别名变量。
这些情况下，我们具有两种类型的定义。对于全局变量，结构体和数组，
我们能够从语句中确定这些类型的变量是否具有一个killing definition（杀死定义）。如果具有，
则语句被标记为具有那个变量的必然定义（@dfn{must definition}）。但是，
如果语句只是定义了变量的一部分（即，结构体中的一个域），
或者如果我们知道语句可能会定义变量，但是不确定，
则我们将那条语句标记为具有一个可能定义（@dfn{may definition}）。例如，给定

@smallexample
@{
  int a, b, *p;

  if (@dots{})
    p = &a;
  else
    p = &b;
  *p = 5;
  return *p;
@}
@end smallexample

@en The assignment @code{*p = 5} may be a definition of @code{a} or
@en @code{b}.  If we cannot determine statically where @code{p} is
@en pointing to at the time of the store operation, we create virtual
@en definitions to mark that statement as a potential definition site for
@en @code{a} and @code{b}.  Memory loads are similarly marked with virtual
@en use operands.  Virtual operands are shown in tree dumps right before
@en the statement that contains them.  To request a tree dump with virtual
@en operands, use the @option{-vops} option to @option{-fdump-tree}:
赋值@code{*p = 5}可能为@code{a}或者@code{b}的定义。
如果我们不能静态地确定在存储操作的时候@code{p}的指向，
我们便创建一个虚定义来标记那条语句为一个@code{a}和@code{b}的潜在的定义。
内存加载也类似的使用虚操作数进行标记。
虚操作数在树转储（dump）中显示在包含它们的语句前面。
要获得带有虚操作数的树转储，使用@option{-fdump-tree}的@option{-vops}选项：

@smallexample
@{
  int a, b, *p;

  if (@dots{})
    p = &a;
  else
    p = &b;
  # a = VDEF <a>
  # b = VDEF <b>
  *p = 5;

  # VUSE <a>
  # VUSE <b>
  return *p;
@}
@end smallexample

@en Notice that @code{VDEF} operands have two copies of the referenced
@en variable.  This indicates that this is not a killing definition of
@en that variable.  In this case we refer to it as a @dfn{may definition}
@en or @dfn{aliased store}.  The presence of the second copy of the
@en variable in the @code{VDEF} operand will become important when the
@en function is converted into SSA form.  This will be used to link all
@en the non-killing definitions to prevent optimizations from making
@en incorrect assumptions about them.
注意@code{VDEF}操作数具有被引用变量的两个副本。
这表明不是一个那个变量的killing definition（杀死定义）。在这种情况下，
我们称它为一个可能定义（@dfn{may definition}）或者
别名存储（@dfn{aliased store}）。
当函数被转换为SSA形式的时候，@code{VDEF}操作数的第二个变量副本将会变得很重要。
其将用于链接所有的非killing definition（杀死定义），用来防止优化对它们做错误的假设。

@en Operands are updated as soon as the statement is finished via a call
@en to @code{update_stmt}.  If statement elements are changed via
@en @code{SET_USE} or @code{SET_DEF}, then no further action is required
@en (i.e., those macros take care of updating the statement).  If changes
@en are made by manipulating the statement's tree directly, then a call
@en must be made to @code{update_stmt} when complete.  Calling one of the
@en @code{bsi_insert} routines or @code{bsi_replace} performs an implicit
@en call to @code{update_stmt}.
当语句完成时，便会立刻通过调用@code{update_stmt}来更新操作数。
如果语句元素通过@code{SET_USE}或@code{SET_DEF}被改变，
则不需要进一步的动作（即，那些宏会处理好语句更新）。
如果改变是通过直接操作语句的树，则必须在完成时调用@code{update_stmt}。
调用@code{bsi_insert}例程中的任何一个，或者@code{bsi_replace}，
都会隐式的调用@code{update_stmt}。

@en @subsection Operand Iterators And Access Routines
@subsection 操作数迭代器和访问例程
@cindex Operand Iterators 
@cindex Operand Access Routines

@en Operands are collected by @file{tree-ssa-operands.c}.  They are stored
@en inside each statement's annotation and can be accessed through either the
@en operand iterators or an access routine.
与操作数相关的代码都在@file{tree-ssa-operands.c}中。
操作数被存储在每条语句的注解中并且可以通过操作数迭代器或者访问例程来访问。

@en The following access routines are available for examining operands:
下列访问例程可以用来检查操作数：

@enumerate
@en @item @code{SINGLE_SSA_@{USE,DEF,TREE@}_OPERAND}: These accessors will return 
@en NULL unless there is exactly one operand matching the specified flags.  If 
@en there is exactly one operand, the operand is returned as either a @code{tree}, 
@en @code{def_operand_p}, or @code{use_operand_p}.
@en @item @code{SINGLE_SSA_@{USE,DEF,TREE@}_OPERAND}: 
这些访问例程将会返回NULL，除非恰好有一个操作数匹配指定的标志。
如果恰好存在一个操作数，则操作数被作为@code{tree},@code{def_operand_p}或者
@code{use_operand_p}返回。 

@smallexample
tree t = SINGLE_SSA_TREE_OPERAND (stmt, flags);
use_operand_p u = SINGLE_SSA_USE_OPERAND (stmt, SSA_ALL_VIRTUAL_USES);
def_operand_p d = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_ALL_DEFS);
@end smallexample

@en @item @code{ZERO_SSA_OPERANDS}: This macro returns true if there are no 
@en operands matching the specified flags.
@item @code{ZERO_SSA_OPERANDS}: 该宏返回真，如果没有操作数匹配指定的标志。 

@smallexample
if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))
  return;
@end smallexample

@en @item @code{NUM_SSA_OPERANDS}: This macro Returns the number of operands 
@en matching 'flags'.  This actually executes a loop to perform the count, so 
@en only use this if it is really needed.
@item @code{NUM_SSA_OPERANDS}: 
该宏返回匹配'flags'的操作数数目。其实际上是执行了一个循环来进行统计，
所以最好只有在真正需要的时候才使用它。 

@smallexample
int count = NUM_SSA_OPERANDS (stmt, flags)
@end smallexample
@end enumerate

@en If you wish to iterate over some or all operands, use the
@en @code{FOR_EACH_SSA_@{USE,DEF,TREE@}_OPERAND} iterator.  For example, to print
@en all the operands for a statement:
如果你想迭代一些或者所有操作数，
使用@code{FOR_EACH_SSA_@{USE,DEF,TREE@}_OPERAND}迭代器。
例如，要打印语句的所有操作数：

@smallexample
void
print_ops (tree stmt)
@{
  ssa_op_iter;
  tree var;

  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)
    print_generic_expr (stderr, var, TDF_SLIM);
@}
@end smallexample

@en How to choose the appropriate iterator:
如何选择合适的迭代器：

@enumerate
@en @item Determine whether you are need to see the operand pointers, or just the
@en trees, and choose the appropriate macro:
@item 确定你是否需要看到操作数指针，或者只是树，并选择合适的宏

@smallexample
Need            Macro:
----            -------
use_operand_p   FOR_EACH_SSA_USE_OPERAND
def_operand_p   FOR_EACH_SSA_DEF_OPERAND
tree            FOR_EACH_SSA_TREE_OPERAND
@end smallexample

@en @item You need to declare a variable of the type you are interested
@en in, and an ssa_op_iter structure which serves as the loop controlling
@en variable.
@item 
你需要声明一个你感兴趣的类型的变量，和一个用作循环控制变量的ssa_op_iter结构体

@en @item Determine which operands you wish to use, and specify the flags of
@en those you are interested in.  They are documented in
@en @file{tree-ssa-operands.h}:
@item 
确定你想使用哪些操作数，并指定你所感兴趣的那些操作数的标志。
这些标志在@file{tree-ssa-operands.h}中声明：

@smallexample
#define SSA_OP_USE              0x01    /* @r{Real USE operands.}  */
#define SSA_OP_DEF              0x02    /* @r{Real DEF operands.}  */
#define SSA_OP_VUSE             0x04    /* @r{VUSE operands.}  */
#define SSA_OP_VMAYUSE          0x08    /* @r{USE portion of VDEFS.}  */
#define SSA_OP_VDEF             0x10    /* @r{DEF portion of VDEFS.}  */

/* @r{These are commonly grouped operand flags.}  */
#define SSA_OP_VIRTUAL_USES     (SSA_OP_VUSE | SSA_OP_VMAYUSE)
#define SSA_OP_VIRTUAL_DEFS     (SSA_OP_VDEF)
#define SSA_OP_ALL_USES         (SSA_OP_VIRTUAL_USES | SSA_OP_USE)
#define SSA_OP_ALL_DEFS         (SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)
#define SSA_OP_ALL_OPERANDS     (SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)
@end smallexample
@end enumerate

@en So if you want to look at the use pointers for all the @code{USE} and
@en @code{VUSE} operands, you would do something like:
所以，如果你想查看所有@code{USE}和@code{VUSE}操作数的use指针，
则可以使用类似下面的方法：

@smallexample
  use_operand_p use_p;
  ssa_op_iter iter;

  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, (SSA_OP_USE | SSA_OP_VUSE))
    @{
      process_use_ptr (use_p);
    @}
@end smallexample

@en The @code{TREE} macro is basically the same as the @code{USE} and
@en @code{DEF} macros, only with the use or def dereferenced via
@en @code{USE_FROM_PTR (use_p)} and @code{DEF_FROM_PTR (def_p)}.  Since we
@en aren't using operand pointers, use and defs flags can be mixed.
宏@code{TREE}基本上与宏@code{USE}和@code{DEF}相同，
除了通过@code{USE_FROM_PTR (use_p)}和@code{DEF_FROM_PTR (def_p)}进行的
use或def的解引用。因为我们不会使用操作数指针，所以可以混合use和def标志。

@smallexample
  tree var;
  ssa_op_iter iter;

  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE)
    @{
       print_generic_expr (stderr, var, TDF_SLIM);
    @}
@end smallexample

@en @code{VDEF}s are broken into two flags, one for the
@en @code{DEF} portion (@code{SSA_OP_VDEF}) and one for the USE portion
@en (@code{SSA_OP_VMAYUSE}).  If all you want to look at are the
@en @code{VDEF}s together, there is a fourth iterator macro for this,
@en which returns both a def_operand_p and a use_operand_p for each
@en @code{VDEF} in the statement.  Note that you don't need any flags for
@en this one.
@code{VDEF}被分解为两个标记，一个是@code{DEF}部分（@code{SSA_OP_VDEF}），
一个是USE部分（@code{SSA_OP_VMAYUSE}）。
如果你只是想要查看合在一起的@code{VDEF}，则可以使用第四个迭代器，
其返回语句中每个@code{VDEF}的 def_operand_p和use_operand_p。
注意该宏不需要任何标记。

@smallexample
  use_operand_p use_p;
  def_operand_p def_p;
  ssa_op_iter iter;

  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)
    @{
      my_code;
    @}
@end smallexample

@en There are many examples in the code as well, as well as the
@en documentation in @file{tree-ssa-operands.h}.
代码中也有很多例子，同时在@file{tree-ssa-operands.h}中也有文档。

@en There are also a couple of variants on the stmt iterators regarding PHI
@en nodes.
还有一些stmt迭代器是用于处理PHI节点的。

@en @code{FOR_EACH_PHI_ARG} Works exactly like 
@en @code{FOR_EACH_SSA_USE_OPERAND}, except it works over @code{PHI} arguments 
@en instead of statement operands.
@code{FOR_EACH_PHI_ARG}跟@code{FOR_EACH_SSA_USE_OPERAND}非常类似，
只不过它是工作于@code{PHI}参数，而不是语句操作数。

@smallexample
/* Look at every virtual PHI use.  */
FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_VIRTUAL_USES)
@{
   my_code;
@}

/* Look at every real PHI use.  */
FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_USES)
  my_code;

/* Look at every PHI use.  */
FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_ALL_USES)
  my_code;
@end smallexample

@en @code{FOR_EACH_PHI_OR_STMT_@{USE,DEF@}} works exactly like 
@en @code{FOR_EACH_SSA_@{USE,DEF@}_OPERAND}, except it will function on
@en either a statement or a @code{PHI} node.  These should be used when it is
@en appropriate but they are not quite as efficient as the individual 
@en @code{FOR_EACH_PHI} and @code{FOR_EACH_SSA} routines.
@code{FOR_EACH_PHI_OR_STMT_@{USE,DEF@}}与
@code{FOR_EACH_SSA_@{USE,DEF@}_OPERAND}非常类似，
只不过它是作用于语句或者@code{PHI}节点。
这些宏可以在合适的时候使用，但是它们比单独使用@code{FOR_EACH_PHI}和
@code{FOR_EACH_SSA}例程的效率要低。

@smallexample
FOR_EACH_PHI_OR_STMT_USE (use_operand_p, stmt, iter, flags)
  @{
     my_code;
  @}

FOR_EACH_PHI_OR_STMT_DEF (def_operand_p, phi, iter, flags)
  @{
     my_code;
  @}
@end smallexample

@en @subsection Immediate Uses
@subsection 立即使用
@cindex Immediate Uses

@en Immediate use information is now always available.  Using the immediate use 
@en iterators, you may examine every use of any @code{SSA_NAME}. For instance,
@en to change each use of @code{ssa_var} to @code{ssa_var2} and call fold_stmt on
@en each stmt after that is done:
现在immediate use（这个短语咋翻译？）信息总是可以被获得。
使用immediate use迭代器，你可以检查任意@code{SSA_NAME}的所有使用。
例如，要将@code{ssa_var}的所有使用改为@code{ssa_var2}，
并且之后在每个stmt上调用fold_stmt：

@smallexample
  use_operand_p imm_use_p;
  imm_use_iterator iterator;
  tree ssa_var, stmt;


  FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
    @{
      FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
        SET_USE (imm_use_p, ssa_var_2);
      fold_stmt (stmt);
    @}
@end smallexample

@en There are 2 iterators which can be used. @code{FOR_EACH_IMM_USE_FAST} is
@en used when the immediate uses are not changed, i.e., you are looking at the
@en uses, but not setting them.  
这里有两个可以使用的迭代器。
@code{FOR_EACH_IMM_USE_FAST}用于当immediate use没有被改变的情况下，即，
只是进行查看use，但不设置它们。

@en If they do get changed, then care must be taken that things are not changed 
@en under the iterators, so use the @code{FOR_EACH_IMM_USE_STMT} and 
@en @code{FOR_EACH_IMM_USE_ON_STMT} iterators.  They attempt to preserve the 
@en sanity of the use list by moving all the uses for a statement into 
@en a controlled position, and then iterating over those uses.  Then the 
@en optimization can manipulate the stmt when all the uses have been
@en processed.  This is a little slower than the FAST version since it adds a 
@en placeholder element and must sort through the list a bit for each statement.  
@en This placeholder element must be also be removed if the loop is 
@en terminated early.  The macro @code{BREAK_FROM_IMM_USE_SAFE} is provided 
@en to do this :
如果确实要做改变，则必须要考虑到迭代器下没有被改变的事物，这时，
可以使用@code{FOR_EACH_IMM_USE_STMT}和@code{FOR_EACH_IMM_USE_ON_STMT}迭代器。
它们试图通过将语句的所有use移动到一个被控制的位置并对它们进行迭代的方式，
来保证use列表的完整性。然后优化就能够在所有的use被处理完后来操作stmt。
这比FAST版本的有点慢，因为它增加了一个占位元素并且必须对每条语句的列表进行排序。
如果循环被提前终止，则该占位元素还必须被移除。
宏@code{BREAK_FROM_IMM_USE_SAFE}用于做这个：

@smallexample
  FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)
    @{
      if (stmt == last_stmt)
        BREAK_FROM_SAFE_IMM_USE (iter);

      FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
        SET_USE (imm_use_p, ssa_var_2);
      fold_stmt (stmt);
    @}
@end smallexample

@en There are checks in @code{verify_ssa} which verify that the immediate use list
@en is up to date, as well as checking that an optimization didn't break from the 
@en loop without using this macro.  It is safe to simply 'break'; from a 
@en @code{FOR_EACH_IMM_USE_FAST} traverse.
在@code{verify_ssa}中有一些检测用来验证immediate use列表是最新的，
同时还检测一个优化是否没有使用该宏而中断循环。
在@code{FOR_EACH_IMM_USE_FAST}遍历中，直接使用'break'语句是安全的。

@en Some useful functions and macros:
@en @enumerate
@en @item  @code{has_zero_uses (ssa_var)} : Returns true if there are no uses of
@en @code{ssa_var}.
@en @item   @code{has_single_use (ssa_var)} : Returns true if there is only a 
@en single use of @code{ssa_var}.
@en @item   @code{single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)} :
@en Returns true if there is only a single use of @code{ssa_var}, and also returns
@en the use pointer and statement it occurs in, in the second and third parameters.
@en @item   @code{num_imm_uses (ssa_var)} : Returns the number of immediate uses of
@en @code{ssa_var}. It is better not to use this if possible since it simply
@en utilizes a loop to count the uses.
@en @item  @code{PHI_ARG_INDEX_FROM_USE (use_p)} : Given a use within a @code{PHI}
@en node, return the index number for the use.  An assert is triggered if the use
@en isn't located in a @code{PHI} node.
@en @item  @code{USE_STMT (use_p)} : Return the statement a use occurs in.
@en @end enumerate
一些有用的函数和宏：
@enumerate
@item  @code{has_zero_uses (ssa_var)} : 如果没有@code{ssa_var}的使用，则返回真。
@item   @code{has_single_use (ssa_var)} : 
如果只有@code{ssa_var}的单个使用，则返回真。
@item   @code{single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)} :
如果只有@code{ssa_var}的单个使用，则返回真，
并且还在第二和第三个参数中返回使用指针和所在的语句。
@item   @code{num_imm_uses (ssa_var)} : 
返回@code{ssa_var}的immediate use的数目。最好不要使用该宏，
因为它只是简单的使用循环来统计use。
@item  @code{PHI_ARG_INDEX_FROM_USE (use_p)} : 
给定一个在@code{PHI}节点中的use，返回use的索引数。
如果use不位于@code{PHI}节点中，则会触发一个断言。
@item  @code{USE_STMT (use_p)} : 返回use所在的语句。
@end enumerate

@en Note that uses are not put into an immediate use list until their statement is
@en actually inserted into the instruction stream via a @code{bsi_*} routine.  
注意在语句通过@code{bsi_*}程序被实际插入指令流中之前，
use是不被放入immediate use列表中的。

@en It is also still possible to utilize lazy updating of statements, but this 
@en should be used only when absolutely required.  Both alias analysis and the 
@en dominator optimizations currently do this.  
还可以使用懒散的语句更新方式，不过这应该在确实需要的时候才使用。
别名分析和dominator优化目前都采用了这种方式。

@en When lazy updating is being used, the immediate use information is out of date 
@en and cannot be used reliably.  Lazy updating is achieved by simply marking
@en statements modified via calls to @code{mark_stmt_modified} instead of 
@en @code{update_stmt}.  When lazy updating is no longer required, all the 
@en modified statements must have @code{update_stmt} called in order to bring them 
@en up to date.  This must be done before the optimization is finished, or 
@en @code{verify_ssa} will trigger an abort.
当使用懒散更新（lazy updating）时，immediate use信息是过时的，不能被信赖。
懒散更新简单的调用@code{mark_stmt_modified}来标记语句被修改了，
而不使用@code{update_stmt}。当不再需要进行懒散更新时，
所有修改的语句都必须调用@code{update_stmt}来保持更新。
这必须在优化完成之前进行，否则@code{verify_ssa}将触发abort 异常中断。

@en This is done with a simple loop over the instruction stream:
这是通过对指令流进行简单的循环来实现的：

@smallexample
  block_stmt_iterator bsi;
  basic_block bb;
  FOR_EACH_BB (bb)
    @{
      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))
        update_stmt_if_modified (bsi_stmt (bsi));
    @}
@end smallexample

@en @node SSA
@en @section Static Single Assignment
@node SSA
@section 静态单赋值
@cindex SSA
@cindex static single assignment

@en Most of the tree optimizers rely on the data flow information provided
@en by the Static Single Assignment (SSA) form.  We implement the SSA form
@en as described in @cite{R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and
@en K. Zadeck.  Efficiently Computing Static Single Assignment Form and the
@en Control Dependence Graph.  ACM Transactions on Programming Languages
@en and Systems, 13(4):451-490, October 1991}.
大多数树优化器都依赖于静态单赋值（SSA）形式所提供的数据流信息。
我们是按照@cite{R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and
K. Zadeck.  Efficiently Computing Static Single Assignment Form and the
Control Dependence Graph.  ACM Transactions on Programming Languages
and Systems, 13(4):451-490, October 1991}中的描述来实现SSA形式的。

@en The SSA form is based on the premise that program variables are
@en assigned in exactly one location in the program.  Multiple assignments
@en to the same variable create new versions of that variable.  Naturally,
@en actual programs are seldom in SSA form initially because variables
@en tend to be assigned multiple times.  The compiler modifies the program
@en representation so that every time a variable is assigned in the code,
@en a new version of the variable is created.  Different versions of the
@en same variable are distinguished by subscripting the variable name with
@en its version number.  Variables used in the right-hand side of
@en expressions are renamed so that their version number matches that of
@en the most recent assignment.
SSA形式基于的前提是程序变量只在程序中的一个位置被赋值。
对同一变量的多次赋值将创建那个变量的新的版本。
实际的程序最初自然很少是SSA形式的，因为变量一般会被赋值多次。
编译器修改程序表示，使得代码中每次变量被赋值的时候，便会创建一个新版本的变量。
不同版本的同一变量通过变量名字的版本号作为下标来区分开。
在表达式右端使用的变量被重命名，使得它们的版本号匹配最近的赋值。

@en We represent variable versions using @code{SSA_NAME} nodes.  The
@en renaming process in @file{tree-ssa.c} wraps every real and
@en virtual operand with an @code{SSA_NAME} node which contains
@en the version number and the statement that created the
@en @code{SSA_NAME}.  Only definitions and virtual definitions may
@en create new @code{SSA_NAME} nodes.
我们使用@code{SSA_NAME}节点来表示变量版本。
@file{tree-ssa.c}中的重命名程序将每个实操作数和虚操作数，
用包含了版本号和创建@code{SSA_NAME}的语句的@code{SSA_NAME}节点包裹起来。
只有定义和虚定义可能会创建新的@code{SSA_NAME}节点。

@cindex PHI nodes
@en Sometimes, flow of control makes it impossible to determine the
@en most recent version of a variable.  In these cases, the compiler
@en inserts an artificial definition for that variable called
@en @dfn{PHI function} or @dfn{PHI node}.  This new definition merges
@en all the incoming versions of the variable to create a new name
@en for it.  For instance,
有时，控制流使得无法确定变量的最近版本是多少。这种情况下，
编译器插入一个那个变量的人造定义，称作@dfn{PHI function}或者@dfn{PHI node}。
这个新的定义将变量的所有可能引入的版本合并一起，以创建一个新的名字。例如，

@smallexample
if (@dots{})
  a_1 = 5;
else if (@dots{})
  a_2 = 2;
else
  a_3 = 13;

# a_4 = PHI <a_1, a_2, a_3>
return a_4;
@end smallexample

@en Since it is not possible to determine which of the three branches
@en will be taken at runtime, we don't know which of @code{a_1},
@en @code{a_2} or @code{a_3} to use at the return statement.  So, the
@en SSA renamer creates a new version @code{a_4} which is assigned
@en the result of ``merging'' @code{a_1}, @code{a_2} and @code{a_3}.
@en Hence, PHI nodes mean ``one of these operands.  I don't know
@en which''.
由于不可能确定在运行时，将运行三个分支中的哪一个，
所以我们不知道在return语句中要使用@code{a_1},@code{a_2}或@code{a_3}中的哪一个。
因此，SSA重命名将会创建一个新的版本a_4，其被赋值为“合并”a_1, a_2和a_3的结果。
因此，PHI节点意味着“这些操作数中的一个，我不知道是哪一个”。

@en The following macros can be used to examine PHI nodes
下面的宏可以用来检查PHI节点。

@defmac PHI_RESULT (@var{phi})
@en Returns the @code{SSA_NAME} created by PHI node @var{phi} (i.e.,
@en @var{phi}'s LHS)@.
返回由PHI节点@var{phi}(即, @var{phi}'s LHS)创建的@code{SSA_NAME}。
@end defmac

@defmac PHI_NUM_ARGS (@var{phi})
@en Returns the number of arguments in @var{phi}.  This number is exactly
@en the number of incoming edges to the basic block holding @var{phi}@.
返回@var{phi}中的参数个数。这个数目就是持有@var{phi}的基本块所引入的边的数目。
@end defmac

@defmac PHI_ARG_ELT (@var{phi}, @var{i})
@en Returns a tuple representing the @var{i}th argument of @var{phi}@.
@en Each element of this tuple contains an @code{SSA_NAME} @var{var} and
@en the incoming edge through which @var{var} flows.
返回@var{phi}的第@var{i}个参数的tuple表示。
tuple中的每个元素包含了一个@code{SSA_NAME} @var{var}和@var{var}借以流向的引入边。
@end defmac

@defmac PHI_ARG_EDGE (@var{phi}, @var{i})
@en Returns the incoming edge for the @var{i}th argument of @var{phi}.
返回@var{phi}的第@var{i}个参数对应的引入边。
@end defmac

@defmac PHI_ARG_DEF (@var{phi}, @var{i})
@en Returns the @code{SSA_NAME} for the @var{i}th argument of @var{phi}.
返回@var{phi}的第@var{i}个参数的@code{SSA_NAME}。
@end defmac


@en @subsection Preserving the SSA form
@subsection 保持SSA形式
@findex update_ssa
@cindex preserving SSA form
@en Some optimization passes make changes to the function that
@en invalidate the SSA property.  This can happen when a pass has
@en added new symbols or changed the program so that variables that
@en were previously aliased aren't anymore.  Whenever something like this
@en happens, the affected symbols must be renamed into SSA form again.  
@en Transformations that emit new code or replicate existing statements
@en will also need to update the SSA form@.
一些优化过程会改变函数并使得不再具有SSA特性。
这可能会发生在当一个过程增加了新的符号或者改变了程序使得变量不再被别名的时候。
不管什么时候发生类似的情况，受到影响的符号必须被再次重命名为SSA形式。
产生新代码或者替代存在的语句的转换也需要更新SSA形式。

@en Since GCC implements two different SSA forms for register and virtual
@en variables, keeping the SSA form up to date depends on whether you are
@en updating register or virtual names.  In both cases, the general idea
@en behind incremental SSA updates is similar: when new SSA names are
@en created, they typically are meant to replace other existing names in
@en the program@.
由于GCC为寄存器和虚变量实现了两种不同的SSA形式，
所有保持SSA形式的更新取决于你是否正在更新寄存器或者虚名字。
这两种情况对于不断的SSA更新的背后思想是类似的：当新的SSA名字被创建时，
它们通常意味着要替换程序中的其它存在的名字。

@en For instance, given the following code:
例如，给定下列代码：

@smallexample
     1  L0:
     2  x_1 = PHI (0, x_5)
     3  if (x_1 < 10)
     4    if (x_1 > 7)
     5      y_2 = 0
     6    else
     7      y_3 = x_1 + x_7
     8    endif
     9    x_5 = x_1 + 1
     10   goto L0;
     11 endif
@end smallexample

@en Suppose that we insert new names @code{x_10} and @code{x_11} (lines
@en @code{4} and @code{8})@.
假设我们插入了新的名字@code{x_10}和@code{x_11}（第@code{4}行和第@code{8}行）。

@smallexample
     1  L0:
     2  x_1 = PHI (0, x_5)
     3  if (x_1 < 10)
     4    x_10 = @dots{}
     5    if (x_1 > 7)
     6      y_2 = 0
     7    else
     8      x_11 = @dots{}
     9      y_3 = x_1 + x_7
     10   endif
     11   x_5 = x_1 + 1
     12   goto L0;
     13 endif
@end smallexample

@en We want to replace all the uses of @code{x_1} with the new definitions
@en of @code{x_10} and @code{x_11}.  Note that the only uses that should
@en be replaced are those at lines @code{5}, @code{9} and @code{11}.
@en Also, the use of @code{x_7} at line @code{9} should @emph{not} be
@en replaced (this is why we cannot just mark symbol @code{x} for
@en renaming)@.
我们想使用@code{x_10}和@code{x_11}的新的定义来替换@code{x_1}的所有使用。
注意将要被替换的使用只在行@code{5}, @code{9}和@code{11}中。而且，
第@code{9}行@code{x_7}的使用不应被替换
（这就是为什么我们不能仅仅标记符号@code{x}为重命名）。

@en Additionally, we may need to insert a PHI node at line @code{11}
@en because that is a merge point for @code{x_10} and @code{x_11}.  So the
@en use of @code{x_1} at line @code{11} will be replaced with the new PHI
@en node.  The insertion of PHI nodes is optional.  They are not strictly
@en necessary to preserve the SSA form, and depending on what the caller
@en inserted, they may not even be useful for the optimizers@.
另外，我们可能需要在第@code{11}行插入一个PHI节点，
因为有一个@code{x_10}和@code{x_11}的合并点。
所以@code{x_1}在第@code{11}行的使用将用新的PHI节点来替换。
PHI节点的插入是可选的。它们并不完全必要用于保持SSA形式，
并且取决于调用者的插入内容，它们可能对优化器没有用处。

@en Updating the SSA form is a two step process.  First, the pass has to
@en identify which names need to be updated and/or which symbols need to
@en be renamed into SSA form for the first time.  When new names are
@en introduced to replace existing names in the program, the mapping
@en between the old and the new names are registered by calling
@en @code{register_new_name_mapping} (note that if your pass creates new
@en code by duplicating basic blocks, the call to @code{tree_duplicate_bb}
@en will set up the necessary mappings automatically).  On the other hand,
@en if your pass exposes a new symbol that should be put in SSA form for
@en the first time, the new symbol should be registered with
@en @code{mark_sym_for_renaming}.
更新SSA形式分为两步。首先，过程必须分别出哪些名字需要被更新，
以及哪些符号需要被重命名为SSA形式。当新的名字被引入以替换程序中现存的名字时，
新旧名字之间的映射通过调用@code{register_new_name_mapping}来注册
（注意如果你的过程通过复制基本块创建了新的代码，
对@code{tree_duplicate_bb}的调用将会自动建立所需的映射）。另一方面，
如果你的过程使得一个新的符号需要为SSA形式，
则新符号需要使用@code{mark_sym_for_renaming}来注册。

@en After the replacement mappings have been registered and new symbols
@en marked for renaming, a call to @code{update_ssa} makes the registered
@en changes.  This can be done with an explicit call or by creating
@en @code{TODO} flags in the @code{tree_opt_pass} structure for your pass.
@en There are several @code{TODO} flags that control the behavior of
@en @code{update_ssa}:
在替换映射被注册完，并且新符号被标记了要重命名后，
将会调用@code{update_ssa}来按照注册的进行改变。
这可以通过显示的调用或者为你的过程在@code{tree_opt_pass}结构体中创建
@code{TODO}标记来完成。
这里有几个@code{TODO}标记用于控制@code{update_ssa}的行为：

@itemize @bullet
@en @item @code{TODO_update_ssa}.  Update the SSA form inserting PHI nodes
@en for newly exposed symbols and virtual names marked for updating.
@en When updating real names, only insert PHI nodes for a real name
@en @code{O_j} in blocks reached by all the new and old definitions for
@en @code{O_j}.  If the iterated dominance frontier for @code{O_j}
@en is not pruned, we may end up inserting PHI nodes in blocks that
@en have one or more edges with no incoming definition for
@en @code{O_j}.  This would lead to uninitialized warnings for
@en @code{O_j}'s symbol@.
@item @code{TODO_update_ssa}.  
采用为新出现的符号插入PHI节点，以及虚名字进行标记的方式更新SSA形式。
当更新实名字时，只为@code{O_j}的所有新旧定义所到达的块中的实名字@code{O_j}
插入PHI节点。如果@code{O_j}的迭代的dominance边界没有被截枝，
我们可以在块中危机具有一个或多个没有即来定义的@code{O_j}结束插入PHI节点。
这将导致对@code{O_j}符号的未初始化警告。

@en @item @code{TODO_update_ssa_no_phi}.  Update the SSA form without
@en inserting any new PHI nodes at all.  This is used by passes that
@en have either inserted all the PHI nodes themselves or passes that
@en need only to patch use-def and def-def chains for virtuals
@en (e.g., DCE)@.
@item @code{TODO_update_ssa_no_phi}. 
不使用插入任何新PHI节点的方式来更新SSA形式。这被用于要自己插入所有PHI节点的
过程或者只需要更新use-def和def-def链的虚名字的过程（例如，DCE）。

@en @item @code{TODO_update_ssa_full_phi}.  Insert PHI nodes everywhere
@en they are needed.  No pruning of the IDF is done.  This is used
@en by passes that need the PHI nodes for @code{O_j} even if it
@en means that some arguments will come from the default definition
@en of @code{O_j}'s symbol (e.g., @code{pass_linear_transform})@.
@item @code{TODO_update_ssa_full_phi}.  
在任何需要的地方都插入PHI节点。不进行IDF的截枝。
这被过程用于需要@code{O_j}的PHI节点的情况
（例如，@code{pass_linear_transform}）。

@en WARNING: If you need to use this flag, chances are that your
@en pass may be doing something wrong.  Inserting PHI nodes for an
@en old name where not all edges carry a new replacement may lead to
@en silent codegen errors or spurious uninitialized warnings@.
警告: 如果你需要使用这个标记，则有可能你的过程是在做一些错误的事情。
为一个旧名字插入PHI节点可能会导致沉默的codegen错误或者虚假的未初始化警告。

@en @item @code{TODO_update_ssa_only_virtuals}.  Passes that update the
@en SSA form on their own may want to delegate the updating of
@en virtual names to the generic updater.  Since FUD chains are
@en easier to maintain, this simplifies the work they need to do.
@en NOTE: If this flag is used, any OLD->NEW mappings for real names
@en are explicitly destroyed and only the symbols marked for
@en renaming are processed@.
@item @code{TODO_update_ssa_only_virtuals}.  
自己更新SSA的过程可能想要使用虚名字更新来代表通用的更新。因为FUD链易于维护，
所有这简化了他们所需的工作。注意：如果使用了该标记，
则任何实名字OLD->NEW的映射将被显式的破坏，只有标记为重命名的符合被处理。
@end itemize

@en @subsection Preserving the virtual SSA form
@subsection 保持虚SSA形式
@cindex preserving virtual SSA form

@en The virtual SSA form is harder to preserve than the non-virtual SSA form
@en mainly because the set of virtual operands for a statement may change at
@en what some would consider unexpected times.  In general, statement
@en modifications should be bracketed between calls to
@en @code{push_stmt_changes} and @code{pop_stmt_changes}.  For example,
虚SSA形式比非虚SSA形式要难以保持，主要是因为语句的虚操作数集可能会意外的改变。
通常，语句修改应该被对@code{push_stmt_changes}和@code{pop_stmt_changes}的调用
所包裹。例如，

@smallexample
    munge_stmt (tree stmt)
    @{
       push_stmt_changes (&stmt);
       @dots{} rewrite STMT @dots{}
       pop_stmt_changes (&stmt);
    @}
@end smallexample

@en The call to @code{push_stmt_changes} saves the current state of the
@en statement operands and the call to @code{pop_stmt_changes} compares
@en the saved state with the current one and does the appropriate symbol
@en marking for the SSA renamer.
对@code{push_stmt_changes}的调用保存了语句操作数的当前状态，
对@code{pop_stmt_changes}的调用比较保存的状态和现在的，
并对适当的符号标记为SSA重命名。

@en It is possible to modify several statements at a time, provided that
@en @code{push_stmt_changes} and @code{pop_stmt_changes} are called in
@en LIFO order, as when processing a stack of statements.
当处理一个语句栈时，通过使用LIFO顺序来调用@code{push_stmt_changes}和
@code{pop_stmt_changes}，可以一次修改多条语句。

@en Additionally, if the pass discovers that it did not need to make
@en changes to the statement after calling @code{push_stmt_changes}, it
@en can simply discard the topmost change buffer by calling
@en @code{discard_stmt_changes}.  This will avoid the expensive operand
@en re-scan operation and the buffer comparison that determines if symbols
@en need to be marked for renaming.
另外，如果过程在调用@code{push_stmt_changes}后发现它不需要改变语句，
它可以通过调用@code{discard_stmt_changes}来简单的丢弃最顶层的缓存。
这将避免用来确定是否符合需要被标记为重命名所需的昂贵的操作数重扫描操作和缓存比较。

@en @subsection Examining @code{SSA_NAME} nodes
@subsection 检验@code{SSA_NAME}节点
@cindex examining SSA_NAMEs

@en The following macros can be used to examine @code{SSA_NAME} nodes
下面的宏可以用来检查@code{SSA_NAME}节点

@defmac SSA_NAME_DEF_STMT (@var{var})
@en Returns the statement @var{s} that creates the @code{SSA_NAME}
@en @var{var}.  If @var{s} is an empty statement (i.e., @code{IS_EMPTY_STMT
@en (@var{s})} returns @code{true}), it means that the first reference to
@en this variable is a USE or a VUSE@.
返回创建@code{SSA_NAME} @var{var}的语句@var{s}。
如过@var{s}是空语句（即，@code{IS_EMPTY_STMT (@var{s})}返回@code{true}），
则意味着对该变量的第一个引用是一个USE或者VUSE。
@end defmac

@defmac SSA_NAME_VERSION (@var{var})
@en Returns the version number of the @code{SSA_NAME} object @var{var}.
返回@code{SSA_NAME}对象@var{var}的版本号。
@end defmac

@en @subsection Walking use-def chains
@subsection 遍历use-def链

@deftypefn {Tree SSA function} void walk_use_def_chains (@var{var}, @var{fn}, @var{data})

@en Walks use-def chains starting at the @code{SSA_NAME} node @var{var}.
@en Calls function @var{fn} at each reaching definition found.  Function
@en @var{FN} takes three arguments: @var{var}, its defining statement
@en (@var{def_stmt}) and a generic pointer to whatever state information
@en that @var{fn} may want to maintain (@var{data}).  Function @var{fn} is
@en able to stop the walk by returning @code{true}, otherwise in order to
@en continue the walk, @var{fn} should return @code{false}.
对use-def链的遍历起始于@code{SSA_NAME}节点@var{var}。
对每一个发现的可达定义调用函数@var{fn}。函数@var{fn}接受三个参数：@var{var}，
它的定义语句（@var{def_stmt}）和一个通用指针指向@var{fn}可能想要维护的任何状态
信息（数据）。函数@var{fn}可以通过返回@code{true}来停止遍历，否则要继续遍历，
@var{fn}应该返回@code{false}。

@en Note, that if @var{def_stmt} is a @code{PHI} node, the semantics are
@en slightly different.  For each argument @var{arg} of the PHI node, this
@en function will:
注意，如果@var{def_stmt}是一个@code{PHI}节点，则语法有点不同。
对PHI节点的每个参数@var{arg}，该函数将：

@enumerate
@en @item Walk the use-def chains for @var{arg}.
@item 为@var{arg}遍历use-def链
@en @item Call @code{FN (@var{arg}, @var{phi}, @var{data})}.
@item 调用@code{FN (@var{arg}, @var{phi}, @var{data})}.
@end enumerate

@en Note how the first argument to @var{fn} is no longer the original
@en variable @var{var}, but the PHI argument currently being examined.
@en If @var{fn} wants to get at @var{var}, it should call
@en @code{PHI_RESULT} (@var{phi}).
注意不管@var{fn}的第一个是否还是最初的变量@var{var}，目前都会检测PHI的参数。
如果@var{fn}想获得@var{var}，则应该调用@code{PHI_RESULT} (@var{phi})。
@end deftypefn

@en @subsection Walking the dominator tree
@subsection 遍历支配树

@deftypefn {Tree SSA function} void walk_dominator_tree (@var{walk_data}, @var{bb})

@en This function walks the dominator tree for the current CFG calling a
@en set of callback functions defined in @var{struct dom_walk_data} in
@en @file{domwalk.h}.  The call back functions you need to define give you
@en hooks to execute custom code at various points during traversal:
该函数遍历当前CFG的支配树，
并调用在@file{domwalk.h}中@var{struct dom_walk_data}里定义的一系列回调函数。
你所需要定义的回调函数可以用于在遍历过程中的不同点执行自定义的代码：

@enumerate
@en @item Once to initialize any local data needed while processing
@en @var{bb} and its children.  This local data is pushed into an
@en internal stack which is automatically pushed and popped as the
@en walker traverses the dominator tree.
@item 
当处理@var{bb}和它的孩子（children）时，在初始化所需要的任何局部数据的时候。
该局部数据被压入一个内部的栈中，该栈在遍历支配树时会被自动的压入和弹出。

@en @item Once before traversing all the statements in the @var{bb}.
@item 在遍历@var{bb}中的所有语句之前。

@en @item Once for every statement inside @var{bb}.
@item 对于@var{bb}中的每条语句。

@en @item Once after traversing all the statements and before recursing
@en into @var{bb}'s dominator children.
@item 当遍历过所有语句之后，并在递归到@var{bb}的支配孩子之前。

@en @item It then recurses into all the dominator children of @var{bb}.
@item 然后递归到@var{bb}的所有支配孩子。

@en @item After recursing into all the dominator children of @var{bb} it
@en can, optionally, traverse every statement in @var{bb} again
@en (i.e., repeating steps 2 and 3).
@item 
在递归到@var{bb}的所有支配孩子之后，可选的，
重新遍历@var{bb}中的每条语句（即，重复步骤2和3）。

@en @item Once after walking the statements in @var{bb} and @var{bb}'s
@en dominator children.  At this stage, the block local data stack
@en is popped.
@item 
当遍历完@var{bb}和@var{bb}的支配孩子中的所有语句之后。这时，块局部数据栈被弹出。
@end enumerate
@end deftypefn

@en @node Alias analysis
@en @section Alias analysis
@node Alias analysis
@section 别名分析
@cindex alias
@cindex flow-sensitive alias analysis
@cindex flow-insensitive alias analysis

Alias analysis in GIMPLE SSA form consists of two pieces.  First
the virtual SSA web ties conflicting memory accesses and provides
a SSA use-def chain and SSA immediate-use chains for walking
possibly dependent memory accesses.  Second an alias-oracle can
be queried to disambiguate explicit and implicit memory references.

@enumerate
@item Memory SSA form.

All statements that may use memory have exactly one accompanied use of
a virtual SSA name that represents the state of memory at the
given point in the IL.

All statements that may define memory have exactly one accompanied
definition of a virtual SSA name using the previous state of memory
and defining the new state of memory after the given point in the IL.

@smallexample
int i;
int foo (void)
@{
  # .MEM_3 = VDEF <.MEM_2(D)>
  i = 1;
  # VUSE <.MEM_3>
  return i;
@}
@end smallexample

The virtual SSA names in this case are @code{.MEM_2(D)} and
@code{.MEM_3}.  The store to the global variable @code{i}
defines @code{.MEM_3} invalidating @code{.MEM_2(D)}.  The
load from @code{i} uses that new state @code{.MEM_3}.

The virtual SSA web serves as constraints to SSA optimizers
preventing illegitimate code-motion and optimization.  It
also provides a way to walk related memory statements.

@item Points-to and escape analysis.

Points-to analysis builds a set of constraints from the GIMPLE
SSA IL representing all pointer operations and facts we do
or do not know about pointers.  Solving this set of constraints
yields a conservatively correct solution for each pointer
variable in the program (though we are only interested in
SSA name pointers) as to what it may possibly point to.

This points-to solution for a given SSA name pointer is stored
in the @code{pt_solution} sub-structure of the
@code{SSA_NAME_PTR_INFO} record.  The following accessor
functions are available:

@itemize @bullet
@item @code{pt_solution_includes}
@item @code{pt_solutions_intersect}
@end itemize

Points-to analysis also computes the solution for two special
set of pointers, @code{ESCAPED} and @code{CALLUSED}.  Those
represent all memory that has escaped the scope of analysis
or that is used by pure or nested const calls.

@item Type-based alias analysis

Type-based alias analysis is frontend dependent though generic
support is provided by the middle-end in @code{alias.c}.  TBAA
code is used by both tree optimizers and RTL optimizers.

Every language that wishes to perform language-specific alias analysis
should define a function that computes, given a @code{tree}
node, an alias set for the node.  Nodes in different alias sets are not
allowed to alias.  For an example, see the C front-end function
@code{c_get_alias_set}.

@item Tree alias-oracle

The tree alias-oracle provides means to disambiguate two memory
references and memory references against statements.  The following
queries are available:

@itemize @bullet
@item @code{refs_may_alias_p}
@item @code{ref_maybe_used_by_stmt_p}
@item @code{stmt_may_clobber_ref_p}
@end itemize

In addition to those two kind of statement walkers are available
walking statements related to a reference ref.
@code{walk_non_aliased_vuses} walks over dominating memory defining
statements and calls back if the statement does not clobber ref
providing the non-aliased VUSE.  The walk stops at
the first clobbering statement or if asked to.
@code{walk_aliased_vdefs} walks over dominating memory defining
statements and calls back on each statement clobbering ref
providing its aliasing VDEF.  The walk stops if asked to.

@end enumerate


@node Memory model
@section Memory model
@cindex memory model

The memory model used by the middle-end models that of the C/C++
languages.  The middle-end has the notion of an effective type
of a memory region which is used for type-based alias analysis.

The following is a refinement of ISO C99 6.5/6, clarifying the block copy case
to follow common sense and extending the concept of a dynamic effective
type to objects with a declared type as required for C++.

@smallexample
The effective type of an object for an access to its stored value is
the declared type of the object or the effective type determined by
a previous store to it.  If a value is stored into an object through
an lvalue having a type that is not a character type, then the
type of the lvalue becomes the effective type of the object for that
access and for subsequent accesses that do not modify the stored value.
If a value is copied into an object using @code{memcpy} or @code{memmove},
or is copied as an array of character type, then the effective type
of the modified object for that access and for subsequent accesses that
do not modify the value is undetermined.  For all other accesses to an
object, the effective type of the object is simply the type of the
lvalue used for the access.
@end smallexample

