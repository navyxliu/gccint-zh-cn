<html lang="zh">
<head>
<title>Costs - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Macros.html#Target-Macros" title="Target Macros">
<link rel="prev" href="Condition-Code.html#Condition-Code" title="Condition Code">
<link rel="next" href="Scheduling.html#Scheduling" title="Scheduling">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Costs"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Scheduling.html#Scheduling">Scheduling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Condition-Code.html#Condition-Code">Condition Code</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Macros.html#Target-Macros">Target Macros</a>
<hr>
</div>

<h3 class="section">17.17 描述操作的相对代价</h3>

<p><a name="index-costs-of-instructions-4336"></a><a name="index-relative-costs-4337"></a><a name="index-speed-of-instructions-4338"></a>
<!-- These macros let you describe the relative speed of various operations -->
<!-- on the target machine. -->
这些宏让你描述target机器上各种操作的相对速度。

<div class="defun">
&mdash; Macro: <b>REGISTER_MOVE_COST</b> (<var>mode, from, to</var>)<var><a name="index-REGISTER_005fMOVE_005fCOST-4339"></a></var><br>
<blockquote><!-- A C expression for the cost of moving data of mode @var{mode} from a -->
     <!-- register in class @var{from} to one in class @var{to}.  The classes are -->
     <!-- expressed using the enumeration values such as @code{GENERAL_REGS}.  A -->
     <!-- value of 2 is the default; other values are interpreted relative to -->
     <!-- that. -->
      <p>一个C表达式，
为从寄存器类别<var>from</var>到类别<var>to</var>移动模式为<var>mode</var>的数据的代价。
类别使用枚举值表示，例如<code>GENERAL_REGS</code>。缺省值为2；其它值相对于它来解析。

     <!-- It is not required that the cost always equal 2 when @var{from} is the -->
     <!-- same as @var{to}; on some machines it is expensive to move between -->
     <!-- registers if they are not general registers. -->
      <p>当<var>from</var>与<var>to</var>相同时，并不要求代价总是为2；在一些机器上，
如果不是通用寄存器，则寄存器之间的移动代价是昂贵的。

     <!-- If reload sees an insn consisting of a single @code{set} between two -->
     <!-- hard registers, and if @code{REGISTER_MOVE_COST} applied to their -->
     <!-- classes returns a value of 2, reload does not check to ensure that the -->
     <!-- constraints of the insn are met.  Setting a cost of other than 2 will -->
     <!-- allow reload to verify that the constraints are met.  You should do this -->
     <!-- if the @samp{mov@var{m}} pattern's constraints do not allow such copying. -->
      <p>如果重载遇到一个insn，由两个硬件寄存器之间的单个<code>set</code>组成，
并且如果<code>REGISTER_MOVE_COST</code>应用到它们的类别上返回2，
则重载不检查insn的约束是否满足。将代价设为2以外的值将允许重载验证约束是否满足。
如果&lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo;模式的约束不允许这样的复制，则你应该这样做。

      <p>These macros are obsolete, new ports should use the target hook
<code>TARGET_REGISTER_MOVE_COST</code> instead. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_REGISTER_MOVE_COST</b> (<var>enum machine_mode mode, reg_class_t from, reg_class_t to</var>)<var><a name="index-TARGET_005fREGISTER_005fMOVE_005fCOST-4340"></a></var><br>
<blockquote><p>This target hook should return the cost of moving data of mode <var>mode</var>
from a register in class <var>from</var> to one in class <var>to</var>.  The classes
are expressed using the enumeration values such as <code>GENERAL_REGS</code>. 
A value of 2 is the default; other values are interpreted relative to
that.

      <p>It is not required that the cost always equal 2 when <var>from</var> is the
same as <var>to</var>; on some machines it is expensive to move between
registers if they are not general registers.

      <p>If reload sees an insn consisting of a single <code>set</code> between two
hard registers, and if <code>TARGET_REGISTER_MOVE_COST</code> applied to their
classes returns a value of 2, reload does not check to ensure that the
constraints of the insn are met.  Setting a cost of other than 2 will
allow reload to verify that the constraints are met.  You should do this
if the &lsquo;<samp><span class="samp">mov</span><var>m</var></samp>&rsquo; pattern's constraints do not allow such copying.

      <p>The default version of this function returns 2. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MEMORY_MOVE_COST</b> (<var>mode, class, in</var>)<var><a name="index-MEMORY_005fMOVE_005fCOST-4341"></a></var><br>
<blockquote><!-- A C expression for the cost of moving data of mode @var{mode} between a -->
     <!-- register of class @var{class} and memory; @var{in} is zero if the value -->
     <!-- is to be written to memory, nonzero if it is to be read in.  This cost -->
     <!-- is relative to those in @code{REGISTER_MOVE_COST}.  If moving between -->
     <!-- registers and memory is more expensive than between two registers, you -->
     <!-- should define this macro to express the relative cost. -->
      <p>一个C表达式，
为在寄存器类别<var>class</var>和内存之间移动模式为<var>mode</var>的数据的代价；
<var>in</var>为0，如果值要被写到内存中，非0，如果要从内存中读进。
该代价为<code>REGISTER_MOVE_COST</code>的相对值。
如果在寄存器和内存间移动比两个寄存器之间更昂贵，则应该定义该宏来表示相对代价。

     <!-- If you do not define this macro, GCC uses a default cost of 4 plus -->
     <!-- the cost of copying via a secondary reload register, if one is -->
     <!-- needed.  If your machine requires a secondary reload register to copy -->
     <!-- between memory and a register of @var{class} but the reload mechanism is -->
     <!-- more complex than copying via an intermediate, define this macro to -->
     <!-- reflect the actual cost of the move. -->
      <p>如果你没有定义该宏，如果需要的话，
则GCC使用缺省值4加上通过第二个重载寄存器复制的代价。
如果你的机器需要第二个重载寄存器在内存和寄存器类别<var>class</var>直接复制，
但是重载机制比通过中间物质复制更复杂，则定义该宏来反映move的实际代价。

     <!-- GCC defines the function @code{memory_move_secondary_cost} if -->
     <!-- secondary reloads are needed.  It computes the costs due to copying via -->
     <!-- a secondary register.  If your machine copies from memory using a -->
     <!-- secondary register in the conventional way but the default base value of -->
     <!-- 4 is not correct for your machine, define this macro to add some other -->
     <!-- value to the result of that function.  The arguments to that function -->
     <!-- are the same as to this macro. -->
      <p>GCC定义函数<code>memory_move_secondary_cost</code>，如果需要第二次重载。
其根据通过第二个寄存器复制来计算代价。
如果你的机器使用第二个寄存器按照约定的方式从内存中复制，
但是缺省值4对你的机器不正确，则定义该宏来增加某个其它值作为那个函数的结果。
函数的参数与该宏相同。

      <p>These macros are obsolete, new ports should use the target hook
<code>TARGET_MEMORY_MOVE_COST</code> instead. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_MEMORY_MOVE_COST</b> (<var>enum machine_mode mode, reg_class_t rclass, bool in</var>)<var><a name="index-TARGET_005fMEMORY_005fMOVE_005fCOST-4342"></a></var><br>
<blockquote><p>This target hook should return the cost of moving data of mode <var>mode</var>
between a register of class <var>rclass</var> and memory; <var>in</var> is <code>false</code>
if the value is to be written to memory, <code>true</code> if it is to be read in. 
This cost is relative to those in <code>TARGET_REGISTER_MOVE_COST</code>. 
If moving between registers and memory is more expensive than between two
registers, you should add this target hook to express the relative cost.

      <p>If you do not add this target hook, GCC uses a default cost of 4 plus
the cost of copying via a secondary reload register, if one is
needed.  If your machine requires a secondary reload register to copy
between memory and a register of <var>rclass</var> but the reload mechanism is
more complex than copying via an intermediate, use this target hook to
reflect the actual cost of the move.

      <p>GCC defines the function <code>memory_move_secondary_cost</code> if
secondary reloads are needed.  It computes the costs due to copying via
a secondary register.  If your machine copies from memory using a
secondary register in the conventional way but the default base value of
4 is not correct for your machine, use this target hook to add some other
value to the result of that function.  The arguments to that function
are the same as to this target hook. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BRANCH_COST</b> (<var>speed_p, predictable_p</var>)<var><a name="index-BRANCH_005fCOST-4343"></a></var><br>
<blockquote><p>A C expression for the cost of a branch instruction.  A value of 1 is
the default; other values are interpreted relative to that. Parameter
<var>speed_p</var> is true when the branch in question should be optimized
for speed.  When it is false, <code>BRANCH_COST</code> should return a value
optimal for code size rather than performance.  <var>predictable_p</var> is
true for well-predicted branches. On many architectures the
<code>BRANCH_COST</code> can be reduced then. 
一个C表达式，为分支指令的代价。缺省值为1；其它值相对于它来解析。
</p></blockquote></div>

<!-- Here are additional macros which do not specify precise relative costs, -->
<!-- but only that certain actions are more expensive than GCC would -->
<!-- ordinarily expect. -->
 <p>这些是额外的宏，其不指定确切的相对代价，而只是指定特定的动作比GCC通常期望的要昂贵。

<div class="defun">
&mdash; Macro: <b>SLOW_BYTE_ACCESS</b><var><a name="index-SLOW_005fBYTE_005fACCESS-4344"></a></var><br>
<blockquote><!-- Define this macro as a C expression which is nonzero if accessing less -->
     <!-- than a word of memory (i.e.@: a @code{char} or a @code{short}) is no -->
     <!-- faster than accessing a word of memory, i.e., if such access -->
     <!-- require more than one instruction or if there is no difference in cost -->
     <!-- between byte and (aligned) word loads. -->
      <p>定义该宏为一个C表达式，如果访问小于一个字的内存
（即<code>char</code>或者<code>short</code>）不如访问一个字的内存快，即，
如果这样的访问需要多于一条的指令，并且如果字节和（对齐的）字加载的代价没有区别，
则值为非零。

     <!-- When this macro is not defined, the compiler will access a field by -->
     <!-- finding the smallest containing object; when it is defined, a fullword -->
     <!-- load will be used if alignment permits.  Unless bytes accesses are -->
     <!-- faster than word accesses, using word accesses is preferable since it -->
     <!-- may eliminate subsequent memory access if subsequent accesses occur to -->
     <!-- other fields in the same word of the structure, but to different bytes. -->
      <p>当该宏没有被定义，则编译器将通过找到最小的包含对象来访问一个域；当其被定义，
如果允许对齐，则会使用全字的加载。除非字节访问比字访问快，则使用字访问比较好，
因为其可以消除后续的内存访问，如果后续的访问发生在结构体的相同字的其它域。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SLOW_UNALIGNED_ACCESS</b> (<var>mode, alignment</var>)<var><a name="index-SLOW_005fUNALIGNED_005fACCESS-4345"></a></var><br>
<blockquote><!-- Define this macro to be the value 1 if memory accesses described by the -->
     <!-- @var{mode} and @var{alignment} parameters have a cost many times greater -->
     <!-- than aligned accesses, for example if they are emulated in a trap -->
     <!-- handler. -->
      <p>定义该宏的值为1，
如果由<var>mode</var>和<var>alignment</var>参数描述的内存访问比对齐的访问具有多倍的代价，
例如如果它们在陷阱处理中被模拟。

     <!-- When this macro is nonzero, the compiler will act as if -->
     <!-- @code{STRICT_ALIGNMENT} were nonzero when generating code for block -->
     <!-- moves.  This can cause significantly more instructions to be produced. -->
     <!-- Therefore, do not set this macro nonzero if unaligned accesses only add a -->
     <!-- cycle or two to the time for a memory access. -->
      <p>当该宏为非0时，编译器在为块移动生成代码时，
将按照<code>STRICT_ALIGNMENT</code>为非0的方式执行。这可以引起相当多的指令被产生。
因此如果非对齐访问只是增加一个周期或者两个，则不要设置该宏为非零。

     <!-- If the value of this macro is always zero, it need not be defined.  If -->
     <!-- this macro is defined, it should produce a nonzero value when -->
     <!-- @code{STRICT_ALIGNMENT} is nonzero. -->
      <p>如果该宏的值总是0，则不需要被定义。如果该宏被定义，其应该产生一个非0值，
当<code>STRICT_ALIGNMENT</code>非0时。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_RATIO</b> (<var>speed</var>)<var><a name="index-MOVE_005fRATIO-4346"></a></var><br>
<blockquote><!-- The threshold of number of scalar memory-to-memory move insns, @emph{below} -->
     <!-- which a sequence of insns should be generated instead of a -->
     <!-- string move insn or a library call.  Increasing the value will always -->
     <!-- make code faster, but eventually incurs high cost in increased code size. -->
      <p>标量的内存到内存的move insn的临界数，<em>低于</em>其值的时候，
应该生成一个insn序列，而不是字符串move insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

     <!-- Note that on machines where the corresponding move insn is a -->
     <!-- @code{define_expand} that emits a sequence of insns, this macro counts -->
     <!-- the number of such sequences. -->
      <p>注意在一些机器上，对应的move insn为一个<code>define_expand</code>，
其产生一个insn序列，则该宏为该序列的个数。

      <p>The parameter <var>speed</var> is true if the code is currently being
optimized for speed rather than size.

     <!-- If you don't define this, a reasonable default is used. -->
      <p>如果没有定义，则会使用一个合理的缺省值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-MOVE_005fBY_005fPIECES_005fP-4347"></a></var><br>
<blockquote><!-- A C expression used to determine whether @code{move_by_pieces} will be used to -->
     <!-- copy a chunk of memory, or whether some other block move mechanism -->
     <!-- will be used.  Defaults to 1 if @code{move_by_pieces_ninsns} returns less -->
     <!-- than @code{MOVE_RATIO}. -->
      <p>一个C表达式，用于确定是否使用<code>move_by_pieces</code>来复制一块内存，
或者使用其它某种块移动机制。缺省为1，
如果<code>move_by_pieces_ninsns</code>返回值小于<code>MOVE_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MOVE_MAX_PIECES</b><var><a name="index-MOVE_005fMAX_005fPIECES-4348"></a></var><br>
<blockquote><!-- A C expression used by @code{move_by_pieces} to determine the largest unit -->
     <!-- a load or store used to copy memory is.  Defaults to @code{MOVE_MAX}. -->
      <p>一个C表达式，
由<code>move_by_pieces</code>使用用于确定load或者store用于复制内存的最大单元。
缺省为<code>MOVE_MAX</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CLEAR_RATIO</b> (<var>speed</var>)<var><a name="index-CLEAR_005fRATIO-4349"></a></var><br>
<blockquote><!-- The threshold of number of scalar move insns, @emph{below} which a sequence -->
     <!-- of insns should be generated to clear memory instead of a string clear insn -->
     <!-- or a library call.  Increasing the value will always make code faster, but -->
     <!-- eventually incurs high cost in increased code size. -->
      <p>标量move insn的临界数，<em>低于</em>其值时，应该生成一个insn序列来清除内存，
而不是字符串clear insn或者库调用。增加值将总是使得代码更快，
但是会最终由于代码大小的增加而产生高的代价。

      <p>The parameter <var>speed</var> is true if the code is currently being
optimized for speed rather than size.

     <!-- If you don't define this, a reasonable default is used. -->
      <p>如果没有定义，则会使用一个合理的缺省值。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CLEAR_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-CLEAR_005fBY_005fPIECES_005fP-4350"></a></var><br>
<blockquote><!-- A C expression used to determine whether @code{clear_by_pieces} will be used -->
     <!-- to clear a chunk of memory, or whether some other block clear mechanism -->
     <!-- will be used.  Defaults to 1 if @code{move_by_pieces_ninsns} returns less -->
     <!-- than @code{CLEAR_RATIO}. -->
      <p>一个C表达式，用于确定是否使用<code>clear_by_pieces</code>来清除一块内存，
或者使用其它块清楚机制。缺省为1，
如果<code>move_by_pieces_ninsns</code>返回值小于<code>CLEAR_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SET_RATIO</b> (<var>speed</var>)<var><a name="index-SET_005fRATIO-4351"></a></var><br>
<blockquote><!-- The threshold of number of scalar move insns, @emph{below} which a sequence -->
     <!-- of insns should be generated to set memory to a constant value, instead of -->
     <!-- a block set insn or a library call. -->
     <!-- Increasing the value will always make code faster, but -->
     <!-- eventually incurs high cost in increased code size. -->
      <p>标量move insn的临界数，<em>低于</em>其值时，
应该生成一个insn序列来将内存设为一个常量值，而不是一个块设置insn或者库调用。
增加值将总是使得代码更快，但是会最终由于代码大小的增加而产生高的代价。

      <p>The parameter <var>speed</var> is true if the code is currently being
optimized for speed rather than size.

     <!-- If you don't define this, it defaults to the value of @code{MOVE_RATIO}. -->
      <p>如果没有定义，缺省值为<code>MOVE_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>SET_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-SET_005fBY_005fPIECES_005fP-4352"></a></var><br>
<blockquote><!-- A C expression used to determine whether @code{store_by_pieces} will be -->
     <!-- used to set a chunk of memory to a constant value, or whether some -->
     <!-- other mechanism will be used.  Used by @code{__builtin_memset} when -->
     <!-- storing values other than constant zero. -->
     <!-- Defaults to 1 if @code{move_by_pieces_ninsns} returns less -->
     <!-- than @code{SET_RATIO}. -->
      <p>一个C表达式用来确定是否使用<code>store_by_pieces</code>来设置内存块为常量值，
或者使用其它机制。当存储非常数0的值时，由<code>__builtin_memset</code>使用。
缺省为1，如果<code>move_by_pieces_ninsns</code>返回值小于<code>SET_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>STORE_BY_PIECES_P</b> (<var>size, alignment</var>)<var><a name="index-STORE_005fBY_005fPIECES_005fP-4353"></a></var><br>
<blockquote><!-- A C expression used to determine whether @code{store_by_pieces} will be -->
     <!-- used to set a chunk of memory to a constant string value, or whether some -->
     <!-- other mechanism will be used.  Used by @code{__builtin_strcpy} when -->
     <!-- called with a constant source string. -->
     <!-- Defaults to 1 if @code{move_by_pieces_ninsns} returns less -->
     <!-- than @code{MOVE_RATIO}. -->
      <p>一个C表达式用来确定是否使用<code>store_by_pieces</code>来设置内存块为常量字符串，
或者使用其它的机制。当使用常量源字符串调用时，被<code>__builtin_strcpy</code>使用。
缺省为1，如果<code>move_by_pieces_ninsns</code>返回值小于<code>MOVE_RATIO</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_POST_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPOST_005fINCREMENT-4354"></a></var><br>
<blockquote><!-- A C expression used to determine whether a load postincrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_POST_INCREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，后增加载是否好。
缺省值为<code>HAVE_POST_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_POST_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPOST_005fDECREMENT-4355"></a></var><br>
<blockquote><!-- A C expression used to determine whether a load postdecrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_POST_DECREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，后减加载是否好。
缺省值为<code>HAVE_POST_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_PRE_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPRE_005fINCREMENT-4356"></a></var><br>
<blockquote><!-- A C expression used to determine whether a load preincrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_PRE_INCREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，前增加载是否好。
缺省值为<code>HAVE_PRE_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_LOAD_PRE_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fLOAD_005fPRE_005fDECREMENT-4357"></a></var><br>
<blockquote><!-- A C expression used to determine whether a load predecrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_PRE_DECREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，前减加载是否好。
缺省值为<code>HAVE_PRE_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_POST_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPOST_005fINCREMENT-4358"></a></var><br>
<blockquote><!-- A C expression used to determine whether a store postincrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_POST_INCREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，后增存储是否好。
缺省值为<code>HAVE_POST_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_POST_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPOST_005fDECREMENT-4359"></a></var><br>
<blockquote><!-- A C expression used to determine whether a store postdecrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_POST_DECREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，后减存储是否好。
缺省值为<code>HAVE_POST_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_PRE_INCREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPRE_005fINCREMENT-4360"></a></var><br>
<blockquote><!-- This macro is used to determine whether a store preincrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_PRE_INCREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，前增存储是否好。
缺省值为<code>HAVE_PRE_INCREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>USE_STORE_PRE_DECREMENT</b> (<var>mode</var>)<var><a name="index-USE_005fSTORE_005fPRE_005fDECREMENT-4361"></a></var><br>
<blockquote><!-- This macro is used to determine whether a store predecrement is a good -->
     <!-- thing to use for a given mode.  Defaults to the value of -->
     <!-- @code{HAVE_PRE_DECREMENT}. -->
      <p>一个C表达式用于确定对于给定的mode，前减存储是否好。
缺省值为<code>HAVE_PRE_DECREMENT</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>NO_FUNCTION_CSE</b><var><a name="index-NO_005fFUNCTION_005fCSE-4362"></a></var><br>
<blockquote><!-- Define this macro if it is as good or better to call a constant -->
     <!-- function address than to call an address kept in a register. -->
      <p>定义该宏，如果调用常量函数地址要比调用保存在寄存器中的地址好些。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>RANGE_TEST_NON_SHORT_CIRCUIT</b><var><a name="index-RANGE_005fTEST_005fNON_005fSHORT_005fCIRCUIT-4363"></a></var><br>
<blockquote><!-- Define this macro if a non-short-circuit operation produced by -->
     <!-- @samp{fold_range_test ()} is optimal.  This macro defaults to true if -->
     <!-- @code{BRANCH_COST} is greater than or equal to the value 2. -->
      <p>定义该宏，如果由&lsquo;<samp><span class="samp">fold_range_test ()</span></samp>&rsquo;产生的non-short-circuit操作为可选的。
该宏缺省为真，如果<code>BRANCH_COST</code>大于或等于2。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_RTX_COSTS</b> (<var>rtx x, int code, int outer_code, int opno, int *total, bool speed</var>)<var><a name="index-TARGET_005fRTX_005fCOSTS-4364"></a></var><br>
<blockquote><!-- This target hook describes the relative costs of RTL expressions. -->
      <p>该target钩子描述了RTL表达式的相对代价。

     <!-- The cost may depend on the precise form of the expression, which is -->
     <!-- available for examination in @var{x}, and the rtx code of the expression -->
     <!-- in which it is contained, found in @var{outer_code}.  @var{code} is the -->
     <!-- expression code-redundant, since it can be obtained with -->
     <!-- @code{GET_CODE (@var{x})}. -->
     <!-- 代价可以依赖于表达式的确切形式，可以通过检查@var{x}来获得表达式的形式， -->
     <!-- 表达式包含的rtx的代码为@var{outer_code}。@var{code}为表达式代码，冗余的， -->
     <!-- 因为其可以使用@code{GET_CODE (@var{x})}获得。 -->
      <p>The cost may depend on the precise form of the expression, which is
available for examination in <var>x</var>, and the fact that <var>x</var> appears
as operand <var>opno</var> of an expression with rtx code <var>outer_code</var>. 
That is, the hook can assume that there is some rtx <var>y</var> such
that &lsquo;<samp><span class="samp">GET_CODE (</span><var>y</var><span class="samp">) == </span><var>outer_code</var></samp>&rsquo; and such that
either (a) &lsquo;<samp><span class="samp">XEXP (</span><var>y</var><span class="samp">, </span><var>opno</var><span class="samp">) == </span><var>x</var></samp>&rsquo; or
(b) &lsquo;<samp><span class="samp">XVEC (</span><var>y</var><span class="samp">, </span><var>opno</var><span class="samp">)</span></samp>&rsquo; contains <var>x</var>.

      <p><var>code</var> is <var>x</var>'s expression code&mdash;redundant, since it can be
obtained with <code>GET_CODE (</code><var>x</var><code>)</code>.

     <!-- In implementing this hook, you can use the construct -->
     <!-- @code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast -->
     <!-- instructions. -->
      <p>实现该钩子时，
你可以使用结构<code>COSTS_N_INSNS (</code><var>n</var><code>)</code>来指定代价等价于<var>n</var>个指令。

     <!-- On entry to the hook, @code{*@var{total}} contains a default estimate -->
     <!-- for the cost of the expression.  The hook should modify this value as -->
     <!-- necessary.  Traditionally, the default costs are @code{COSTS_N_INSNS (5)} -->
     <!-- for multiplications, @code{COSTS_N_INSNS (7)} for division and modulus -->
     <!-- operations, and @code{COSTS_N_INSNS (1)} for all other operations. -->
      <p>在钩子的入口处，<code>*</code><var>total</var>包含了缺省的表达式代价的估值。需要的话，
钩子应该修改该值。传统的，缺省代价对于乘法为<code>COSTS_N_INSNS (5)</code>，
对于除法和求模为<code>COSTS_N_INSNS (7)</code>，
对于其它操作为<code>COSTS_N_INSNS (1)</code>。

     <!-- When optimizing for code size, i.e.@: when @code{speed} is -->
     <!-- false, this target hook should be used to estimate the relative -->
     <!-- size cost of an expression, again relative to @code{COSTS_N_INSNS}. -->
      <p>当优化代码大小时，即，当<code>optimize_size</code>非0时，
该target钩子应该用于估计一个表达式的相对大小代价，
同样也是相对于<code>COSTS_N_INSNS</code>。

     <!-- The hook returns true when all subexpressions of @var{x} have been -->
     <!-- processed, and false when @code{rtx_cost} should recurse. -->
      <p>钩子返回真，当所有<var>x</var>的子表达式都被处理，当<code>rtx_cost</code>应该递归时返回假。
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_ADDRESS_COST</b> (<var>rtx address, bool speed</var>)<var><a name="index-TARGET_005fADDRESS_005fCOST-4365"></a></var><br>
<blockquote><!-- This hook computes the cost of an addressing mode that contains -->
     <!-- @var{address}.  If not defined, the cost is computed from -->
     <!-- the @var{address} expression and the @code{TARGET_RTX_COST} hook. -->
      <p>该钩子计算包含<var>address</var>的寻址模式的代价。如果没有定义，
代价通过<var>address</var>表达式和<code>TARGET_RTX_COST</code>钩子来计算。

     <!-- For most CISC machines, the default cost is a good approximation of the -->
     <!-- true cost of the addressing mode.  However, on RISC machines, all -->
     <!-- instructions normally have the same length and execution time.  Hence -->
     <!-- all addresses will have equal costs. -->
      <p>对于大多数CISC机器，缺省代价为寻址模式的真实代价的合理近似值。
然而，在RISC机器上，所有指令通常具有相同的长度和执行时间。
因此所有寻址将具有相等的代价。

     <!-- In cases where more than one form of an address is known, the form with -->
     <!-- the lowest cost will be used.  If multiple forms have the same, lowest, -->
     <!-- cost, the one that is the most complex will be used. -->
      <p>对于多于一个的形式的寻址，将会使用最低代价的形式。
如果多个形式具有相同的，最低的代价，则使用最复杂的。

     <!-- For example, suppose an address that is equal to the sum of a register -->
     <!-- and a constant is used twice in the same basic block.  When this macro -->
     <!-- is not defined, the address will be computed in a register and memory -->
     <!-- references will be indirect through that register.  On machines where -->
     <!-- the cost of the addressing mode containing the sum is no higher than -->
     <!-- that of a simple indirect reference, this will produce an additional -->
     <!-- instruction and possibly require an additional register.  Proper -->
     <!-- specification of this macro eliminates this overhead for such machines. -->
      <p>例如，假设地址等于寄存器和常量的和，并在同一基本块中使用两次。
当该宏没有被定义，地址将在寄存器中计算，并且内存引用将通过寄存器间接实现。
在一些机器上，包含该和的寻址模式的代价不比简单的间接引用高，
这样则会产生一条额外的指令，并且可能需要一个额外的寄存器。
对该宏进行合适的指定，会消除这样的情况。

     <!-- This hook is never called with an invalid address. -->
      <p>该钩子从不会被无效地址调用。

     <!-- On machines where an address involving more than one register is as -->
     <!-- cheap as an address computation involving only one register, defining -->
     <!-- @code{TARGET_ADDRESS_COST} to reflect this can cause two registers to -->
     <!-- be live over a region of code where only one would have been if -->
     <!-- @code{TARGET_ADDRESS_COST} were not defined in that manner.  This effect -->
     <!-- should be considered in the definition of this macro.  Equivalent costs -->
     <!-- should probably only be given to addresses with different numbers of -->
     <!-- registers on machines with lots of registers. -->
      <p>在一些机器上，地址包括多于一个寄存器的代价，
跟只包含一个寄存器的地址计算代价一样低，
则定义<code>TARGET_ADDRESS_COST</code>来反映这种情况，
可以使得两个寄存器在代码域中为活跃的，如果没有定义则可能只有一个为活跃的。
这种效果在定义该宏时应该被考虑。
可能只有对于有大量寄存器的机器才可能会有相等的代价。
</p></blockquote></div>

<!-- @node Scheduling -->
<!-- @section Adjusting the Instruction Scheduler -->
 </body></html>

