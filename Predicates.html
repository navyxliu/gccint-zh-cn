<html lang="zh">
<head>
<title>Predicates - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Machine-Desc.html#Machine-Desc" title="Machine Desc">
<link rel="prev" href="Output-Statement.html#Output-Statement" title="Output Statement">
<link rel="next" href="Constraints.html#Constraints" title="Constraints">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Predicates"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Constraints.html#Constraints">Constraints</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Output-Statement.html#Output-Statement">Output Statement</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Machine-Desc.html#Machine-Desc">Machine Desc</a>
<hr>
</div>

<h3 class="section">16.7 断言</h3>

<p><a name="index-g_t_00e6_0096_00ad_00e8_00a8_0080-3239"></a><a name="index-g_t_00e6_0093_008d_00e4_00bd_009c_00e6_0095_00b0_00e6_0096_00ad_00e8_00a8_0080-3240"></a><a name="index-g_t_00e6_0093_008d_00e4_00bd_009c_00e7_00ac_00a6_00e6_0096_00ad_00e8_00a8_0080-3241"></a>
<!-- A predicate determines whether a @code{match_operand} or -->
<!-- @code{match_operator} expression matches, and therefore whether the -->
<!-- surrounding instruction pattern will be used for that combination of -->
<!-- operands.  GCC has a number of machine-independent predicates, and you -->
<!-- can define machine-specific predicates as needed.  By convention, -->
<!-- predicates used with @code{match_operand} have names that end in -->
<!-- @samp{_operand}, and those used with @code{match_operator} have names -->
<!-- that end in @samp{_operator}. -->
断言用于确定一个<code>match_operand</code>或者 <code>match_operator</code>表达式是否匹配， 以及周围的指令模式是否会被用于那些操作数的组合。 GCC有许多机器无关的predicate，并且你可以根据需要来定义机器特定的断言。 按照惯例，与<code>match_operand</code>一起使用的predicate的名字以&lsquo;<samp><span class="samp">_operand</span></samp>&rsquo;结尾， 与<code>match_operator</code>一起使用的predicate的名字以&lsquo;<samp><span class="samp">_operator</span></samp>&rsquo;结尾。

<!-- All predicates are Boolean functions (in the mathematical sense) of -->
<!-- two arguments: the RTL expression that is being considered at that -->
<!-- position in the instruction pattern, and the machine mode that the -->
<!-- @code{match_operand} or @code{match_operator} specifies.  In this -->
<!-- section, the first argument is called @var{op} and the second argument -->
<!-- @var{mode}.  Predicates can be called from C as ordinary two-argument -->
<!-- functions; this can be useful in output templates or other -->
<!-- machine-specific code. -->
 <p>所有断言（从数学意义上）都是具有两个参数的布尔函数： 指令模式中在那个位置上被考虑的RTL表达式， 以及<code>match_operand</code>或<code>match_operator</code>所指定的机器模式。 在这一节里，第一个参数被称为<var>op</var>，第二个参数被称为<var>mode</var>。 predicate可以作为普通的具有两个参数的函数，从C中调用； 这在输出模板或者其它机器特定的代码中，很有用处。

<!-- Operand predicates can allow operands that are not actually acceptable -->
<!-- to the hardware, as long as the constraints give reload the ability to -->
<!-- fix them up (@pxref{Constraints}).  However, GCC will usually generate -->
<!-- better code if the predicates specify the requirements of the machine -->
<!-- instructions as closely as possible.  Reload cannot fix up operands -->
<!-- that must be constants (``immediate operands''); you must use a -->
<!-- predicate that allows only constants, or else enforce the requirement -->
<!-- in the extra condition. -->
 <p>操作数断言可以允许硬件实际上无法接受的操作数， 只要约束能够为reload提供能力，来修复它们（参见<a href="Constraints.html#Constraints">Constraints</a>）。 然而，只要断言指定的机器指令需求尽可能的严密， GCC通常便会生成更好的代码。reload不能修复必须为常量的操作数（立即数）； 你必须使用只允许常量的断言，或者使用额外的条件来加强必要条件。

<!-- @cindex predicates and machine modes -->
<!-- @cindex normal predicates -->
<!-- @cindex special predicates -->
<!-- Most predicates handle their @var{mode} argument in a uniform manner. -->
<!-- If @var{mode} is @code{VOIDmode} (unspecified), then @var{op} can have -->
<!-- any mode.  If @var{mode} is anything else, then @var{op} must have the -->
<!-- same mode, unless @var{op} is a @code{CONST_INT} or integer -->
<!-- @code{CONST_DOUBLE}.  These RTL expressions always have -->
<!-- @code{VOIDmode}, so it would be counterproductive to check that their -->
<!-- mode matches.  Instead, predicates that accept @code{CONST_INT} and/or -->
<!-- integer @code{CONST_DOUBLE} check that the value stored in the -->
<!-- constant will fit in the requested mode. -->
 <p><a name="index-predicates-and-machine-modes-3242"></a><a name="index-normal-predicates-3243"></a><a name="index-special-predicates-3244"></a>大多数predicate使用统一的方式来处理它们的<var>mode</var>参数。
如果<var>mode</var>为<code>VOIDmode</code>（未加指明的），则<var>op</var>可以具有任意的模式。
如果<var>mode</var>为其它情况，则<var>op</var>必须具有相同的机器模式，
除非<var>op</var>是一个<code>CONST_INT</code>或整数<code>CONST_DOUBLE</code>。
这些RTL表达式总是具有<code>VOIDmode</code>，所以检测它们的模式匹配反而会适得其反。
替代的，接受<code>CONST_INT</code>和/或整数<code>CONST_DOUBLE</code>的predicate，
可以检测存储在常量中的值是否适合所要求的机器模式。

<!-- Predicates with this behavior are called @dfn{normal}. -->
<!-- @command{genrecog} can optimize the instruction recognizer based on -->
<!-- knowledge of how normal predicates treat modes.  It can also diagnose -->
<!-- certain kinds of common errors in the use of normal predicates; for -->
<!-- instance, it is almost always an error to use a normal predicate -->
<!-- without specifying a mode. -->
 <p>具有这种行为的predicate被称为常规的。
<samp><span class="command">genrecog</span></samp>能够根据常规predicate如何处理机器模式的知识来优化指令识别器。
它还能够诊断使用常规predicate所出现的一些常见错误。例如，
使用常规predicate而没有指定机器模式几乎总是错误的。

<!-- Predicates that do something different with their @var{mode} argument -->
<!-- are called @dfn{special}.  The generic predicates -->
<!-- @code{address_operand} and @code{pmode_register_operand} are special -->
<!-- predicates.  @command{genrecog} does not do any optimizations or -->
<!-- diagnosis when special predicates are used. -->
 <p>对<var>mode</var>参数进行不同方式处理的predicate被称为特殊的。
通用predicate <code>address_operand</code>和<code>pmode_register_operand</code>
是特殊predicate。当使用特殊predicate的时候，
<samp><span class="command">genrecog</span></samp>不做任何的优化或诊断。

<!-- @menu -->
<!-- * Machine-Independent Predicates::  Predicates available to all back ends. -->
<!-- * Defining Predicates::             How to write machine-specific predicate -->
<!-- functions. -->
<!-- @end menu -->
<ul class="menu">
<li><a accesskey="1" href="Machine_002dIndependent-Predicates.html#Machine_002dIndependent-Predicates">Machine-Independent Predicates</a>:  所有后端都可用的断言。
<li><a accesskey="2" href="Defining-Predicates.html#Defining-Predicates">Defining Predicates</a>:        如何写机器特定的predicate函数。
</ul>

<!-- @node Machine-Independent Predicates -->
<!-- @subsection Machine-Independent Predicates -->
<!-- @cindex machine-independent predicates -->
<!-- @cindex generic predicates -->
 </body></html>

