<html lang="zh">
<head>
<title>Unary and Binary Expressions - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Expression-trees.html#Expression-trees" title="Expression trees">
<link rel="prev" href="Storage-References.html#Storage-References" title="Storage References">
<link rel="next" href="Vectors.html#Vectors" title="Vectors">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Unary-and-Binary-Expressions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Vectors.html#Vectors">Vectors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Storage-References.html#Storage-References">Storage References</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Expression-trees.html#Expression-trees">Expression trees</a>
<hr>
</div>

<h4 class="subsection">11.6.3 一元和二元表达式</h4>

<p><a name="index-NEGATE_005fEXPR-2438"></a><a name="index-ABS_005fEXPR-2439"></a><a name="index-BIT_005fNOT_005fEXPR-2440"></a><a name="index-TRUTH_005fNOT_005fEXPR-2441"></a><a name="index-PREDECREMENT_005fEXPR-2442"></a><a name="index-PREINCREMENT_005fEXPR-2443"></a><a name="index-POSTDECREMENT_005fEXPR-2444"></a><a name="index-POSTINCREMENT_005fEXPR-2445"></a><a name="index-FIX_005fTRUNC_005fEXPR-2446"></a><a name="index-FLOAT_005fEXPR-2447"></a><a name="index-COMPLEX_005fEXPR-2448"></a><a name="index-CONJ_005fEXPR-2449"></a><a name="index-REALPART_005fEXPR-2450"></a><a name="index-IMAGPART_005fEXPR-2451"></a><a name="index-NON_005fLVALUE_005fEXPR-2452"></a><a name="index-NOP_005fEXPR-2453"></a><a name="index-CONVERT_005fEXPR-2454"></a><a name="index-FIXED_005fCONVERT_005fEXPR-2455"></a><a name="index-THROW_005fEXPR-2456"></a><a name="index-LSHIFT_005fEXPR-2457"></a><a name="index-RSHIFT_005fEXPR-2458"></a><a name="index-BIT_005fIOR_005fEXPR-2459"></a><a name="index-BIT_005fXOR_005fEXPR-2460"></a><a name="index-BIT_005fAND_005fEXPR-2461"></a><a name="index-TRUTH_005fANDIF_005fEXPR-2462"></a><a name="index-TRUTH_005fORIF_005fEXPR-2463"></a><a name="index-TRUTH_005fAND_005fEXPR-2464"></a><a name="index-TRUTH_005fOR_005fEXPR-2465"></a><a name="index-TRUTH_005fXOR_005fEXPR-2466"></a><a name="index-POINTER_005fPLUS_005fEXPR-2467"></a><a name="index-PLUS_005fEXPR-2468"></a><a name="index-MINUS_005fEXPR-2469"></a><a name="index-MULT_005fEXPR-2470"></a><a name="index-RDIV_005fEXPR-2471"></a><a name="index-TRUNC_005fDIV_005fEXPR-2472"></a><a name="index-FLOOR_005fDIV_005fEXPR-2473"></a><a name="index-CEIL_005fDIV_005fEXPR-2474"></a><a name="index-ROUND_005fDIV_005fEXPR-2475"></a><a name="index-TRUNC_005fMOD_005fEXPR-2476"></a><a name="index-FLOOR_005fMOD_005fEXPR-2477"></a><a name="index-CEIL_005fMOD_005fEXPR-2478"></a><a name="index-ROUND_005fMOD_005fEXPR-2479"></a><a name="index-EXACT_005fDIV_005fEXPR-2480"></a><a name="index-LT_005fEXPR-2481"></a><a name="index-LE_005fEXPR-2482"></a><a name="index-GT_005fEXPR-2483"></a><a name="index-GE_005fEXPR-2484"></a><a name="index-EQ_005fEXPR-2485"></a><a name="index-NE_005fEXPR-2486"></a><a name="index-ORDERED_005fEXPR-2487"></a><a name="index-UNORDERED_005fEXPR-2488"></a><a name="index-UNLT_005fEXPR-2489"></a><a name="index-UNLE_005fEXPR-2490"></a><a name="index-UNGT_005fEXPR-2491"></a><a name="index-UNGE_005fEXPR-2492"></a><a name="index-UNEQ_005fEXPR-2493"></a><a name="index-LTGT_005fEXPR-2494"></a><a name="index-MODIFY_005fEXPR-2495"></a><a name="index-INIT_005fEXPR-2496"></a><a name="index-COMPOUND_005fEXPR-2497"></a><a name="index-COND_005fEXPR-2498"></a><a name="index-CALL_005fEXPR-2499"></a><a name="index-STMT_005fEXPR-2500"></a><a name="index-BIND_005fEXPR-2501"></a><a name="index-LOOP_005fEXPR-2502"></a><a name="index-EXIT_005fEXPR-2503"></a><a name="index-CLEANUP_005fPOINT_005fEXPR-2504"></a><a name="index-CONSTRUCTOR-2505"></a><a name="index-COMPOUND_005fLITERAL_005fEXPR-2506"></a><a name="index-SAVE_005fEXPR-2507"></a><a name="index-TARGET_005fEXPR-2508"></a><a name="index-VA_005fARG_005fEXPR-2509"></a>
     <dl>
<dt><code>NEGATE_EXPR</code><dd><!-- These nodes represent unary negation of the single operand, for both -->
<!-- integer and floating-point types.  The type of negation can be -->
<!-- determined by looking at the type of the expression. -->
这些节点表示对单个,整数或浮点类型的操作数，进行一元取负运算。取负运算结果的类型可以通过查看表达式的类型来决定。

     <!-- The behavior of this operation on signed arithmetic overflow is -->
     <!-- controlled by the @code{flag_wrapv} and @code{flag_trapv} variables. -->
     <p>该操作在有符号算术溢出时的行为，由<code>flag_wrapv</code>和<code>flag_trapv</code>变量来控制。

     <br><dt><code>ABS_EXPR</code><dd><!-- These nodes represent the absolute value of the single operand, for -->
<!-- both integer and floating-point types.  This is typically used to -->
<!-- implement the @code{abs}, @code{labs} and @code{llabs} builtins for -->
<!-- integer types, and the @code{fabs}, @code{fabsf} and @code{fabsl} -->
<!-- builtins for floating point types.  The type of abs operation can -->
<!-- be determined by looking at the type of the expression. -->
这些节点表示单个操作数，整数和浮点类型的，的绝对值。这通常用于实现整数类型的内建<code>abs</code>，<code>labs</code>和<code>llabs</code>，以及浮点类型的<code>fabs</code>，<code>fabsf</code>和<code>fabsl</code>。abs操作的类型可以通过查看表达式的类型来决定。

     <!-- This node is not used for complex types.  To represent the modulus -->
     <!-- or complex abs of a complex value, use the @code{BUILT_IN_CABS}, -->
     <!-- @code{BUILT_IN_CABSF} or @code{BUILT_IN_CABSL} builtins, as used -->
     <!-- to implement the C99 @code{cabs}, @code{cabsf} and @code{cabsl} -->
     <!-- built-in functions. -->
     <p>该节点不用于复数类型。要表示复数的模或者复数abs，使用内建的<code>BUILT_IN_CABS</code>, <code>BUILT_IN_CABSF</code>或<code>BUILT_IN_CABSL</code>，这些被用于实现C99的内建函数<code>cabs</code>, <code>cabsf</code>和<code>cabsl</code>。

     <br><dt><code>BIT_NOT_EXPR</code><dd><!-- These nodes represent bitwise complement, and will always have integral -->
<!-- type.  The only operand is the value to be complemented. -->
这些节点表示按位求补运算，并总是具有整数型。唯一的操作数是要被求补的值。

     <br><dt><code>TRUTH_NOT_EXPR</code><dd><!-- These nodes represent logical negation, and will always have integral -->
<!-- (or boolean) type.  The operand is the value being negated.  The type -->
<!-- of the operand and that of the result are always of @code{BOOLEAN_TYPE} -->
<!-- or @code{INTEGER_TYPE}. -->
这些节点表示逻辑非，并总是具有整数（或布尔）类型。操作数是要求非的值。操作数的，以及结果的类型总是<code>BOOLEAN_TYPE</code>或<code>INTEGER_TYPE</code>。

     <br><dt><code>PREDECREMENT_EXPR</code><dt><code>PREINCREMENT_EXPR</code><dt><code>POSTDECREMENT_EXPR</code><dt><code>POSTINCREMENT_EXPR</code><dd><!-- These nodes represent increment and decrement expressions.  The value of -->
<!-- the single operand is computed, and the operand incremented or -->
<!-- decremented.  In the case of @code{PREDECREMENT_EXPR} and -->
<!-- @code{PREINCREMENT_EXPR}, the value of the expression is the value -->
<!-- resulting after the increment or decrement; in the case of -->
<!-- @code{POSTDECREMENT_EXPR} and @code{POSTINCREMENT_EXPR} is the value -->
<!-- before the increment or decrement occurs.  The type of the operand, like -->
<!-- that of the result, will be either integral, boolean, or floating-point. -->
这些节点表示递增和递减表达式。单操作数的值将被计算，并且操作数递增或递减。在<code>PREDECREMENT_EXPR</code>和<code>PREINCREMENT_EXPR</code>的情况下，表达式的值是递增或递减之后的结果；在<code>POSTDECREMENT_EXPR</code>和<code>POSTINCREMENT_EXPR</code>的情况下，表达式的值是递增或递减发生前的值。操作数的值，跟结果的一样，将会是整数，布尔，或浮点的。

     <br><dt><code>FIX_TRUNC_EXPR</code><dd><!-- These nodes represent conversion of a floating-point value to an -->
<!-- integer.  The single operand will have a floating-point type, while -->
<!-- the complete expression will have an integral (or boolean) type.  The -->
<!-- operand is rounded towards zero. -->
这些节点表示浮点值到整数的转换。单操作数将具有一个浮点类型，完整的表达式将具有整数（或布尔）类型。操作数向0方向舍入。

     <br><dt><code>FLOAT_EXPR</code><dd><!-- These nodes represent conversion of an integral (or boolean) value to a -->
<!-- floating-point value.  The single operand will have integral type, while -->
<!-- the complete expression will have a floating-point type. -->
这些节点表示整数（或布尔）值向浮点值的转换。单操作数将具有整数类型，而完整的表达式将具有浮点类型。

     <!-- FIXME: How is the operand supposed to be rounded?  Is this dependent on -->
     <!-- @option{-mieee}? -->
     <p>FIXME: 操作数是如何被舍入的？这是不是取决于<samp><span class="option">-mieee</span></samp>？

     <br><dt><code>COMPLEX_EXPR</code><dd><!-- These nodes are used to represent complex numbers constructed from two -->
<!-- expressions of the same (integer or real) type.  The first operand is the -->
<!-- real part and the second operand is the imaginary part. -->
这些节点用于表示通过两个相同类型（整数或实数）的表达式构造的复数。第一个操作数是实部，第二个操作数是虚部。

     <br><dt><code>CONJ_EXPR</code><dd><!-- These nodes represent the conjugate of their operand. -->
这些节点表示它们的操作数的共轭（conjugate）。

     <br><dt><code>REALPART_EXPR</code><dt><code>IMAGPART_EXPR</code><dd><!-- These nodes represent respectively the real and the imaginary parts -->
<!-- of complex numbers (their sole argument). -->
这些节点表示复数的相应实数和虚数部分。

     <br><dt><code>NON_LVALUE_EXPR</code><dd><!-- These nodes indicate that their one and only operand is not an lvalue. -->
<!-- A back end can treat these identically to the single operand. -->
这些节点指示它们有且仅有的一个操作数不是左值的。后端可以将其作为单操作数来对待。

     <br><dt><code>NOP_EXPR</code><dd><!-- These nodes are used to represent conversions that do not require any -->
<!-- code-generation.  For example, conversion of a @code{char*} to an -->
<!-- @code{int*} does not require any code be generated; such a conversion is -->
<!-- represented by a @code{NOP_EXPR}.  The single operand is the expression -->
<!-- to be converted.  The conversion from a pointer to a reference is also -->
<!-- represented with a @code{NOP_EXPR}. -->
这些节点用于表示不需要任何代码生成的转换。例如，由<code>char*</code>到<code>int*</code>不需要任何代码生成；这样的转换被表示为一个<code>NOP_EXPR</code>。单操作数为要转换的表达式。从指针到引用的转换也被表示为<code>NOP_EXPR</code>。

     <br><dt><code>CONVERT_EXPR</code><dd><!-- These nodes are similar to @code{NOP_EXPR}s, but are used in those -->
<!-- situations where code may need to be generated.  For example, if an -->
<!-- @code{int*} is converted to an @code{int} code may need to be generated -->
<!-- on some platforms.  These nodes are never used for C++-specific -->
<!-- conversions, like conversions between pointers to different classes in -->
<!-- an inheritance hierarchy.  Any adjustments that need to be made in such -->
<!-- cases are always indicated explicitly.  Similarly, a user-defined -->
<!-- conversion is never represented by a @code{CONVERT_EXPR}; instead, the -->
<!-- function calls are made explicit. -->
这些节点类似于<code>NOP_EXPR</code>，不过用于可能会有代码生成的情况。例如，如果<code>int*</code>被转换为<code>int</code>，则可能会在一些平台上需要生成代码。这些节点从来不被用于C++特定的转换，例如在一个继承体系中不同的类的指针间的转换。这种情况下的任何调整，总是需要被显式的指出。类似的，用户定义的转换也不使用<code>CONVERT_EXPR</code>表示；相反的，而是显式的调用函数。

     <br><dt><code>FIXED_CONVERT_EXPR</code><dd><!-- These nodes are used to represent conversions that involve fixed-point -->
<!-- values.  For example, from a fixed-point value to another fixed-point value, -->
<!-- from an integer to a fixed-point value, from a fixed-point value to an -->
<!-- integer, from a floating-point value to a fixed-point value, or from -->
<!-- a fixed-point value to a floating-point value. -->
这些节点用于表示涉及定点值的转换。例如，从一个定点值到另一个定点值，从一个整数到一个定点值，从一个定点值到一个整数，从一个浮点值到一个定点值，或者从一个定点值到一个浮点值。

     <br><dt><code>LSHIFT_EXPR</code><dt><code>RSHIFT_EXPR</code><dd><!-- These nodes represent left and right shifts, respectively.  The first -->
<!-- operand is the value to shift; it will always be of integral type.  The -->
<!-- second operand is an expression for the number of bits by which to -->
<!-- shift.  Right shift should be treated as arithmetic, i.e., the -->
<!-- high-order bits should be zero-filled when the expression has unsigned -->
<!-- type and filled with the sign bit when the expression has signed type. -->
<!-- Note that the result is undefined if the second operand is larger -->
<!-- than or equal to the first operand's type size. -->
这些节点分别表示左移和右移。第一个操作数为要移动的值；其将总是为整数类型。第二个操作数为表示移动位数的表达式。右移将作为算术移动，即，当表达式具有无符号类型则高位填充0，当表达式具有有符号类型则高位填充符号位。注意如果第二个操作数大于或等于第一个操作数的类型大小，则结果无定义。

     <br><dt><code>BIT_IOR_EXPR</code><dt><code>BIT_XOR_EXPR</code><dt><code>BIT_AND_EXPR</code><dd><!-- These nodes represent bitwise inclusive or, bitwise exclusive or, and -->
<!-- bitwise and, respectively.  Both operands will always have integral -->
<!-- type. -->
这些节点分别表示位运算符“或”，“异或”，和“与”。所有操作数将总是为整数类型。

     <br><dt><code>TRUTH_ANDIF_EXPR</code><dt><code>TRUTH_ORIF_EXPR</code><dd><!-- These nodes represent logical ``and'' and logical ``or'', respectively. -->
<!-- These operators are not strict; i.e., the second operand is evaluated -->
<!-- only if the value of the expression is not determined by evaluation of -->
<!-- the first operand.  The type of the operands and that of the result are -->
<!-- always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}. -->
这些节点分别表示逻辑“与”和“或”。这些操作符不是严格的；即第二个操作数只在通过求值第一个操作数无法确定表达式的值的时候，才被计算求值。操作数和结果的类型总是为<code>BOOLEAN_TYPE</code>或<code>INTEGER_TYPE</code>。

     <br><dt><code>TRUTH_AND_EXPR</code><dt><code>TRUTH_OR_EXPR</code><dt><code>TRUTH_XOR_EXPR</code><dd><!-- These nodes represent logical and, logical or, and logical exclusive or. -->
<!-- They are strict; both arguments are always evaluated.  There are no -->
<!-- corresponding operators in C or C++, but the front end will sometimes -->
<!-- generate these expressions anyhow, if it can tell that strictness does -->
<!-- not matter.  The type of the operands and that of the result are -->
<!-- always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}. -->
这些节点表示逻辑与，或和异或。它们为严格的方式；所有参数都总是被计算求值。这在C或C++中没有对应的运算符，但是前端如果可以断定严格的方式没关系，则有时将会生成这些表达式。操作数和结果的类型总是为<code>BOOLEAN_TYPE</code>或<code>INTEGER_TYPE</code>。

     <dt><code>POINTER_PLUS_EXPR</code><dd><!-- This node represents pointer arithmetic.  The first operand is always -->
<!-- a pointer/reference type.  The second operand is always an unsigned -->
<!-- integer type compatible with sizetype.  This is the only binary -->
<!-- arithmetic operand that can operate on pointer types. -->
该节点表示指针算术运算。第一个操作数总是为一个指针/引用类型。第二个操作数总是为一个与sizetype兼容的无符号整数类型。这是唯一的可以操作指针类型的二元算术运算。

     <dt><code>PLUS_EXPR</code><dt><code>MINUS_EXPR</code><dt><code>MULT_EXPR</code><dd><!-- These nodes represent various binary arithmetic operations. -->
<!-- Respectively, these operations are addition, subtraction (of the second -->
<!-- operand from the first) and multiplication.  Their operands may have -->
<!-- either integral or floating type, but there will never be case in which -->
<!-- one operand is of floating type and the other is of integral type. -->
这些节点表示不同的二元算术运算。分别为加法，减法和乘法。它们的操作数可以为整数或者浮点类型，但不会为一个是浮点类型的，而另一个是整数类型。

     <!-- The behavior of these operations on signed arithmetic overflow is -->
     <!-- controlled by the @code{flag_wrapv} and @code{flag_trapv} variables. -->
     <p>这些运算在有符号算术溢出时的行为，由变量<code>flag_wrapv</code>和<code>flag_trapv</code>来控制。

     <br><dt><code>RDIV_EXPR</code><dd><!-- This node represents a floating point division operation. -->
该节点表示一个浮点除法运算。

     <br><dt><code>TRUNC_DIV_EXPR</code><dt><code>FLOOR_DIV_EXPR</code><dt><code>CEIL_DIV_EXPR</code><dt><code>ROUND_DIV_EXPR</code><dd><!-- These nodes represent integer division operations that return an integer -->
<!-- result.  @code{TRUNC_DIV_EXPR} rounds towards zero, @code{FLOOR_DIV_EXPR} -->
<!-- rounds towards negative infinity, @code{CEIL_DIV_EXPR} rounds towards -->
<!-- positive infinity and @code{ROUND_DIV_EXPR} rounds to the closest integer. -->
<!-- Integer division in C and C++ is truncating, i.e.@: @code{TRUNC_DIV_EXPR}. -->
这些节点表示返回整数结果的整数除法运算。<code>TRUNC_DIV_EXPR</code>向0方向舍入，<code>FLOOR_DIV_EXPR</code>向负无穷大舍入，<code>CEIL_DIV_EXPR</code>向正无穷大舍入，<code>ROUND_DIV_EXPR</code>向最近的整数舍入。C和C++中的整数除法为截断方式，即<code>TRUNC_DIV_EXPR</code>。

     <!-- The behavior of these operations on signed arithmetic overflow, when -->
     <!-- dividing the minimum signed integer by minus one, is controlled by the -->
     <!-- @code{flag_wrapv} and @code{flag_trapv} variables. -->
     <p>这些运算在有符号算术溢出时的行为，由变量<code>flag_wrapv</code>和<code>flag_trapv</code>来控制。

     <br><dt><code>TRUNC_MOD_EXPR</code><dt><code>FLOOR_MOD_EXPR</code><dt><code>CEIL_MOD_EXPR</code><dt><code>ROUND_MOD_EXPR</code><dd><!-- These nodes represent the integer remainder or modulus operation. -->
<!-- The integer modulus of two operands @code{a} and @code{b} is -->
<!-- defined as @code{a - (a/b)*b} where the division calculated using -->
<!-- the corresponding division operator.  Hence for @code{TRUNC_MOD_EXPR} -->
<!-- this definition assumes division using truncation towards zero, i.e.@: -->
<!-- @code{TRUNC_DIV_EXPR}.  Integer remainder in C and C++ uses truncating -->
<!-- division, i.e.@: @code{TRUNC_MOD_EXPR}. -->
这些节点表示整数类型的求余或求模运算。两个操作数<code>a</code>和<code>b</code>的整型的模被定义为<code>a - (a/b)*b</code>，其中使用相应的除法操作符进行除法运算。因此，对于<code>TRUNC_MOD_EXPR</code>的定义，是假设使用了向零方向舍去的除法，即<code>TRUNC_DIV_EXPR</code>。C和C++中的整型求余，使用了舍去除法，即<code>TRUNC_MOD_EXPR</code>。

     <br><dt><code>EXACT_DIV_EXPR</code><dd><!-- The @code{EXACT_DIV_EXPR} code is used to represent integer divisions where -->
<!-- the numerator is known to be an exact multiple of the denominator.  This -->
<!-- allows the backend to choose between the faster of @code{TRUNC_DIV_EXPR}, -->
<!-- @code{CEIL_DIV_EXPR} and @code{FLOOR_DIV_EXPR} for the current target. -->
<code>EXACT_DIV_EXPR</code>用来表示整数除法，即分子已知为分母的确切的倍数。这使得后端可以从<code>TRUNC_DIV_EXPR</code>，<code>CEIL_DIV_EXPR</code>和<code>FLOOR_DIV_EXPR</code>中，为当前的目标机选择更快的运算。

     <br><dt><code>LT_EXPR</code><dt><code>LE_EXPR</code><dt><code>GT_EXPR</code><dt><code>GE_EXPR</code><dt><code>EQ_EXPR</code><dt><code>NE_EXPR</code><dd><!-- These nodes represent the less than, less than or equal to, greater -->
<!-- than, greater than or equal to, equal, and not equal comparison -->
<!-- operators.  The first and second operand with either be both of integral -->
<!-- type or both of floating type.  The result type of these expressions -->
<!-- will always be of integral or boolean type.  These operations return -->
<!-- the result type's zero value for false, and the result type's one value -->
<!-- for true. -->
这些节点表示小于，小于或等于，大于，大于或等于，等于，和不等于的比较运算符。第一个和第二个操作数或者都为整数类型，或者都为浮点类型。这些表达式的结果类型将总是为整数或布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

     <!-- For floating point comparisons, if we honor IEEE NaNs and either operand -->
     <!-- is NaN, then @code{NE_EXPR} always returns true and the remaining operators -->
     <!-- always return false.  On some targets, comparisons against an IEEE NaN, -->
     <!-- other than equality and inequality, may generate a floating point exception. -->
     <p>对于浮点类型比较运算，如果我们使用了IEEE NaN，并且任意一个操作数为NaN，则<code>NE_EXPR</code>总是返回真，而其余的运算符总是返回假。在一些目标机上，对于IEEE NaN，除了等于和不等于以外的其它比较运算，可能会生成一个浮点异常。

     <br><dt><code>ORDERED_EXPR</code><dt><code>UNORDERED_EXPR</code><dd><!-- These nodes represent non-trapping ordered and unordered comparison -->
<!-- operators.  These operations take two floating point operands and -->
<!-- determine whether they are ordered or unordered relative to each other. -->
<!-- If either operand is an IEEE NaN, their comparison is defined to be -->
<!-- unordered, otherwise the comparison is defined to be ordered.  The -->
<!-- result type of these expressions will always be of integral or boolean -->
<!-- type.  These operations return the result type's zero value for false, -->
<!-- and the result type's one value for true. -->
这些节点表示non-trapping的有序和无序的比较运算。这些运算接受两个浮点操作数，并确定它们之间是有序的，还是无序的。如果有一个操作数为IEEE NaN，则它们的比较被定以为无序的，否则为有序的。这些表达式的结果类型将总是为整数或者布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

     <br><dt><code>UNLT_EXPR</code><dt><code>UNLE_EXPR</code><dt><code>UNGT_EXPR</code><dt><code>UNGE_EXPR</code><dt><code>UNEQ_EXPR</code><dt><code>LTGT_EXPR</code><dd><!-- These nodes represent the unordered comparison operators. -->
<!-- These operations take two floating point operands and determine whether -->
<!-- the operands are unordered or are less than, less than or equal to, -->
<!-- greater than, greater than or equal to, or equal respectively.  For -->
<!-- example, @code{UNLT_EXPR} returns true if either operand is an IEEE -->
<!-- NaN or the first operand is less than the second.  With the possible -->
<!-- exception of @code{LTGT_EXPR}, all of these operations are guaranteed -->
<!-- not to generate a floating point exception.  The result -->
<!-- type of these expressions will always be of integral or boolean type. -->
<!-- These operations return the result type's zero value for false, -->
<!-- and the result type's one value for true. -->
这些节点表示无序比较运算符。这些运算接受两个浮点操作数，并分别确定它们之间是否为无序的，小于，小于或等于，大于，大于或等于，或者等于。例如，如果一个操作数为IEEE NaN，或者第一个操作数小于第二个，则<code>UNLT_EXPR</code>返回真。除了<code>LTGT_EXPR</code>可能会产生异常，其它的运算都保证不会产生浮点异常。这些表达式的结果类型将总是为整数或者布尔类型。如果为假，则这些运算返回值0，如果为真，则返回值1。

     <br><dt><code>MODIFY_EXPR</code><dd><!-- These nodes represent assignment.  The left-hand side is the first -->
<!-- operand; the right-hand side is the second operand.  The left-hand side -->
<!-- will be a @code{VAR_DECL}, @code{INDIRECT_REF}, @code{COMPONENT_REF}, or -->
<!-- other lvalue. -->
这些节点表示赋值。左手边为第一个操作数，右手边为第二个操作数。左手边为一个<code>VAR_DECL</code>, <code>INDIRECT_REF</code>, <code>COMPONENT_REF</code>，或者其它左值。

     <!-- These nodes are used to represent not only assignment with @samp{=} but -->
     <!-- also compound assignments (like @samp{+=}), by reduction to @samp{=} -->
     <!-- assignment.  In other words, the representation for @samp{i += 3} looks -->
     <!-- just like that for @samp{i = i + 3}. -->
     <p>这些节点不仅用来表示使用&lsquo;<samp><span class="samp">=</span></samp>&rsquo;进行赋值，也用来表示复合赋值（像&lsquo;<samp><span class="samp">+=</span></samp>&rsquo;），并将其转换成&lsquo;<samp><span class="samp">=</span></samp>&rsquo;赋值。换句话说，对&lsquo;<samp><span class="samp">i += 3</span></samp>&rsquo;的表示，看起来就像是对&lsquo;<samp><span class="samp">i = i + 3</span></samp>&rsquo;的表示。

     <br><dt><code>INIT_EXPR</code><dd><!-- These nodes are just like @code{MODIFY_EXPR}, but are used only when a -->
<!-- variable is initialized, rather than assigned to subsequently.  This -->
<!-- means that we can assume that the target of the initialization is not -->
<!-- used in computing its own value; any reference to the lhs in computing -->
<!-- the rhs is undefined. -->
这些节点就像<code>MODIFY_EXPR</code>一样，只不过用于一个变量被初始化的时候，而不是后续的赋值。这意味着，我们可以假设初始化的目标，没有在右手边被用于计算它自己的值；任何在右手边的计算中，对左手边的引用，其行为将是未定义。

     <br><dt><code>COMPOUND_EXPR</code><dd><!-- These nodes represent comma-expressions.  The first operand is an -->
<!-- expression whose value is computed and thrown away prior to the -->
<!-- evaluation of the second operand.  The value of the entire expression is -->
<!-- the value of the second operand. -->
这些节点表示逗号表达式。第一个操作数为表达式，其值被计算，并在求出第二个操作数的值之前丢掉。整个表达式的值为第二个操作数的值。

     <br><dt><code>COND_EXPR</code><dd><!-- These nodes represent @code{?:} expressions.  The first operand -->
<!-- is of boolean or integral type.  If it evaluates to a nonzero value, -->
<!-- the second operand should be evaluated, and returned as the value of the -->
<!-- expression.  Otherwise, the third operand is evaluated, and returned as -->
<!-- the value of the expression. -->
这些节点表示<code>?:</code>表达式。第一个操作数是布尔或者整数类型。如果其求解为非零值，则第二个操作数将被求值，并返回表达式的值。否则，第三个操作数将被求值，并将表达式的值返回。

     <!-- The second operand must have the same type as the entire expression, -->
     <!-- unless it unconditionally throws an exception or calls a noreturn -->
     <!-- function, in which case it should have void type.  The same constraints -->
     <!-- apply to the third operand.  This allows array bounds checks to be -->
     <!-- represented conveniently as @code{(i >= 0 && i < 10) ? i : abort()}. -->
     <p>第二个操作数必须与整个表达式具有相同的类型，除非它是要无条件的抛出一个异常或者调用一个不返回的函数，这种情况下，其将是void类型。第三个操作数也具有同样的约束。这使得数组的边界检查可以被方便的表示为<code>(i &gt;= 0 &amp;&amp; i &lt; 10) ? i : abort()</code>。

     <!-- As a GNU extension, the C language front-ends allow the second -->
     <!-- operand of the @code{?:} operator may be omitted in the source. -->
     <!-- For example, @code{x ? : 3} is equivalent to @code{x ? x : 3}, -->
     <!-- assuming that @code{x} is an expression without side-effects. -->
     <!-- In the tree representation, however, the second operand is always -->
     <!-- present, possibly protected by @code{SAVE_EXPR} if the first -->
     <!-- argument does cause side-effects. -->
     <p>作为GNU扩展，C语言前端允许<code>?:</code>运算符的第二个操作数可以在源程序中省略掉。例如，<code>x ? : 3</code>等价于<code>x ? x : 3</code>，假设<code>x</code>是一个没有副作用的表达式。但是，在tree的表示中，第二个操作数总是存在的，并且，如果第一个参数确实产生副作用的话，则其可能通过<code>SAVE_EXPR</code>来保护。

     <br><dt><code>CALL_EXPR</code><dd><!-- These nodes are used to represent calls to functions, including -->
<!-- non-static member functions.  @code{CALL_EXPR}s are implemented as -->
<!-- expression nodes with a variable number of operands.  Rather than using -->
<!-- @code{TREE_OPERAND} to extract them, it is preferable to use the -->
<!-- specialized accessor macros and functions that operate specifically on -->
<!-- @code{CALL_EXPR} nodes. -->
这些节点用来表示对函数的调用，包括non-static成员函数。<code>CALL_EXPR</code>被实现为一个具有可变数目操作数的表达式节点。不要用<code>TREE_OPERAND</code>来获取这些操作数，最好是用针对<code>CALL_EXPR</code>节点的特定的访问宏和函数。

     <!-- @code{CALL_EXPR_FN} returns a pointer to the -->
     <!-- function to call; it is always an expression whose type is a -->
     <!-- @code{POINTER_TYPE}. -->
     <p><code>CALL_EXPR_FN</code>返回一个调用函数的指针；其总是一个类型为<code>POINTER_TYPE</code>的表达式。

     <!-- The number of arguments to the call is returned by @code{call_expr_nargs}, -->
     <!-- while the arguments themselves can be accessed with the @code{CALL_EXPR_ARG} -->
     <!-- macro.  The arguments are zero-indexed and numbered left-to-right. -->
     <!-- You can iterate over the arguments using @code{FOR_EACH_CALL_EXPR_ARG}, as in: -->
     <p>调用函数的参数数目由<code>call_expr_nargs</code>来返回，而参数本身可以使用<code>CALL_EXPR_ARG</code>宏来访问。参数从零开始，从左向右进行索引。你可以使用<code>FOR_EACH_CALL_EXPR_ARG</code>来迭代参数，例如：

     <pre class="smallexample">          tree call, arg;
          call_expr_arg_iterator iter;
          FOR_EACH_CALL_EXPR_ARG (arg, iter, call)
            /* arg is bound to successive arguments of call.  */
            ...;
</pre>
     <!-- For non-static -->
     <!-- member functions, there will be an operand corresponding to the -->
     <!-- @code{this} pointer.  There will always be expressions corresponding to -->
     <!-- all of the arguments, even if the function is declared with default -->
     <!-- arguments and some arguments are not explicitly provided at the call -->
     <!-- sites. -->
     <p>对于non-static成员函数，将会有一个对应于<code>this</code>指针的操作数。所有的参数都会有相应的表达式，即使函数使用缺省的参数声明，并且在调用的地方，一些参数没有被显式的提供。

     <!-- @code{CALL_EXPR}s also have a @code{CALL_EXPR_STATIC_CHAIN} operand that -->
     <!-- is used to implement nested functions.  This operand is otherwise null. -->
     <p><code>CALL_EXPR</code>还有一个<code>CALL_EXPR_STATIC_CHAIN</code>操作数，用于实现嵌套函数。如果没有嵌套函数，则为null。

     <br><dt><code>CLEANUP_POINT_EXPR</code><dd><!-- These nodes represent full-expressions.  The single operand is an -->
<!-- expression to evaluate.  Any destructor calls engendered by the creation -->
<!-- of temporaries during the evaluation of that expression should be -->
<!-- performed immediately after the expression is evaluated. -->
这些节点表示full-expression。单个操作数为被求值的表达式。任何在表达式求值中通过创建临时对象所引起的析构调用，都应该在表达式求值之后立刻执行。

     <br><dt><code>CONSTRUCTOR</code><dd><!-- These nodes represent the brace-enclosed initializers for a structure or -->
<!-- array.  The first operand is reserved for use by the back end.  The -->
<!-- second operand is a @code{TREE_LIST}.  If the @code{TREE_TYPE} of the -->
<!-- @code{CONSTRUCTOR} is a @code{RECORD_TYPE} or @code{UNION_TYPE}, then -->
<!-- the @code{TREE_PURPOSE} of each node in the @code{TREE_LIST} will be a -->
<!-- @code{FIELD_DECL} and the @code{TREE_VALUE} of each node will be the -->
<!-- expression used to initialize that field. -->
这些节点表示大括号括起的，对结构体或者数组的初始化。第一个操作数被保留，用于后端。第二个操作数为<code>TREE_LIST</code>。如果<code>CONSTRUCTOR</code>的<code>TREE_TYPE</code>为一个<code>RECORD_TYPE</code>或者<code>UNION_TYPE</code>，则<code>TREE_LIST</code>中每个节点的<code>TREE_PURPOSE</code>将为一个<code>FIELD_DECL</code>，并且每个节点的<code>TREE_VALUE</code>将为初始化该域的表达式。

     <!-- If the @code{TREE_TYPE} of the @code{CONSTRUCTOR} is an -->
     <!-- @code{ARRAY_TYPE}, then the @code{TREE_PURPOSE} of each element in the -->
     <!-- @code{TREE_LIST} will be an @code{INTEGER_CST} or a @code{RANGE_EXPR} of -->
     <!-- two @code{INTEGER_CST}s.  A single @code{INTEGER_CST} indicates which -->
     <!-- element of the array (indexed from zero) is being assigned to.  A -->
     <!-- @code{RANGE_EXPR} indicates an inclusive range of elements to -->
     <!-- initialize.  In both cases the @code{TREE_VALUE} is the corresponding -->
     <!-- initializer.  It is re-evaluated for each element of a -->
     <!-- @code{RANGE_EXPR}.  If the @code{TREE_PURPOSE} is @code{NULL_TREE}, then -->
     <!-- the initializer is for the next available array element. -->
     <p>如果<code>CONSTRUCTOR</code>的<code>TREE_TYPE</code>为一个<code>ARRAY_TYPE</code>，则<code>TREE_LIST</code>中每个节点的<code>TREE_PURPOSE</code>将为一个<code>INTEGER_CST</code>，或者两个<code>INTEGER_CST</code>的<code>RANGE_EXPR</code>。单个<code>INTEGER_CST</code>指出了数组（从0开始索引）的哪个元素将被赋值。<code>RANGE_EXPR</code>指出了包含端点元素的一个范围将被初始化。这两种情况下，<code>TREE_VALUE</code>都对应初始化者。其值将对于<code>RANGE_EXPR</code>的每个元素都重新计算一次。如果<code>TREE_PURPOSE</code>是<code>NULL_TREE</code>，则初始化是针对下一个可用的数组元素。

     <!-- In the front end, you should not depend on the fields appearing in any -->
     <!-- particular order.  However, in the middle end, fields must appear in -->
     <!-- declaration order.  You should not assume that all fields will be -->
     <!-- represented.  Unrepresented fields will be set to zero. -->
     <p>在前端，你不要认为域是按照特定的顺序出现。但是，在中端，域必须按照声明的顺序出现。你不应该假设所有的域都被表示了。没有表示的域将被设置为0。

     <br><dt><code>COMPOUND_LITERAL_EXPR</code><dd><a name="index-COMPOUND_005fLITERAL_005fEXPR_005fDECL_005fEXPR-2510"></a><a name="index-COMPOUND_005fLITERAL_005fEXPR_005fDECL-2511"></a><!-- These nodes represent ISO C99 compound literals.  The -->
<!-- @code{COMPOUND_LITERAL_EXPR_DECL_EXPR} is a @code{DECL_EXPR} -->
<!-- containing an anonymous @code{VAR_DECL} for -->
<!-- the unnamed object represented by the compound literal; the -->
<!-- @code{DECL_INITIAL} of that @code{VAR_DECL} is a @code{CONSTRUCTOR} -->
<!-- representing the brace-enclosed list of initializers in the compound -->
<!-- literal.  That anonymous @code{VAR_DECL} can also be accessed directly -->
<!-- by the @code{COMPOUND_LITERAL_EXPR_DECL} macro. -->
这些节点表示复合文字。<code>COMPOUND_LITERAL_EXPR_DECL_STMT</code>为一个<code>DECL_STMT</code>，包含了一个由复合文字表示的未命名对象的匿名<code>VAR_DECL</code>；<code>VAR_DECL</code>的<code>DECL_INITIAL</code>是一个<code>CONSTRUCTOR</code>用来表示在复合文字中大括号包围的初始值列表。匿名的<code>VAR_DECL</code>还可以通过<code>COMPOUND_LITERAL_EXPR_DECL</code>宏直接访问。

     <br><dt><code>SAVE_EXPR</code><dd><!-- A @code{SAVE_EXPR} represents an expression (possibly involving -->
<!-- side-effects) that is used more than once.  The side-effects should -->
<!-- occur only the first time the expression is evaluated.  Subsequent uses -->
<!-- should just reuse the computed value.  The first operand to the -->
<!-- @code{SAVE_EXPR} is the expression to evaluate.  The side-effects should -->
<!-- be executed where the @code{SAVE_EXPR} is first encountered in a -->
<!-- depth-first preorder traversal of the expression tree. -->
<code>SAVE_EXPR</code>表示一个被多次使用的表达式（可能会有副作用）。副作用应该只在表达式第一次被求值时发生。后续的使用应该只是重用计算所得的值。<code>SAVE_EXPR</code>的第一个操作数是要求值的表达式。副作用应该在深度优先前续遍历表达式树，第一次遇到<code>SAVE_EXPR</code>时被执行。

     <br><dt><code>TARGET_EXPR</code><dd><!-- A @code{TARGET_EXPR} represents a temporary object.  The first operand -->
<!-- is a @code{VAR_DECL} for the temporary variable.  The second operand is -->
<!-- the initializer for the temporary.  The initializer is evaluated and, -->
<!-- if non-void, copied (bitwise) into the temporary.  If the initializer -->
<!-- is void, that means that it will perform the initialization itself. -->
<code>TARGET_EXPR</code>表示一个临时对象。第一个操作数是临时变量<code>VAR_DECL</code>。第二个操作数是临时变量的初始值。初始值将被求值，并且如果不是void型的，则（按位）复制到临时变量中。如果初始值是void的，意味着将会自己执行初始化。

     <!-- Often, a @code{TARGET_EXPR} occurs on the right-hand side of an -->
     <!-- assignment, or as the second operand to a comma-expression which is -->
     <!-- itself the right-hand side of an assignment, etc.  In this case, we say -->
     <!-- that the @code{TARGET_EXPR} is ``normal''; otherwise, we say it is -->
     <!-- ``orphaned''.  For a normal @code{TARGET_EXPR} the temporary variable -->
     <!-- should be treated as an alias for the left-hand side of the assignment, -->
     <!-- rather than as a new temporary variable. -->
     <p>很多时候，<code>TARGET_EXPR</code>会出现在赋值的右边，或者作为逗号表达式的第二个操作数。 这种情况下，我们说<code>TARGET_EXPR</code>是“normal”的；否则，我们说它是“orphaned”。对于一个正常的<code>TARGET_EXPR</code>，临时变量应被视为赋值的左端的一个别名，而不是一个新的临时变量。

     <!-- The third operand to the @code{TARGET_EXPR}, if present, is a -->
     <!-- cleanup-expression (i.e., destructor call) for the temporary.  If this -->
     <!-- expression is orphaned, then this expression must be executed when the -->
     <!-- statement containing this expression is complete.  These cleanups must -->
     <!-- always be executed in the order opposite to that in which they were -->
     <!-- encountered.  Note that if a temporary is created on one branch of a -->
     <!-- conditional operator (i.e., in the second or third operand to a -->
     <!-- @code{COND_EXPR}), the cleanup must be run only if that branch is -->
     <!-- actually executed. -->
     <p><code>TARGET_EXPR</code>的第三个操作数，如果存在的话，是临时变量的清理表达式（即析构调用）。如果该表达式是孤儿的，则该表达式必须当包含它的语句是完整的时候被执行。这些清理必须总是按照相反的顺序执行。注意如果临时变量是在条件操作符的分支上创建的（即，<code>COND_EXPR</code>的第二个或第三个操作数），则清理必须只有在该分支实际被执行时才运行。

     <br><dt><code>VA_ARG_EXPR</code><dd><!-- This node is used to implement support for the C/C++ variable argument-list -->
<!-- mechanism.  It represents expressions like @code{va_arg (ap, type)}. -->
<!-- Its @code{TREE_TYPE} yields the tree representation for @code{type} and -->
<!-- its sole argument yields the representation for @code{ap}. -->
该节点用来实现对C/C++可变参数列表机制的支持。它表示了像<code>va_arg (ap, type)</code>这样的表达式。它的<code>TREE_TYPE</code>用来产生<code>type</code>的树表示，唯一的参数用来产生对<code>ap</code>的表示。
</dl>

<!-- @node Vectors -->
<!-- @subsection Vectors -->
 </body></html>

