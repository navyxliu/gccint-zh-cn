<html lang="zh">
<head>
<title>Modifiers - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Constraints.html#Constraints" title="Constraints">
<link rel="prev" href="Class-Preferences.html#Class-Preferences" title="Class Preferences">
<link rel="next" href="Disable-Insn-Alternatives.html#Disable-Insn-Alternatives" title="Disable Insn Alternatives">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Modifiers"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Disable-Insn-Alternatives.html#Disable-Insn-Alternatives">Disable Insn Alternatives</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Class-Preferences.html#Class-Preferences">Class Preferences</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Constraints.html#Constraints">Constraints</a>
<hr>
</div>

<h4 class="subsection">16.8.4 constraint修饰符</h4>

<p><a name="index-modifiers-in-constraints-3311"></a><a name="index-constraint-modifier-characters-3312"></a>
<!-- @c prevent bad page break with this line -->
<!-- Here are constraint modifier characters. -->
<!-- prevent bad page break with this line -->
这里是约束修饰符。

     
<a name="index-g_t_0040samp_007b_003d_007d-in-constraint-3313"></a>
<dl><dt>&lsquo;<samp><span class="samp">=</span></samp>&rsquo;<dd><!-- Means that this operand is write-only for this instruction: the previous -->
<!-- value is discarded and replaced by output data. -->
意味着该指令的该操作数为只写的：先前的值将被丢弃并且由输出数据替换。

     <p><a name="index-g_t_0040samp_007b_002b_007d-in-constraint-3314"></a><br><dt>&lsquo;<samp><span class="samp">+</span></samp>&rsquo;<dd><!-- Means that this operand is both read and written by the instruction. -->
意味着该操作数可以由指令读和写。

     <!-- When the compiler fixes up the operands to satisfy the constraints, -->
     <!-- it needs to know which operands are inputs to the instruction and -->
     <!-- which are outputs from it.  @samp{=} identifies an output; @samp{+} -->
     <!-- identifies an operand that is both input and output; all other operands -->
     <!-- are assumed to be input only. -->
     <p>当编译器修订操作数来满足约束时，
它需要知道哪些操作数为指令的输入以及哪些为它的输出。&lsquo;<samp><span class="samp">=</span></samp>&rsquo;表示一个输出；
&lsquo;<samp><span class="samp">+</span></samp>&rsquo;表示一个操作数同时为输入和输出；所有其它操作数将被认为只是输入。

     <!-- If you specify @samp{=} or @samp{+} in a constraint, you put it in the -->
     <!-- first character of the constraint string. -->
     <p>如果你指定了&lsquo;<samp><span class="samp">=</span></samp>&rsquo;或者&lsquo;<samp><span class="samp">+</span></samp>&rsquo;，你要将它作为约束字符串的第一个字符。

     <!-- @cindex @samp{&} in constraint -->
     <!-- @cindex earlyclobber operand -->
     <!-- @item & -->
     <!-- Means (in a particular alternative) that this operand is an -->
     <!-- @dfn{earlyclobber} operand, which is modified before the instruction is -->
     <!-- finished using the input operands.  Therefore, this operand may not lie -->
     <!-- in a register that is used as an input operand or as part of any memory -->
     <!-- address. -->
     <!-- @samp{&} applies only to the alternative in which it is written.  In -->
     <!-- constraints with multiple alternatives, sometimes one alternative -->
     <!-- requires @samp{&} while others do not.  See, for example, the -->
     <!-- @samp{movdf} insn of the 68000. -->
     <!-- An input operand can be tied to an earlyclobber operand if its only -->
     <!-- use as an input occurs before the early result is written.  Adding -->
     <!-- alternatives of this form often allows GCC to produce better code -->
     <!-- when only some of the inputs can be affected by the earlyclobber. -->
     <!-- See, for example, the @samp{mulsi3} insn of the ARM@. -->
     <!-- @samp{&} does not obviate the need to write @samp{=}. -->
     <p><a name="index-g_t_0040samp_007b_0026_007d-in-constraint-3315"></a><a name="index-earlyclobber-operand-3316"></a><br><dt>&lsquo;<samp><span class="samp">&amp;</span></samp>&rsquo;<dd>意味着（在一个特别的可选项中）该操作数为一个<dfn>earlyclobber</dfn>操作数，
其在指令完成使用输入操作数之前就被修改了。
因此该操作数可能不在被用作输入操作数或者用作任何内存地址的一部分的寄存器中。

     <p>&lsquo;<samp><span class="samp">&amp;</span></samp>&rsquo;只应用于其所在的可选项。在具有多个可选项的约束中，
有时一个可选项需要&lsquo;<samp><span class="samp">&amp;</span></samp>&rsquo;，而其它的不需要。例如，参见68000的&lsquo;<samp><span class="samp">movdf</span></samp>&rsquo; insn。

     <p>一个输入操作数可以被限定为一个earlyclobber操作数，
如果它唯一的作为输入的使用发生在早期结果被写出之前。
增加这种形式的可选项经常可以允许GCC来产生更好的代码，
当只有一些输出可以被earlyclobber影响时。例如，参见ARM的&lsquo;<samp><span class="samp">mulsi3</span></samp>&rsquo; insn。

     <p>&lsquo;<samp><span class="samp">&amp;</span></samp>&rsquo;不排除对&lsquo;<samp><span class="samp">=</span></samp>&rsquo;的需要。

     <!-- @cindex @samp{%} in constraint -->
     <!-- @item % -->
     <!-- Declares the instruction to be commutative for this operand and the -->
     <!-- following operand.  This means that the compiler may interchange the -->
     <!-- two operands if that is the cheapest way to make all operands fit the -->
     <!-- constraints. -->
     <!-- @ifset INTERNALS -->
     <!-- This is often used in patterns for addition instructions -->
     <!-- that really have only two operands: the result must go in one of the -->
     <!-- arguments.  Here for example, is how the 68000 halfword-add -->
     <!-- instruction is defined: -->
     <!-- @smallexample -->
     <!-- (define_insn "addhi3" -->
     <!-- [(set (match_operand:HI 0 "general_operand" "=m,r") -->
     <!-- (plus:HI (match_operand:HI 1 "general_operand" "%0,0") -->
     <!-- (match_operand:HI 2 "general_operand" "di,g")))] -->
     <!-- @dots{}) -->
     <!-- @end smallexample -->
     <!-- @end ifset -->
     <!-- GCC can only handle one commutative pair in an asm; if you use more, -->
     <!-- the compiler may fail.  Note that you need not use the modifier if -->
     <!-- the two alternatives are strictly identical; this would only waste -->
     <!-- time in the reload pass.  The modifier is not operational after -->
     <!-- register allocation, so the result of @code{define_peephole2} -->
     <!-- and @code{define_split}s performed after reload cannot rely on -->
     <!-- @samp{%} to make the intended insn match. -->
     <p><a name="index-g_t_0040samp_007b_0025_007d-in-constraint-3317"></a><br><dt>&lsquo;<samp><span class="samp">%</span></samp>&rsquo;<dd>声明指令对于该操作数和随后的操作数是可交换的。这意味着编译器可以交换两操作数，
如果有更廉价的方式来使得所有操作数都适合约束。
这经常被用于实际上只有两个操作数的加法指令中：结果必须放在一个参数中。
这里有个例子，是68000半字加指令如何被定义的：

     <pre class="smallexample">          (define_insn "addhi3"
            [(set (match_operand:HI 0 "general_operand" "=m,r")
               (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
                        (match_operand:HI 2 "general_operand" "di,g")))]
            ...)
</pre>
     <p>GCC只能处理在asm中的一个可交换对；如果你有更多的，编译器将会失败。
注意如果两个可选项严格相同，则不需要使用该修饰符；这只会在重载过程浪费时间。
该修饰符在寄存器分配之后，是不可操作的，
所以在重载之后执行的<code>define_peephole2</code>和<code>define_split</code>的结果不能依赖
&lsquo;<samp><span class="samp">%</span></samp>&rsquo;来进行insn匹配。

     <!-- @cindex @samp{#} in constraint -->
     <!-- @item # -->
     <!-- Says that all following characters, up to the next comma, are to be -->
     <!-- ignored as a constraint.  They are significant only for choosing -->
     <!-- register preferences. -->
     <p><a name="index-g_t_0040samp_007b_0023_007d-in-constraint-3318"></a><br><dt>&lsquo;<samp><span class="samp">#</span></samp>&rsquo;<dd>表示所有后续的字符，直到下一个逗号，作为约束都被忽略掉。
它们只对选择寄存器优先时有意义。

     <!-- @cindex @samp{*} in constraint -->
     <!-- @item * -->
     <!-- Says that the following character should be ignored when choosing -->
     <!-- register preferences.  @samp{*} has no effect on the meaning of the -->
     <!-- constraint as a constraint, and no effect on reloading. -->
     <p><a name="index-g_t_0040samp_007b_002a_007d-in-constraint-3319"></a><br><dt>&lsquo;<samp><span class="samp">*</span></samp>&rsquo;<dd>表示后续字符在选择寄存器优先时应该被忽略掉。&lsquo;<samp><span class="samp">*</span></samp>&rsquo;对于重载没有影响。

     <!-- @ifset INTERNALS -->
     <!-- Here is an example: the 68000 has an instruction to sign-extend a -->
     <!-- halfword in a data register, and can also sign-extend a value by -->
     <!-- copying it into an address register.  While either kind of register is -->
     <!-- acceptable, the constraints on an address-register destination are -->
     <!-- less strict, so it is best if register allocation makes an address -->
     <!-- register its goal.  Therefore, @samp{*} is used so that the @samp{d} -->
     <!-- constraint letter (for data register) is ignored when computing -->
     <!-- register preferences. -->
     <!-- @smallexample -->
     <!-- (define_insn "extendhisi2" -->
     <!-- [(set (match_operand:SI 0 "general_operand" "=*d,a") -->
     <!-- (sign_extend:SI -->
     <!-- (match_operand:HI 1 "general_operand" "0,g")))] -->
     <!-- @dots{}) -->
     <!-- @end smallexample -->
     <!-- @end ifset -->
     <!-- @end table -->
     <p>这里有一个例子：68000有一条指令，用于在数据寄存器中符号扩展一个半字，
并且还可以通过将其复制到一个地址寄存器中来符号扩展一个值。
当每种寄存器都可以被接受时，对于地址寄存器的约束相对不是很严格，
所以最好是寄存器分配将地址寄存器作为其目标。
因此，&lsquo;<samp><span class="samp">*</span></samp>&rsquo;被使用，以至于&lsquo;<samp><span class="samp">d</span></samp>&rsquo;约束字母（数据寄存器）被忽略，
当计算寄存器优先时。

     <pre class="smallexample">          (define_insn "extendhisi2"
            [(set (match_operand:SI 0 "general_operand" "=*d,a")
                  (sign_extend:SI
                   (match_operand:HI 1 "general_operand" "0,g")))]
            ...)
</pre>
     </dl>

<!-- @node Machine Constraints -->
<!-- @subsection Constraints for Particular Machines -->
<!-- @cindex machine specific constraints -->
<!-- @cindex constraints, machine specific -->
 </body></html>

