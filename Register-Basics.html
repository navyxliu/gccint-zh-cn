<html lang="zh">
<head>
<title>Register Basics - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Registers.html#Registers" title="Registers">
<link rel="next" href="Allocation-Order.html#Allocation-Order" title="Allocation Order">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Register-Basics"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Allocation-Order.html#Allocation-Order">Allocation Order</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Registers.html#Registers">Registers</a>
<hr>
</div>

<h4 class="subsection">17.7.1 寄存器的基本特征</h4>

<!-- prevent bad page break with this line -->
<!-- Registers have various characteristics. -->
<p>寄存器具有多种特征。

<div class="defun">
&mdash; Macro: <b>FIRST_PSEUDO_REGISTER</b><var><a name="index-FIRST_005fPSEUDO_005fREGISTER-3947"></a></var><br>
<blockquote><!-- Number of hardware registers known to the compiler.  They receive -->
     <!-- numbers 0 through @code{FIRST_PSEUDO_REGISTER-1}; thus, the first -->
     <!-- pseudo register's number really is assigned the number -->
     <!-- @code{FIRST_PSEUDO_REGISTER}. -->
      <p>编译器所知道的硬件寄存器个数。它们包括编号0到<code>FIRST_PSEUDO_REGISTER-1</code>；因此，第一个伪寄存器的编号实际被赋值为<code>FIRST_PSEUDO_REGISTER</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FIXED_REGISTERS</b><var><a name="index-FIXED_005fREGISTERS-3948"></a></var><br>
<blockquote><p><a name="index-fixed-register-3949"></a><!-- An initializer that says which registers are used for fixed purposes -->
<!-- all throughout the compiled code and are therefore not available for -->
<!-- general allocation.  These would include the stack pointer, the frame -->
<!-- pointer (except on machines where that can be used as a general -->
<!-- register when no frame pointer is needed), the program counter on -->
<!-- machines where that is considered one of the addressable registers, -->
<!-- and any other numbered register with a standard use. -->
一个初始化，用来说明哪些寄存器在整个被编译的代码中都具有固定用途，因此不能用于通用分配。这些将包括栈指针，帧指针（在一些机器上，当不需要帧指针时，其可以作为通用寄存器来使用），在一些机器上被认为是寻址寄存器的程序计数器，以及其它具有标准用法的编号寄存器。

     <!-- This information is expressed as a sequence of numbers, separated by -->
     <!-- commas and surrounded by braces.  The @var{n}th number is 1 if -->
     <!-- register @var{n} is fixed, 0 otherwise. -->
      <p>这些信息通过一个逗号分隔，大括号包裹的编号序列来表示。如果寄存器<var>n</var>为固定的，则第<var>n</var>个编号为1，否则为0。

     <!-- The table initialized from this macro, and the table initialized by -->
     <!-- the following one, may be overridden at run time either automatically, -->
     <!-- by the actions of the macro @code{CONDITIONAL_REGISTER_USAGE}, or by -->
     <!-- the user with the command options @option{-ffixed-@var{reg}}, -->
     <!-- @option{-fcall-used-@var{reg}} and @option{-fcall-saved-@var{reg}}. -->
      <p>通过该宏初始化的表格，以及通过下面的宏初始化的表格，其内容都可以在运行时，通过执行宏<code>CONDITIONAL_REGISTER_USAGE</code>，或者通过用户命令选项<samp><span class="option">-ffixed-</span><var>reg</var></samp>，<samp><span class="option">-fcall-used-</span><var>reg</var></samp>和<samp><span class="option">-fcall-saved-</span><var>reg</var></samp>来覆盖。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CALL_USED_REGISTERS</b><var><a name="index-CALL_005fUSED_005fREGISTERS-3950"></a></var><br>
<blockquote><p><a name="index-call_002dused-register-3951"></a><a name="index-call_002dclobbered-register-3952"></a><a name="index-call_002dsaved-register-3953"></a><!-- Like @code{FIXED_REGISTERS} but has 1 for each register that is -->
<!-- clobbered (in general) by function calls as well as for fixed -->
<!-- registers.  This macro therefore identifies the registers that are not -->
<!-- available for general allocation of values that must live across -->
<!-- function calls. -->
类似于<code>FIXED_REGISTERS</code>，对于被函数调用破坏的寄存器，以及固定寄存器，其值为1。因此，该宏标识了哪些寄存器不适合用于活跃信息跨函数调用的值的通用分配。

     <!-- If a register has 0 in @code{CALL_USED_REGISTERS}, the compiler -->
     <!-- automatically saves it on function entry and restores it on function -->
     <!-- exit, if the register is used within the function. -->
      <p>如果寄存器在<code>CALL_USED_REGISTERS</code>中的值为0，则当寄存器在函数中被使用时，编译器会自动在函数入口保存它，并在函数出口恢复它。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CALL_REALLY_USED_REGISTERS</b><var><a name="index-CALL_005fREALLY_005fUSED_005fREGISTERS-3954"></a></var><br>
<blockquote><p><a name="index-call_002dused-register-3955"></a><a name="index-call_002dclobbered-register-3956"></a><a name="index-call_002dsaved-register-3957"></a><!-- Like @code{CALL_USED_REGISTERS} except this macro doesn't require -->
<!-- that the entire set of @code{FIXED_REGISTERS} be included. -->
<!-- (@code{CALL_USED_REGISTERS} must be a superset of @code{FIXED_REGISTERS}). -->
<!-- This macro is optional.  If not specified, it defaults to the value -->
<!-- of @code{CALL_USED_REGISTERS}. -->
类似于<code>CALL_USED_REGISTERS</code>，但是该宏不需要包含整个<code>FIXED_REGISTERS</code>集。（<code>CALL_USED_REGISTERS</code>必须为<code>FIXED_REGISTERS</code>的超集）。该宏为可选的。如果没有被定义，其缺省值为<code>CALL_USED_REGISTERS</code>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HARD_REGNO_CALL_PART_CLOBBERED</b> (<var>regno, mode</var>)<var><a name="index-HARD_005fREGNO_005fCALL_005fPART_005fCLOBBERED-3958"></a></var><br>
<blockquote><p><a name="index-call_002dused-register-3959"></a><a name="index-call_002dclobbered-register-3960"></a><a name="index-call_002dsaved-register-3961"></a><!-- A C expression that is nonzero if it is not permissible to store a -->
<!-- value of mode @var{mode} in hard register number @var{regno} across a -->
<!-- call without some part of it being clobbered.  For most machines this -->
<!-- macro need not be defined.  It is only required for machines that do not -->
<!-- preserve the entire contents of a register across a call. -->
一个C表达式，如果不允许将机器模式为<var>mode</var>的值存储在编号为<var>regno</var>的硬件寄存器中，并且整个调用中没有破坏其某个部分，则值为非0。对于大多数机器，该宏不需要被定义。其只用于一些在调用中不保留寄存器的整个内容的机器上。
</p></blockquote></div>

 <p><a name="index-fixed_005fregs-3962"></a><a name="index-call_005fused_005fregs-3963"></a><a name="index-global_005fregs-3964"></a><a name="index-reg_005fnames-3965"></a><a name="index-reg_005fclass_005fcontents-3966"></a>

<div class="defun">
&mdash; Target Hook: void <b>TARGET_CONDITIONAL_REGISTER_USAGE</b> (<var>void</var>)<var><a name="index-TARGET_005fCONDITIONAL_005fREGISTER_005fUSAGE-3967"></a></var><br>
<blockquote><!-- This hook may conditionally modify five variables -->
     <!-- @code{fixed_regs}, @code{call_used_regs}, @code{global_regs}, -->
     <!-- @code{reg_names}, and @code{reg_class_contents}, to take into account -->
     <!-- any dependence of these register sets on target flags.  The first three -->
     <!-- of these are of type @code{char []} (interpreted as Boolean vectors). -->
     <!-- @code{global_regs} is a @code{const char *[]}, and -->
     <!-- @code{reg_class_contents} is a @code{HARD_REG_SET}.  Before the macro is -->
     <!-- called, @code{fixed_regs}, @code{call_used_regs}, -->
     <!-- @code{reg_class_contents}, and @code{reg_names} have been initialized -->
     <!-- from @code{FIXED_REGISTERS}, @code{CALL_USED_REGISTERS}, -->
     <!-- @code{REG_CLASS_CONTENTS}, and @code{REGISTER_NAMES}, respectively. -->
     <!-- @code{global_regs} has been cleared, and any @option{-ffixed-@var{reg}}, -->
     <!-- @option{-fcall-used-@var{reg}} and @option{-fcall-saved-@var{reg}} -->
     <!-- command options have been applied. -->
      <p>该钩子可以条件修改<code>fixed_regs</code>，<code>call_used_rehs</code>，<code>global_regs</code>，<code>reg_names</code>和<code>reg_class_contents</code>这5个变量，用于当这些寄存器集对目标机标记（target flags）有任何依赖的情况下。前3个为<code>char []</code>类型（作为布尔向量来解析）。<code>global_regs</code>为一个<code>const char *[]</code>，<code>reg_class_contents</code>为一个<code>HARD_REG_SET</code>。在宏被调用之前，<code>fixed_regs</code>, <code>call_used_regs</code>, <code>reg_class_contents</code>和<code>reg_names</code>已经分别通过<code>FIXED_REGISTERS</code>, <code>CALL_USED_REGISTERS</code>, <code>REG_CLASS_CONTENTS</code>和<code>REGISTER_NAMES</code>被初始化。<code>global_regs</code>已经被清除，并且所有<samp><span class="option">-ffixed-</span><var>reg</var></samp>, <samp><span class="option">-fcall-used-</span><var>reg</var></samp>和<samp><span class="option">-fcall-saved-</span><var>reg</var></samp>选项都已经被应用。

     <!-- You need not define this macro if it has no work to do. -->
      <p>如果不需要做什么工作，则不必定义该宏。

      <p><a name="index-disabling-certain-registers-3968"></a><a name="index-controlling-register-usage-3969"></a><!-- If the usage of an entire class of registers depends on the target -->
<!-- flags, you may indicate this to GCC by using this macro to modify -->
<!-- @code{fixed_regs} and @code{call_used_regs} to 1 for each of the -->
<!-- registers in the classes which should not be used by GCC@.  Also define -->
<!-- the macro @code{REG_CLASS_FROM_LETTER} / @code{REG_CLASS_FROM_CONSTRAINT} -->
<!-- to return @code{NO_REGS} if it -->
<!-- is called with a letter for a class that shouldn't be used. -->
如果整个寄存器类别的使用，取决于目标机标记，则对于类别中的每个不应由GCC使用的寄存器，你可以通过使用该宏来指示GCC修改<code>fixed_regs</code>和<code>call_used_regs</code>为1。还有就是，如果其被调用，并带有一个不应该被使用的类别字母，则可以定义宏<code>REG_CLASS_FROM_LETTER</code> / <code>REG_CLASS_FROM_CONSTRAINT</code>来返回<code>NO_REGS</code>。

     <!-- (However, if this class is not included in @code{GENERAL_REGS} and all -->
     <!-- of the insn patterns whose constraints permit this class are -->
     <!-- controlled by target switches, then GCC will automatically avoid using -->
     <!-- these registers when the target switches are opposed to them.) -->
      <p>（然而，如果该类别没有包含在<code>GENERAL_REGS</code>中，并且所有的指令模式（insn patterns）的约束允许该类别通过目标机开关来控制，则当目标机开关与它们相反时，GCC将自动避免使用这些寄存器。）
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INCOMING_REGNO</b> (<var>out</var>)<var><a name="index-INCOMING_005fREGNO-3970"></a></var><br>
<blockquote><!-- Define this macro if the target machine has register windows.  This C -->
     <!-- expression returns the register number as seen by the called function -->
     <!-- corresponding to the register number @var{out} as seen by the calling -->
     <!-- function.  Return @var{out} if register number @var{out} is not an -->
     <!-- outbound register. -->
      <p>如果目标机器具有寄存器窗口，则定义该宏。该C表达式，根据调用函数能看到的寄存器编号<var>out</var>，返回被调用函数所能看到的寄存器编号。如果寄存器编号<var>out</var>不是一个出站寄存器（outbound register），则返回<var>out</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>OUTGOING_REGNO</b> (<var>in</var>)<var><a name="index-OUTGOING_005fREGNO-3971"></a></var><br>
<blockquote><!-- Define this macro if the target machine has register windows.  This C -->
     <!-- expression returns the register number as seen by the calling function -->
     <!-- corresponding to the register number @var{in} as seen by the called -->
     <!-- function.  Return @var{in} if register number @var{in} is not an inbound -->
     <!-- register. -->
      <p>如果目标机器具有寄存器窗口，则定义该宏。该C表达式，根据被调用函数能看到的寄存器编号<var>in</var>，返回调用函数所能看到的寄存器编号。如果寄存器编号<var>in</var>不是一个进站寄存器（inbound register），则返回<var>in</var>。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>LOCAL_REGNO</b> (<var>regno</var>)<var><a name="index-LOCAL_005fREGNO-3972"></a></var><br>
<blockquote><!-- Define this macro if the target machine has register windows.  This C -->
     <!-- expression returns true if the register is call-saved but is in the -->
     <!-- register window.  Unlike most call-saved registers, such registers -->
     <!-- need not be explicitly restored on function exit or during non-local -->
     <!-- gotos. -->
      <p>如果目标机器具有寄存器窗口，则定义该宏。该C表达式，当寄存器为调用保存的，并且在寄存器窗口中时，返回真。不像大多调用保存的寄存器，这样的寄存器不需要在函数出口或者非局部goto中被显式的恢复。
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PC_REGNUM</b><var><a name="index-PC_005fREGNUM-3973"></a></var><br>
<blockquote><!-- If the program counter has a register number, define this as that -->
     <!-- register number.  Otherwise, do not define it. -->
      <p>如果程序计数器具有一个寄存器编号，则将其定义为那个寄存器编号。否则不要定义它。
</p></blockquote></div>

<!-- @node Allocation Order -->
<!-- @subsection Order of Allocation of Registers -->
 </body></html>

