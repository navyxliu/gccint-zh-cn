<html lang="zh">
<head>
<title>Insn Splitting - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Machine-Desc.html#Machine-Desc" title="Machine Desc">
<link rel="prev" href="Expander-Definitions.html#Expander-Definitions" title="Expander Definitions">
<link rel="next" href="Including-Patterns.html#Including-Patterns" title="Including Patterns">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Insn-Splitting"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Including-Patterns.html#Including-Patterns">Including Patterns</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Expander-Definitions.html#Expander-Definitions">Expander Definitions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Machine-Desc.html#Machine-Desc">Machine Desc</a>
<hr>
</div>

<h3 class="section">16.16 定义如何拆分指令</h3>

<p><a name="index-insn-splitting-3608"></a><a name="index-instruction-splitting-3609"></a><a name="index-splitting-instructions-3610"></a>
<!-- There are two cases where you should specify how to split a pattern -->
<!-- into multiple insns.  On machines that have instructions requiring -->
<!-- delay slots (@pxref{Delay Slots}) or that have instructions whose -->
<!-- output is not available for multiple cycles (@pxref{Processor pipeline -->
<!-- description}), the compiler phases that optimize these cases need to -->
<!-- be able to move insns into one-instruction delay slots.  However, some -->
<!-- insns may generate more than one machine instruction.  These insns -->
<!-- cannot be placed into a delay slot. -->
<!-- Often you can rewrite the single insn as a list of individual insns, -->
<!-- each corresponding to one machine instruction.  The disadvantage of -->
<!-- doing so is that it will cause the compilation to be slower and require -->
<!-- more space.  If the resulting insns are too complex, it may also -->
<!-- suppress some optimizations.  The compiler splits the insn if there is a -->
<!-- reason to believe that it might improve instruction or delay slot -->
<!-- scheduling. -->
<!-- The insn combiner phase also splits putative insns.  If three insns are -->
<!-- merged into one insn with a complex expression that cannot be matched by -->
<!-- some @code{define_insn} pattern, the combiner phase attempts to split -->
<!-- the complex pattern into two insns that are recognized.  Usually it can -->
<!-- break the complex pattern into two patterns by splitting out some -->
<!-- subexpression.  However, in some other cases, such as performing an -->
<!-- addition of a large constant in two insns on a RISC machine, the way to -->
<!-- split the addition into two insns is machine-dependent. -->
有两种情况，你应该指定如何将一个指令模式拆分为多个insn。在一些机器上，
指令需要延迟槽（参见<a href="Delay-Slots.html#Delay-Slots">Delay Slots</a>）或者指令的输出对于多周期
（参见<a href="Processor-pipeline-description.html#Processor-pipeline-description">Processor pipeline description</a>）不可用，
则优化这些情况的编译器过程需要能够将insn移入延迟槽中。但是，
一些insn可能会生成不止一条机器指令。这些insn则不能被放入延迟槽。

 <p>通常你可以重写单个insn为单独的insn列表，每个对应于一条机器指令。
这样做的缺点是它将造成编译变慢并且需要更多的空间。如果结果insn太复杂，
则还会抑制一些优化。当编译器有理由相信可以改进指令或者延迟槽调度的时候，
则会拆分insn。

 <p>insn组合器阶段还拆分putative insns。
如果三个insn被合并到一个使用复杂表达式的insn，
其不能被某个<code>define_insn</code>模式匹配，
则组合器阶段尝试将复杂指令模式拆分为两个被识别的insn。通常，
它能够将复杂指令模式通过拆分某个子表达式来断开。但是，有些情况下，
像在一个RISC机器上执行一个大常量的加法，则拆分加法为两个insn的方式是机器相关的。

<!-- @findex define_split -->
<!-- The @code{define_split} definition tells the compiler how to split a -->
<!-- complex insn into several simpler insns.  It looks like this: -->
<!-- @smallexample -->
<!-- (define_split -->
<!-- [@var{insn-pattern}] -->
<!-- "@var{condition}" -->
<!-- [@var{new-insn-pattern-1} -->
<!-- @var{new-insn-pattern-2} -->
<!-- @dots{}] -->
<!-- "@var{preparation-statements}") -->
<!-- @end smallexample -->
 <p><a name="index-define_005fsplit-3611"></a><code>define_split</code>定义告诉了编译器如何将一个复杂的insn拆分为多个简单的insn。
它的形式为：

<pre class="smallexample">     (define_split
       [<var>insn-pattern</var>]
       "<var>condition</var>"
       [<var>new-insn-pattern-1</var>
        <var>new-insn-pattern-2</var>
        ...]
       "<var>preparation-statements</var>")
</pre>
 <!-- @var{insn-pattern} is a pattern that needs to be split and -->
<!-- @var{condition} is the final condition to be tested, as in a -->
<!-- @code{define_insn}.  When an insn matching @var{insn-pattern} and -->
<!-- satisfying @var{condition} is found, it is replaced in the insn list -->
<!-- with the insns given by @var{new-insn-pattern-1}, -->
<!-- @var{new-insn-pattern-2}, etc. -->
<!-- The @var{preparation-statements} are similar to those statements that -->
<!-- are specified for @code{define_expand} (@pxref{Expander Definitions}) -->
<!-- and are executed before the new RTL is generated to prepare for the -->
<!-- generated code or emit some insns whose pattern is not fixed.  Unlike -->
<!-- those in @code{define_expand}, however, these statements must not -->
<!-- generate any new pseudo-registers.  Once reload has completed, they also -->
<!-- must not allocate any space in the stack frame. -->
<!-- Patterns are matched against @var{insn-pattern} in two different -->
<!-- circumstances.  If an insn needs to be split for delay slot scheduling -->
<!-- or insn scheduling, the insn is already known to be valid, which means -->
<!-- that it must have been matched by some @code{define_insn} and, if -->
<!-- @code{reload_completed} is nonzero, is known to satisfy the constraints -->
<!-- of that @code{define_insn}.  In that case, the new insn patterns must -->
<!-- also be insns that are matched by some @code{define_insn} and, if -->
<!-- @code{reload_completed} is nonzero, must also satisfy the constraints -->
<!-- of those definitions. -->
<!-- As an example of this usage of @code{define_split}, consider the following -->
<!-- example from @file{a29k.md}, which splits a @code{sign_extend} from -->
<!-- @code{HImode} to @code{SImode} into a pair of shift insns: -->
 <p><var>insn-pattern</var>为需要被拆分的指令模式，<var>condition</var>为要被测试的最终条件，
跟<code>define_insn</code>中的一样。当一个insn匹配<var>insn-pattern</var>，
并且满足条件<var>condition</var>，则它由insn列表<var>new-insn-pattern-1</var>,
<var>new-insn-pattern-2</var>等来替换。

 <p><var>preparation-statements</var>与那些为<code>define_expand</code>（参见<a href="Expander-Definitions.html#Expander-Definitions">Expander Definitions</a>）
指定的语句类似，并且在生成新RTL之前被执行。
与<code>define_expand</code>中的不同之处为，这些语句不能生成任何新的伪寄存器。
一旦完成重载，它们则不能在栈帧中分配任何空间。

 <p>指令模式根据两种不同的环境来匹配<var>insn-pattern</var>。
如果需要为延迟槽调度或者insn调度来拆分insn，则insn已经是有效的，
这意味着它已经被一些<code>define_insn</code>匹配过，
并且如果<code>reload_completed</code>为非0，则已经满足那个<code>define_insn</code>的约束。
在那种情况下，新的insn模式必须也是匹配某个<code>define_insn</code>的insn，
并且如果<code>reload_completed</code>为非0，则也必须满足那些定义的约束。

 <p>对于这种<code>define_split</code>用法的例子，考虑下面来自<samp><span class="file">a29k.md</span></samp>的例子，
其将从<code>HImode</code>到<code>SImode</code>的<code>sign_extend</code>拆分为一对shift insn：

<pre class="smallexample">     (define_split
       [(set (match_operand:SI 0 "gen_reg_operand" "")
             (sign_extend:SI (match_operand:HI 1 "gen_reg_operand" "")))]
       ""
       [(set (match_dup 0)
             (ashift:SI (match_dup 1)
                        (const_int 16)))
        (set (match_dup 0)
             (ashiftrt:SI (match_dup 0)
                          (const_int 16)))]
       "
     { operands[1] = gen_lowpart (SImode, operands[1]); }")
</pre>
 <!-- When the combiner phase tries to split an insn pattern, it is always the -->
<!-- case that the pattern is @emph{not} matched by any @code{define_insn}. -->
<!-- The combiner pass first tries to split a single @code{set} expression -->
<!-- and then the same @code{set} expression inside a @code{parallel}, but -->
<!-- followed by a @code{clobber} of a pseudo-reg to use as a scratch -->
<!-- register.  In these cases, the combiner expects exactly two new insn -->
<!-- patterns to be generated.  It will verify that these patterns match some -->
<!-- @code{define_insn} definitions, so you need not do this test in the -->
<!-- @code{define_split} (of course, there is no point in writing a -->
<!-- @code{define_split} that will never produce insns that match). -->
<!-- Here is an example of this use of @code{define_split}, taken from -->
<!-- @file{rs6000.md}: -->
 <p>当组合器阶段尝试拆分一个insn模式时，则情况总是为，
指令模式没有被任何<code>define_insn</code>匹配。
组合器过程首先尝试将单个<code>set</code>表达式拆分，
然后是在<code>parallel</code>中的相同的<code>set</code>表达式，
不过跟随一个伪寄存器的<code>clobber</code>，以作为scratch寄存器来使用。
这这些情况下，组合器期望能够生成两个新的insn。
它将验证这些指令模式匹配某个<code>define_insn</code>定义，
所以你不需要在<code>define_split</code>中做这些测试（当然，there is no point in writing a <code>define_split</code> that will never produce insns that match).

<pre class="smallexample">     (define_split
       [(set (match_operand:SI 0 "gen_reg_operand" "")
             (plus:SI (match_operand:SI 1 "gen_reg_operand" "")
                      (match_operand:SI 2 "non_add_cint_operand" "")))]
       ""
       [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))
        (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]
     "
     {
       int low = INTVAL (operands[2]) &amp; 0xffff;
       int high = (unsigned) INTVAL (operands[2]) &gt;&gt; 16;
     
       if (low &amp; 0x8000)
         high++, low |= 0xffff0000;
     
       operands[3] = GEN_INT (high &lt;&lt; 16);
       operands[4] = GEN_INT (low);
     }")
</pre>
 <!-- Here the predicate @code{non_add_cint_operand} matches any -->
<!-- @code{const_int} that is @emph{not} a valid operand of a single add -->
<!-- insn.  The add with the smaller displacement is written so that it -->
<!-- can be substituted into the address of a subsequent operation. -->
<!-- An example that uses a scratch register, from the same file, generates -->
<!-- an equality comparison of a register and a large constant: -->
 <p>这里断言<code>non_add_cint_operand</code>匹配任何不是单个add insn的有效操作数的
<code>const_int</code>。

 <p>使用scratch寄存器的例子，来自同一个文件，
用来生成等价的寄存器和大常量的比较运算：

<pre class="smallexample">     (define_split
       [(set (match_operand:CC 0 "cc_reg_operand" "")
             (compare:CC (match_operand:SI 1 "gen_reg_operand" "")
                         (match_operand:SI 2 "non_short_cint_operand" "")))
        (clobber (match_operand:SI 3 "gen_reg_operand" ""))]
       "find_single_use (operands[0], insn, 0)
        &amp;&amp; (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ
            || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)"
       [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))
        (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]
       "
     {
       /* <span class="roman">Get the constant we are comparing against, C, and see what it
          looks like sign-extended to 16 bits.  Then see what constant
          could be XOR'ed with C to get the sign-extended value.</span>  */
     
       int c = INTVAL (operands[2]);
       int sextc = (c &lt;&lt; 16) &gt;&gt; 16;
       int xorv = c ^ sextc;
     
       operands[4] = GEN_INT (xorv);
       operands[5] = GEN_INT (sextc);
     }")
</pre>
 <!-- To avoid confusion, don't write a single @code{define_split} that -->
<!-- accepts some insns that match some @code{define_insn} as well as some -->
<!-- insns that don't.  Instead, write two separate @code{define_split} -->
<!-- definitions, one for the insns that are valid and one for the insns that -->
<!-- are not valid. -->
<!-- The splitter is allowed to split jump instructions into sequence of -->
<!-- jumps or create new jumps in while splitting non-jump instructions.  As -->
<!-- the central flowgraph and branch prediction information needs to be updated, -->
<!-- several restriction apply. -->
<!-- Splitting of jump instruction into sequence that over by another jump -->
<!-- instruction is always valid, as compiler expect identical behavior of new -->
<!-- jump.  When new sequence contains multiple jump instructions or new labels, -->
<!-- more assistance is needed.  Splitter is required to create only unconditional -->
<!-- jumps, or simple conditional jump instructions.  Additionally it must attach a -->
<!-- @code{REG_BR_PROB} note to each conditional jump.  A global variable -->
<!-- @code{split_branch_probability} holds the probability of the original branch in case -->
<!-- it was a simple conditional jump, @minus{}1 otherwise.  To simplify -->
<!-- recomputing of edge frequencies, the new sequence is required to have only -->
<!-- forward jumps to the newly created labels. -->
 <p>为了避免混淆，不要写这样的<code>define_split</code>，
其接受匹配某个<code>define_insn</code>的一些insn，同时也接受不匹配的insn。替代的，
可以写两个分别的<code>define_split</code>定义，一个针对有效的insn，
一个针对无效的insn。

 <p>允许将跳转指令拆分为一个跳转序列或者在拆分非跳转指令时创建新的跳转。
由于控制流图和分支预测信息需要更新，所以会有一些限制。

 <p>将跳转指令拆分为由另一个跳转指令覆盖的指令序列，总是有效的，
因为编译器期望新的跳转具有相同的行为。当新的序列包含多个跳转指令或新的标号时，
则需要更多的辅助。只允许创建无条件跳转，或者简单的条件跳转指令。另外，
其必须为每个条件跳转附加一个<code>REG_BR_PROB</code>注解。
全局变量<code>split_branch_probability</code>保存了原始分支的可能性。
为了简化边频率的重新计算，新的序列要求只具有向前跳转。

<!-- @findex define_insn_and_split -->
<!-- For the common case where the pattern of a define_split exactly matches the -->
<!-- pattern of a define_insn, use @code{define_insn_and_split}.  It looks like -->
<!-- this: -->
 <p><a name="index-define_005finsn_005fand_005fsplit-3612"></a>对于通常的情况，define_split的模式完全匹配define_insn的模式，
则可以使用<code>define_insn_and_split</code>。其形式为：

<pre class="smallexample">     (define_insn_and_split
       [<var>insn-pattern</var>]
       "<var>condition</var>"
       "<var>output-template</var>"
       "<var>split-condition</var>"
       [<var>new-insn-pattern-1</var>
        <var>new-insn-pattern-2</var>
        ...]
       "<var>preparation-statements</var>"
       [<var>insn-attributes</var>])
     
</pre>
 <!-- @var{insn-pattern}, @var{condition}, @var{output-template}, and -->
<!-- @var{insn-attributes} are used as in @code{define_insn}.  The -->
<!-- @var{new-insn-pattern} vector and the @var{preparation-statements} are used as -->
<!-- in a @code{define_split}.  The @var{split-condition} is also used as in -->
<!-- @code{define_split}, with the additional behavior that if the condition starts -->
<!-- with @samp{&&}, the condition used for the split will be the constructed as a -->
<!-- logical ``and'' of the split condition with the insn condition.  For example, -->
<!-- from i386.md: -->
 <p><var>insn-pattern</var>, <var>condition</var>, <var>output-template</var>和
<var>insn-attributes</var>跟在<code>define_insn</code>中的用法一样. 
<var>new-insn-pattern</var>向量和<var>preparation-statements</var>跟在
<code>define_split</code>中的用法一样。
<var>split-condition</var>也跟在<code>define_split</code>中的用法一样,
不同之处是如果condition开始于&lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo;,
则用于拆分的条件将被构造为split condition和insn condition的逻辑“and”运算。
例如，在i386.md中:

<pre class="smallexample">     (define_insn_and_split "zero_extendhisi2_and"
       [(set (match_operand:SI 0 "register_operand" "=r")
          (zero_extend:SI (match_operand:HI 1 "register_operand" "0")))
        (clobber (reg:CC 17))]
       "TARGET_ZERO_EXTEND_WITH_AND &amp;&amp; !optimize_size"
       "#"
       "&amp;&amp; reload_completed"
       [(parallel [(set (match_dup 0)
                        (and:SI (match_dup 0) (const_int 65535)))
                   (clobber (reg:CC 17))])]
       ""
       [(set_attr "type" "alu1")])
     
</pre>
 <!-- In this case, the actual split condition will be -->
<!-- @samp{TARGET_ZERO_EXTEND_WITH_AND && !optimize_size && reload_completed}. -->
<!-- The @code{define_insn_and_split} construction provides exactly the same -->
<!-- functionality as two separate @code{define_insn} and @code{define_split} -->
<!-- patterns.  It exists for compactness, and as a maintenance tool to prevent -->
<!-- having to ensure the two patterns' templates match. -->
 <p>在这种情况下，实际的split condition将为&lsquo;<samp><span class="samp">TARGET_ZERO_EXTEND_WITH_AND &amp;&amp; !optimize_size &amp;&amp; reload_completed</span></samp>&rsquo;。

 <p><code>define_insn_and_split</code>结构提供了与两个单独的<code>define_insn</code>和<code>define_split</code>指令模式相同的功能. 其形式紧凑。

<!-- @end ifset -->
<!-- @ifset INTERNALS -->
<!-- @node Including Patterns -->
<!-- @section Including Patterns in Machine Descriptions. -->
<!-- @cindex insn includes -->
<!-- @findex include -->
<!-- The @code{include} pattern tells the compiler tools where to -->
<!-- look for patterns that are in files other than in the file -->
<!-- @file{.md}.  This is used only at build time and there is no preprocessing allowed. -->
<!-- It looks like: -->
 </body></html>

