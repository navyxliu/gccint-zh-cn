<html lang="zh">
<head>
<title>Special Accessors - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="Accessors.html#Accessors" title="Accessors">
<link rel="next" href="Flags.html#Flags" title="Flags">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
版权 (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 自由软件基金会

您可以依据自由软件基金会所发行的GNU自由文档授权1.3版本或者之后的任何版本，对本文档进行复制，分发和/或修改；其中不可变章节为"资助自由软件"，封面文字为 (a) (参见下面)，以及封底文字为 (b) (参见下面)。授权的副本要被包含在标题为"GNU自由文档授权"的章节中。

(a) FSF的封面文字为：

     GNU 手册

(b) FSF的封底文字为：

     您可以自由复制和修改本GNU手册，如同GNU软件。由自由软件基金会所发行的副本用于为GNU开发筹集资金。-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Special-Accessors"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Flags.html#Flags">Flags</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Accessors.html#Accessors">Accessors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr>
</div>

<h3 class="section">10.4 访问特殊操作数</h3>

<p><a name="index-access-to-special-operands-1726"></a>
<!-- Some RTL nodes have special annotations associated with them. -->
一些RTL节点具有与它们相关联的特殊的注解。

     <dl>
<dt><code>MEM</code><dd>
          
<a name="index-MEM_005fALIAS_005fSET-1727"></a>
<dl><dt><code>MEM_ALIAS_SET (</code><var>x</var><code>)</code><dd><!-- If 0, @var{x} is not in any alias set, and may alias anything.  Otherwise, -->
<!-- @var{x} can only alias @code{MEM}s in a conflicting alias set.  This value -->
<!-- is set in a language-dependent manner in the front-end, and should not be -->
<!-- altered in the back-end.  In some front-ends, these numbers may correspond -->
<!-- in some way to types, or other language-level entities, but they need not, -->
<!-- and the back-end makes no such assumptions. -->
<!-- These set numbers are tested with @code{alias_sets_conflict_p}. -->
如果为0，则<var>x</var>不在任何别名集中，并可能为任何对象的别名。否则，<var>x</var>只能为在冲突别名集中的<code>MEM</code>的别名。该值在前端使用语言相关的方式来设置，并且不能在后端修改。在一些前端中，这些可以通过某种方式对应到类型，或者其它语言级的实体，但是不要求非要这样，所以在后端不要做这样的假设。这些集合编号使用<code>alias_sets_conflict_p</code>来测试。

          <p><a name="index-MEM_005fEXPR-1728"></a><br><dt><code>MEM_EXPR (</code><var>x</var><code>)</code><dd><!-- If this register is known to hold the value of some user-level -->
<!-- declaration, this is that tree node.  It may also be a -->
<!-- @code{COMPONENT_REF}, in which case this is some field reference, -->
<!-- and @code{TREE_OPERAND (@var{x}, 0)} contains the declaration, -->
<!-- or another @code{COMPONENT_REF}, or null if there is no compile-time -->
<!-- object associated with the reference. -->
如果该寄存器被已知为存放了一些用户级的声明的值，则为那个tree节点。其也可以为<code>COMPONENT_REF</code>，这种情况下，其为某个域的引用，并且<code>TREE_OPERAND (</code><var>x</var><code>, 0)</code>包含了声明，或者另一个<code>COMPONENT_REF</code>，或者如果没有编译时对象相关引用，则为空。

          <p><a name="index-MEM_005fOFFSET_005fKNOWN_005fP-1729"></a><br><dt><code>MEM_OFFSET_KNOWN_P (</code><var>x</var><code>)</code><dd>True if the offset of the memory reference from <code>MEM_EXPR</code> is known. 
&lsquo;<samp><span class="samp">MEM_OFFSET (</span><var>x</var><span class="samp">)</span></samp>&rsquo; provides the offset if so.

          <p><a name="index-MEM_005fOFFSET-1730"></a><br><dt><code>MEM_OFFSET (</code><var>x</var><code>)</code><dd><!-- The offset from the start of @code{MEM_EXPR} as a @code{CONST_INT} rtx. -->
<!-- 从@code{MEM_EXPR}起始的偏移量，为一个@code{CONST_INT} rtx。 -->
The offset from the start of <code>MEM_EXPR</code>.  The value is only valid if
&lsquo;<samp><span class="samp">MEM_OFFSET_KNOWN_P (</span><var>x</var><span class="samp">)</span></samp>&rsquo; is true.

          <p><a name="index-MEM_005fSIZE-1731"></a><br><dt><code>MEM_SIZE (</code><var>x</var><code>)</code><dd><!-- The size in bytes of the memory reference. -->
<!-- This is mostly relevant for @code{BLKmode} references as otherwise -->
<!-- the size is implied by the mode.  The value is only valid if -->
<!-- @samp{MEM_SIZE_KNOWN_P (@var{x})} is true. -->
以字节为单位的内存引用长度。这主要与<code>BLKmode</code>引用相关，否则机器模式已经隐含了长度。
The value is only valid if <!-- @samp{MEM_SIZE_KNOWN_P (@var{x})} is true. -->

          <p><a name="index-MEM_005fALIGN-1732"></a><br><dt><code>MEM_ALIGN (</code><var>x</var><code>)</code><dd><!-- The known alignment in bits of the memory reference. -->
内存引用的已知的对齐方式，以位为单位。

          <p><a name="index-MEM_005fADDR_005fSPACE-1733"></a><br><dt><code>MEM_ADDR_SPACE (</code><var>x</var><code>)</code><dd>The address space of the memory reference.  This will commonly be zero
for the generic address space. 
</dl>

     <br><dt><code>REG</code><dd>
          
<a name="index-ORIGINAL_005fREGNO-1734"></a>
<dl><dt><code>ORIGINAL_REGNO (</code><var>x</var><code>)</code><dd><!-- This field holds the number the register ``originally'' had; for a -->
<!-- pseudo register turned into a hard reg this will hold the old pseudo -->
<!-- register number. -->
该域存放了寄存器原先具有的编号；对于伪寄存器放入到一个硬寄存器中，其将存放旧的伪寄存器编号。

          <p><a name="index-REG_005fEXPR-1735"></a><br><dt><code>REG_EXPR (</code><var>x</var><code>)</code><dd><!-- If this register is known to hold the value of some user-level -->
<!-- declaration, this is that tree node. -->
如果该寄存器被已知存放了某个用户级的声明的值，则其为那个tree节点。

          <p><a name="index-REG_005fOFFSET-1736"></a><br><dt><code>REG_OFFSET (</code><var>x</var><code>)</code><dd><!-- If this register is known to hold the value of some user-level -->
<!-- declaration, this is the offset into that logical storage. -->
如果该寄存器被已知存放了某个用户级的声明的值，则其为相对那个逻辑存储的便宜量。

     </dl>

     <br><dt><code>SYMBOL_REF</code><dd>
          
<a name="index-SYMBOL_005fREF_005fDECL-1737"></a>
<dl><dt><code>SYMBOL_REF_DECL (</code><var>x</var><code>)</code><dd><!-- If the @code{symbol_ref} @var{x} was created for a @code{VAR_DECL} or -->
<!-- a @code{FUNCTION_DECL}, that tree is recorded here.  If this value is -->
<!-- null, then @var{x} was created by back end code generation routines, -->
<!-- and there is no associated front end symbol table entry. -->
如果是针对<code>VAR_DECL</code>或<code>FUNCTION_DECL</code>创建的<code>symbol_ref</code> <var>x</var>，则那个tree被记录在这里。如果该值为空，则<var>x</var>由后端代码生成例程创建，并不与前端的符号表实体相关联。

          <!-- @code{SYMBOL_REF_DECL} may also point to a tree of class @code{'c'}, -->
          <!-- that is, some sort of constant.  In this case, the @code{symbol_ref} -->
          <!-- is an entry in the per-file constant pool; again, there is no associated -->
          <!-- front end symbol table entry. -->
          <p><code>SYMBOL_REF_DECL</code>也可以指向<code>'c'</code>类别的tree，即某种常量。这种情况下，<code>symbol_ref</code>为每个文件的常量池中的实体；同样，不与前端的符号表实体相关联。

          <p><a name="index-SYMBOL_005fREF_005fCONSTANT-1738"></a><br><dt><code>SYMBOL_REF_CONSTANT (</code><var>x</var><code>)</code><dd><!-- If @samp{CONSTANT_POOL_ADDRESS_P (@var{x})} is true, this is the constant -->
<!-- pool entry for @var{x}.  It is null otherwise. -->
如果&lsquo;<samp><span class="samp">CONSTANT_POOL_ADDRESS_P (</span><var>x</var><span class="samp">)</span></samp>&rsquo;为真，则为<var>x</var>的常量池实体。否则为空。

          <p><a name="index-SYMBOL_005fREF_005fDATA-1739"></a><br><dt><code>SYMBOL_REF_DATA (</code><var>x</var><code>)</code><dd><!-- A field of opaque type used to store @code{SYMBOL_REF_DECL} or -->
<!-- @code{SYMBOL_REF_CONSTANT}. -->
一个不透明类型的域，用来存储<code>SYMBOL_REF_DECL</code>或<code>SYMBOL_REF_CONSTANT</code>。

          <p><a name="index-SYMBOL_005fREF_005fFLAGS-1740"></a><br><dt><code>SYMBOL_REF_FLAGS (</code><var>x</var><code>)</code><dd><!-- In a @code{symbol_ref}, this is used to communicate various predicates -->
<!-- about the symbol.  Some of these are common enough to be computed by -->
<!-- common code, some are specific to the target.  The common bits are: -->
在一个<code>symbol_ref</code>中，其用于传达关于符号的各种断言。它们中的一些可以使用通用的代码来计算，一些是特定于目标机器的。通用的位：

               
<a name="index-SYMBOL_005fREF_005fFUNCTION_005fP-1741"></a>
<a name="index-SYMBOL_005fFLAG_005fFUNCTION-1742"></a>
<dl><dt><code>SYMBOL_FLAG_FUNCTION</code><dd><!-- Set if the symbol refers to a function. -->
用来表示符号引用一个函数。

               <p><a name="index-SYMBOL_005fREF_005fLOCAL_005fP-1743"></a><a name="index-SYMBOL_005fFLAG_005fLOCAL-1744"></a><br><dt><code>SYMBOL_FLAG_LOCAL</code><dd><!-- Set if the symbol is local to this ``module''. -->
<!-- See @code{TARGET_BINDS_LOCAL_P}. -->
用来表示符号局部于该模块。参见<code>TARGET_BINDS_LOCAL_P</code>。

               <p><a name="index-SYMBOL_005fREF_005fEXTERNAL_005fP-1745"></a><a name="index-SYMBOL_005fFLAG_005fEXTERNAL-1746"></a><br><dt><code>SYMBOL_FLAG_EXTERNAL</code><dd><!-- Set if this symbol is not defined in this translation unit. -->
<!-- Note that this is not the inverse of @code{SYMBOL_FLAG_LOCAL}. -->
用来表示该符号不在该转换单元中定义。注意，其并不是<code>SYMBOL_FLAG_LOCAL</code>的反转。

               <p><a name="index-SYMBOL_005fREF_005fSMALL_005fP-1747"></a><a name="index-SYMBOL_005fFLAG_005fSMALL-1748"></a><br><dt><code>SYMBOL_FLAG_SMALL</code><dd><!-- Set if the symbol is located in the small data section. -->
<!-- See @code{TARGET_IN_SMALL_DATA_P}. -->
用来表示符号位于小数据段。参见<code>TARGET_IN_SMALL_DATA_P</code>。

               <p><a name="index-SYMBOL_005fFLAG_005fTLS_005fSHIFT-1749"></a><a name="index-SYMBOL_005fREF_005fTLS_005fMODEL-1750"></a><br><dt><code>SYMBOL_REF_TLS_MODEL (</code><var>x</var><code>)</code><dd><!-- This is a multi-bit field accessor that returns the @code{tls_model} -->
<!-- to be used for a thread-local storage symbol.  It returns zero for -->
<!-- non-thread-local symbols. -->
这是多个位的域访问，其返回用于线程局部存储符号的<code>tls_model</code>。对于非线程局部符号，其返回0。

               <p><a name="index-SYMBOL_005fREF_005fHAS_005fBLOCK_005fINFO_005fP-1751"></a><a name="index-SYMBOL_005fFLAG_005fHAS_005fBLOCK_005fINFO-1752"></a><br><dt><code>SYMBOL_FLAG_HAS_BLOCK_INFO</code><dd><!-- Set if the symbol has @code{SYMBOL_REF_BLOCK} and -->
<!-- @code{SYMBOL_REF_BLOCK_OFFSET} fields. -->
用来表示符号具有<code>SYMBOL_REF_BLOCK</code>和<code>SYMBOL_REF_BLOCK_OFFSET</code>域。

               <p><a name="index-SYMBOL_005fREF_005fANCHOR_005fP-1753"></a><a name="index-SYMBOL_005fFLAG_005fANCHOR-1754"></a><a name="index-g_t_0040option_007b_002dfsection_002danchors_007d-1755"></a><br><dt><code>SYMBOL_FLAG_ANCHOR</code><dd><!-- Set if the symbol is used as a section anchor.  ``Section anchors'' -->
<!-- are symbols that have a known position within an @code{object_block} -->
<!-- and that can be used to access nearby members of that block. -->
<!-- They are used to implement @option{-fsection-anchors}. -->
用来表示符号作为section anchor。&ldquo;Section anchors&rdquo;为在<code>object_block</code>中具有一个已知位置的符号，并且可以用来访问该块中的附近成员。它们用来实现<samp><span class="option">-fsection-anchors</span></samp>。

               <!-- If this flag is set, then @code{SYMBOL_FLAG_HAS_BLOCK_INFO} will be too. -->
               <p>如果该标记被设置，则<code>SYMBOL_FLAG_HAS_BLOCK_INFO</code>也被设置。

          </dl>

          <!-- Bits beginning with @code{SYMBOL_FLAG_MACH_DEP} are available for -->
          <!-- the target's use. -->
          <p>起始于<code>SYMBOL_FLAG_MACH_DEP</code>的位，可供目标机器使用。
</dl>

     <p><a name="index-SYMBOL_005fREF_005fBLOCK-1756"></a><br><dt><code>SYMBOL_REF_BLOCK (</code><var>x</var><code>)</code><dd><!-- If @samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}, this is the -->
<!-- @samp{object_block} structure to which the symbol belongs, -->
<!-- or @code{NULL} if it has not been assigned a block. -->
如果&lsquo;<samp><span class="samp">SYMBOL_REF_HAS_BLOCK_INFO_P (</span><var>x</var><span class="samp">)</span></samp>&rsquo;，则其为该符号所属的&lsquo;<samp><span class="samp">object_block</span></samp>&rsquo;结构体， 或者如果其没有被分配给一个块，则为<code>NULL</code>。

     <p><a name="index-SYMBOL_005fREF_005fBLOCK_005fOFFSET-1757"></a><br><dt><code>SYMBOL_REF_BLOCK_OFFSET (</code><var>x</var><code>)</code><dd><!-- If @samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})}, this is the offset of @var{x} -->
<!-- from the first object in @samp{SYMBOL_REF_BLOCK (@var{x})}.  The value is -->
<!-- negative if @var{x} has not yet been assigned to a block, or it has not -->
<!-- been given an offset within that block. -->
如果&lsquo;<samp><span class="samp">SYMBOL_REF_HAS_BLOCK_INFO_P (</span><var>x</var><span class="samp">)</span></samp>&rsquo;，则其为<var>x</var>的偏移量，从&lsquo;<samp><span class="samp">SYMBOL_REF_BLOCK (</span><var>x</var><span class="samp">)</span></samp>&rsquo;中的第一个对象开始。如果<var>x</var>还没有被分配给一个块，或者其还没有在那个块中给定一个偏移量，则值为负数。

 </dl>

<!-- @node Flags -->
<!-- @section Flags in an RTL Expression -->
 </body></html>

